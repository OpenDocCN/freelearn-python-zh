- en: Chapter 5. A Spymaster's More Sensitive Analyses
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。间谍大师的更敏感分析
- en: Most of our previous espionage missions focused on bulk data collection and
    processing. HQ doesn't always want details. Sometimes it needs summaries and assessments.
    This means calculating central tendencies, summaries, trends, and correlations,
    which means we need to write more sophisticated algorithms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的间谍任务大多集中在大量数据收集和处理上。HQ 并不总是需要细节。有时它需要摘要和评估。这意味着计算集中趋势、摘要、趋势和相关性，这意味着我们需要编写更复杂的算法。
- en: We will skirt the borders of some very heavy-duty statistical algorithms. Once
    we cross the frontier, we will need more powerful tools. For additional tools
    to support sophisticated numeric processing, check [http://www.numpy.org](http://www.numpy.org).
    For some analyses, we may be more successful using the SciPy package ([http://www.scipy.org](http://www.scipy.org)).
    A good book to refer is *Learning SciPy for Numerical and Scientific Computing*,
    *Francisco J. Blanco-Silva*, *Packt Publishing* ([http://www.packtpub.com/learning-scipy-for-numerical-and-scientific-computing/book](http://www.packtpub.com/learning-scipy-for-numerical-and-scientific-computing/book)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绕过一些非常强大的统计算法的边界。一旦我们越过这个前沿，我们就需要更强大的工具。为了支持复杂的数值处理，请检查[http://www.numpy.org](http://www.numpy.org)。对于某些分析，我们可能更成功地使用
    SciPy 包（[http://www.scipy.org](http://www.scipy.org)）。一本好的参考书是 *Learning SciPy
    for Numerical and Scientific Computing*，作者 *Francisco J. Blanco-Silva*，出版社 *Packt
    Publishing*（[http://www.packtpub.com/learning-scipy-for-numerical-and-scientific-computing/book](http://www.packtpub.com/learning-scipy-for-numerical-and-scientific-computing/book)）。
- en: Another direction we could be pulled in includes the analysis of natural language
    documents. Reports, speeches, books, and articles are sometimes as important as
    basic facts and figures. If we want to work with words and language, we need to
    use the **Natural Language Toolkit** (**NLTK**). More information on this can
    be found at [http://www.nltk.org](http://www.nltk.org).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会被拉入的另一个方向包括自然语言文档的分析。报告、演讲、书籍和文章有时与基本的事实和数字一样重要。如果我们想处理文字和语言，我们需要使用**自然语言工具包**（**NLTK**）。更多信息可以在[http://www.nltk.org](http://www.nltk.org)找到。
- en: 'In this chapter, we''ll look at several more advanced topics that secret agents
    need to master, such as:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个更高级的主题，特工需要掌握，例如：
- en: Computing *central tendency*—mean, median, and mode—of the data we've gathered.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算我们所收集数据的*集中趋势*——平均值、中位数和众数。
- en: Interrogating CSV files to extract information.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 询问 CSV 文件以提取信息。
- en: More tips and techniques to use Python generator functions.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多使用 Python 生成器函数的技巧和技术。
- en: Designing higher-level constructs such as Python modules, libraries, and applications.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计高级结构，如 Python 模块、库和应用。
- en: A quick introduction to class definitions.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义的快速介绍。
- en: Computations of standard deviation, standardized scores, and the coefficient
    of correlation. This kind of analysis adds value to intelligence assets. Any secret
    agent can ferret out the raw data. It takes real skill to provide useful summaries.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算标准差、标准化分数和相关性系数。这种分析为情报资产增加了价值。任何秘密特工都可以挖掘出原始数据。提供有用的摘要需要真正的技能。
- en: How to use doctest to assure that these more sophisticated algorithms really
    work. Presence of a software bug raises serious questions about the overall quality
    of the data being reported.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 doctest 确保这些更复杂的算法真正有效。软件错误的产生会对报告数据的整体质量提出严重质疑。
- en: Being a secret agent isn't all car chases and confusing cocktail recipes in
    posh restaurants. *Shaken? Stirred? Who can remember?*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 成为特工并不全是汽车追逐和豪华餐厅里令人困惑的鸡尾酒配方。*摇匀还是搅拌？谁能记得？*
- en: Sometimes, we need to tackle some rather complex analysis questions that HQ
    has assigned us. How can we work with per capita cheese consumption, accidental
    suffocation and strangulation in bed, and the number of doctorates in civil engineering?
    What Python components should we apply to this problem?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要处理一些相当复杂的问题，这些问题是 HQ 分配给我们的。我们如何处理人均奶酪消费、床上意外窒息和勒死，以及土木工程博士学位的数量？我们应该应用哪些
    Python 组件来解决这个问题？
- en: Creating statistical summaries
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建统计摘要。
- en: 'One essential kind of statistical summary is the *measure of central tendency*.
    There are several variations on this theme; mean, mode, and median, which are
    explained as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一种基本的统计摘要类型是*集中趋势的度量*。这个主题有几个变体；平均值、众数和中位数，如下所述：
- en: The mean, also known as the average, combines all of the values into a single
    value
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均值，也称为平均值，将所有值组合成一个单一值。
- en: The median is the middlemost value—the data must be sorted to locate the one
    in the middle
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中位数是中间值——数据必须排序以找到中间的值
- en: The mode is the most common value
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 众数是最常见的值
- en: None of these is perfect to describe a set of data. Data that is truly random
    can often be summarized by the mean. Data that isn't random, however, can be better
    summarized by the median. With continuous data, each value might differ slightly
    from another. Every measurement in a small set of samples may be unique, making
    a mode meaningless.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不完美地描述了一组数据。真正随机的数据通常可以通过平均值来概括。然而，非随机数据可以通过中位数更好地概括。对于连续数据，每个值可能与其他值略有不同。在一个小样本集中，每个测量值可能都是唯一的，这使得众数变得没有意义。
- en: As a consequence, we'll need algorithms to compute all three of these essential
    summaries. First, we need some data to work with.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要算法来计算这三个基本摘要的所有内容。首先，我们需要一些数据来处理。
- en: In [Chapter 2](ch02.html "Chapter 2. Acquiring Intelligence Data"), *Acquiring
    Intelligence Data*, HQ asked us to gather cheese consumption data. We used the
    URL [http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls](http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。获取情报数据")中，*获取情报数据*，HQ要求我们收集奶酪消费数据。我们使用了URL [http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls](http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls)。
- en: 'Sadly, the data was in a format that we can''t easily automate, forcing us
    to copy and paste the annual cheese consumption data. This is what we got. Hopefully,
    there aren''t many errors introduced by copying and pasting. The following is
    the data that we gathered:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，数据格式我们无法轻易自动化，迫使我们复制粘贴年度奶酪消费数据。这就是我们得到的结果。希望复制粘贴过程中引入的错误不多。以下是我们收集到的数据：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will serve as a handy dataset that we can use.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为一个方便的数据集，我们可以使用。
- en: Note that we can type this on multiple lines at the `>>>` prompt. Python needs
    to see a matching pair of `[` and `]` to consider the statement complete. The
    matching `[]` rule allows the users to enter long statements comfortably.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以在`>>>`提示符下多行输入这些内容。Python需要看到匹配的`[`和`]`对，才会认为语句已完整。匹配的`[]`规则允许用户舒适地输入长语句。
- en: Parsing the raw data file
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析原始数据文件
- en: We've been given the cause of death using ICD code W75 as *accidental suffocation
    and strangulation in bed*. It's not perfectly clear what HQ thinks this data means.
    However, it has somehow become important. We went to the [http://wonder.cdc.gov](http://wonder.cdc.gov)
    website to get the summary of cause of death by year.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被提供了使用ICD代码W75表示的死亡原因，即*床上意外窒息和勒颈*。然而，HQ对此数据的含义并不完全清楚。然而，它已经变得很重要。我们访问了[http://wonder.cdc.gov](http://wonder.cdc.gov)网站，以获取按年份汇总的死亡原因摘要。
- en: 'We wound up with a file that starts out like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到了一个以如下方式开始的文件：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a bit painful to process. It's almost—but not quite—in CSV notation.
    It's true that there aren't many commas, but there are tab characters encoded
    as `\t` in Python. These characters are sufficient to make a CSV file, where the
    tab takes the role of a comma.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个文件有点痛苦。它几乎——但并不完全——符合CSV格式。确实，逗号不多，但在Python中，这些逗号被编码为`\t`。这些字符足以构成一个CSV文件，其中制表符扮演了逗号的角色。
- en: 'We can read this file using Python''s `csv` module with a `\t` delimiter:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python的`csv`模块和`\t`分隔符来读取这个文件：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This snippet will create a `csv.DictReader` object using the `\t` delimiter
    instead of the default value of `,`. Once we have a reader that uses `\t` characters,
    we can iterate through the rows in the document. Each row will appear as a dictionary.
    The column title, found in the first row, will be the key for the items in the
    dictionary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将创建一个使用`\t`分隔符的`csv.DictReader`对象，而不是默认的`,`分隔符。一旦我们有了使用`\t`字符的读取器，我们就可以遍历文档中的行。每一行将显示为一个字典。第一行中找到的列标题将是字典中项的键。
- en: We used the expression `row['Notes']` to get the value from the `Notes` column
    of each row. If the notes are equal to `---`, this is the beginning of the footnotes
    for the data. What follows is a great deal of metadata.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`row['Notes']`表达式从每一行的`Notes`列获取值。如果注释等于`---`，这是数据的脚注的开始。接下来是大量的元数据。
- en: 'The resulting dataset can be summarized easily. First, we''ll create a generator
    function to parse our data:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据集可以很容易地概括。首先，我们将创建一个生成器函数来解析我们的数据：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We replaced the `print()` function with the `yield` statement. We also replaced
    `---` with `Total` to prune the totals off the data. We can compute our own totals.
    Finally, we converted the year and deaths to integer values so that we can calculate
    with them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`yield`语句替换了`print()`函数。我们还用`Total`替换了`---`来从数据中剪除总计。我们可以自己计算总计。最后，我们将年份和死亡人数转换为整数值，以便我们可以对它们进行计算。
- en: This function will iterate through the various rows of data producing two-tuples
    of the year and the number of deaths.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将遍历数据的不同行，产生包含年份和死亡人数的两个元组。
- en: 'Once we have this generator function, we can collect the summary like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个生成器函数，我们就可以这样收集摘要：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We get this as a result:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果如下：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This seems to be the data they're looking for. It gives us more data to work
    with.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎就是他们正在寻找的数据。它为我们提供了更多的工作数据。
- en: Finding an average value
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找平均值
- en: The mean is defined using a daunting formula which looks like ![Finding an average
    value](img/0420OS_05_01.jpg). While the formula looks complex, the various parts
    are first-class built-in functions of Python.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 均值是通过一个看起来令人畏惧的公式定义的，它看起来像![寻找平均值](img/0420OS_05_01.jpg)。虽然公式看起来很复杂，但它的各个部分都是Python的一流内置函数。
- en: The big sigma ![Finding an average value](img/0420OS_05_03.jpg) is math-speak
    for the Python `sum()` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大写的西格玛![寻找平均值](img/0420OS_05_03.jpg)是数学上对Python `sum()`函数的表述。
- en: 'Given a list of values, the mean is this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个值列表，均值是这样的：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our two sets of data are provided as two-tuples with year and amount. We need
    to reel in the years, stowing away the time for later use. We can use a simple
    generator function for this. We can use the expression `cheese for year, cheese
    in year_cheese` to separate the cheese portion of each two-tuple.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供两组数据作为包含年份和金额的两个元组。我们需要收集年份，将时间保留以供以后使用。我们可以使用一个简单的生成器函数来完成这个任务。我们可以使用表达式`cheese
    for year, cheese in year_cheese`来分离每个两个元组中的奶酪部分。
- en: 'Here''s what happens when we use a generator with our `mean()` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用生成器与我们的`mean()`函数一起使用时，会发生以下情况：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Wait. What?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。什么？
- en: How can the simple generator not work?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的生成器怎么可能不起作用呢？
- en: Actually, it does work. It just doesn't do what we assume.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它确实有效。但它并没有做我们假设的事情。
- en: Understanding generator expressions
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解生成器表达式
- en: 'There are three important rules that apply to Python generators:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个重要的规则适用于Python生成器：
- en: Many—but not all—functions will work with generator objects. Some functions,
    however, will not work well with generators; they require a sequence object.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多（但不全是）函数可以与生成器对象一起工作。然而，有些函数与生成器不太兼容；它们需要一个序列对象。
- en: The objects yielded by a generator aren't created until absolutely necessary.
    We can describe a generator as being lazy. A list, for example, actually contains
    objects. A generator expression can operate similarly to a list, but the objects
    aren't really created until needed.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器产生的对象只有在绝对必要时才会创建。我们可以将生成器描述为“懒惰”。例如，列表实际上包含对象。生成器表达式可以像列表一样操作，但对象实际上只有在需要时才会创建。
- en: Generator functions can only be used once. A list can be reused indefinitely.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数只能使用一次。列表可以无限期地重复使用。
- en: The first restriction applies in particular to the `len()` function. This function
    works for lists, tuples, and sets. However, it doesn't work for generators. There's
    no way to know how many items will eventually be created by a generator, so `len()`
    can't return the size.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个限制特别适用于`len()`函数。这个函数适用于列表、元组和集合。然而，它不适用于生成器。我们无法知道生成器最终将创建多少项，因此`len()`无法返回大小。
- en: The second restriction is mostly relevant when we try to print the results of
    a generator. We'll see something such as `<generator object <genexpr> at 0x1007b4460>`,
    until we actually evaluate the generator and create the objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个限制主要在尝试打印生成器的结果时相关。我们会看到类似`<generator object <genexpr> at 0x1007b4460>`这样的内容，直到我们实际评估生成器并创建对象。
- en: 'The third restriction is less obvious. We will to need an example. Let''s try
    to work around the `len()` problem by defining a `count()` function that counts
    items yielded by a generator function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个限制不太明显。我们需要一个例子。让我们尝试通过定义一个`count()`函数来绕过`len()`问题，该函数计算生成器函数产生的项数：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will add up a sequence of 1s instead of the sequence of actual values.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将累加一系列1，而不是实际值序列。
- en: 'We can test it like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样测试它：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This seems to work, right? Based on this one experiment, we can try to rewrite
    the `mean()` function like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎没问题，对吧？基于这个实验，我们可以尝试像这样重写`mean()`函数：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We used `count()`, which works with a generator expression, instead of `len()`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`count()`，它与生成器表达式一起工作，而不是`len()`。
- en: 'When we use it, we get a `ZeroDivisionError: float division by zero` error.
    Why didn''t `count()` work in the context of `mean()`?'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们使用它时，我们会得到一个`ZeroDivisionError: float division by zero`错误。为什么`count()`在`mean()`的上下文中不起作用？'
- en: This reveals the one-use-only rule. The `sum()` function consumed the generator
    expression. When the time to evaluate the `count()` function came, there was no
    data left. The generator was empty, `sum( 1 for x in [] )` was zero.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了单次使用规则。`sum()`函数消耗了生成器表达式。当`count()`函数需要评估时，没有数据了。生成器为空，`sum( 1 for x in
    [] )`为零。
- en: What can we do?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做什么？
- en: 'We have three choices, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个选择，如下所示：
- en: We can write our own more sophisticated `sum()` that produces both sum and count
    from one pass through the generator.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写自己的更复杂的`sum()`，它从生成器的一次遍历中产生总和和计数。
- en: Alternatively, we can use the `itertools` library to put a *tee* fitting into
    the generator pipeline so that we have two copies of the iterable. This is actually
    a very efficient solution, but it's also a bit advanced for field agents.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`itertools`库将一个*tee*适配器放入生成器管道中，这样我们就有两个可迭代的副本。这实际上是一个非常高效的解决方案，但对于现场特工来说，这有点高级。
- en: More simply, we can create an actual list object from the generator. We can
    use the `list()` function or wrap the generator expression in `[]`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简单地说，我们可以从生成器创建一个实际的列表对象。我们可以使用`list()`函数或用`[]`包裹生成器表达式。
- en: 'The first two choices are too complex for our purposes. The third is really
    simple. We can use this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个选择对于我们来说太复杂了。第三个选择非常简单。我们可以这样做：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By including `[]`, we created a list object from the generator. We can get both
    `sum()` and `len()` from the list object. This approach works very nicely.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含`[]`，我们从一个生成器创建了一个列表对象。我们可以从列表对象中获取`sum()`和`len()`。这种方法非常好用。
- en: 'It points out the importance of writing docstrings in our functions. We really
    need to do this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它指出了编写函数文档字符串的重要性。我们真的需要这样做：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We put a reminder here that the function works with an object that is a sequence,
    but it doesn't work with a generator expression or other objects that are merely
    iterable. When we use `help(mean)`, we'll see the reminder we left in the docstring.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提醒一下，该函数与一个序列对象一起工作，但它不与生成器表达式或其他仅可迭代的对象一起工作。当我们使用`help(mean)`时，我们会看到我们在文档字符串中留下的提醒。
- en: There's a hierarchy of concepts here. Being iterable is a very general feature
    of many kinds of Python objects. A sequence is one of many kinds of iterable Python
    objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个概念层次。可迭代性是许多Python对象的一个非常通用的特性。序列是许多可迭代Python对象中的一种。
- en: Finding the value in the middle
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找中间的值
- en: The median value is in the middle of a sorted collection of values. In order
    to find the median, we need to sort the data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数是在一组排序后的值中间的值。为了找到中位数，我们需要对数据进行排序。
- en: 'Here''s an easy function to compute the median of a sequence:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算序列中位数的简单函数：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This includes the common technique of averaging the two middlemost values when
    there's an even number of samples.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括当样本数量为偶数时，平均两个中间值的常用技术。
- en: We used `len(s)%2` to determine if the sequence length is odd. In two separate
    places, we compute `len(s)//2`; seems like we might be able to simplify things
    using the `divmod()` function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`len(s)%2`来确定序列长度是否为奇数。在两个不同的地方，我们计算`len(s)//2`；看起来我们可能能够使用`divmod()`函数简化一些事情。
- en: 'We can use this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This change removes a little bit of the duplicated code that computes `len(s)//2`,
    but is it really more clear?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改移除了一点点重复计算`len(s)//2`的代码，但这真的更清晰吗？
- en: 'Two potential issues here are the overheads associated with sorting:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个潜在问题与排序相关的开销：
- en: First, sorting means a lot of comparisons between items. As the size of the
    list grows, the number of items compared grows more quickly. Also, the `sorted()`
    function produces a copy of the sequence, potentially wasting memory when processing
    a very large list.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，排序意味着有很多项目之间的比较。随着列表大小的增加，比较的项目数量增长得更快。此外，`sorted()`函数会产生序列的副本，在处理非常大的列表时可能会浪费内存。
- en: The alternative is a clever variation on the quickselect algorithm. For field
    agents, this level of sophistication isn't necessary. More information is available
    at [http://en.wikipedia.org/wiki/Quickselect](http://en.wikipedia.org/wiki/Quickselect).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代方案是对快速选择算法的一种巧妙变体。对于现场特工来说，这种复杂程度是不必要的。更多信息请参阅[http://en.wikipedia.org/wiki/Quickselect](http://en.wikipedia.org/wiki/Quickselect)。
- en: Finding the most popular value
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找最流行的值
- en: The modal value is the single most popular value in the collection. We can compute
    this using the `Counter` class in the `collections` module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模式值是集合中最受欢迎的单个值。我们可以使用 `collections` 模块中的 `Counter` 类来计算这个值。
- en: 'Here''s a `mode` function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个 `mode` 函数：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `most_common()` method of a `Counter` class returns a sequence of two-tuples.
    Each tuple has the value and the number of times it occurred. For our purposes,
    we only wanted the value, so we had to take the first element from the sequence
    of two-tuples. Then, we had to break the pair down into the value and the counter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 类的 `most_common()` 方法返回一个包含两个元素的元组序列。每个元组包含一个值和该值出现的次数。就我们的目的而言，我们只需要值，因此我们必须从两个元素的元组序列中取出第一个元素。然后，我们必须将这对值和计数器分开。'
- en: 'The problem with a demonstration is that our datasets are really small and
    don''t have a proper mode. Here''s a contrived example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 演示的问题在于我们的数据集非常小，没有合适的模式。这里有一个人为的例子：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This demonstrates that the `mode` function works, even though it doesn't make
    sense for our cheese consumption and death rate data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了 `mode` 函数是有效的，尽管它对我们奶酪消耗和死亡率数据来说没有意义。
- en: Creating Python modules and applications
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Python 模块和应用程序
- en: We relied heavily on modules in the Python library. Additionally, we added several
    packages, including Pillow and BeautifulSoup. The question should arise, *can
    we create our own module?*
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Python 库中大量使用了模块。此外，我们还添加了几个包，包括 Pillow 和 BeautifulSoup。应该出现这样的问题，*我们能否创建自己的模块？*
- en: 'The answer is, of course, *yes*. A Python module is simply a file. It turns
    out that each example script has been a module. We can look a little more deeply
    at how we can make our own modules of reusable programming. When we look at Python
    programs, we observe three kinds of files:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 答案当然是 *是的*。Python 模块只是一个文件。结果证明，每个示例脚本都是一个模块。我们可以更深入地了解如何创建我们自己的可重用编程模块。当我们查看
    Python 程序时，我们会观察到三种类型的文件：
- en: Library modules that are purely definitional
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯定义性的库模块
- en: Application modules that do the real work of our applications
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行我们应用程序实际工作的应用程序模块
- en: Hybrid modules that are both applications and can be used as libraries
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时是应用程序和可以作为库使用的混合模块
- en: The essential ingredient of creating a Python module is separating the *real
    work* of the top-level script from the various definitions that support this real
    work. All our examples of definitions have been functions created with the `def`
    statement. The other import examples of definitions are `class` definitions, which
    we'll discuss in the following sections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Python 模块的基本要素是将顶层脚本的 *实际工作* 与支持这一实际工作的各种定义分开。我们所有的定义示例都是使用 `def` 语句创建的函数。其他导入定义的例子是
    `class` 定义，我们将在下一节中讨论。
- en: Creating and using a module
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用模块
- en: To create a module of only definitions, we simply put all the function and class
    definitions into a file. We have to give the file a name that is an acceptable
    Python variable name. This means that filenames should look like Python variables;
    letters, digits, and `_` are perfectly legal. Characters that Python uses as an
    operator (`+`, `-`, `/`, and so on) may be allowed by our OS for a filename, but
    these characters cannot be used to name a module file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建仅包含定义的模块，我们只需将所有函数和类定义放入一个文件中。我们必须给文件一个可接受的 Python 变量名。这意味着文件名应该看起来像 Python
    变量；字母、数字和 `_` 是完全合法的。Python 使用的运算符字符（`+`、`-`、`/` 等）可能由我们的操作系统允许作为文件名，但这些字符不能用于命名模块文件。
- en: The file name must end in `.py`. This is not part of the module name; it's for
    the benefit of the operating system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名必须以 `.py` 结尾。这不是模块名称的一部分；这是为了操作系统的便利。
- en: We might collect our statistics functions into a file named `stats.py`. This
    file defines a module named `stats`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会将我们的统计函数收集到一个名为 `stats.py` 的文件中。此文件定义了一个名为 `stats` 的模块。
- en: 'We can import the entire suite of functions or individual functions, or we
    can import the module as a whole. Use the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以导入整个函数集或单个函数，或者我们可以将整个模块导入。使用以下代码：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By using this, we import all the functions (and classes) defined in the stats
    module. We can simply use names such as `mean( some_list )`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们导入了在 `stats` 模块中定义的所有函数（和类）。我们可以简单地使用如 `mean( some_list )` 这样的名称。
- en: 'Consider we use this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们使用这个：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We imported two specific functions from the stats module. We ignored any other
    definition that might be available in that module.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `stats` 模块中导入了两个特定的函数。我们忽略了该模块中可能存在的任何其他定义。
- en: 'We can also use this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下方法：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will import the module, but it won't put any of the names into the global
    namespace that we usually work with. All the names in the `stats` module must
    be accessed with a qualified name, such as `stats.mean( some_list )`. In very
    complex scripts, the use of qualified names helps clarify where a particular function
    or class was defined.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入模块，但不会将任何名称放入我们通常使用的全局命名空间中。`stats`模块中的所有名称都必须使用限定名称访问，例如`stats.mean( some_list
    )`。在非常复杂的脚本中，使用限定名称有助于澄清特定函数或类是在哪里定义的。
- en: Creating an application module
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序模块
- en: 'The simplest way to create an application with a **command-line interface**
    (**CLI**) is to write a file and run it from the command line. Consider the following
    example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有**命令行界面**（CLI）的应用程序的最简单方法是编写一个文件，并在命令行中运行它。考虑以下示例：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we enter this in the terminal window or command window, we use the OS `python3`
    command and provide a filename. In Windows, the name `python.exe` is sometimes
    used for Python 3, so the command may be `python basic_stats.py`. In most other
    OSes, there will often be both the `python3` and `python3.3` commands. On Mac
    OS X, the `python` command may refer to the old `Python2.7` that is part of Mac
    OS X.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在终端窗口或命令窗口中输入时，我们使用OS的`python3`命令并提供一个文件名。在Windows中，`python.exe`有时用于Python
    3，因此命令可能是`python basic_stats.py`。在大多数其他操作系统上，通常会有`python3`和`python3.3`命令。在Mac
    OS X上，`python`命令可能指的是Mac OS X的一部分的旧`Python2.7`。
- en: We can determine the difference by using the `python -V` command to see what
    version is bound to the name `python`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`python -V`命令来确定与名称`python`绑定的版本。
- en: 'As noted previously, we want to separate our definitions into one file, and
    then put the real work in another file. When we look inside `basic_stats.py`,
    we might find this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望将定义分开到文件中，然后将实际工作放在另一个文件中。当我们查看`basic_stats.py`内部时，我们可能会发现以下内容：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The file starts with a triple-quoted string that—like the docstring for a function—is
    the docstring for a module. We imported some functions from another module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文件以一个三引号字符串开头，就像函数的docstring一样，这是模块的docstring。我们从另一个模块导入了某些函数。
- en: Then, we completed some processing using the functions that we imported. This
    is a common structure for a simple command-line module.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用导入的函数完成了一些处理。这是简单命令行模块的常见结构。
- en: We can also run this via the command `python3 -m basic_stats`. This will use
    Python's internal search path to locate the module, and then run that module.
    Running a module is subtly different from running a file, but the net effect is
    the same; the file produces the output we designed via the `print()` statements.
    For details on how the `-m` option works, consult the documentation for the `runpy`
    module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过命令`python3 -m basic_stats`运行此操作。这将使用Python的内部搜索路径来定位模块，然后运行该模块。运行模块与运行文件略有不同，但最终效果相同；文件通过`print()`语句产生我们设计的输出。有关`-m`选项如何工作的详细信息，请参阅`runpy`模块的文档。
- en: Creating a hybrid module
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建混合模块
- en: 'There are two significant improvements we can make to the `basic_stats.py`
    module shown previously:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前显示的`basic_stats.py`模块，我们可以进行两个重要的改进：
- en: First, we put all the processing into a function definition. We call it `analyze_cheese_deaths`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将所有处理放入一个函数定义中。我们称它为`analyze_cheese_deaths`。
- en: The second is the addition of an `if` statement to determine the context in
    which the module is being used.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是添加一个`if`语句来确定模块被使用的上下文。
- en: 'Here''s the more sophisticated version of `basic_stats.py`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`basic_stats.py`的更复杂版本：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating a function definition to encapsulate the real work gives us a way to
    extend or reuse this script. We can reuse a function definition (via `import`)
    more easily than we can reuse a top-level script.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个函数定义来封装实际工作，这为我们提供了扩展或重用此脚本的方法。我们可以比重用顶级脚本更容易地重用函数定义（通过`import`）。
- en: The `__name__` variable is a global that Python sets to show the processing
    context. The top-level module—the one named on the command line—has the `__name__`
    variable set to `__main__`. All other module imports have the `__name__` variable
    set to the module name.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`__name__`变量是一个Python设置的全球变量，用于显示处理上下文。顶级模块——在命令行上命名的模块——的`__name__`变量设置为`__main__`。所有其他模块导入的`__name__`变量都设置为模块名称。'
- en: Yes, the global variable, `__name__`, has double-underscores before and after.
    This marks it as part of the machinery of Python. Similarly, the string value
    for the main module name, `__main__`, involves double underscores.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，全局变量`__name__`前后都有双下划线。这标志着它是Python机制的一部分。同样，主模块名称的字符串值`__main__`也涉及双下划线。
- en: This technique allows us to create a module that can be run as a command and
    also be imported to provide definitions. The idea is to promote reusable programming.
    Each time we set out to solve a problem, we don't need to reinvent the wheel and
    other related technology. We should import prior work and build on that.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术允许我们创建一个可以作为命令运行并导入以提供定义的模块。想法是促进可重用编程。每次我们着手解决问题时，我们不需要重新发明轮子和其他相关技术。我们应该导入先前的工作并在此基础上构建。
- en: Creating our own classes of objects
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的对象类
- en: The two lists of data values that HQ asked us to get—cheese consumption and
    W75 deaths—form two objects that are very similar. They seem to be two instances
    of the same class of things.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: HQ要求我们获取的两个数据值列表——奶酪消费和W75死亡人数——形成了两个非常相似的对象。它们似乎是同一类事物的两个实例。
- en: In this case, the class of things seems to have *annual statistics*. They're
    collections with a consistent structure of a year and a measurement. Both these
    annual statistics objects have a common set of operations. Indeed, the operations
    are pretty tightly bound to the measurement, and they are not at all bound to
    the year number.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，事物类似乎具有*年度统计*。它们是具有年份和测量的一致结构的集合。这两个年度统计对象都有一个共同的运算集。实际上，这些运算与测量紧密相关，并且与年份数字完全没有关系。
- en: Our collection of statistical functions is not very tightly bound to our data
    at all.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的统计函数集合与我们的数据几乎没有紧密的联系。
- en: We can improve the binding between data structure and processing through a class
    definition. If we define the general features of a class of objects that we can
    call *annual statistics*, we can create two instances of this class and use the
    defined methods on the unique data of each instance. We can easily reuse our method
    functions by having multiple objects of the same class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过类定义来提高数据结构和处理之间的绑定。如果我们定义了一个可以称为“年度统计”的对象类的通用特征，我们可以创建这个类的两个实例，并使用定义的方法处理每个实例的独特数据。我们可以通过拥有多个同一类的对象来轻松重用我们的方法函数。
- en: A class definition in Python is a collection of method functions. Each method
    function definition has an additional parameter variable, usually named `self`,
    which must be the first parameter to each function. The self variable is how we
    can access the attribute values that are unique to each instance of the class
    of objects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的类定义是一系列方法函数的集合。每个方法函数定义都有一个额外的参数变量，通常命名为`self`，它必须是每个函数的第一个参数。`self`变量是我们访问对象类每个实例的独特属性值的方式。
- en: 'Here''s how we might define a class for the simple statistics HQ is asking
    us to get:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可能定义一个用于获取HQ要求的简单统计的类的示例：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `class` statement provides a name for our definition. Within the indented
    body of the class statement, we provide `def` statements for each method function
    within this class. Each `def` statement contains the instance variable, `self`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`语句为我们定义提供了一个名称。在类语句缩进的主体中，我们为这个类中的每个方法函数提供`def`语句。每个`def`语句都包含实例变量`self`。'
- en: 'We''ve defined two methods with special names, as shown in the following list.
    These names have double underscores, they''re fixed by Python, and we must use
    exactly these names in order to have objects initialized or printed properly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个具有特殊名称的方法，如下所示。这些名称包含双下划线，由Python固定，我们必须使用这些确切名称来正确初始化或打印对象：
- en: 'The `__init__()` method is used implicitly to initialize the instance when
    it''s created. We''ll show an example of instance creation in the following section.
    When we create an `AnnualStats` object, three internal attributes are created,
    as shown in the following list:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`方法在创建实例时隐式地用于初始化。我们将在下一节中展示实例创建的示例。当我们创建`AnnualStats`对象时，会创建三个内部属性，如下所示：'
- en: The `self.year_measure` instance variable contains the data provided as an argument
    value
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.year_measure`实例变量包含作为参数值提供的数据。'
- en: The `self.data` instance variable contains just the data values extracted from
    the year-data two-tuples
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.data`实例变量仅包含从年份数据二元组中提取的数据值。'
- en: The `self.counter` instance variable contains a `Counter` object built from
    the data values
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.counter`实例变量包含一个由数据值构建的`Counter`对象'
- en: The `__repr__()` method is used implicitly when we attempt to print the object.
    We returned the representation of the internal `self.year_measure` instance variable
    as the representation for the instance as a whole.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们尝试打印对象时，会隐式地使用`__repr__()`方法。我们将内部`self.year_measure`实例变量的表示作为整个实例的表示返回。
- en: The other method functions look similar to the standalone function definitions
    shown previously. Each of these method functions depend on having the instance
    variables properly initialized by the `__init__()` method. These names are entirely
    part of our software design; we can call them anything that's syntactically legal
    and meaningful.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法函数看起来与之前展示的独立函数定义相似。这些方法函数都依赖于`__init__()`方法正确初始化实例变量。这些名称完全是我们软件设计的一部分；我们可以将它们命名为任何语法上合法且有意义的内容。
- en: Using a class definition
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类定义
- en: 'Here''s how we can use our `AnnualStats` class definition:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用我们的`AnnualStats`类定义：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We built two instances of the `AnnualStats` class. The `deaths` object is an
    `AnnualStats` object built from the year-death set of data. Similarly, the cheese
    object is an `AnnualStats` object built from the cheese consumption set of data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`AnnualStats`类的两个实例。`deaths`对象是由年份-死亡数据集构建的`AnnualStats`对象。同样，奶酪对象是由奶酪消费数据集构建的`AnnualStats`对象。
- en: In both cases, the `AnnualStats.__init__()` method is evaluated with the given
    argument value. When we evaluate `AnnualStats( get_deaths() )`, the result of
    `get_deaths()` is provided to `AnnualStats.__init__()` as the value of the `year_measure`
    parameter. The statements of the `__init__()` method will then set the values
    of the three instance variables.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`AnnualStats.__init__()`方法使用给定的参数值进行评估。当我们评估`AnnualStats( get_deaths()
    )`时，`get_deaths()`的结果作为`year_measure`参数的值提供给`AnnualStats.__init__()`。然后`__init__()`方法的语句将设置三个实例变量的值。
- en: When we evaluate `deaths.min_year()`, this will evaluate the `AnnualStats.min_year()`
    method function. The `self` variable will be `deaths`. This means that `self.year_measure`
    denotes the object originally created by `get_deaths()`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`deaths.min_year()`时，这将评估`AnnualStats.min_year()`方法函数。`self`变量将是`deaths`。这意味着`self.year_measure`表示由`get_deaths()`创建的原始对象。
- en: When we evaluate `deaths.mean()`, this will evaluate the `AnnualStats.min_year()`
    method function with the `self` variable referring to deaths. This means `deaths.data`
    is the sorted sequence we derived from the object originally created by `get_deaths()`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`deaths.mean()`时，这将评估`AnnualStats.min_year()`方法函数，其中`self`变量指向`deaths`。这意味着`deaths.data`是我们从`get_deaths()`创建的原始对象中导出的排序序列。
- en: Each instance (`deaths`, `cheese`) refers to the instance variables created
    by the `__init__()` method. A class encapsulates the processing of the method
    functions with the various instance variables. The encapsulation idea can help
    us design software that is more tightly focused and less likely to have confusing
    bugs or inconsistencies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个（`deaths`，`cheese`）实例都指的是由`__init__()`方法创建的实例变量。一个类封装了使用各种实例变量的方法函数的处理。封装的概念可以帮助我们设计更紧密聚焦且不太可能出现混淆性错误或不一致的软件。
- en: Comparisons and correlations
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较和相关性
- en: An important statistical question centers around correlation between variables.
    We often wonder if two sequences of values correlate with each other. If we have
    variables that correlate, perhaps we've found an interesting causal relationship.
    We might be able to use one variable to predict the values of another variable.
    We might also be able to prove that they're independent and have nothing to do
    with each other.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的统计问题集中在变量之间的相关性上。我们经常想知道两个值序列是否相关。如果我们有相关的变量，也许我们找到了一个有趣的因果关系。我们可能能够使用一个变量来预测另一个变量的值。我们也许还能证明它们是独立的，并且彼此无关。
- en: 'The essential statistical tool for this is the *coefficient of correlation*.
    We have several ways to compute this. One solution is to download NumPy or SciPy
    from the following links:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个统计工具的必要工具是*相关系数*。我们有几种计算这个系数的方法。一种解决方案是从以下链接下载NumPy或SciPy：
- en: '[http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html](http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html](http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html)'
- en: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html)'
- en: The correlation algorithms, however, aren't too complex. Implementing these
    two calculations will build up our basic data gathering espionage skills. We'll
    build some more basic statistical functions. Then, we'll build the correlation
    calculation, which will depend on other statistical functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相关算法并不复杂。实现这两个计算将建立我们的基本数据收集间谍技能。我们将构建一些更基本的统计函数。然后，我们将构建相关计算，这将依赖于其他统计函数。
- en: The essential numerical depends on computing means and standard deviations.
    We looked at the mean calculation previously. We'll add the standard deviation
    to our bag of tricks. Given the standard deviation, we can standardize each value.
    We'll compute the distance from the mean using the standard deviation as the measurement
    of distance. We can then compare standardized scores to see if two sets of data
    correlate.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的数值依赖于计算平均值和标准差。我们之前已经讨论了平均值计算。我们将把标准差添加到我们的技巧包中。给定标准差，我们可以标准化每个值。我们将使用标准差作为距离的度量来计算与平均值的距离。然后，我们可以比较标准化分数，以查看两组数据是否相关。
- en: Computing the standard deviation
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算标准差
- en: 'To compute the correlation coefficient, we need another descriptive statistic
    for a set of data: the standard deviation. This is a measure of how widely dispersed
    the data is. When we compute the mean, we find a center for the data. The next
    question is, *how tightly do the values huddle around the center?*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算相关系数，我们需要为数据集提供另一个描述性统计量：标准差。这是衡量数据分散程度的一个指标。当我们计算平均值时，我们找到了数据的一个中心。下一个问题是，*值是如何紧密围绕中心的？*
- en: If the standard deviation is small, the data is tightly clustered. If the standard
    deviation is large, the data is spread all over the place. The standard deviation
    calculation gives us a numeric range that brackets about two-third of the data
    values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标准差小，数据紧密聚集。如果标准差大，数据分布广泛。标准差计算给出了一个数值范围，大约包含三分之二的数据值。
- en: Having the standard deviation lets us spot unusual data. For example, the mean
    cheese consumption is 31.8 pounds per person. The standard deviation is 1.27 pounds.
    We expect to see much of the data huddled within the range of 31.8 ± 1.27, that
    is, between 30.53 and 33.07\. If our informant tries to tell as the per capita
    cheese consumption is 36 pounds in 2012, we have a good reason to be suspicious
    of the report.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有标准差让我们能够发现异常数据。例如，平均奶酪消费量为每人31.8磅。标准差为1.27磅。我们预计大部分数据将聚集在31.8 ± 1.27的范围内，即介于30.53和33.07之间。如果我们的信息提供者试图告诉我们2012年的人均奶酪消费量为36磅，我们有充分的理由对报告表示怀疑。
- en: There are a few variations to the theme of computing a standard deviation. There
    are some statistical subtleties, also, that relate to whether or not we have the
    entire population or just a sample. Here's one of the standard formulae ![Computing
    the standard deviation](img/0420OS_05_04.jpg). The symbol ![Computing the standard
    deviation](img/0420OS_05_05.jpg) represents the standard deviation of some variable,
    ![Computing the standard deviation](img/0420OS_05_06.jpg). The symbol ![Computing
    the standard deviation](img/0420OS_05_07.jpg) represents the mean of a variable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 计算标准差的主题有一些变体。还有一些与是否拥有整个总体或只是样本相关的统计细微差别。这里有一个标准公式 ![计算标准差](img/0420OS_05_04.jpg)。符号
    ![计算标准差](img/0420OS_05_05.jpg) 代表某个变量的标准差 ![计算标准差](img/0420OS_05_06.jpg)。符号 ![计算标准差](img/0420OS_05_07.jpg)
    代表变量的平均值。
- en: We have a method function, `mean()`, which computes the ![Computing the standard
    deviation](img/0420OS_05_07.jpg) value. We need to implement the standard deviation
    formula.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个方法函数，`mean()`，它计算 ![计算标准差](img/0420OS_05_07.jpg) 值。我们需要实现标准差公式。
- en: The standard deviation formula uses the `math.sqrt()` and `sum()` functions.
    We'll rely on using `import math` in our script.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差公式使用了`math.sqrt()`和`sum()`函数。我们将在脚本中依赖`import math`。
- en: 'We can directly translate the equation into Python. Here''s a method function
    we can add to our `AnnualStat` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将方程式翻译成Python。以下是我们可以添加到`AnnualStat`类中的方法函数：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We evaluated the `mean()` method function to get the mean, shown as ![Computing
    the standard deviation](img/0420OS_05_07.jpg), and assigned this to `μ_x` (yes,
    Greek letters are legal for Python variable names; if your OS doesn't offer ready
    access to extended Unicode characters, you might want to use `mu` instead). We
    also evaluated `len(data)` to get the value of `n`, the number of elements in
    the collection.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们评估了`mean()`方法函数以获取均值，如![计算标准差](img/0420OS_05_07.jpg)所示，并将其分配给`μ_x`（是的，希腊字母对于Python变量名是合法的；如果你的操作系统没有提供对扩展Unicode字符的快速访问，你可能想使用`mu`代替）。我们还评估了`len(data)`以获取集合中元素的数量`n`。
- en: We can then do a very literal translation from math-speak to Python. For example,
    the ![Computing the standard deviation](img/0420OS_05_08.jpg) becomes `sum((x-μ_x)**2
    for x in self.data)`. This kind of literal match between mathematical notation
    and Python makes it easy to vet Python programming to be sure it matches the mathematical
    abstraction.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数学语言直接翻译成Python。例如，![计算标准差](img/0420OS_05_08.jpg)变成了`sum((x-μ_x)**2 for
    x in self.data)`。这种数学符号与Python之间的直接匹配使得验证Python编程是否与数学抽象相匹配变得容易。
- en: 'Here''s another version of standard deviation, based on a slightly different
    formula:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是标准差的一个基于略微不同公式的版本：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This has an elegant symmetry to it. The formula looks like ![Computing the standard
    deviation](img/0420OS_05_09.jpg). It's not efficient or accurate any more. It's
    just sort of cool because of the symmetry between ![Computing the standard deviation](img/0420OS_05_10.jpg),
    ![Computing the standard deviation](img/0420OS_05_11.jpg), and ![Computing the
    standard deviation](img/0420OS_05_12.jpg).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优雅的对称性。公式看起来像![计算标准差](img/0420OS_05_09.jpg)。它不再高效或准确。它之所以有点酷，只是因为![计算标准差](img/0420OS_05_10.jpg)，![计算标准差](img/0420OS_05_11.jpg)和![计算标准差](img/0420OS_05_12.jpg)之间的对称性。
- en: Computing a standardized score
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算标准化分数
- en: Once we have the standard deviation, we can standardize each measurement in
    the sequence. This standardized score is sometimes called a Z score. It's the
    number of standard deviations a particular value lies from the mean.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了标准差，我们就可以将序列中的每个测量值标准化。这种标准化分数有时被称为Z分数。它是特定值与均值之间的标准差数。
- en: In ![Computing a standardized score](img/0420OS_05_13.jpg), the standardized
    score, ![Computing a standardized score](img/0420OS_05_14.jpg), is the difference
    between the score, ![Computing a standardized score](img/0420OS_05_15.jpg), and
    the mean, ![Computing a standardized score](img/0420OS_05_07.jpg), divided by
    the standard deviation, ![Computing a standardized score](img/0420OS_05_05.jpg).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在![计算标准化分数](img/0420OS_05_13.jpg)中，标准化分数![计算标准化分数](img/0420OS_05_14.jpg)是分数![计算标准化分数](img/0420OS_05_15.jpg)与均值![计算标准化分数](img/0420OS_05_07.jpg)之差除以标准差![计算标准化分数](img/0420OS_05_05.jpg)。
- en: If we have a mean, ![Computing a standardized score](img/0420OS_05_16.jpg),
    of 31.8 and a standard deviation, ![Computing a standardized score](img/0420OS_05_17.jpg),
    of 1.27, then a measured value of 29.87 will have a Z score of -1.519\. About
    30 percent of the data will be outside 1 standard deviation from the mean. When
    our informant tries to tell us that consumption jumped to 36 pounds of cheese
    per capita, we can compute the Z score for this, 3.307, and suggest that it's
    unlikely to be valid data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个均值为31.8，![计算标准化分数](img/0420OS_05_16.jpg)，标准差为1.27，![计算标准化分数](img/0420OS_05_17.jpg)，那么一个测量值为29.87的值将有一个Z分数为-1.519。大约30%的数据将超出均值1个标准差。当我们的信息提供者试图告诉我们人均消费量跳升到36磅奶酪时，我们可以计算这个值的Z分数，3.307，并建议这不太可能是有效数据。
- en: 'Standardizing our values to produce scores is a great use of a generator expression.
    We''ll add this to our class definition too:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的价值观标准化以生成分数是生成器表达式的一个很好的用途。我们也将把它添加到我们的类定义中：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We computed the mean of our data and assigned it to `μ_x`. We computed the standard
    deviation and assigned it to `σ_x`. We used a generator expression to evaluate
    `(x-μ_x)/σ_x` for each value, `x`, in our data. Since the generator was in `[]`,
    we will create a new list object with the standardized scores.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算了数据的均值并将其分配给`μ_x`。我们计算了标准差并将其分配给`σ_x`。我们使用生成器表达式评估`(x-μ_x)/σ_x`对于数据中的每个值`x`。由于生成器在`[]`中，我们将创建一个新的列表对象，包含标准化分数。
- en: 'We can show how this works with this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下方式展示它是如何工作的：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ll get a sequence like the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下序列：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Comparing a sequence and an iterable
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较序列和可迭代对象
- en: When we look at the result of the `stdscore()` method, we have a choice of what
    to return. In the previous example, we returned a new list object. We don't really
    need to do this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 `stdscore()` 方法的结果时，我们可以选择返回什么。在之前的例子中，我们返回了一个新的列表对象。我们实际上并不需要这样做。
- en: 'We can use this in the function to return a generator instead of a list:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数中使用这个序列来返回一个生成器而不是列表：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The rest of the function is the same. It's good to give this version a different
    name. Call the old one `stdscore2()` so that you can compare list and generator
    versions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分与之前相同。最好给这个版本一个不同的名字。将旧的函数命名为 `stdscore2()`，这样我们就可以比较列表和生成器版本。
- en: The generator `stdscore()` function now returns an expression that can be used
    to generate the values. For most of our calculations, there's no practical difference
    between an actual list object and an iterable sequence of values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器 `stdscore()` 函数现在返回一个可以用来生成值的表达式。对于我们的大多数计算，实际列表对象和可迭代值序列之间没有实际差异。
- en: 'There are three differences that we''ll notice:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到三个差异：
- en: Firstly, we can't use `len()` on the generator results
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们不能在生成器结果上使用 `len()`。
- en: Secondly, a generator doesn't generate any data until we use it in a `for` loop
    or to create a list
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，生成器在我们使用它在一个 `for` 循环中或创建一个列表之前不会生成任何数据。
- en: Thirdly, an iterable can only be used once
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，一个可迭代对象只能使用一次。
- en: 'Try to see how this works with something simple like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用这个简单的例子看看它是如何工作的：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ll see the generator expression, not the values that are generated. Here''s
    the output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到生成器表达式，而不是生成的值。以下是输出结果：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We need to do this to collect the generated values into an object. The `list()`
    function does this nicely. Here''s what we can do to evaluate the generator and
    actually generate the values:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这样做，以便将生成的值收集到一个对象中。`list()` 函数可以很好地完成这项工作。以下是评估生成器并实际生成值的操作方法：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will evaluate the generator, producing a list object that we can print.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估生成器，生成一个我们可以打印的列表对象。
- en: Computing a coefficient of correlation
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算相关系数
- en: 'One important question that arises when comparing two sequences of data is
    how well they correlate with each other. When one sequence trends up, does the
    other? Do they trend at the same rate? We can measure this correlation by computing
    a coefficient based on the products of the standardized scores:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较两个数据序列时，一个重要的问题是如何评估它们之间的相关性。当一个序列呈上升趋势时，另一个序列是否也是如此？它们是否以相同的速率变化？我们可以通过计算基于标准化分数乘积的系数来测量这种相关性：
- en: '![Computing a coefficient of correlation](img/0420OS_05_18.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![计算相关系数](img/0420OS_05_18.jpg)'
- en: In this case, ![Computing a coefficient of correlation](img/0420OS_05_19.jpg)
    is the standardized score for each individual value, ![Computing a coefficient
    of correlation](img/0420OS_05_20.jpg). We do the same calculation for the other
    sequences and compute the product of each pair. The average of the product of
    the various standardized scores will be a value between +1 and -1\. A value near
    +1 means the two sequences correlate nicely. A value near -1 means the sequences
    oppose each other. One trends up when the other trends down. A value near 0 means
    the sequences don't correlate.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，![计算相关系数](img/0420OS_05_19.jpg) 是每个单独值的标准化分数，![计算相关系数](img/0420OS_05_20.jpg)。我们对其他序列做同样的计算，并计算每一对的乘积。各种标准化分数乘积的平均值将在
    +1 和 -1 之间。接近 +1 的值意味着两个序列很好地相关。接近 -1 的值意味着序列相互对立。一个序列上升时，另一个序列下降。接近 0 的值意味着序列不相关。
- en: 'Here''s a function that computes the correlation between two instances of `AnnualStat`
    data collections:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算两个 `AnnualStat` 数据集合实例之间相关性的函数：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We used the `stdscore()` method of each `AnnualStat` object to create a sequence
    of standardized score values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用每个 `AnnualStat` 对象的 `stdscore()` 方法创建了一个标准化分数值的序列。
- en: We created a generator using the `zip()` function that will yield two-tuples
    from two separate sequences of scores. The mean of this sequence of products is
    the coefficient correlation between the two sequences. We computed the mean by
    summing and dividing by the length, `n`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `zip()` 函数创建了一个生成器，它将从两个不同的分数序列中产生二元组。这个乘积序列的平均值是两个序列之间的相关系数。我们通过求和并除以长度
    `n` 来计算平均值。
- en: Writing high-quality software
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高质量的软件
- en: How do we know these various statistical functions work? This is potentially
    very tricky programming, with lots of opportunities to have things go wrong.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道这些各种统计函数是如何工作的？这可能是非常棘手的编程，有很多机会出错。
- en: 'The best tool to make sure that software works is unit testing. The idea behind
    unit testing is to break a module down into separate units—usually functions or
    classes—and test each unit in isolation. Python gives us two ways to perform unit
    testing:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 确保软件工作的最佳工具是单元测试。单元测试背后的思想是将模块分解成单独的单元——通常是函数或类——并在隔离状态下测试每个单元。Python为我们提供了两种执行单元测试的方法：
- en: Putting examples into docstrings for modules, functions, and classes
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将示例放入模块、函数和类的文档字符串中
- en: Writing separate `unittest.TestCase` classes
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单独的`unittest.TestCase`类
- en: Most secret agents will be very happy with docstring test cases. They're easy
    to write. We put them in the docstring right in front of the rest of the code.
    They're visible when we use the `help()` function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数秘密特工都会对文档字符串测试用例感到非常满意。它们很容易编写。我们将它们放在代码的文档字符串中。当我们使用`help()`函数时，它们是可见的。
- en: We create these docstring test cases by copying and pasting known correct results
    from interactive Python. The copy and paste will include the `>>>` prompt to make
    it easy to find the examples. Of course, we also include the output that's expected.
    Once we include this in the docstring, the `doctest` module will find and use
    the example.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从交互式Python复制和粘贴已知正确结果来创建这些文档字符串测试用例。复制和粘贴将包括`>>>`提示，以便轻松找到示例。当然，我们也包括预期的输出。一旦我们将这些包含在文档字符串中，`doctest`模块就会找到并使用这些示例。
- en: In some cases, we need to fake the expected results. It's actually common to
    have worked out what the answer is supposed to be before having written any working
    Python code. If we're sure the docstring example has the expected right answer,
    we can leverage this and use it to help debug the code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要伪造预期的结果。实际上，在编写任何有效的Python代码之前，就已经计算出答案应该是怎样的，这是很常见的。如果我们确信文档字符串示例有预期的正确答案，我们可以利用这一点，并使用它来帮助调试代码。
- en: 'Let''s look at a simple function we wrote earlier:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们之前编写的一个简单函数：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We added the example interaction to the function's docstring. We included what
    looks like a copy and paste of the sequence of interactions that will exercise
    this function. In some cases, we make the sequence up based on what we plan to
    write, not what we've written.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将示例交互添加到函数的文档字符串中。我们包括了看起来像是复制和粘贴的交互序列，这些交互将测试这个函数。在某些情况下，我们根据我们计划编写的内容而不是已经编写的内容来构建这个序列。
- en: 'We can exercise the several different ways. The easiest is this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以练习几种不同的方法。最简单的是这个：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We run the `doctest` module as a top-level main application. The single argument
    to this application is the name of a Python application that has doctest examples
    pasted into docstrings.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`doctest`模块作为顶级主应用程序运行。这个应用程序的单个参数是包含doctest示例并粘贴到文档字符串中的Python应用程序的名称。
- en: 'There''s no output if everything works. If we''re curious, we can ask for more
    verbose output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，则没有输出。如果我们好奇，我们可以要求更详细的输出：
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will produce voluminous output that shows each test that was found in the
    docstrings in the module.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生大量的输出，显示模块文档字符串中找到的每个测试。
- en: The other techniques include building a self-testing module and writing a separate
    script that just runs tests.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 其他技术包括构建一个自测试模块和编写一个单独的脚本，该脚本仅运行测试。
- en: Building a self-testing module and a test module
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个自测试模块和一个测试模块
- en: One of the techniques that works out nicely is using the `__name__ == "__main__"`
    technique to add a test script to a library module. We'll evaluate the `doctest.testmod()`
    function to test the functions and classes defined in a module.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种效果很好的技术是使用`__name__ == "__main__"`技术将测试脚本添加到库模块中。我们将评估`doctest.testmod()`函数来测试模块中定义的函数和类。
- en: 'It looks like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If this module is being run from the command line, it's the main module, and
    global `__name__` will be set to `"__main__"`. When this is true, we can import
    the doctest module and evaluate `doctest.testmod()` to confirm that everything
    else in the module works.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个模块是从命令行运行的，它就是主模块，全局`__name__`将被设置为`"__main__"`。当这是真的时，我们可以导入doctest模块并评估`doctest.testmod()`以确认模块中的其他一切正常。
- en: 'We can also write a separate test script. We might call it "`test.py`"; it
    might be as short as this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以编写一个单独的测试脚本。我们可能称之为"`test.py`"；它可能像这样简短：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This short script imported the doctest module. It also imported the module we're
    going to test.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的脚本导入了doctest模块。它还导入了我们要测试的模块。
- en: 'We used the `doctest.testmod()` function to locate doctest examples in the
    given module. The output looks like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`doctest.testmod()`函数在给定的模块中定位doctest示例。输出看起来像这样：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a confirmation that there were two lines of `>>>` examples, and everything
    worked perfectly.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了有两个`>>>`示例行，并且一切工作得非常完美。
- en: Creating more sophisticated tests
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建更复杂的测试
- en: There are times when we have to be a little cautious of the doctest example
    output. These are situations where Python's behavior is not specified to the level
    of detail where we can copy and paste interactive results without thinking about
    what we're doing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们必须对doctest示例输出保持一定的谨慎。这些情况是Python的行为没有详细说明到我们可以复制粘贴交互结果而不考虑我们在做什么的程度。
- en: When working with dict and set collections, the order of the items is not guaranteed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当与字典和集合集合一起工作时，项的顺序是不保证的。
- en: For a dict, a doctest string needs to include `sorted()` to force a specific
    order. It's essential to use `sorted(some_dict.items())` instead of simply using
    `some_dict`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于字典，doctest字符串需要包含`sorted()`来强制特定的顺序。使用`sorted(some_dict.items())`而不是简单地使用`some_dict`是至关重要的。
- en: The same consideration applies to sets. We must use something like `sorted(some_set)`
    instead of `some_set`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样的考虑也适用于集合。我们必须使用类似`sorted(some_set)`的东西而不是`some_set`。
- en: 'Some internal functions such as `id()` and `repr()` can display a physical
    memory address that''s unlikely to be the same each time we run the tests. There''s
    a special comment we can include that will alert doctest to skip the details.
    We''ll include `#doctest: +ELLIPSIS` and replace the ID or address with `...`
    (three dots).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '一些内部函数，如`id()`和`repr()`，可以显示一个物理内存地址，这个地址在每次运行测试时可能不会相同。我们可以包含一个特殊的注释来提醒doctest跳过这些细节。我们将包含`#doctest:
    +ELLIPSIS`并将ID或地址替换为`...`（三个点）。'
- en: Another place we might use ellipsis is to shorten up a very long bit of output.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能在输出非常长的输出时使用省略号来缩短。
- en: 'For example, we might have a module docstring like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能有一个模块文档字符串如下：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A module docstring must be (almost) the first lines in a module file. The only
    line that might come before the module docstring is a one-line `#!` comment. A
    `#!` comment line, if present, is aimed at the OS shell and identifies the rest
    of the file as being a Python script, not a shell script.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 模块文档字符串必须是模块文件中的（几乎）第一行。可能出现在模块文档字符串之前的是一行`#!`注释。如果存在，`#!`注释行是针对操作系统shell的，它将文件的其余部分标识为Python脚本，而不是shell脚本。
- en: 'We used the `# doctest: +ELLIPSIS` directive on one of our tests. The result
    wasn''t complete, it had "`...`" in the expected results to show the parts doctest
    should ignore.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在我们的测试中使用了`# doctest: +ELLIPSIS`指令。结果并不完整，预期结果中包含"`...`"以显示doctest应该忽略的部分。'
- en: Floating-point values may not be identical for different processors and OSes.
    We have to be careful to show floating-point numbers with formatting or rounding.
    We might use `"{:.4f}".format(value)` or `round(value,4)` to assure that the insignificant
    digits are ignored.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值在不同处理器和操作系统之间可能不完全相同。我们必须小心地显示带有格式化或四舍五入的浮点数。我们可能使用`"{:.4f}".format(value)`或`round(value,4)`来确保忽略不重要的数字。
- en: Adding doctest cases to a class definition
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将doctest案例添加到类定义中
- en: We looked at doctests in modules and functions. We can put doctests in several
    places in a class definition. This is because we have several places to put docstrings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了模块和函数中的doctests。我们可以在类定义的几个地方放置doctests。这是因为我们有几个地方可以放置文档字符串。
- en: The class as a whole can have a docstring right at the top. It's the first line
    after the `class` statement. Also, each individual method within a class can have
    its own private docstring.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 整个类可以在顶部有一个文档字符串。它是`class`语句之后的第一个行。此外，类中的每个单独的方法也可以有自己的私有文档字符串。
- en: 'We might, for example, include a comprehensive docstring at the beginning of
    our class definition:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在类定义的开始处包含一个全面的文档字符串：
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This provides a complete rundown of all of the features of this class in one
    tidy summary.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个关于此类所有功能的完整概述。
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Our sample data leads to a standard deviation of exactly 2.0\. This trick shows
    that with clever test data, we can circumvent some of the doctest float-point
    output limitations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据样本导致标准差恰好为2.0。这个技巧表明，通过巧妙的设计测试数据，我们可以绕过一些doctest浮点数输出的限制。
- en: Solving problems – analyzing some interesting datasets
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决问题——分析一些有趣的数据库
- en: What is the correlation coefficient between per-capita cheese consumption and
    death code W75 (accidental suffocation and strangulation in bed) for the years
    2000 to 2009?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 2000年至2009年间，人均奶酪消费与死亡代码W75（床上意外窒息和勒死）之间的相关系数是多少？
- en: Recall that the cheese data came from [http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls](http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，奶酪数据来自[http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls](http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls)。
- en: This is a pesky bit of data because it's in a proprietary spreadsheet format.
    As much as we dislike copying and pasting, there's no other easy way to get this
    data.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段令人烦恼的数据，因为它在专有电子表格格式中。尽管我们不喜欢复制粘贴，但除此之外没有其他简单的方法来获取这些数据。
- en: The strangulation in bed data comes from cause of death W75 grouped by year.
    The data request process starts at [http://wonder.cdc.gov/controller/datarequest/D76](http://wonder.cdc.gov/controller/datarequest/D76).
    There will be some further espionage work required to enter a request for data.
    For some additional help, check [http://wonder.cdc.gov/wonder/help/ucd.html](http://wonder.cdc.gov/wonder/help/ucd.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 床上勒死的统计数据来自按年份分组的死亡原因W75。数据请求过程从[http://wonder.cdc.gov/controller/datarequest/D76](http://wonder.cdc.gov/controller/datarequest/D76)开始。将需要一些额外的间谍工作来提交数据请求。如需更多帮助，请查看[http://wonder.cdc.gov/wonder/help/ucd.html](http://wonder.cdc.gov/wonder/help/ucd.html)。
- en: How the correlation possibly be so high?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关联为何可能如此之高？
- en: What is it about cheese consumption and death by strangulation in bed that leads
    to this amazing correlation?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 是什么使得奶酪消费和床上勒死之间的这种关联如此令人惊讶？
- en: Getting some more data
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取更多数据
- en: HQ appears to be working on a theory about dairy products. The cheese spreadsheet
    also has mozzarella cheese consumption over the same period of time—2000 to 2009.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: HQ似乎正在研究关于乳制品的理论。奶酪电子表格还有同一时期（2000年至2009年）的莫扎雷拉奶酪消费数据。
- en: We've been ordered to get details on civil engineering doctorates awarded during
    this period.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求获取关于这一时期授予的土木工程博士学位的详细信息。
- en: 'Some initial espionage turned up this set of data:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一些初步的间谍活动揭露了这一组数据：
- en: '[http://www.nsf.gov/statistics/infbrief/nsf12303/](http://www.nsf.gov/statistics/infbrief/nsf12303/)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.nsf.gov/statistics/infbrief/nsf12303/](http://www.nsf.gov/statistics/infbrief/nsf12303/)'
- en: This is a tricky table to parse. It's a bit more complex because the years are
    in columns and the data we're looking for is in a particular row, a row with `th.text
    == "Civil engineering"`. The heading for the table as a whole is in a row with
    `th.text == "Field"`. This means that the navigation will be rather complex to
    locate the `Field` row and the `Civil engineering` rows of the proper table on
    this page.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个难以解析的表格。它稍微复杂一些，因为年份在列中，而我们正在寻找的数据在特定的行中，即`th.text == "Civil engineering"`的行。整个表格的标题在`th.text
    == "Field"`的行中。这意味着导航将相当复杂，以定位本页上正确的表格的`Field`行和`Civil engineering`行。
- en: How does annual per-capita mozzarella cheese consumption correlate with civil
    engineering doctorates?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 年人均莫扎雷拉奶酪消费量与土木工程博士学位之间有何关联？
- en: How can the correlation possibly be so high?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关联为何可能如此之高？
- en: What is it about cheese, death, and doctorates?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 跟奶酪、死亡和博士学位有什么关系呢？
- en: Further research
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步研究
- en: Is this just a spurious correlation?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否只是一个偶然的关联？
- en: Are there other correlations like this?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 是否还有其他类似的关联？
- en: What else can we learn from [http://www.tylervigen.com/](http://www.tylervigen.com/)?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能从[http://www.tylervigen.com/](http://www.tylervigen.com/)学到什么？
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We saw how we can easily implement sophisticated statistical analyses as short
    pieces of Python programming. We applied basic statistical insights to all our
    intelligence gathering.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何轻松地将复杂的统计分析实现为简短的Python编程片段。我们将基本的统计洞察力应用于我们所有的情报收集。
- en: We learned to design Python modules. This allows us to extend the Python standard
    library with our own more specialized modules. We can now easily package reusable
    software in modules for our own purposes as well as for distribution to our network
    of agents.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了设计Python模块。这使我们能够通过我们自己的更专业化的模块扩展Python标准库。现在，我们可以轻松地将可重用软件打包成模块，用于我们自己的目的，以及分发到我们的代理网络。
- en: 'In addition to designing modules, we also saw how to write tests to confirm
    that our software really works. Software can''t be trusted unless there are formal
    unit tests to confirm that things are behaving correctly. We saw the essential
    ingredients of the Python language, the standard library, and the ecosystem of
    related projects and tools. The Python language is quite simple: it only has about
    22 statements, and we saw examples of almost all of them.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设计模块，我们还看到了如何编写测试来确认我们的软件确实工作。除非有正式的单元测试来确认事物是否按正确的方式运行，否则无法信任软件。我们看到了Python语言的基本要素、标准库以及相关项目和工具的生态系统。Python语言相当简单：它只有大约22条语句，我们看到了几乎所有这些语句的示例。
- en: At this point, each secret agent's areas of interest and expertise will start
    to diverge. There are numerous packages, libraries, and application areas that
    are open for exploration.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，每个秘密代理的兴趣领域和专长将开始分化。有众多可供探索的软件包、库和应用领域。
- en: Since our focus is on getting field agents to be productive, we were studiously
    avoiding more serious software development issues. In particular, we avoided the
    subject of object-oriented design. An agent that needs to do more sophisticated
    processing will need to write more sophisticated software. A book like *Python
    3 Object Oriented Programming*, *Dusty Phillips*, *Packt Publishing*, is essential
    to learn this important technique. Check [http://www.packtpub.com/python-3-object-oriented-programming/book](http://www.packtpub.com/python-3-object-oriented-programming/book).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的重点是让现场代理变得高效，所以我们仔细避免涉及更严肃的软件开发问题。特别是，我们避开了面向对象设计的主题。需要做更复杂处理的代理将需要编写更复杂的软件。一本像《Python
    3 Object Oriented Programming》（作者：Dusty Phillips，出版社：Packt Publishing）这样的书对于学习这项重要技术是必不可少的。请查看[http://www.packtpub.com/python-3-object-oriented-programming/book](http://www.packtpub.com/python-3-object-oriented-programming/book)。
- en: An agent's interests and abilities will often lead in different directions.
    Some agents will want to build websites. A book like *Python 3 Web Development
    Beginner's Guide*, *Michel Anders*, *Packt Publishing*, can help. Some agents
    will want to build interactive applications; a book like *Instant Pygame for Python
    Game Development How-to*, *Ivan Idris*, *Packt Publishing*, can help master the
    Pygame framework. This framework is for more than just games.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的兴趣和能力往往会导致不同的方向。一些代理可能想要建立网站；一本像《Python 3 Web Development Beginner's Guide》（作者：Michel
    Anders，出版社：Packt Publishing）这样的书可能会有所帮助。一些代理可能想要构建交互式应用程序；一本像《Instant Pygame for
    Python Game Development How-to》（作者：Ivan Idris，出版社：Packt Publishing）这样的书可以帮助掌握Pygame框架。这个框架不仅仅适用于游戏。
- en: Some agents will pursue natural language processing. A book like *Python 3 Text
    Processing with NLTK 3 Cookbook*, *Jacob Perkins*, *Packt Publishing*, can help.
    Other agents will pursue more complex media using *Python Multimedia*, *Ninad
    Sathaye*, *Packt Publishing* or perhaps *Practical Maya Programming with Python*,
    *Robert Galanakis*, *Packt Publishing*. Agents interested in geospatial analysis
    might pursue *Programming ArcGIS 10.1 with Python Cookbook*, *Eric Pimpler*, *Packt
    Publishing*.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代理可能会追求自然语言处理。一本像《Python 3 Text Processing with NLTK 3 Cookbook》（作者：Jacob
    Perkins，出版社：Packt Publishing）这样的书可能会有所帮助。其他代理可能会使用*Python Multimedia*（作者：Ninad
    Sathaye，出版社：Packt Publishing）或可能使用*Practical Maya Programming with Python*（作者：Robert
    Galanakis，出版社：Packt Publishing）来追求更复杂的媒体。对地理空间分析感兴趣的代理可能会追求《Programming ArcGIS
    10.1 with Python Cookbook》（作者：Eric Pimpler，出版社：Packt Publishing）。
- en: Skilled agents will find that Python can be used for a wide variety of missions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 熟练的代理会发现Python可以用于各种任务。
