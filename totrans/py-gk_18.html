<html><head></head><body>
		<div><h1 id="_idParaDest-292"><em class="italic"><a id="_idTextAnchor330"/>Chapter 14</em>: Using Python for Network Automation</h1>
			<p>Traditionally, networks are built and operated by network experts, and this is still a trend in the telecom industry. However, this manual approach of managing and operating a network is slow and sometimes results in costly network outages due to human mistakes. Additionally, to obtain a new service (such as an internet service), customers have to wait for days after placing a request for a new service before it's ready. Based on the experience of smartphones and mobile applications, where you can enable new services and applications with a click of a button, customers expect network service readiness in minutes, if not seconds. This is not possible with the current approach to network management. The traditional approaches are also sometimes a roadblock in introducing new products and services by the telecom service providers. </p>
			<p><strong class="bold">Network automation</strong> can <a id="_idIndexMarker1497"/>improve these situations by offering software for automating the management as well as operational aspects of a network. Network automation helps eliminate human errors in configuring network devices and reduce operational costs significantly by automating repetitive tasks. Network automation helps accelerate service delivery and enables telecom service providers to introduce new services.</p>
			<p>Python<a id="_idIndexMarker1498"/> is a popular choice for network automation. In this chapter, we will discover Python capabilities for <a id="_idIndexMarker1499"/>network automation. Python provides libraries such<a id="_idIndexMarker1500"/> as <strong class="bold">Paramiko</strong>, <strong class="bold">Netmiko</strong>, and <strong class="bold">NAPALM</strong> that<a id="_idIndexMarker1501"/> can be used to interact with network devices. If the network devices are managed <a id="_idIndexMarker1502"/>by a <strong class="bold">Network Management System</strong> (<strong class="bold">NMS</strong>) or a network controller/orchestrator, Python can interact with these platforms <a id="_idIndexMarker1503"/>using the <strong class="bold">REST</strong> or <strong class="bold">RESTCONF</strong> protocols. End-to-end network automation is <a id="_idIndexMarker1504"/>not possible without listening to real-time events happening in the network. These real-time network events or real-time streaming data is typically available through<a id="_idIndexMarker1505"/> systems such as <strong class="bold">Apache Kafka</strong>. We will also explore interaction with an event-driven system using Python. </p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing network automation</li>
				<li>Interacting with network devices</li>
				<li>Integrating with network management systems</li>
				<li>Working with event-based systems</li>
			</ul>
			<p>After completing this chapter, you will understand how to use Python libraries to fetch data from a network device and to push configurational data to these devices. These are foundational steps for any network automation process. </p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor331"/>Technical requirements</h1>
			<p>The following are the technical requirements for this chapter:</p>
			<ul>
				<li>You need to have Python 3.7 or later installed on your computer.</li>
				<li>You need to install Paramiko, Netmiko, NAPALM, ncclient, and the requests libraries on top of Python.</li>
				<li>You need to have access to one or more network devices with the SSH protocol. </li>
				<li>You need to have access to a Nokia developer lab to be able to access Nokia's NMS (known as <strong class="bold">Network Services Platform</strong> (<strong class="bold">NSP</strong>)).</li>
			</ul>
			<p>The sample code for this chapter can be found at <a href="https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter14">https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter14</a>. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In this chapter, you will need access to physical or virtual network devices and network management systems to execute the code examples. This may not be possible for everyone. You can use any network device with similar capabilities. We will focus more on the Python side of the implementation and make it convenient to reuse the code for any other device or management system. </p>
			<p>We will start our discussion by providing an introduction to network automation.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor332"/>Introducing network automation</h1>
			<p>Network automation <a id="_idIndexMarker1506"/>is the use of technology and software to automate the processes of managing and operationalizing networks. The keyword for network automation is <em class="italic">automating a process</em>, which means it is not only about deploying and configuring a network but also the steps that must be followed to achieve network automation. For example, sometimes, the automation steps involve gaining approval from different stakeholders before a configuration is pushed to a network. Automating such an approval step is part of network automation. Therefore, the network automation process can vary from one organization to another based on the internal processes each organization follows. This makes it challenging to build a single platform that can perform automation out of the box for many customers.  </p>
			<p>There are a significant number of ongoing efforts to provide the necessary platforms from the network device <a id="_idIndexMarker1507"/>vendors that can help in building customized automation with minimal effort. A few examples<a id="_idIndexMarker1508"/> of such platforms are Cisco <strong class="bold">Network Services Orchestrator</strong> (<strong class="bold">NSO</strong>), the <strong class="bold">Paragon Automation</strong> platform from<a id="_idIndexMarker1509"/> Juniper Networks, and <strong class="bold">NSP</strong> from Nokia. </p>
			<p>One of the challenges with these automation platforms<a id="_idIndexMarker1510"/> is that they are typically vendor locked. This means that the vendors claim that their platform can manage and automate other vendors' network devices as well, but the process to achieve multi-vendor automation is tedious and costly. Therefore, telecom service providers are looking beyond the vendor's platforms for automation. <strong class="bold">Python</strong> and <strong class="bold">Ansible</strong> are<a id="_idIndexMarker1511"/> two popular programming languages that are<a id="_idIndexMarker1512"/> used for automation in the telecom industry. Before we jump into how Python achieves network automation, let's explore a few merits and challenges of network automation. </p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor333"/>Merits and challenges of network automation</h2>
			<p>We have highlighted a few merits of network automation<a id="_idIndexMarker1513"/> already. We can summarize the key merits as follows: </p>
			<ul>
				<li><strong class="bold">Expedite service delivery</strong>: Faster service delivery to new customers enables you to start the service billing early and have more satisfied customers.</li>
				<li><strong class="bold">Reducing operational costs</strong>: The operational costs of a network can be reduced by automating repetitive tasks and monitoring the network through tools and closed-loop automation platforms. </li>
				<li><strong class="bold">Eliminate humor errors</strong>: The majority of network outages are because of human errors. Network automation can eliminate this cause by configuring the networks using standard <a id="_idIndexMarker1514"/>templates. These templates are deeply evaluated and tested before being put into production.</li>
				<li><strong class="bold">Consistent network setup</strong>: When humans are configuring a network, it is impossible to follow consistent templates and naming conventions, which are important for the operations team to manage the network. Network automation brings consistency in setting up the network as we configure the network every time using the same script or template.</li>
				<li><strong class="bold">Network visibility</strong>: With network automation tools and platforms, we can have access to performance monitoring capabilities and can visualize our network from end to end. Proactive network management is possible by detecting traffic spikes and heavy resources utilization before they cause bottlenecks for the network traffic. </li>
			</ul>
			<p>Network automation is a <a id="_idIndexMarker1515"/>must for digital transformation, but there are some costs and challenges to achieve it. These challenges are as follows: </p>
			<ul>
				<li><strong class="bold">Cost</strong>: There is always a cost when it comes to building or customizing the software for network automation. Network automation is a journey and a cost budget must be set for it on an annual basis. </li>
				<li><strong class="bold">Human resistance</strong>: In many organizations, human resources consider network automation as a threat to their jobs, so they resist adopting network automation, especially within operation teams. </li>
				<li><strong class="bold">Organizational structure</strong>: Network automation brings a real <strong class="bold">return on investment</strong> (<strong class="bold">ROI</strong>) when it is <a id="_idIndexMarker1516"/>used across different network layers and network domains such as IT and network domains. The challenge in many organizations is that these domains are owned by different departments and each has their own automation strategies and preferences regarding automation platforms. </li>
				<li><strong class="bold">Selecting an automation platform/tool</strong>: Selecting an automation platform from network equipment vendors such as Cisco or Nokia, or working with third-party automation platforms such as HP or Accenture, is not an easy decision. In many cases, the<a id="_idIndexMarker1517"/> telecom service providers end up with multiple vendors for building their network automation, and this brings a new set of challenges to make these vendors work together. </li>
				<li><strong class="bold">Maintenance</strong>: Maintaining automation tools and scripts is as essential as building them. This requires either buying essential maintenance contracts from automation vendors or setting an internal team to provide maintenance for such automation platforms. </li>
			</ul>
			<p>Next, we look at the use cases.</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor334"/>Use cases</h2>
			<p>Several monotonous tasks regarding network management can be automated using Python or other tools. But the real benefits are to automate those tasks that are repetitive, error-prone, or tedious if done manually. From a telecom service provider's point of view, the following are the main <a id="_idIndexMarker1518"/>applications of network automation:</p>
			<ul>
				<li>We can automate the day-to-day configuration of network devices, such as creating new IP interfaces and network connectivity services. It is time-consuming to do these tasks manually. </li>
				<li>We can configure firewall rules and policies to save time. Creating firewall rule configurations is a tedious activity, and any mistakes can result in wasting time in troubleshooting the communication challenges.</li>
				<li>When we have thousands of devices in a network, upgrading their software is a big challenge and sometimes, it takes 1 to 2 years to achieve this. Network automation can expedite this activity and enforce pre- and post-upgrade checks conveniently for seamless upgrades.</li>
				<li>We can use network automation to onboard new network devices in the network. If the device is to be installed on a customer's premises, we can save a truck roll by<a id="_idIndexMarker1519"/> automating the device's onboarding process. This <a id="_idIndexMarker1520"/>onboarding process is also known as <strong class="bold">zero touch provisioning</strong> (<strong class="bold">ZTP</strong>). </li>
			</ul>
			<p>Now that we've introduced network automation, let's explore how to interact with network devices using different protocols. </p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor335"/>Interacting with network devices</h1>
			<p>Python is a popular choice for network automation<a id="_idIndexMarker1521"/> because it is easy to learn and can be used to integrate with network devices directly, as well as through NMS. In fact, many vendors, such as Nokia and Cisco, support Python runtimes on their network devices. The option of on-device Python runtimes is useful for automating tasks and activities in the context of a single device. In this section, we will focus on the<a id="_idIndexMarker1522"/> off-device Python runtime option. This option will give us the flexibility to work with multiple devices at a time. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">For all the code examples provided in this section, we will use a virtual network device from Cisco (IOS XR with release 7.1.2). For integration with the NMS we will use the Nokia NSP system.</p>
			<p>Before working with Python so that we can interact with network devices, we will discuss the protocols that are available for communicating with network devices.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor336"/>Protocols for interacting with network devices</h2>
			<p>When it comes to<a id="_idIndexMarker1523"/> talking to network devices directly, there are several protocols we can use, such as <strong class="bold">Secure Shell Protocol</strong> (<strong class="bold">SSH</strong>), <strong class="bold">Simple Network Management Protocol</strong> (<strong class="bold">SNMP</strong>), and <strong class="bold">Network Configuration</strong> (<strong class="bold">NETCONF</strong>). Some of these protocols work on top of each other. The most commonly used protocols will be described next.</p>
			<h3>SSH</h3>
			<p>SSH is a <a id="_idIndexMarker1524"/>network protocol for communicating between any two devices or computers securely. All the information between the two entities will be encrypted before it's sent to a transport <a id="_idIndexMarker1525"/>channel. We typically use an SSH client to connect to a network device using the <code>ssh</code> command. The SSH client uses the <em class="italic">username</em> of the logged-in operating system user with the <code>ssh</code> command:</p>
			<pre>ssh &lt;server ip or hostname&gt;</pre>
			<p>To use a different user other than the logged-in user, we can specify the <em class="italic">username</em>, as follows: </p>
			<pre>ssh username@&lt;server IP or hostname&gt;</pre>
			<p>Once an SSH connection has been established, we can send CLI commands either to retrieve configuration or operational information from a device or to configure the device. <strong class="bold">SSH version 2</strong> (<strong class="bold">SSHv2</strong>) is a <a id="_idIndexMarker1526"/>popular choice for interacting with devices for network management and even for automation purposes. </p>
			<p>We will discuss how to use the SSH protocol with Python libraries such as Paramiko, Netmiko, and NAPALM in the <em class="italic">Interacting with network devices using SSH-based protocols</em> section. SSH is also a foundational transport protocol for many advanced network management protocols, such as NETCONF.</p>
			<h3>SNMP</h3>
			<p>This protocol<a id="_idIndexMarker1527"/> has been a de facto standard for network management for 30+ years and<a id="_idIndexMarker1528"/> it is still used heavily for network management. However, it is being replaced by more advanced and scalable protocols such as NETCONF and gNMI. SNMP can be used both for network configuration and for network monitoring, but it is more popular for network monitoring. In today's world, it is considered a legacy protocol that was introduced in the late 1980s, purely for network management. </p>
			<p>The <a id="_idIndexMarker1529"/>SNMP protocol relies on <strong class="bold">Management Information Base</strong> (<strong class="bold">MIB</strong>), which <a id="_idIndexMarker1530"/>is a device model. This <a id="_idIndexMarker1531"/>model was built using a data<a id="_idIndexMarker1532"/> modeling language called <strong class="bold">Structure of Management Information</strong> (<strong class="bold">SMI</strong>). </p>
			<h3>NETCONF</h3>
			<p>The<a id="_idIndexMarker1533"/> NETCONF protocol, which was <a id="_idIndexMarker1534"/>introduced by the <strong class="bold">Internet Engineering Task Force</strong> (<strong class="bold">IETF</strong>), is considered a <a id="_idIndexMarker1535"/>successor of SNMP. NETCONF is primarily used for configuring network devices and is expected to be supported by all new network devices. NETCONF is based on four layers: </p>
			<ul>
				<li><strong class="bold">Content</strong>: This is a<a id="_idIndexMarker1536"/> data layer that relies on YANG modeling. Every device offers several YANG models<a id="_idIndexMarker1537"/> for various modules it offers. These models can be explored at <a href="https://github.com/YangModels/yang">https://github.com/YangModels/yang</a>.</li>
				<li><code>get</code>, <code>get-config</code>, <code>edit-config</code>, and <code>delete-config</code>. </li>
				<li><strong class="bold">Messages</strong>: These are <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>) messages<a id="_idIndexMarker1540"/> that are exchanged between the NETCONF clients and<a id="_idIndexMarker1541"/> NETCONF Agent. NETCONF operations and data that's encoded as XML are wrapped within the RPC messages. </li>
				<li><strong class="bold">Transport</strong>: This layer provides a communication path between a client and a server. NETCONF messages <a id="_idIndexMarker1542"/>can use NETCONF over SSH or NETCONF over TLS with the SSL certificate option. </li>
			</ul>
			<p>The NETCONF <a id="_idIndexMarker1543"/>protocol is based on XML messages that have been exchanged via the SSH protocol using port <code>830</code> as the default port. There are typically two types of configuration databases that are managed by network devices. The first type is called the <strong class="bold">running</strong> database, which<a id="_idIndexMarker1544"/> represents the active configuration on a device, including operation data. This is a mandatory database for each device. The second type is known as <a id="_idIndexMarker1545"/>the <strong class="bold">candidate</strong> database, which represents the candidate configuration before it can be pushed to the running database. When a candidate database exists, configuration changes are not allowed to be made directly to the running database.</p>
			<p>We will discuss how to work with NETCONF using Python in the <em class="italic">Interacting with network devices using NETCONF</em> section.</p>
			<h3>RESTCONF</h3>
			<p>RESTCONF is <a id="_idIndexMarker1546"/>another <em class="italic">IETF</em> standard that offers a subset of NETCONF functionality using the RESTful interface. Instead of <a id="_idIndexMarker1547"/>using NETCONF RPC calls with XML encoding, RESTCONF offers HTTP/HTTPS-based REST calls, with the option of using XML or JSON messages. If network devices offer the RESTCONF interface, we can use HTTP methods (<code>GET</code>, <code>PATCH</code>, <code>PUT</code>, <code>POST</code>, and <code>DELETE</code>) for network management. When RESTCONF is used for network automation, we must understand that it provides a limited NETCONF functionality over HTTP/HTTPS. NETCONF operations such as commits, rollbacks, and configuration locking are not supported through RESTCONF.</p>
			<h3>gRPC/gNMI</h3>
			<p>gNMI is a gRPC <strong class="bold">Network Management Interface</strong> (<strong class="bold">NMI</strong>). gRPC is a remote procedure call that was<a id="_idIndexMarker1548"/> developed by Google for<a id="_idIndexMarker1549"/> low-latency and highly scalable data retrieval. The gRPC protocol was developed originally for mobile clients that wanted to communicate with cloud servers with stringent latency requirements. The gRPC protocol is highly efficient for transporting structured data through <strong class="bold">protocol buffers</strong> (<strong class="bold">Protobufs</strong>), which <a id="_idIndexMarker1550"/>is a key component of this protocol. By using Protobufs, the data is packed in a binary format instead of a textual format such as JSON or XML. This format not only reduces the size of the data but is very efficient for serializing and deserializing data compared to JSON or XML. Moreover, the data is transported using HTTP/2 instead of HTTP 1.1. HTTP/2 offers both the request-response model and the bidirectional communication model. This bidirectional communication model makes it possible for clients to open long-lived connections that speed up the data transfer <a id="_idIndexMarker1551"/>process significantly. These two technologies make the gRPC protocol <em class="italic">7 to 10</em> times faster than the REST API. </p>
			<p>gNMI is a specific implementation of the gRPC protocol for network management purposes and telemetry applications. It is also a YANG model-driven protocol like NETCONF and offers very few operations compared to NETCONF. These operations include <code>Get</code>, <code>Set</code>, and <code>Subscribe</code>. gNMI is getting more popular for telemetry data collection than for <a id="_idIndexMarker1552"/>network management. The main reason for this is that it does not provide as much flexibility as NETCONG for network configuration, but it is an optimized protocol when it comes to collecting data from a remote system, especially in real time or near-real time.</p>
			<p>Next, we will discuss Python libraries for interacting with network devices. </p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor337"/>Interacting with network devices using SSH-based Python libraries</h2>
			<p>There are <a id="_idIndexMarker1553"/>several Python libraries available for interacting with network devices using SSH. Paramiko, Netmiko, and NAPALM are three popular libraries that are available, and we will explore them in the next subsections. We will start with Paramiko. </p>
			<h3>Paramiko</h3>
			<p>The <a id="_idIndexMarker1554"/>Paramiko library is an abstraction of the SSH v2 protocol in Python and includes both<a id="_idIndexMarker1555"/> server-side and client-side functionality. We will only focus on the client-side capabilities of the Paramiko library here. </p>
			<p>When we interact with a network device, we either try to get configuration data, or we push a new configuration for certain objects. The former is achieved with <em class="italic">show</em> types of CLI commands, as per the operating system of the device, while the latter may require a special mode for executing the configuration CLI commands. These two types of commands are handled differently when working through Python libraries. </p>
			<h4>Fetching device configuration</h4>
			<p>To connect to a<a id="_idIndexMarker1556"/> network device (listening as an SSH server) using the Paramiko library, we must use an instance of the <code>paramiko.SSHClient</code> class or directly use a low-level <code>paramiko.Transport</code> class. The <code>Transport</code> class offers low-level methods that provide direct control over sockets-based communication. The <code>SSHClient</code> class is a wrapper class and uses the <code>Transport</code> class under the hood to manage a session, with an SSH server implemented on a network device. </p>
			<p>We can use the Paramiko library to establish a connection with a network device (Cisco IOS XR, in our case) and to run a show command (<code>show ip int brief</code>, in our case) like so: </p>
			<pre>#<strong class="bold">show_cisco_int_pmk.py</strong>
import paramiko
host='HOST_ID'
port=22
username='xxx'
password='xxxxxx'
#cisco ios command to get a list of IP interfaces
cmd= '<strong class="bold">show ip int brief </strong>\n'
def main():
    try:
        ssh = paramiko.<strong class="bold">SSHClient</strong>()
        ssh.set_missing_host_key_policy(paramiko.          AutoAddPolicy())
        ssh.<strong class="bold">connect</strong>(host, port, username, password)
        stdin, stdout, stderr = ssh.<strong class="bold">exec_command</strong>(cmd)
        output_lines = stdout.<strong class="bold">readlines</strong>()
        response = ''.join(output_lines)
        print(response)
    finally:
        ssh.close()
if __name__ == '__main__':
    main()</pre>
			<p>The key points of<a id="_idIndexMarker1557"/> this code example are as follows: </p>
			<ul>
				<li>We created an <code>SSHClient</code> instance and opened a connection with the SSH server. </li>
				<li>Since we are not using the host key for our SSH connection, we applied the <code>set_missing_host_key_policy</code> method to avoid any warnings or errors. </li>
				<li>Once the SSH connection had been established, we sent our show command, <code>show ip int brief</code>, to the host machine using SSH transport and received the output of the command as an SSH reply. </li>
				<li>The output of this program is a tuple of <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> objects. If our command is executed successfully, we will retrieve the output from the <code>stdout</code> object. </li>
			</ul>
			<p>The output of this program, when executed on a Cisco IOS XR device, is as follows: </p>
			<pre>Mon Jul 19 12:03:41.631 UTC
Interface                   IP-Address      Status    Protocol 
Loopback0                   10.180.180.10   Up        Up
GigabitEthernet0/0/0/0      10.1.10.2       Up        Up
GigabitEthernet0/0/0/0.100  unassigned      Up        Down
GigabitEthernet0/0/0/1      unassigned      Up        Up
GigabitEthernet0/0/0/1.100  150.150.150.1   Up        Up
GigabitEthernet0/0/0/2      unassigned      Shutdown  Down </pre>
			<p>If you are running this program on another device type, you must change the command that has been set as the <code>cmd</code> variable, as per your device's type.</p>
			<p>The<a id="_idIndexMarker1558"/> Paramiko library provides low-level control over network communication, but it can sometimes be quirky due to the non-standard or incomplete implementation of the SSH protocol by many network devices. If you face challenges in using Paramiko with some network devices, it is not you or Paramiko but the way the device expects you to communicate with it. A low-level transport channel can solve these issues, but this requires a bit of complex programming. Netmiko comes to the rescue here. </p>
			<h3>Netmiko</h3>
			<p>Netmiko<a id="_idIndexMarker1559"/> is an abstracted library for network management that is built on top of the Paramiko library. It eliminates the challenges of Paramiko by treating every network<a id="_idIndexMarker1560"/> device differently. Netmiko uses Paramiko under the hood and hides many device-level communication details. Netmiko supports several devices from different vendors, such as Cisco, Arista, Juniper, and Nokia.</p>
			<h4>Fetching device configuration</h4>
			<p>To connect to a <a id="_idIndexMarker1561"/>network device using the show type of CLI commands, we must set a <code>device_type</code> definition that is used to connect with the target network device. This <code>device_type</code> definition is a dictionary that must include the device's type, the host IP or the device's <code>22</code>. The following code can be used to execute the same <code>show</code> command that we executed with the Paramiko library: </p>
			<pre>#<strong class="bold">show_cisco_int_nmk.py</strong>
from netmiko import ConnectHandler
cisco_rtr = {
    "device_type": "<strong class="bold">cisco_ios</strong>",
    "host": "HOST_ID",
    "username": "xxx",
    "password": "xxxxxxx",
    #"global_delay_factor": 2,
}
def main():
    command = "<strong class="bold">show ip int brief</strong>"
    with <strong class="bold">ConnectHandler</strong>(**cisco_rtr) as net_connect:
        print(net_connect.find_prompt())
        print(net_connect.enable())
        output = net_connect.<strong class="bold">send_command</strong>(command)
    print(output)</pre>
			<p>The key points of this<a id="_idIndexMarker1563"/> example code are as follows: </p>
			<ul>
				<li>We created a network connection using the <code>ConnectHandler</code> class using a context manager. The context manager will manage the life cycle of the connection.</li>
				<li>Netmiko offers a simple method called <code>find_prompt</code> for grabbing the prompt of the target device, which is useful for parsing the output of many network devices. This is not required for the <em class="italic">Cisco IOS XR</em> network device but we used it as a best practice.</li>
				<li>Netmiko also allows us to enter <em class="italic">Enable</em> mode (it is a command-line prompt, <code>#</code>) for Cisco IOS devices by using the <code>enable</code> method. Again, this is not required for this example, but it is a best practice to use it, especially in cases where we are pushing CLI commands for configuration as part of the same programming script. </li>
				<li>We executed the <code>show ip int brief</code> command using the <code>send_command</code> method and got the same output that we did for the <code>show_cisco_int_pmk.py</code> program. </li>
			</ul>
			<p>Based on the code example we shared for the same <code>show</code> command, we can conclude that working with Netmiko is much more convenient compared to Paramiko.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">It is very important to set the correct device type for consistent results, even if you are using devices from the same vendor. This is especially important when using commands for configuring a device. An incorrect device type can give inconsistent errors.  </p>
			<p>Sometimes, we execute<a id="_idIndexMarker1564"/> commands that require more time to complete than normal <code>show</code> commands. For example, we may want to copy a file from one location to the other on a device, and we know this can take a few hundred seconds for a large file. By default, Netmiko waits nearly <em class="italic">100</em> seconds for a command to complete. We can add a global delay factor as part of the device definition by adding a line like the following:</p>
			<pre>"global_delay_factor": 2</pre>
			<p>This will increase the wait time for all the commands for this device by a factor of 2. Alternatively, we can set the delay factor for an individual command with the <code>send_command</code> method by passing the following argument:</p>
			<pre>delay_factor=2 </pre>
			<p>We should be adding a delay factor when we expect a significant execution time. When we have to add a delay factor, we should also be adding another attribute as an argument with the <code>send_command</code> method, which will break the wait cycle early if we see a command prompt (for example, <code>#</code> in the case of Cisco IOS devices). This can be set by using the following attribute: </p>
			<pre>expect_string=r'#'</pre>
			<h4>Configuring a network device</h4>
			<p>In the following code <a id="_idIndexMarker1565"/>example, we will provide some sample code for configuration purposes. Configuring a device using Netmiko is similar to executing <code>show</code> commands as Netmiko will take care of enabling the configuration terminal (if required, as per the device type) and exiting out of the configuration terminal gracefully.  </p>
			<p>For our code example, we will set a <code>description</code> of an interface using Netmiko with the following program:</p>
			<pre>#<strong class="bold">config_cisco_int_nmk.py</strong>
from netmiko import ConnectHandler
cisco_rtr = {
    "device_type": "<strong class="bold">cisco_ios</strong>",
    "host": "HOST_ID",
    "username": "xxx",
    "password": "xxxxxx",
}
def main():
    commands = ["<strong class="bold">int Lo0</strong> "<strong class="bold">description custom_description</strong>",       "<strong class="bold">commit</strong>"]
    with ConnectHandler(<strong class="bold">**cisco_rtr</strong>) as net_connect:
        output = net_connect.<strong class="bold">send_config_set</strong>(commands)
    print(output)
    print()</pre>
			<p>The key points of this <a id="_idIndexMarker1566"/>code example are as follows: </p>
			<ul>
				<li>For this program, we created a list of three commands (<code>int &lt;interface id&gt;</code>, <code>description &lt;new description&gt;</code>, and <code>commit</code>). The first two commands can be sent as a single command as well, but we have kept them separate for illustration purposes. The <code>commit</code> command is used to save changes. </li>
				<li>When we send a command to the device for configuration, we use the <code>send_config_set</code> method from the Netmiko library to set up a connection for configuration purposes. Successfully executing this step depends on the correct setting of the device type. This is because the device behavior varies from one device to the other for the configuration commands. </li>
				<li>The set of three commands will add or update the <code>description</code> attribute for the specified interface. </li>
			</ul>
			<p>No special output will be <a id="_idIndexMarker1567"/>expected from this program, except that the device config prompts with our commands. The console output will look as follows: </p>
			<pre>Mon Jul 19 13:21:16.904 UTC
RP/0/RP0/CPU0:cisco(config)#int Lo0
RP/0/RP0/CPU0:cisco(config-if)#description custom_description
RP/0/RP0/CPU0:cisco(config-if)#commit
Mon Jul 19 13:21:17.332 UTC
RP/0/RP0/CPU0:cisco(config-if)#</pre>
			<p>Netmiko offers a lot more functionality, but we will leave this for you to explore by reading its official<a id="_idIndexMarker1568"/> documentation (<a href="https://pypi.org/project/netmiko/">https://pypi.org/project/netmiko/</a>). The code examples we've discussed in this section have been tested with a Cisco network device, but the same program can be used by changing the device type and the commands for any other device if the device is supported by Netmiko. </p>
			<p>Netmiko simplifies our code for network device interaction, but we are still running the CLI commands for fetching the device configuration or pushing the configuration toward the device. Programmability is not easily to do with Netmiko, but another library called NAPALM is there to help. </p>
			<h3>NAPALM</h3>
			<p><strong class="bold">NAPALM</strong> is an <a id="_idIndexMarker1569"/>acronym for <strong class="bold">Network Automation and Programmability Abstraction Layer with Multivendor</strong>. This library provides the next level of abstraction on top of Netmiko by offering a set of functions as a unified API to interact with several network devices. It does not support as many devices as Netmiko. For release 3 of NAPALM, core drivers are available <a id="_idIndexMarker1570"/>for the <strong class="bold">Arista EOS</strong>, <strong class="bold">Cisco IOS</strong>, <strong class="bold">Cisco IOS-XR</strong>, <strong class="bold">Cisco NX-OS</strong>, and <strong class="bold">Juniper JunOS</strong> network devices. However, there<a id="_idIndexMarker1571"/> are several <a id="_idIndexMarker1572"/>community-built <a id="_idIndexMarker1573"/>drivers available <a id="_idIndexMarker1574"/>for communicating <a id="_idIndexMarker1575"/>with <a id="_idIndexMarker1576"/>many <a id="_idIndexMarker1577"/>other devices, such as <strong class="bold">Nokia SROS</strong>, <strong class="bold">Aruba AOS-CX</strong>, and <strong class="bold">Ciena SAOS</strong>. </p>
			<p>As we did for Netmiko, we will build NAPALM examples for interacting with a network device. In the first example, we will get a list of IP interfaces, while for the second example, we will add or update the <code>description</code> attribute for an IP interface. These two code examples will perform the same operations that we performed using the Paramiko and Netmiko libraries. </p>
			<h4>Fetching device configuration</h4>
			<p>To fetch a <a id="_idIndexMarker1578"/>device configuration, we must set up the connection to our network device. We will do this in both code examples. Setting up a connection is a three-step process, as explained here: </p>
			<ol>
				<li>To set up a connection, we must get a device driver class based on the supported device type. This can be achieved using the <code>get_network_driver</code> function of the NAPALM library.</li>
				<li>Once we have a device driver class, we can create a device object by providing arguments such as <code>host id</code>, <code>username</code>, and <code>password</code> to the driver class constructor.</li>
				<li>The next step is to connect to the device using the <code>open</code> method of the device object. All these steps can be implemented as Python code, as shown here:<pre>from napalm import get_network_driver 
driver = <strong class="bold">get_network_driver</strong>('iosxr')
device = <strong class="bold">driver</strong>('HOST_ID', 'xxxx', 'xxxx')
device.open()</pre></li>
			</ol>
			<p>Once the device's connection is available, we can call methods such as <code>get_interfaces_ip</code> (equivalent to the <code>show interfaces</code> CLI command) or <code>get_facts</code> (equivalent to the <code>show version</code> CLI command). The complete code for using these two <a id="_idIndexMarker1579"/>methods is as follows: </p>
			<pre>#<strong class="bold">show_cisco_int_npm.py</strong>
from napalm import get_network_driver
import json
def main():
    driver = <strong class="bold">get_network_driver</strong>('iosxr')
    device = <strong class="bold">driver</strong>('HOST_ID', 'root', 'rootroot')
    try:
        device.open()
        print(json.dumps(device.<strong class="bold">get_interfaces_ip</strong>(), indent=2))
        #print(json.dumps(device.<strong class="bold">get_facts</strong>(), indent=2))
    finally:
        device.close()</pre>
			<p>The most interesting fact is that the output of this program is in JSON format by default. NAPALM converts the<a id="_idIndexMarker1580"/> CLI command's output into a dictionary by default that is easy to consume in Python. An excerpt of the output for the previous code example is shown here:</p>
			<pre>{
  "Loopback0": {
    "ipv4": {
      "10.180.180.180": {
        "prefix_length": 32
      }
    }
  },
  "MgmtEth0/RP0/CPU0/0": {
    "ipv4": {
      "172.16.2.12": {
        "prefix_length": 24
      }
    }
  }
}</pre>
			<h4>Configuring a network device</h4>
			<p>In the <a id="_idIndexMarker1581"/>following code example, we are using the NAPALM library to add or update the <code>description</code> attribute for an existing IP interface:</p>
			<pre>#<strong class="bold">config_cisco_int_npm.py</strong>
from napalm import get_network_driver
import json
def main():
    driver = get_network_driver('iosxr')
    device = driver('HOST_ID', 'xxx', 'xxxx')
    try:
        device.open()
        device.<strong class="bold">load_merge_candidate</strong>(config='interface Lo0 \n            description napalm_desc \n end\n')
        print(device.<strong class="bold">compare_config()</strong>)
        device.<strong class="bold">commit_config</strong>()
    finally:
        device.close()</pre>
			<p>The key points of this code example are as follows: </p>
			<ul>
				<li>To configure the IP interface, we must use the <code>load_merge_candidate</code> method and pass the same set of CLI commands to this method as we did for the interface configuration with Netmiko. </li>
				<li>Next, we<a id="_idIndexMarker1582"/> compared the configs before our commands and after the commands using the <code>compare_config</code> method. This indicates what new configuration has been added and what has been removed.</li>
				<li>We applied a commit to all the changes using the <code>commit_config</code> method.</li>
			</ul>
			<p>For this example code, the output will show the delta of changes, like so:</p>
			<pre>--- 
+++ 
@@ -47,7 +47,7 @@
  !
 !
 interface Loopback0
- description my custom description
+ description napalm added new desc 
  ipv4 address 10.180.180.180 255.255.255.255
 !
 interface MgmtEth0/RP0/CPU0/0</pre>
			<p>Here, the line that starts with <code>-</code> is a configuration to be removed; any line with <code>+</code> at the start is a new configuration to be added. </p>
			<p>With these two <a id="_idIndexMarker1583"/>code examples, we have showed you a basic set of NAPALM features for one device type. The library can be used to configure multiple devices at a time and can work with different sets of configurations. </p>
			<p>In the next section, we will discuss interacting with network devices using the NETCONF protocol. </p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor338"/>Interacting with network devices using NETCONF</h2>
			<p>NETCONF was <a id="_idIndexMarker1584"/>created for model (object)-driven network management, especially for network configuration. When working with a network device using NETCONF, it is important to understand two capabilities of the device, as follows: </p>
			<ul>
				<li>You can understand the YANG models of the devices you have. Having this knowledge is important if you wish to send the messages in the correct format. Here is an excellent source of YANG models<a id="_idIndexMarker1585"/> from various vendors: <a href="https://github.com/YangModels/yang">https://github.com/YangModels/yang</a>.</li>
				<li>You can enable the NETCONF and SSH ports for the NETCONF protocol on the network device for your network device. In our case, we will be using a virtual device from Cisco IOS XR, as we did in our previous code examples. </li>
			</ul>
			<p>Before starting any network management-related activity, we must check the device's NETCONF capabilities and the details of the NETCONF data source's configuration. For all the code examples in this section, we will use a NETCONF client library for Python known as <code>ncclient</code>. This library provides convenient methods for sending NETCONF RPC requests. We can write a sample Python program using the <code>ncclient</code> library to get the device's capabilities and the device's full configuration, as follows:</p>
			<pre>#<strong class="bold">check_cisco_device.py</strong>
from ncclient import manager
with <strong class="bold">manager.connect</strong>(host='device_ip, username=xxxx,   password=xxxxxx, hostkey_verify=False) as conn:
   capabilities = []
   for capability in conn.<strong class="bold">server_capabilities</strong>:
      capabilities.append(capability)
   capabilities = sorted(capabilities)
   for cap in capabilities:
     print(cap)
   result = conn.<strong class="bold">get_config</strong>(source="running")
   print (result)</pre>
			<p>The <code>manager</code> object from the <code>ncclient</code> library is used to connect to the device using SSH but for NETCONF port <code>830</code> (default). First, we get a list of server capabilities through the connection<a id="_idIndexMarker1586"/> instance and then print them in a sorted format for the convenience of reading. In the next part of this code example, we initiated a <code>get-config</code> NETCONF operation by using the <code>get_config</code> method of the <code>manager</code> class library. The output of this program is very long and displays all the capabilities and the device configuration. We leave it to you to explore the output and become familiar with your device's capabilities. </p>
			<p>It is important to understand that the scope of this section is not to explain NETCONF but to learn how to use Python and <code>ncclient</code> to work with NETCONF. To achieve this goal, we will write two code examples: one for fetching the configuration of device interfaces and another on how to update the description of an interface, which is the same as what we did for the previous Python libraries. </p>
			<h3>Getting interfaces via NETCONF</h3>
			<p>In the <a id="_idIndexMarker1587"/>previous section, we learned that our device (Cisco IOS XR) supports<a id="_idIndexMarker1588"/> interfaces by using the <strong class="bold">OpenConfig</strong> implementation, which is <a id="_idIndexMarker1589"/>available at <a href="http://openconfig.net/yang/interfaces?module=openconfig-interfaces">http://openconfig.net/yang/interfaces?module=openconfig-interfaces</a>.</p>
			<p>We can also check the XML format of our interface's configuration, which we received as the output of the <code>get_config</code> method. In this code example, we will simply pass an XML filter with interface configuration as an argument to the <code>get_config</code> method, as follows: </p>
			<pre>#<strong class="bold">show_all_interfaces.py</strong>
from ncclient import manager
with manager.connect(host='device_ip', username=xxx,                password='xxxx', hostkey_verify=False) as conn:
    result = conn.<strong class="bold">get_config</strong>("running", filter=('subtree', 
    '<strong class="bold">&lt;interfaces xmlns= "http://openconfig.net/yang/      interfaces"/&gt;</strong>'))
    print (result)</pre>
			<p>The <a id="_idIndexMarker1590"/>output of this program is a list of interfaces. We will <a id="_idIndexMarker1591"/>only show an excerpt of the output here for illustration purposes:</p>
			<pre>&lt;rpc-reply message-id="urn:uuid:f4553429-ede6-4c79-aeea-5739993cacf4" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"&gt;
 &lt;data&gt;
  &lt;interfaces xmlns="http://openconfig.net/yang/interfaces"&gt;
   &lt;interface&gt;
    &lt;name&gt;Loopback0&lt;/name&gt;
    &lt;config&gt;
     &lt;name&gt;Loopback0&lt;/name&gt;
     &lt;description&gt;Configured by NETCONF&lt;/description&gt;
    &lt;/config&gt;
&lt;!—rest of the output is skipped --&gt;</pre>
			<p>To get a selective set of interfaces, we will use an extended version of the XML filter based on the interface's YANG model. For the following code example, we will define an XML filter with the <code>name</code> properties of the interfaces as our filtering criteria. Since this XML filter is more<a id="_idIndexMarker1592"/> than one line, we will define it separately as a<a id="_idIndexMarker1593"/> string object. Here is the sample code with the XML filter: </p>
			<pre>#<strong class="bold">show_int_config.py</strong>
from ncclient import manager
# Create filter template for an interface
filter_temp = """
&lt;filter&gt;
    &lt;interfaces xmlns="<strong class="bold">http://openconfig.net/yang/interfaces</strong>"&gt;
        &lt;interface&gt;
            &lt;name&gt;<strong class="bold">{int_name}</strong>&lt;/name&gt;
        &lt;/interface&gt;
    &lt;/interfaces&gt;
&lt;/filter&gt;"""
with manager.connect(host='device_ip', username=xxx,                password='xxxx', hostkey_verify=False) as conn:
    filter = filter_temp.<strong class="bold">format</strong>(int_name = "MgmtEth0/RP0/      CPU0/0")
    result = m.<strong class="bold">get_config</strong>("running", <strong class="bold">filter</strong>)
    print (result)</pre>
			<p>The output <a id="_idIndexMarker1594"/>of this program will be a single interface (as per the configuration in our device) and <a id="_idIndexMarker1595"/>look as follows:</p>
			<pre>&lt;?xml version="1.0"?&gt;
&lt;rpc-reply message-id="urn:uuid:c61588b3-1bfb-4aa4-a9de-2a98727e1e15" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"&gt;
 &lt;data&gt;
  &lt;interfaces xmlns="http://openconfig.net/yang/interfaces"&gt;
   &lt;interface&gt;
    &lt;name&gt;MgmtEth0/RP0/CPU0/0&lt;/name&gt;
    &lt;config&gt;
     &lt;name&gt;MgmtEth0/RP0/CPU0/0&lt;/name&gt;
    &lt;/config&gt;
    &lt;ethernet xmlns="http://openconfig.net/yang/interfaces/      ethernet"&gt;
     &lt;config&gt;
      &lt;auto-negotiate&gt;false&lt;/auto-negotiate&gt;
     &lt;/config&gt;
    &lt;/ethernet&gt;
    &lt;subinterfaces&gt;
     &lt;@!— ommitted sub interfaces details to save space --&gt;
    &lt;/subinterfaces&gt;
   &lt;/interface&gt;
  &lt;/interfaces&gt;
 &lt;/data&gt;
&lt;/rpc-reply&gt;</pre>
			<p>We can define XML filters in an XML file as well and then read the file's contents into a string object in the Python program. Another option is to use <em class="italic">Jinja</em> templates if we are planning to use filters extensively. </p>
			<p>Next, we will discuss how to update an interface's description. </p>
			<h3>Updating the interface's description</h3>
			<p>To configure<a id="_idIndexMarker1596"/> an interface attribute such as <code>description</code>, we must use the YANG model available at <a href="http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg">http://cisco.com/ns/yang/Cisco-IOS-XR-ifmgr-cfg</a>.</p>
			<p>Moreover, the XML block for configuring an interface is different than the XML block we used for getting the interface's configuration. For updating an interface, we must use the following template, which we have defined in a separate file:</p>
			<pre>&lt;!--<strong class="bold">config-template.xml</strong>--&gt;
&lt;config xmlns:xc="urn:ietf:params:xml:ns:netconf:base:1.0"&gt;
 &lt;<strong class="bold">interface-configurations</strong> xmlns="<strong class="bold">http://cisco.com/ns/yang/  Cisco-IOS-XR-ifmgr-cfg</strong>"&gt;
   &lt;<strong class="bold">interface-configuration</strong>&gt;
    &lt;active&gt;act&lt;/active&gt;
    &lt;interface-name&gt;<strong class="bold">{int_name}</strong>&lt;/interface-name&gt;
    &lt;description&gt;<strong class="bold">{int_desc}&lt;/</strong>description&gt;
   &lt;/interface-configuration&gt;
 &lt;/interface-configurations&gt;
&lt;/config&gt;</pre>
			<p>In this template, we set the placeholders for the <code>name</code> and <code>description</code> properties of the interface. Next, we will write a Python program that will read this template and call the <code>edit-config</code> NETCONF operation by using the <code>edit_config</code> method of the <code>ncclient</code> library. This will push the template to the candidate database of the device:</p>
			<pre>#<strong class="bold">config_cisco_int_desc.py</strong>
from ncclient import manager
nc_template = open("config-template.xml").<strong class="bold">read</strong>()
nc_payload = <strong class="bold">nc_template.format</strong>(int_name='Loopback0',                          int_desc="Configured by NETCONF")
with manager.connect(host='device_ip, username=xxxx,                     password=xxx, hostkey_verify=False) as nc:
    netconf_reply = <strong class="bold">nc.edit_config</strong>(nc_payload,       target="candidate")
    print(netconf_reply)
    reply = <strong class="bold">nc.commit</strong>()
    print(reply)</pre>
			<p>It is important to<a id="_idIndexMarker1597"/> highlight two things here. First, the Cisco IOS XR device has been configured to only accept the new configuration through the candidate database. If we try to set the <code>target</code> attribute to <code>running</code>, it will fail. Second, we must call the <code>commit</code> method after the <code>edit-config</code> operation in the same session to make the new configuration operational. The output of this program will be two OK replies from the NETCONF server, as follows:</p>
			<pre>&lt;?xml version="1.0"?&gt;
&lt;rpc-reply message-id="urn:uuid:6d70d758-6a8e-407d-8cb8-10f500e9f297" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"&gt;
 &lt;ok/&gt;
&lt;/rpc-reply&gt;
&lt;?xml version="1.0"?&gt;
&lt;rpc-reply message-id="urn:uuid:2a97916b-db5f-427d-9553-de1b56417d89" xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"&gt;
 &lt;ok/&gt;
&lt;/rpc-reply&gt;</pre>
			<p>This concludes <a id="_idIndexMarker1598"/>our discussion of using Python for NETCONF operations. We covered two main operations (<code>get-config</code> and <code>edit-config</code>) of NETCONF with the <code>ncclient</code> library.</p>
			<p>In the next section, we will look at integrating with network management systems using Python.</p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor339"/>Integrating with network management systems</h1>
			<p>Network management systems or network controllers are systems that offer network management applications<a id="_idIndexMarker1599"/> with <strong class="bold">graphical user interfaces</strong> (<strong class="bold">GUIs</strong>). These<a id="_idIndexMarker1600"/> systems include applications such as network inventory, network provisioning, fault management, and mediation with network devices. These systems communicate with network devices using a combination of communication protocols such as SSH/NETCONF for network provisioning, SNMP for alarms and device monitoring, and gRPC for telemetry data collection. These systems also offer automation capabilities through their scripting and workflow engines. </p>
			<p>The most value-added aspect of these systems is that they aggregate the network device's functionality into a single system (itself) and then offer it through its <strong class="bold">North Bound Interfaces</strong> (<strong class="bold">NBIs</strong>), which are<a id="_idIndexMarker1601"/> typically REST or RESTCONF interfaces. These systems also offer notifications of real-time events such as alarms through an event-based system such as Apache Kafka. In this section, we will discuss a couple of examples of using the REST API of a NMS We will explore how to integrate with Apache Kafka using Python in <em class="italic">Integrating with event driven systems</em> section. </p>
			<p>To work with a NMS we will use a shared lab offered by Nokia's online developer portal (<a href="https://network.developer.nokia.com/">https://network.developer.nokia.com/</a>). This lab has a few Nokia IP routers and an NSP. This shared lab is offered free of charge for a limited time (3 hours per day at the time of writing this book). You will be required to create an account with the developer portal free of charge. When you book a lab for use, you will receive an email with instructions on how to connect to the lab, along with the necessary VPN details. If you are a network engineer and you have access to any other NMS or a controller, you can use that system for the exercises in this section by making the appropriate adjustments. </p>
			<p>To consume a REST <a id="_idIndexMarker1602"/>API from Nokia NSP, we need to interact with the REST API Gateway, which manages several API endpoints for Nokia NSP. We can start working with the REST API Gateway by using location services, as explained next. </p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor340"/>Using location services endpoints</h2>
			<p>To understand what <a id="_idIndexMarker1603"/>API endpoints are available, Nokia NSP offers a location services endpoint that provides a list of all API endpoints. To consume any REST API in this section, we will use the <code>requests</code> library from Python. The <code>requests</code> library is well-known for sending HTML requests to a server using the HTTP protocol, and we have used it in previous chapters. To get a list of API endpoints from the Nokia NSP system, we will use the following Python code to invoke a location services API:</p>
			<pre>#<strong class="bold">location_services1.py</strong>
import requests
payload = {}
headers = {}
url = "https://&lt;NSP URL&gt;/rest-gateway/rest/api/v1/<strong class="bold">location/  services</strong>"
resp = requests.request("GET", url, headers=headers,   data=payload)
print(resp.text)</pre>
			<p>This API response will provide you with a few dozen API endpoints in JSON format. You can check the online documentation of Nokia NSP at <a href="https://network.developer.nokia.com/api-documentation/">https://network.developer.nokia.com/api-documentation/</a> to understand how each API works. If we are looking for a specific API endpoint, we can change the value of the <code>url</code> variable in the aforementioned code example, as follows:</p>
			<pre>url = "https://&lt;NSP URL&gt;/rest-gateway/rest/api/v1/ location/services/endpoints?endPoint=/v1/auth/token</pre>
			<p>By using this new API URL, we <a id="_idIndexMarker1604"/>are trying to find an API endpoint for the authorization token (<code>/v1/auth/token</code>). The output of the code example with this new URL is as follows: </p>
			<pre>{ 
 "response": { 
  "status": 0, 
  "startRow": 0, 
  "endRow": 0, 
  "totalRows": 1, 
  "data": { 
   "endpoints": [ 
    { 
    "docUrl":"https://&lt;NSP_URL&gt;/rest-gateway/api-docs#!/      authent..", 
    "effectiveUrl": "https://&lt;NSP_URL&gt;/rest-gateway/rest/api", 
    "operation": "[POST]" 
    } 
   ] 
  }, 
  "errors": null 
 } 
}</pre>
			<p>Note that no authentication is required to use the location services API. However, we will need an authentication token to call any other API. In the next section, we will learn how to get an authentication token.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor341"/>Getting an authentication token</h2>
			<p>As a next step, we <a id="_idIndexMarker1605"/>will use <code>effectiveUrl</code> from the output of the previous code example to get the authentication token. This API requires that we pass the <em class="italic">base64</em> encoding of <code>username</code> and <code>password</code> as the <code>Authorization</code> attribute of the HTTP header. The Python code to call this authentication API is as follows: </p>
			<pre>#<strong class="bold">get_token.py</strong>
import requests
from base64 import b64encode
import json
#getting base64 encoding 
message = 'username'+ ':' +'password'
message_bytes = message.encode('UTF-8')
basic_token = <strong class="bold">b64encode</strong>(message_bytes)
payload = json.dumps({
  "grant_type": "client_credentials"
})
headers = {
  'Content-Type': 'application/json',
  'Authorization': 'Basic {}'.format(str(basic_token,'UTF-8'))
}
url = "https://<strong class="bold">&lt;NSP SERVER URL&gt;/</strong>rest-gateway/rest/api/v1/auth/  token"
resp = requests.<strong class="bold">request</strong>("POST", url, headers=headers,   data=payload)
token = resp.json()["access_token"]
print(resp)
When executing this Python code, we will get a token for one   hour to be used for any NSP API. 
{
  "access_token": "VEtOLVNBTXFhZDQ3MzE5ZjQtNWUxZjQ0YjNl",
  "refresh_token": "UkVUS04tU0FNcWF5ZlMTmQ0ZTA5MDNlOTY=",
  "token_type": "Bearer",
  "expires_in": 3600
}</pre>
			<p>There is also a refresh token available that can be used to refresh the token before it expires. A best practice is to refresh your token every <em class="italic">30</em> minutes. We can refresh our token using the same <a id="_idIndexMarker1606"/>authentication token API, but send the following attributes in the body of the HTTP request: </p>
			<pre>payload = json.dumps({
  "grant_type": "<strong class="bold">refresh_token</strong>",
  "refresh_token": "UkVUS04tU0FNcWF5ZlMTmQ0ZTA5MDNlOTY="
})</pre>
			<p>Another good practice is to revoke the token when there is no further need for it. This can be achieved by using the following API endpoint: </p>
			<pre> url = "https://&lt;NSP URL&gt;rest-gateway/rest/api/v1/<strong class="bold">auth/  revocation</strong>"</pre>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor342"/>Getting network devices and an interface inventory</h2>
			<p>Once we have received <a id="_idIndexMarker1607"/>the authentication token, we can use the REST API to get <a id="_idIndexMarker1608"/>configured data, as well as to add a new configuration. We will start with a simple code example that will get a list of all the network devices in a network that is managed by NSP. In this code example, we will use the token we have already retrieved using the token API:</p>
			<pre>#<strong class="bold">get_network_devices.py</strong>
import requests
pload={}
headers = {
  'Authorization': 'Bearer {<strong class="bold">token</strong>}'.format(token)
}
url = "https://{{NSP_URL}}:<strong class="bold">8544/NetworkSupervision/rest/api/v1/  networkElements</strong>"
response = requests.<strong class="bold">request</strong>("GET", url, headers=headers,   data=pload)
print(response.text)</pre>
			<p>The output of this program will be a list of network devices with network device attributes. We skipped showing the output due to this being a large set of data.</p>
			<p>In the following code example, we will show how to get a list of device ports (interfaces) based on a filter. Note that we can apply filters to network devices as well. For this code example, we will ask the NSP API to give us a list of ports based on the port name (<code>Port 1/1/1</code>, in our case):</p>
			<pre>#<strong class="bold">get_ports_filter.py</strong>
import requests
payload={}
headers = {
  'Authorization': 'Bearer {<strong class="bold">token</strong>}'.format(token)
}
url = "https://{{server}}:8544/NetworkSupervision/rest/api/v1/  ports?<strong class="bold">filter</strong>=(<strong class="bold">name='Port 1/1/1'</strong>)
response = requests.request("GET", url, headers=headers,   data=payload)
print(response.text)</pre>
			<p>The output of this <a id="_idIndexMarker1609"/>program will be a list of device ports called <code>Port 1/1/1</code> from <a id="_idIndexMarker1610"/>all network devices. Getting ports across multiple network devices with a single API is the real value of working with a NMS </p>
			<p>Next, we will discuss how to update a network resource using the NMS API. </p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor343"/>Updating the network device port</h2>
			<p>Creating new <a id="_idIndexMarker1611"/>objects or updating existing objects is also convenient when using the NMS API. We will implement a case of updating the port description, as we did in previous code examples, using <code>Netmiko</code>, <code>NAPALM</code>, and <code>ncclient</code>. To update a port or <a id="_idIndexMarker1612"/>interface, we will use a different API endpoint that is available from the <strong class="bold">Network Function Manager for Packet</strong> (<strong class="bold">NFMP</strong>) module. NFMP is an NMS module for Nokia network devices under the Nokia NSP platform. Let's look at the steps of updating a port description or making any change to a network resource:</p>
			<ol>
				<li value="1">To update an object or create a new object under an existing object, we will need the <code>v1/managedobjects/searchWithFilter</code> API with the<a id="_idIndexMarker1615"/> following filter criteria:<pre>#<code>fullClassNames</code>. The object's full class names are available in the Nokia NFMP object model documentation. We set <code>filterExpression</code> to search for a unique port based on the device site's ID and port name. The <code>resultFilter</code> attribute is used to limit the attributes that are returned by the API in the response. We are interested in the <code>objectFullName</code> attribute in the response of this API. </p></li>
				<li>Next, we will<a id="_idIndexMarker1616"/> use a different API endpoint called <code>v1/managedobjects/ofn</code> to update an attribute of the network object. In our case, we are only updating the description attribute. For the update operation, we must set the <code>fullClassName</code> attribute in the payload and a new value for the description attribute. For the API endpoint's URL, we will concatenate the <code>port_ofn</code> variable that we computed in the previous step. The sample code for this part of the program is as follows:<pre>#<strong class="bold">update_port_desc.py (part 2)</strong>
payload2 = json.dumps({
  "fullClassName": "equipment.PhysicalPort",
  "properties": {
    "description": "description added by a Python       program"
  }
})
url2 = "https://<strong class="bold"> NFMP_URL</strong>:8443/nfm-p/rest/api/v1/  managedobjects/"+port_ofn
response = requests.request("PUT", url2, headers=headers,   data=payload2, verify=False)
print(response.text)</pre></li>
			</ol>
			<p>Network automation<a id="_idIndexMarker1617"/> is the process of creating and updating many network objects in a specific order. For example, we can update a port before creating an IP connectivity service to connect two or more local area networks. This type of use case requires that we perform a series of tasks to update all the ports involved, as well as many other objects. With the NMS API, we can orchestrate all these tasks in a program to implement an automated process. </p>
			<p>In the next section, we will explore how to integrate with Nokia NSP or similar systems for event-driven communication. </p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor344"/>Integrating with event-driven systems </h1>
			<p>In the previous <a id="_idIndexMarker1618"/>sections, we discussed how to interact with network devices and network management systems using the request-response model. In this model, a client sends a request to a server and the server sends a response as a reply to the request. The HTTP (REST API) and SSH protocols are based on a request-response-based model. This model works well for configuring a system or getting the operational state of the network on an ad hoc basis or periodically. But what about if something happens in the network that requires the operation team's attention? For example, let's say a hardware failure on a device or a line cable has been cut. Network devices typically raise alarms in such situations, and these alarms have to reach the operator (via an email, an SMS, or a dashboard) immediately. </p>
			<p>We can use the request-response model to poll the network device every second (or every few seconds) to check if there has been any change in the state of a network device or if there is a new alarm. However, this is not an efficient use of the network device's resources and will contribute to unnecessary traffic in the network. What about if the network device or NMS itself reaches out to the interested clients whenever there is a change in the state of critical resources, or an alarm is raised? This type of model is called an <em class="italic">event-driven</em> model, and it is a popular communication approach for sending real-time events. </p>
			<p>Event-driven systems <a id="_idIndexMarker1619"/>can be implemented<a id="_idIndexMarker1620"/> either using <strong class="bold">webhooks</strong>/<strong class="bold">WebSockets</strong> or using the <strong class="bold">streaming</strong> approach. WebSockets <a id="_idIndexMarker1621"/>offers a bidirectional transport channel over HTTP 1.1 through a TCP/IP socket. Since this bidirectional connection is not using the traditional request-response model, WebSockets is an efficient approach when we want to establish a<a id="_idIndexMarker1622"/> one-to-one connection between the two systems. This is one of the best options when we need real-time communication between the two programs. WebSockets are supported by all standard browsers, including the one that's available with iPhone and Android devices. It is also a popular choice for many social media platforms, streaming applications, and online gaming.</p>
			<p>WebSockets <a id="_idIndexMarker1623"/>is a lightweight solution for getting real-time events. But when many clients are looking to receive events from one system, using a streaming approach is scalable and efficient. The streaming event-based model typically follows a publisher-subscriber design pattern and has three main components, as described here: </p>
			<ul>
				<li><strong class="bold">Topic</strong>: All<a id="_idIndexMarker1624"/> streaming messages or event notifications are stored under a topic. We can think of a topic as a directory. This topic helps us subscribe to topics of interest to help us avoid receiving all events.</li>
				<li><strong class="bold">Producer</strong>: This is a program<a id="_idIndexMarker1625"/> or piece of software that pushes the events or messages to a topic. This is also <a id="_idIndexMarker1626"/>called the <strong class="bold">publisher</strong>. In our case, it will be an NSP application. </li>
				<li><strong class="bold">Consumer</strong>: This is a <a id="_idIndexMarker1627"/>program that fetches the events or messages from a topic. This is also <a id="_idIndexMarker1628"/>called a <strong class="bold">subscriber</strong>. In our case, this will be a Python program we will write. </li>
			</ul>
			<p>Event-driven systems are <a id="_idIndexMarker1629"/>available for network devices, as well as network management systems. NMS platforms use event systems such as gRPC or SNMP to receive real-time events from network devices, and they offer aggregated interfaces for the orchestration layer or the operational or monitoring applications. For our example, we will interact with an event system from the Nokia NSP platform. The Nokia NSP system offers an event system based on Apache Kafka. Apache Kafka is <a id="_idIndexMarker1630"/>an open source piece of software that was developed in Scala and Java, and it provides the implementation of a software messaging bus that is based on the <strong class="bold">Publisher-Subscriber</strong> design pattern. Before<a id="_idIndexMarker1631"/> interacting with Apache Kafka, we will enumerate a list of key <strong class="bold">categories</strong> (a term used for topics in Apache Kafka) offered through Nokia NSP, as follows:</p>
			<ul>
				<li><code>NSP-FAULT</code>: This category covers events related to faults or alarms.</li>
				<li><code>NSP-PACKET-ALL</code>: This category is used for all network management events, including keep-alive events.</li>
				<li><code>NSP-REAL-TIME-KPI</code>: This category represents events for real-time streaming notifications. </li>
				<li><code>NSP-PACKET-STATS</code>: This category is used for statistics events.</li>
			</ul>
			<p>A full list of categories is available in Nokia NSP documentation. All these categories offer additional filters for subscribing to a certain type of event. In the context of Nokia NSP, we will be interacting with Apache Kafka to create a new subscription and then process the events from the Apache Kafka system. We will start with subscription management. </p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor345"/>Creating subscriptions for Apache Kafka</h2>
			<p>Before receiving<a id="_idIndexMarker1632"/> any event or message from Apache Kafka, we <a id="_idIndexMarker1633"/>must subscribe to a topic or a category. Note that one subscription is only valid for one category. A subscription typically expires after 1 hour, so it is recommended to renew a subscription 30 minutes before its expiry time.  </p>
			<p>To create a new subscription, we will use the <code>v1/notifications/subscriptions</code> API and the following sample code to get a new subscription:</p>
			<pre>#<strong class="bold">subscribe.py</strong>
import requests
token = &lt;token obtain earlier&gt;
url = "https://NSP_URL:8544/nbi-notification/api/<strong class="bold">v1/  notifications/subscriptions</strong>"
def create_subscription(<strong class="bold">category</strong>):
  headers = {'Authorization': 'Bearer {}'.format(token) }
  payload = {
      "categories": [
        {
          "name": "{}".format(<strong class="bold">category</strong>)
        }
      ]
  }
  response = requests.request("POST", url, json=payload,                               headers=headers, verify=False)
  print(response.text)
if __name__ == '__main__':
      create_subscription("<strong class="bold">NSP-PACKET-ALL</strong>")</pre>
			<p>The <a id="_idIndexMarker1634"/>output of this program will include important attributes <a id="_idIndexMarker1635"/>such as <code>subscriptionId</code> , <code>topicId</code>, and <code>expiresAt</code>, among others, as shown here:</p>
			<pre>{
   "response":{
      "status":0,
      "startRow":0,
      "endRow":0,
      "totalRows":1,
      "data": {
         "subscriptionId":"440e4924-d236-4fba-b590-           a491661aae14",
         "clientId": null,
         "topicId":"ns-eg-440e4924-d236-4fba-b590-           a491661aae14",
         "timeOfSubscription":1627023845731,
         "expiresAt":1627027445731,
         "stage":"ACTIVE",
         "persisted":true
      },
      "errors":null
   }
}</pre>
			<p>The <code>subscriptionId</code> attribute is used to renew or delete a subscription later. Apache Kafka will create a topic specifically for this subscription. It is provided to us as a <code>topicId</code> attribute. We <a id="_idIndexMarker1636"/>will use this <code>topicId</code> attribute to connect <a id="_idIndexMarker1637"/>to Apache Kafka to receive events. This explains why we call general topics categories in Apache Kafka. The <code>expiresAt</code> attribute indicates the time this subscription will expire. </p>
			<p>Once a subscription is ready, we can connect to Apache Kafka to receive events, as explained in the next subsection.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor346"/>Processing events from Apache Kafka</h2>
			<p>Writing a <a id="_idIndexMarker1638"/>basic Kafka consumer takes no more than a <a id="_idIndexMarker1639"/>few lines of Python code with the <code>kafka-python</code> library. To create a Kafka client, we will use the <code>KafkaConsumer</code> class from the <code>kafka-python</code> library. We can use the following sample code to consume events for our subscription topic:</p>
			<pre>#<strong class="bold">basic_consumer.py</strong>
topicid = 'ns-eg-ff15a252-f927-48c7-a98f-2965ab6c187d'
consumer = KafkaConsumer(topic_id,
                         group_id='120',
                         bootstrap_servers=[host_id], value_                          deserializer=lambda m: json.loads                          (m.decode('ascii')),
                         api_version=(0, 10, 1))
try:
    for message in consumer:
        if message is None:
            continue
        else:
            print(json.dumps(message.value, indent=4, sort_              keys=True))
except KeyboardInterrupt:
    sys.stderr.write('++++++ Aborted by user ++++++++\n')
finally:
    consumer.close()</pre>
			<p>It is important to note that you must use the <code>kafka-python</code> library if you are using Python 3.7 or later. If you are using a version of Python that's earlier than 3.7, you can use the <code>kafka</code> library. There are known issues with the <code>kafka</code> library if we use it with Python 3.7 or later. For example, there is a known issue that <code>async</code> has become a keyword in Python 3.7 or later releases, but it has been used as a variable in the <code>kafka</code> library. There are also API version issues when using the <code>kafka-python</code> library with Python 3.7 or later. These can be avoided by setting a correct API version as an argument (the <code>0.10.0</code> version, in this case). </p>
			<p>In this section, we showed you a basic Kafka consumer, but you can explore a more sophisticated example in the source code provided with this book by going to <a href="https://github.com/nokia/NSP-Integration-Bootstrap/tree/master/kafka/kafka_cmd_consumer">https://github.com/nokia/NSP-Integration-Bootstrap/tree/master/kafka/kafka_cmd_consumer</a>.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor347"/>Renewing and deleting a subscription</h2>
			<p>We can renew <a id="_idIndexMarker1640"/>a subscription with the Nokia NSP Kafka system using the same API endpoint that we used to create a subscription. We will add the <code>subscriptionId</code> attribute at the end of the URL, along with the <code>renewals</code> resource, as follows:</p>
			<pre>https://{{server}}:8544/nbi-notification/api/v1/notifications/subscriptions/&lt;subscriptionId&gt;/renewals</pre>
			<p>We can<a id="_idIndexMarker1641"/> delete a subscription using the same API endpoint with the <code>subscriptionId</code> attribute at the end of the URL but using the HTTP <code>Delete</code> method. This API endpoint will look as follows for a delete request: </p>
			<pre>https://{{server}}:8544/nbi-notification/api/v1/notifications/subscriptions/&lt;subscriptionId&gt;</pre>
			<p>In both cases, we will not send any arguments in the request body.</p>
			<p>This concludes our discussion on integrating with NMS and network controllers using both the request-response model and the event-driven model. Both these approaches will give you a good starting point when it comes to integrating with other management systems.</p>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor348"/>Summary</h1>
			<p>In this chapter, we introduced network automation, along with its benefits and the challenges it provides for telecom service providers. We also discussed the key use cases of network automation. After this introduction, we discussed the transport protocols that are available for network automation to interact with network devices. Network automation can be adopted in many ways. We started by looking at how to directly interact with network devices using the SSH protocol in Python. We used the Paramiko, Netmiko, and NAPALM Python libraries to fetch configuration from a device and we elaborated on how to push this configuration to a network device. Next, we discussed how to use NETCONF with Python to interact with a network device. We provided code examples for working with NETCONF and used the ncclient library to fetch an IP interface configuration. We also used the same library to update an IP interface on a network device. </p>
			<p>In the last part of this chapter, we explored how to interact with network management systems such as Nokia NSP. We interacted with the Nokia NSP system using Python as a REST API client and as a Kafka consumer. We provided a few code examples in terms of how to get an authentication token, and then sent a REST API to a NMS to retrieve configuration data and update the network configuration on devices.</p>
			<p>This chapter included several code examples to make you familiar with using Python for interacting with devices using SSH, NETCONF protocols, and using an NMS-level REST API. This practical knowledge is critical if you are an automation engineer and looking to excel in your area by using Python capabilities.</p>
			<p>This chapter concludes this book. We not only covered the advanced concepts of Python but also provided an insight into using Python in many advanced areas, such as data processing, serverless computing, web development, machine learning, and network automation. </p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor349"/>Questions</h1>
			<ol>
				<li value="1">What is the name of the commonly used class from the Paramiko library for making a connection to a device? </li>
				<li>What are the four layers of NETCONF?</li>
				<li>Can you push configuration directly to a <code>running</code> database in NETCONF?</li>
				<li>Why is gNMI better for data collection than network configuration?</li>
				<li>Does RESTCONF provide the same features as NETCONF but through REST interfaces?</li>
				<li>What are a publisher and consumer in Apache Kafka?</li>
			</ol>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor350"/>Further reading</h1>
			<ul>
				<li><em class="italic">Mastering Python Networking</em>, by Eric Chou.</li>
				<li><em class="italic">Practical Network Automation</em>, Second Edition, by Abhishek Ratan.</li>
				<li><em class="italic">Network Programmability and Automation</em>, by Jason Edelman.</li>
				<li><em class="italic">Paramiko official documentation</em> is available at <a href="http://docs.paramiko.org/">http://docs.paramiko.org/</a>.</li>
				<li><em class="italic">Netmiko official documentation</em> is available at <a href="https://ktbyers.github.io/">https://ktbyers.github.io/</a>.</li>
				<li><em class="italic">NAPALM official documentation</em> is available at <a href="https://napalm.readthedocs.io/">https://napalm.readthedocs.io/</a>.</li>
				<li><em class="italic">ncclient official documentation</em> is available at <a href="https://ncclient.readthedocs.io/">https://ncclient.readthedocs.io/</a>.</li>
				<li><em class="italic">NETCONF YANG models</em> can be found at <a href="https://github.com/YangModels/yang">https://github.com/YangModels/yang</a>.</li>
				<li><em class="italic">Nokia NSP API documentation</em> is available at <a href="https://network.developer.nokia.com/api-documentation/">https://network.developer.nokia.com/api-documentation/</a>.</li>
			</ul>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor351"/>Answers</h1>
			<ol>
				<li value="1">The <code>paramiko.SSHClient</code> class.</li>
				<li>Content, Operations, Messages, and Transport.</li>
				<li>If a network device does not support a <code>candidate</code> database, it typically allows direct updates to be performed for the <code>running</code> database. </li>
				<li>gNMI is based on gRPC, which is a protocol that was introduced by Google for RPC calls between mobile clients and cloud applications. The protocol has been optimized for data transfer, which makes it more efficient in terms of collecting data from network devices compared to configuring them.</li>
				<li>RESTCONF provides most of the functionality of NETCONF through REST interfaces but it does not expose all the operations of NETCONF. </li>
				<li>The publisher is a client program that sends messages to a Kafka topic (category) as events, whereas the consumer is a client application that reads and processes the messages from a Kafka topic.</li>
			</ol>
		</div>
	</body></html>