- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs and Intent-Driven Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Low-Level Network Device Interactions*, we looked at ways to
    interact with network devices using Python libraries such as Pexpect, Paramiko,
    Netmiko, and Nornir. Paramiko and similar libraries use persistent sessions that
    simulate a user typing in commands as if sitting in front of a Terminal. This
    approach works fine up to a point. It is easy to send commands for execution on
    a device and capture the output. However, when the output becomes more than a
    few lines of characters, it becomes difficult for a computer program to interpret
    the output. The returned output from Paramiko, for example, is a series of characters
    meant to be read by a human being. The structure of the output consists of lines
    and spaces that are human-friendly but difficult to be understood by computer
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point is: for our computer programs to automate many of the tasks we
    want to perform, we need to interpret the returned results and make follow-up
    actions based on the returned results. When we cannot accurately and predictably
    interpret the returned results, we cannot execute the next command with confidence.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a similar issue faced by the internet community in general, not just
    with network automation, whenever computers need to communicate with each other.
    Imagine the difference between a computer and a human being when they both read
    a web page. The human sees words, pictures, and spaces interpreted by the browser;
    the computer sees raw HTML code, Unicode characters, and binary files. What happens
    when a website needs to become a web service for another computer? The same web
    resources need to accommodate both human clients and other computer programs.
    Essentially, the web server needs to transfer information to another computer
    in the most optimized way. How do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is the **application program interface** (**API**). It is important
    to note that an API is a concept and not a particular technology or framework.
    As defined by Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: In computer programming, an application programming interface (API) is a set
    of subroutine definitions, protocols, and tools for building application software.
    In general terms, it’s a set of clearly defined methods of communication between
    various software components. A good API makes it easier to develop a computer
    program by providing all the building blocks, which are then put together by the
    programmer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In our use case, the set of clearly defined methods of communication would be
    between our Python program and the destination device. The APIs from our network
    devices provide a separate interface for the computer programs, such as our Python
    scripts. The exact API implementation is vendor and sometimes product specific.
    One vendor will prefer XML, while another might use JSON; one product might use
    HTTPS as the underlying transport protocol, and others might provide Python libraries
    called SDKs to be used with the device. We will see many different vendors and
    product examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the differences, the concept of an API remains the same: it is a communication
    method optimized for other computer programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Treating **infrastructure as code** (**IaC**), intent-driven networking, and
    data modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco NX-API, **Application Centric Infrastructure** (**ACI**), and Meraki examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Juniper **Network Configuration Protocol** (**NETCONF**) and PyEZ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arista eAPI and pyeapi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by examining why we want to treat infrastructure as code.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure-as-Code (IaC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a perfect world, network engineers and architects who design and manage networks
    should focus on what they want the network to achieve instead of the device-level
    interactions. But we all know the world is far from perfect. Many years ago, when
    I worked as an intern for a second-tier ISP, one of my first assignments was to
    install a router on a customer’s site to turn up their fractional frame relay
    link (remember those?). *How would I do that?* I asked. I was handed down a standard
    operating procedure for turning up frame relay links.
  prefs: []
  type: TYPE_NORMAL
- en: I went to the customer site, blindly typed in the commands, looked at the green
    lights flashing, happily packed my bag, and patted myself on the back for a job
    well done. As exciting as that assignment was, I did not fully understand what
    I was doing. I was simply following instructions without thinking about the implication
    of the commands I was typing in. How would I troubleshoot something if the light
    was red instead of green? No doubt I would have had to call the office and ask
    a more senior engineer for help.
  prefs: []
  type: TYPE_NORMAL
- en: Network engineering is not about typing commands into a device; it is about
    building a way that allows services to be delivered from one point to another
    with as little friction as possible. The commands we have to use and the output
    we have to interpret are merely means to an end. In other words, we should be
    focused on our intent for the network. **What we want our network to achieve is
    much more important than the command syntax we use to get the device to do what
    we want it to do**. If we further abstract that idea of describing our intent
    as lines of code, we can potentially describe our whole infrastructure as a particular
    state. The infrastructure will be described in lines of code with the necessary
    software or framework to enforce that state.
  prefs: []
  type: TYPE_NORMAL
- en: Intent-driven networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the publication of the first edition of this book, the terms **intent-based
    networking** (**IBN**) and **intent-driven networking** (**IDN**) have seen an
    uptick after major network vendors chose to use them to describe their next-generation
    devices. The two terms generally mean the same thing. *In my opinion, IDN is the
    idea of defining a state that the network should be in and having software code
    to enforce that state*. As an example, if my goal is to block port `80` from being
    externally accessible, that is how I should declare it as the intention of the
    network. The underlying software will be responsible for knowing the syntax of
    configuring and applying the necessary access list on the border router to achieve
    that goal. Of course, IDN is an idea with no clear answer on the exact implementation.
    The software we use to enforce our declared intent can be a library, a framework,
    or a complete package we purchase from a vendor.
  prefs: []
  type: TYPE_NORMAL
- en: When using an API, it is my opinion that it gets us closer to a state of IDN.
    In short, because we abstract the layer of a specific command executed on our
    destination device, we focus on our intent instead of the specific commands. For
    example, going back to our `block port 80` access-list example, we might use `access-list`
    and `access-group` on a Cisco router and `filter-list` on a Juniper router. However,
    by using an API, our program can start asking the executor for their intent while
    masking the kind of physical device the software is talking to. We can even use
    a higher-level declarative framework, such as Ansible, which we will cover in
    *Chapter 4*, *The Python Automation Framework*. But for now, let’s focus on network
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Screen scraping versus API structured output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine a common scenario where we need to log into the network device and
    make sure all the interfaces on the device are in an up/up state (both the status
    and the protocol are showing as `up`). For the human network engineers getting
    into a Cisco NX-OS device, it is simple enough to issue the `show ip interface
    brief` command in the Terminal to easily tell from the output which interface
    is up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The line break, white spaces, and the first line of the column title are easily
    distinguished by the human eye. They are there to help us line up, say, the IP
    addresses of each interface from line one to lines two and three. If we were to
    put ourselves in the computer’s position for capturing the information, all these
    spaces and line breaks only take us away from the important output, which is:
    which interfaces are in the up/up state? To illustrate this point, we can look
    at the Paramiko output for the `show interface brief` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to parse out that data contained in the output variable, this is
    what I would do in a pseudo-code fashion (pseudo-code means a simplified representation
    of the actual code I would write) to subtract the text into the information I
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: Split each line via the line break.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I do not need the first line that contains the executed command of `show ip
    interface brief` and will discard it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take out everything on the second line up until the hostname prompt, and save
    it in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the rest of the lines, because we do not know how many interfaces there
    are, we will use a regular expression statement to search if the line starts with
    interface names, such as `lo` for loopback and `GigabitEthernet` for Ethernet
    interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need to split this line into three sections separated by a space, each
    consisting of the name of the interface, IP address, and then the interface status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interface status will then be split further using the while space to give
    us the protocol, the link, and the admin status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Whew, that is a lot of work just for something that a human being can tell
    at a glance! The steps are what we need to do when we need to screen scrap unstructured
    texts. There are many downsides to this method, but some of the bigger problems
    that I can see are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: We spent so much time on painstaking details to parse out
    the outputs from each command. It is hard to imagine how we can do this for the
    hundreds of commands we typically run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predictability**: There is no guarantee that the output stays the same between
    different software versions. If the output is changed ever so slightly, it might
    just render our hard-fought battle of information gathering useless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor and software lock-in**: Once we spend all this effort parsing the
    output for this particular vendor and software version, in this case, Cisco IOS,
    we need to repeat this process for the next vendor we pick. I don’t know about
    you, but if I were to evaluate a new vendor, the new vendor would be at a severe
    onboarding disadvantage if I have to rewrite all the screen scrap code again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s compare that with an output from an NX-API call for the same `show ip
    interface brief` command. We will go over the specifics of getting this output
    from the device later in this chapter, but what is important here is to compare
    the following output to the previous screen scraping output (the full output is
    in the course code repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: NX-API can return output in XML or JSON, and this is the JSON output. Right
    away, we can see the output is structured and can be mapped directly to the Python
    dictionary data structure. Once this is converted to a Python dictionary, no extensive
    parsing is required — we can simply pick the key and retrieve the value associated
    with the key. We can also see from the output that there is various metadata in
    the output, such as the success or failure of the command. If the command fails,
    there will be a message telling the sender the reason for the failure. We no longer
    need to keep track of the command issued, because it is already returned to you
    in the `input` field. There is also other useful metadata in the output, such
    as the NX-API version.
  prefs: []
  type: TYPE_NORMAL
- en: This type of exchange makes life easier for both vendors and operators. On the
    vendor side, they can easily transfer configuration and state information. They
    can add extra fields when the need to expose additional data arises using the
    same data structure. On the operator side, we can easily ingest the information
    and build our infrastructure automation around it. It is agreed by all that network
    automation and programmability are beneficial to both network vendors and operators.
    The questions are usually about the transport, format, and structure of the automation
    messages. As we will see later in this chapter, there are many competing technologies
    under the umbrella of API. On the transport language alone, we have REST API,
    NETCONF, and RESTCONF, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Data modeling for IaC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to Wikipedia ([https://en.wikipedia.org/wiki/Data_model](https://en.wikipedia.org/wiki/Data_model)),
    the definition of a data model is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A data model is an abstract model that organizes elements of data and standardizes
    how they relate to one another and to properties of real-world entities. For instance,
    a data model may specify that the data element representing a car be composed
    of a number of other elements which, in turn, represent the color and size of
    the car and define its owner.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The data modeling process is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18403_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Data example process'
  prefs: []
  type: TYPE_NORMAL
- en: When applying the data model concept to the network, we can say the network
    data model is an abstract model that describes our network. If we take a closer
    look at a physical data center, a layer 2 Ethernet switch can be considered a
    device containing a table of MAC addresses mapped to each port. Our switch data
    model describes how the MAC address should be kept in a table, which includes
    the keys, additional characteristics (think of VLAN and private VLAN), and more.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can move beyond devices and map the whole data center in a data
    model. We can start with the number of devices in each of the access, distribution,
    and core layers, how they are connected, and how they should behave in a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have a fat-tree network, we can declare in the model how
    many links each of the spine routers have, the number of routes they should contain,
    and the number of next-hops each of the prefixes would have.
  prefs: []
  type: TYPE_NORMAL
- en: Remember we talked about IaC? These characteristics can be mapped out in a format
    that can then be referenced as the ideal state we can check against using software
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: YANG and NETCONF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the network data modeling languages is YANG, an interesting acronym for
    **Yet Another Next Generation** (despite common belief, some of the IETF workgroups
    do have a sense of humor). It was first published in RFC 6020 in 2010 and has
    since gained traction among vendors and operators.
  prefs: []
  type: TYPE_NORMAL
- en: As a data modeling language, YANG is used to model the configuration of devices.
    It can also represent state data manipulated by the NETCONF protocol, NETCONF
    remote procedure calls, and NETCONF notifications. It aims to provide a common
    abstraction layer between the protocols, such as NETCONF, and the underlying vendor-specific
    syntax for configuration and operations. We will look at some examples of YANG
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the high-level concepts of API-based device management
    and data modeling, let us look at some examples from Cisco in their API structures.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco API examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cisco Systems, the 800-pound gorilla in the networking space, have not missed
    out on the trend of network automation. In their push for network automation,
    they have made various in-house developments, product enhancements, partnerships,
    and many external acquisitions. However, with product lines spanning routers,
    switches, firewalls, servers (unified computing), wireless, collaboration software
    and hardware, and analytic software, it is hard to know where to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this book focuses on Python and networking, we will scope the Cisco examples
    in this section to the main networking products. In particular, we will cover
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Nexus with NX-API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco NETCONF and YANG examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco **Application Centric Infrastructure** (**ACI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco Meraki examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the NX-API and NETCONF examples in this chapter, we can either use the Cisco
    DevNet always-on lab devices mentioned in *Chapter 2*, *Low-Level Network Device
    Interactions*, or a locally run Cisco CML virtual lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the same lab topology as we did in *Chapter 2*, *Low-Level Network
    Device Interactions*, and focus on the devices running **NX-OSv**, **lax-cor-r1**,
    and **nyc-cor-r1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18403_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Lab NX-OSv Device'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the Cisco NX-API example first.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco NX-API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nexus is Cisco’s primary product line of data center switches. The NX-API ([http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html](http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html))
    allows the engineer to interact with the switch outside of the device via a variety
    of transports including SSH, HTTP, and HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Lab preparation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember to activate our Python virtual environment. This should be a given
    requirement whenever we perform labs from now on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ncclient` ([https://github.com/ncclient/ncclient](https://github.com/ncclient/ncclient))
    library is a Python library for NETCONF clients. We will also install a popular
    Python HTTP client library called Requests ([https://pypi.org/project/requests/](https://pypi.org/project/requests/)).
    We can install both via pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'NX-API on Nexus devices is turned off by default, so we will need to turn it
    on. We will also need a user. In this case, we will just use the existing user
    of `cisco`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For our lab, we will turn on both the `nxapi` `http` and the `nxapi` `sandbox`
    configuration; keep in mind that both should be turned off in production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to look at our first NX-API example.
  prefs: []
  type: TYPE_NORMAL
- en: NX-API examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NX-API sandbox is a great way to play around with various commands, data formats,
    and even copy the Python script directly from the web page. In the last step,
    we turned it on for learning purposes. Again, the sandbox should be turned off
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s launch a web browser with the Nexus device’s management IP and look at
    the various message formats, requests, and responses based on the CLI commands
    that we are already familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: NX-API Developer Sandbox'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I have selected `JSON-RPC` and the `CLI` command
    type for the `show version` command. Click on **POST**, and we will see both the
    **REQUEST** and **RESPONSE**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: NX-API Sandbox example output'
  prefs: []
  type: TYPE_NORMAL
- en: The sandbox comes in handy if you are unsure about the supportability of the
    message format or if you have questions about the response data field keys for
    the value you want to retrieve in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our first example, `cisco_nxapi_1.py`, we are just going to connect to the
    Nexus device and print out the capabilities exchanged when the connection was
    first made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we are using the `ncclient` library to connect to the device.
    The connection parameters of the host, port, username, and password are self-explanatory.
    The device parameter specifies the kind of device the client is connecting to.
    The `hostkey_verify` bypasses the `known_host` requirement for SSH; if it’s not
    set to false, the host fingerprint will need to be listed in the `~/.ssh/known_hosts`
    file. The `look_for_keys` option disables public-private key authentication and
    uses the username and password combination for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will show the XML- and NETCONF-supported features of this version
    of NX-OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using ncclient and NETCONF over SSH is great because it gets us closer to the
    native implementation and syntax. We will use the same library later on in this
    book for other vendors as a comparison. For NX-API, we can also use HTTPS and
    JSON-RPC. In the earlier screenshot of **NX-API Developer Sandbox**, if you noticed,
    in the **REQUEST** box, there is a box labeled **Python**. If you click on it,
    you will be able to get an automatically converted Python script based on the
    Requests library.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `show version` example from the NX-API sandbox, the following Python
    script is automatically generated for us. I am pasting in the output without any
    modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `cisco_nxapi_2.py` script, you will see that I have taken the script
    the NX-API sandbox generated and only modified the URL, username, and password
    of the script. The output was parsed to include only the software version. Here
    is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The best part about using this method is that the same overall syntax structure
    works with configuration and `show` commands. This is illustrated in the `cisco_nxapi_3.py`
    file, configuring the device with a new hostname. After command execution, you
    will see the device hostname being changed from `lax-cor-r1` to `lax-cor-r1-new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For multiline configuration, you can use the ID field to specify the order
    of operations. This is shown in `cisco_nxapi_4.py`. The following payload was
    listed for changing the description of the interface Ethernet 2/12 in the interface
    configuration mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the result of the previous configuration script by looking at
    the running configuration of the Nexus device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the next example, we will see how we can use YANG with NETCONF.
  prefs: []
  type: TYPE_NORMAL
- en: The Cisco YANG Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us take a look at Cisco’s YANG model support with an example. First, we
    should know that the YANG model only defines the type of schema sent over the
    NETCONF protocol without dictating what the data should be. Secondly, it is worth
    pointing out that NETCONF exists as a standalone protocol, as we saw in the NX-API
    section. Thirdly, YANG has different supportability across vendors and product
    lines. For example, if we run a capability exchange script for a Cisco CSR 1000v
    running IOS-XE, we can see the YANG models supported on the platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: YANG has somewhat uneven support among different vendors and products. I have
    included a `cisco_yang_1.py` script with the book code repository for a Cisco
    IOS-XE always-on sandbox provided by Cisco Devnet that shows how to parse out
    the NETCONF XML output with YANG filters called `urn:ietf:params:xml:ns:yang:ietf-interfaces`.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the latest vendor support on the YANG GitHub project page ([https://github.com/YangModels/yang/tree/master/vendor](https://github.com/YangModels/yang/tree/master/vendor)).
  prefs: []
  type: TYPE_NORMAL
- en: The Cisco ACI examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Cisco Application Centric Infrastructure, or ACI, is meant to provide a
    centralized controller approach to all network components we defined within its
    management scope. In the data center context, the centralized controller is aware
    of and manages the spine, leaf, and top-of-rack switches, as well as all the network
    service functions. This can be done through a GUI, CLI, or API. Some might argue
    that the ACI is Cisco’s answer to broader controller-based, software-defined networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ACI API follows the REST model to use the HTTP verbs (`GET`, `POST`, and
    `DELETE`) to specify the intended operation. In our example, we can use the Cisco
    DevNet always-on lab ACI device ([https://devnetsandbox.cisco.com/RM/Topology](https://devnetsandbox.cisco.com/RM/Topology)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B18403_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Cisco DevNet Sandboxes'
  prefs: []
  type: TYPE_NORMAL
- en: Always check the latest Cisco DevNet page for the latest device information,
    username, and password as they may have changed since the book was written.
  prefs: []
  type: TYPE_NORMAL
- en: 'The controller is the brain of the network that maintains visibility to all
    network devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18403_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Cisco ACI Controller'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a web browser to log on to the controller and take a look at the
    different tenants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B18403_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Cisco ACI Tenants'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a Python interactive prompt to see how we can interact with the ACI
    controller. We will start by importing the correct libraries and defining the
    destination URL as well as the login credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then make a request and convert the response into JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can grab the token from the response and use it as an authentication cookie
    for future requests to the controller. In the example below, we query for the
    `cisco` tenant that we saw in the controller tenant section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we only query a single controller device, but we can get a high-level
    view of all the network devices that the controller is aware of. This is pretty
    neat! The downside is, of course, that the ACI controller only supports Cisco
    devices at this time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cisco IOS-XE**'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, Cisco IOS-XE scripts are functionally similar to scripts
    we have written for NX-OS. IOS-XE has additional features that can benefit Python
    network programmability, such as on-box Python and a guest shell, [https://developer.cisco.com/docs/ios-xe/#!on-box-python-and-guestshell-quick-start-guide/onbox-python](https://developer.cisco.com/docs/ios-xe/#!on-box-python-and-guestshell-quick-start-guide/onbox-python).
  prefs: []
  type: TYPE_NORMAL
- en: Similar to ACI, Cisco Meraki is a centrally managed controller that has visibility
    for multiple wired and wireless networks. Unlike the ACI controller, Meraki is
    cloud based, so it is hosted outside of the on-premises location. Let us look
    at some of the Cisco Meraki features and examples in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco Meraki controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cisco Meraki is a cloud-based centralized controller that simplifies IT management
    of devices. The approach is very similar to ACI with the exception that the controller
    has a cloud-based public URL. The user typically receives the API key via the
    GUI, then it can be used in a Python script to retrieve the organization ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us execute the script, `cisco_meraki_1.py`, which is a simple request toward
    an always-on Meraki controller provided by Cisco DevNet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, the organization ID can be used to further retrieve information,
    such as the inventory, network information, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at the output from the `cisco_meraki_2.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have seen examples of Cisco devices using NX-API, ACI, and the Meraki controller.
    In the next section, let us take a look at some of the Python examples working
    with Juniper Networks devices.
  prefs: []
  type: TYPE_NORMAL
- en: The Python API for Juniper Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Juniper Networks has always been a favorite among the service provider crowd.
    If we take a step back and look at the service provider vertical, it would make
    sense that automating network equipment is at the top of their list of requirements.
    Before the dawn of cloud-scale data centers, service providers had the most network
    equipment to manage. For example, a typical enterprise network might have a few
    redundant internet connections at the corporate headquarters with a few hub-and-spoke
    remote sites connected back to the HQ using a private **multiprotocol label switching**
    (**MPLS**) network. But to a service provider, they are the ones needing to build,
    provision, manage, and troubleshoot the MPLS connections and the underlying networks.
    They make their money by selling the bandwidth along with value-added managed
    services. It would make sense for the service providers to invest in automation
    to use the fewest engineering hours to keep the network humming along. In their
    use case, network automation is a key to their competitive advantage.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the difference between a service provider’s network needs compared
    to a cloud data center is that, traditionally, service providers aggregate more
    services into a single device. A good example would be MPLS, which almost all
    major service providers provide but rarely adopt in enterprise or data center
    networks. Juniper Networks has identified this need for network programmability
    and excelled at fulfilling the service provider requirements of automating. Let’s
    take a look at some of Juniper’s automation APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper and NETCONF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NETCONF is an IETF standard that was first published in 2006 as `RFC 4741`
    and later revised in `RFC 6241`. Juniper Networks contributed heavily to both
    of the RFC standards. In fact, Juniper was the sole author of `RFC 4741`. It makes
    sense that Juniper devices fully support NETCONF, and it serves as the underlying
    layer for most of its automation tools and frameworks. Some of the main characteristics
    of NETCONF include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses **extensible markup language** (**XML**) for data encoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses **remote procedure calls** (**RPCs**). Therefore, if HTTP(s) is the
    transport protocol, the URL endpoint is identical while the operation intended
    is specified in the request’s body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is conceptually based on layers from top to bottom. The layers include the
    content, operations, messages, and transport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with medium confidence](img/B18403_03_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: NETCONF model'
  prefs: []
  type: TYPE_NORMAL
- en: Juniper Networks provides an extensive NETCONF XML management protocol developer
    guide ([https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview](https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview))
    in its technical library. Let’s take a look at its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Device preparation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start using NETCONF, let’s create a separate user as well as turn on the
    required services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For the Juniper device lab, I am using an older, unsupported platform called
    **JunOS Olive**. It is solely used for lab purposes. You can use your favorite
    search engine to find some interesting facts and history about Juniper Olive.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Juniper device, you can always take a look at the configuration either
    in a flat file or in XML format. The `flat` file comes in handy when you need
    to specify a one-liner command to make configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The XML format comes in handy at times when you need to see the XML structure
    of the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We installed the necessary Linux libraries and the `ncclient` Python library
    in the *Lab software installation and device preparation within Cisco NX-API*
    section. If you have not done so, go back to that section and install the necessary
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to look at our first Juniper NETCONF example.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper NETCONF examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use a pretty straightforward example to execute `show version`. We
    will name this file `junos_netconf_1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All the fields in the script should be pretty self-explanatory, with the exception
    of `device_params`. Starting with ncclient 0.4.1, the device handler was added
    to specify different vendors or platforms. For example, the name can be Juniper,
    CSR, Nexus, or Huawei. We also added `hostkey_verify=False` because we are using
    a self-signed certificate from the Juniper device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned output is `rpc-reply` encoded in XML with an output element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can parse the XML output to just include the output text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In `junos_netconf_2.py`, we will make configuration changes to the device.
    We will start with some new imports for constructing new XML elements and the
    connection manager object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will lock the configuration and make configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the build configuration section, we create a new element of `system` with
    sub-elements of `host-name` and `domain-name`. If you were wondering about the
    hierarchy structure, you can see from the XML display that the node structure
    with `system` is the parent of `host-name` and `domain-name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After the configuration is built, the script will push the configuration and
    commit the configuration changes. These are the normal best practice steps (`lock`,
    `configure`, `unlock`, `commit`) for Juniper configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, the NETCONF steps map pretty well to what we would have done in the
    CLI steps. Please take a look at the `junos_netconf_3.py` script for a more reusable
    code. The following example combines the step-by-step example with a few Python
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This file can be executed by itself, or it can be imported to be used by other
    Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper also provides a Python library to be used with their devices called
    PyEZ. We will look at a few examples of using the library in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper PyEZ for developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PyEZ** is a high-level Python library implementation that integrates better
    with your existing Python code. By utilizing the Python API that wraps around
    the underlying configuration, you can perform common operations and configuration
    tasks without extensive knowledge of the Junos CLI.'
  prefs: []
  type: TYPE_NORMAL
- en: Juniper maintains a comprehensive Junos PyEZ developer guide at [https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration)
    on their technical library. If you are interested in using PyEZ, I would highly
    recommend at least a glance through the various topics in the guide.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and preparation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The installation instructions for each of the operating systems can be found
    on the *Installing Junos PyEZ* ([https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html))
    page.
  prefs: []
  type: TYPE_NORMAL
- en: '`PyEZ` packages can be installed via `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Juniper device, NETCONF needs to be configured as the underlying XML
    API for PyEZ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For user authentication, we can either use password authentication or an SSH
    key pair. We can create a new user or use the existing user. For `ssh` key authentication,
    first, generate the key pair on your management host if you have not done so for
    *Chapter 2*, *Low-Level Network Device Interactions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the public key will be called `id_rsa.pub` under `~/.ssh/`, while
    the private key will be named `id_rsa` in the same directory. Treat the private
    key like a password that you never share. The public key can be freely distributed.
    In our use case, we will copy the public key to the `/tmp` directory and enable
    the Python 3 HTTP server module to create a reachable URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'From the Juniper device, we can create the user and associate the public key
    by downloading the public key from the Python 3 web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to `ssh` with the private key from the management station, the
    user will be automatically authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make sure that both of the authentication methods work with PyEZ. Let’s
    try the username and password combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also try to use the SSH key authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Great! We are now ready to look at some examples for PyEZ.
  prefs: []
  type: TYPE_NORMAL
- en: PyEZ examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous interactive prompt, we saw that when the device connects, the
    object automatically retrieves a few facts about the device. In our first example,
    `junos_pyez_1.py`, we were connecting to the device and executing an RPC call
    for `show interface em1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Device` class has an `rpc` property that includes all operational commands.
    This is awesome because there is no slippage between what we can do in CLI versus
    API. The catch is that we need to find the corresponding `xml rpc` element tag
    for the CLI command. In our first example, how do we know `show interface em1`
    equates to `get_interface_information`? We have three ways of finding out this
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: We can reference the *Junos XML API Operational Developer Reference*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the CLI and display the XML RPC equivalent and replace the dash (-)
    between the words with an underscore (_).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also do this programmatically by using the PyEZ library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I typically use the second option to get the output directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of using PyEZ programmatically (the third option):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can make configuration changes as well. In the `junos_pyez_2.py`
    configuration example, we will import an additional `Config()` method from PyEZ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We will utilize the same block to connect to a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new Config()` method will load the XML data and make the configuration
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The PyEZ examples are simple by design. Hopefully, they demonstrate the ways
    you can leverage PyEZ for your Junos automation needs. In the following example,
    let’s look at how we can work with Arista network devices using Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The Arista Python API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Arista Networks** has always been focused on large-scale data center networks.
    On its corporate profile page ([https://www.arista.com/en/company/company-overview](https://www.arista.com/en/company/company-overview)),
    it states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ”Arista Networks is an industry leader in data-driven, client to cloud networking
    for large data center, campus, and routing environments.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice that the statement specifically called out **large data centers**, which
    we know are exploding with servers, databases, and, yes, network equipment. It
    makes sense that automation has always been one of Arista’s leading features.
    In fact, it has a Linux underpinning behind its operating system, allowing many
    added benefits, such as Linux commands and a built-in Python interpreter directly
    on the platform. From day one, Arista was open about exposing the Linux and Python
    features to the network operators.
  prefs: []
  type: TYPE_NORMAL
- en: Like other vendors, you can interact with Arista devices directly via eAPI,
    or you can choose to leverage their Python library. We will see examples of both
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Arista eAPI management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arista’s eAPI was first introduced in EOS 4.12 a few years ago. It transports
    a list of show or configuration commands over HTTP or HTTPS and responds in JSON.
    An important distinction is that it is an RPC and **JSON-RPC**, instead of a pure
    RESTful API that is served over HTTP or HTTPS. The difference is that we make
    the request to the same URL endpoint using the same HTTP method (`POST`). But
    instead of using HTTP verbs (`GET`, `POST`, `PUT`, `DELETE`) to express our action,
    we simply state our intended action in the request’s body. In the case of eAPI,
    we will specify a `method` key with a `runCmds` value.
  prefs: []
  type: TYPE_NORMAL
- en: For the following examples, I am using a physical Arista switch running EOS
    4.16.
  prefs: []
  type: TYPE_NORMAL
- en: eAPI preparation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The eAPI agent on the Arista device is disabled by default, so we will need
    to enable it on the device before we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have turned off the HTTP server and are using HTTPS as the
    sole transport instead. The management interfaces, by default, reside in a VRF
    called **management**. In my topology, I am accessing the device via the management
    interface; therefore, I have specified the VRF for eAPI management.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check that API management state via the `show management api http-commands`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After enabling the agent, we can access the exploration page for eAPI by going
    to the device’s IP address in a web browser. If you have changed the default port
    for access, just append it. The authentication is tied to the method of authentication
    on the switch. We will use the username and password configured locally on the
    device. By default, a self-signed certificate will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Arista EOS explorer'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be taken to an explorer page, where we can type in the CLI command
    and get a nice output for the body of our request. For example, if I want to see
    how to make a request body for `show version`, this is the output I will see from
    the explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Arista EOS explorer viewer'
  prefs: []
  type: TYPE_NORMAL
- en: The overview link will take us to the sample use and background information,
    while the command documentation will serve as reference points for the show commands.
    Each command reference will contain the returned value field name, type, and a
    brief description. The online reference scripts from Arista use `jsonrpclib` ([https://github.com/joshmarshall/jsonrpclib/](https://github.com/joshmarshall/jsonrpclib/)),
    which we will use.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section mainly use Python 2.7 as jsonrpclib was not ported
    to Python 3 for a long time. However, per GitHub pull request [https://github.com/joshmarshall/jsonrpclib/issues/38](https://github.com/joshmarshall/jsonrpclib/issues/38),
    Python 3 support should be included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation is straightforward using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: eAPI examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can then write a simple program called `eapi_1.py` to look at the response
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the response I received from the previous `runCmds()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the result is a list containing one dictionary item. If we
    need to grab the serial number, we can simply reference the item number and the
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will contain only the serial number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To be more familiar with the command reference, I recommend clicking on the
    **Command Documentation** link on the eAPI page and comparing our output with
    the output of **show version** in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, unlike REST, the JSON-RPC client uses the same URL endpoint
    for calling the server resources. We can see from the previous example that the
    `runCmds()` method contains a list of commands. For the execution of configuration
    commands, you can follow the same steps and configure the device via a list of
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of configuration commands in a file named `eapi_2.py`. In
    our example, we wrote a function that takes the `switch` object and the list of
    commands as attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the command’s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, do a quick check on the `switch` to verify the command’s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Overall, eAPI is fairly straightforward and simple to use. Most programming
    languages have libraries similar to `jsonrpclib`, which abstracts away JSON-RPC
    internals. With a few commands, you can start integrating Arista EOS automation
    into your network.
  prefs: []
  type: TYPE_NORMAL
- en: The Arista Pyeapi library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python client Pyeapi ([http://pyeapi.readthedocs.io/en/master/index.html](http://pyeapi.readthedocs.io/en/master/index.html))
    library is a native Python library wrapper around eAPI. It provides a set of bindings
    to configure Arista EOS nodes. Why do we need Pyeapi when we already have eAPI?
    The answer is “it depends.” Picking between Pyeapi and eAPI is mostly a judgment
    call.
  prefs: []
  type: TYPE_NORMAL
- en: If you are in a non-Python environment, eAPI is probably the way to go. From
    our examples, you can see that the only requirement of eAPI is a JSON-RPC-capable
    client. Thus, it is compatible with most programming languages. When I first started
    out in the field, Perl was the dominant language for scripting and network automation.
    There are still many enterprises that rely on Perl scripts as their primary automation
    tool. If you’re in a situation where the company has already invested a ton of
    resources and the code base is in a language other than Python, eAPI with JSON-RPC
    would be a good bet.
  prefs: []
  type: TYPE_NORMAL
- en: However, for those of us who prefer to code in Python, a native Python library
    such as Pyeapi means a more natural feeling in writing our code. It certainly
    makes extending a Python program to support the EOS node easier. It also makes
    keeping up with the latest changes in Python easier. For example, we can use Python
    3 with Pyeapi ([https://pyeapi.readthedocs.io/en/master/requirements.html](https://pyeapi.readthedocs.io/en/master/requirements.html))!
  prefs: []
  type: TYPE_NORMAL
- en: Pyeapi installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installation is straightforward with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that pip will also install the `netaddr` library as it is part of the stated
    requirements ([http://pyeapi.readthedocs.io/en/master/requirements.html](http://pyeapi.readthedocs.io/en/master/requirements.html))
    for Pyeapi.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Pyeapi client will look for an INI-style hidden (with a period
    in front) file called `eapi.conf` in your home directory. You can override this
    behavior by specifying the `eapi.conf` file path. It is generally a good idea
    to separate your connection credential and lock it down from the script itself.
    You can check out the Arista Pyeapi documentation ([http://pyeapi.readthedocs.io/en/master/configfile.html#configfile](http://pyeapi.readthedocs.io/en/master/configfile.html#configfile))
    for the fields contained in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the file I am using in the lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line, `[connection:Arista1]`, contains the name that we will use
    in our Pyeapi connection; the rest of the fields should be pretty self-explanatory.
    You can lock down the file to be read-only for the user using this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now that Pyeapi is installed, let’s get into some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Pyeapi examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by connecting to the EOS node by creating an object in the interactive
    Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute `show` commands to the node and receive the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration field can be either a single command or a list of commands
    using the `config()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that command abbreviations (`show run` versus `show running-config`) and
    some extensions will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can always catch the results and get the desired value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have been doing what we have been doing with eAPI for `show` and
    `configuration` commands. Pyeapi offers various APIs to make life easier. In the
    following example, we will connect to the node, call the VLAN API, and start to
    operate on the VLAN parameters of the device. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s verify that VLAN 10 was created on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the Python native API on the EOS object is where Pyeapi excels
    beyond eAPI. It abstracts the lower-level attributes into the device object and
    makes the code cleaner and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of ever-increasing Pyeapi APIs, check the official documentation
    ([http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html](http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html)).
  prefs: []
  type: TYPE_NORMAL
- en: To round up this section, let’s assume that we repeat the previous steps enough
    times that we would like to write another Python class to save us some work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pyeapi_1.py` script is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the script, we automatically connect to the node, set the
    hostname, and load `running_config` upon connection. We also create a method of
    the class that creates VLAN by using the VLAN API. Let’s try out the script in
    an interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now looked at Python scripts for three of the top vendors in networking:
    Cisco Systems, Juniper Networks, and Arista Networks. In the next section, we
    will take a look at an open-source network operating system that is gaining some
    momentum in the same space.'
  prefs: []
  type: TYPE_NORMAL
- en: VyOS example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VyOS is a fully open-source network OS that runs on a wide range of hardware,
    virtual machines, and cloud providers ([https://vyos.io/](https://vyos.io/)).
    Because of its open-source nature, it is gaining wide support in the open-source
    community. Many open-source projects are using VyOS as the default platform for
    testing. In the last section of the chapter, we will look at a quick VyOS example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The VyOS image can be downloaded in various formats: [https://wiki.vyos.net/wiki/Installation](https://wiki.vyos.net/wiki/Installation).
    Once it’s downloaded and initialized, we can install the Python library on our
    management host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The example script, `vyos_1.py`, is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute the script to change the system domain name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can log in to the device to verify the domain name change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the example, the method we use for VyOS is pretty similar
    to the other examples we have seen before from proprietary vendors. This is mainly
    by design, as they provide an easy transition from using other vendor equipment
    to open-source VyOS. We are getting close to the end of the chapter. There are
    some other libraries that are worth mentioning and should be kept an eye out for
    in development, which we will do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Other libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll finish this chapter by mentioning that there are several excellent efforts
    in terms of vendor-neutral libraries such as Nornir ([https://nornir.readthedocs.io/en/stable/index.html](https://nornir.readthedocs.io/en/stable/index.html)),
    Netmiko ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko)),
    NAPALM ([https://github.com/napalm-automation/napalm](https://github.com/napalm-automation/napalm)),
    and Scrapli ([https://carlmontanari.github.io/scrapli/](https://carlmontanari.github.io/scrapli/)).
    We have seen some of their examples in the last chapter. Most of these vendor-neutral
    libraries are likely a step slower to support the latest platform or features.
    However, because the libraries are vendor neutral, if you do not like vendor lock-in
    for your tools, these libraries are good choices. Another benefit of using vendor-neutral
    libraries is that they are normally open source, so you can contribute upstream
    for new features and bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at various ways to communicate with and manage network
    devices from Cisco, Juniper, Arista, and Vyatta. We looked at both direct communication
    with the likes of NETCONF and REST and using vendor-provided libraries such as
    PyEZ and Pyeapi. These are different layers of abstraction meant to provide a
    way to programmatically manage your network devices without human intervention.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 4*, *The Python Automation Framework*, we will take a look at a
    higher level of vendor-neutral abstraction framework called Ansible. Ansible is
    an open-source, general-purpose automation tool written in Python. It can be used
    to automate servers, network devices, load balancers, and much more. Of course,
    for our purpose, we will focus on using this automation framework for network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Join our book community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2903617220506617062.png)'
  prefs: []
  type: TYPE_IMG
