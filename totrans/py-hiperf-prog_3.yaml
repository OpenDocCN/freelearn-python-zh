- en: Chapter 3. C Performance with Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cython is a language that extends Python by adding static typing to functions,
    variables, and classes. Cython combines the simplicity of Python and the efficiency
    of C. After rewriting your scripts in Cython you can compile them to C or C++,
    generating efficient code in a straightforward way.
  prefs: []
  type: TYPE_NORMAL
- en: Cython also acts as a bridge between Python and C, as it can be used to create
    interfaces to external C code. By creating bindings, you can reuse fast C routines
    in your scripts, effectively using Python as a glue language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Cython syntax basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compile Cython programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use **static typing** to generate fast code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to efficiently manipulate arrays by making use of typed **memoryviews.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will apply our new Cython skills to profile and optimize the particle
    simulator.
  prefs: []
  type: TYPE_NORMAL
- en: While a minimum knowledge of C is helpful, this chapter focuses only on Cython
    in the context of Python optimization. Therefore, it doesn't require any C background.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Cython extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By design, the Cython syntax is a superset of Python. Cython can typically compile
    a Python module without requiring any change. Cython source files have the extension
    `.pyx` and they can be compiled to C using the `cython` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first Cython script will contain a simple function that prints *Hello,
    World!* to the output. Create a new file `hello.pyx` containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cython` command will read `hello.pyx` and generate the `hello.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile `hello.c` to a Python extension module we will use the gcc compiler.
    We need to add some Python-specific compilation options that depend on the operating
    system. On Ubuntu 13.10, with the default Python installation, you can use the
    following options to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce a file called `hello.so`: a C extension module importable
    from Python.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cython accepts both Python 2 and Python 3 as input and output languages. In
    other words, you can compile a Python 3 `hello.pyx` file using the `-3` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated `hello.c` can be compiled without any changes to Python 2 and
    Python 3 by including the corresponding headers with the `-I` option in gcc as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A Cython program can be compiled in a more straightforward way by using `distutils`—the
    standard Python packaging tool. By writing a `setup.py` script we can compile
    the `.pyx` file directly to an extension module. To compile our `hello.pyx` example
    we need to write a `setup.py` containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the first two lines of the previous code, we import the `setup` function
    and the `cythonize` helper. The `setup` function contains a few key-value pairs
    that tell `distutils` the name of the application and which extensions need to
    be built.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cythonize` helper takes either a string or a list of strings containing
    the Cython modules we want to compile. You can also use glob patterns using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile our extension module using `distutils` you can execute the `setup.py`
    script using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `build_ext` option tells the script to build the extension modules indicated
    in `ext_modules`, and the `--inplace` option places the output `hello.so` file
    in the same location as the source file (instead of a build directory).
  prefs: []
  type: TYPE_NORMAL
- en: Cython modules can automatically be compiled using `pyximport`. By adding `pyximport.install()`
    at the beginning of your script (or issuing the command in your interpreter) you
    can import `.pyx` files directly; `pyximport` will transparently compile the corresponding
    Cython modules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, `pyximport` will not work for all kinds of configurations (for
    example when they involve a combination of C and Cython files), but it comes in
    handy for testing simple scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since version 0.13, IPython includes the `cythonmagic` extension to interactively
    write and test a series of Cython statements. You can load the extensions in an
    IPython shell using `load_ext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the extension is loaded you can use the `%%cython` *cell magic* to write
    a multi-line Cython snippet. In the following example, we define a `hello_snippet`
    function that will be compiled and added to the `session` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding static types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, variables have an associated type that can change during the execution.
    While this feature is desirable, as it makes the language more flexible, the interpreter
    needs to do type-checks and method look-ups to correctly handle operations between
    variables—an extra step that introduces a significant overhead. Cython extends
    the Python language with static type declarations; in this way it can generate
    efficient C code by avoiding the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main way to declare data types in Cython is by using `cdef` statements.
    The `cdef` keyword can be used in multiple contexts: to declare variables, functions,
    and extension types (`cdef` classes).'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Cython you can declare the type of a variable by prepending the variable
    with `cdef` and its respective type. For example, we can declare the variable
    `i` as a 16 bit integer in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cdef` statement supports multiple variable names on the same line, along
    with optional initialization values, as seen in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Typed variables are treated differently in comparison to standard variables.
    In Python, variables are often regarded as *labels* referring to objects in memory.
    At any point in the program, we can assign a string to a variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The string *hello* will be bound to the variable `a`. At a different place
    in the program, we can assign to the same variable another value, for example
    an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Python will assign the integer object *1* to the variable `a` without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed variables can be considered more like *data containers*; we *store* the
    value in the variable and only values of the same type are allowed to get in.
    For example, if we declare the variable `a` as an `int` type variable, and then
    we try to assign it to a `double`, Cython will trigger an error, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Static typing allows useful optimizations. If we declare indexes to be used
    in a loop as integers, Cython will rewrite the loops in pure C without stepping
    into the Python interpreter. In the following example, we do an iteration 100
    times and each time we increment the `int` variable `j`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how big the improvement is, we will compare the speed with an
    analogous, pure Python loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The speedup obtained by writing the loop with typing information is a whopping
    100x! This works because the Cython loop has first been converted to pure C and
    then to efficient machine code, while the Python loop still relies on the slow
    interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare a variable of any available C type, and we can also define custom
    types by using C structs, enums, and typedefs. An interesting example is that
    if we declare a variable to be of `object` type, the variable will accept any
    kind of Python object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, certain types of variables are compatible (such as `float` and `int`
    numbers) but not exactly the same. In Cython it is possible to convert (*cast*)
    between types by surrounding the destination type with `<` and `>` pointy brackets,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add type information to the arguments of a Python function by specifying
    the type in front of the argument name. Such functions will work and perform like
    a regular Python function but its arguments will be type-checked. We can write
    a `max_python` function, which returns the greater value between two integers
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That function doesn''t provide much benefit except for type-checking. To take
    advantage of Cython optimizations we have to declare the function using a `cdef`
    statement and an optional return type, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Functions declared in this way are translated to native C functions, which are
    not callable from Python. They have much less overhead compared to Python functions,
    and using them results in a substantial increase in performance. Their scope is
    restricted to the same Cython file, unless they're exposed in a definition file
    (refer to the *Sharing Declarations* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Cython allows you to define functions that are both callable from Python and
    translatable to native C functions. If you declare a function with the keyword
    `cpdef`, Cython will generate two versions of the function—a Python version available
    to the interpreter, and a fast C function usable from Cython—achieving both convenience
    and speed. The `cpdef` syntax is equivalent to `cdef`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, the call overhead can be a performance issue even with C functions,
    especially when the same function is called many times in a critical loop. When
    the function body is small, it is convenient to add the `inline` keyword in front
    of the function definition; the function call will be removed and replaced by
    the function body. For instance, our following `max` function is a good candidate
    for *inlining*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The`cdef` keyword can also be put in front of a class definition to create an
    *extension type*. An extension type is similar to a Python class but its attributes
    must have a type and are stored in an efficient C *struct*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an extension type by using the `cdef class` statement and declaring
    its attributes in the class body. For example, we can create an extension type
    `Point`, as shown in the following code, which stores two coordinates (x, y) of
    type `double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the declared attributes in the class methods allows Cython to avoid
    the Python attribute look-up by replacing it with direct access to the `struct`
    fields. In this way, attribute access becomes an extremely fast operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of the `struct` access, Cython needs to know that the variable
    is an extension type at the time of compilation. You can use the extension type
    name (such as `Point`) in any context where you would use a standard one (such
    as `double`, `float`, `int`). For example, if we want a Cython function that calculates
    the `norm` of a `Point`, we have to declare the input variable as `Point`, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, access to the attributes is restricted to Cython code. If you try
    to access an extension type attribute from Python, you will get an `AttributeError`
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access attributes from Python code you have to use the `public`
    (for read-write access) or `readonly` specifiers in the attribute declaration,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Extension types do not support the addition of extra attributes. A workaround
    for this problem is subclassing the extension type, creating a derived Python
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing your Cython modules, you may want to encapsulate generic functions
    and types in a separate file. Cython allows you to reuse those components with
    the `cimport` statement by writing a *definition file.*
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we have a module with the functions `max` and `min`, and we want to
    reuse those functions in multiple Cython programs. If we simply write a `.pyx`
    file—also called *implementation file*—the functions declared are confined in
    the same module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Definition files are also used to interface Cython with an external C code.
    The idea is to copy the types and function prototypes in the definition file and
    leave the implementation to the external C code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To share those functions we need to write a definition file, with a `.pxd`
    extension. Such a file only contains the types and function prototypes that we
    want share to other modules—a *public* interface. We can write the prototypes
    of our `max` and `min` functions in a file named `mathlib.pxd` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we only write the function name and arguments, without implementing
    the function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function implementation goes into the implementation file with the same
    base name but `.pyx` extension—`mathlib.pyx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `mathlib` module is now importable from another Cython module.
  prefs: []
  type: TYPE_NORMAL
- en: To test our Cython module we will create a file named `distance.pyx` containing
    a function named `chebyshev`. The function will calculate the Chebyshev distance
    between two points, as shown in the following code. The Chebyshev distance between
    two coordinates (x1, y1) and (x2, y2) is defined as the maximum value of the difference
    between each coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `chebyshev` function we will use the `max` function, declared
    in `mathlib.pxd` by importing it with the `cimport` statement, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `cimport` statement will read `hello.pxd` and the `max` definition will
    be used to generate the `distance.c` file.
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numerical and high performance calculations often make use of arrays. Cython
    provides an easy way to interact with them, from the low-level approach of C arrays,
    to the more general *typed memoryviews*.
  prefs: []
  type: TYPE_NORMAL
- en: C arrays and pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C arrays are a collection of items of the same size stored contiguously in memory.
    Before digging into the details, it is helpful to understand (or review) how memory
    is managed in C.
  prefs: []
  type: TYPE_NORMAL
- en: Variables in C are like containers. When creating a variable, a space in memory
    is reserved to store its value. For example, if we create a variable containing
    a 64 bit floating point number (`double`), the program will allocate 64 bit (16
    bytes) of memory. This portion of memory can be accessed through an address to
    that memory location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the address of a variable we can use the *address operator*, denoted
    with the `&` symbol. We can also use the `printf` function, as follows, available
    in the `libc.stdio` Cython module to print the address of this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Memory addresses can be stored in special variables—*pointers*—declared by
    putting a `*` prefix on the variable name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If we have a pointer and we want to grab the value contained in the address
    it's pointing at, we can use the *dereference operator*, denoted with the `*`
    symbol, as shown in the following code. Be careful, the `*` used in this context
    has a different meaning from the `*` used in the variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When declaring a C array, the program allocates enough space to contain several
    elements of the specified size. For instance, to create an array that has 10 `double`
    values (8 bytes each), the program will reserve *8 * 10 = 80* bytes of contiguous
    space in memory. In Cython we can declare such an array using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare a multidimensional array, like an array with 5 rows and
    2 columns using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The memory will be allocated in a single block of memory, row after row. This
    order is commonly referred to as *row-major* and is represented in the following
    figure. Arrays can also be ordered *column-mayor*, as it happens in the FORTRAN
    programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '![C arrays and pointers](img/8458_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Array ordering has important consequences. When iterating a C array over the
    last dimension, we access contiguous memory blocks (in our example 0, 1, 2, 3
    …)while when we iterate on the first dimension, we skip a few positions (0, 2,
    4, 6, 8, 1 … ). You should always try to access memory contiguously as this optimizes
    cache usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can store and retrieve elements from the array by using standard indexing,
    C arrays don''t support fancy indexing or slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'C arrays can also be used as pointers. The `arr` variable, in fact, is a pointer
    to the first element of the array. We can verify that the address of the first
    element of the array is the same as the address contained in the variable `arr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You should use C arrays and pointers when interfacing with existing C libraries
    or when you need a fine control over the memory. For more common use-cases you
    can employ NumPy arrays or typed memoryviews.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy arrays can be used in Cython as normal Python objects, by using their
    already optimized broadcasted operations.
  prefs: []
  type: TYPE_NORMAL
- en: The problem comes when we want to efficiently iterate over the array. When we
    do an indexing operation on a NumPy array, a few other operations take place at
    the interpreter level causing a major overhead. Cython can optimize those indexing
    operations by acting directly on the underlying memory area used by NumPy arrays,
    allowing us to treat them just like C arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy array support comes in the form of a `ndarray` data type. We first have
    to `cimport` the `numpy` module. We assign it to the name `c_np` to differentiate
    it from the regular `numpy` Python module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now declare a NumPy array by specifying the type of the array elements
    and the number of dimensions, with a special syntax called *buffer syntax*. To
    declare a two-dimensional array of type `double` we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: An array defined in this way will be indexed by acting directly on the underlying
    memory area; the operation will avoid the Python interpreter giving us a tremendous
    speed boost.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we will show the usage of the buffer syntax and compare
    it with the normal Python version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first write the `numpy_bench_py` function that increments each element of
    `py_arr` by 1000\. We declared the index `i` as integer so that we avoid the `for`
    loop overhead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we write the same function using the buffer syntax. Notice that after
    we define the `c_arr` variable using `c_np.ndarray`, we can assign to it an array
    from the `numpy` Python module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can time the results using `timeit`, obtaining an impressive 50x speedup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Typed memoryviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C and NumPy arrays are both objects that act on a memory area. Cython provides
    a universal object—the *typed memoryview*—to access arrays and other data structures
    that expose the so called *buffer interface*, such as the built-ins `bytes`, `bytearray`,
    and `array.array`.
  prefs: []
  type: TYPE_NORMAL
- en: A **memoryview** is an object that maintains a reference on a certain memory
    area. It doesn't actually own the memory, but it can read and change its content
    (it is a *view*). By using typed memoryviews we can interact with both C and NumPy
    arrays in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memoryviews can be defined using a special syntax. We can define a memoryview
    of `int` and a 2D memoryview of `double` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The same syntax applies to function definitions, class attributes, and so on.
    Any object that exposes a buffer interface will automatically be bound to the
    memoryview. We can bind the memoryview to an array by the following simple assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The new memoryview will share the data with the NumPy array. Changes in the
    array elements will be shared between the two data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In a certain sense, the memoryview is a generalization of a NumPy array. As
    we have seen in [Chapter 2](ch02.html "Chapter 2. Fast Array Operations with NumPy"),
    *Fast Array Operations with Numpy*, slicing a NumPy array does not copy the data
    but returns a view on the same memory area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memoryviews also support array slicing with the following standard NumPy syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy data between a memoryview and another, you can use a syntax similar
    to the slice assignment, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will use the typed memoryviews to handle the arrays
    in our particle simulator application.
  prefs: []
  type: TYPE_NORMAL
- en: Particle simulator in Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding on how Cython works we can rewrite the
    `ParticleSimulator.evolve` method. Thanks to Cython, we can convert our loops
    in C, thus removing the overhead introduced by the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Fast Array Operations with NumPy"), *Fast
    Array Operations with Numpy*, we wrote a fairly efficient version of the `evolve`
    method using NumPy. We can rename the old version as `evolve_numpy` to differentiate
    it from the new version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We want to convert this code to Cython. Our strategy will be to take advantage
    of the fast indexing operations by removing the NumPy array broadcasting, thus
    reverting to an indexing-based algorithm. Since Cython generates efficient C code,
    we are free to use as many loops as we like without any performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: As a design choice, we can decide to encapsulate the loop in a function that
    we will rewrite in a Cython module called `cevolve.pyx.` The module will contain
    a single Python function `c_evolve` that will take the particle positions, the
    angular velocities, the timestep, and the number of steps as input.
  prefs: []
  type: TYPE_NORMAL
- en: At first, we are not adding typing information; we just want to isolate the
    function and make sure that we can compile our module without errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we don''t need a return value for `c_evolve`, as values are updated
    in the `r_i` array in-place. We can benchmark the untyped Cython version against
    the old NumPy version by slightly changing our benchmark function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can time the different versions in an IPython shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The two versions have the same speed. Compiling the Cython module without static
    typing doesn't have any advantage over pure Python. The next step, is to declare
    the type of all the important variables so that Cython can perform its optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: We can start by adding types to the function arguments. We will declare the
    arrays as typed memoryviews containing `double` values. It is worth mentioning
    that if we pass an array of `int` or `float32` type, the casting won't happen
    automatically and we would get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At that point, we want to rewrite the loops over the particles and time steps.
    We can declare the iteration variables `i, j` and the particle number `nparticles`
    as `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point the algorithm is very similar to the pure Python version; we
    iterate over the particles and time steps and we compute the velocity and displacement
    vectors for each particle coordinate, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we added the `x`, `y`, `ang_speed`, `norm`, `vx`, `vy`,
    `dx`, and `dy` variables. To avoid the Python interpreter overhead we have to
    declare them with their corresponding types at the beginning of the function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We also used a function called `sqrt` to calculate the norm. If we use the
    `sqrt` present in the `math` module or the one in `numpy`, we would again include
    a slow Python function in our critical loop, thus killing our performance. A fast
    `sqrt` is available in the standard C library, already wrapped in the `libc.math`
    Cython module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After recompiling, we can re-run our benchmark to assess our improvements,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For small particle numbers the speed-up is massive, we obtained a 40x performance
    improvement over the previous version. However, we should also try with a larger
    number of particles to test the performance scaling, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As we increase the number of particles, the two versions get closer in speed.
    By increasing the particle size to 1000 we already decreased our speed-up to a
    more modest 6x. This is likely due to the fact that as we increase the number
    of particles the Python for-loop overhead gets less and less significant compared
    to the speed of the other operations.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cython gives us a wonderful tool to quickly find the slow spots due to the
    Python interpreter—a feature called *annotated view*. We can turn on this feature
    by compiling a Cython file with the `-a` option, using the following command line.
    Cython will generate a HTML file containing our code annotated with some useful
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML file displayed in the following screenshot shows our Cython file line-by-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profiling Cython](img/8458_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each line has a background color in different shades of yellow; an intense color
    means that the code has a lot of interpreter-related calls, while white lines
    gets translated to pure C. Since interpreter calls are typically slow, the objective
    is to make the function body as white as possible. By clicking on any of the lines
    we can see the C code generated by the Cython compiler. For example, the line
    `v_y = x/norm` checks that the norm is not 0, raising a `ZeroDivisionError` otherwise.
    The line `x = r_i[j, 0]` shows that Cython checks that the indexes are within
    the bounds of the array. You may notice that the last line is of a very intense
    color, by inspecting the code we can see that this is actually a glitch; the code
    refers to a boilerplate related to the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cython can shut down those checks to improve speed using its compiler directives.
    There are three different ways to add compiler directives:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a decorator or a context manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a comment at the beginning of the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Cython command line options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of the Cython compiler directives you can refer to the official
    documentation at [http://docs.cython.org/src/reference/compilation.html#compiler-directives](http://docs.cython.org/src/reference/compilation.html#compiler-directives)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, to disable the "bounds" checking of arrays, it is sufficient to
    decorate a function with `cython.boundscheck` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `cython.boundscheck` to wrap a block of code into a context manager,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to disable bounds checking for a whole module we can add the following
    line of code at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To alter the directives with the command line options you can use `-X` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now try to avoid the extra checks in our function by disabling the `boundscheck`
    directive and enabling `cdivision` (this disables the checks for `ZeroDivisionError`)
    as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the annotated view again, the loop body is completely white;
    we removed all traces of the interpreter from the loop. In the following case
    however, we didn''t obtain a performance improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can profile Cython code with `cProfile` by including the `profile=True`
    directive in our files. To show its usage we can write a function that calculates
    the Chebyshev distance between two arrays of coordinates. Create a file `cheb.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try profiling this script as-is, we won''t get any statistics regarding
    the functions that we implemented in Cython. If we want to know the profile metrics
    for the `max` and `min` functions we have to add the `profile=True` option to
    the `mathlib.pyx` file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now profile our script with `%prun` using IPython, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we can see that the `max` function is present and is not a
    bottleneck. The problem seems to be lying in the `benchmark` function; the issue
    is likely to be the Python for-loop overhead. In this case, the best strategy
    would be rewriting the loop in NumPy or port the code to Cython.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cython will bring the speed of your programs to another level. Cython programs
    are much easier to maintain in comparison to C, thanks to the tight integration
    with Python and the availability of profiling tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we introduced the basics of the Cython language and how to
    make our programs faster by adding static types. We also learned how to work with
    C arrays, NumPy arrays, and memoryviews.
  prefs: []
  type: TYPE_NORMAL
- en: We optimized our particle simulator by rewriting the critical `evolve` function,
    obtaining a tremendous speed gain. Finally, we learned how to use the annotated
    view to quickly spot interpreter related calls and how to enable `cProfile` for
    Cython scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn the parallel processing basics and see how
    to write Python programs that take advantage of multiple processors so that you
    can write faster programs and solve larger problems.
  prefs: []
  type: TYPE_NORMAL
