- en: Chapter 28
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第28章
- en: Tips and Tricks with Loop Control Structures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 循环控制结构的技巧和窍门
- en: 28.1 Introduction
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.1 简介
- en: This chapter is dedicated to teaching you some useful tips and tricks that can
    help you write “better” code. You should always keep them in mind when you design
    your own algorithms, or even your own Python programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于向您介绍一些有用的技巧和窍门，这些技巧和窍门可以帮助您编写“更好”的代码。在设计自己的算法或甚至自己的Python程序时，您应始终牢记这些技巧。
- en: These tips and tricks can help you increase your code's readability, help you
    choose which loop control structure is better to use in each given problem, and
    help make the code shorter or even faster. Of course there is no single perfect
    method because on one occasion the use of a specific tip or trick may help, but
    on another occasion the same tip or trick may have exactly the opposite result.
    Most of the time, code optimization is a matter of programming experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧和窍门可以帮助您提高代码的可读性，帮助您选择在给定问题中哪种循环控制结构更好，并帮助使代码更短或甚至更快。当然，没有单一完美的方法，因为有时使用特定的技巧或窍门可能会有所帮助，但在另一种情况下，相同的技巧或窍门可能会有完全相反的结果。大多数时候，代码优化是编程经验的问题。
- en: '![](img/remember.jpg)Smaller algorithms are not always the best solution to
    a given problem. In order to solve a specific problem, you might write a concise
    algorithm that unfortunately proves to consume a significant amount of CPU time
    and/or a large portion of main memory (RAM). On the other hand, you might solve
    the same problem with another algorithm that appears longer but calculates the
    result much faster and/or utilizes less RAM.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/remember.jpg)较小的算法并不总是解决特定问题的最佳方案。为了解决特定问题，您可能编写了一个简洁的算法，不幸的是，这个算法证明消耗了大量的CPU时间以及/或大量主内存（RAM）。另一方面，您可能使用另一个算法来解决相同的问题，该算法看起来更长，但计算结果更快以及/或使用更少的RAM。'
- en: 28.2 Choosing a Loop Control Structure
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.2 选择循环控制结构
- en: The following diagram can help you choose the most appropriate loop control
    structure to use in each given problem, depending on the number of iterations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表可以帮助您根据迭代次数选择在给定问题中使用的最合适的循环控制结构。
- en: '![Image](img/chapter28-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter28-01.png)'
- en: '![](img/notice.jpg)This diagram recommends the best option, not the only option.
    For example, when the number of iterations is known, it is not wrong to use a
    pre-test or a post-test loop structure instead. The proposed for-loop, though,
    is more convenient.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)此图推荐最佳选项，而非唯一选项。例如，当迭代次数已知时，使用预测试或后测试循环结构并非错误。然而，提出的for循环更为方便。'
- en: 28.3 The “Ultimate” Rule
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.3 “终极”规则
- en: One question that often preys on programmers' minds when using pre-test or post-test
    loop structures, is how to determine which statements should be written inside,
    and which outside, the loop control structure and in which order.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用预测试或后测试循环结构时，程序员常常会问的一个问题是，如何确定哪些语句应该写入循环控制结构内部，哪些应该写入外部，以及它们的顺序。
- en: There is one simple yet powerful rule—the “Ultimate” rule! Once you follow it,
    the potential for making a logic error is reduced to zero!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单而强大的规则——“终极”规则！一旦您遵循它，逻辑错误的潜在风险就会降至零！
- en: 'The “Ultimate” rule states:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “终极”规则指出：
- en: ►The variable or variables that participate in a loop's Boolean expression must
    be initialized before entering the loop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ► 参与循环布尔表达式的变量或变量必须在进入循环之前初始化。
- en: ►The value of the variable or variables that participate in a loop's Boolean
    expression must be updated (altered) within the loop. And more specifically, the
    statement that does this update/alteration must be one of the last statements
    of the loop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ► 变量或参与循环布尔表达式的变量值必须在循环内更新（更改）。更具体地说，执行此更新/更改的语句必须是循环的最后一个语句之一。
- en: For example, if variable x is the variable that participates in a loop's Boolean
    expression, a pre-test loop structure should be in the following form,
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果变量x是参与循环布尔表达式的变量，则预测试循环结构应采用以下形式，
- en: Initialize x
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化x
- en: 'while Boolean_Expression(x):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'while Boolean_Expression(x):'
- en: A statement or block of statements
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语句或语句块
- en: Update/alter x
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更新/更改x
- en: and a post-test loop structure should be in the following form,
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以及后测试循环结构应采用以下形式，
- en: Initialize x
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化x
- en: 'while True:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: A statement or block of statements
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语句或语句块
- en: Update/alter x
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更新/更改x
- en: 'if Boolean_Expression(x): break'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 'if Boolean_Expression(x): break'
- en: where
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '►Initialize x is any statement that assigns an initial value to variable x.
    It can be either an input statement such as input("Enter a number: "), or an assignment
    statement using the value assignment operator ( = ). In a post-test loop structure
    though, this statement may sometimes be redundant and can be omitted since initialization
    of x can occur directly inside the loop.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ►初始化x是任何为变量x分配初始值的语句。它可以是输入语句，如input("输入一个数字：")，或者使用值赋值运算符（=）的赋值语句。然而，在后测试循环结构中，这个语句有时可能是多余的，可以省略，因为x的初始化可以直接在循环内部进行。
- en: ►Boolean_Expression(x) can be any Boolean expression from a simple to a complex
    one, dependent on variable x.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ►布尔_表达式(x)可以是任何从简单到复杂的布尔表达式，取决于变量x。
- en: ►Update/alter x is any statement that alters the value of x, such as another
    input statement, an assignment statement using the value assignment operator (
    = ), or even compound assignment operators. It is important that this statement
    must be positioned just before the point where the loop's Boolean expression is
    evaluated. This means it should be one of the last statements within the loop.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ►更新/修改x是任何改变x值的语句，例如另一个输入语句，使用值赋值运算符（=）的赋值语句，或者甚至是复合赋值运算符。重要的是，这个语句必须位于循环布尔表达式评估点之前。这意味着它应该是循环中最后的语句之一。
- en: Following are some examples that use the “Ultimate” rule.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用“终极”规则的示例。
- en: Example 1
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1
- en: a = int(input())  #Initialization of a
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())  #a的初始化
- en: 'while a > 0:  #Boolean expression dependent on a'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'while a > 0:  #依赖于a的布尔表达式'
- en: print(a)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: print(a)
- en: a = a – 1  #Update/alteration of a
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: a = a – 1  #a的更新/修改
- en: Example 2
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2
- en: a = int(input())  #Initialization of a
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())  #a的初始化
- en: b = int(input())  #Initialization of b
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())  #b的初始化
- en: 'while a > b:  #Boolean expression dependent on a and b'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'while a > b:  #依赖于a和b的布尔表达式'
- en: print(a, b)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: print(a, b)
- en: a = int(input())  #Update/alteration of a
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())  #a的更新/修改
- en: b = int(input())  #Update/alteration of b
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())  #b的更新/修改
- en: Example 3
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3
- en: s = 0  #Initialization of s
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0  #s的初始化
- en: 'while True:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: y = int(input())
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: y = int(input())
- en: s = s + y  #Update/alteration of s
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: s = s + y  #s的更新/修改
- en: 'if s >= 1000: break  #Boolean expression dependent on s'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'if s >= 1000: break  #依赖于s的布尔表达式'
- en: Example 4
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4
- en: y = 0  #Initialization of y
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: y = 0  #y的初始化
- en: 'while True:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: y = int(input())  #Update/alteration of y
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: y = int(input())  #y的更新/修改
- en: 'if y >= 0: break  #Boolean expression dependent on y'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'if y >= 0: break  #依赖于y的布尔表达式'
- en: In this example, though, initialization of variable y outside the loop is redundant
    and can be omitted, as shown here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，尽管变量y在循环外部的初始化是多余的，可以省略，如下所示。
- en: 'while True:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: y = int(input())  #Initialization and update/alteration of y
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: y = int(input())  #y的初始化和更新/修改
- en: 'if y >= 0: break  #Boolean expression dependent on y'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'if y >= 0: break  #依赖于y的布尔表达式'
- en: Example 5
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5
- en: 'odd = 0   #Initialization of odd'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'odd = 0   #odd的初始化'
- en: even = 0  #Initialization of even
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: even = 0  #even的初始化
- en: 'while odd + even < 5:  #Boolean expression dependent on odd and even'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'while odd + even < 5:  #依赖于odd和even的布尔表达式'
- en: x = int(input())
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: x = int(input())
- en: 'if x % 2 == 0:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x % 2 == 0:'
- en: even += 1  #Update/alteration of even
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: even += 1  #even的更新/修改
- en: 'else:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'odd += 1   #Update/alteration of odd'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'odd += 1   #odd的更新/修改'
- en: print("Odds:", odd, "Evens:", even)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: print("奇数:", odd, "偶数:", even)
- en: 'Now, you will realize why you should always follow the “Ultimate” rule”! Let''s
    take a look at the following exercise:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会意识到为什么你应该始终遵循“终极”规则！让我们看看以下练习：
- en: Write a code fragment that lets the user enter numbers repeatedly until three
    positive numbers are entered in total.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个代码片段，允许用户重复输入数字，直到总共输入了三个正数。
- en: This exercise was given to a class, and a student gave the following code fragment
    as an answer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习被给了一个班级，一个学生给出了以下代码片段作为答案。
- en: positivesCount = 0
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: positivesCount = 0
- en: x = float(input())
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: x = float(input())
- en: 'while positivesCount != 3:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'while positivesCount != 3:'
- en: 'if x > 0:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 0:'
- en: positivesCount += 1
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: positivesCount += 1
- en: x = float(input())
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: x = float(input())
- en: print("Three positives provided!")
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: print("提供了三个正数！")
- en: At first glance it appears to be correct. It lets the user enter a number, enters
    the loop, checks whether the user-provided number is positive or not, then lets
    the user enter a second number, and so on. However, this code contains a logic
    error—and unfortunately, it's a tricky one. Can you spot it?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这似乎是正确的。它允许用户输入一个数字，进入循环，检查用户提供的数字是否为正数，然后让用户输入第二个数字，以此类推。然而，这段代码中存在一个逻辑错误——而且不幸的是，这是一个棘手的错误。你能找到它吗？
- en: Follow the flow of execution by trying various input values—positives, negatives,
    or even zeros. When the user enters a positive number, the variable positivesCount
    increments by one; and when they enter a negative number or zero, it remains unchanged.
    Everything appears to runs smoothly, doesn't it? —so smoothly that it might make
    you question if this book is reliable or if you should throw it away!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尝试各种输入值（正数、负数或零）来遵循执行流程。当用户输入一个正数时，变量正数计数增加一个；而当他们输入一个负数或零时，它保持不变。一切看起来似乎运行得都很顺利，不是吗？——如此顺利，以至于你可能质疑这本书是否可靠，或者你是否应该扔掉它！
- en: The problem becomes evident only when the user attempts to enter all three of
    the expected positive values. The trace table that follows can help you determine
    where the problem lies. Let's assume that the user wants to enter the values 5,
    −10, −2, 4, and 20.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当用户尝试输入所有三个预期的正数值时，问题才会变得明显。下面的跟踪表可以帮助你确定问题所在。假设用户想要输入的值是5、-10、-2、4和20。
- en: '| Step | Statement | Notes | positivesCount | x |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 说明 | 备注 | 正数计数 | x |'
- en: '| 1 | positivesCount = 0 |   | 0 | ? |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 正数计数 = 0 |  | 0 | ? |'
- en: '| 2 | x = float(input()) |   | 0 | 5.0 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 2 | x = float(input()) |  | 0 | 5.0 |'
- en: '| 3 | while positivesCount != 3 | This evaluates to True |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 3 | while 正数计数 != 3 | 这将评估为 True |'
- en: '| 4 | if x > 0 | This evaluates to True |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 4 | if x > 0 | 这将评估为 True |'
- en: '| 5 | positivesCount += 1 |   | 1 | 5.0 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 正数计数 += 1 |  | 1 | 5.0 |'
- en: '| 6 | x = float(input()) |   | 1 | −10.0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 6 | x = float(input()) |  | 1 | -10.0 |'
- en: '| 7 | while positivesCount != 3 | This evaluates to True |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 7 | while 正数计数 != 3 | 这将评估为 True |'
- en: '| 8 | if x > 0 | This evaluates to False |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 8 | if x > 0 | 这将评估为 False |'
- en: '| 9 | x = float(input()) |   | 1 | −2.0 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 9 | x = float(input()) |  | 1 | -2.0 |'
- en: '| 10 | while positivesCount != 3 | This evaluates to True |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 10 | while 正数计数 != 3 | 这将评估为 True |'
- en: '| 11 | if x > 0 | This evaluates to False |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 11 | if x > 0 | 这将评估为 False |'
- en: '| 12 | x = float(input()) |   | 1 | 4.0 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 12 | x = float(input()) |  | 1 | 4.0 |'
- en: '| 13 | while positivesCount != 3 | This evaluates to True |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 13 | while 正数计数 != 3 | 这将评估为 True |'
- en: '| 14 | if x > 0 | This evaluates to True |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 14 | if x > 0 | 这将评估为 True |'
- en: '| 15 | positivesCount += 1 |   | 2 | 4.0 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 正数计数 += 1 |  | 2 | 4.0 |'
- en: '| 16 | x = float(input()) |   | 2 | 20.0 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 16 | x = float(input()) |  | 2 | 20.0 |'
- en: '| 17 | while positivesCount != 3 | This evaluates to True |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 17 | while 正数计数 != 3 | 这将评估为 True |'
- en: '| 18 | if x > 0 | This evaluates to True |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 18 | if x > 0 | 这将评估为 True |'
- en: '| 19 | positivesCount += 1 |   | 3 | 20.0 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 正数计数 += 1 |  | 3 | 20.0 |'
- en: '| 20 | x = float(input()) |   | 3 | ??? |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 20 | x = float(input()) |  | 3 | ??? |'
- en: And here is the logic error! At step 20, even though the total number of user-provided
    positives is three, and you expect the execution to end, unfortunately the user
    is being asked to enter an additional number! But, you needed a code fragment
    that lets the user enter three positive numbers, not four, right?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是逻辑错误！在第20步，尽管用户提供的正数总数是三个，你期望执行结束，但不幸的是，用户被要求再输入一个数字！但是，你需要一个代码片段让用户输入三个正数，而不是四个，对吧？
- en: This is why you should always go by the book! Let's see how this code fragment
    should be written.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么你应该始终按照书上的来做！让我们看看这个代码片段应该如何编写。
- en: Since the Boolean expression of the while-loop is dependent on the variable
    positivesCount, this is the variable that must be initialized outside of the loop.
    This variable must also be updated/altered within the loop. The statement that
    does this update/alteration must be the last statement within the loop, as shown
    in the code fragment (in general form) that follows.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于while循环的布尔表达式依赖于变量正数计数，因此这个变量必须在循环外部初始化。此变量还必须在循环内部更新/更改。执行此更新/更改的语句必须是循环中的最后一个语句，如下面的代码片段（以一般形式）所示。
- en: positivesCount = 0    #Initialization of positivesCount
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '正数计数 = 0  # 正数计数的初始化'
- en: 'while positivesCount != 3: #This is dependent on positivesCount'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'while 正数计数 != 3: # 这依赖于正数计数'
- en: A statement or block of statements
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语句或语句块
- en: 'if x > 0:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 0:'
- en: 'positivesCount += 1   #Update/alteration of positivesCount'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '正数计数 += 1  # 正数计数的更新/更改'
- en: Now you can add any necessary statements to complete the code. The only statements
    that you need to add here are the statement that lets the user enter a number
    (this must be done within the loop), and the statement that displays the last
    message (this must be done when the loop finishes all of its iterations). So,
    the final code fragment becomes
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以添加任何必要的语句来完成代码。你只需要添加的语句是允许用户输入一个数字的语句（这必须在循环内部完成），以及显示最后信息的语句（这必须在循环完成所有迭代时完成）。因此，最终的代码片段变为
- en: positivesCount = 0
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: positivesCount = 0
- en: 'while positivesCount != 3:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当 positivesCount 不等于 3 时：
- en: x = float(input())
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: x = float(input())
- en: 'if x > 0:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 x 大于 0：
- en: positivesCount += 1
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: positivesCount += 1
- en: print("Three positives provided!")
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("提供了三个正数！")
- en: 28.4 Breaking Out of a Loop
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.4 从循环中退出
- en: Loops can consume too much CPU time so you have to be very careful when you
    use them. There are times when you need to break out of, or end, a loop before
    it completes all of its iterations, usually when a specified condition is met.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 循环可能会消耗过多的 CPU 时间，所以当你使用它们时必须非常小心。有时在满足特定条件之前，你需要跳出或结束循环，通常是在满足特定条件时。
- en: Suppose there is a hidden password and you somehow know that it is three characters
    long, containing only digits. The following for-loop performs 900 iterations in
    an attempt to find that hidden password using a brute-force attack.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个隐藏的密码，你某种方式知道它由三个字符组成，只包含数字。下面的 for 循环通过暴力攻击尝试在 900 次迭代中找到那个隐藏的密码。
- en: found = False
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: found = False
- en: 'for i in range(100, 1000):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100, 1000):'
- en: 'if i == hiddenPassword:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 i 等于 hiddenPassword：
- en: password = i
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: password = i
- en: found = True
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: found = True
- en: 'if found == True:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 found 等于 True：
- en: print("Hidden password is:", password)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("隐藏的密码是：", password)
- en: '![](img/notice.jpg)A brute-force attack is the simplest method to gain access
    to anything that is password protected. An attacker tries combinations of letters,
    numbers, and symbols with the hope of eventually guessing correctly.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)暴力攻击是获取任何受密码保护的访问权限的最简单方法。攻击者尝试字母、数字和符号的组合，希望最终猜对。'
- en: Now, suppose that the hidden password is 123\. As you already know, the for-loop
    iterates a specified number of times, and in this case, it doesn't care whether
    the hidden password is actually found or not. Even though the password is found
    in the 24^(th) iteration, the loop unfortunately continues to iterate until variable
    i reaches the value of 999, thus wasting CPU time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设隐藏的密码是 123。正如你所知，for 循环会迭代指定的次数，在这种情况下，它并不关心是否找到了隐藏的密码。即使密码在 24 次迭代中被找到，循环仍然不幸地继续迭代，直到变量
    i 达到 999 的值，从而浪费了 CPU 时间。
- en: Someone may argue that 800 – 900 iterations are not a big deal, and they would
    probably be right. However, in large-scale data processing, every iteration counts.
    Therefore, you should be very careful when using loop control structures, especially
    those that iterate too many times. What if the hidden password was ten digits
    long? This would mean that the for-loop would have to perform 9,000,000,000 iterations!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会说 800 – 900 次迭代并不是什么大问题，他们可能是对的。然而，在大规模数据处理中，每一次迭代都很重要。因此，在使用循环控制结构时，你应该非常小心，特别是那些迭代次数太多的结构。如果隐藏的密码是十位数长呢？这意味着
    for 循环将不得不执行 9,000,000,000 次迭代！
- en: There are two approaches that can help you make programs like the previous one
    run faster. The main idea, in both of them, is to break out of the loop when a
    specified condition is met; in this case when the hidden password is found.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以帮助你使像前面的程序一样运行得更快。这两种方法的主要思想都是在满足特定条件时跳出循环；在这种情况下，当找到隐藏的密码时。
- en: First approach – Using the break statement
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法 - 使用 break 语句
- en: You can break out of a loop before it actually completes all of its iterations
    by using the break statement.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 break 语句在循环实际完成所有迭代之前跳出循环。
- en: Look at the following Python program. When the hidden password is found, the
    flow of execution immediately exits (breaks out of) the for-loop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的 Python 程序。当隐藏的密码被找到时，执行流程立即退出（跳出）for 循环。
- en: found = False
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: found = False
- en: 'for i in range(100, 1000):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100, 1000):'
- en: 'if i == hiddenPassword:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 i 等于 hiddenPassword：
- en: password = i
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: password = i
- en: found = True
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: found = True
- en: break
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: break
- en: 'if found:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 found：
- en: print("Hidden password is:", password)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("隐藏的密码是：", password)
- en: '![](img/notice.jpg)The statement if found is equivalent to the statement if
    found == True'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)if found 等价于 if found == True'
- en: Second approach – Using a flag
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法 - 使用标志
- en: The break statement doesn't actually exist in all computer languages; and since
    this book's intent is to teach you “Algorithmic Thinking” (and not just special
    statements that only Python supports), let's look at an alternate approach.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: break 语句并不是所有计算机语言都有的；由于这本书的目的是教你“算法思维”（而不仅仅是 Python 支持的特殊语句），让我们看看一种替代方法。
- en: In the following Python program, when the hidden password is found, the Boolean
    expression found == False forces the flow of execution to exit the loop.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 Python 程序中，当隐藏的密码被找到时，布尔表达式 found == False 强制执行流程退出循环。
- en: found = False
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: found = False
- en: i = 100
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: i = 100
- en: 'while found == False and i <= 999:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'while found == False and i <= 999:'
- en: 'if i == hiddenPassword:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i == hiddenPassword:'
- en: password = i
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: password = i
- en: found = True
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: found = True
- en: i += 1
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: i += 1
- en: 'if found:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'if found:'
- en: print("Hidden password is:", password)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: print("隐藏的密码是:", password)
- en: '![](img/notice.jpg)Consider variable found as a flag. Initially, the flag is
    not “raised” (found = False). The flow of execution enters the loop, and it keeps
    iterating as long as the flag remains down (while found == False …). When something
    occurs within the loop that raises the flag (assigning True to the variable found),
    the flow of execution exits the loop.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)将找到的变量视为标志。最初，标志没有被“升起”（found = False）。执行流程进入循环，只要标志保持未升起状态（while
    found == False …），就会持续迭代。当循环内部发生使标志升起（将 True 赋值给变量 found）的事件时，执行流程将退出循环。'
- en: '![](img/notice.jpg)The while found == False and i <= 999 can alternatively
    be written as while not found and i <= 999.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)while found == False and i <= 999 可以改写为 while not found
    and i <= 999。'
- en: '![](img/notice.jpg)The i <= 999 Boolean expression is still necessary in case
    the hidden password is not found.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)i <= 999 的布尔表达式仍然是必要的，以防隐藏的密码没有找到。'
- en: 28.5 Cleaning Out Your Loops
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.5 清理循环
- en: As already stated, loops can consume too much CPU time, so you must be very
    careful and use them sparingly. Although a large number of iterations is sometimes
    inevitable, there are always things that you can do to make your loops perform
    better.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，循环可能会消耗过多的 CPU 时间，所以你必须非常小心，并且要谨慎使用它们。尽管有时大量的迭代是不可避免的，但总有你可以做的事情来提高循环的性能。
- en: The next code fragment calculates the sum of the numbers 1, 2, 3, 4, 5, … 10000.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段计算了数字 1, 2, 3, 4, 5, … 10000 的总和。
- en: s = 0
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: i = 1
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1
- en: 'while True:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: countOfNumbers = 10000
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: countOfNumbers = 10000
- en: s = s + i
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: s = s + i
- en: i += 1
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: i += 1
- en: 'if i > countOfNumbers : break'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i > countOfNumbers : break'
- en: print(s)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: print(s)
- en: What you should always keep in mind when using loops, especially those that
    perform many iterations, is to avoid putting any statement inside a loop that
    serves no purposes in that loop. In the previous example, the statement countOfNumbers
    = 10000 is such a statement. Unfortunately, as long as it exists inside the loop,
    the computer executes it 10000 times for no reason, which of course affects the
    computer's performance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用循环时，尤其是执行多次迭代的循环时，你应该始终牢记一点：避免在循环中放置任何在该循环中没有任何目的的语句。在上一个例子中，countOfNumbers
    = 10000 这条语句就是这样一条语句。不幸的是，只要它存在于循环中，计算机就会无理由地执行它 10000 次，这当然会影响计算机的性能。
- en: To resolve this problem, you can simply move this statement outside the loop,
    as follows.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以简单地把这个语句移出循环，如下所示。
- en: countOfNumbers = 10000
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: countOfNumbers = 10000
- en: s = 0
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: i = 1
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1
- en: 'while True:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: s = s + i
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: s = s + i
- en: i += 1
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: i += 1
- en: 'if i > countOfNumbers: break'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i > countOfNumbers: break'
- en: print(s)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: print(s)
- en: Exercise 28.5-1 Cleaning Out the Loop
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 28.5-1 清理循环
- en: The following code fragment calculates the average value of numbers 1, 2, 3,
    4, … 10000\. Try to move as many statements as possible outside the loop to make
    the program more efficient.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段计算了数字 1, 2, 3, 4, … 10000 的平均值。尽量将尽可能多的语句移出循环，以提高程序效率。
- en: s = 0
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: 'for i in range(1, 10001):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, 10001):'
- en: s = s + i
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: s = s + i
- en: average = s / 10000
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: average = s / 10000
- en: print(average)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: print(average)
- en: Solution
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: One very common mistake that novice programmers make when calculating average
    values is to put the statement that divides the total sum by how many numbers
    there are in the sum (here average = s / 10000) inside the loop. Think about it!
    Imagine that you want to calculate your average grade in school. Your first step
    would be to calculate the sum of the grades for all 10 courses that you're taking.
    Then, when all your grades have been summed up, you would divide that sum by 10\.
    This means that you would perform 10 additions and only one division.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者在计算平均值时犯的一个非常常见的错误是将将总和除以总和中的数字数量的语句（这里 average = s / 10000）放在循环中。想想看！想象一下你想计算你在学校的学习平均成绩。你的第一步是计算你正在上的
    10 门课程的分数总和。然后，当所有分数都加起来后，你会将这个总和除以 10。这意味着你会执行 10 次加法运算和 1 次除法运算。
- en: '![](img/notice.jpg)Calculating an average is a two-step process.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)计算平均值是一个两步过程。'
- en: Therefore, it is pointless to calculate the average value inside the loop. You
    can move this statement outside and right after the loop, and leave the loop just
    to sum up the numbers as follows.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在循环中计算平均值是没有意义的。你可以将这个语句移到循环外，紧接在循环之后，并让循环仅用于求和，如下所示。
- en: s = 0
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: 'for i in range(1, 10001):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, 10001):'
- en: s = s + i
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: s = s + i
- en: average = s / 10000
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: average = s / 10000
- en: print(average)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(average)
- en: Exercise 28.5-2 Cleaning Out the Loop
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 28.5-2 清理循环
- en: The next formula
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个公式
- en: .![Image](img/chapter28-02.png)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: .![图像](img/chapter28-02.png)
- en: is solved using the following Python program, where N is provided by the user.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 Python 程序解决，其中 N 由用户提供。
- en: 'n = int(input("Enter N: "))'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'n = int(input("输入 N: "))'
- en: s = 0
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: 'for i in range(1, n + 1):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, n + 1):'
- en: denom = 0
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: denom = 0
- en: 'for j in range(1, n + 1):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(1, n + 1):'
- en: denom += j ** j
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: denom += j ** j
- en: s += i / denom
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: s += i / denom
- en: print(s)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(s)
- en: Try to move as many statements as possible outside the loop to make the program
    more efficient.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量将尽可能多的语句移出循环，以提高程序效率。
- en: Solution
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: As you can see from the formula, the denominator is common for all fractions.
    Thus, it is pointless to calculate it again and again for every fraction. You
    can calculate the denominator just once and use the result many times, as follows.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如公式所示，分母对所有分数都是共同的。因此，对每个分数重复计算它是没有意义的。您可以只计算一次分母，然后多次使用结果，如下所示。
- en: 'n = int(input("Enter N: "))'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'n = int(input("输入 N: "))'
- en: denom = 0         [[More…]](more.html#more_28_5_2_1)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: denom = 0         [[更多…]](more.html#more_28_5_2_1)
- en: 'for j in range(1, n + 1):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(1, n + 1):'
- en: denom += j ** j
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: denom += j ** j
- en: s = 0
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: 'for i in range(1, n + 1):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, n + 1):'
- en: s += i / denom
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: s += i / denom
- en: print(s)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(s)
- en: 28.6 Endless Loops and How to Stop Them
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.6 无限循环及其停止方法
- en: All while-loops must include something inside the loop that eventually leads
    the flow of execution to exit the loop. But mistakes do happen! For instance,
    the following code fragment contains an endless loop. Unfortunately, the programmer
    forgot to increase variable i inside the loop; therefore, variable i can never
    reach the value 10.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 while 循环都必须包含一些最终导致执行流程退出循环的内容。但错误确实会发生！例如，以下代码片段包含一个无限循环。不幸的是，程序员忘记在循环中增加变量
    i；因此，变量 i 永远无法达到 10 的值。
- en: i = 1
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1
- en: 'while i != 10:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'while i != 10:'
- en: print("Hello there!")
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("Hello there!")
- en: '![](img/notice.jpg)If a loop cannot stop iterating, it is called an endless
    loop or an infinite loop.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)如果一个循环无法停止迭代，它被称为无限循环或死循环。'
- en: 'Another mistake that a programmer can make is something like the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可能犯的另一个错误如下：
- en: i = 1
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1
- en: 'while i != 10:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 'while i != 10:'
- en: print("Hello there!")
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("Hello there!")
- en: i += 2
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: i += 2
- en: Even though this code fragment does contain a statement that increases variable
    i inside the loop (i += 2), unfortunately the flow of execution never exits the
    loop because the value 10 is never assigned to the variable i.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个代码片段确实包含一个在循环中增加变量 i 的语句（i += 2），但不幸的是，执行流程永远不会退出循环，因为变量 i 永远不会被赋值为 10。
- en: An endless loop continues to iterate forever, and the only way to stop it from
    iterating is to use magic forces! For example, when an application in a Windows
    operating system “hangs” (probably because the flow of execution entered an endless
    loop), the user must use the key combination ALT+CTRL+DEL to force the application
    to end.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环会永远迭代，唯一停止其迭代的方法是使用魔法力量！例如，当一个在 Windows 操作系统中的应用程序“挂起”（可能是因为执行流程进入了一个无限循环），用户必须使用键组合
    ALT+CTRL+DEL 来强制结束应用程序。
- en: In IDLE, if you execute a code that enters an endless loop, you can hit the
    CTRL+C key combination, and the Python compiler will stop the execution.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDLE 中，如果你执行一个进入无限循环的代码，你可以按 CTRL+C 键组合，Python 编译器将停止执行。
- en: In Visual Studio Code, when you accidentally write and execute an endless loop,
    you can simply click on the “Stop” ![Image](img/vs_code_stop_button.png) toolbar
    icon, and the execution will stop.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，当你意外编写并执行一个无限循环时，你可以简单地点击“停止” ![图像](img/vs_code_stop_button.png)
    工具栏图标，执行将停止。
- en: '![](img/notice.jpg)In Visual Studio Code, an alternative way to force the application
    to end is to use the key combination CTRL+C within the Terminal window.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)在 Visual Studio Code 中，强制应用程序结束的另一种方法是，在终端窗口中使用键组合 CTRL+C。'
- en: 28.7 The “From Inner to Outer” Method
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.7 从内到外的方法
- en: From inner to outer is a method proposed by this book to help you learn “Algorithmic
    Thinking” from the inside out. This method first manipulates and designs the inner
    (nested) control structures and then, as the algorithm (or the program) is developed,
    more and more control structures are added, nesting the previous ones. This method
    can be used in large and complicated control structures as it helps you design
    error-free flowcharts or even Python programs. This book uses this method wherever
    and whenever it seems necessary.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从内到外是本书提出的一种方法，旨在帮助你从内部学习“算法思维”。这种方法首先操纵和设计内部（嵌套）控制结构，然后，随着算法（或程序）的发展，会添加越来越多的控制结构，将先前的结构嵌套其中。这种方法可以用于大型和复杂控制结构，因为它有助于你设计无错误的流程图或甚至Python程序。本书在似乎必要的地方都使用了这种方法。
- en: Let's try the following example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下示例。
- en: Write a Python program that displays the following multiplication table as it
    is shown below.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，以如下所示的方式显示以下乘法表。
- en: '![Image](img/chapter28-03.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter28-03.png)'
- en: According to the “from inner to outer” method, you start by writing the inner
    control structure, and then, when everything is tested and operates fine, you
    can add the outer control structure(s).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 根据“从内到外”方法，你首先编写内部控制结构，然后，当一切测试并运行正常后，你可以添加外部控制结构（s）。
- en: So, let's try to display only the first line of the multiplication table. If
    you examine this line, it reveals that, in each multiplication, the multiplicand
    is always 1\. Let's consider the multiplicand as variable i with a value of 1\.
    The loop control structure that displays only the first line of the multiplication
    table is as follows.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试只显示乘法表的第一行。如果你检查这一行，它会揭示在每次乘法中，乘数总是1。让我们将乘数视为变量i，其值为1。显示乘法表第一行的循环控制结构如下。
- en: '![](img/my_exercise_header.png) Code Fragment 1'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) 代码片段1'
- en: 'for j in range(1, 11):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(1, 11):'
- en: print(i, "x", j, "=", i * j, end = "\t")
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: print(i, "x", j, "=", i * j, end = "\t")
- en: If you execute this code fragment, the result is
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行此代码片段，结果是
- en: '![Image](img/chapter28-04.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter28-04.png)'
- en: '![](img/remember.jpg)The special sequence of characters \t “displays” a tab
    character after each iteration. This ensures that everything is aligned properly.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/remember.jpg)特殊字符序列\t“显示”在每个迭代后一个制表符。这确保了所有内容都正确对齐。'
- en: The inner (nested) loop control structure is ready. What you need now is a way
    to execute this control structure nine times, but each time variable i must contain
    a different value, from 1 to 9\. This can be achieved as follows.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 内部（嵌套）循环控制结构已就绪。你现在需要一种方法来执行这个控制结构九次，但每次变量i必须包含不同的值，从1到9。这可以通过以下方式实现。
- en: '![](img/my_exercise_header.png) Main Code'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) 主代码'
- en: 'for i in range(1, 10):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, 10):'
- en: 'Code Fragment 1: Display one single line of the multiplication table'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段1：显示乘法表的一行
- en: print()
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '![](img/notice.jpg)The print() statement is used to “display” a line break
    between lines.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)print()语句用于在行之间“显示”换行符。'
- en: After embedding Code Fragment 1 in Main Code, the final Python program becomes
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码片段1嵌入主代码后，最终的Python程序变为
- en: '![](img/my_exercise_header.png) file_28.7'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_28.7'
- en: 'for i in range(1, 10):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, 10):'
- en: for j in range(1, 11):             [[More…]](more.html#more_28_7_1)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: for j in range(1, 11):             [[更多…]](more.html#more_28_7_1)
- en: print(i, "x", j, "=", i * j, end = "\t")
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print(i, "x", j, "=", i * j, end = "\t")
- en: print()
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '28.8 Review Questions: True/False'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.8 复习问题：正确/错误
- en: Choose true or false for each of the following statements.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对以下每个陈述选择正确或错误。
- en: 1)When the number of iterations is unknown, you can use a definite loop.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 1)当迭代次数未知时，你可以使用确定循环。
- en: 2)When the number of iterations is known, you cannot use a post-test loop structure.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 2)当迭代次数已知时，你不能使用后测试循环结构。
- en: 3)According to the “Ultimate” rule, in a pre-test loop structure, the initialization
    of the variable that participates in the loop's Boolean expression must be done
    inside the loop.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 3)根据“终极”规则，在预测试循环结构中，参与循环布尔表达式的变量的初始化必须在循环内部完成。
- en: 4)According to the “Ultimate” rule, in a pre-test loop structure, the statement
    that updates/alters the value of the variable that participates in the loop's
    Boolean expression must be the last statement within the loop.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 4)根据“终极”规则，在预测试循环结构中，更新/更改参与循环布尔表达式的变量值的语句必须是循环内的最后一个语句。
- en: 5)According to the “Ultimate” rule, in a post-test loop structure, the initialization
    of the variable that participates in the loop's Boolean expression can sometimes
    be done inside the loop.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 5)根据“终极”规则，在测试后的循环结构中，参与循环布尔表达式的变量的初始化有时可以在循环内部完成。
- en: 6)According to the “Ultimate” rule, in a post-test loop structure, the update/alteration
    of the variable that participates in the loop's Boolean expression must be the
    first statement within the loop.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 6)根据“终极”规则，在测试前的循环结构中，参与循环布尔表达式的变量的更新/修改必须是循环内的第一条语句。
- en: 7)In Python, you can break out of a loop before it completes all iterations
    using the exit statement.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 7)在Python中，你可以使用exit语句在循环完成所有迭代之前跳出循环。
- en: 8)A statement that assigns a constant value to a variable is better placed inside
    a loop control structure.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 8)将常量值赋给变量的语句最好放在循环控制结构内部。
- en: 9)In the following code fragment there is at least one statement that can be
    moved outside the for-loop.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 9)在以下代码片段中，至少有一个语句可以被移出for循环。
- en: 'for i in range(30):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(30):'
- en: a = "Hello"
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: a = "Hello"
- en: print(a)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: print(a)
- en: 10)In the following code fragment there is at least one statement that can be
    moved outside the while-loop.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 10)在以下代码片段中，至少有一个语句可以被移出while循环。
- en: s = 0
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: count = 1
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: count = 1
- en: 'while count < 100:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'while count < 100:'
- en: a = int(input())
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: s += a
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: s += a
- en: average = s / count
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: average = s / count
- en: count += 1
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: count += 1
- en: print(average)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: print(average)
- en: 11)In the following code fragment there is at least one statement that can be
    moved outside the while-loop.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 11)在以下代码片段中，至少有一个语句可以被移出while循环。
- en: s = 0
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: y = int(input())
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: y = int(input())
- en: 'while y != -99:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 'while y != -99:'
- en: s = s + y
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: s = s + y
- en: y = int(input())
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: y = int(input())
- en: 12)The following code fragment satisfies the property of finiteness.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 12)以下代码片段满足有限性的属性。
- en: i = 1
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1
- en: 'while i != 100:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'while i != 100:'
- en: print("Hello there!")
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello there!")
- en: i += 5
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: i += 5
- en: 13)When the not equal ( != ) comparison operator is used in the Boolean expression
    of a pre-test loop structure, the loop always iterates endlessly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 13)当在测试前的循环结构的布尔表达式中使用不等于（!=）比较运算符时，循环总是无限迭代。
- en: 14)The following code fragment satisfies the property of finiteness.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 14)以下代码片段满足有限性的属性。
- en: i = 0
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: 'while True:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: print("Hello there!")
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello there!")
- en: i += 5
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: i += 5
- en: 'if i >= 100: break'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i >= 100: break'
- en: '28.9 Review Questions: Multiple Choice'
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.9 复习问题：多项选择题
- en: Select the correct answer for each of the following statements.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 选择以下每个陈述的正确答案。
- en: 1)When the number of iterations is unknown, you can use
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 1)当迭代次数未知时，你可以使用
- en: a)the pre-test loop structure.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: a)测试前的循环结构。
- en: b)the post-test loop structure.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: b)测试后的循环结构。
- en: c)all of the above
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: c)所有上述选项
- en: 2)When the number of iterations is known, you can use
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 2)当迭代次数已知时，你可以使用
- en: a)the pre-test loop structure.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: a)测试前的循环结构。
- en: b)the post-test loop structure.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: b)测试后的循环结构。
- en: c)a for-loop.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: c)a for循环。
- en: d)all of the above
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: d)所有上述选项。
- en: 3)According to the “Ultimate” rule, in a pre-test loop structure, the initialization
    of the variable that participates in the loop's Boolean expression must be done
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 3)根据“终极”规则，在测试前的循环结构中，参与循环布尔表达式的变量的初始化必须
- en: a)inside the loop.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: a)循环内部。
- en: b)outside the loop.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: b)循环外部。
- en: c)all of the above
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: c)所有上述选项。
- en: 4)According to the “Ultimate” rule, in a pre-test loop structure, the update/alteration
    of the variable that participates in the loop's Boolean expression must be done
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 4)根据“终极”规则，在测试前的循环结构中，参与循环布尔表达式的变量的更新/修改必须
- en: a)inside the loop.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: a)循环内部。
- en: b)outside the loop.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: b)循环外部。
- en: c)all of the above
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: c)所有上述选项。
- en: 5)According to the “Ultimate” rule, in a post-test loop structure, the initialization
    of the variable that participates in the loop's Boolean expression can be done
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 5)根据“终极”规则，在测试后的循环结构中，参与循环布尔表达式的变量的初始化可以
- en: a)inside the loop.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: a)循环内部。
- en: b)outside the loop.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: b)循环外部。
- en: c)all of the above
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: c)所有上述选项。
- en: 6)In the following code fragment
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 6)在以下代码片段中
- en: s = 0
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: 'for i in range(100):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100):'
- en: s = s + i
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: s = s + i
- en: x = 100.0
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: x = 100.0
- en: average = s / x
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: average = s / x
- en: the number of statements that can be moved outside of the for-loop is
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 可以移出for循环的语句数量是
- en: a)0.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: a)0。
- en: b)1.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: b)1。
- en: c)2.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: c)2。
- en: d)3.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: d)3。
- en: 7)When this comparison operator is used in the Boolean expression of a post-test
    loop structure, the loop iterates forever.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 7)当这个比较运算符在测试后的循环结构的布尔表达式中使用时，循环将永远迭代。
- en: a)==
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: a)==
- en: b)!=
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: b)!=
- en: c)it depends
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: c)视情况而定
- en: 28.10 Review Exercises
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 28.10 复习练习
- en: Complete the following exercises.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下练习。
- en: 1)The following program is supposed to prompt the user to enter names repeatedly
    until the word “STOP” (used as a name) is entered. At the end, the program must
    display the total number of names entered as well as how many of these names were
    not “John”.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 1)以下程序旨在提示用户重复输入名字，直到输入“STOP”（用作名字）为止。最后，程序必须显示输入的总名字数以及其中有多少个不是“John”。
- en: countNames = 0
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: countNames = 0
- en: countNotJohns = 0
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: countNotJohns = 0
- en: name = ""
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: name = ""
- en: 'while name != "STOP":'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 'while name != "STOP":'
- en: 'name = input("Enter a name: ")'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: name = input("输入一个名字：")
- en: countNames += 1
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: countNames += 1
- en: 'if name != "John":'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'if name != "John":'
- en: countNotJohns += 1
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: countNotJohns += 1
- en: print("Total names entered:", countNames)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: print("输入的总名字数：", countNames)
- en: print("Names other than John entered:", countNotJohns)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 打印("输入的除John以外的名字有：", countNotJohns)
- en: However, the program displays wrong results! Using the “Ultimate” Rule, try
    to modify the program so that it displays the correct results.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，程序显示的结果是错误的！使用“终极”规则，尝试修改程序以显示正确的结果。
- en: 2)Write a Python program that prompts the user to enter some text. The text
    can be either a single word or a whole sentence. Then, the program must display
    a message stating whether the user-provided text is one single word or a complete
    sentence.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 2)编写一个Python程序，提示用户输入一些文本。文本可以是单个单词或整个句子。然后，程序必须显示一条消息，说明用户提供的文本是单个单词还是完整的句子。
- en: 'Hint: Search for a space character! If a space character is found, it means
    that the user entered a sentence. The program must stop searching further when
    it finds at least one space character.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：搜索空格字符！如果找到空格字符，则意味着用户输入了一个句子。程序必须在找到至少一个空格字符时停止搜索。
- en: 3)Write a Python program that prompts the user to enter a sentence. The program
    must then display the message “The sentence contains a number” if the sentence
    contains at least one number. The program must stop searching further when it
    finds at least one digit.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 3)编写一个Python程序，提示用户输入一个句子。然后，程序必须显示消息“句子中包含数字”如果句子中至少包含一个数字。程序必须在找到至少一个数字时停止搜索。
- en: 4)Correct the following code fragment so that it does not iterate endlessly.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 4)修正以下代码片段，使其不会无限循环。
- en: print("Printing all integers from 1 to 100")
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: print("打印1到100的所有整数")
- en: i = 1
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1
- en: 'while i < 101:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'while i < 101:'
- en: print(i)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: 5)Correct the Boolean expression of the following loop control structure so
    that it does not iterate endlessly.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 5)修正以下循环控制结构的布尔表达式，使其不会无限循环。
- en: print("Printing odd integers from 1 to 99")
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: print("打印1到99的奇数")
- en: i = 1
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1
- en: 'while not(i == 100):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 'while not(i == 100):'
- en: print(i)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: i += 2
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: i += 2
- en: 6)The following code fragment calculates the average value of 100 numbers entered
    by the user. Try to move as many statements as possible outside the loop to make
    it more efficient.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 6)以下代码片段计算用户输入的100个数的平均值。尽量将尽可能多的语句移出循环以提高效率。
- en: s = 0
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: i = 1
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: i = 1
- en: 'while True:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: count = 100
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: count = 100
- en: number = float(input())
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: number = float(input())
- en: s = s + number
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: s = s + number
- en: average = s / count
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: average = s / count
- en: i += 1
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: i += 1
- en: 'if i > count: break'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i > count: break'
- en: print(average)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: print(average)
- en: 7)The following formula
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 7)以下公式
- en: .![Image](img/chapter28-05.png)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: .![图片](img/chapter28-05.png)
- en: is solved using the following Python program.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: is solved using the following Python program.
- en: s = 0
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: s = 0
- en: 'for i in range(1, 101):'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, 101):'
- en: denom = 1
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: denom = 1
- en: 'for j in range(1, 101):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(1, 101):'
- en: denom *= j
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: denom *= j
- en: s += i / denom
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: s += i / denom
- en: print(s)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: print(s)
- en: Try to move as many statements as possible outside the loop to make it more
    efficient.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量将尽可能多的语句移出循环以提高效率。
- en: 8)Write a Python program that displays every combination of two integers as
    well as their resulting product, for pairs of integers between 1 and 4\. The output
    must display as follows.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 8)编写一个Python程序，显示1到4之间整数对的所有组合以及它们的乘积。输出必须如下所示。
- en: 1 x 1 = 1
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 1 x 1 = 1
- en: 1 x 2 = 2
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 1 x 2 = 2
- en: 1 x 3 = 3
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 1 x 3 = 3
- en: 1 x 4 = 4
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 1 x 4 = 4
- en: 2 x 1 = 2
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 2 x 1 = 2
- en: 2 x 2 = 4
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 2 x 2 = 4
- en: 2 x 3 = 6
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 2 x 3 = 6
- en: 2 x 4 = 8
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 2 x 4 = 8
- en: …
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: …
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: 4 x 1 = 4
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 4 x 1 = 4
- en: 4 x 2 = 8
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 4 x 2 = 8
- en: 4 x 3 = 12
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 4 x 3 = 12
- en: 4 x 4 = 16
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 4 x 4 = 16
- en: 9)Write a Python program that displays the multiplication table for pairs of
    integers between 1 and 12, as shown next. Please note that the output is aligned
    with tabs.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 9)编写一个Python程序，显示1到12之间整数对的乘法表，如下所示。请注意，输出使用制表符对齐。
- en: '![Image](img/chapter28-06.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter28-06.png)'
- en: 10)Write a Python program that prompts the user to enter an integer and then
    displays the multiplication table for pairs of integers between 1 and that integer.
    For example, if the user enters the value 5, the output must be as shown next.
    Please note that the output is aligned with tabs.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 10) 编写一个Python程序，提示用户输入一个整数，然后显示从1到该整数之间的整数对乘法表。例如，如果用户输入的值是5，输出必须像下面所示。请注意，输出是按制表符对齐的。
- en: '![Image](img/chapter28-07.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter28-07.png)'
