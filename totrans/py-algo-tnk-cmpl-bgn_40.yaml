- en: Chapter 28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tips and Tricks with Loop Control Structures
  prefs: []
  type: TYPE_NORMAL
- en: 28.1 Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter is dedicated to teaching you some useful tips and tricks that can
    help you write “better” code. You should always keep them in mind when you design
    your own algorithms, or even your own Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: These tips and tricks can help you increase your code's readability, help you
    choose which loop control structure is better to use in each given problem, and
    help make the code shorter or even faster. Of course there is no single perfect
    method because on one occasion the use of a specific tip or trick may help, but
    on another occasion the same tip or trick may have exactly the opposite result.
    Most of the time, code optimization is a matter of programming experience.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Smaller algorithms are not always the best solution to
    a given problem. In order to solve a specific problem, you might write a concise
    algorithm that unfortunately proves to consume a significant amount of CPU time
    and/or a large portion of main memory (RAM). On the other hand, you might solve
    the same problem with another algorithm that appears longer but calculates the
    result much faster and/or utilizes less RAM.'
  prefs: []
  type: TYPE_NORMAL
- en: 28.2 Choosing a Loop Control Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following diagram can help you choose the most appropriate loop control
    structure to use in each given problem, depending on the number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter28-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)This diagram recommends the best option, not the only option.
    For example, when the number of iterations is known, it is not wrong to use a
    pre-test or a post-test loop structure instead. The proposed for-loop, though,
    is more convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: 28.3 The “Ultimate” Rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One question that often preys on programmers' minds when using pre-test or post-test
    loop structures, is how to determine which statements should be written inside,
    and which outside, the loop control structure and in which order.
  prefs: []
  type: TYPE_NORMAL
- en: There is one simple yet powerful rule—the “Ultimate” rule! Once you follow it,
    the potential for making a logic error is reduced to zero!
  prefs: []
  type: TYPE_NORMAL
- en: 'The “Ultimate” rule states:'
  prefs: []
  type: TYPE_NORMAL
- en: ►The variable or variables that participate in a loop's Boolean expression must
    be initialized before entering the loop.
  prefs: []
  type: TYPE_NORMAL
- en: ►The value of the variable or variables that participate in a loop's Boolean
    expression must be updated (altered) within the loop. And more specifically, the
    statement that does this update/alteration must be one of the last statements
    of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if variable x is the variable that participates in a loop's Boolean
    expression, a pre-test loop structure should be in the following form,
  prefs: []
  type: TYPE_NORMAL
- en: Initialize x
  prefs: []
  type: TYPE_NORMAL
- en: 'while Boolean_Expression(x):'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements
  prefs: []
  type: TYPE_NORMAL
- en: Update/alter x
  prefs: []
  type: TYPE_NORMAL
- en: and a post-test loop structure should be in the following form,
  prefs: []
  type: TYPE_NORMAL
- en: Initialize x
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements
  prefs: []
  type: TYPE_NORMAL
- en: Update/alter x
  prefs: []
  type: TYPE_NORMAL
- en: 'if Boolean_Expression(x): break'
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '►Initialize x is any statement that assigns an initial value to variable x.
    It can be either an input statement such as input("Enter a number: "), or an assignment
    statement using the value assignment operator ( = ). In a post-test loop structure
    though, this statement may sometimes be redundant and can be omitted since initialization
    of x can occur directly inside the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: ►Boolean_Expression(x) can be any Boolean expression from a simple to a complex
    one, dependent on variable x.
  prefs: []
  type: TYPE_NORMAL
- en: ►Update/alter x is any statement that alters the value of x, such as another
    input statement, an assignment statement using the value assignment operator (
    = ), or even compound assignment operators. It is important that this statement
    must be positioned just before the point where the loop's Boolean expression is
    evaluated. This means it should be one of the last statements within the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Following are some examples that use the “Ultimate” rule.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())  #Initialization of a
  prefs: []
  type: TYPE_NORMAL
- en: 'while a > 0:  #Boolean expression dependent on a'
  prefs: []
  type: TYPE_NORMAL
- en: print(a)
  prefs: []
  type: TYPE_NORMAL
- en: a = a – 1  #Update/alteration of a
  prefs: []
  type: TYPE_NORMAL
- en: Example 2
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())  #Initialization of a
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())  #Initialization of b
  prefs: []
  type: TYPE_NORMAL
- en: 'while a > b:  #Boolean expression dependent on a and b'
  prefs: []
  type: TYPE_NORMAL
- en: print(a, b)
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())  #Update/alteration of a
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())  #Update/alteration of b
  prefs: []
  type: TYPE_NORMAL
- en: Example 3
  prefs: []
  type: TYPE_NORMAL
- en: s = 0  #Initialization of s
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: y = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: s = s + y  #Update/alteration of s
  prefs: []
  type: TYPE_NORMAL
- en: 'if s >= 1000: break  #Boolean expression dependent on s'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4
  prefs: []
  type: TYPE_NORMAL
- en: y = 0  #Initialization of y
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: y = int(input())  #Update/alteration of y
  prefs: []
  type: TYPE_NORMAL
- en: 'if y >= 0: break  #Boolean expression dependent on y'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, though, initialization of variable y outside the loop is redundant
    and can be omitted, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: y = int(input())  #Initialization and update/alteration of y
  prefs: []
  type: TYPE_NORMAL
- en: 'if y >= 0: break  #Boolean expression dependent on y'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5
  prefs: []
  type: TYPE_NORMAL
- en: 'odd = 0   #Initialization of odd'
  prefs: []
  type: TYPE_NORMAL
- en: even = 0  #Initialization of even
  prefs: []
  type: TYPE_NORMAL
- en: 'while odd + even < 5:  #Boolean expression dependent on odd and even'
  prefs: []
  type: TYPE_NORMAL
- en: x = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if x % 2 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: even += 1  #Update/alteration of even
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'odd += 1   #Update/alteration of odd'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Odds:", odd, "Evens:", even)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you will realize why you should always follow the “Ultimate” rule”! Let''s
    take a look at the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a code fragment that lets the user enter numbers repeatedly until three
    positive numbers are entered in total.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise was given to a class, and a student gave the following code fragment
    as an answer.
  prefs: []
  type: TYPE_NORMAL
- en: positivesCount = 0
  prefs: []
  type: TYPE_NORMAL
- en: x = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'while positivesCount != 3:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: positivesCount += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: print("Three positives provided!")
  prefs: []
  type: TYPE_NORMAL
- en: At first glance it appears to be correct. It lets the user enter a number, enters
    the loop, checks whether the user-provided number is positive or not, then lets
    the user enter a second number, and so on. However, this code contains a logic
    error—and unfortunately, it's a tricky one. Can you spot it?
  prefs: []
  type: TYPE_NORMAL
- en: Follow the flow of execution by trying various input values—positives, negatives,
    or even zeros. When the user enters a positive number, the variable positivesCount
    increments by one; and when they enter a negative number or zero, it remains unchanged.
    Everything appears to runs smoothly, doesn't it? —so smoothly that it might make
    you question if this book is reliable or if you should throw it away!
  prefs: []
  type: TYPE_NORMAL
- en: The problem becomes evident only when the user attempts to enter all three of
    the expected positive values. The trace table that follows can help you determine
    where the problem lies. Let's assume that the user wants to enter the values 5,
    −10, −2, 4, and 20.
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Statement | Notes | positivesCount | x |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | positivesCount = 0 |   | 0 | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | x = float(input()) |   | 0 | 5.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | while positivesCount != 3 | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | if x > 0 | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | positivesCount += 1 |   | 1 | 5.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | x = float(input()) |   | 1 | −10.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | while positivesCount != 3 | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | if x > 0 | This evaluates to False |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | x = float(input()) |   | 1 | −2.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | while positivesCount != 3 | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | if x > 0 | This evaluates to False |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | x = float(input()) |   | 1 | 4.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | while positivesCount != 3 | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | if x > 0 | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | positivesCount += 1 |   | 2 | 4.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | x = float(input()) |   | 2 | 20.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | while positivesCount != 3 | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | if x > 0 | This evaluates to True |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | positivesCount += 1 |   | 3 | 20.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | x = float(input()) |   | 3 | ??? |'
  prefs: []
  type: TYPE_TB
- en: And here is the logic error! At step 20, even though the total number of user-provided
    positives is three, and you expect the execution to end, unfortunately the user
    is being asked to enter an additional number! But, you needed a code fragment
    that lets the user enter three positive numbers, not four, right?
  prefs: []
  type: TYPE_NORMAL
- en: This is why you should always go by the book! Let's see how this code fragment
    should be written.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Boolean expression of the while-loop is dependent on the variable
    positivesCount, this is the variable that must be initialized outside of the loop.
    This variable must also be updated/altered within the loop. The statement that
    does this update/alteration must be the last statement within the loop, as shown
    in the code fragment (in general form) that follows.
  prefs: []
  type: TYPE_NORMAL
- en: positivesCount = 0    #Initialization of positivesCount
  prefs: []
  type: TYPE_NORMAL
- en: 'while positivesCount != 3: #This is dependent on positivesCount'
  prefs: []
  type: TYPE_NORMAL
- en: A statement or block of statements
  prefs: []
  type: TYPE_NORMAL
- en: 'if x > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'positivesCount += 1   #Update/alteration of positivesCount'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now you can add any necessary statements to complete the code. The only statements
    that you need to add here are the statement that lets the user enter a number
    (this must be done within the loop), and the statement that displays the last
    message (this must be done when the loop finishes all of its iterations). So,
    the final code fragment becomes
  prefs: []
  type: TYPE_NORMAL
- en: positivesCount = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while positivesCount != 3:'
  prefs: []
  type: TYPE_NORMAL
- en: x = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if x > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: positivesCount += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Three positives provided!")
  prefs: []
  type: TYPE_NORMAL
- en: 28.4 Breaking Out of a Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loops can consume too much CPU time so you have to be very careful when you
    use them. There are times when you need to break out of, or end, a loop before
    it completes all of its iterations, usually when a specified condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose there is a hidden password and you somehow know that it is three characters
    long, containing only digits. The following for-loop performs 900 iterations in
    an attempt to find that hidden password using a brute-force attack.
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100, 1000):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if i == hiddenPassword:'
  prefs: []
  type: TYPE_NORMAL
- en: password = i
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found == True:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hidden password is:", password)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A brute-force attack is the simplest method to gain access
    to anything that is password protected. An attacker tries combinations of letters,
    numbers, and symbols with the hope of eventually guessing correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that the hidden password is 123\. As you already know, the for-loop
    iterates a specified number of times, and in this case, it doesn't care whether
    the hidden password is actually found or not. Even though the password is found
    in the 24^(th) iteration, the loop unfortunately continues to iterate until variable
    i reaches the value of 999, thus wasting CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: Someone may argue that 800 – 900 iterations are not a big deal, and they would
    probably be right. However, in large-scale data processing, every iteration counts.
    Therefore, you should be very careful when using loop control structures, especially
    those that iterate too many times. What if the hidden password was ten digits
    long? This would mean that the for-loop would have to perform 9,000,000,000 iterations!
  prefs: []
  type: TYPE_NORMAL
- en: There are two approaches that can help you make programs like the previous one
    run faster. The main idea, in both of them, is to break out of the loop when a
    specified condition is met; in this case when the hidden password is found.
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Using the break statement
  prefs: []
  type: TYPE_NORMAL
- en: You can break out of a loop before it actually completes all of its iterations
    by using the break statement.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the following Python program. When the hidden password is found, the
    flow of execution immediately exits (breaks out of) the for-loop.
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100, 1000):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if i == hiddenPassword:'
  prefs: []
  type: TYPE_NORMAL
- en: password = i
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hidden password is:", password)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The statement if found is equivalent to the statement if
    found == True'
  prefs: []
  type: TYPE_NORMAL
- en: Second approach – Using a flag
  prefs: []
  type: TYPE_NORMAL
- en: The break statement doesn't actually exist in all computer languages; and since
    this book's intent is to teach you “Algorithmic Thinking” (and not just special
    statements that only Python supports), let's look at an alternate approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the following Python program, when the hidden password is found, the Boolean
    expression found == False forces the flow of execution to exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: i = 100
  prefs: []
  type: TYPE_NORMAL
- en: 'while found == False and i <= 999:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if i == hiddenPassword:'
  prefs: []
  type: TYPE_NORMAL
- en: password = i
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hidden password is:", password)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Consider variable found as a flag. Initially, the flag is
    not “raised” (found = False). The flow of execution enters the loop, and it keeps
    iterating as long as the flag remains down (while found == False …). When something
    occurs within the loop that raises the flag (assigning True to the variable found),
    the flow of execution exits the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The while found == False and i <= 999 can alternatively
    be written as while not found and i <= 999.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The i <= 999 Boolean expression is still necessary in case
    the hidden password is not found.'
  prefs: []
  type: TYPE_NORMAL
- en: 28.5 Cleaning Out Your Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As already stated, loops can consume too much CPU time, so you must be very
    careful and use them sparingly. Although a large number of iterations is sometimes
    inevitable, there are always things that you can do to make your loops perform
    better.
  prefs: []
  type: TYPE_NORMAL
- en: The next code fragment calculates the sum of the numbers 1, 2, 3, 4, 5, … 10000.
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: i = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: countOfNumbers = 10000
  prefs: []
  type: TYPE_NORMAL
- en: s = s + i
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if i > countOfNumbers : break'
  prefs: []
  type: TYPE_NORMAL
- en: print(s)
  prefs: []
  type: TYPE_NORMAL
- en: What you should always keep in mind when using loops, especially those that
    perform many iterations, is to avoid putting any statement inside a loop that
    serves no purposes in that loop. In the previous example, the statement countOfNumbers
    = 10000 is such a statement. Unfortunately, as long as it exists inside the loop,
    the computer executes it 10000 times for no reason, which of course affects the
    computer's performance.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this problem, you can simply move this statement outside the loop,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: countOfNumbers = 10000
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: i = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: s = s + i
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if i > countOfNumbers: break'
  prefs: []
  type: TYPE_NORMAL
- en: print(s)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 28.5-1 Cleaning Out the Loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following code fragment calculates the average value of numbers 1, 2, 3,
    4, … 10000\. Try to move as many statements as possible outside the loop to make
    the program more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, 10001):'
  prefs: []
  type: TYPE_NORMAL
- en: s = s + i
  prefs: []
  type: TYPE_NORMAL
- en: average = s / 10000
  prefs: []
  type: TYPE_NORMAL
- en: print(average)
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: One very common mistake that novice programmers make when calculating average
    values is to put the statement that divides the total sum by how many numbers
    there are in the sum (here average = s / 10000) inside the loop. Think about it!
    Imagine that you want to calculate your average grade in school. Your first step
    would be to calculate the sum of the grades for all 10 courses that you're taking.
    Then, when all your grades have been summed up, you would divide that sum by 10\.
    This means that you would perform 10 additions and only one division.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Calculating an average is a two-step process.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is pointless to calculate the average value inside the loop. You
    can move this statement outside and right after the loop, and leave the loop just
    to sum up the numbers as follows.
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, 10001):'
  prefs: []
  type: TYPE_NORMAL
- en: s = s + i
  prefs: []
  type: TYPE_NORMAL
- en: average = s / 10000
  prefs: []
  type: TYPE_NORMAL
- en: print(average)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 28.5-2 Cleaning Out the Loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next formula
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter28-02.png)
  prefs: []
  type: TYPE_NORMAL
- en: is solved using the following Python program, where N is provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'n = int(input("Enter N: "))'
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, n + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: denom = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, n + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: denom += j ** j
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: s += i / denom
  prefs: []
  type: TYPE_NORMAL
- en: print(s)
  prefs: []
  type: TYPE_NORMAL
- en: Try to move as many statements as possible outside the loop to make the program
    more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the formula, the denominator is common for all fractions.
    Thus, it is pointless to calculate it again and again for every fraction. You
    can calculate the denominator just once and use the result many times, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'n = int(input("Enter N: "))'
  prefs: []
  type: TYPE_NORMAL
- en: denom = 0         [[More…]](more.html#more_28_5_2_1)
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, n + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: denom += j ** j
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, n + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: s += i / denom
  prefs: []
  type: TYPE_NORMAL
- en: print(s)
  prefs: []
  type: TYPE_NORMAL
- en: 28.6 Endless Loops and How to Stop Them
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All while-loops must include something inside the loop that eventually leads
    the flow of execution to exit the loop. But mistakes do happen! For instance,
    the following code fragment contains an endless loop. Unfortunately, the programmer
    forgot to increase variable i inside the loop; therefore, variable i can never
    reach the value 10.
  prefs: []
  type: TYPE_NORMAL
- en: i = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while i != 10:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello there!")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If a loop cannot stop iterating, it is called an endless
    loop or an infinite loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another mistake that a programmer can make is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while i != 10:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello there!")
  prefs: []
  type: TYPE_NORMAL
- en: i += 2
  prefs: []
  type: TYPE_NORMAL
- en: Even though this code fragment does contain a statement that increases variable
    i inside the loop (i += 2), unfortunately the flow of execution never exits the
    loop because the value 10 is never assigned to the variable i.
  prefs: []
  type: TYPE_NORMAL
- en: An endless loop continues to iterate forever, and the only way to stop it from
    iterating is to use magic forces! For example, when an application in a Windows
    operating system “hangs” (probably because the flow of execution entered an endless
    loop), the user must use the key combination ALT+CTRL+DEL to force the application
    to end.
  prefs: []
  type: TYPE_NORMAL
- en: In IDLE, if you execute a code that enters an endless loop, you can hit the
    CTRL+C key combination, and the Python compiler will stop the execution.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio Code, when you accidentally write and execute an endless loop,
    you can simply click on the “Stop” ![Image](img/vs_code_stop_button.png) toolbar
    icon, and the execution will stop.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In Visual Studio Code, an alternative way to force the application
    to end is to use the key combination CTRL+C within the Terminal window.'
  prefs: []
  type: TYPE_NORMAL
- en: 28.7 The “From Inner to Outer” Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From inner to outer is a method proposed by this book to help you learn “Algorithmic
    Thinking” from the inside out. This method first manipulates and designs the inner
    (nested) control structures and then, as the algorithm (or the program) is developed,
    more and more control structures are added, nesting the previous ones. This method
    can be used in large and complicated control structures as it helps you design
    error-free flowcharts or even Python programs. This book uses this method wherever
    and whenever it seems necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that displays the following multiplication table as it
    is shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter28-03.png)'
  prefs: []
  type: TYPE_IMG
- en: According to the “from inner to outer” method, you start by writing the inner
    control structure, and then, when everything is tested and operates fine, you
    can add the outer control structure(s).
  prefs: []
  type: TYPE_NORMAL
- en: So, let's try to display only the first line of the multiplication table. If
    you examine this line, it reveals that, in each multiplication, the multiplicand
    is always 1\. Let's consider the multiplicand as variable i with a value of 1\.
    The loop control structure that displays only the first line of the multiplication
    table is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) Code Fragment 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, 11):'
  prefs: []
  type: TYPE_NORMAL
- en: print(i, "x", j, "=", i * j, end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: If you execute this code fragment, the result is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter28-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/remember.jpg)The special sequence of characters \t “displays” a tab
    character after each iteration. This ensures that everything is aligned properly.'
  prefs: []
  type: TYPE_NORMAL
- en: The inner (nested) loop control structure is ready. What you need now is a way
    to execute this control structure nine times, but each time variable i must contain
    a different value, from 1 to 9\. This can be achieved as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) Main Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, 10):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code Fragment 1: Display one single line of the multiplication table'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The print() statement is used to “display” a line break
    between lines.'
  prefs: []
  type: TYPE_NORMAL
- en: After embedding Code Fragment 1 in Main Code, the final Python program becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_28.7'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, 10):'
  prefs: []
  type: TYPE_NORMAL
- en: for j in range(1, 11):             [[More…]](more.html#more_28_7_1)
  prefs: []
  type: TYPE_NORMAL
- en: print(i, "x", j, "=", i * j, end = "\t")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '28.8 Review Questions: True/False'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)When the number of iterations is unknown, you can use a definite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 2)When the number of iterations is known, you cannot use a post-test loop structure.
  prefs: []
  type: TYPE_NORMAL
- en: 3)According to the “Ultimate” rule, in a pre-test loop structure, the initialization
    of the variable that participates in the loop's Boolean expression must be done
    inside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 4)According to the “Ultimate” rule, in a pre-test loop structure, the statement
    that updates/alters the value of the variable that participates in the loop's
    Boolean expression must be the last statement within the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 5)According to the “Ultimate” rule, in a post-test loop structure, the initialization
    of the variable that participates in the loop's Boolean expression can sometimes
    be done inside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 6)According to the “Ultimate” rule, in a post-test loop structure, the update/alteration
    of the variable that participates in the loop's Boolean expression must be the
    first statement within the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 7)In Python, you can break out of a loop before it completes all iterations
    using the exit statement.
  prefs: []
  type: TYPE_NORMAL
- en: 8)A statement that assigns a constant value to a variable is better placed inside
    a loop control structure.
  prefs: []
  type: TYPE_NORMAL
- en: 9)In the following code fragment there is at least one statement that can be
    moved outside the for-loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(30):'
  prefs: []
  type: TYPE_NORMAL
- en: a = "Hello"
  prefs: []
  type: TYPE_NORMAL
- en: print(a)
  prefs: []
  type: TYPE_NORMAL
- en: 10)In the following code fragment there is at least one statement that can be
    moved outside the while-loop.
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: count = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while count < 100:'
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: s += a
  prefs: []
  type: TYPE_NORMAL
- en: average = s / count
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: print(average)
  prefs: []
  type: TYPE_NORMAL
- en: 11)In the following code fragment there is at least one statement that can be
    moved outside the while-loop.
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: y = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'while y != -99:'
  prefs: []
  type: TYPE_NORMAL
- en: s = s + y
  prefs: []
  type: TYPE_NORMAL
- en: y = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 12)The following code fragment satisfies the property of finiteness.
  prefs: []
  type: TYPE_NORMAL
- en: i = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while i != 100:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello there!")
  prefs: []
  type: TYPE_NORMAL
- en: i += 5
  prefs: []
  type: TYPE_NORMAL
- en: 13)When the not equal ( != ) comparison operator is used in the Boolean expression
    of a pre-test loop structure, the loop always iterates endlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 14)The following code fragment satisfies the property of finiteness.
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello there!")
  prefs: []
  type: TYPE_NORMAL
- en: i += 5
  prefs: []
  type: TYPE_NORMAL
- en: 'if i >= 100: break'
  prefs: []
  type: TYPE_NORMAL
- en: '28.9 Review Questions: Multiple Choice'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Select the correct answer for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)When the number of iterations is unknown, you can use
  prefs: []
  type: TYPE_NORMAL
- en: a)the pre-test loop structure.
  prefs: []
  type: TYPE_NORMAL
- en: b)the post-test loop structure.
  prefs: []
  type: TYPE_NORMAL
- en: c)all of the above
  prefs: []
  type: TYPE_NORMAL
- en: 2)When the number of iterations is known, you can use
  prefs: []
  type: TYPE_NORMAL
- en: a)the pre-test loop structure.
  prefs: []
  type: TYPE_NORMAL
- en: b)the post-test loop structure.
  prefs: []
  type: TYPE_NORMAL
- en: c)a for-loop.
  prefs: []
  type: TYPE_NORMAL
- en: d)all of the above
  prefs: []
  type: TYPE_NORMAL
- en: 3)According to the “Ultimate” rule, in a pre-test loop structure, the initialization
    of the variable that participates in the loop's Boolean expression must be done
  prefs: []
  type: TYPE_NORMAL
- en: a)inside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: b)outside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: c)all of the above
  prefs: []
  type: TYPE_NORMAL
- en: 4)According to the “Ultimate” rule, in a pre-test loop structure, the update/alteration
    of the variable that participates in the loop's Boolean expression must be done
  prefs: []
  type: TYPE_NORMAL
- en: a)inside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: b)outside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: c)all of the above
  prefs: []
  type: TYPE_NORMAL
- en: 5)According to the “Ultimate” rule, in a post-test loop structure, the initialization
    of the variable that participates in the loop's Boolean expression can be done
  prefs: []
  type: TYPE_NORMAL
- en: a)inside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: b)outside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: c)all of the above
  prefs: []
  type: TYPE_NORMAL
- en: 6)In the following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100):'
  prefs: []
  type: TYPE_NORMAL
- en: s = s + i
  prefs: []
  type: TYPE_NORMAL
- en: x = 100.0
  prefs: []
  type: TYPE_NORMAL
- en: average = s / x
  prefs: []
  type: TYPE_NORMAL
- en: the number of statements that can be moved outside of the for-loop is
  prefs: []
  type: TYPE_NORMAL
- en: a)0.
  prefs: []
  type: TYPE_NORMAL
- en: b)1.
  prefs: []
  type: TYPE_NORMAL
- en: c)2.
  prefs: []
  type: TYPE_NORMAL
- en: d)3.
  prefs: []
  type: TYPE_NORMAL
- en: 7)When this comparison operator is used in the Boolean expression of a post-test
    loop structure, the loop iterates forever.
  prefs: []
  type: TYPE_NORMAL
- en: a)==
  prefs: []
  type: TYPE_NORMAL
- en: b)!=
  prefs: []
  type: TYPE_NORMAL
- en: c)it depends
  prefs: []
  type: TYPE_NORMAL
- en: 28.10 Review Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 1)The following program is supposed to prompt the user to enter names repeatedly
    until the word “STOP” (used as a name) is entered. At the end, the program must
    display the total number of names entered as well as how many of these names were
    not “John”.
  prefs: []
  type: TYPE_NORMAL
- en: countNames = 0
  prefs: []
  type: TYPE_NORMAL
- en: countNotJohns = 0
  prefs: []
  type: TYPE_NORMAL
- en: name = ""
  prefs: []
  type: TYPE_NORMAL
- en: 'while name != "STOP":'
  prefs: []
  type: TYPE_NORMAL
- en: 'name = input("Enter a name: ")'
  prefs: []
  type: TYPE_NORMAL
- en: countNames += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if name != "John":'
  prefs: []
  type: TYPE_NORMAL
- en: countNotJohns += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Total names entered:", countNames)
  prefs: []
  type: TYPE_NORMAL
- en: print("Names other than John entered:", countNotJohns)
  prefs: []
  type: TYPE_NORMAL
- en: However, the program displays wrong results! Using the “Ultimate” Rule, try
    to modify the program so that it displays the correct results.
  prefs: []
  type: TYPE_NORMAL
- en: 2)Write a Python program that prompts the user to enter some text. The text
    can be either a single word or a whole sentence. Then, the program must display
    a message stating whether the user-provided text is one single word or a complete
    sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Search for a space character! If a space character is found, it means
    that the user entered a sentence. The program must stop searching further when
    it finds at least one space character.'
  prefs: []
  type: TYPE_NORMAL
- en: 3)Write a Python program that prompts the user to enter a sentence. The program
    must then display the message “The sentence contains a number” if the sentence
    contains at least one number. The program must stop searching further when it
    finds at least one digit.
  prefs: []
  type: TYPE_NORMAL
- en: 4)Correct the following code fragment so that it does not iterate endlessly.
  prefs: []
  type: TYPE_NORMAL
- en: print("Printing all integers from 1 to 100")
  prefs: []
  type: TYPE_NORMAL
- en: i = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < 101:'
  prefs: []
  type: TYPE_NORMAL
- en: print(i)
  prefs: []
  type: TYPE_NORMAL
- en: 5)Correct the Boolean expression of the following loop control structure so
    that it does not iterate endlessly.
  prefs: []
  type: TYPE_NORMAL
- en: print("Printing odd integers from 1 to 99")
  prefs: []
  type: TYPE_NORMAL
- en: i = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while not(i == 100):'
  prefs: []
  type: TYPE_NORMAL
- en: print(i)
  prefs: []
  type: TYPE_NORMAL
- en: i += 2
  prefs: []
  type: TYPE_NORMAL
- en: 6)The following code fragment calculates the average value of 100 numbers entered
    by the user. Try to move as many statements as possible outside the loop to make
    it more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: i = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: count = 100
  prefs: []
  type: TYPE_NORMAL
- en: number = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: s = s + number
  prefs: []
  type: TYPE_NORMAL
- en: average = s / count
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if i > count: break'
  prefs: []
  type: TYPE_NORMAL
- en: print(average)
  prefs: []
  type: TYPE_NORMAL
- en: 7)The following formula
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter28-05.png)
  prefs: []
  type: TYPE_NORMAL
- en: is solved using the following Python program.
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, 101):'
  prefs: []
  type: TYPE_NORMAL
- en: denom = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, 101):'
  prefs: []
  type: TYPE_NORMAL
- en: denom *= j
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: s += i / denom
  prefs: []
  type: TYPE_NORMAL
- en: print(s)
  prefs: []
  type: TYPE_NORMAL
- en: Try to move as many statements as possible outside the loop to make it more
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 8)Write a Python program that displays every combination of two integers as
    well as their resulting product, for pairs of integers between 1 and 4\. The output
    must display as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 1 x 1 = 1
  prefs: []
  type: TYPE_NORMAL
- en: 1 x 2 = 2
  prefs: []
  type: TYPE_NORMAL
- en: 1 x 3 = 3
  prefs: []
  type: TYPE_NORMAL
- en: 1 x 4 = 4
  prefs: []
  type: TYPE_NORMAL
- en: 2 x 1 = 2
  prefs: []
  type: TYPE_NORMAL
- en: 2 x 2 = 4
  prefs: []
  type: TYPE_NORMAL
- en: 2 x 3 = 6
  prefs: []
  type: TYPE_NORMAL
- en: 2 x 4 = 8
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: 4 x 1 = 4
  prefs: []
  type: TYPE_NORMAL
- en: 4 x 2 = 8
  prefs: []
  type: TYPE_NORMAL
- en: 4 x 3 = 12
  prefs: []
  type: TYPE_NORMAL
- en: 4 x 4 = 16
  prefs: []
  type: TYPE_NORMAL
- en: 9)Write a Python program that displays the multiplication table for pairs of
    integers between 1 and 12, as shown next. Please note that the output is aligned
    with tabs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter28-06.png)'
  prefs: []
  type: TYPE_IMG
- en: 10)Write a Python program that prompts the user to enter an integer and then
    displays the multiplication table for pairs of integers between 1 and that integer.
    For example, if the user enters the value 5, the output must be as shown next.
    Please note that the output is aligned with tabs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter28-07.png)'
  prefs: []
  type: TYPE_IMG
