["```py\n@app.route('/tasks/new', methods=['POST'])\ndef create_task():\n    task = create_task_from_request(request.form)\n    # Framework-specific logging:\n    app.logger.info('Created task %s', task.id) \n    return redirect(url_for('index')) \n```", "```py\n# todo_app/application/use_cases/task_use_cases.py\nimport logging\nlogger = logging.getLogger(__name__)\n@dataclass\nclass CreateTaskUseCase:\n    task_repository: TaskRepository\n    project_repository: ProjectRepository\n    def execute(self, request: CreateTaskRequest) -> Result:\n        try:\n            logger.info(\n                \"Creating new task\",\n                extra={\"context\": {\n                    \"title\": request.title,\n                    \"project_id\": request.project_id\n                }},\n            )\n            # ... implementation continues ... \n```", "```py\n# todo_app/infrastructure/logging/config.py\nclass JsonFormatter(logging.Formatter):\n    \"\"\"Formats log records as JSON.\"\"\"\n    def __init__(self, app_context: str):\n        super().__init__()\n        self.app_context = app_context\n        # Custom encoder handles datetime, UUID, sets, and exceptions\n        self.encoder = JsonLogEncoder()\n    def format(self, record: logging.LogRecord) -> str:\n        \"\"\"Format log record as JSON.\"\"\"\n        log_data = {\n            \"timestamp\": datetime.now(timezone.utc),\n            \"level\": record.levelname,\n            \"logger\": record.name,\n            \"message\": record.getMessage(),\n            \"app_context\": self.app_context,\n        }\n        # `extra` in the log statement, places `context`\n        # on the LogRecord so seek and extract\n        context = {}\n        for key, value in record.__dict__.items():\n            if key == \"context\":\n                context = value\n                break\n        if context:\n            log_data[\"context\"] = context\n        return self.encoder.encode(log_data) \n```", "```py\n# todo_app/infrastructure/logging/config.py\ndef configure_logging(app_context: Literal[\"CLI\", \"WEB\"]) -> None:\n    \"\"\"Configure application logging with sensible defaults.\"\"\"\n    log_dir = Path(\"logs\")\n    log_dir.mkdir(exist_ok=True)\n    config = {\n        \"formatters\": {\n            \"json\": {\"()\": JsonFormatter, \"app_context\": app_context},\n            \"standard\": {\"format\": \"%(message)s\"},\n        },\n        ... \n```", "```py\n...\n        },\n        \"handlers\" = {\n            \"app_file\": {\n                \"class\": \"logging.FileHandler\",\n                \"filename\": log_dir / \"app.log\",\n                \"formatter\": \"json\",\n            },\n            \"access_file\": {\n                \"class\": \"logging.FileHandler\",\n                \"filename\": log_dir / \"access.log\",\n                \"formatter\": \"standard\",\n            },\n        },\n        ... \n```", "```py\n...\n        },   \n        \"loggers\" = {\n            # Application logger\n            \"todo_app\": {\n                \"handlers\": [\"app_file\"],\n                \"level\": \"INFO\",\n            },\n            # Flask's werkzeug logger\n            \"werkzeug\": {\n                \"handlers\": [\"access_file\"],\n                \"level\": \"INFO\",\n                \"propagate\": False,\n            },\n        },\n    } // end configure_logging() \n```", "```py\n# web_main.py\ndef main():\n    \"\"\"Configure logging early\"\"\"\n    configure_logging(app_context=\"WEB\")\n    # ... \n```", "```py\nimport logging\nlogger = logging.getLogger(__name__)\n@dataclass\nclass CreateTaskUseCase:\n    task_repository: TaskRepository\n    project_repository: ProjectRepository\n    def execute(self, request: CreateTaskRequest) -> Result:\n        try:\n            logger.info(\n                \"Creating new task\",\n                extra={\"title\": request.title,\n                       \"project_id\": request.project_id},\n            )\n            # ... task creation logic ...\n            logger.info(\n                \"Task created successfully\",\n                extra={\"context\":{\n                    \"task_id\": str(task.id),\n                    \"project_id\": str(project_id),\n                    \"priority\": task.priority.name}}\n            ) \n```", "```py\n{\n  \"timestamp\": \"2025-02-22T20:10:03.800373+00:00\",\n  \"level\": \"INFO\",\n  \"logger\":\n  \"todo_app.application.use_cases.task_use_cases\",\n  \"message\": \"Creating new task\",\n  \"app_context\": \"WEB\",\n  \"trace_id\": \"19d386aa-5537-45ac-9da6-3a0ce8717660\",\n  \"context\": {\n    \"title\": \"New Task\",\n    \"project_id\": \"e587f1d5-5f6e-4da5-8d6b-155b39bbe8a9\"\n  }\n} \n```", "```py\n# todo_app/infrastructure/logging/trace.py\n# Thread-safe context variable to hold trace ID\ntrace_id_var: ContextVar[Optional[str]] = ContextVar(\"trace_id\", \n                                                     default=None)\ndef get_trace_id() -> str:\n    \"\"\"Get current trace ID or generate new one if not set.\"\"\"\n    current = trace_id_var.get()\n    if current is None:\n        current = str(uuid4())\n        trace_id_var.set(current)\n    return current\ndef set_trace_id(trace_id: Optional[str] = None) -> str:\n    \"\"\"Set trace ID for current context.\"\"\"\n    new_id = trace_id or str(uuid4())\n    trace_id_var.set(new_id)\n    return new_id \n```", "```py\n# todo_app/infrastructure/logging/config.py\ndef configure_logging(app_context: Literal[\"CLI\", \"WEB\"]) -> None:\n    config = {\n        \"formatters\": {\n            \"json\": {\"()\": JsonFormatter, \"app_context\": app_context},\n            \"standard\": {\n                \"format\": \"%(asctime)s [%(trace_id)s] %(message)s\",\n                \"datefmt\": \"%Y-%m-%d %H:%M:%S\"\n            },\n        },\n        # ... rest of configuration\n    } \n```", "```py\n# todo_app/infrastructure/web/middleware.py\ndef trace_requests(flask_app):\n    \"\"\"Add trace ID to all requests.\"\"\"\n    @flask_app.before_request\n    def before_request():\n        trace_id = request.headers.get(\"X-Trace-ID\") or None\n        # pull trace id from globals\n        g.trace_id = set_trace_id(trace_id)\n    @flask_app.after_request\n    def after_request(response):\n        response.headers[\"X-Trace-ID\"] = g.trace_id\n        return response \n```", "```py\n# todo_app/infrastructure/web/app.py\ndef create_web_app(app_container: Application) -> Flask:\n    \"\"\"Create and configure Flask application.\"\"\"\n    flask_app = Flask(__name__)\n    flask_app.config[\"SECRET_KEY\"] = \"dev\"\n    flask_app.config[\"APP_CONTAINER\"] = app_container\n    # Add trace ID middleware\n    trace_requests(flask_app)\n    # ... \n```", "```py\nclass ArchitectureConfig:\n    \"\"\"Defines Clean Architecture structure and rules.\"\"\"\n\n    # Ordered from innermost to outermost layer\n    LAYER_HIERARCHY = [\n        \"domain\",\n        \"application\",\n        \"interfaces\",\n        \"infrastructure\"\n    ] \n```", "```py\ndef test_source_folders(self):\n    \"\"\"Verify todo_app contains only Clean Architecture layer folders.\"\"\"\n    src_path = Path(\"todo_app\")\n    folders = {f.name for f in src_path.iterdir() if f.is_dir()}\n\n    # All layer folders must exist\n    for layer in ArchitectureConfig.LAYER_HIERARCHY:\n        self.assertIn(\n            layer,\n            folders,\n            f\"Missing {layer} layer folder\"\n        )\n\n    # No unexpected folders\n    unexpected = folders - set(ArchitectureConfig.LAYER_HIERARCHY)\n    self.assertEqual(\n        unexpected,\n        set(),\n        f\"Source should only contain Clean Architecture layers.\\n\"\n        f\"Unexpected folders found: {unexpected}\"\n    ) \n```", "```py\n❯ pytest tests/architecture\n========== test session starts ==================\ntests/architecture/test_source_structure.py F\nE    AssertionError: Items in the first set but not the second:\nE    'notifications' : Source should only contain Clean Architecture layers.\nE    Unexpected folders found: {'notifications'} \n```", "```py\ndef test_domain_layer_dependencies(self):\n    \"\"\"Verify domain layer has no outward dependencies.\"\"\"\n    domain_path = Path(\"todo_app/domain\")\n    violations = []\n\n    for py_file in domain_path.rglob(\"*.py\"):\n        with open(py_file) as f:\n            tree = ast.parse(f.read())\n\n        for node in ast.walk(tree):\n            if isinstance(node, ast.Import) or isinstance(\n               node, ast.ImportFrom\n            ):\n                module = node.names[0].name\n                if module.startswith(\"todo_app.\"):\n                    layer = module.split(\".\")[1]\n                    if layer in [\n                        \"infrastructure\",\n                        \"interfaces\",\n                        \"application\"\n                    ]:\n                        violations.append(\n                            f\"{py_file.relative_to(domain_path)}: \"\n                            f\"Domain layer cannot import from \"\n                            f\"{layer} layer\"\n                        )\n    self.assertEqual(\n        violations,\n        [],\n        \"\\nDependency Rule Violations:\\n\" + \"\\n\".join(violations)\n    ) \n```", "```py\n# todo_app/domain/entities/task.py\n# Dependency Rule Violation!\nfrom todo_app.infrastructure.notifications.recorder import NotificationRecorder\nclass Task:\n    def complete(self):\n        self.status = TaskStatus.DONE\n        self.completed_at = datetime.now()\n\n        # Direct dependency on infrastructure –\n        # violates Clean Architecture\n        notification = NotificationRecorder()\n        notification.notify_task_completed(self) \n```", "```py\n❯ pytest tests/architecture\n====================== test session starts ==========\n...\nE    'entities/task.py: Domain layer cannot import from infrastructure layer'\nE    Dependency Rule Violations:\nE    entities/task.py: Domain layer cannot import from infrastructure layer\n====================== 2 passed in 0.01s ============ \n```"]