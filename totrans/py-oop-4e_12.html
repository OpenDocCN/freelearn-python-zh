<html><head></head><body>
  <div id="_idContainer187">
    <h1 class="chapterNumber">12</h1>
    <h1 id="_idParaDest-257" class="chapterTitle">Advanced Design Patterns</h1>
    <p class="normal">In this chapter, we will be introduced to several more design patterns. Once again, we'll cover the canonical examples as well as any common alternative implementations in Python. We'll be discussing the following:</p>
    <ul>
      <li class="bullet">The Adapter pattern</li>
      <li class="bullet">The Façade pattern</li>
      <li class="bullet">Lazy initialization and the Flyweight pattern</li>
      <li class="bullet">The Abstract Factory pattern</li>
      <li class="bullet">The Composite pattern</li>
      <li class="bullet">The Template pattern</li>
    </ul>
    <p class="normal">The case study for this chapter will demonstrate how to apply a few of these patterns to the iris sample problem. In particular, we'll show how much of the design has been based – implicitly – on a number of these patterns.</p>
    <p class="normal">Consistent with the practice in <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em>, we'll capitalize the pattern names. </p>
    <p class="normal">We'll begin with the Adapter pattern. This is often used to provide a needed interface around an object with a design that doesn't – quite – fit our needs.</p>
    <h1 id="_idParaDest-258" class="title">The Adapter pattern</h1>
    <p class="normal">Unlike <a id="_idIndexMarker855"/>most of the <a id="_idIndexMarker856"/>patterns we reviewed in the previous chapter, the Adapter pattern is designed to interact with existing code. We would not design a brand new set of objects that implement the Adapter pattern. Adapters are used to allow two preexisting objects to work together, even if their interfaces are not compatible. Like the display adapters that allow you to plug your Micro USB charging cable into a USB-C phone, an adapter object sits between two different interfaces, translating between them on the fly. The adapter object's sole purpose is to perform this translation. Adapting may entail a variety of tasks, such as converting arguments to a different format, rearranging the order of arguments, calling a differently named method, or supplying default arguments.</p>
    <p class="normal">In structure, the Adapter pattern is similar to a simplified decorator pattern. Decorators typically provide the same interface that they replace, whereas adapters map between two different<a id="_idIndexMarker857"/> interfaces. This is <a id="_idIndexMarker858"/>depicted in UML form in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.1: Adapter pattern</p>
    <p class="normal">Here, a client object, an instance of <strong class="keyword">Client</strong>,<strong class="keyword"> </strong>needs to collaborate with another class to do something useful. In this example, we're using <code class="Code-In-Text--PACKT-">load_data()</code> as a concrete example of a method that requires an adapter. </p>
    <p class="normal">We already have this perfect class, named <strong class="keyword">Implementation</strong>, that does everything we want (and to avoid duplication, we don't want to rewrite it!). This perfect class has one problem: it requires a complex sequence of operations using methods called <code class="Code-In-Text--PACKT-">read_raw_data()</code>, <code class="Code-In-Text--PACKT-">parse_raw_data()</code>, and <code class="Code-In-Text--PACKT-">create_useful_object()</code>. The <strong class="keyword">Adapter</strong> class implements an easy-to-use <code class="Code-In-Text--PACKT-">load_data()</code> interface that hides the complexity of the existing interface provided by the <strong class="keyword">Implementation</strong>.</p>
    <p class="normal">The advantage of this design is that the code that maps from the hoped-for interface to the actual interface is all in one place, the <strong class="keyword">Adapter</strong> class. The alternative would require putting the code into <a id="_idIndexMarker859"/>the client, cluttering it up with possibly irrelevant<a id="_idIndexMarker860"/> implementation details. If we had multiple kinds of clients, we'd have to perform the complex <code class="Code-In-Text--PACKT-">load_data()</code> processing in multiple places whenever any of those clients needed to access the <code class="Code-In-Text--PACKT-">Implementation</code> class.</p>
    <h2 id="_idParaDest-259" class="title">An Adapter example</h2>
    <p class="normal">Imagine we have the<a id="_idIndexMarker861"/> following pre-existing class, which takes string timestamps in the format <code class="Code-In-Text--PACKT-">HHMMSS</code> and calculates useful floating-point intervals from those strings:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TimeSince</span><span class="hljs-class">:</span>
    <span class="hljs-string">"""Expects time as six digits, no punctuation."""</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">parse_time</span><span class="hljs-function">(</span><span class="hljs-params">self, time: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; tuple[float, float, float]:</span>
        <span class="hljs-keyword">return</span> (
            <span class="hljs-built_in">float</span>(time[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]),
            <span class="hljs-built_in">float</span>(time[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]),
            <span class="hljs-built_in">float</span>(time[<span class="hljs-number">4</span>:]),
        )
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, starting_time: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.hr, self.<span class="hljs-built_in">min</span>, self.sec = self.parse_time(starting_time)
        self.start_seconds = ((self.hr * <span class="hljs-number">60</span>) + self.<span class="hljs-built_in">min</span>) * <span class="hljs-number">60</span> + self.sec
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">interval</span><span class="hljs-function">(</span><span class="hljs-params">self, log_time: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; float:</span>
        log_hr, log_min, log_sec = self.parse_time(log_time)
        log_seconds = ((log_hr * <span class="hljs-number">60</span>) + log_min) * <span class="hljs-number">60</span> + log_sec
        <span class="hljs-keyword">return</span> log_seconds - self.start_seconds
</code></pre>
    <p class="normal">This class handles string to time-interval conversion. Since we have this class in the application already, it has unit test cases and works nicely. If you forget the <code class="Code-In-Text--PACKT-">from __future__ import annotations</code>, you'll get an error trying to use <code class="Code-In-Text--PACKT-">tuple[float, float, float]</code> as a type hint. Be sure to include the <code class="Code-In-Text--PACKT-">annotations</code> module as the first line of code.</p>
    <p class="normal">Here's an example showing how this class works:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> ts = TimeSince(<span class="hljs-con-string">"000123"</span>)  <span class="hljs-con-comment"># Log started at 00:01:23</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ts.interval(<span class="hljs-con-string">"020304"</span>)
7301.0
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ts.interval(<span class="hljs-con-string">"030405"</span>)
10962.0
</code></pre>
    <p class="normal">Working with these unformatted times is a little awkward, but a number of <strong class="keyword">Internet of Things</strong> (<strong class="keyword">IoT</strong>) devices<a id="_idIndexMarker862"/> provide these kinds of time strings, separated from the rest of the date. For example, look at the NMEA 0183 format messages from a GPS device, where dates and times are unformatted strings of digits.</p>
    <p class="normal">We have an old log from one of these devices, apparently created years ago. We want to analyze this log for the sequence of messages that occur after each ERROR message. We'd like the exact<a id="_idIndexMarker863"/> times, relative to the ERROR, as part of our root cause problem analysis. </p>
    <p class="normal">Here's some of the log data we're using for testing:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> data = [
<span class="hljs-con-meta">...</span>     (<span class="hljs-con-string">"000123"</span>, <span class="hljs-con-string">"INFO"</span>, <span class="hljs-con-string">"Gila Flats 1959-08-20"</span>),
<span class="hljs-con-meta">...</span>     (<span class="hljs-con-string">"000142"</span>, <span class="hljs-con-string">"INFO"</span>, <span class="hljs-con-string">"test block 15"</span>),
<span class="hljs-con-meta">...</span>     (<span class="hljs-con-string">"004201"</span>, <span class="hljs-con-string">"ERROR"</span>, <span class="hljs-con-string">"intrinsic field chamber door locked"</span>),
<span class="hljs-con-meta">...</span>     (<span class="hljs-con-string">"004210.11"</span>, <span class="hljs-con-string">"INFO"</span>, <span class="hljs-con-string">"generator power active"</span>),
<span class="hljs-con-meta">...</span>     (<span class="hljs-con-string">"004232.33"</span>, <span class="hljs-con-string">"WARNING"</span>, <span class="hljs-con-string">"extra mass detected"</span>)
<span class="hljs-con-meta">...</span> ]
</code></pre>
    <p class="normal">It's difficult to compute the time interval between the ERROR and the WARNING message. It's not impossible; many of us have enough fingers to do the computation. But it would be better to show the log with relative times instead of absolute times. Here's an outline of the log formatter we'd like to use. This code, however, has a problem that we've marked with <code class="Code-In-Text--PACKT-">???</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LogProcessor</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-params">(</span><span class="hljs-keyword">self</span><span class="hljs-params">, </span><span class="hljs-symbol">log_entries:</span><span class="hljs-params"> list[tuple[str, str, str]])</span> -&gt; <span class="hljs-symbol">None:</span>
        <span class="hljs-keyword">self</span>.log_entries = log_entries
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">report</span><span class="hljs-params">(</span><span class="hljs-keyword">self</span><span class="hljs-params">)</span> -&gt; <span class="hljs-symbol">None:</span>
        first_time, first_sev, first_msg = <span class="hljs-keyword">self</span>.log_entries[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> log_time, severity, message <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">log_entries:</span>
            <span class="hljs-keyword">if</span> severity == <span class="hljs-string">"ERROR"</span>:
                first_time = log_time
            <span class="code-highlight"><strong class="hljs-slc">interval = ??? Need to compute an interval ???</strong></span>
            print(f<span class="hljs-string">"{interval:8.2f} | {severity:7s} {message}"</span>)
</code></pre>
    <p class="normal">This <code class="Code-In-Text--PACKT-">LogProcessor</code> class seems like the right thing to do. It iterates through the log entries, resetting the <code class="Code-In-Text--PACKT-">first_time</code> variable on each occurrence of an ERROR line. This makes sure that the log shows offsets from the error, saving us from having to do a lot of math to work out exactly what happened.</p>
    <p class="normal">But, we have a problem. We'd really like to reuse the <code class="Code-In-Text--PACKT-">TimeSince</code> class. However, it doesn't simply compute an interval between two values. We have several options to address this scenario: </p>
    <ul>
      <li class="bullet">We could rewrite the <code class="Code-In-Text--PACKT-">TimeSince</code> class to work with a pair of time strings. This runs a small risk of breaking something else in our application. We sometimes call this the <strong class="keyword">splash radius</strong> of <a id="_idIndexMarker864"/>a change – how many other things get wet when we drop a boulder into the swimming pool? The Open/Closed design principle (one of the SOLID<a id="_idIndexMarker865"/> principles, which we discussed in the Chapter 4 case study; see <a href="https://subscription.packtpub.com/book/application_development/9781788835831/4"><span class="url">https://subscription.packtpub.com/book/application_development/9781788835831/4</span></a> for more background) suggests a class should be open to extension but closed to this kind of modification. If this class was downloaded from PyPI, we may not want to change its internal structure because then we wouldn't be able to use any subsequent releases. We need an alternative to tinkering inside another class.</li>
      <li class="bullet">We could use the class as it is, and whenever we want to calculate the intervals between an ERROR and subsequent log lines, we create a new <code class="Code-In-Text--PACKT-">TimeSince</code> object. This is a lot of object creation. Imagine we have several log analysis applications, each looking at different aspects of the log messages. Making a change means having to go back and fix all of the places where these <code class="Code-In-Text--PACKT-">TimeSince</code> objects were created. Cluttering up the <code class="Code-In-Text--PACKT-">LogProcessor</code> class with details of how the <code class="Code-In-Text--PACKT-">TimeSince</code> class works violates the Single Responsibility design principle. Another <a id="_idIndexMarker866"/>principle, <strong class="keyword">Don't Repeat Yourself</strong> (<strong class="keyword">DRY</strong>), seems to apply in this case, also.</li>
      <li class="bullet">Instead, we can add an adapter that connects the needs of the <code class="Code-In-Text--PACKT-">LogProcessor</code> class with the methods available from the <code class="Code-In-Text--PACKT-">TimeSince</code> class.</li>
    </ul>
    <p class="normal">The Adapter solution introduces a class that offers the interface required by the <code class="Code-In-Text--PACKT-">LogProcessor</code> class. It consumes the interface offered by the <code class="Code-In-Text--PACKT-">TimeSince</code> class. It allows for independent evolution of the two classes, leaving them closed to modification, but open to extension. It looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">IntervalAdapter</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.ts: Optional[TimeSince] = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">time_offset</span><span class="hljs-function">(</span><span class="hljs-params">self, start: </span><span class="hljs-built_in">str</span><span class="hljs-params">, now: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; float:</span>
        <span class="hljs-keyword">if</span> self.ts <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            self.ts = TimeSince(start)
        <span class="hljs-keyword">else</span>:
            h_m_s = self.ts.parse_time(start)
            <span class="hljs-keyword">if</span> h_m_s != (self.ts.hr, self.ts.<span class="hljs-built_in">min</span>, self.ts.sec):
                self.ts = TimeSince(start)
        <span class="hljs-keyword">return</span> self.ts.interval(now)
</code></pre>
    <p class="normal">This adapter <a id="_idIndexMarker867"/>creates a <code class="Code-In-Text--PACKT-">TimeSince</code> object when it's needed. If there is no <code class="Code-In-Text--PACKT-">TimeSince</code>, it has to create one. If there is an existing <code class="Code-In-Text--PACKT-">TimeSince</code> object, and it uses the already established start time, the <code class="Code-In-Text--PACKT-">TimeSince</code> instance can be reused. If, however, the <code class="Code-In-Text--PACKT-">LogProcessor</code> class has shifted the focus of the analysis to a new error message, then a new <code class="Code-In-Text--PACKT-">TimeSince</code> needs to be created.</p>
    <p class="normal">Here's the final design for the <code class="Code-In-Text--PACKT-">LogProcessor</code> class, using the <code class="Code-In-Text--PACKT-">IntervalAdapter</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LogProcessor</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def </span><span class="hljs-title">__init__</span><span class="hljs-params">(</span>
<span class="hljs-keyword">        self</span><span class="hljs-params">,</span>
<span class="hljs-keyword">        </span><span class="hljs-symbol">log_entries:</span><span class="hljs-keyword"> </span><span class="hljs-params">list[tuple[str, str, str]]</span>
<span class="hljs-params">    )</span><span class="hljs-keyword"> </span>-&gt;<span class="hljs-keyword"> </span><span class="hljs-symbol">None:</span>
        self.log_entries = log_entries
        self.time_convert = IntervalAdapter()
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">report</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        first_time, first_sev, first_msg = self.log_entries[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> log_time, severity, message <span class="hljs-keyword">in</span> self.log_entries:
            <span class="hljs-keyword">if</span> severity == <span class="hljs-string">"ERROR"</span>:
                first_time = log_time
            <span class="code-highlight"><strong class="hljs-slc">interval = self.time_convert.time_offset(first_time, log_time)</strong></span>
            print(<span class="hljs-string">f"</span><span class="hljs-subst">{interval:</span><span class="hljs-number">8.2</span><span class="hljs-subst">f}</span><span class="hljs-string"> | </span><span class="hljs-subst">{severity:7s}</span><span class="hljs-string"> </span><span class="hljs-subst">{message}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">We created an <code class="Code-In-Text--PACKT-">IntervalAdapter()</code> instance during initialization. Then we used this object to compute each time offset. This lets us reuse the existing <code class="Code-In-Text--PACKT-">TimeSince</code> class without any modification to the original class, and it leaves the <code class="Code-In-Text--PACKT-">LogProcessor</code> uncluttered by details of how <code class="Code-In-Text--PACKT-">TimeSince</code> works.</p>
    <p class="normal">We can also tackle this kind of design through inheritance. We could extend <code class="Code-In-Text--PACKT-">TimeSince</code> to add the needed method to it. This inheritance alternative isn't a bad idea, and it illustrates the common situation where there's no single "right" answer. In some cases, we need to write out the inheritance solution and compare it with the adapter solution to see which one is easier to explain.</p>
    <p class="normal">Instead of inheritance, we can sometimes also use monkey patching to add a method to an existing class. Python lets us add a new method that provides the adapted interface that is required by calling code. This means, of course, the easy-to-find class definition inside the <code class="Code-In-Text--PACKT-">class</code> statement<a id="_idIndexMarker868"/> isn't the whole class being used at runtime. We force other developers to search the code base to find out where the new feature was monkey patched into the class. Outside unit testing, monkey patching is not a good idea. </p>
    <p class="normal">It is often possible to use a function as an adapter. While this doesn't obviously fit the traditional design of the Adapter class design pattern, it's a distinction with little practical impact: a class with the <code class="Code-In-Text--PACKT-">__call__()</code> method is a callable object, indistinguishable from a function. A function can be a perfectly good Adapter; Python doesn't require everything be defined in classes.</p>
    <p class="normal">The distinction between Adapter and Decorator is small but important. An Adapter often extends, modifies, or combines more than one method from the class(es) being adapted. A Decorator, however, generally avoids profound changes, keeping a similar interface for a given method, adding features incrementally. As we saw in <em class="chapterRef">Chapter 11</em>, <em class="italic">Common Design Patterns</em>, a Decorator should be viewed as a specialized kind of Adapter. </p>
    <p class="normal">Using an Adapter class is a lot like using a Strategy class; the idea is that we might make changes, and need a different adapter someday. The principal difference is that Strategies are often chosen at runtime, where as an Adapter is a design-time choice and changes very slowly.</p>
    <p class="normal">The next pattern we'll look at is similar to an Adapter, as it also wraps functionality inside a new container. The difference is the complexity of what is being wrapped; a Façade often contains considerably more complex structures.</p>
    <h1 id="_idParaDest-260" class="title">The Façade pattern</h1>
    <p class="normal">The Façade pattern <a id="_idIndexMarker869"/>is designed to provide a simple interface to a complex <a id="_idIndexMarker870"/>system of components. It allows us to define a new class that encapsulates a typical usage of the system, thereby avoiding a design that exposes the many implementation details hiding among multiple object interactions. Any time we want access to common or typical functionality, we can use a single object's simplified interface. If another part of the project needs access to more complete functionality, it is still able to interact with the components and individual methods directly.</p>
    <p class="normal">The UML diagram for the Façade pattern is really dependent on the subsystem, shown as a package, <code class="Code-In-Text--PACKT-">Big System</code>, but in<a id="_idIndexMarker871"/> a cloudy way it looks like this:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.2: The Façade pattern</p>
    <p class="normal">The Façade pattern is, in many ways, like the Adapter pattern. The primary difference is that a Façade tries to abstract a simpler interface out of a complex one, while an Adapter only<a id="_idIndexMarker872"/> tries <a id="_idIndexMarker873"/>to map one existing interface to another.</p>
    <h2 id="_idParaDest-261" class="title">A Façade example</h2>
    <p class="normal">The images for<a id="_idIndexMarker874"/> this book were made with PlantUML (<a href="https://plantuml.com"><span class="url">https://plantuml.com</span></a>). Each diagram starts as a text file and needs to be converted to the PNG file that's part of the text. This is a two-step process and we use a Façade pattern to combine the two processes.</p>
    <p class="normal">The first part is locating all of the UML files. This is a walk through the directory tree finding all files with names ending in <code class="Code-In-Text--PACKT-">.uml</code>. We also look inside the file to see if there are multiple diagrams named inside the file.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from </span>__future__<span class="hljs-keyword"> import</span> annotations
<span class="hljs-keyword">import</span> re
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterator, Tuple
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FindUML</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, base: Path</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.base = base
        self.start_pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r"@startuml *(.*)"</span>)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">uml_file_iter</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; Iterator[tuple[Path, Path]]:</span>
        <span class="hljs-keyword">for</span> source <span class="hljs-keyword">in</span> self.base.glob(<span class="hljs-string">"**/*.uml"</span>):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(n.startswith(<span class="hljs-string">"."</span>) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> source.parts):
                <span class="hljs-keyword">continue</span>
            body = source.read_text()
            <span class="hljs-keyword">for</span> output_name <span class="hljs-keyword">in</span> self.start_pattern.findall(body):
                <span class="hljs-keyword">if</span> output_name:
                    target = source.parent / output_name
                <span class="hljs-keyword">else</span>:
                    target = source.with_suffix(<span class="hljs-string">".png"</span>)
                <span class="hljs-keyword">yield</span> (
                    source.relative_to(self.base),
                    target.relative_to(self.base)
                )
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">FindUML</code> class requires a base directory. The <code class="Code-In-Text--PACKT-">uml_file_iter()</code> method walks the entire directory tree, using the <code class="Code-In-Text--PACKT-">Path.glob()</code> method. It skips over any directories with names that start with <code class="Code-In-Text--PACKT-">.</code>; these are often used by tools like <strong class="keyword">tox</strong>, <strong class="" style="font-style: italic;">mypy</strong>, or <strong class="keyword">git</strong>, and we don't want to look inside these directories. The remaining files will have <code class="Code-In-Text--PACKT-">@startuml</code> lines in them. Some will have a line that names multiple output files. Most of the UML files don't create multiple files. The <code class="Code-In-Text--PACKT-">self.start_pattern</code> regular expression will capture the name, if one is provided. The iterator yields tuples with two paths.</p>
    <p class="normal">Separately, we have a class that runs the PlantUML application program as a subprocess. When Python is running, it's an operating system process. We can, using the <code class="Code-In-Text--PACKT-">subprocess</code> module, start child processes that run other binary applications or shell scripts. It looks<a id="_idIndexMarker875"/> like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> subprocess
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PlantUML</span><span class="hljs-class">:</span>
    conda_env_name = <span class="hljs-string">"CaseStudy"</span>
    base_env = Path.home() / <span class="hljs-string">"miniconda3"</span> / <span class="hljs-string">"envs"</span> / conda_env_name
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span>
<span class="hljs-params">        self,</span>
<span class="hljs-params">        graphviz: Path = Path(</span><span class="hljs-string">"bin"</span><span class="hljs-params">) / </span><span class="hljs-string">"dot"</span><span class="hljs-params">,</span>
<span class="hljs-params">        plantjar: Path = Path(</span><span class="hljs-string">"share"</span><span class="hljs-params">) / </span><span class="hljs-string">"plantuml.jar"</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.graphviz = self.base_env / graphviz
        self.plantjar = self.base_env / plantjar
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process</span><span class="hljs-function">(</span><span class="hljs-params">self, source: Path</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        env = {
            <span class="hljs-string">"GRAPHVIZ_DOT"</span>: <span class="hljs-built_in">str</span>(self.graphviz),
        }
        command = [
          <span class="hljs-string">"java"</span>, <span class="hljs-string">"-jar"</span>,         <span class="hljs-built_in">str</span>(self.plantjar), <span class="hljs-string">"-progress"</span>,         <span class="hljs-built_in">str</span>(source)
        ]
        subprocess.run(command, env=env, check=<span class="hljs-literal">True</span>)
        print()
</code></pre>
    <p class="normal">This <code class="Code-In-Text--PACKT-">PlantUML</code> class depends on using <strong class="keyword">conda</strong> to create a virtual environment named <code class="Code-In-Text--PACKT-">CaseStudy</code>. If other virtual environment managers are used, a subclass can provide the needed path modifications. We'll need to install the Graphviz package into the named virtual environment; this renders the diagram as an image file. We also need to download the <code class="Code-In-Text--PACKT-">plantuml.jar</code> file somewhere. We chose to put it into a <code class="Code-In-Text--PACKT-">share</code> directory inside our virtual environment. The value of the <code class="Code-In-Text--PACKT-">command</code> variable presumes the <strong class="keyword">Java Runtime Environment</strong> (<strong class="keyword">JRE</strong>) is properly installed and visible.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">subprocess.run()</code> function accepts the command-line arguments and any special environment variables that need to be set. It will run the given command, with the given environment, and it will check the resulting return code to be sure the program ran properly.</p>
    <p class="normal">Separately, we can use these steps to find all the UML files and create the diagrams. Because the interface is a bit awkward, a class that follows the Façade pattern helps create a useful<a id="_idIndexMarker876"/> command-line application.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">GenerateImages</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, base: Path</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.finder = FindUML(base)
        self.painter = PlantUML()
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">make_all_images</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">for</span> source, target <span class="hljs-keyword">in</span> self.finder.uml_file_iter():
            <span class="hljs-keyword">if</span> (
               <span class="hljs-keyword">not</span> target.exists() 
               <span class="hljs-keyword">or</span> source.stat().st_mtime &gt; target.stat().st_mtime
            ):
                print(<span class="hljs-string">f"Processing </span><span class="hljs-subst">{source}</span><span class="hljs-string"> -&gt; </span><span class="hljs-subst">{target}</span><span class="hljs-string">"</span>)
                self.painter.process(source)
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">f"Skipping </span><span class="hljs-subst">{source}</span><span class="hljs-string"> -&gt; </span><span class="hljs-subst">{target}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">GenerateImages</code> class is a handy façade that combines features of the <code class="Code-In-Text--PACKT-">FindUML</code> and the <code class="Code-In-Text--PACKT-">PlantUML</code> classes. It uses the <code class="Code-In-Text--PACKT-">FindUML.uml_file_iter()</code> method to locate source files and output image files. It checks the modification times of these files to avoid processing them if the image is newer than the source. (The <code class="Code-In-Text--PACKT-">stat().st_mtime</code> is pretty obscure; it turns out the <code class="Code-In-Text--PACKT-">stat()</code> method of a <code class="Code-In-Text--PACKT-">Path</code> provides a lot of file status information, and the modification time is only one of many things we can find about a file.)</p>
    <p class="normal">If the <code class="Code-In-Text--PACKT-">.uml</code> file is newer, it means one of the authors changed it, and the images need to be regenerated. The main script to do this is now delightfully simple:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    g = GenerateImages(Path.cwd())
    g.make_all_images()
</code></pre>
    <p class="normal">This example shows one of the important ways Python can be used to automate things. We broke the process into steps that we could implement in a few lines of code. Then we combined those steps, wrapping them in a Façade. Another, more complex application can use the Façade without worrying deeply about how it's implemented. </p>
    <p class="normal">Although it is rarely mentioned by name in the Python community, the Façade pattern is an integral part of the Python ecosystem. Because Python emphasizes language readability, both the language and its libraries tend to provide easy-to-comprehend interfaces for complicated tasks. For example, <code class="Code-In-Text--PACKT-">for</code> loops, <code class="Code-In-Text--PACKT-">list</code> comprehensions, and generators are all façades into a more complicated iterator protocol. The <code class="Code-In-Text--PACKT-">defaultdict</code> implementation is a façade that abstracts away annoying edge cases when a key doesn't exist in a dictionary. </p>
    <p class="normal">The third-party <code class="Code-In-Text--PACKT-">requests</code> or <code class="Code-In-Text--PACKT-">httpx</code> libraries are both powerful façades over less readable <code class="Code-In-Text--PACKT-">urllib</code> libraries for HTTP processing. The <code class="Code-In-Text--PACKT-">urllib</code> package itself is a façade over managing the text-based HTTP protocol using the underlying <code class="Code-In-Text--PACKT-">socket</code> package.</p>
    <p class="normal">A Façade conceals<a id="_idIndexMarker877"/> complexity. Sometimes, we want to avoid duplicating data. The next design pattern can help optimize storage when working with large volumes of data. It's particularly helpful on very small computers, typical for Internet of Things applications.</p>
    <h1 id="_idParaDest-262" class="title">The Flyweight pattern</h1>
    <p class="normal">The Flyweight<a id="_idIndexMarker878"/> pattern<a id="_idIndexMarker879"/> is a memory optimization pattern. Novice Python programmers tend to ignore memory optimization, assuming the built-in garbage collector will take care of it. Relying on the built-in memory management is the best way to start. In some cases, for example, very large data science applications, memory constraints can become barriers, and more active measures need to be taken. In very small Internet of Things devices, memory management can also be helpful.</p>
    <p class="normal">The Flyweight pattern ensures that objects that share a state can use the same memory for their shared state. It is normally implemented only after a program has demonstrated memory problems. It may make sense to design an optimal configuration from the beginning in some situations, but bear in mind that premature optimization is the most effective way to create a program that is too complicated to maintain.</p>
    <p class="normal">In some languages, a Flyweight design requires careful sharing of object references, avoiding accidental object copying, and careful tracking of object ownership to ensure that objects aren't deleted prematurely. In Python, everything is an object, and all objects work through consistent references. A Flyweight design in Python is generally somewhat simpler<a id="_idIndexMarker880"/> than in other languages.</p>
    <p class="normal">Let's have a look at<a id="_idIndexMarker881"/> the following UML diagram for the Flyweight <a id="_idIndexMarker882"/>pattern:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.3: The Flyweight pattern</p>
    <p class="normal">Each <strong class="keyword">Flyweight</strong> object has no specific state of its own. Any time it needs to perform an operation on <strong class="keyword">SpecificState</strong>, that state needs to be passed into the <strong class="keyword">Flyweight</strong> by the calling code as an argument value. Traditionally, the factory that returns an instance of a <code class="Code-In-Text--PACKT-">Flyweight</code> class is a separate object; its purpose is to return individual Flyweight objects, perhaps organized by a key or index of some kind. It works like the Singleton pattern we discussed in <em class="chapterRef">Chapter 11</em>, <em class="italic">Common Design Patterns</em>; if the Flyweight exists, we return it; otherwise, we create a new one. In many languages, the factory is implemented, not as a separate object, but as a static method on the <code class="Code-In-Text--PACKT-">Flyweight</code> class itself.</p>
    <p class="normal">We can liken this to the way the World Wide Web has replaced a computer loaded up with data. In the olden days, we would be forced to collect and index documents and files, filling up our local computer with copies of source material. This used to involve transfers of physical media like floppy disks and CDs. Now, we can – via a website – have a reference to the <a id="_idIndexMarker883"/>original data without making a bulky, space-consuming copy. Because <a id="_idIndexMarker884"/>we are working with a reference to the source data, we can read it easily on a mobile device. The Flyweight principle of working with a reference to data has been a profound change in our access to information. </p>
    <p class="normal">Unlike the Singleton design pattern, which only needs to return one instance of a class, a Flyweight design may have multiple instances of the Flyweight classes. One approach is to store the items in a dictionary and provide values to Flyweight objects based on the dictionary key. Another common approach in some IoT applications is to leverage a buffer of items. On a large computer, allocating and deallocating objects is relatively low-cost. On a small IoT computer, we need to minimize object creation, which means leveraging Flyweight designs where a buffer is shared by objects.</p>
    <h2 id="_idParaDest-263" class="title">A Flyweight example in Python </h2>
    <p class="normal">We'll start with <a id="_idIndexMarker885"/>some concrete classes for an IoT device<a id="_idIndexMarker886"/> that works with GPS messages. We don't want to create a lot of individual <code class="Code-In-Text--PACKT-">Message</code> objects with duplicate values taken from a source buffer; instead, we want Flyweight objects to help save memory. This leverages two important features:</p>
    <ul>
      <li class="bullet">The Flyweight objects reuse bytes in a single buffer. This avoids data duplication in a small computer.</li>
      <li class="bullet">The Flyweight classes can have unique processing for the various message types. In particular, the GPGGA, GPGLL, and GPRMC messages all have latitude and longitude information. Even though the details vary by message, we don't want to create distinct Python objects. It's a fair amount of overhead to handle the case when the only real processing distinction is the location of the relevant bytes<a id="_idIndexMarker887"/> within<a id="_idIndexMarker888"/> a buffer.</li>
    </ul>
    <p class="normal">Here's the UML diagram:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.4: GPS messages UML diagram</p>
    <p class="normal">Given a <code class="Code-In-Text--PACKT-">Buffer</code> object with bytes read from the GPS, we can apply a <code class="Code-In-Text--PACKT-">MessageFactory</code> to create Flyweight instances of the various <code class="Code-In-Text--PACKT-">Message</code> subclasses. Each subclass has access to the shared <code class="Code-In-Text--PACKT-">Buffer</code> object and can produce a <code class="Code-In-Text--PACKT-">Point</code> object, but they have unique implementations reflecting the distinct structure of each message.</p>
    <p class="normal">There's an additional complication that is unique to Python. We can get into trouble when we have multiple references to an instance of the <code class="Code-In-Text--PACKT-">Buffer</code> object. After working with a number of messages, we'll have local, temporary data in each of the <code class="Code-In-Text--PACKT-">Message</code> subclasses, including a reference to the <code class="Code-In-Text--PACKT-">Buffer</code> instance. </p>
    <p class="normal">The situation might look as shown in the following diagram, which has the concrete objects and their references:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.5: Reference diagram</p>
    <p class="normal">Some client<a id="_idIndexMarker889"/> application, shown as a <code class="Code-In-Text--PACKT-">Client</code> object, has a <a id="_idIndexMarker890"/>reference to a <code class="Code-In-Text--PACKT-">Buffer</code> instance. It read a bunch of GPS traffic into this buffer. Additionally, a specific <code class="Code-In-Text--PACKT-">GPGGA</code> instance also has a reference to the <code class="Code-In-Text--PACKT-">Buffer</code> object because offset 0 in the buffer had a GPGGA message. Offsets 68 and 98 have other messages; these will also have references back to the <code class="Code-In-Text--PACKT-">Buffer</code> instance.</p>
    <p class="normal">Because the <code class="Code-In-Text--PACKT-">Buffer</code> has a reference to a GPGGA <code class="Code-In-Text--PACKT-">Message</code> object, and the <code class="Code-In-Text--PACKT-">Message</code> also has a reference back to the <code class="Code-In-Text--PACKT-">Buffer</code>, we have a circular pair of references. When the client stops using a <code class="Code-In-Text--PACKT-">Buffer</code>, the reference count goes from four references to three. We cannot easily remove the <code class="Code-In-Text--PACKT-">Buffer</code> and its <code class="Code-In-Text--PACKT-">Message</code> objects.</p>
    <p class="normal">We can solve this problem by taking advantage of Python's <code class="Code-In-Text--PACKT-">weakref</code> module. Unlike ordinary ("strong") references, a weak reference isn't counted for the purposes of memory management. We can have lots of weak references to an object, but once the last ordinary reference is removed, the object can be removed from memory. This permits the client to start working with a new <code class="Code-In-Text--PACKT-">Buffer</code> object without having to worry about the old <code class="Code-In-Text--PACKT-">Buffer</code> cluttering up memory. The number of strong references goes from one to zero, allowing it to be removed. Similarly, each <code class="Code-In-Text--PACKT-">Message</code> object could have one strong reference from the <code class="Code-In-Text--PACKT-">Buffer</code>, so removing the <code class="Code-In-Text--PACKT-">Buffer</code> will also remove each <code class="Code-In-Text--PACKT-">Message</code>.</p>
    <p class="normal">Weak references are part of the foundation of the Python runtime. Consequently, they are an important optimization that surfaces in a few special cases. One of these optimizations is that we can't create a weak reference to a <code class="Code-In-Text--PACKT-">bytes</code> object. The overhead would be painful. </p>
    <p class="normal">In a few cases (like this) we need to create an Adapter for the underlying <code class="Code-In-Text--PACKT-">bytes</code> object <a id="_idIndexMarker891"/>to transform it into an object that can<a id="_idIndexMarker892"/> have weak references.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Buffer</span><span class="hljs-class">(</span><span class="hljs-params">Sequence[</span><span class="hljs-built_in">int</span><span class="hljs-params">]</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, content: </span><span class="hljs-built_in">bytes</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.content = content
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__len__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; int:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.content)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__iter__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; Iterator[int]:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self.content)
<span class="hljs-meta">    @overload</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__getitem__</span><span class="hljs-function">(</span><span class="hljs-params">self, index: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; int:</span>
        ...
<span class="hljs-meta">    @overload</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__getitem__</span><span class="hljs-function">(</span><span class="hljs-params">self, index: </span><span class="hljs-built_in">slice</span><span class="hljs-function">) -&gt; bytes:</span>
        ...
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__getitem__</span><span class="hljs-function">(</span><span class="hljs-params">self, index: Union[</span><span class="hljs-built_in">int</span><span class="hljs-params">, </span><span class="hljs-built_in">slice</span><span class="hljs-params">]</span><span class="hljs-function">) -&gt; Union[int, bytes]:</span>
        <span class="hljs-keyword">return</span> self.content[index]
</code></pre>
    <p class="normal">This definition of a <code class="Code-In-Text--PACKT-">Buffer</code> class doesn't really contain a great deal of new code. We provided three special methods, and all three delegated the work to the underlying <code class="Code-In-Text--PACKT-">bytes</code> object. The <code class="Code-In-Text--PACKT-">Sequence</code> abstract base type provides a few methods for us, like <code class="Code-In-Text--PACKT-">index()</code> and <code class="Code-In-Text--PACKT-">count()</code>. </p>
    <p class="normal">The three definitions of the overloaded <code class="Code-In-Text--PACKT-">__getitem__()</code> method is how we tell <strong class="" style="font-style: italic;">mypy</strong> of the important distinction between an expression like <code class="Code-In-Text--PACKT-">buffer[i]</code> and <code class="Code-In-Text--PACKT-">buffer[start: end]</code>. The first expression gets a single <code class="Code-In-Text--PACKT-">int</code> item from the buffer, the second uses a slice and returns a <code class="Code-In-Text--PACKT-">bytes</code> object. The final non-overload definition of <code class="Code-In-Text--PACKT-">__getitem__()</code> implements the two overloads by delegating the work to the <code class="Code-In-Text--PACKT-">self.contents</code> object, which handles this nicely.</p>
    <p class="normal">Back in <em class="chapterRef">Chapter 11</em>, <em class="italic">Common Design Patterns</em>, we looked at using a state-based design to acquire and compute checksums. This chapter takes a different approach to working with a large volume of rapidly arriving GPS messages.</p>
    <p class="normal">Here's a typical GPS message:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> raw = Buffer(<span class="hljs-con-string">b"$GPGLL,3751.65,S,14507.36,E*77"</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">$</code> starts <a id="_idIndexMarker893"/>the <a id="_idIndexMarker894"/>message. The <code class="Code-In-Text--PACKT-">*</code> ends the message. The characters after the <code class="Code-In-Text--PACKT-">*</code> are the checksum value. We'll ignore the two checksum bytes in this example, trusting that it's correct. Here's the abstract <code class="Code-In-Text--PACKT-">Message</code> class with some common methods to help parse these GPS messages:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Message</span><span class="hljs-class">(</span><span class="hljs-params">abc.ABC</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.buffer: weakref.ReferenceType[Buffer]
        self.offset: <span class="hljs-built_in">int</span>
        self.end: Optional[<span class="hljs-built_in">int</span>]
        self.commas: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">from_buffer</span><span class="hljs-function">(</span><span class="hljs-params">self, buffer: Buffer, offset: </span><span class="hljs-built_in">int</span><span class="hljs-function">) -&gt; "Message":</span>
        self.buffer = weakref.ref(buffer)
        self.offset = offset
        self.commas = [offset]
        self.end = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(offset, offset + <span class="hljs-number">82</span>):
            <span class="hljs-keyword">if</span> buffer[index] == <span class="hljs-built_in">ord</span>(<span class="hljs-string">b","</span>):
                self.commas.append(index)
            <span class="hljs-keyword">elif</span> buffer[index] == <span class="hljs-built_in">ord</span>(<span class="hljs-string">b"*"</span>):
                self.commas.append(index)
                self.end = index + <span class="hljs-number">3</span>
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> self.end <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">raise</span> GPSError(<span class="hljs-string">"Incomplete"</span>)
        <span class="hljs-comment"># </span><span class="hljs-doctag">TODO:</span><span class="hljs-comment"> confirm checksum.</span>
        <span class="hljs-keyword">return</span> self
    <span class="hljs-keyword">def </span><span class="hljs-title">__getitem__</span><span class="hljs-function">(</span><span class="hljs-params">self, field:</span><span class="hljs-keyword"> </span><span class="hljs-built_in">int</span><span class="hljs-function">)</span><span class="hljs-keyword"> </span><span class="hljs-function">-&gt; bytes:</span>
<span class="hljs-keyword">        if </span>(<span class="hljs-keyword">not </span><span class="hljs-built_in">hasattr</span>(self,<span class="hljs-keyword"> </span><span class="hljs-string">"buffer"</span>)<span class="hljs-keyword"> </span>
<span class="hljs-keyword">            or </span>(buffer := self.buffer())<span class="hljs-keyword"> is </span><span class="hljs-literal">None</span>):
<span class="hljs-keyword">        raise</span> RuntimeError(<span class="hljs-string">"Broken reference"</span>)
<span class="hljs-keyword">    </span>start, end = self.commas[field] +<span class="hljs-keyword"> </span><span class="hljs-number">1</span>, self.commas[field + <span class="hljs-number">1</span>]
<span class="hljs-keyword">    return </span>buffer[start:end]
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__init__()</code> method doesn't actually do anything. We've provided a list of instance variables with their types, but we don't actually set them here. This is a way to alert <strong class="" style="font-style: italic;">mypy</strong> to what instance variables are going to be set elsewhere in the class. </p>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">from_buffer()</code> method, we create a weak reference to a <code class="Code-In-Text--PACKT-">Buffer</code> instance using the <code class="Code-In-Text--PACKT-">weakref.ref()</code> function. As noted above, this special reference is not used to track how many places a <code class="Code-In-Text--PACKT-">Buffer</code> object is used, allowing <code class="Code-In-Text--PACKT-">Buffer</code> objects to be removed even if <code class="Code-In-Text--PACKT-">Message</code> objects still have old, stale references to them. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">from_buffer()</code> method scans the buffer for "<code class="Code-In-Text--PACKT-">,</code>" characters, making it easier to locate where each field is. This can save some time if we need several fields. If we only need one or<a id="_idIndexMarker895"/> two<a id="_idIndexMarker896"/> fields, this might be excessive overhead. </p>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">__getitem__()</code> method, we de-reference the weak reference to track down the <code class="Code-In-Text--PACKT-">Buffer</code> object. Normally, when processing a <code class="Code-In-Text--PACKT-">Buffer</code>, it's in memory along with some <code class="Code-In-Text--PACKT-">Message</code> objects. Evaluating <code class="Code-In-Text--PACKT-">self.buffer()</code> – calling the reference like a function – retrieves the ordinary reference we can use in the body of the method. At the end of the <code class="Code-In-Text--PACKT-">__getitem__()</code> method, the buffer variable is no longer used, and the temporary reference vanishes.</p>
    <p class="normal">A client application may have code like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    buffer = Buffer(gps_device.read(<span class="hljs-number">1024</span>))
    <span class="hljs-comment"># process the messages in the buffer.</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">buffer</code> variable has an ordinary reference to a <code class="Code-In-Text--PACKT-">Buffer</code> object. Ideally, this is the only reference. Each time we execute this assignment statement, the old <code class="Code-In-Text--PACKT-">Buffer</code> object will have zero references and can be removed from memory. After this assignment statement, and before we evaluate the <code class="Code-In-Text--PACKT-">from_buffer()</code> method of a <code class="Code-In-Text--PACKT-">Message</code>, an attempt to use the <code class="Code-In-Text--PACKT-">__getitem__()</code> method of a <code class="Code-In-Text--PACKT-">Message</code> object will raise a <code class="Code-In-Text--PACKT-">RuntimeError</code> exception. </p>
    <p class="normal">If our application attempts to use a <code class="Code-In-Text--PACKT-">Message</code> object's <code class="Code-In-Text--PACKT-">__getitem__()</code> method without having done <code class="Code-In-Text--PACKT-">set_fields()</code> first, that's a serious, fatal bug. We've tried to make it obvious by crashing the application. When we get to <em class="chapterRef">Chapter 13</em>, <em class="italic">Testing Object-Oriented Programs</em>, we can use unit tests to confirm that the methods are used in the proper order. Until then, we have to be sure we use <code class="Code-In-Text--PACKT-">__getitem__()</code> correctly.</p>
    <p class="normal">Here's the rest of the <code class="Code-In-Text--PACKT-">Message</code> abstract base class, showing the methods required to extract a fix from a message:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def </span><span class="hljs-title">get_fix</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">)</span><span class="hljs-keyword"> </span><span class="hljs-function">-&gt; Point:</span>
<span class="hljs-keyword">    return </span>Point.from_bytes(
<span class="hljs-keyword">        </span>self.latitude(), 
        self.lat_n_s(), 
        self.longitude(), 
        self.lon_e_w()
<span class="hljs-keyword">    </span>)
<span class="hljs-meta">@abc.abstractmethod</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">latitude</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bytes:</span>
    ...
<span class="hljs-meta">@abc.abstractmethod</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">lat_n_s</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bytes:</span>
    ...
<span class="hljs-meta">@abc.abstractmethod</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">longitude</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bytes:</span>
    ...
<span class="hljs-meta">@abc.abstractmethod</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">lon_e_w</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bytes:</span>
    ...
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">get_fix()</code> method <a id="_idIndexMarker897"/>delegates the work to four separate <a id="_idIndexMarker898"/>methods, each of which extracts one of the many fields from the GPS message. We can provide subclasses like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">GPGLL</span><span class="hljs-class">(</span><span class="hljs-params">Message</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">latitude</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bytes:</span>
        <span class="hljs-keyword">return</span> self[<span class="hljs-number">1</span>]
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">lat_n_s</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bytes:</span>
        <span class="hljs-keyword">return</span> self[<span class="hljs-number">2</span>]
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">longitude</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bytes:</span>
        <span class="hljs-keyword">return</span> self[<span class="hljs-number">3</span>]
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">lon_e_w</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bytes:</span>
        <span class="hljs-keyword">return</span> self[<span class="hljs-number">4</span>]
</code></pre>
    <p class="normal">This class will use the <code class="Code-In-Text--PACKT-">get_field()</code> method, inherited from the <code class="Code-In-Text--PACKT-">Message</code> class, to pick out the bytes for four specific fields in the overall sequence of bytes. Because the <code class="Code-In-Text--PACKT-">get_field()</code> method uses a reference to a <code class="Code-In-Text--PACKT-">Buffer</code> object, we don't need to duplicate the entire message's sequence of bytes. Instead, we reach back into the <code class="Code-In-Text--PACKT-">Buffer</code> object to get the data, avoiding cluttering up memory.</p>
    <p class="normal">We haven't shown the <code class="Code-In-Text--PACKT-">Point</code> object. It's left as part of the exercises. It needs to convert strings of bytes into useful floating-point numbers.</p>
    <p class="normal">Here's how we <a id="_idIndexMarker899"/>create a suitable Flyweight object, based on <a id="_idIndexMarker900"/>the message type in the buffer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">message_factory</span><span class="hljs-function">(</span><span class="hljs-params">header: </span><span class="hljs-built_in">bytes</span><span class="hljs-function">) -&gt; Optional[Message]:</span>
    <span class="hljs-comment"># </span><span class="hljs-doctag">TODO:</span><span class="hljs-comment"> Add functools.lru_cache to save storage and time</span>
    <span class="hljs-keyword">if</span> header == <span class="hljs-string">b"GPGGA"</span>:
        <span class="hljs-keyword">return</span> GPGGA()
    <span class="hljs-keyword">elif</span> header == <span class="hljs-string">b"GPGLL"</span>:
        <span class="hljs-keyword">return</span> GPGLL()
    <span class="hljs-keyword">elif</span> header == <span class="hljs-string">b"GPRMC"</span>:
        <span class="hljs-keyword">return</span> GPRMC()
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
</code></pre>
    <p class="normal">If we're looking at a recognized message, we create an instance of one of our Flyweight classes. We left a comment suggesting another exercise: Use <code class="Code-In-Text--PACKT-">functools.lru_cache</code> to avoid creating <code class="Code-In-Text--PACKT-">Message</code> objects that are already available. Let's look at how the <code class="Code-In-Text--PACKT-">message_factory()</code> works in practice:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> buffer = Buffer(
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">b"$GPGLL,3751.65,S,14507.36,E*77"</span>
<span class="hljs-con-meta">...</span> )
<span class="hljs-con-meta">&gt;&gt;&gt;</span> flyweight = message_factory(buffer[<span class="hljs-con-number">1</span> : <span class="hljs-con-number">6</span>])
<span class="hljs-con-meta">&gt;&gt;&gt;</span> flyweight.from_buffer(buffer, <span class="hljs-con-number">0</span>)
&lt;gps_messages.GPGLL object at 0x7fc357a2b6d0&gt;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> flyweight.get_fix()
Point(latitude=-37.86083333333333, longitude=145.12266666666667)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(flyweight.get_fix())
(37°51.6500S, 145°07.3600E)
</code></pre>
    <p class="normal">We've loaded up a <code class="Code-In-Text--PACKT-">Buffer</code> object with some bytes. The message name is a slice of bytes in positions 1 to 6 of the buffer. The slice operation will create a small <code class="Code-In-Text--PACKT-">bytes</code> object here. The <code class="Code-In-Text--PACKT-">message_factory()</code> function will locate one of our Flyweight class definitions, the <code class="Code-In-Text--PACKT-">GPGLL</code> class. We can then use the <code class="Code-In-Text--PACKT-">from_buffer()</code> method so the Flyweight can scan the <code class="Code-In-Text--PACKT-">Buffer</code>, starting from offset zero, looking for "<code class="Code-In-Text--PACKT-">,</code>" bytes to locate the starting point and ending point for the various fields.</p>
    <p class="normal">When we evaluate <code class="Code-In-Text--PACKT-">get_fix()</code>, the <code class="Code-In-Text--PACKT-">GPGLL</code> flyweight will extract four fields, convert the values to useful <a id="_idIndexMarker901"/>degrees and return a <code class="Code-In-Text--PACKT-">Point</code> object with<a id="_idIndexMarker902"/> two floating-point values. If we want to correlate this with other devices, we might want to show a value that has degrees and minutes separated from each other. It can be more helpful to see <code class="Code-In-Text--PACKT-">37°51.6500S</code> than <code class="Code-In-Text--PACKT-">37.86083333333333</code>. </p>
    <h2 id="_idParaDest-264" class="title">Multiple messages in a buffer</h2>
    <p class="normal">Let's stretch this<a id="_idIndexMarker903"/> out a bit, to look at a buffer with a sequence of messages in it. We'll put two GPGLL messages into a sequence of bytes. We'll include explicit end-of-line whitespace characters that some GPS devices include in the data stream.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> buffer_2 = Buffer(
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">b"$GPGLL,3751.65,S,14507.36,E*77\\r\\n"</span>
<span class="hljs-con-meta">...</span>     <span class="hljs-con-string">b"$GPGLL,3723.2475,N,12158.3416,W,161229.487,A,A*41\\r\\n"</span>
<span class="hljs-con-meta">...</span> )
<span class="hljs-con-meta">&gt;&gt;&gt;</span> start = <span class="hljs-con-number">0</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> flyweight = message_factory(buffer_2[start+<span class="hljs-con-number">1</span> : start+<span class="hljs-con-number">6</span>])
<span class="hljs-con-meta">&gt;&gt;&gt;</span> p_1 = flyweight.from_buffer(buffer_2, start).get_fix()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> p_1
Point(latitude=-37.86083333333333, longitude=145.12266666666667)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(p_1)
(37°51.6500S, 145°07.3600E)
</code></pre>
    <p class="normal">We've found the first GPGLL message, created a <code class="Code-In-Text--PACKT-">GPGLL</code> object, and extracted the fix from the message. The next message begins where the previous message ends. This lets us start at a new offset in the buffer and examine a different region of bytes.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> flyweight.end
30
<span class="hljs-con-meta">&gt;&gt;&gt;</span> next_start = buffer_2.index(<span class="hljs-con-built_in">ord</span>(<span class="hljs-con-string">b"$"</span>), flyweight.end)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> next_start
32
<span class="hljs-con-meta">&gt;&gt;&gt;</span> 
<span class="hljs-con-meta">&gt;&gt;&gt;</span> flyweight = message_factory(buffer_2[next_start+<span class="hljs-con-number">1</span> : next_start+<span class="hljs-con-number">6</span>])
<span class="hljs-con-meta">&gt;&gt;&gt;</span> p_2 = flyweight.from_buffer(buffer_2, next_start).get_fix()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> p_2
Point(latitude=37.387458333333335, longitude=-121.97236)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print(p_2)
(37°23.2475N, 121°58.3416W)
</code></pre>
    <p class="normal">We've used the <code class="Code-In-Text--PACKT-">message_factory()</code> function to create a new GPGLL object. Since the data from the message isn't in the object, we can reuse the previous GPGLL object. We can take out the <code class="Code-In-Text--PACKT-">flyweight =</code> line of code, and the results are the same. When we use the <code class="Code-In-Text--PACKT-">from_buffer()</code> method, we'll locate a new batch of "<code class="Code-In-Text--PACKT-">,</code>" characters. When we use the <code class="Code-In-Text--PACKT-">get_fix()</code> method, we'll get values from a new place in the overall collection of bytes. </p>
    <p class="normal">This implementation creates a few short strings of bytes to create a cacheable object for use by <code class="Code-In-Text--PACKT-">message_factory()</code>. It creates new float values when it creates a <code class="Code-In-Text--PACKT-">Point</code>. It avoids<a id="_idIndexMarker904"/> slinging around large blocks of bytes, however, by making the message processing objects reuse a single <code class="Code-In-Text--PACKT-">Buffer</code> instance.</p>
    <p class="normal">Generally, using the Flyweight pattern in Python is a matter of making sure we have references to the original data. Generally, Python avoids making implicit copies of objects; almost all object creation is obvious, using a class name or perhaps comprehension syntax. One case where object creation is not obvious is taking a slice from a sequence, like a buffer of bytes: when we use <code class="Code-In-Text--PACKT-">bytes[start: end]</code>, this makes a copy of the bytes. Too many of these and our IoT device is out of usable memory. A Flyweight design avoids creating new objects, and – in particular – avoids slicing strings and bytes to create copies of the data.</p>
    <p class="normal">Our example also introduced <code class="Code-In-Text--PACKT-">weakref</code>. This isn't essential for a Flyweight design, but it can be helpful to identify objects that can be removed from memory. While the two are often seen together, they're not closely related.</p>
    <p class="normal">The Flyweight pattern can have an enormous impact on memory consumption. It is common for programming solutions that optimize CPU, memory, or disk space to result in more complicated code than their unoptimized brethren. It is therefore important to weigh up the trade-offs when deciding between code maintainability and optimization. When choosing optimization, try to use patterns such as Flyweight to ensure that the complexity introduced by optimization is confined to a single (well-documented) section of the code.</p>
    <p class="normal">Before we look at the Abstract Factory pattern, we'll digress a bit, to look at another memory<a id="_idIndexMarker905"/> optimization technique, unique to Python. This is the <code class="Code-In-Text--PACKT-">__slots__</code> magic attribute name.</p>
    <h2 id="_idParaDest-265" class="title">Memory optimization via Python's __slots__</h2>
    <p class="normal">If you <a id="_idIndexMarker906"/>have a lot of Python<a id="_idIndexMarker907"/> objects in one program, another way to save memory is through the use of <code class="Code-In-Text--PACKT-">__slots__</code>. This is a sidebar, since it's not a common design pattern outside the Python language. It is a helpful Python design pattern because it can shave a few bytes off an object that's used widely. Instead of a Flyweight design – where storage is intentionally shared – a slots design creates objects with their own private data, but avoids Python's built-in dictionary. Instead, there is direct mapping from attribute name to a sequence of values, avoiding the rather large hash table that is a part of every Python <code class="Code-In-Text--PACKT-">dict</code> object.</p>
    <p class="normal">Looking back at our previous example in this chapter, we avoided describing the <code class="Code-In-Text--PACKT-">Point</code> object that was created as part of the <code class="Code-In-Text--PACKT-">get_fix()</code> method of each subclass of <code class="Code-In-Text--PACKT-">Message</code>. Here's one possible definition of the <code class="Code-In-Text--PACKT-">Point</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Point</span><span class="hljs-class">:</span>
    __slots__ = (<span class="hljs-string">"latitude"</span>, <span class="hljs-string">"longitude"</span>)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, latitude: </span><span class="hljs-built_in">float</span><span class="hljs-params">, longitude: </span><span class="hljs-built_in">float</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.latitude = latitude
        self.longitude = longitude
    <span class="hljs-keyword">def </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">)</span><span class="hljs-keyword"> </span><span class="hljs-function">-&gt; str:</span>
<span class="hljs-keyword">        return </span>(
<span class="hljs-keyword">            </span><span class="hljs-string">f"Point(latitude=</span><span class="hljs-subst">{self.latitude}</span><span class="hljs-string">,</span><span class="hljs-keyword"> </span><span class="hljs-string">"</span>
<span class="hljs-keyword">            </span><span class="hljs-string">f"longitude=</span><span class="hljs-subst">{self.longitude}</span><span class="hljs-string">)"</span>
<span class="hljs-keyword">        </span>)
</code></pre>
    <p class="normal">Each instance of a <code class="Code-In-Text--PACKT-">Point</code> can have exactly two attributes with the names <code class="Code-In-Text--PACKT-">latitude</code> and <code class="Code-In-Text--PACKT-">longitude</code>. The <code class="Code-In-Text--PACKT-">__init__()</code> method sets these values and provides useful type hints for tools like <strong class="" style="font-style: italic;">mypy</strong>.</p>
    <p class="normal">In most other respects, this class is the same as a class without <code class="Code-In-Text--PACKT-">__slots__</code>. The most notable difference is we cannot add attributes. Here's an example, showing what exception is raised:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> p2 = Point(latitude=<span class="hljs-con-number">49.274</span>, longitude=-<span class="hljs-con-number">123.185</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> p2.extra_attribute = <span class="hljs-con-number">42</span>
Traceback (most recent call last):
<span class="hljs-con-meta">...</span>
AttributeError: 'Point' object has no attribute 'extra_attribute' 
</code></pre>
    <p class="normal">The extra housekeeping of defining the names of the slots can be helpful when our application creates vast numbers of these objects. In many cases, however, our application is built on one or a very small number of instances of a class, and the memory-saving from introducing <code class="Code-In-Text--PACKT-">__slots__</code> is negligible. </p>
    <p class="normal">In some cases, using a <code class="Code-In-Text--PACKT-">NamedTuple</code> can be as effective at saving memory as using <code class="Code-In-Text--PACKT-">__slots__</code>. We looked at these in <em class="chapterRef">Chapter 7</em>, <em class="italic">Python Data Structures</em>.</p>
    <p class="normal">We've seen how to manage complexity by wrapping objects in a Façade. We've seen how to manage<a id="_idIndexMarker908"/> memory use by<a id="_idIndexMarker909"/> using Flyweight objects that have little (or no) internal state. Next, we'll look at how we can create a variety of different kinds of objects using a <em class="italic">factory</em>.</p>
    <h1 id="_idParaDest-266" class="title">The Abstract Factory pattern</h1>
    <p class="normal">The Abstract <a id="_idIndexMarker910"/>Factory pattern is appropriate when we have multiple <a id="_idIndexMarker911"/>possible implementations of a system that depend on some configuration or platform detail. The calling code requests an object from the Abstract Factory, not knowing exactly what class of object will be returned. The underlying implementation returned may depend on a variety of factors, such as the current locale, operating system, or local configuration.</p>
    <p class="normal">Common examples of the Abstract Factory pattern include code for operating-system-independent toolkits, database backends, and country-specific formatters or calculators. An operating-system-independent GUI toolkit might use an Abstract Factory pattern that returns a set of WinForm widgets under Windows, Cocoa widgets under Mac, GTK widgets under Gnome, and QT widgets under KDE. Django provides an abstract factory that returns a set of object-relational classes for interacting with a specific database backend (MySQL, PostgreSQL, SQLite, and others) depending on a configuration setting for the current site. If the application needs to be deployed in multiple places, each one can use a different database backend by changing only one configuration variable. Different countries have different systems for calculating taxes, subtotals, and totals on retail merchandise; an Abstract Factory can return a particular tax calculation object.</p>
    <p class="normal">There are two central features of an Abstract Factory:</p>
    <ul>
      <li class="bullet">We need to have multiple implementation choices. Each implementation has a factory class to create objects. A single Abstract Factory defines the interface to the implementation factories.</li>
      <li class="bullet">We have a<a id="_idIndexMarker912"/> number of closely related objects, and the relationships are implemented <a id="_idIndexMarker913"/>via multiple methods of each factory.</li>
    </ul>
    <p class="normal">The following <a id="_idIndexMarker914"/>UML class diagram seems like a clutter of <a id="_idIndexMarker915"/>relationships:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.6: Abstract Factory pattern</p>
    <p class="normal">There's an essential symmetry here that's very important. The client needs instances of class A and class B. To the client, these are abstract class definitions. The <code class="Code-In-Text--PACKT-">Factory</code> class is an abstract base<a id="_idIndexMarker916"/> class that requires an implementation. Each of the implementation packages, <code class="Code-In-Text--PACKT-">implementation_1</code> and <code class="Code-In-Text--PACKT-">implementation_2</code>, provides concrete <code class="Code-In-Text--PACKT-">Factory</code> subclasses that will build the necessary A and B instances for the client.</p>
    <h2 id="_idParaDest-267" class="title">An Abstract Factory example</h2>
    <p class="normal">The UML class <a id="_idIndexMarker917"/>diagram for the Abstract Factory pattern is hard to understand without a specific example, so let's turn things around and create a concrete example first. Let's look at two card games, Poker and Cribbage. Don't panic, you don't need to know all the rules, only that they're similar in a few fundamental ways but different in the details. This is depicted in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.7: Abstract Factory pattern for Cribbage and Poker</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Game</code> class requires <code class="Code-In-Text--PACKT-">Card</code> objects and <code class="Code-In-Text--PACKT-">Hand</code> objects (among several others). We've shown that the abstract <code class="Code-In-Text--PACKT-">Card</code> objects are contained within the abstract <code class="Code-In-Text--PACKT-">Hand</code> collection. Each implementation provides some unique features. For the most part, the <code class="Code-In-Text--PACKT-">PokerCard</code> matches the generic <code class="Code-In-Text--PACKT-">Card</code> definition. The <code class="Code-In-Text--PACKT-">PokerHand</code> class, however, extends the <code class="Code-In-Text--PACKT-">Hand</code> abstract base class with all the unique rules for defining the rank of the hand. Poker players know that there are a very, very large number of Poker game variants. We've shown a hand containing five cards because this seems to be a common feature of many games.</p>
    <p class="normal">The Cribbage implementation introduces a number of types of <code class="Code-In-Text--PACKT-">CribbageCard</code> subclasses, each of <a id="_idIndexMarker918"/>which has an additional attribute, points. The <code class="Code-In-Text--PACKT-">CribbageFace</code> cards are all worth 10 points, while for the other kinds of <code class="Code-In-Text--PACKT-">CribbageCard</code> classes the number of points matches the rank. The <code class="Code-In-Text--PACKT-">CribbageHand</code> class extends the abstract base class of <code class="Code-In-Text--PACKT-">Hand</code> with the unique rules for finding all the scoring combinations in a hand. We can use an Abstract Factory to build <code class="Code-In-Text--PACKT-">Card</code> and <code class="Code-In-Text--PACKT-">Hand</code> objects.</p>
    <p class="normal">Here are the core definitions of <code class="Code-In-Text--PACKT-">Hand</code> and <code class="Code-In-Text--PACKT-">Card</code>. We didn't make these official abstract base classes. Python doesn't require this, and the extra complexity didn't seem helpful.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum, auto
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> NamedTuple, List
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Suit</span><span class="hljs-class">(</span><span class="hljs-built_in">str</span><span class="hljs-params">, Enum</span><span class="hljs-class">):</span>
    Clubs = <span class="hljs-string">"\N{Black Club Suit}"</span>
    Diamonds = <span class="hljs-string">"\N{Black Diamond Suit}"</span>
    Hearts = <span class="hljs-string">"\N{Black Heart Suit}"</span>
    Spades = <span class="hljs-string">"\N{Black Spade Suit}"</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Card</span><span class="hljs-class">(</span><span class="hljs-params">NamedTuple</span><span class="hljs-class">):</span>
    rank: <span class="hljs-built_in">int</span>
    suit: Suit
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__str__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"</span><span class="hljs-subst">{self.rank}{self.suit}</span><span class="hljs-string">"</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Trick</span><span class="hljs-class">(</span><span class="hljs-built_in">int</span><span class="hljs-params">, Enum</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Hand</span><span class="hljs-class">(</span><span class="hljs-params">List[Card]</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, *cards: Card</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-built_in">super</span>().__init__(cards)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">scoring</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; List[Trick]:</span>
        <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">These seem to capture the essence of "card" and "hand of cards." We'll need to extend these with subclasses that pertain to each game. We'll also need an Abstract Factory that creates cards and hands for us:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> abc
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">CardGameFactory</span><span class="hljs-class">(</span><span class="hljs-params">abc.ABC</span><span class="hljs-class">):</span>
<span class="hljs-meta">    @abc.abstractmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">make_card</span><span class="hljs-function">(</span><span class="hljs-params">self, rank: </span><span class="hljs-built_in">int</span><span class="hljs-params">, suit: Suit</span><span class="hljs-function">) -&gt; "Card":</span>
        ...
<span class="hljs-meta">    @abc.abstractmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">make_hand</span><span class="hljs-function">(</span><span class="hljs-params">self, *cards: Card</span><span class="hljs-function">) -&gt; "Hand":</span>
        ...
</code></pre>
    <p class="normal">We've made<a id="_idIndexMarker919"/> the factory an actual abstract base class. Each individual game needs to provide extensions for the game's unique features of <code class="Code-In-Text--PACKT-">Hand</code> and <code class="Code-In-Text--PACKT-">Card</code>. The game will also provide an implementation of the <code class="Code-In-Text--PACKT-">CardGameFactory</code> class that can build the expected classes.</p>
    <p class="normal">We can define the cards for cribbage like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">CribbageCard</span><span class="hljs-class">(</span><span class="hljs-params">Card</span><span class="hljs-class">):</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">points</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; int:</span>
        <span class="hljs-keyword">return</span> self.rank
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">CribbageAce</span><span class="hljs-class">(</span><span class="hljs-params">Card</span><span class="hljs-class">):</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">points</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; int:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">CribbageFace</span><span class="hljs-class">(</span><span class="hljs-params">Card</span><span class="hljs-class">):</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">points</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; int:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>
</code></pre>
    <p class="normal">These extensions to the base <code class="Code-In-Text--PACKT-">Card</code> class all have an additional points property. In Cribbage, one of the kinds of tricks is any combination of cards worth 15 points. Most cards have points equal to the rank, but the Jack, Queen, and King are all worth 10 points. This also means the Cribbage extension to <code class="Code-In-Text--PACKT-">Hand</code> has a rather complex method for scoring, which we'll omit for now.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">CribbageHand</span><span class="hljs-class">(</span><span class="hljs-params">Hand</span><span class="hljs-class">):</span>
    starter: Card
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">upcard</span><span class="hljs-function">(</span><span class="hljs-params">self, starter: Card</span><span class="hljs-function">) -&gt; "Hand":</span>
        self.starter = starter
        <span class="hljs-keyword">return</span> self
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">scoring</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; list[Trick]:</span>
        <span class="hljs-string">"""15's. Pairs. Runs. Right Jack."""</span>
        ... details omitted ...
        <span class="hljs-keyword">return</span> tricks
</code></pre>
    <p class="normal">To provide some <a id="_idIndexMarker920"/>uniformity between the games, we've designated the scoring combinations in Cribbage and the rank of the hand in Poker as a subclass of "Trick." In Cribbage, there's a fairly large number of point-scoring tricks. In Poker, on the other hand, there's a single Trick that represents the hand as a whole. Tricks don't seem to be a place where an Abstract Factory is useful.</p>
    <p class="normal">The computation of the various scoring combinations in Cribbage is a rather sophisticated problem. It involves looking at all possible combinations of cards that total to 15 points, among other things. These details are unrelated to the Abstract Factory design pattern.</p>
    <p class="normal">The Poker variant has its own unique complication: Aces are a higher rank than the King: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PokerCard</span><span class="hljs-class">(</span><span class="hljs-params">Card</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__str__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-keyword">if</span> self.rank == <span class="hljs-number">14</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">f"A</span><span class="hljs-subst">{self.suit}</span><span class="hljs-string">"</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"</span><span class="hljs-subst">{self.rank}{self.suit}</span><span class="hljs-string">"</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PokerHand</span><span class="hljs-class">(</span><span class="hljs-params">Hand</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">scoring</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; list[Trick]:</span>
        <span class="hljs-string">"""Return a single 'Trick'"""</span>
     ... details omitted ...
        <span class="hljs-keyword">return</span> [rank]
</code></pre>
    <p class="normal">Ranking the various hands in poker is also a rather sophisticated problem, but outside the Abstract Factory realm. Here's the concrete factory that builds hands and cards for Poker:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PokerFactory</span><span class="hljs-class">(</span><span class="hljs-params">CardGameFactory</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">make_card</span><span class="hljs-function">(</span><span class="hljs-params">self, rank: </span><span class="hljs-built_in">int</span><span class="hljs-params">, suit: Suit</span><span class="hljs-function">) -&gt; "Card":</span>
        <span class="hljs-keyword">if</span> rank == <span class="hljs-number">1</span>:
            <span class="hljs-comment"># Aces above kings</span>
            rank = <span class="hljs-number">14</span>
        <span class="hljs-keyword">return</span> PokerCard(rank, suit)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">make_hand</span><span class="hljs-function">(</span><span class="hljs-params">self, *cards: Card</span><span class="hljs-function">) -&gt; "Hand":</span>
        <span class="hljs-keyword">return</span> PokerHand(*cards)
</code></pre>
    <p class="normal">Note the way the <code class="Code-In-Text--PACKT-">make_card()</code> method reflects the way Aces work in Poker. Having the Ace outrank the King reflects a common complication in a number of card games; we need to reflect <a id="_idIndexMarker921"/>the various ways Aces work.</p>
    <p class="normal">Here's a test case for how Cribbage works:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> factory = CribbageFactory()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> cards = [
<span class="hljs-con-meta">...</span>     factory.make_card(<span class="hljs-con-number">6</span>, Suit.Clubs),
<span class="hljs-con-meta">...</span>     factory.make_card(<span class="hljs-con-number">7</span>, Suit.Diamonds),
<span class="hljs-con-meta">...</span>     factory.make_card(<span class="hljs-con-number">8</span>, Suit.Hearts),
<span class="hljs-con-meta">...</span>     factory.make_card(<span class="hljs-con-number">9</span>, Suit.Spades),
<span class="hljs-con-meta">...</span> ]
<span class="hljs-con-meta">&gt;&gt;&gt;</span> starter = factory.make_card(<span class="hljs-con-number">5</span>, Suit.Spades)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> hand = factory.make_hand(*cards)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> score = <span class="hljs-con-built_in">sorted</span>(hand.upcard(starter).scoring())
<span class="hljs-con-meta">&gt;&gt;&gt;</span> [t.name <span class="hljs-con-keyword">for</span> t <span class="hljs-con-keyword">in</span> score]
['Fifteen', 'Fifteen', 'Run_5']
</code></pre>
    <p class="normal">We've created an instance of the <code class="Code-In-Text--PACKT-">CribbageFactory</code> class, a concrete implementation of the abstract <code class="Code-In-Text--PACKT-">CardGameFactory</code> class. We can use the factory to create some cards, and we can also use the factory to create a hand of cards. When playing Cribbage, an additional card is flipped, called the "starter." In this case, our hand is four cards in sequence, and the starter happens to fit with that sequence. We can score the hand and see that there are three scoring combinations: there are two ways to make 15 points, plus a run of five cards. </p>
    <p class="normal">This design provides some hints toward what needs to be done when we want to add support for more games. Introducing new rules means creating the new <code class="Code-In-Text--PACKT-">Hand</code> and <code class="Code-In-Text--PACKT-">Card</code> subclasses and extending the Abstract Factory class definition, also. Of course, inheritance<a id="_idIndexMarker922"/> leads to the opportunity for reuse, something we can capitalize on to create families of games with similar rules.</p>
    <h2 id="_idParaDest-268" class="title">Abstract Factories in Python</h2>
    <p class="normal">The previous<a id="_idIndexMarker923"/> example highlights an interesting <a id="_idIndexMarker924"/>consequence of the way Python's duck typing works. Do we really need the abstract base class, <code class="Code-In-Text--PACKT-">CardGameFactory?</code> It provides a framework used for type checking, but otherwise doesn't have any useful features. Since we don't really need it, we can think of this design as having three parallel modules:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_08.png" alt=""/> </figure>
    <p class="packt_figref">Figure 12.8: Abstract Factory without abstract base classes</p>
    <p class="normal">Both of the<a id="_idIndexMarker925"/> defined<a id="_idIndexMarker926"/> games implement a class, <code class="Code-In-Text--PACKT-">CardGameFactory</code>, that defines the unique features of the game. Because these are in separate modules, we can use the same name for each class. This lets us write a Cribbage application that uses <code class="Code-In-Text--PACKT-">from cribbage import CardGameFactory</code>. This skips past the overhead of a common abstract base class and lets us provide extensions as separate modules sharing some common base class definitions. Each alternative implementation also provides a common module-level interface: they expose a standard class name that handles the remaining details of creating unique objects. </p>
    <p class="normal">In this case, the Abstract Factory becomes a concept, and is not implemented as an actual abstract base class. We'll need to provide adequate documentation in the docstrings for all classes that purport to be <code class="Code-In-Text--PACKT-">CardGameFactory</code> implementations. We can clarify our intentions by defining a protocol using <code class="Code-In-Text--PACKT-">typing.Protocol</code>. It could look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">CardGameFactoryProtocol</span><span class="hljs-class">(</span><span class="hljs-params">Protocol</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">make_card</span><span class="hljs-function">(</span><span class="hljs-params">self, rank: </span><span class="hljs-built_in">int</span><span class="hljs-params">, suit: Suit</span><span class="hljs-function">) -&gt; "Card":</span>
        ...
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">make_hand</span><span class="hljs-function">(</span><span class="hljs-params">self, *cards: Card</span><span class="hljs-function">) -&gt; "Hand":</span>
        ...
</code></pre>
    <p class="normal">This <a id="_idIndexMarker927"/>definition <a id="_idIndexMarker928"/>allows <strong class="" style="font-style: italic;">mypy</strong> to confirm that a <code class="Code-In-Text--PACKT-">Game</code> class can refer to either a <code class="Code-In-Text--PACKT-">poker.CardGameFactory</code> or a <code class="Code-In-Text--PACKT-">cribbage.CardGameFactory</code> because both implement the same protocol. Unlike the abstract base class definition, this is not a runtime check. A protocol definition is only used by <strong class="" style="font-style: italic;">mypy</strong> to confirm that the code is likely to pass its unit test suite.</p>
    <p class="normal">The Abstract Factory pattern helps us define related families of objects, for instance, playing cards and hands. A single factory can produce two separate classes of objects that are closely related. In some cases, the relationships aren't a simple collection and item. Sometimes there are sub-collections in addition to items. These kinds of structures can be handled using the Composite design pattern.</p>
    <h1 id="_idParaDest-269" class="title">The Composite pattern</h1>
    <p class="normal">The Composite<a id="_idIndexMarker929"/> pattern allows complex tree structures to be built from simple <a id="_idIndexMarker930"/>components, often called <strong class="keyword">nodes</strong>. A node with children will behave like a container; a node without children will behave like a single object. A composite object is – generally – a container object, where the content may be another composite object.</p>
    <p class="normal">Traditionally, each node in a composite object must be either a <strong class="keyword">leaf</strong> node (that cannot contain other objects) or a <strong class="keyword">composite</strong> node. The key is that both composite and leaf nodes can have the same interface. The following <a id="_idIndexMarker931"/>UML diagram shows this elegant parallelism as a <code class="Code-In-Text--PACKT-">some_action()</code> method:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.9: The Composite pattern</p>
    <p class="normal">This simple <a id="_idIndexMarker932"/>pattern, however, allows <a id="_idIndexMarker933"/>us to create complex arrangements of elements, all of which satisfy the interface of the component object. The following diagram depicts a concrete instance of such a complicated arrangement:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.10: A large Composite pattern</p>
    <p class="normal">The Composite pattern applies to language<a id="_idIndexMarker934"/> processing. Both natural languages and artificial<a id="_idIndexMarker935"/> languages (like Python) tend to follow rules that are hierarchical and fit nicely with the Composite design pattern. Markup languages, like HTML, XML, RST, and Markdown, tend to reflect some common composite concepts like lists of lists, and headers with sub-headings.</p>
    <p class="normal">A programming language involves recursive tree structures. The Python standard library includes the <code class="Code-In-Text--PACKT-">ast</code> module, which provides the classes that define the structure of Python code. We can use this module to examine Python code without resorting to regular expressions or other hard-to-get-correct text processing.</p>
    <h2 id="_idParaDest-270" class="title">A Composite example </h2>
    <p class="normal">The Composite <a id="_idIndexMarker936"/>pattern needs to be applied to tree structures like the files and folders of a file system. Regardless of whether a node in the tree is an ordinary data file or a folder, it is still subject to operations such as moving, copying, or deleting the node. We can create a component interface that supports these operations, and then use a composite object to represent folders, and leaf nodes to represent data files.</p>
    <p class="normal">Of course, in Python, once again, we can take advantage of duck typing to implicitly provide the interface, so we only need to write two classes. Let's define these interfaces first<a id="_idIndexMarker937"/> in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Folder</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span>
<span class="hljs-params">            self, </span>
<span class="hljs-params">            name: </span><span class="hljs-built_in">str</span><span class="hljs-params">, </span>
<span class="hljs-params">            children: Optional[</span><span class="hljs-built_in">dict</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">, </span><span class="hljs-string">"Node"</span><span class="hljs-params">]] = </span><span class="hljs-literal">None</span>
<span class="hljs-params">    </span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.name = name
        self.children = children <span class="hljs-keyword">or</span> {}
        self.parent: Optional[<span class="hljs-string">"Folder"</span>] = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"Folder(</span><span class="hljs-subst">{self.name!r}</span><span class="hljs-string">, </span><span class="hljs-subst">{self.children!r}</span><span class="hljs-string">)"</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">add_child</span><span class="hljs-function">(</span><span class="hljs-params">self, node: </span><span class="hljs-string">"Node"</span><span class="hljs-function">) -&gt; "Node":</span>
        node.parent = self
        <span class="hljs-keyword">return</span> self.children.setdefault(node.name, node)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">move</span><span class="hljs-function">(</span><span class="hljs-params">self, new_folder: </span><span class="hljs-string">"Folder"</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">copy</span><span class="hljs-function">(</span><span class="hljs-params">self, new_folder: </span><span class="hljs-string">"Folder"</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">remove</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">pass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">File</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, name: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.name = name
        self.parent: Optional[Folder] = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"File(</span><span class="hljs-subst">{self.name!r}</span><span class="hljs-string">)"</span>
 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">move</span><span class="hljs-function">(</span><span class="hljs-params">self, new_path</span><span class="hljs-function">):</span> 
        <span class="hljs-keyword">pass</span> 
 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">copy</span><span class="hljs-function">(</span><span class="hljs-params">self, new_path</span><span class="hljs-function">):</span> 
        <span class="hljs-keyword">pass</span> 
 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">remove</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span> 
        <span class="hljs-keyword">pass</span> 
</code></pre>
    <p class="normal">For each <code class="Code-In-Text--PACKT-">Folder</code>, a composite object, we maintain a dictionary of children. The children may be a mixture of <code class="Code-In-Text--PACKT-">Folder</code> and <code class="Code-In-Text--PACKT-">File</code> instances. For many composite implementations, a list is sufficient, but<a id="_idIndexMarker938"/> in this case, a dictionary will be useful for looking up children by name.</p>
    <p class="normal">Thinking about the methods involved, there are several patterns:</p>
    <ul>
      <li class="bullet">For doing a move, relocating the <code class="Code-In-Text--PACKT-">Folder</code> will carry along all the children. Relocating a <code class="Code-In-Text--PACKT-">File</code> will turn out to be precisely the same code because we don't need to consider the children.</li>
      <li class="bullet">For doing a copy, we'll need to copy all of the children. Since there's no data outside the <code class="Code-In-Text--PACKT-">File</code> nodes of the composite object, we don't need to do anything more.</li>
      <li class="bullet">For a delete, we should follow the Linux pattern of clearing out the children before trying to remove a parent.</li>
    </ul>
    <p class="normal">This design lets us create subclasses with distinct operation implementations. Each subclass implementation could make external requests, or perhaps make OS requests on the local machine.</p>
    <p class="normal">To take advantage of the similar operations, we can extract the common methods into a parent class. Let's refactor this to create a base class, <code class="Code-In-Text--PACKT-">Node</code>, with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Node</span><span class="hljs-class">(</span><span class="hljs-params">abc.ABC</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span>
<span class="hljs-params">        self,</span>
<span class="hljs-params">        name: </span><span class="hljs-built_in">str</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.name = name
        self.parent: Optional[<span class="hljs-string">"Folder"</span>] = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">move</span><span class="hljs-function">(</span><span class="hljs-params">self, new_place: </span><span class="hljs-string">"Folder"</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        previous = self.parent
        new_place.add_child(self)
        <span class="hljs-keyword">if</span> previous:
            <span class="hljs-keyword">del</span> previous.children[self.name]
<span class="hljs-meta">    @abc.abstractmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">copy</span><span class="hljs-function">(</span><span class="hljs-params">self, new_folder: </span><span class="hljs-string">"Folder"</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        ...
<span class="hljs-meta">    @abc.abstractmethod</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">remove</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        ...
</code></pre>
    <p class="normal">This abstract <code class="Code-In-Text--PACKT-">Node</code> class defines that each node has a string with a reference to a parent. Keeping the parent information around lets us look "up" the tree toward the root node. This makes it possible to move and remove files by making a change to the parent's collection of children.</p>
    <p class="normal">We've created<a id="_idIndexMarker939"/> the <code class="Code-In-Text--PACKT-">move()</code> method on the <code class="Code-In-Text--PACKT-">Node</code> class. This works by reassigning a <code class="Code-In-Text--PACKT-">Folder</code> or a <code class="Code-In-Text--PACKT-">File</code> object to a new location. It follows up by removing the object from its previous location. For the <code class="Code-In-Text--PACKT-">move()</code> method, the target should be an existing folder, or we'll get an error because a <code class="Code-In-Text--PACKT-">File</code> instance doesn't have an <code class="Code-In-Text--PACKT-">add_child()</code> method. As in many examples in technical books, error handling is woefully absent, to help focus on the principles under consideration. A common practice is to handle the <code class="Code-In-Text--PACKT-">AttributeError</code> exception by raising a new <code class="Code-In-Text--PACKT-">TypeError</code> exception. See <em class="chapterRef">Chapter 4</em>, <em class="italic">Expecting the Unexpected</em>.</p>
    <p class="normal">We can then extend this class to provide the unique features of a <code class="Code-In-Text--PACKT-">Folder</code> that has children, and a <code class="Code-In-Text--PACKT-">File</code>, which is the leaf node of the tree and has no children:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Folder</span><span class="hljs-class">(</span><span class="hljs-params">Node</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span>
<span class="hljs-params">            self, </span>
<span class="hljs-params">            name: </span><span class="hljs-built_in">str</span><span class="hljs-params">, </span>
<span class="hljs-params">            children: Optional[</span><span class="hljs-built_in">dict</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">, </span><span class="hljs-string">"Node"</span><span class="hljs-params">]] = </span><span class="hljs-literal">None</span>
<span class="hljs-params">    </span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-built_in">super</span>().__init__(name)
        self.children = children <span class="hljs-keyword">or</span> {}
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"Folder(</span><span class="hljs-subst">{self.name!r}</span><span class="hljs-string">, </span><span class="hljs-subst">{self.children!r}</span><span class="hljs-string">)"</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">add_child</span><span class="hljs-function">(</span><span class="hljs-params">self, node: </span><span class="hljs-string">"Node"</span><span class="hljs-function">) -&gt; "Node":</span>
        node.parent = self
        <span class="hljs-keyword">return</span> self.children.setdefault(node.name, node)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">copy</span><span class="hljs-function">(</span><span class="hljs-params">self, new_folder: </span><span class="hljs-string">"Folder"</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        target = new_folder.add_child(Folder(self.name))
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> self.children:
            self.children[c].copy(target)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">remove</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        names = <span class="hljs-built_in">list</span>(self.children)
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> names:
            self.children[c].remove()
        <span class="hljs-keyword">if</span> self.parent:
            <span class="hljs-keyword">del</span> self.parent.children[self.name]
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">File</span><span class="hljs-class">(</span><span class="hljs-params">Node</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"File(</span><span class="hljs-subst">{self.name!r}</span><span class="hljs-string">)"</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">copy</span><span class="hljs-function">(</span><span class="hljs-params">self, new_folder: </span><span class="hljs-string">"Folder"</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        new_folder.add_child(File(self.name))
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">remove</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">if</span> self.parent:
            <span class="hljs-keyword">del</span> self.parent.children[self.name]
</code></pre>
    <p class="normal">When we add a<a id="_idIndexMarker940"/> child to a <code class="Code-In-Text--PACKT-">Folder</code>, we'll do two things. First, we tell the child who their new parent is. This makes sure that each <code class="Code-In-Text--PACKT-">Node</code> (except the root <code class="Code-In-Text--PACKT-">Folder</code> instance) has a parent. Second, we'll drop the new <code class="Code-In-Text--PACKT-">Node</code> into the folder's collection of children, if it doesn't already exist. </p>
    <p class="normal">When we copy <code class="Code-In-Text--PACKT-">Folder</code> objects around, we need to make sure all the children are copied. Each child could, in turn, be another <code class="Code-In-Text--PACKT-">Folder</code>, with children. This recursive walk involves delegating the <code class="Code-In-Text--PACKT-">copy()</code> operation to each sub-<code class="Code-In-Text--PACKT-">Folder</code> within a <code class="Code-In-Text--PACKT-">Folder</code> instance. The implementation for a <code class="Code-In-Text--PACKT-">File</code> object, on the other hand, is simpler. </p>
    <p class="normal">The recursive design for removal is similar to the recursive copy. A <code class="Code-In-Text--PACKT-">Folder</code> instance must first remove all of the children; this may involve removing sub-<code class="Code-In-Text--PACKT-">Folder</code> instances. A <code class="Code-In-Text--PACKT-">File</code> object, on the other hand, can be directly removed.</p>
    <p class="normal">Well, that was easy enough. Let's see if our composite file hierarchy is working properly with the following code snippet:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> tree = Folder(<span class="hljs-con-string">"Tree"</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> tree.add_child(Folder(<span class="hljs-con-string">"src"</span>))
Folder('src', {})
<span class="hljs-con-meta">&gt;&gt;&gt;</span> tree.children[<span class="hljs-con-string">"src"</span>].add_child(File(<span class="hljs-con-string">"ex1.py"</span>))
File('ex1.py')
<span class="hljs-con-meta">&gt;&gt;&gt;</span> tree.add_child(Folder(<span class="hljs-con-string">"src"</span>))
Folder('src', {'ex1.py': File('ex1.py')})
<span class="hljs-con-meta">&gt;&gt;&gt;</span> tree.children[<span class="hljs-con-string">"src"</span>].add_child(File(<span class="hljs-con-string">"test1.py"</span>))
File('test1.py')
<span class="hljs-con-meta">&gt;&gt;&gt;</span> tree
Folder('Tree', {'src': Folder('src', {'ex1.py': File('ex1.py'), 'test1.py': File('test1.py')})})
</code></pre>
    <p class="normal">The value of <code class="Code-In-Text--PACKT-">tree</code> can be a<a id="_idIndexMarker941"/> little difficult to visualize. Here's a variation on the display that can help.</p>
    <pre class="programlisting con"><code class="hljs-con">+-- Tree
     +-- src
          +-- ex1.py
          +-- test1.py
</code></pre>
    <p class="normal">We didn't cover the algorithm for producing this nested visualization. It's not too difficult to add to the class definitions. We can see that the parent folder, <code class="Code-In-Text--PACKT-">Tree</code>, has a sub-folder, <code class="Code-In-Text--PACKT-">src</code>, with two files inside it. We can describe a filesystem operation like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> test1 = tree.children[<span class="hljs-con-string">"src"</span>].children[<span class="hljs-con-string">"test1.py"</span>]
<span class="hljs-con-meta">&gt;&gt;&gt;</span> test1
File('test1.py')
<span class="hljs-con-meta">&gt;&gt;&gt;</span> tree.add_child(Folder(<span class="hljs-con-string">"tests"</span>))
Folder('tests', {})
<span class="hljs-con-meta">&gt;&gt;&gt;</span> test1.move(tree.children[<span class="hljs-con-string">"tests"</span>])
<span class="hljs-con-meta">&gt;&gt;&gt;</span> tree
Folder('Tree', 
    {'src': Folder('src', 
        {'ex1.py': File('ex1.py')}), 
     'tests': Folder('tests', 
        {'test1.py': File('test1.py')})})
</code></pre>
    <p class="normal">We've created a new folder, <code class="Code-In-Text--PACKT-">tests</code>, and moved the file. Here's another view of the resulting composite objects:</p>
    <pre class="programlisting con"><code class="hljs-con">+-- Tree
     +-- src
          +-- ex1.py
     +-- tests
          +-- test1.py
</code></pre>
    <p class="normal">The Composite pattern is extremely useful for a variety of tree-like structures, including GUI widget hierarchies, file hierarchies, tree sets, graphs, and HTML DOM. Sometimes, if only a shallow tree is being created, we can get away with a list of lists or a dictionary of dictionaries, and do not need to implement custom component, leaf, and composite classes. Indeed, JSON, YAML, and TOML documents often follow the dict-of-dict pattern. While we often <a id="_idIndexMarker942"/>use abstract base classes for this, it isn't required; Python's duck typing can make it easy to add other objects to a composite hierarchy, as long as they have the correct interface.</p>
    <p class="normal">One of the important aspects of the Composite pattern is a common interface for the various subtypes of a node. We needed two implementation variants for <code class="Code-In-Text--PACKT-">Folder</code> and <code class="Code-In-Text--PACKT-">File</code> classes. In some cases, these operations are similar, and it can help to offer a template implementation of a complex method. </p>
    <h1 id="_idParaDest-271" class="title">The Template pattern</h1>
    <p class="normal">The <a id="_idIndexMarker943"/>Template<a id="_idIndexMarker944"/> pattern (sometimes called the Template method) is useful for removing duplicate code; it's intended to support the <strong class="keyword">Don't Repeat Yourself</strong> principle we discussed in <em class="chapterRef">Chapter 5</em>, <em class="italic">When to Use Object-Oriented Programming</em>. It is designed for situations where we have several different tasks to accomplish that have some, but not all, steps in common. The common steps are implemented in a base class, and the distinct steps are overridden in subclasses to provide custom behavior. In some ways, it's like the Strategy pattern, except similar sections of the algorithms are<a id="_idIndexMarker945"/> shared using a base class. Here it is in the UML format:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.11: The Template pattern</p>
    <h2 id="_idParaDest-272" class="title">A Template example</h2>
    <p class="normal">Let's create a car <a id="_idIndexMarker946"/>sales reporter as an example. We can store records of sales in an SQLite database table. SQLite is the built-in database engine that allows us to store records using SQL syntax. Python includes SQLite in its standard library, so there are no extra modules to install.</p>
    <p class="normal">We have two common tasks we need to perform:</p>
    <ul>
      <li class="bullet">Select all sales of new vehicles and output them to the screen in a comma-delimited format</li>
      <li class="bullet">Output a comma-delimited list of all salespeople with their gross sales and save it to a file that can be imported to a spreadsheet</li>
    </ul>
    <p class="normal">These seem like quite different tasks, but they have some common features. In both cases, we need to perform the following steps:</p>
    <ol>
      <li class="numbered">Connect to the database</li>
      <li class="numbered">Construct a query for new vehicles or gross sales</li>
      <li class="numbered">Issue the query</li>
      <li class="numbered">Format the results into a comma-delimited string</li>
      <li class="numbered">Output the data to a file or email</li>
    </ol>
    <p class="normal">The query construction and output steps are different for the two tasks, but the remaining steps are identical. We can use the Template pattern to put the common steps in a base <a id="_idIndexMarker947"/>class, and the varying steps in two subclasses.</p>
    <p class="normal">Before we start, let's create a database and put some sample data in it, using a few lines of SQL:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> sqlite3
<span class="hljs-keyword">def </span><span class="hljs-title">test_setup</span><span class="hljs-function">(</span><span class="hljs-params">db_name:</span><span class="hljs-keyword"> </span><span class="hljs-built_in">str</span><span class="hljs-keyword"> = </span><span class="hljs-string">"sales.db"</span><span class="hljs-function">)</span><span class="hljs-keyword"> </span><span class="hljs-function">-&gt;</span><span class="hljs-keyword"> </span><span class="hljs-function">sqlite3.Connection:</span>
<span class="hljs-keyword">    </span>conn = sqlite3.connect(db_name)
<span class="hljs-keyword">    </span>conn.execute(
<span class="hljs-keyword">        </span><span class="hljs-string">"""</span>
<span class="hljs-string">        CREATE TABLE IF NOT EXISTS Sales (</span>
<span class="hljs-string">            salesperson text,</span>
<span class="hljs-string">            amt currency,</span>
<span class="hljs-string">            year integer,</span>
<span class="hljs-string">            model text,</span>
<span class="hljs-string">            new boolean</span>
<span class="hljs-string">        )</span>
<span class="hljs-string">        """</span>
<span class="hljs-keyword">    </span>)
<span class="hljs-keyword">    </span>conn.execute(
<span class="hljs-keyword">       </span><span class="hljs-string"> """</span>
<span class="hljs-string">        DELETE FROM Sales</span>
<span class="hljs-string">        """</span>
<span class="hljs-keyword">    </span>)
<span class="hljs-keyword">    </span>conn.execute(
<span class="hljs-keyword">        </span><span class="hljs-string">"""</span>
<span class="hljs-string">        INSERT INTO Sales </span>
<span class="hljs-string">        VALUES('Tim', 16000, 2010, 'Honda Fit', 'true')</span>
<span class="hljs-string">        """</span>
<span class="hljs-keyword">    </span>)
    conn.execute(
<span class="hljs-keyword">        </span><span class="hljs-string">"""</span>
<span class="hljs-string">        INSERT INTO Sales </span>
<span class="hljs-string">        VALUES('Tim', 9000, 2006, 'Ford Focus', 'false')</span>
<span class="hljs-string">        """</span>
<span class="hljs-keyword">    </span>)
    conn.execute(
<span class="hljs-keyword">        </span><span class="hljs-string">"""</span>
<span class="hljs-string">        INSERT INTO Sales </span>
<span class="hljs-string">        VALUES('Hannah', 8000, 2004, 'Dodge Neon', 'false')</span>
<span class="hljs-string">        """</span>
<span class="hljs-keyword">    </span>)
    conn.execute(
<span class="hljs-keyword">      </span><span class="hljs-string">  """</span>
<span class="hljs-string">        INSERT INTO Sales </span>
<span class="hljs-string">        VALUES('Hannah', 28000, 2009, 'Ford Mustang', 'true')</span>
<span class="hljs-string">        """</span>
<span class="hljs-keyword">    </span>)
    conn.execute(
<span class="hljs-keyword">        </span><span class="hljs-string">"""</span>
<span class="hljs-string">        INSERT INTO Sales </span>
<span class="hljs-string">        VALUES('Hannah', 50000, 2010, 'Lincoln Navigator', 'true')</span>
<span class="hljs-string">        """</span>
<span class="hljs-keyword">    </span>)
    conn.execute(
<span class="hljs-keyword">       </span><span class="hljs-string"> """</span>
<span class="hljs-string">        INSERT INTO Sales </span>
<span class="hljs-string">        VALUES('Jason', 20000, 2008, 'Toyota Prius', 'false')</span>
<span class="hljs-string">        """</span>
<span class="hljs-keyword">    </span>)
    conn.commit()
<span class="hljs-keyword">    return </span>conn
</code></pre>
    <p class="normal">Hopefully, you can see what's going on here even if you don't know SQL; we've created a table named <code class="Code-In-Text--PACKT-">Sales</code> to <a id="_idIndexMarker948"/>hold the data, and used six <code class="Code-In-Text--PACKT-">insert</code> statements to add sales records. The data is stored in a file named <code class="Code-In-Text--PACKT-">sales.db</code>. Now we have a sample database with a table we can work with in developing our Template pattern.</p>
    <p class="normal">Since we've already outlined the steps that the template has to perform, we can start by defining the base class that contains the steps. Each step gets its own method (to make it easy to selectively override any one step), and we have one more managerial method that calls the steps in turn. Without any method content, here's how the class might look as a first step toward completion:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">QueryTemplate</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, db_name: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">"sales.db"</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">connect</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">construct_query</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">do_query</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">output_context</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; ContextManager[TextIO]:</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">output_results</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process_format</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.connect()
        self.construct_query()
        self.do_query()
        self.format_results()
        self.output_results()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">process_format()</code> method is the primary method to be called by an outside client. It ensures each step is executed in order, but it does not care whether that step is implemented in this class or in a subclass. For our examples, we expect the <code class="Code-In-Text--PACKT-">construct_query()</code> and the <code class="Code-In-Text--PACKT-">output_context()</code> methods are likely to change.</p>
    <p class="normal">In Python, we<a id="_idIndexMarker949"/> can formalize our expectation by using an abstract base class. An alternative is to raise a <code class="Code-In-Text--PACKT-">NotImplementedError</code> exception for the missing method in the template. This will provide a runtime check if we subclass the <code class="Code-In-Text--PACKT-">QueryTemplate</code> and – perhaps – misspell the name of our attempted override of the <code class="Code-In-Text--PACKT-">construct_query()</code> method.</p>
    <p class="normal">The remaining methods are going to be identical between our two classes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">QueryTemplate</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, db_name: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">"sales.db"</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.db_name = db_name
        self.conn: sqlite3.Connection
        self.results: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">str</span>, ...]]
        self.query: <span class="hljs-built_in">str</span>
        self.header: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">connect</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.conn = sqlite3.connect(self.db_name)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">construct_query</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">"construct_query not implemented"</span>)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">do_query</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        results = self.conn.execute(self.query)
        self.results = results.fetchall()
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">output_context</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; ContextManager[TextIO]:</span>
        self.target_file = sys.stdout
        <span class="hljs-keyword">return</span> cast(ContextManager[TextIO], contextlib.nullcontext())
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">output_results</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        writer = csv.writer(self.target_file)
        writer.writerow(self.header)
        writer.writerows(self.results)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process_format</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.connect()
        self.construct_query()
        self.do_query()
        <span class="hljs-keyword">with</span> self.output_context():
            self.output_results()
</code></pre>
    <p class="normal">This is a kind of abstract class. It doesn't use a formal abstract base class; instead, the two methods <a id="_idIndexMarker950"/>we expect to update show two distinct approaches to providing an abstract definition:</p>
    <ul>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">construct_query()</code> method must be overridden. The method definition base class raises the <code class="Code-In-Text--PACKT-">NotImplementedError</code> exception. This is an alternative for creating an abstract interface in Python. Raising <code class="Code-In-Text--PACKT-">NotImplementedError</code> helps the programmer understand that the class is meant to be subclassed and these methods overridden. It can be described as "smuggling in an abstract base class without being explicit" in the <code class="Code-In-Text--PACKT-">class</code> definition and without using <code class="Code-In-Text--PACKT-">@abc.abstracmethod</code> decorators.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">output_context()</code> method may be overridden. There's a default implementation provided that sets the <code class="Code-In-Text--PACKT-">self.target_file</code> instance variable and also returns a context value. The default uses <code class="Code-In-Text--PACKT-">sys.stdout</code> as the output file and a null context manager.</li>
    </ul>
    <p class="normal">Now we have a template class that takes care of the boring details, but is flexible enough to allow the execution and formatting of a wide variety of queries. The best part is, if we ever want to change our database engine from SQLite to another database engine (such as <code class="Code-In-Text--PACKT-">py-postgresql</code>), we only have to do it here, in this template class, and we don't have to touch the two (or two hundred) subclasses we might have written.</p>
    <p class="normal">Let's have a look at the concrete classes now:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">NewVehiclesQuery</span><span class="hljs-class">(</span><span class="hljs-params">QueryTemplate</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">construct_query</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.query = <span class="hljs-string">"select * from Sales where new='true'"</span>
        self.header = [<span class="hljs-string">"salesperson"</span>, <span class="hljs-string">"amt"</span>, <span class="hljs-string">"year"</span>, <span class="hljs-string">"model"</span>, <span class="hljs-string">"new"</span>]
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SalesGrossQuery</span><span class="hljs-class">(</span><span class="hljs-params">QueryTemplate</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">construct_query</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.query = (
            <span class="hljs-string">"select salesperson, sum(amt) "</span>
            <span class="hljs-string">" from Sales group by salesperson"</span>
        )
        self.header = [<span class="hljs-string">"salesperson"</span>, <span class="hljs-string">"total sales"</span>]
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">output_context</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; ContextManager[TextIO]:</span>
        today = datetime.date.today()
        filepath = Path(<span class="hljs-string">f"gross_sales_</span><span class="hljs-subst">{today:%Y%m%d}</span><span class="hljs-string">.csv"</span>)
        self.target_file = filepath.<span class="hljs-built_in">open</span>(<span class="hljs-string">"w"</span>)
        <span class="hljs-keyword">return</span> self.target_file
</code></pre>
    <p class="normal">These two classes are actually pretty short, considering what they're doing: connecting to a database, executing <a id="_idIndexMarker951"/>a query, formatting the results, and outputting them. The superclass takes care of the repetitive work, but lets us easily specify those steps that vary between tasks. Further, we can also easily change steps that are provided in the base class. For example, if we wanted to output something other than a comma-delimited string (for example, an HTML report to be uploaded to a website), we can still override the <code class="Code-In-Text--PACKT-">output_results()</code> method.</p>
    <h1 id="_idParaDest-273" class="title">Case study</h1>
    <p class="normal">The previous <a id="_idIndexMarker952"/>chapters of the case study have contained a number of design patterns. We'll pick a variation on the model and walk through some of the patterns from this chapter and how they were applied.</p>
    <p class="normal">Here's an overview of several parts of the application's classes. This is from the case study in <em class="chapterRef">Chapter 7</em>, <em class="italic">Python Data Structures</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17070_12_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 12.12: The case study Logical view</p>
    <p class="normal">This involves a <a id="_idIndexMarker953"/>number of patterns we've seen in this chapter. We'll start with the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class, which is a Façade that includes two separate complex components, the classifier algorithm and the training data.</p>
    <p class="normal">First, we'll look at the classifier algorithm. In <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>, we saw how the classifier is itself a complex structure. We looked at three alternatives: <code class="Code-In-Text--PACKT-">k_nn_1()</code>, which had a naïve sort, <code class="Code-In-Text--PACKT-">k_nn_b()</code>, which used bisection, and <code class="Code-In-Text--PACKT-">k_nn_q()</code>, which used a heap queue. This exploration relied on several design patterns from this chapter:</p>
    <ul>
      <li class="bullet">The classifier depends on the Strategy design pattern to incorporate one of the many distance computations. We defined a class, <code class="Code-In-Text--PACKT-">Distance</code>, and made sure each distance computation was a subclass. The classifier algorithm was given the distance computation as a parameter.</li>
      <li class="bullet">The classifier is a Façade that provides a uniform interface for testing and evaluating a sample. Each variation on the classifier used a slightly different data structure for managing the collection of nearest neighbors. We don't want to sort a large training set; we only want to track the subset of nearest neighbors.</li>
    </ul>
    <p class="normal">Throughout the previous chapters, we've made sure the training data leverages the Flyweight design pattern to avoid keeping multiple copies of the training data. The idea of wrapping each <code class="Code-In-Text--PACKT-">Sample</code> object with a separate frozen dataclass to include known information about the sample is a kind of Flyweight design, also. More fundamentally, it is an example of the Composite pattern. The useable sample is a composite and avoids keeping multiple copies of the underlying <code class="Code-In-Text--PACKT-">KnownSample</code> objects in memory.</p>
    <p class="normal">Looking at the <code class="Code-In-Text--PACKT-">TrainingData</code> class, we can see how this design also follows the Façade design pattern. A <a id="_idIndexMarker954"/>number of distinct operations have a uniform interface. There are two important parts:</p>
    <ul>
      <li class="bullet">Loading raw <code class="Code-In-Text--PACKT-">Sample</code> instances to partition them into training and testing subsets. The various data formats described in <em class="chapterRef">Chapter 9</em>, <em class="italic">Strings, Serialization, and File Paths</em>, can be seen as complex algorithms that are simplified by a uniform Façade. The choice of algorithm to partition the initial set of samples into a training set and a testing set is, similarly, an application of the Strategy design pattern. This lets us change the ratio of samples used for training and testing using a different implementation from a strategy class hierarchy.</li>
      <li class="bullet">Keeping the testing and training sets to be used for hyperparameter tuning is done by partitioning the raw data into two disjoint lists.</li>
    </ul>
    <p class="normal">The idea of creating <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> or <code class="Code-In-Text--PACKT-">TestingKnownSample</code> instances is an example of the Abstract Factory pattern. The partitioning algorithm can be described by an Abstract Factory class definition. Each partitioning algorithm becomes a concrete factory that creates different mixtures of training and testing objects. </p>
    <p class="normal">In <em class="chapterRef">Chapter 11</em>, <em class="italic">Common Design Patterns</em>, we looked closely at the hyperparameter tuning process. The <em class="italic">k</em>-nearest neighbors algorithm depends on two parameters, called hyperparameters:</p>
    <ul>
      <li class="bullet">The algorithm used to compute the distances between samples.</li>
      <li class="bullet">The number of samples, <em class="italic">k</em>, used. The most common of the <em class="italic">k</em> nearest neighbors becomes the label assigned to the unknown sample. If the value for <em class="italic">k</em> is odd, we can avoid an even split between two choices, ensuring there's always a winner.</li>
    </ul>
    <p class="normal">In <em class="chapterRef">Chapter 11</em>, the tuning algorithm shown is not particularly speedy but is patiently thorough: the grid search algorithm. In that chapter, we used the Command design pattern to enumerate various combinations of <em class="italic">k</em> and distance computations. Each combination was a command that – when executed – provided quality and timing information. </p>
    <p class="normal">There were three major phases of work involved in the application, as a whole. These were presented in <em class="chapterRef">Chapter 1</em>, <em class="italic">Object-Oriented Design</em>, as the various use cases:</p>
    <ol>
      <li class="numbered" value="1">A Botanist provides training data</li>
      <li class="numbered">A Botanist uses hyperparameter tuning to locate an optimal model</li>
      <li class="numbered">Users make use of this to classify their unknown samples</li>
    </ol>
    <p class="normal">This pattern of <a id="_idIndexMarker955"/>work suggests the Template design pattern may be required to ensure that classes like the <code class="Code-In-Text--PACKT-">TrainingData</code> class and the overall application work consistently. Currently, it doesn't seem like a carefully designed class hierarchy is needed. When we review <em class="chapterRef">Chapter 1</em>, however, the initial intent was to use this example to learn more about classifiers, and eventually extend this from the simple example of classifying iris species to more complex real-world problems. This follows what's called "the telescope rule":</p>
    <blockquote class="packt_quote">Thomson's Rule for First-Time Telescope Makers: "It is faster to make a four-inch mirror then a six-inch mirror than to make a six-inch mirror."</blockquote>
    <blockquote class="packt_quote">-- Programming Pearls, Communications of the ACM, September 1985</blockquote>
    <p class="normal">The intent behind the problem is to build something workable, using a variety of design patterns. The various components can then be replaced, revised, and expanded to tackle larger and more complex problems. The telescope maker will learn a lot about telescopes from making their first mirror, and those lessons can be applied to making their next, more useful telescope. A similar pattern of learning applies to software and object-oriented design. If the various components are designed well and follow established patterns, then the changes to improve and expand are not damaging or disruptive.</p>
    <h1 id="_idParaDest-274" class="title">Recall</h1>
    <p class="normal">Often, we'll spot really good ideas that are repeated; the repetition can form a recognizable pattern. Exploiting a pattern-based approach to software design can save the developer from wasting time trying to reinvent something already well understood. In this chapter, we looked at a few more advanced design patterns:</p>
    <ul>
      <li class="bullet">An Adapter class is a way to insert an intermediary so a client can make use of an existing class even when the class is not a perfect match. The software adapter parallels the idea of USB hardware adapters between various kinds of devices with various USB interface connectors. </li>
      <li class="bullet">The Façade pattern is a way to create a unified interface over a number of objects. The idea parallels the façade of a building that unifies separate floors, rooms, and halls into a single space.</li>
      <li class="bullet">We can leverage the Flyweight pattern to implement a kind of lazy initialization. Instead of copying objects, we can design Flyweight classes that share a common pool of data, minimizing or avoiding initialization entirely.</li>
      <li class="bullet">When we have closely related classes of objects, the Abstract Factory pattern can be used to build a class that can emit instances that will work together. </li>
      <li class="bullet">The Composition pattern is widely used for complex document types. It covers programming languages, natural languages, and markup languages, including XML and HTML. Even something like the filesystem with a hierarchy of directories and files fits this design pattern.</li>
      <li class="bullet">When we have a number of similar, complex classes, it seems appropriate to create a class following the Template pattern. We can leave gaps or openings in the template into which we can inject any unique features.</li>
    </ul>
    <p class="normal">These patterns can help a designer focus on accepted, good design practices. Each problem is, of course, unique, so the patterns must be adapted. It's often better to make an adaptation to a known pattern and avoid trying to invent something completely new.</p>
    <h1 id="_idParaDest-275" class="title">Exercises</h1>
    <p class="normal">Before diving into exercises for each design pattern, take a moment to add the <code class="Code-In-Text--PACKT-">os</code> and <code class="Code-In-Text--PACKT-">pathlib</code> calls to implement the methods for the <code class="Code-In-Text--PACKT-">File</code> and <code class="Code-In-Text--PACKT-">Folder</code> objects in the section on <em class="italic">The Composite pattern</em>. The <code class="Code-In-Text--PACKT-">copy()</code> method on <code class="Code-In-Text--PACKT-">File</code> will need to read and write the bytes of a file. The <code class="Code-In-Text--PACKT-">copy()</code> method on <code class="Code-In-Text--PACKT-">Folder</code> is quite a bit more complicated, as you first have to duplicate the folder, and then recursively copy each of its children to the new location. The examples we provided update the internal data structure, but don't apply changes to the operating system. Be careful about testing this in isolated directories. You don't want to accidentally destroy important files.</p>
    <p class="normal">Now, as in the previous chapter, look at the patterns we've discussed and consider ideal places where you might implement them. You may want to apply the Adapter pattern to existing code, as it is usually applicable when interfacing with existing libraries, rather than new code. How can you use an Adapter to force two interfaces to interact with each other correctly?</p>
    <p class="normal">Can you think of a system complex enough to justify using the Façade pattern? Consider how façades are used in real-life situations, such as the driver-facing interface of a car, or the control panel in a factory. It is similar in software, except the users of the façade interface are other programmers, rather than people trained to use it. Are there complex systems in your latest project that could benefit from the Façade pattern?</p>
    <p class="normal">It's possible you don't have any huge, memory-consuming code that would benefit from the Flyweight pattern, but can you think of situations where it might be useful? Anywhere that large amounts of overlapping data need to be processed, a Flyweight is waiting to be used. Would it be useful in the banking industry? In web applications? At what point does adopting the Flyweight pattern make sense? When is it overkill?</p>
    <p class="normal">The Abstract Factory pattern, or the somewhat more Pythonic derivatives we discussed, can be very useful for creating one-touch-configurable systems. Can you think of places where such systems are useful?</p>
    <p class="normal">The Composite pattern applies in a number of places. There are tree-like structures all around us in programming. Some of them, like our file hierarchy example, are blatant; others are fairly subtle. What situations might arise where the Composite pattern would be useful? Can you think of places where you can use it in your own code? What if you adapted the pattern slightly; for example, to contain different types of leaf or composite nodes for different types of objects?</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">ast</code> module provides a composite tree structure for Python code. A particularly useful thing is to use the <code class="Code-In-Text--PACKT-">ast</code> module to locate all of the import statements in some code. This can help confirm that a project's list of required modules, often in a <code class="Code-In-Text--PACKT-">requirements.txt</code> file, is complete and consistent.</p>
    <p class="normal">A Template method is helpful when decomposing a complex operation so it is open to extension. It appears that the <em class="italic">k</em>-nearest neighbors algorithm might be a good candidate for a Template method. In <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>, we rewrote the <em class="italic">k</em>-nearest neighbors algorithm as three completely separate functions. Was this necessary? Could we have rewritten it into a method that decomposes the problem into three steps: computing distances, finding the <em class="italic">k</em>-nearest, and then finding the mode? Compare this design with doing it as separate functions; which do you find more expressive?</p>
    <h1 id="_idParaDest-276" class="title">Summary</h1>
    <p class="normal">In this chapter, we went into detail on several more design patterns, covering their canonical descriptions as well as alternatives for implementing them in Python, which is often more flexible and versatile than traditional object-oriented languages. The Adapter pattern is useful for matching interfaces, while the Façade pattern is suited to simplifying them. Flyweight is a complicated pattern and only useful if memory optimization is required. Abstract Factories allow the runtime separation of implementations depending on configuration or system information. The Composite pattern is used universally for tree-like structures. A Template method can be helpful for breaking complex operations into steps to avoid repeating the common features.</p>
    <p class="normal">This is the last of the truly object-oriented design chapters in this book. In the next two chapters, we'll discuss how important it is to test Python programs, and how to do it, focusing on object-oriented principles. Then we'll look at the concurrency features of Python and how to exploit them to get work done more quickly.</p>
  </div>
</body></html>