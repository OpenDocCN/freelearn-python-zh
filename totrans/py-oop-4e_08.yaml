- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: The Intersection of Object-Oriented and Functional Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象与函数式编程的交汇
- en: 'There are many aspects of Python that appear more reminiscent of structural
    or functional programming than object-oriented programming. Although object-oriented
    programming has been the most visible paradigm of the past two decades, the old
    models have seen a recent resurgence. As with Python''s data structures, most of
    these tools are syntactic sugar over an underlying object-oriented implementation;
    we can think of them as a further abstraction layer built on top of the (already
    abstracted) object-oriented paradigm. In this chapter, we''ll be covering a grab
    bag of Python features that are not strictly object-oriented:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python的许多方面看起来更像是结构化或函数式编程，而不是面向对象编程。尽管面向对象编程在过去二十年里是最明显的编程范式，但旧的模式最近又有所复兴。与Python的数据结构一样，这些工具中的大多数都是在底层面向对象实现之上的语法糖；我们可以把它们看作是在（已经抽象化的）面向对象范式之上构建的进一步抽象层。在本章中，我们将介绍一些不是严格面向对象的Python特性：
- en: Built-in functions that take care of common tasks in one call
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数，一次调用即可处理常见任务
- en: An alternative to method overloading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重载的替代方案
- en: Functions as objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为对象
- en: File I/O and context managers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件输入输出和上下文管理器
- en: The case study in this chapter will revisit some of the essential algorithms
    of *k*-nearest neighbor classification. We'll look at how we can use functions
    instead of classes with methods. For parts of the application, separating algorithms
    from a class definition can provide some flexibility.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究将回顾一些关键的 *k* 近邻分类算法。我们将探讨如何使用函数而不是类的方法。对于应用的部分，将算法与类定义分离可以提供一些灵活性。
- en: We'll start this chapter by looking at some of Python's built-in functions.
    Some of these are closely related to class definitions, allowing us to use a functional
    style of programming with the underlying complex objects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，通过查看一些 Python 的内置函数。其中一些与类定义紧密相关，使我们能够使用函数式编程风格来处理底层复杂对象。
- en: Python built-in functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 内置函数
- en: There are numerous functions in Python that perform a task or calculate a result
    on certain types of objects without being methods on the underlying class. They
    usually abstract common calculations that apply to multiple types of classes.
    This is duck typing at its best; these functions accept objects that have certain
    attributes or methods, and are able to perform generic operations using those
    methods. We've used many of the built-in functions already, but let's quickly
    go through the important ones and pick up a few neat tricks along the way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有许多函数，它们在底层类上不是方法，但可以在某些类型的对象上执行任务或计算结果。它们通常抽象出适用于多种类型类的通用计算。这就是鸭子类型最完美的体现；这些函数接受具有某些属性或方法的对象，并能够使用这些方法执行通用操作。我们已经使用了许多内置函数，但让我们快速浏览一下重要的函数，并在过程中学习一些巧妙的技巧。
- en: The len() function
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`len()` 函数'
- en: 'One simple example of functions that are related to object methods is the `len()` function,
    which returns the number of items in some kind of container object, such as a
    dictionary or list. You''ve seen it before, demonstrated as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与对象方法相关的一个简单例子是`len()`函数，它返回某种容器对象中元素的数量，例如字典或列表。您之前已经见过它，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may wonder why these objects don't have a length property instead of having
    to call a function on them. Technically, they do. Most objects that `len()` will
    apply to have a method called `__len__()` that returns the same value. So `len(myobj)`
    seems to call `myobj.__len__()`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会 wonder 为什么这些对象没有长度属性，而需要调用它们上的一个函数。Technically，它们确实有。大多数`len()`函数可以应用的对象都有一个名为`__len__()`的方法，它返回相同的值。所以`len(myobj)`看起来就像是调用了`myobj.__len__()`。
- en: Why should we use the `len()` function instead of the `__len__()` method? Obviously, `__len__()` is
    a special double-underscore method, suggesting that we shouldn't call it directly.
    There must be an explanation for this. The Python developers don't make such design
    decisions lightly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该使用`len()`函数而不是`__len__()`方法？显然，`__len__()`是一个特殊的双下划线方法，暗示我们不应该直接调用它。这肯定有它的原因。Python开发者不会轻易做出这样的设计决策。
- en: The main reason is efficiency. When we call the `__len__()` method of an object,
    the object has to look the method up in its namespace, and, if the special `__getattribute__()`
    method (which is called every time an attribute or method on an object is accessed)
    is defined on that object, it has to be called as well. Furthermore, the `__getattribute__()`
    method may have been written to do something clever, for example, refusing to
    give us access to special methods such as `__len__()`! The `len()` function doesn't
    encounter any of this. It actually calls the `__len__()` method on the underlying
    class, so `len(myobj)` maps to `MyObj.``__len__(myobj)`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是效率。当我们调用对象的`__len__()`方法时，对象必须在它的命名空间中查找该方法，并且如果在该对象上定义了特殊的`__getattribute__()`方法（每次访问对象的属性或方法时都会调用该方法），那么它也必须被调用。此外，`__getattribute__()`方法可能被编写为执行一些巧妙的事情，例如，拒绝给我们访问特殊方法，如`__len__()`！`len()`函数不会遇到任何这些问题。它实际上在底层类上调用`__len__()`方法，所以`len(myobj)`映射到`MyObj.__len__(myobj)`。
- en: Another reason is maintainability. In the future, Python developers may want
    to change `len()` so that it can calculate the length of objects that don't have `__len__()`,
    for example, by counting the number of items returned in an iterator. They'll
    only have to change one function instead of countless `__len__()` methods in many
    objects across the board.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是可维护性。在未来，Python 开发者可能希望修改 `len()` 函数，使其能够计算没有 `__len__()` 方法的对象的长度，例如，通过计算迭代器返回的项目数量。他们只需更改一个函数，而不是在众多对象中更改无数个
    `__len__()` 方法。
- en: The functional style, `len(myobj)`, is described by some as more readable than
    the alternative method style, `myobj.len()`. Some debate the inconsistency of
    this syntax, but others prefer it for those few common operations that are applied
    to a wide number of collection types.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 功能式风格，`len(myobj)`，被一些人认为比替代方法风格，`myobj.len()`，更易读。有些人争论这种语法的非一致性，但其他人更喜欢它，因为它适用于大量集合类型中的那些常见操作。
- en: Another, sometimes overlooked, reason for `len()` being an external function
    is backward compatibility. This is often cited in articles as *for historical
    reasons*, which can be a mildly dismissive way of saying a mistake was made long
    ago and we're stuck with it. Strictly speaking, `len()` isn't a mistake; it's
    a design decision that has stood the test of time and has some benefits.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有时被忽视的原因，`len()` 是一个外部函数，是因为向后兼容性。这在文章中常被引用为 *出于历史原因*，这可以是一种轻微的轻视方式，意味着很久以前犯了一个错误，我们现在只能忍受它。严格来说，`len()`
    并不是一个错误；它是一个经得起时间考验的设计决策，并且带来了一些好处。
- en: The reversed() function
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: reversed() 函数
- en: The `reversed()` function takes any sequence as input and returns a copy of
    that sequence in reverse order. It is normally used in `for` statements when we
    want to iterate over items from back to front.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()` 函数接受任何序列作为输入，并返回该序列的逆序副本。它通常在`for`循环语句中使用，当我们想要从后向前遍历项目时。'
- en: 'Similar to the `len()` function, `reversed()` calls the `__reversed__()` method
    on the class for the parameter. If that method does not exist, `reversed` builds
    the reversed sequence itself using calls to `__len__()` and `__getitem__()`, which
    are used to define a sequence. We only need to override `__reversed__()` if we
    want to somehow customize or optimize the process, as demonstrated in the following
    code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `len()` 函数类似，`reversed()` 函数会在参数的类上调用 `__reversed__()` 方法。如果该方法不存在，`reversed`
    会通过调用 `__len__()` 和 `__getitem__()` 方法来构建反转的序列，这些方法用于定义序列。我们只需要覆盖 `__reversed__()`
    方法，如果我们想以某种方式自定义或优化这个过程，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s exercise this function on three different kinds of lists:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在三种不同的列表上练习这个函数：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `for` statements at the end print reversed versions of a generic list object,
    and instances of the `CustomSequence` class and the `FunkyBackwards` class. The
    output shows that `reversed` works on all three of them, but has very different
    results.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾处的`for`语句打印出通用列表对象的反转版本，以及`CustomSequence`类和`FunkyBackwards`类的实例。输出显示`reversed`在这三个对象上都有效，但结果却非常不同。
- en: When we reverse `CustomSequence`, the `__getitem__()` method is called for each
    item, which just inserts an `x` before the index. For `FunkyBackwards`, the `__reversed__()`
    method returns a string, each character of which is output individually in the
    `for` loop.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们反转`CustomSequence`时，`__getitem__()`方法会对每个项目进行调用，这只是在索引前插入一个`x`。对于`FunkyBackwards`，`__reversed__()`方法返回一个字符串，其中的每个字符都在`for`循环中单独输出。
- en: The `CustomSequence` class is incomplete. It doesn't define a proper version
    of `__iter__()`, so a forward `for` loop over them will never end. This is the
    subject of *Chapter 10*, *The Iterator Pattern*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomSequence` 类不完整。它没有定义一个合适的 `__iter__()` 版本，因此对它们的正向 `for` 循环永远不会结束。这是
    *第10章*，*迭代器模式*的主题。'
- en: The enumerate() function
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`enumerate()` 函数'
- en: 'Sometimes, when we''re examining items in a container with a `for` statement,
    we want access to the index (the current position in the container) of the current
    item being processed. The `for` statement doesn''t provide us with indexes, but
    the `enumerate()` function gives us something better: it creates a sequence of
    tuples, where the first object in each tuple is the index and the second is the
    original item.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当我们使用`for`语句检查容器中的项目时，我们希望访问当前正在处理的项目在容器中的索引（即当前位置）。`for`语句并没有为我们提供索引，但`enumerate()`函数提供了更好的东西：它创建了一个元组的序列，其中每个元组的第一个对象是索引，第二个是原始项目。
- en: 'This is useful because it assigns an index number. It works well for sets or
    dictionaries where there isn''t an inherent index order to the values. It also
    works for text files, which have an implied line number. Consider some simple
    code that outputs each of the lines in a file with the associated line numbers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，因为它分配了一个索引号。它适用于没有固有索引顺序的值集合或字典。它也适用于文本文件，因为文本文件隐含了行号。考虑一些简单的代码，它输出文件中的每一行及其关联的行号：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running this shows the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将显示以下内容：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `enumerate` function is an iterable: it returns a sequence of tuples. Our
    `for` statement splits each tuple into two values, and the `print()` function
    formats them together. We used the optional `start=1` on the enumerate function
    to provide a convention 1-based sequence of line numbers.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate` 函数是一个可迭代对象：它返回一系列元组。我们的 `for` 语句将每个元组拆分为两个值，并且 `print()` 函数将它们格式化在一起。我们在
    `enumerate` 函数上使用了可选的 `start=1` 来提供一个基于1的行号序列约定。'
- en: 'We''ve only touched on a few of the more important Python built-in functions.
    As you can see, many of them call into object-oriented concepts, while others
    subscribe to purely functional or procedural paradigms. There are numerous others
    in the standard library; some of the more interesting ones include the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只简要介绍了几个比较重要的Python内置函数。正如您所看到的，其中许多都涉及面向对象的概念，而另一些则遵循纯粹的功能性或过程性范式。标准库中还有许多其他函数；其中一些比较有趣的包括以下内容：
- en: '`abs()`, `str()`, `repr()`, `pow()`, and `divmod()` map directly to the special
    methods `__abs__()`, `__str__()`, `__repr__()`, `__pow__()`, and `__divmod__()`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abs()`, `str()`, `repr()`, `pow()`, 和 `divmod()` 直接映射到特殊方法 `__abs__()`, `__str__()`,
    `__repr__()`, `__pow__()`, 和 `__divmod__()`'
- en: '`bytes()`, `format()`, `hash()`, and `bool()` also map directly to the special
    methods `__bytes__()`, `__format__()`, `__hash__()`, and `__bool__()`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes()`, `format()`, `hash()`, 和 `bool()` 也直接映射到特殊方法 `__bytes__()`, `__format__()`,
    `__hash__()` 和 `__bool__()`'
- en: 'And several more. *Section 3.3, Special Methods Names* of *The Python Language
    Reference*, provides the details of these mappings. Other interesting built-in
    functions include the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个更多。*《Python语言参考》中的第3.3节，特殊方法名称*提供了这些映射的详细信息。其他有趣的内置函数包括以下内容：
- en: '`all()` and `any()`, which accept an iterable object and return `True` if all,
    or any, of the items evaluate to true (such as a non-empty string or list, a non-zero
    number, an object that is not `None`, or the literal `True`).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all()`和`any()`函数，它们接受一个可迭代对象，如果所有或任何项目评估为真（例如非空字符串或列表、非零数字、非`None`的对象或字面量`True`），则返回`True`。'
- en: '`eval()`, `exec()`, and `compile()`, which execute string as code inside the
    interpreter. Be careful with these ones; they are not safe, so don''t execute
    code an unknown user has supplied to you (in general, assume all unknown users
    are malicious, foolish, or both).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval()`, `exec()` 和 `compile()`，这些函数在解释器内部执行字符串作为代码。对这些函数要小心；它们不安全，因此不要执行未知用户提供给您的代码（通常，假设所有未知用户都是恶意的、愚蠢的，或者两者都是）。'
- en: '`hasattr()`, `getattr()`, `setattr()`, and `delattr()`, which allow attributes
    on an object to be manipulated by their string names.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasattr()`, `getattr()`, `setattr()`, 和 `delattr()`，这些函数允许通过对象的字符串名称来操作其属性。'
- en: '`zip()`, which takes two or more sequences and returns a new sequence of tuples,
    where each tuple contains a single value from each sequence.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip()` 函数接受两个或更多序列，并返回一个新的元组序列，其中每个元组包含来自每个序列的单个值。'
- en: And many more! See the interpreter help documentation for each of the functions
    listed in `help("builtins")`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多！请参阅每个函数的解析器帮助文档，这些函数列在`help("builtins")`中。
- en: What's central is avoiding a narrow viewpoint that an object-oriented programming
    language must always use `object.method()` syntax for everything. Python strives
    for readability, and a simple `len(collection)` seems more clear than the slightly
    more consistent *potential* alternative, `collection.len()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 核心在于避免一个狭隘的观点，即面向对象编程语言必须始终使用 `object.method()` 语法来处理所有事情。Python追求可读性，简单的 `len(collection)`
    似乎比略微更一致的*潜在*替代方案 `collection.len()` 更清晰。
- en: An alternative to method overloading
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重载的替代方案
- en: One prominent feature of many object-oriented programming languages is a tool
    called **method overloading**. Method overloading refers to having multiple methods
    with the same name that accept different sets of parameters. In statically typed
    languages, this is useful if we want to have a method that accepts either an integer
    or a string, for example. In non-object-oriented languages, we might need two
    functions, called `add_s` and `add_i`, to accommodate such situations. In statically
    typed object-oriented languages, we'd need two methods, both called `add`, one
    that accepts strings, and one that accepts integers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 许多面向对象编程语言的一个显著特点是称为**方法重载**的工具。方法重载指的是拥有多个具有相同名称但接受不同参数集的方法。在静态类型语言中，如果我们想要一个可以接受整数或字符串的方法，例如，这非常有用。在非面向对象的语言中，我们可能需要两个函数，分别称为`add_s`和`add_i`，以适应这种情况。在静态类型面向对象语言中，我们需要两个方法，都称为`add`，一个接受字符串，另一个接受整数。
- en: In Python, we've already seen that we only need one method, which accepts any
    type of object. It may have to do some testing on the object type (for example,
    if it is a string, convert it to an integer), but only one method is required.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们已经看到我们只需要一个方法，该方法接受任何类型的对象。可能需要对对象类型进行一些测试（例如，如果它是一个字符串，则将其转换为整数），但只需要一个方法即可。
- en: The type hints for a parameter that can take on multiple types can become rather
    complex. We'll often have to use a `typing.Union` hint to show that a parameter
    can have values from `Union[int, str]`. This definition clarifies the alternatives
    so **mypy** can confirm that we're using the overloaded function properly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以接受多种类型的参数的类型提示可能会变得相当复杂。我们通常会使用 `typing.Union` 提示来表明一个参数可以具有来自 `Union[int,
    str]` 的值。这个定义明确了备选方案，以便 **mypy** 可以确认我们正确地使用了重载函数。
- en: 'We have to distinguish between two varieties of overloading here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里必须区分两种过载的类型：
- en: Overloading parameters to allow alternative types using `Union[...]` hints
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Union[...]` 指示符来过载参数以允许使用替代类型
- en: Overloading the method by using more complex patterns of parameters
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用更复杂的参数模式来过度加载该方法
- en: For example, an email message method might come in two versions, one of which
    accepts a parameter for the *from* email address. The other method might look
    up a default *from* email address instead. Some languages force us to write multiple
    methods with the same name and different parameter patterns. Python doesn't permit
    multiple definitions of methods with the same name, but it does provide a different,
    equally flexible way to specify variant parameters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，电子邮件消息方法可能有两种版本，其中一种接受用于*发件人*电子邮件地址的参数。另一种方法可能查找默认的*发件人*电子邮件地址。某些语言强制我们编写具有相同名称但不同参数模式的多个方法。Python不允许对具有相同名称的方法进行多次定义，但它提供了一种不同但同样灵活的方式来指定变体参数。
- en: 'We''ve seen some of the possible ways to send argument values to methods and
    functions in previous examples, but now we''ll cover all the details. The simplest
    function accepts no parameters. We probably don''t need an example, but here''s
    one for completeness:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的示例中已经看到了一些向方法和函数发送参数值的方法，但现在我们将涵盖所有细节。最简单的函数不接受任何参数。我们可能不需要示例，但为了完整性，这里有一个例子：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And here''s how it''s called:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的称呼方式：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, since we're working interactively, we omitted the type hint. A
    function that does accept parameters will provide the names of those parameter
    names in a comma-separated list. Only the name of each parameter needs to be supplied.
    A type hint, however, is always helpful. The hints follow the names, separated
    by a colon, `:`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，因为我们是在交互式工作，所以我们省略了类型提示。一个接受参数的函数将通过逗号分隔的列表提供那些参数名称。只需要提供每个参数的名称。然而，类型提示总是有帮助的。提示跟随名称，由冒号分隔，`:`。
- en: 'When calling the function, the values for the positional parameters must be
    specified in order, and none can be missed or skipped. This is the most common
    way in which we''ve specified parameters in our previous examples:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，必须按照顺序指定位置参数的值，且不能遗漏或跳过任何一个。这是我们之前示例中最常见的指定参数的方式：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To call it, type the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用它，请输入以下内容：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Python code is generic with respect to type. This means that any type of object
    can be passed as an argument value: an object, a container, a primitive, even
    functions and classes. The preceding call shows a hardcoded string, the value
    of a variable, and a Boolean passed into the function.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码在类型方面是通用的。这意味着任何类型的对象都可以作为参数值传递：一个对象、一个容器、一个原始数据类型，甚至是函数和类。前面的调用显示了硬编码的字符串、变量的值以及传递给函数的布尔值。
- en: 'Generally, our applications are not completely generic. That''s why we often
    provide type hints to narrow the domain of possible values. In the rare case when
    we''re writing something truly generic, we can use the `typing.Any` hint to tell
    **mypy** that we really mean that any object is usable:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们的应用程序并非完全通用。这就是我们经常提供类型提示来缩小可能值的域的原因。在极少数情况下，当我们真正编写通用代码时，我们可以使用`typing.Any`提示来告诉**mypy**我们确实意味着任何对象都是可用的：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can use **mypy** to locate code like this using the `--disallow-any-expr`
    option. This can flag lines that may be in need of some clarity on what types
    are really important.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**mypy**通过`--disallow-any-expr`选项定位此类代码。这可以标记出可能需要一些清晰说明哪些类型真正重要的行。
- en: Default values for parameters
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数的默认值
- en: If we want to make a parameter's value optional, we can specify a default value.
    Some other languages (Java, for example) require a second method with a different
    set of parameters. In Python, we define a single method; we can provide a default
    value for a parameter using an equals sign. If the calling code does not supply
    an argument value for the parameter, it will be assigned the given default value.
    This means calling code can still choose to override the default by passing in
    a different value. If a value of `None` is used as the default for optional parameter
    values, the `typing` module lets us describe this using the `Optional` type hint.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让一个参数的值是可选的，我们可以指定一个默认值。一些其他语言（例如Java）要求有一个带有不同参数集的第二种方法。在Python中，我们定义一个单一的方法；我们可以使用等号为一个参数提供默认值。如果调用代码没有为该参数提供参数值，它将被分配给定的默认值。这意味着调用代码仍然可以选择通过传递不同的值来覆盖默认值。如果一个`None`值被用作可选参数值的默认值，`typing`模块允许我们使用`Optional`类型提示来描述这种情况。
- en: 'Here''s a function definition with default parameter definitions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个带有默认参数定义的函数定义：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first two parameters are mandatory and must be provided. The last two parameters
    have default argument values and can be omitted.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数是必填的，必须提供。最后两个参数有默认参数值，可以省略。
- en: 'There are several ways we can call this function. We can supply all argument
    values in order, as though all the parameters were positional, as can be seen
    in the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式调用这个函数。我们可以按顺序提供所有参数值，就像所有参数都是位置参数一样，如下所示：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, we can supply just the mandatory argument values in order, allowing
    one of the keyword parameters (`sec`) to use a default value, and providing a
    keyword argument for the `dir` parameter:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以按顺序提供必要的参数值，允许其中一个关键字参数（`sec`）使用默认值，并为`dir`参数提供一个关键字参数：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've used equals sign syntax when calling a function to skip default values
    that we aren't interested in.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调用函数时使用了等号语法来跳过我们不感兴趣的默认值。
- en: 'Surprisingly, we can even use the equals sign syntax to mix up the order of
    arguments for the positional parameters, so long as all the parameters are given
    an argument value:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们甚至可以使用等号语法来打乱位置参数的顺序，只要所有参数都给出了一个参数值：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may occasionally find it useful to make a *keyword-only* parameter. To
    use this, the argument value must be supplied as a keyword argument. You can do
    that by placing a `*` before all of the keyword-only parameters:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会偶尔发现创建一个**仅关键字**参数很有用。要使用这个，必须以关键字参数的形式提供参数值。你可以通过在所有仅关键字参数前放置一个`*`来实现这一点：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function has one positional parameter, `x`, and three keyword parameters, `y`, `a`,
    and `b`. The `x` and `y` parameters are both mandatory, but `a` can only be passed
    as a keyword argument. `y` and `b` are both optional with default values, but
    if `b` is supplied, it can only be a keyword argument.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有一个位置参数`x`，以及三个关键字参数`y`、`a`和`b`。`x`和`y`参数都是必需的，但`a`只能作为关键字参数传递。`y`和`b`都是可选的，并具有默认值，但如果提供了`b`，则它只能作为关键字参数。
- en: 'This function fails if you don''t pass `a`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传递`a`，此函数将失败：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It also fails if you pass `a` as a positional argument:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`a`作为位置参数传递，它也会失败：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But you can pass `a` and `b` as keyword arguments:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以将`a`和`b`作为关键字参数传递：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can also mark parameters as being supplied only by position. We do this by
    providing these names before a single `/` that separates the positional-only parameters
    from the more flexible parameters that follow.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将参数标记为仅通过位置提供。我们通过在分隔仅位置参数和随后更灵活参数的单个 `/` 之前提供这些名称来实现这一点。
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This function requires argument values for the `x` and `y` parameters be the
    first two, and named arguments for `x` and `y` are specifically not permitted.
    Here''s what happens if we try:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数要求`x`和`y`参数的值作为前两个参数，并且不允许对`x`和`y`使用命名参数。以下是尝试时的结果：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We must provide argument values for the first two parameters, `x` and `y`, positionally.
    The third parameter, `z`, can be provided positionally, or with a keyword.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须按位置提供前两个参数`x`和`y`的值。第三个参数`z`可以按位置提供，也可以使用关键字提供。
- en: 'We have three separate kinds of parameter possibilities:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种不同的参数可能性：
- en: '**Positional only**: These are handy in a few cases; see PEP 570 for examples:
    [https://www.python.org/dev/peps/pep-0570](https://www.python.org/dev/peps/pep-0570).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅位置相关**：在某些情况下这些很有用；请参阅PEP 570中的示例：[https://www.python.org/dev/peps/pep-0570](https://www.python.org/dev/peps/pep-0570).'
- en: '**Either positional or keyword**: This is the case for most parameters. The
    order is designed to be helpful, and keywords can be used for clarification. More
    than three positional parameters invites confusion, so a long list of positional
    parameters isn''t a great idea.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置或关键字**：大多数参数都是这种情况。参数的顺序设计得有助于理解，并且可以使用关键字进行说明。超过三个位置参数可能会引起混淆，因此长列表的位置参数不是一个好主意。'
- en: '**Keyword only**: After the `*`, the argument values **must** have a keyword
    supplied. This can be helpful to make rarely used options more visible. It can help
    to think of keywords as keys to a dictionary.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键词仅限**: 在 `*` 之后，参数值**必须**提供关键词。这有助于使不常用的选项更加明显。可以将关键词视为字典的键。'
- en: Choosing how to call the method normally takes care of itself, depending on
    which values need to be supplied, and which can be left at their defaults. For
    simple methods with a few argument values, positional parameters are more or less
    expected. For complex methods with a lot of argument values, using keywords can help
    to clarify how things work.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 选择如何调用方法通常可以自行处理，这取决于需要提供哪些值，哪些可以保留为默认值。对于只有几个参数值的基本方法，使用位置参数几乎是预期的。对于具有许多参数值的复杂方法，使用关键字可以帮助阐明其工作原理。
- en: Additional details on defaults
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认值的附加细节
- en: 'One thing to take note of with keyword arguments is that anything we provide
    as a default argument is evaluated exactly once when the function is first created,
    not when it is evaluated. This means we can''t have dynamically generated default
    values. For example, the following code won''t behave quite as expected:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键字参数中需要注意的一点是，我们提供的任何默认参数都是在函数首次创建时进行评估的，而不是在评估时。这意味着我们不能有动态生成的默认值。例如，以下代码的行为可能不会完全符合预期：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The default value for the `x` parameter is the current value *when the function
    is defined*. We can see that behavior when we try to evaluate this with different
    values for the `number` variable:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 参数的默认值是函数定义时的当前值 *当函数被定义时*。我们可以通过尝试用不同的 `number` 变量值来评估这个行为，从而看到这种行为：'
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first evaluation looks like our expectation; the default value is the original
    value. This is a coincidence. The second evaluation, after changing the global
    variable, `number`, shows that the function definition has a fixed value for the
    default – the variable is not re-evaluated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次评估看起来符合我们的预期；默认值是原始值。这是一个巧合。第二次评估，在改变全局变量`number`之后，显示函数定义对于默认值有一个固定值——变量不会被重新评估。
- en: 'To make this work, we''ll often use `None` as a default value and assign the
    current value of a global variable within the body of the function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个功能正常工作，我们通常会使用 `None` 作为默认值，并在函数体内分配全局变量的当前值：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This `better_function()` does not have a value for the `number` variable bound
    into the function definition. It uses the current value of a global `number` variable.
    Yes, this function is implicitly dependent on a global variable, and the docstring
    should explain that, ideally surrounded by flame emojis to make it clear to anyone
    reading it how the function's results may not be obviously idempotent.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`better_function()`函数在函数定义中没有绑定`number`变量的值。它使用全局`number`变量的当前值。是的，这个函数隐式地依赖于一个全局变量，并且文档字符串应该解释这一点，理想情况下用火焰表情符号包围，以便让任何阅读它的人都能清楚地了解函数的结果可能不是显然的幂等的。
- en: 'A slightly more compact way to set a parameter value to an argument or a default
    looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数值设置为一个参数或默认值的一个稍微紧凑的方式如下：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `number if x is None else x` expression seems to make it clear that `x`
    will have the value of the global, `number`, or the argument value provided for
    `x`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`number if x is None else x` 表达式似乎表明 `x` 将具有全局变量 `number` 的值，或者为 `x` 提供的参数值。'
- en: 'The "evaluation at definition time" can trip us up when working with mutable
    containers such as lists, sets, and dictionaries. It seems like a good design
    decision to make an empty list (or set or dictionary) as a default value for a
    parameter. We shouldn''t do this because it will create only one instance of the
    mutable object, when the code is first constructed. This one object will be reused,
    demonstrated as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: “定义时评估”可能会在处理如列表、集合和字典等可变容器时让我们陷入困境。将空列表（或集合或字典）作为参数的默认值似乎是一个良好的设计决策。我们不应该这样做，因为当代码首次构建时，它将只创建一个可变对象的实例。这个对象将被重复使用，如下所示：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is very bad design. We can try to create a history list, `h`, and append
    things to it. This seems to work. Spoiler alert: the default object is one specific
    mutable, `list`, that''s shared:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常糟糕的设计。我们可以尝试创建一个历史列表，`h`，并将事物添加到其中。这似乎是可行的。剧透警告：默认对象是一个特定的可变对象，`list`，它是共享的：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Whoops, that''s not quite what we expected! When we tried to create a second
    history list, `h2`, it was based on the one and only default value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这并不是我们预期的结果！当我们尝试创建第二个历史列表，`h2`时，它是基于唯一默认值：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The usual way to get around this is to make the default value `None`. We''ve
    seen this in previous examples, and this is a common approach:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的通常方法是设置默认值为`None`。我们已经在之前的例子中见过这种情况，这是一种常见的做法：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will build a fresh, empty `list[str]` object if no parameter was supplied.
    This is the best way to work with default values that are also mutable objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供参数，这将创建一个全新的空`list[str]`对象。这是处理默认值且这些默认值也是可变对象的最佳方式。
- en: Variable argument lists
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数列表
- en: Default values alone do not allow us all the flexibility we might want. One
    thing that makes Python really slick is the ability to write methods that accept
    an arbitrary number of positional or keyword arguments without explicitly naming
    them. We can also pass arbitrary lists and dictionaries into such functions. In
    other languages, these are sometimes called variadic arguments, **varargs**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用默认值并不能提供我们可能需要的所有灵活性。Python真正出色的一点是能够编写接受任意数量位置参数或关键字参数的方法，而无需明确命名它们。我们还可以将这些任意列表和字典传递给此类函数。在其他语言中，这些有时被称为可变参数，**变参**。
- en: 'For example, we could write a function to accept a link or list of URLs and
    download the web pages. The idea is to avoid the confusing-looking overhead of
    a singleton list when we only want one page downloaded. Instead of accepting a
    single value with a list of URLs, we can accept an arbitrary number of arguments,
    where each argument is a URL. We do this by defining one positional parameter
    to receive all the argument values. This parameter has to be last (among the positional
    parameters), and we''ll decorate it with a `*` in the function definition, as
    follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写一个函数来接受一个链接或URL列表并下载网页。这个想法是为了避免当我们只想下载一个页面时，出现看起来令人困惑的单例列表。而不是用一个URL列表接受单个值，我们可以接受任意数量的参数，其中每个参数都是一个URL。我们通过定义一个位置参数来接收所有参数值来实现这一点。这个参数必须在最后（在位置参数中），我们将在函数定义中使用一个`*`来装饰它，如下所示：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `*` in the `*links` parameter says, *I''ll accept any number of arguments
    and put them all in a tuple named* `links`. If we supply only one argument, it
    will be a list with one element; if we supply no arguments, it will be an empty
    list. Thus, all these function calls are valid:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`*links`参数中的`*`表示，“我会接受任意数量的参数并将它们全部放入一个名为`links`的元组中”。如果我们只提供一个参数，它将是一个只有一个元素的列表；如果我们不提供任何参数，它将是一个空列表。因此，所有这些函数调用都是有效的：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that our type hint suggested that all of the positional argument values
    are of the same type, `str`, in this example. This is a widespread expectation:
    the variable parameters feature is little more than syntactic sugar, saving us
    from writing a dumb-looking list. The alternative to one type for the variable
    parameter tuple is potentially confusing: why write a function expecting a complex
    collection of distinct types, but – somehow – not state this in the parameter
    definitions? Don''t write that function.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的类型提示表明在这个例子中所有位置参数的值都是同一类型，即`str`。这是一个普遍的期望：变量参数功能不过是语法糖，可以让我们避免编写看起来愚蠢的列表。对于变量参数元组使用单一类型而非其他类型的替代方案可能会造成混淆：为什么编写一个期望复杂且不同类型集合的函数，但——不知为何——在参数定义中又不明确指出这一点？不要编写那样的函数。
- en: 'We can also accept arbitrary keyword arguments. These arrive in the function
    as a dictionary. They are specified with two asterisks (as in `**kwargs`) in the
    function declaration. This tool is commonly used in configuration setups. The
    following class allows us to specify a set of options with default values:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以接受任意的关键字参数。这些参数以字典的形式传递给函数。在函数声明中，它们通过两个星号（如`**kwargs`）指定。这个工具在配置设置中常用。以下类允许我们指定一组具有默认值的选项：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This class leverages a feature of the `__init__()` method. We have a dictionary
    of default options, with the boring name of `default_options`, defined as part
    of the class. The `__init__()` method starts initializing this instance with the
    values from the class-level dictionary of defaults. We do that instead of modifying
    the dictionary directly, in case we instantiate two separate sets of options.
    (Remember, class-level variables are shared among all instances of the class.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类利用了`__init__()`方法的特性。我们有一个默认选项的字典，名称为`default_options`，它是类的一部分定义的。`__init__()`方法开始使用类级别的默认字典中的值初始化这个实例。我们这样做而不是直接修改字典，以防我们实例化两个不同的选项集。（记住，类级别的变量在类的所有实例之间是共享的。）
- en: After having seeded the instance from the class-level source data, `__init__()` uses
    the `update()` method inherited from the superclass to change any non-default
    values to those supplied as keyword arguments. Because the value of `kwargs` is
    also a dictionary, the `update()` method handles the merge of default values with
    override values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在从类级别的源数据中初始化实例之后，`__init__()` 方法使用从超类继承的 `update()` 方法将任何非默认值更改为作为关键字参数提供的值。因为
    `kwargs` 的值也是一个字典，所以 `update()` 方法处理默认值与覆盖值的合并。
- en: 'Here''s a session demonstrating the class in action:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个展示该类在实际应用中的会话：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We're able to access our `options` instance using dictionary indexing syntax.
    The `Options` dictionary includes both default values and the ones we set using
    keyword arguments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字典索引语法访问我们的`options`实例。`Options`字典包括默认值以及我们使用关键字参数设置的值。
- en: 'Note that the parent class is `typing.Dict[str, Any]`, the class for a generic
    dictionary limited to strings for keys. When we initialize the `default_options`
    object, we can rely on the `from __future__ import annotations` statement and
    use `dict[str, Any]` to tell the **mypy** tool what to expect for this variable.
    The distinction is important: the class relies on `typing.Dict` as a superclass.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，父类是 `typing.Dict[str, Any]`，这是一个限制键为字符串的泛型字典类。当我们初始化 `default_options` 对象时，我们可以依赖
    `from __future__ import annotations` 语句，并使用 `dict[str, Any]` 来告诉 **mypy** 工具对这个变量有什么期望。这种区别很重要：该类依赖于
    `typing.Dict` 作为其超类。
- en: The variable needs a type hint, and we can use either the `typing.Dict` class
    or we can use the built-in `dict` class. We suggest using the `typing` module
    only when absolutely required, and using the built-in classes as much as possible.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 变量需要一个类型提示，我们可以使用`typing.Dict`类，或者我们可以使用内置的`dict`类。我们建议仅在绝对必要时使用`typing`模块，尽可能多地使用内置类。
- en: In the preceding example, it's possible to pass arbitrary keyword arguments
    to the `Options` initializer to represent options that don't exist in the default
    dictionary. This can be handy when adding new features to an application. This
    can be bad when debugging a spelling mistake. Providing the "Port" option instead
    of the "port" option will lead to two similar-looking options where only one should
    have existed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，可以向`Options`初始化器传递任意的关键字参数来表示默认字典中不存在的选项。这在向应用程序添加新功能时可能很有用。但在调试拼写错误时可能会造成麻烦。使用“Port”选项而不是“port”选项会导致出现两个看起来相似但实际上只应存在一个的选项。
- en: One way to limit the risk of spelling mistakes is to write an `update()` method
    that only replaces existing keys. This can prevent misspellings from creating
    problems. The solution is interesting and we'll leave it as an exercise for the
    reader.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 限制拼写错误风险的一种方法是通过编写一个只替换现有键的`update()`方法。这可以防止拼写错误造成问题。这个解决方案很有趣，我们将把它留作读者的练习题。
- en: Keyword arguments are also very useful when we need to accept arbitrary arguments
    to pass to a second function, but we don't know what those arguments will be.
    We saw this in action in *Chapter 3*, *When Objects Are Alike*, when we were building
    support for multiple inheritance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数在需要接受任意参数传递给第二个函数，但不知道这些参数具体是什么时也非常有用。我们在*第3章*，*当对象相似时*中看到了这一点，当时我们在构建多重继承的支持。
- en: 'We can, of course, combine the variable argument and variable keyword argument
    syntax in one function call, and we can use normal positional and default arguments
    as well. The following example is somewhat contrived, but demonstrates the four
    types of parameters in action:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在一个函数调用中结合变量参数和变量关键字参数的语法，同时也可以使用正常的位置参数和默认参数。以下示例有些牵强，但它展示了四种参数的实际应用：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This example processes an arbitrary list of directory paths to run the **doctest**
    tool on markdown files in those directories. Let''s look at each parameter definition
    in detail:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例处理一个任意目录路径列表，在这些目录中运行**doctest**工具对Markdown文件进行处理。让我们详细查看每个参数的定义：
- en: The first parameter, `output`, is an open file to which output will be written.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数，`output`，是一个用于写入输出的打开文件。
- en: The `directories` parameter will be given all non-keyword arguments. These should
    all be `Path()` objects.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directories` 参数将接受所有非关键字参数。这些都应该都是 `Path()` 对象。'
- en: The keyword-only parameter, `verbose`, tells us whether to print information
    on each file processed.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅关键字参数`verbose`告诉我们是否要在处理每个文件时打印信息。
- en: Finally, we can supply any other keyword as the name of a file to process specially.
    Four names – output, directories, verbose, and stems – are effectively special
    filenames that can't be given special processing. Any other keyword argument will
    be collected into the `stems` dictionary, and these names will be singled out
    for special processing. Specifically, if a file stem is listed with a value of
    `"SKIP"`, the file won't be tested. If there's a value of `"ellipsis"`, then a
    special option flag will be provided to doctest.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以将任何其他关键字作为处理特殊文件的名称。四个名称——output、directories、verbose和stems——实际上是特殊文件名，不能进行特殊处理。任何其他关键字参数都将收集到`stems`字典中，并且这些名称将被单独选出进行特殊处理。具体来说，如果一个文件基名列出的值为`"SKIP"`，则该文件将不会被测试。如果值为`"ellipsis"`，则将提供一个特殊的选项标志给doctest。
- en: We create an inner helper function, `log()`, which will print messages only
    if the `verbose` parameter has been set. This function keeps code readable by
    encapsulating this functionality in a single location.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个内部辅助函数，`log()`，它只会在`verbose`参数被设置时打印消息。这个函数通过将此功能封装在单个位置来保持代码的可读性。
- en: The outermost `with` statement redirects all output normally sent to `sys.stdout`
    to the desired file. This lets us collect a single log from `print()` functions.
    The `for` statement examines all the positional argument values collected into
    the `directories` parameter. Each directory is examined with the `glob()` method
    to locate all `*.md` files in any subdirectory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层的 `with` 语句将所有通常发送到 `sys.stdout` 的输出重定向到所需的文件。这使得我们可以从 `print()` 函数中收集单个日志。`for`
    语句检查收集到 `directories` 参数中的所有位置参数值。每个目录都使用 `glob()` 方法进行检查，以定位任何子目录中的所有 `*.md`
    文件。
- en: A file's *stem* is the name without its path or suffix. So `ch_03/docs/examples.md`
    has a stem of `examples`. If the stem was used as a keyword argument, the value
    of that argument provides additional details of what to do for files with that
    specific stem. For example, if we provide the keyword argument `examples='SKIP'`,
    this will populate the `**stems` dictionary, and any file with a stem of `examples`
    will be skipped.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的**主名**是指不带路径或后缀的名称。所以 `ch_03/docs/examples.md` 的主名为 `examples`。如果将主名用作关键字参数，该参数的值提供了关于具有该特定主名文件要执行的操作的额外细节。例如，如果我们提供关键字参数
    `examples='SKIP'`，这将填充 `**stems**` 字典，并且任何主名为 `examples` 的文件都将被跳过。
- en: We use `subprocess.run()` because of the way doctest works out the local directory.
    When we want to run doctest in a number of different directories, it seems easiest
    to be sure that the current working directory (`cwd`) is set first, before we
    run doctest.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `subprocess.run()` 是因为 doctest 处理本地目录的方式。当我们想在多个不同的目录中运行 doctest 时，似乎最简单的方法是首先设置当前工作目录
    (`cwd`)，然后再运行 doctest。
- en: 'In common cases, this function could be called as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见情况下，此函数可以如下调用：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command would locate all the `*.md` files in these two directories and
    run doctest. The output would appear on the console because we redirected `sys.stdout`
    back to `sys.stdout`. Very little output would be produced because the `verbose`
    parameter would have a default value of `False`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会在这两个目录中查找所有`*.md`文件并运行doctest。输出将显示在控制台上，因为我们已将`sys.stdout`重定向回`sys.stdout`。由于`verbose`参数默认值为`False`，因此产生的输出会非常少。
- en: 'If we want to collect detailed output, we can call it with the help of the
    following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要收集详细的输出，我们可以通过以下命令来实现：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This tests files in two directories and tells us what it's doing. Notice that
    it is impossible to specify `verbose` as a positional argument in this example;
    we must pass this as a keyword argument. Otherwise, Python would think it was
    another `Path` in the `*directories` list.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在两个目录中的文件，并告诉我们它在做什么。注意，在这个例子中不能将`verbose`指定为一个位置参数；我们必须将其作为关键字参数传递。否则，Python会认为它是在`*directories`列表中的另一个`Path`。
- en: 'If we want to change the processing for a selected set of files in the list,
    we can pass additional keyword arguments, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想更改列表中选定文件的处理方式，我们可以传递额外的关键字参数，如下所示：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will test two directories, but won't display any output, since we didn't
    specify `verbose`. This will apply the `doctest --ellipsis` option to any file
    with a step of `examples`. Similarly, any file with a stem of `examples_38`, `case_study_2`,
    or `case_study_3`, are skipped.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将测试两个目录，但由于我们没有指定`verbose`，所以不会显示任何输出。这将对任何具有`examples`步骤的文件应用`doctest --ellipsis`选项。同样，任何以`examples_38`、`case_study_2`或`case_study_3`为根名的文件都将被跳过。
- en: Because we can provide any name we choose, and they will all be collected into
    the value of the `stems` parameter, we can make use of this flexibility to match
    names of files in the directory structures. There are, of course, a number of
    limitations on Python identifiers that don't match operating system filenames,
    making this less than perfect. It does, however, show the amazing flexibility
    of Python function arguments.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以选择任何名称，并且它们都将被收集到`stems`参数的值中，我们可以利用这种灵活性来匹配目录结构中文件的名称。当然，Python标识符有一些限制，它们与操作系统文件名不匹配，这使得这并不完美。然而，这确实展示了Python函数参数的惊人灵活性。
- en: Unpacking arguments
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包参数
- en: 'There''s one more nifty trick involving positional and keyword parameters.
    We''ve used it in some of our previous examples, but it''s never too late for
    an explanation. Given a list or dictionary of values, we can pass a sequence of
    values into a function as if they were normal positional or keyword arguments.
    Have a look at this code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个涉及位置参数和关键字参数的巧妙技巧。我们在之前的例子中使用过它，但解释永远不会太晚。给定一个值列表或字典，我们可以将一系列值传递给函数，就像它们是正常的位置参数或关键字参数一样。看看下面的代码：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The function accepts three parameters, one of which has a default value. But
    when we have a list of three argument values, we can use the `*` operator inside
    a function call to unpack it into the three arguments.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受三个参数，其中一个参数有默认值。但是当我们有一个包含三个参数值的列表时，我们可以在函数调用内部使用`*`运算符来将其解包为三个参数。
- en: 'Here''s what it looks like when we run it with `*some_args` to provide a three-element
    iterable:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用`*some_args`来提供一个包含三个元素的迭代器运行时的样子：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The value of `*some_args` has to match the positional parameter definition.
    Because there's a default value for `arg3`, making it optional, we can provide
    two or three values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`*some_args`的值必须与位置参数定义相匹配。因为`arg3`有一个默认值，使其成为可选参数，所以我们可以提供两个或三个值。'
- en: 'If we have a dictionary of arguments, we can use the `**` syntax to unpack
    a dictionary to supply argument values for keyword parameters. It looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个参数字典，我们可以使用`**`语法来解包字典，为关键字参数提供参数值。它看起来是这样的：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is often useful when mapping information that has been collected from user
    input or from an outside source (for example, an internet page or a text file)
    and needs to be provided to a function or method call. Rather than decompose an
    external source of data into individual keyword parameters, we simply provide
    the keyword parameters from the dictionary keys. An expression like `show_args(arg1=more_args['arg1'],
    arg2=more_args['arg2'])` seems an error-prone way to match a parameter name with
    the dictionary key.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在将用户输入或外部来源（例如，网页或文本文件）收集的信息映射到函数或方法调用时很有用。我们不是将外部数据源分解成单个关键字参数，而是直接从字典键提供关键字参数。像`show_args(arg1=more_args['arg1'],
    arg2=more_args['arg2'])`这样的表达式似乎是一种容易出错的将参数名与字典键匹配的方法。
- en: 'This unpacking syntax can be used in some areas outside of function calls,
    too. The `Options` class shown in the *Variable argument lists* section, earlier
    in this chapter, had an `__init__()` method that looked like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解包语法也可以用在函数调用之外的一些区域。本章前面“变量参数列表”部分展示的`Options`类，其`__init__()`方法看起来是这样的：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'An even more succinct way to do this would be to unpack the two dictionaries
    like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一个更加简洁的方法是将这两个字典这样展开：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The expression `{**self.default_options, **kwargs}` merges dictionaries by
    unpacking each dictionary into keyword arguments and then assembling a final dictionary
    from them. Because the dictionaries are unpacked in order from left to right,
    the resulting dictionary will contain all the default options, with any of the
    `kwarg` options replacing some of the keys. Here''s an example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `{**self.default_options, **kwargs}` 通过将每个字典解包成关键字参数，然后将它们组装成一个最终的字典来合并字典。由于字典是从左到右按顺序解包的，因此生成的字典将包含所有默认选项，其中任何
    `kwarg` 选项将替换一些键。以下是一个示例：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This dictionary unpacking is a handy consequence of the way the `**` operator
    transforms a dictionary into named parameters for a function call.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典解包是`**`操作符将字典转换为函数调用命名参数的方式的一个便捷结果。
- en: After looking at sophisticated ways we can provide argument values to functions,
    we need to look at functions a little more broadly. Python considers functions
    as one kind of "callable" object. This means functions are objects, and higher-order
    functions can accept functions as argument values and return functions as results.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了我们可以如何为函数提供参数值的各种复杂方法之后，我们需要对函数的概念进行更广泛的思考。Python 将函数视为一种“可调用”的对象。这意味着函数是对象，高阶函数可以接受函数作为参数值，并返回函数作为结果。
- en: Functions are objects, too
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数也是对象
- en: There are numerous situations where we'd like to pass around a small object
    that is simply called to perform an action. In essence, we'd like an object that
    is a callable function. This is most frequently done in event-driven programming,
    such as graphical toolkits or asynchronous servers; we'll see some design patterns
    that use it in *Chapter 11*, *Common Design Patterns*, and *Chapter 12*, *Advanced Design
    Patterns*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们都希望传递一个简单的对象来执行某个动作。本质上，我们希望的是一个可调用的函数对象。这通常在事件驱动编程中最为常见，例如图形工具包或异步服务器；我们将在第11章“常见设计模式”和第12章“高级设计模式”中看到一些使用它的设计模式。
- en: In Python, we don't need to wrap such methods in a class definition because
    functions are already objects! We can set attributes on functions (though this
    isn't a common activity), and we can pass them around to be called at a later
    date. They even have a few special properties that can be accessed directly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们不需要在类定义中包裹这样的方法，因为函数本身就是对象！我们可以在函数上设置属性（尽管这不是一个常见的活动），并且我们可以传递它们以便在稍后调用。它们甚至还有一些可以直接访问的特殊属性。
- en: 'Here''s yet another contrived example, sometimes used as an interview question:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个人为设计的例子，有时会被用作面试问题：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `fizz()` and `buzz()` functions check to see whether their parameter, `x`,
    is an exact multiple of another number. This relies on the definition of the modulo
    operator: if *x* is a multiple of 3, then 3 divides *x* with no remainder. Sometimes
    they say ![](img/B17070_08_001.png) in the math books. In Python, we say `x %
    3 == 0`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`fizz()` 和 `buzz()` 函数检查它们的参数 `x` 是否是另一个数的精确倍数。这依赖于模运算符的定义：如果 *x* 是3的倍数，那么3除以
    *x* 没有余数。有时数学书中会说 ![图片](img/B17070_08_001.png)。在Python中，我们说 `x % 3 == 0`。'
- en: The `name_or_number()` function uses any number of test functions, provided
    as the `tests` parameter value. The `for` statement assigns each function in the
    `tests` collection to a variable, `t`, then evaluates the variable with the number
    parameter's value. If the function's value is true, then the result is the function's
    name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_or_number()` 函数使用任意数量的测试函数，这些函数作为 `tests` 参数的值提供。`for` 语句将 `tests` 集合中的每个函数分配给变量
    `t`，然后使用数字参数的值评估该变量。如果函数的值为真，则结果为该函数的名称。'
- en: 'Here''s how this function looks when we apply it to a number and another function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是当我们将此函数应用于一个数字和另一个函数时，它的样子：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In each case, the value of the `tests` parameter is `(fizz,)` a tuple that contains
    only the `fizz` function. The `name_or_number()` function evaluates `t(number)`,
    where `t` is the `fizz()` function. When `fizz(number)` is true, the value returned
    is the value of the function's `__name__` attribute – the `'fizz'` string. Function
    names are available at runtime as an attribute of the function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，`tests`参数的值是`(fizz,)`，一个只包含`fizz`函数的元组。`name_or_number()`函数评估`t(number)`，其中`t`是`fizz()`函数。当`fizz(number)`为真时，返回的值是函数的`__name__`属性值——即`'fizz'`字符串。函数名在运行时作为函数的一个属性可用。
- en: 'What if we provide multiple functions? Each is applied to the number until
    one is true:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供多个函数呢？每个函数都会应用到这个数字上，直到其中一个函数返回为真：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is, by the way, not completely correct. What should happen for a number
    like 15? Is it `fizz` or `buzz` or both? Because it's both, some work needs to
    be done in the `name_or_number()` function to collect **all** the names of all
    the true functions. That sounds like it would make a good exercise.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这并不完全正确。对于像15这样的数字，会发生什么？它是“fizz”还是“buzz”，或者两者都是？因为两者都是，所以在`name_or_number()`函数中需要做一些工作来收集所有真正函数的**所有**名称。这听起来像是一个很好的练习。
- en: We can add to our list of special functions. We might define `bazz()` to be
    true for multiples of seven. This, too, sounds like a good exercise.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以增加我们特殊函数的列表。我们可以定义`bazz()`对于七的倍数返回true。这同样听起来像是一个不错的练习。
- en: 'If we run this code, we can see that we were able to pass two different functions
    into our `name_or_number()` function, and get different output for each one:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们可以看到我们能够将两个不同的函数传递给我们的`name_or_number()`函数，并且为每个函数得到不同的输出：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We could apply our functions to an argument value using `t(number)`. We were
    able to get the value of the function's `__name__` attribute using `t.__name__`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `t(number)` 将我们的函数应用于一个参数值。我们能够通过 `t.__name__` 获取函数的 `__name__` 属性的值。
- en: Function objects and callbacks
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数对象和回调函数
- en: 'The fact that functions are top-level objects is most often used to pass them
    around to be executed at a later date, for example, when a certain condition has
    been satisfied. Callbacks are common as part of building a user interface: when
    the user clicks on something, the framework can call a function so the application
    code can create a visual response. For very long-running tasks, like file transfers,
    it is often helpful for the transfer library to call back to the application with
    status on the number of bytes transferred so far – this makes it possible to display
    status thermometers to show status.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为顶级对象的事实通常被用来在稍后执行时传递它们，例如，当满足某个条件时。回调作为构建用户界面的一部分很常见：当用户点击某个东西时，框架可以调用一个函数，以便应用程序代码可以创建一个视觉响应。对于像文件传输这样长时间运行的任务，传输库通常会在已传输的字节数上回调应用程序的状态，这有助于显示状态温度计来显示状态。
- en: 'Let''s build an event-driven timer using callbacks so that things will happen
    at scheduled intervals. This can be handy for an **IoT** (**Internet of Things**)
    application built on a small CircuitPython or MicroPython device. We''ll break
    this down into two parts: a task, and a scheduler that executes the function object
    stored in the task:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用回调函数构建一个事件驱动的定时器，以便事物能够在预定的时间间隔内发生。这对于基于小型CircuitPython或MicroPython设备的**物联网（IoT**）应用来说可能很有用。我们将将其分为两部分：一个任务和一个执行存储在任务中的函数对象的调度器：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Task` class definition has two mandatory fields and two optional fields.
    The mandatory fields, `scheduled` and `callback`, provide a scheduled time to
    do something and a callback function, the thing to be done at the scheduled time.
    The scheduled time has an `int` type hint; the time module can use floating-point
    time, for super-accurate operations. We're going to ignore these details. Also,
    the **mypy** tool is well aware that integers can be coerced to floating-point
    numbers, so we don't have to be super-fussy-precise about numeric types.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 类的定义包含两个必填字段和两个可选字段。必填字段 `scheduled` 和 `callback` 提供了一个预定的时间去做某事以及一个回调函数，即在预定时间要执行的操作。预定时间有一个
    `int` 类型的提示；时间模块可以使用浮点时间，以实现超精确的操作。我们将忽略这些细节。此外，**mypy** 工具非常清楚整数可以被强制转换为浮点数，所以我们不需要对数字类型过于挑剔精确。'
- en: 'The callback has a hint of `Callable[[int], None]`. This summarizes what the
    function definition should look like. A callback function definition should look
    like `def some_name(an_arg: int) -> None:`. If it doesn''t match, **mypy** will
    alert us to the potential mismatch between our callback function definition and
    the contract specified by the type hint.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '回调函数具有`Callable[[int], None]`的提示。这总结了函数定义应该看起来像什么。一个回调函数的定义应该看起来像`def some_name(an_arg:
    int) -> None:`。如果它不匹配，**mypy**将提醒我们回调函数的定义与类型提示指定的合约之间可能存在不匹配。'
- en: The `repeat()` method can return a task for those tasks that might repeat. It
    computes a new time for the task, provides the reference to the original function
    object, and may provide a subsequent delay and a changed limit. The changed limit
    will count the number of repetitions toward zero, giving us a defined upper limit
    on processing; it's always nice to be sure that iteration will terminate.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()` 方法可以返回可能重复的任务。它计算任务的新时间，提供对原始函数对象的引用，并可能提供后续的延迟和改变的限制。改变的限制将计算重复次数，使计数达到零，为我们提供处理的上限定义；确保迭代将终止总是令人愉快的。'
- en: 'The `# type: ignore [misc]` comments are there because there''s a feature here
    that''s confusing to **mypy**. When we use code like `self.callback` or `someTask.callback()`,
    it looks like an ordinary method. The code in the `Scheduler` class is not going
    to use it as an ordinary method; it will be used as a reference to a separate
    function defined entirely outside of the class. The assumption wired into Python
    is this: a `Callable` attribute must be a method, and that means the method must
    have a "`self`" variable. In this case, the callable object is a separate function.
    The easiest way to refute the assumption is by silencing **mypy**''s checking
    of this line of code. An alternative is to assign `self.callback` to another non-`self`
    variable to make it look like it''s an external function.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`# type: ignore [misc]` 注释存在是因为这里有一个让 **mypy** 感到困惑的功能。当我们使用 `self.callback`
    或 `someTask.callback()` 这样的代码时，它看起来像是一个普通的方法。`Scheduler` 类中的代码不会将其作为普通方法使用；它将用作对完全定义在类外部的单独函数的引用。Python
    中内置的假设是：一个 `Callable` 属性必须是一个方法，这意味着该方法必须有一个 "`self`" 变量。在这种情况下，可调用对象是一个单独的函数。反驳这个假设的最简单方法是通过静默
    **mypy** 对此行代码的检查。另一种方法是将其赋值给另一个非 `self` 变量，使其看起来像是一个外部函数。'
- en: 'Here''s the overall `Scheduler` class that uses these `Task` objects and their
    associated callback functions:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用这些`Task`对象及其相关回调函数的`Scheduler`类的整体结构：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The central feature of the `Scheduler` class is a heap queue, a `List` of `Task`
    objects kept in a specific order. We mentioned the heap queue in the *Three types
    of queues* section of *Chapter 7*, *Python Data Structures*, noting that the priority
    ordering made it inappropriate for that use case. Here, however, the heap data
    structure makes use of the flexibility of a list to keep items in order without
    the overhead of a complete sort of the entire list. In this case, we want to keep
    items in order by the time they''re required to be executed: "first things first"
    order. When we push something to a heap queue, it''s inserted so the time order
    will be maintained. When we pop the next thing from the queue, the heap may be
    adjusted to keep the first things at the front of the queue.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scheduler`类的核心特性是一个堆队列，这是一个按照特定顺序排列的`Task`对象列表。我们在*第7章*的*三种队列类型*部分提到了堆队列，指出由于优先级排序，它不适合那个用例。然而，在这里，堆数据结构利用了列表的灵活性来保持项目顺序，而不需要整个列表的完整排序开销。在这种情况下，我们希望按照项目需要执行的时间顺序来保持项目顺序：“先来先服务”的顺序。当我们向堆队列中推入某物时，它会以保持时间顺序的方式插入。当我们从队列中弹出下一个项目时，堆可能会进行调整，以保持队列前面的项目是优先的。'
- en: The `Scheduler` class provides an `enter()` method to add a new task to the
    queue. This method accepts a `delay` parameter representing the interval to wait
    before executing the callback task, and the `task` function itself, a function
    to be executed at the correct time. This `task` function should fit the type hint
    of `Callback`, defined above.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scheduler` 类提供了一个 `enter()` 方法来将新任务添加到队列中。此方法接受一个表示在执行回调任务之前等待间隔的 `delay`
    参数，以及 `task` 函数本身，这是一个将在正确时间执行的函数。此 `task` 函数应适合上面定义的 `Callback` 类型的提示。'
- en: There are no runtime checks to ensure the callback function really does meet
    the type hint. It's only checked by **mypy**. More importantly, the `after`, `delay`,
    and `limit` parameters should have some validation checks. For example, a negative
    value of `after` or `delay` should raise a `ValueError` exception. There's a special
    method name, `__post_init__()`, that a dataclass can use for validation. This
    is invoked after `__init__()` and can be used for other initialization, pre-computing
    derived values, or validating that the combination of values is sensible.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 没有运行时检查来确保回调函数确实符合类型提示。这仅由 **mypy** 进行检查。更重要的是，`after`、`delay` 和 `limit` 参数应该有一些验证检查。例如，`after`
    或 `delay` 的负值应该引发一个 `ValueError` 异常。有一个特殊的方法名，`__post_init__()`，数据类可以使用它来进行验证。这个方法在
    `__init__()` 之后被调用，可以用于其他初始化、预计算派生值或验证值的组合是否合理。
- en: The `run()` method removes items from the queue in order by the time they're
    supposed to be performed. If we're at (or past) the required time, then the value
    computed for `delay` will be zero or negative, and we don't need to wait; we can
    perform the callback immediately. If we're before the required time, then we need
    to sleep until the time arrives.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()`方法按照项目应该执行的时间顺序从队列中移除项目。如果我们已经到达（或超过）了所需时间，那么计算出的`delay`值将是零或负数，我们不需要等待；我们可以立即执行回调。如果我们还在所需时间之前，那么我们需要睡眠直到时间到来。'
- en: At the appointed time, we'll update our current time in the `current_time` variable.
    We'll call the callback function provided in the `Task` object. And then we'll
    see if the `Task` object's `repeat()` method will provide another repeat task
    into the queue.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定时间，我们将更新`current_time`变量中的当前时间。我们将调用`Task`对象中提供的回调函数。然后我们将查看`Task`对象的`repeat()`方法是否会将另一个重复任务添加到队列中。
- en: The important things to note here are the lines that touch callback functions.
    The function is passed around like any other object and the `Scheduler` and `Task`
    classes never know or care what the original name of the function is or where
    it was defined. When it's time to call the function, the `Scheduler` simply evaluates
    the function with `new_task.callback(current_time)`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事项是那些接触回调函数的行。该函数就像任何其他对象一样被传递，而`Scheduler`和`Task`类永远不会知道或关心该函数的原始名称或定义位置。当需要调用该函数时，`Scheduler`只需使用`new_task.callback(current_time)`来评估该函数。
- en: 'Here''s a set of callback functions that test the `Scheduler` class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一组用于测试`Scheduler`类的回调函数：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: These functions all meet the definition of the `Callback` type hint, so they'll
    work nicely. The `Repeater` class definition has a method, `four()`, that meets
    the definition. That means an instance of `Repeater` can also be used.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数都符合`Callback`类型提示的定义，所以它们将很好地工作。`Repeater`类定义中有一个名为`four()`的方法，它符合该定义。这意味着`Repeater`的一个实例也可以被使用。
- en: We've defined a handy utility function, `format_time()`, to write common messages.
    It uses the format string syntax to add the current time to the message. The three
    small callback functions output the current time and a short message telling us
    which of the callbacks has been fired.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个方便的实用函数，`format_time()`，用于编写常用信息。它使用格式字符串语法将当前时间添加到信息中。三个小的回调函数输出当前时间，并显示哪个回调已被触发。
- en: 'Here''s an example of creating a scheduler and loading it up with callback
    functions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个创建调度器并将回调函数加载到其中的示例：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This example allows us to see how multiple callbacks interact with the timer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子让我们看到多个回调如何与计时器交互。
- en: The `Repeater` class demonstrates that methods can be used as callbacks too,
    since they are really functions that happen to be bound to an object. Using a
    method of an instance of the `Repeater` class is a function like any other.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repeater` 类演示了方法也可以用作回调，因为它们实际上是绑定到对象上的函数。使用 `Repeater` 类实例的方法就像使用任何其他函数一样。'
- en: 'The output shows that events are run in the expected order:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示事件按照预期的顺序执行：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that some events have the same scheduled run time. Scheduled after 2 seconds,
    for example, both callback functions `one()` and `two()` are defined. They both
    ran at 01:44:36\. There's no rule to decide how to resolve the tie between these
    two functions. The scheduler's algorithm is to pop an item from the heap queue,
    execute the callback function, then pop another item from the heap queue; if it
    has the same execution time, then evaluate the next callback function. Which of
    the two callbacks is performed first and which is done second is an implementation
    detail of the heap queue. If order matters to your application, you'll need an
    additional attribute to distinguish among items scheduled at the same time; a
    priority number is often used for this.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，某些事件具有相同的预定运行时间。例如，在2秒后预定，回调函数`one()`和`two()`都被定义。它们都在01:44:36运行。没有规则来决定如何解决这两个函数之间的平局。调度器的算法是从堆队列中弹出一个项目，执行回调函数，然后从堆队列中弹出一个另一个项目；如果它们具有相同的执行时间，那么评估下一个回调函数。这两个回调函数哪个先执行，哪个后执行是堆队列的实现细节。如果你的应用程序中顺序很重要，你需要一个额外的属性来区分同时预定的事件；通常使用优先级数字来完成这个任务。
- en: Because Python is a dynamic language, the contents of a class are not fixed.
    There are some more advanced programming techniques available to us. In the next
    section, we'll look at changing the methods of a class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python是一种动态语言，类的内含内容不是固定的。我们有更多高级的编程技术可以使用。在下一节中，我们将探讨如何更改类的属性。
- en: Using functions to patch a class
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数来修补类
- en: One of the things we noted in the previous example was that **mypy** assumed
    that the `Callable` attribute, `callback`, was a method of the `Task` class. This
    leads to a potentially confusing **mypy** error message, `Invalid self argument
    "Task" to attribute function "callback" with type "Callable[[int], None]"`. In
    the previous example, the callable attribute was emphatically not a method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们注意到**mypy**假设了`Callable`属性`callback`是`Task`类的一个方法。这可能导致一个可能令人困惑的**mypy**错误信息，“无效的自变量“Task”到属性函数“callback”的类型“Callable[[int],
    None]””。在前一个示例中，可调用属性明确不是一个方法。
- en: The presence of the confusion means that a callable attribute can be treated
    as a method of a class. Since we can generally supply extra methods to a class,
    it means we can patch in additional methods at runtime.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 存在混淆意味着一个可调用的属性可以被当作一个类的成员方法。由于我们通常可以向类提供额外的成员方法，这意味着我们可以在运行时添加额外的成员方法。
- en: Does it mean we **should** do this? It's perhaps a bad idea, except in a very
    special situation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们**应该**这样做？或许这并不是一个好主意，除非在非常特殊的情况下。
- en: 'It is possible to add or change a function to an instantiated object, demonstrated
    as follows. First we''ll define a class, `A`, with a method, `show_something()`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向一个实例化的对象添加或更改一个函数，如下所示。首先，我们将定义一个类，`A`，并包含一个方法，`show_something()`：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This looks like what we''d expect. We invoke the method on an instance of the
    class and see the results of the `print()` function. Now, let''s patch this object,
    replacing the `show_something()` method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是我们预期的样子。我们在类的实例上调用该方法，并查看`print()`函数的结果。现在，让我们修复这个对象，替换`show_something()`方法：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We've patched the object introducing an attribute that's a callable function.
    When we use `a_object.show_something()`, the rule is to look in local attributes
    first, then look in class attributes. Because of this, we've used a callable attribute
    to create a localized patch to this instance of the `A` class.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对该对象进行了修复，引入了一个可调用的函数属性。当我们使用`a_object.show_something()`时，规则是首先查找本地属性，然后查找类属性。正因为如此，我们使用可调用属性为`A`类的这个实例创建了一个本地化的修复补丁。
- en: 'We can create another instance of the class, unpatched, and see that it''s
    still using the class-level method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建该类的另一个实例，未修补的，并查看它仍然使用的是类级别的`方法`：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we can patch an object, you'd think we can also patch the class. We can.
    It is possible to replace methods on classes instead of objects. If we change
    the class, we have to account for the `self` argument that will be implicitly
    provided to methods defined in the class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以修补一个对象，你可能会想我们也可以修补类。我们可以。在类上替换方法而不是对象是可能的。如果我们更改类，我们必须考虑到将隐式提供给类中定义的方法的`self`参数。
- en: It's very important to note that patching a class will change the method for
    all instances of that object, even ones that have already been instantiated. Obviously,
    replacing methods like this can be both dangerous and confusing to maintain. Somebody
    reading the code will see that a method has been called and look up that method
    on the original class. But the method on the original class is not the one that
    was called. Figuring out what really happened can become a tricky, frustrating
    debugging session.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，修补一个类将会改变该对象所有实例的方法，即使这些实例已经实例化。显然，以这种方式替换方法可能会既危险又难以维护。阅读代码的人会看到调用了某个方法，并会在原始类中查找该方法。但原始类中的方法并不是被调用的那个方法。弄清楚究竟发生了什么可能会变成一个棘手、令人沮丧的调试过程。
- en: 'There''s a cardinal assumption that needs to underpin everything we write.
    It''s a kind of contract that is essential to understanding how software works:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个基本的假设需要支撑我们写下的每一件事。这是一种对于理解软件工作原理至关重要的契约：
- en: The code people see in a module file must be the code that is running.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 模块文件中人们看到的代码必须是正在运行的代码。
- en: Breaking this assumption will really confuse people. Our previous example showed
    an instance of class `A` that had a method named `show_something()` with behavior
    clearly different to the definition for class `A`. That's going to be lead people
    to distrust your application software.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 打破这个假设会真正让人感到困惑。我们之前的例子展示了一个名为`A`的类，它有一个名为`show_something()`的方法，其行为与类`A`的定义明显不同。这可能会导致人们不信任你的应用程序软件。
- en: This technique does have its uses though. Often, replacing or adding methods
    at runtime (called **monkey patching**) is used in automated testing. If testing
    a client-server application, we may not want to actually connect to the server
    while testing the client; this may result in accidental transfers of funds or
    embarrassing test emails being sent to real people.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术虽然有其用途。通常，在运行时替换或添加方法（称为**猴子补丁**）被用于自动化测试。如果在测试客户端-服务器应用程序时，我们可能不想在测试客户端时实际连接到服务器；这可能会导致意外转账或尴尬的测试邮件发送给真实的人。
- en: Instead, we can set up our test code to replace some of the key methods on the
    object that sends requests to the server so that it only records that the methods
    have been called. We'll cover this in detail in *Chapter 13*, *Testing Object-Oriented
    Programs*. Outside the narrow realm of testing, monkey patching is generally a
    sign of bad design.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以设置我们的测试代码来替换对象发送请求到服务器的一些关键方法，以便它只记录这些方法已被调用。我们将在*第13章*，*面向对象程序的测试*中详细讲解这一点。在测试的狭隘领域之外，猴子补丁通常被视为设计不佳的标志。
- en: This is sometimes justified as part of a bug fix for imported components. If
    this is done, the patch needs to be clearly flagged so anyone looking at the code
    knows what bug is being worked around and when the fix can be removed. We call
    this kind of code *tech debt*, because the complication of using a monkey patch
    is a liability.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时被正当化为修复导入组件中的错误的一部分。如果这样做，补丁需要明确标记，以便任何查看代码的人都知道正在解决哪个错误以及何时可以移除修复。我们称这种代码为*技术债务*，因为使用猴子补丁的复杂性是一种负债。
- en: In the case of our class in this example, a subclass of `A` with a distinct
    implementation of `show_something()` would make things much more clear than a
    patched method.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中我们班级的情况下，一个具有独特`show_something()`实现方式的`A`的子类，会比修补方法使事情更加清晰。
- en: We can use class definitions to create objects that are usable as if they were
    functions. This gives us another path toward using small, separate functions to
    build applications.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类定义来创建可以像函数一样使用的对象。这为我们使用小型、独立的函数构建应用程序提供了另一条途径。
- en: Callable objects
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可调用对象
- en: 'Just as functions are objects that can have attributes set on them, it is possible
    to create an object that can be called as though it were a function. Any object
    can be made callable by giving it a `__call__()` method that accepts the required
    arguments. Let''s make our `Repeater` class, from the timer example, a little
    easier to use by making it a callable, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如函数是可以设置属性的实体一样，可以创建一个可以像函数一样调用的对象。任何对象都可以通过给它一个接受所需参数的`__call__()`方法来使其可调用。让我们通过使其可调用，使从计时器示例中的`Repeater`类更容易使用，如下所示：
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This example isn''t much different from the earlier class; all we did was change
    the name of the `repeater` function to `__call__` and pass the object itself as
    a callable. How does this work? We can do the following interactively to see an
    example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与之前的类并没有太大的不同；我们只是将`repeater`函数的名称改为了`__call__`，并将对象本身作为可调用对象传递。这是怎么工作的呢？我们可以通过以下交互式操作来查看一个示例：
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At this point, we''ve created a callable object, `rpt()`. When we evaluate
    something like `rpt(1)`, Python will evaluate `rpt.__call__(1)` for us because
    there''s a `__call__()` method defined. It looks like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个可调用的对象，`rpt()`。当我们评估类似 `rpt(1)` 的内容时，Python 会为我们评估 `rpt.__call__(1)`，因为定义了
    `__call__()` 方法。它看起来是这样的：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here''s an example of using this variation on the `Repeater_2` class definition
    with a `Scheduler` object:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`Repeater_2`类定义的这种变体以及`Scheduler`对象的示例：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that, when we make the `enter()` call, we pass as an argument the value `Repeater_2()`.
    Those two parentheses are creating a new instance of the class. The instance that
    is created has the `__call__()` method, which can be used by the `Scheduler`.
    When working with callable objects, it's essential to create an instance of a class;
    it's the object that's callable, not the class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们调用`enter()`方法时，我们将`Repeater_2()`的值作为参数传递。这两个括号正在创建类的新实例。创建的实例具有`__call__()`方法，该方法可以被`Scheduler`使用。当与可调用对象一起工作时，创建类的实例是至关重要的；是对象可调用，而不是类。
- en: 'At this point, we''ve seen two different kinds of callable objects:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两种不同类型的可调用对象：
- en: Python's functions, built with the `def` statement.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 的函数，通过 `def` 语句构建。
- en: Callable objects. These are instances of a class with the `__call__()` method
    defined.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可调用对象。这些是定义了`__call__()`方法的类的实例。
- en: Generally, the simple `def` statement is all we need. Callable objects, however,
    can do something an ordinary function can't do. Our `Repeater_2` class counts
    the number of times it was used. An ordinary function is stateless. A callable
    object can be stateful. This needs to be used with some care, but some algorithms
    can have a dramatic performance improvement from saving results in a cache, and
    a callable object is a great way to save results from a function so they don't
    need to be recomputed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，简单的`def`语句就足够了。然而，可调用对象可以做一些普通函数做不到的事情。我们的`Repeater_2`类会计算它被使用的次数。一个普通函数是无状态的。可调用对象可以是状态的。这需要谨慎使用，但某些算法可以通过在缓存中保存结果来显著提高性能，而可调用对象是保存函数结果以避免重新计算的一个很好的方法。
- en: File I/O
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件输入输出
- en: Our examples so far that have touched the filesystem have operated entirely
    on text files without much thought as to what is going on under the hood. Operating
    systems represent files as a sequence of bytes, not text. We'll take a deep dive
    into the relationship between bytes and text in *Chapter 9*, *Strings, Serialization,
    and File Paths*. For now, be aware that reading textual data from a file is a
    fairly involved process, but Python takes care of most of the work for us behind
    the scenes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止的例子中，涉及文件系统的操作都是完全在文本文件上进行的，并没有太多考虑底层发生了什么。操作系统将文件表示为一系列字节，而不是文本。我们将在第9章“字符串、序列化和文件路径”中深入探讨字节和文本之间的关系。现在，请注意，从文件中读取文本数据是一个相当复杂的过程，但Python在幕后为我们处理了大部分工作。
- en: The concept of files has been around since long before anyone coined the term *object-oriented
    programming*. However, Python has wrapped the interface that operating systems
    provide in a sweet abstraction that allows us to work with file (or file-like,
    vis-à-vis duck typing) objects.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的概念早在有人提出**面向对象编程**这一术语之前就已经存在了。然而，Python 将操作系统提供的接口封装在一个甜美的抽象层中，这使得我们可以与文件（或类似文件的对象，即鸭子类型）对象一起工作。
- en: The confusion arises because the operating system file and the Python file object
    are both, commonly, called "files." It's difficult to be ultra-cautious and wrap
    each reference to the term *file* with appropriate context to distinguish bytes
    on a disk from the OS libraries for accessing those bytes from the Python file
    object that wraps the OS libraries.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 产生混淆的原因是因为操作系统文件和Python文件对象通常都被称为“文件”。很难做到极度谨慎，并且在每个对术语*文件*的引用周围都加上适当的环境来区分磁盘上的字节和从Python文件对象访问这些字节的操作系统库。
- en: Python's `open()` built-in function is used to open the OS file and return a
    Python file object. For reading text from a file, we only need to pass the name
    of the file into the function. The OS file will be opened for reading, and the
    bytes will be converted to text using the platform's default encoding.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `open()` 内置函数用于打开操作系统文件并返回一个 Python 文件对象。对于从文件中读取文本，我们只需将文件名传递给函数即可。操作系统文件将以读取模式打开，并且使用平台默认编码将字节转换为文本。
- en: A file "name" can be a name relative to the current working directory. It can
    also be an absolute name, beginning from the root of the directory tree. A file's
    name is the tail end of a path to the file from the root of the filesystem. The
    root in a Linux-based filesystem is "`/`". In Windows, there's a filesystem on
    each device, so we use a more complex name like "`C:\`". While Windows uses `\`
    for separating elements of the file path, Python's `pathlib` uses "`/`" consistently,
    converting the string to the OS-specific names when needed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名 "name" 可以是相对于当前工作目录的相对路径。它也可以是一个绝对路径，从目录树的根开始。文件名是从文件系统根到文件路径的末尾。基于Linux的文件系统中，根是
    "`/`"。在Windows中，每个设备上都有一个文件系统，所以我们使用更复杂的名称，如 "`C:\`"。虽然Windows使用 `\` 来分隔文件路径的元素，但Python的
    `pathlib` 一致地使用 "`/`"，在需要时将字符串转换为特定于操作系统的名称。
- en: 'Of course, we don''t always want to *read* files; often we want to *write*
    data to them! To open a file for writing, we need to pass a `mode` argument as
    the second positional argument to `open()`, with a value of `"w"`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们并不总是想*读取*文件；通常我们希望向其中*写入*数据！为了打开文件进行写入，我们需要将`mode`参数作为`open()`函数的第二个位置参数传递，其值为`"w"`：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We could also supply the value `"a"` as a mode argument, to *append* to the
    end of the file, rather than completely overwriting existing file content.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将值 `"a"` 作为模式参数提供，以 *追加* 的方式添加到文件末尾，而不是完全覆盖现有文件内容。
- en: These files with built-in wrappers for converting bytes to text are great, but
    it'd be awfully inconvenient if the file we wanted to open was an image, executable,
    or other binary file, wouldn't it?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置将字节转换为文本的包装器的文件很棒，但如果我们要打开的文件是一个图片、可执行文件或其他二进制文件，那就非常不方便了，不是吗？
- en: To open a binary file, we modify the mode string to append `"b"`. So, `"wb"` would
    open a file for writing bytes, while `"rb"` allows us to read them. They will
    behave like text files, but without the automatic encoding of text to bytes. When
    we read such a file, it will return `bytes` objects instead of `str`, and when
    we write to it, it will fail if we try to pass a text object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开一个二进制文件，我们需要修改模式字符串以追加 `"b"`。因此，`"wb"` 将打开一个用于写入字节的文件，而 `"rb"` 允许我们读取它们。它们的行为类似于文本文件，但不会自动将文本编码为字节。当我们读取这样的文件时，它将返回 `bytes` 对象而不是 `str`，当我们向其写入时，如果我们尝试传递一个文本对象，它将失败。
- en: These mode strings for controlling how files are opened are rather cryptic and
    are neither Pythonic nor object-oriented. However, they are consistent with virtually
    every other programming language out there because they are based on the venerable
    standard I/O library. File I/O is one of the fundamental jobs an operating system
    has to handle, and all programming languages have to talk to the operating system using
    the same system calls.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于控制文件打开方式的模式字符串相当晦涩，既不符合Python风格，也不是面向对象的。然而，由于它们基于备受尊敬的标准I/O库，因此与几乎所有其他编程语言都保持一致。文件I/O是操作系统必须处理的基本任务之一，所有编程语言都必须使用相同的系统调用来与操作系统进行通信。
- en: Since all files are actually bytes, it's important to be aware that reading
    text means that the bytes are converted to text characters. Most operating systems
    use an encoding called UTF-8 to represent the Unicode characters Python uses as
    bytes. In some cases, other encodings might be used, and we may have to provide
    an `encoding='cp1252'` argument value when opening a text file that uses an uncommon
    encoding.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有文件实际上都是字节，因此重要的是要意识到读取文本意味着字节被转换为文本字符。大多数操作系统使用一种称为UTF-8的编码来表示Python作为字节使用的Unicode字符。在某些情况下，可能会使用其他编码，并且当我们打开使用不常见编码的文本文件时，可能需要提供一个`encoding='cp1252'`的参数值。
- en: Once a file is opened for reading, we can call any of the `read()`, `readline()`,
    or `readlines()` methods to get the contents of the file. The `read()` method
    returns the entire contents of the file as a `str` or `bytes` object, depending
    on whether there is `"b"` in the mode. Be careful not to use this method without
    arguments on huge files. You don't want to find out what happens if you try to
    load that much data into memory!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被打开用于读取，我们可以调用`read()`、`readline()`或`readlines()`中的任何一种方法来获取文件的内容。`read()`方法返回整个文件的内容作为一个`str`或`bytes`对象，这取决于模式中是否有`"b"`。请注意，不要在没有参数的情况下对大文件使用此方法。你不想知道如果尝试将如此多的数据加载到内存中会发生什么！
- en: It is also possible to read a fixed number of bytes from a file; we pass an
    integer argument to the `read()` method, describing how many bytes we want to
    read. The next call to `read()` will load the next sequence of bytes, and so on.
    We can do this inside a `while` statement to read the entire file in manageable
    chunks.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取固定数量的字节也是可能的；我们通过传递一个整数参数给`read()`方法，来描述我们想要读取的字节数。下一次调用`read()`将加载下一个字节序列，依此类推。我们可以在`while`语句中这样做，以分块读取整个文件。
- en: Some file formats define neatly bounded chunks for us. The logging module can
    transmit log objects as bytes. A process reading those bytes must first read four
    bytes to determine the size of the log message. The size value defines how many
    more bytes must be read to gather a single, complete message.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件格式为我们定义了整齐划分的块。日志模块可以将日志对象作为字节传输。读取这些字节的过程必须首先读取四个字节以确定日志消息的大小。大小值定义了还需要读取多少字节才能收集到一个完整的信息。
- en: The `readline()` method returns a single line from the file (where each line
    ends in a newline, a carriage return, or both, depending on the operating system
    on which the file was created). We can call it repeatedly to get additional lines.
    The plural `readlines()` method returns a list of all the lines in the file. Like
    the `read()` method, it's not safe to use on very large files. These two methods
    even work when the file is open in `bytes` mode, but it only makes sense if we
    are parsing text-like data that has newlines at reasonable positions. An image
    or audio file, for example, will not have newline characters in it (unless the
    newline byte happened to represent a certain pixel or sound), so applying `readline()` wouldn't
    make sense.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`readline()` 方法从文件中返回单行（每行以换行符、回车符或两者兼而有之结束，具体取决于创建文件时使用的操作系统）。我们可以反复调用它来获取额外的行。复数形式的
    `readlines()` 方法返回文件中所有行的列表。与 `read()` 方法类似，在处理非常大的文件时使用它并不安全。这两个方法在文件以 `bytes`
    模式打开时也能工作，但这只有在我们要解析具有合理位置换行符的类似文本数据时才有意义。例如，图像或音频文件中不会有换行符（除非换行字节恰好代表某个像素或声音），因此应用
    `readline()` 就没有意义。'
- en: For readability, and to avoid reading a large file into memory at once, it is
    often better to use a `for` statement to consume lines from a file object. For
    text files, it will read each line, one at a time, and we can process it inside
    the `for` statement. For binary files, this will also work, but it's often unlikely
    that the binary file adheres to text file rules. For binary files, it's better
    to read fixed-sized chunks of data using the `read()` method, passing a parameter
    for the maximum number of bytes to read.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，并且避免一次性将大文件读入内存，通常最好使用`for`语句从文件对象中逐行读取。对于文本文件，它会逐行读取，每次一行，我们可以在`for`语句内部进行处理。对于二进制文件，这同样适用，但通常不太可能二进制文件遵循文本文件的规则。对于二进制文件，最好使用`read()`方法读取固定大小的数据块，并传递一个参数来指定要读取的最大字节数。
- en: 'Reading a file might look like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件可能看起来像这样：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Writing to a file is just as easy; the `write()` method on file objects writes
    a string (or bytes, for binary data) object to the file. It can be called repeatedly
    to write multiple strings, one after the other. The `writelines()` method accepts
    a sequence of strings and writes each of the iterated values to the file. The `writelines()` method
    does *not* append a new line after each item in the sequence. It is basically
    a poorly named convenience function to write the contents of a sequence of strings
    without having to explicitly iterate over it using a `for` statement.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 向文件写入同样简单；文件对象的`write()`方法会将一个字符串（或字节，对于二进制数据）对象写入文件。它可以被反复调用以写入多个字符串，一个接一个。`writelines()`方法接受一个字符串序列，并将迭代值中的每个值写入文件。`writelines()`方法在序列中的每个项目后**不会**添加一个新行。它基本上是一个命名不佳的便利函数，用于在不显式使用`for`语句迭代的情况下写入字符串序列的内容。
- en: 'Writing to a file might look like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将内容写入文件可能看起来像这样：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The explicit newline characters, `\n`, are required to create line breaks in
    the file. Only the `print()` function adds newlines automatically. Because the
    `open()` function is built-in, there are no imports required for simple file input
    and output operations.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的换行符 `\n` 是在文件中创建行断点的必需品。只有 `print()` 函数会自动添加换行符。因为 `open()` 函数是内置的，所以进行简单的文件输入输出操作不需要导入。
- en: Lastly, and we do mean lastly, we come to the `close()` method. This method
    should be called when we are finished reading or writing the file, to ensure any
    buffered writes are written to the disk, that the file has been properly cleaned
    up, and that all resources associated with the file are released back to the operating
    system. It's very important to be explicit and clean up after ourselves, especially
    in long-running processes like web servers.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们真的指的是最后，我们来到了`close()`方法。当我们在完成读取或写入文件后，应该调用此方法，以确保任何缓冲的写入都被写入磁盘，文件已经被适当清理，以及所有与文件关联的资源都被释放回操作系统。在像网络服务器这样的长时间运行过程中，明确地清理并处理好自己的事务非常重要。
- en: Each open file is a context manager, usable by the `with` statement. If we use
    files like this, the `close()` happens automatically at the end of the context.
    We'll look closely at using context managers to control the OS resources in the
    next section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 每个打开的文件都是一个上下文管理器，可以通过`with`语句使用。如果我们这样使用文件，`close()`方法将在上下文结束时自动执行。我们将在下一节中详细探讨如何使用上下文管理器来控制操作系统资源。
- en: Placing it in context
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将其置于上下文中
- en: The need to close files when we are finished with them can make our code quite
    ugly. Because an exception may occur at any time during file I/O, we ought to
    wrap all calls to a file in a `try...finally` clause. The file should be closed
    in the `finally` clause, regardless of whether I/O was successful. This isn't
    very Pythonic. Of course, there is a more elegant way to do it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 完成文件操作后关闭文件的需求可能会让我们的代码变得相当丑陋。因为在文件输入输出过程中，任何时刻都可能发生异常，所以我们应当将所有对文件的调用都包裹在`try...finally`语句中。文件应在`finally`语句中关闭，无论输入输出操作是否成功。这并不太符合Python的风格。当然，还有更优雅的方式来处理这个问题。
- en: Python's file objects are also **context managers**. By using the `with` statement,
    the context management methods ensure that the file is closed, even if an exception
    is raised. By using the `with` statement, we no longer have to explicitly manage
    the closing of the file.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的文件对象也是 **上下文管理器**。通过使用 `with` 语句，上下文管理方法确保即使在抛出异常的情况下文件也会被关闭。使用 `with`
    语句后，我们不再需要显式地管理文件的关闭。
- en: 'Here is what a file-oriented `with` statement looks like in practice:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是文件导向的`with`语句在实际中的样子：
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `open` method of a `Path` object returns a file object, which has `__enter__()`
    and `__exit__()` methods. The returned object is assigned to the variable named
    `source_file` by the `as` clause. We know the file will be closed when the code
    returns to the outer indentation level, and that this will happen even if an exception
    is raised. (We'll look at `Path` objects in more detail in *Chapter 9*, *Strings*,
    *Serialization*, *and File Paths*. For now, we'll use them to open our files.)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`对象的`open`方法返回一个文件对象，该对象具有`__enter__()`和`__exit__()`方法。通过`as`子句，返回的对象被分配给名为`source_file`的变量。我们知道当代码返回到外部缩进级别时，文件将被关闭，即使发生异常也是如此。（我们将在*第9章*，*字符串*，*序列化*，*和文件路径*中更详细地了解`Path`对象。现在，我们将使用它们来打开我们的文件。）'
- en: The `with` statement is used widely, often where startup and cleanup code need
    to be connected in spite of anything that might go wrong. For example, the `urlopen` call
    returns a context object that can be used in a `with` statement to clean up the
    socket when we're done. Locks in the `threading` module can automatically release
    the lock after the body of the `with` statement has been executed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 语句被广泛使用，通常在需要将启动和清理代码连接起来，尽管可能会出现任何错误的情况下。例如，`urlopen` 调用返回一个上下文对象，该对象可以在
    `with` 语句中使用来清理套接字，当我们完成时。`threading` 模块中的锁可以在 `with` 语句的主体执行完毕后自动释放锁。'
- en: 'Most interestingly, because any object that has the appropriate special methods
    can be a context manager, used by the `with` statement, we can use it in our own
    frameworks. For example, remember that strings are immutable, but sometimes you
    need to build a string from multiple parts. For efficiency, this is usually done
    by storing the component strings in a list and joining them at the end. Let''s
    extend the list class to create a simple context manager that allows us to construct
    a sequence of characters and automatically convert it to a string upon exit:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的是，由于任何具有适当特殊方法的对象都可以成为上下文管理器，可以被`with`语句使用，我们可以在自己的框架中使用它。例如，记住字符串是不可变的，但有时你需要从多个部分构建一个字符串。为了效率，这通常是通过将组件字符串存储在列表中并在最后将它们连接起来来完成的。让我们扩展列表类来创建一个简单的上下文管理器，它允许我们构建一个字符序列，并在退出时自动将其转换为字符串：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This code adds the two special methods required of a context manager to the `list` class
    it inherits from. The `__enter__()` method performs any required setup code (in
    this case, there isn't any) and then returns the object that will be assigned
    to the variable after `as` in the `with` statement. Often, as we've done here,
    this is the context manager object itself. The `__exit__()` method accepts three
    arguments. In a normal situation, these are all given a value of `None`. However,
    if an exception occurs inside the `with` block, they will be set to values related
    to the type, value, and traceback for the exception. This allows the `__exit__()` method
    to perform any cleanup code that may be required, even if an exception occurred.
    In our example, we create a result string by joining the characters in the string,
    regardless of whether an exception was thrown. In some cases, it may be necessary
    to do more sophisticated cleanup to respond to the exceptional condition.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将上下文管理器所需的两个特殊方法添加到它继承的`list`类中。`__enter__()`方法执行任何所需的设置代码（在这种情况下，没有）然后返回将在`with`语句中的`as`之后分配给变量的对象。通常，就像我们在这里所做的那样，这将是上下文管理器对象本身。`__exit__()`方法接受三个参数。在正常情况下，这些参数都被赋予`None`的值。然而，如果在`with`块内部发生异常，它们将被设置为与异常的类型、值和回溯相关的值。这允许`__exit__()`方法执行可能需要的任何清理代码，即使发生了异常。在我们的例子中，我们通过连接字符串中的字符来创建一个结果字符串，无论是否抛出异常。在某些情况下，可能需要进行更复杂的清理来响应异常情况。
- en: 'Formally, the type hints look like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，类型提示看起来是这样的：
- en: '[PRE63]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that we''ve defined `__exit__()` to always return `False`. A return value
    of `False` makes sure any exception that is raised in the context will be seen.
    This is the typical behavior. We can, however, silence the exceptions raised by
    returning `True`. This means changing the type hint from `Literal[False]` to `bool`
    and – of course – examining the exception details to see if it should be silenced.
    We might, for example, check `exc_type` to see if it is `StopIteration`, like
    this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经定义了`__exit__()`方法始终返回`False`。返回值`False`确保在上下文中抛出的任何异常都会被看到。这是典型行为。然而，我们可以通过返回`True`来静默这些异常。这意味着将类型提示从`Literal[False]`更改为`bool`，并且当然——检查异常细节以确定是否应该静默。例如，我们可以检查`exc_type`以确定它是否为`StopIteration`，如下所示：
- en: '[PRE64]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This will silence only `StopIteration` exceptions, and allow all others to propagate
    outside the context. For a refresher on exceptions, refer back to *Chapter 4*,
    *Expecting the Unexpected*.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅静默`StopIteration`异常，并允许所有其他异常在上下文外部传播。关于异常的复习，请参阅*第4章*，*意料之外*。
- en: 'While this is one of the simplest context managers we could write, and its
    usefulness is dubious, it does work with a `with` statement. Have a look at it
    in action:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是我们能够编写的最简单的上下文管理器之一，并且其有用性值得怀疑，但它确实可以与`with`语句一起工作。看看它是如何运作的吧：
- en: '[PRE65]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This code constructs a string by appending and extending an initial list of
    characters. When the `with` statement finishes the indented statements of the
    context, the `__exit__()` method is called, and the `result` attribute becomes
    available on the `StringJoiner` object, `sj`. We then print this value to see
    the resulting string. Note that the `__exit__()` is always executed, even if there''s
    an exception. The following example raises an exception inside the context, and
    the final result is still built:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码通过追加和扩展初始字符列表来构建一个字符串。当`with`语句完成上下文缩进语句后，会调用`__exit__()`方法，此时`result`属性在`StringJoiner`对象`sj`上变得可用。然后我们打印这个值以查看生成的字符串。请注意，`__exit__()`总是会被执行，即使有异常发生。以下示例在上下文中引发异常，但最终结果仍然会被构建：
- en: '[PRE66]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The division by zero raised an exception. The statement appending this to the
    `sj` variable failed, and the remaining statements within the context aren't executed.
    The context's `__exit__()` method is executed, with details of the exception.
    The `__exit__()` method computed the `result` attribute, and allowed the exception
    to propagate. The `sj` variable has the partial result.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 零除引发了异常。将此异常附加到`sj`变量上的语句失败，并且上下文中的剩余语句没有执行。上下文的`__exit__()`方法被执行，并带有异常的详细信息。`__exit__()`方法计算了`result`属性，并允许异常传播。`sj`变量具有部分结果。
- en: We can also build a context manager from a simple function. This relies on a
    feature of an iterator, something we'll look at deeply in *Chapter 10*, *The Iterator
    Pattern*. For now, it's enough to know that the `yield` statement produces the
    first result of a sequence of results. Because of the way iterators work in Python,
    we can write a function that has the `__enter__()` processing and the `__exit__()`
    processing separated by a single `yield` statement.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从一个简单的函数构建上下文管理器。这依赖于迭代器的一个特性，我们将在第10章“迭代器模式”中深入探讨。目前，只需知道`yield`语句会产生一系列结果中的第一个结果。由于Python中迭代器的工作方式，我们可以编写一个函数，通过单个`yield`语句将`__enter__()`处理和`__exit__()`处理分开。
- en: The example of a string joiner is a stateful context manager, and using a function
    can cleanly separate the state-changing object from the context manager that makes
    the state change.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接器的例子是一个有状态的上下文管理器，使用函数可以干净地分离改变状态的对象和执行状态改变的上下文管理器。
- en: 'Here''s a revised "`string joiner`" object that implements part of the work.
    It contains the strings and also the final result attribute:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个实现了部分功能的修改后的"`字符串连接器`"对象。它包含字符串以及最终的`result`属性：
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Separate from this is a context manager that has some steps for entering the
    context and exiting it:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 与此分开的是，有一个上下文管理器包含了一些进入和退出上下文的步骤：
- en: '[PRE68]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The steps prior to the `yield` are performed on entry into the context. The
    expression in the `yield` statement is assigned to the `as` variable in the `with`
    statement. When the context finishes normally, the code after the `yield` is processed.
    The `try:` statement's `finally:` clause will make sure that the final result
    attribute is always set, irrespective of the presence of an exception. Since the
    `try:` statement doesn't explicitly match any exceptions, it doesn't silence anything,
    and the exception will be visible outside the enclosing `with` statement. This
    behaves identically to the `StringJoiner` examples above; the only change is to
    replace `StringJoiner` – a class that is a context manager – with `joiner`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入上下文之前执行`yield`之前的步骤。`yield`语句中的表达式被分配给`with`语句中的`as`变量。当上下文正常结束时，处理`yield`之后的代码。`try:`语句的`finally:`子句将确保最终结果属性始终被设置，无论是否存在异常。由于`try:`语句没有显式匹配任何异常，它不会静默任何内容，异常将在包含的`with`语句外部可见。这和上面的`StringJoiner`示例行为相同；唯一的改变是将`StringJoiner`——一个上下文管理器类——替换为`joiner`。
- en: The `@contextmanager` decorator is used to add some features around this function
    to make it work like a context manager class definition. This saves us from the
    overhead of a class that defines both `__enter__()` and `__exit__()` methods.
    In this case, the context management involves so few lines of code that a decorated
    function seems more appropriate than a longer and more complex-looking class.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`@contextmanager` 装饰器用于在函数周围添加一些功能，使其工作起来像是一个上下文管理器类的定义。这使我们免去了定义同时包含 `__enter__()`
    和 `__exit__()` 方法的类的开销。在这种情况下，上下文管理涉及到的代码行数如此之少，以至于装饰过的函数似乎比一个更长且看起来更复杂的类更合适。'
- en: Context managers can do many things. The reason why we cover them adjacent to
    simple file operations is because one of the important places we can use context
    managers is when opening files, databases, or network connections. Any place where
    external, operating system-managed resources are involved, we need a context manager
    to be sure that the external resources are properly released no matter what goes
    wrong in our application programming.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器可以执行许多操作。我们之所以将它们与简单的文件操作放在一起介绍，是因为我们可以使用上下文管理器的一个重要场景就是在打开文件、数据库或网络连接时。任何涉及到外部、操作系统管理的资源的地方，我们都需要上下文管理器来确保无论我们的应用程序编程中发生什么错误，外部资源都能得到适当的释放。
- en: Any time we're working with a file, always wrap the processing in a `with` statement.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们处理文件时，总是将处理过程包裹在`with`语句中。
- en: Case study
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: While object-oriented programming is helpful for encapsulating features, it's
    not the only way to create flexible, expressive, and succinct application programs.
    Functional programming emphasizes functional design and function composition over
    object-oriented design.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然面向对象编程有助于封装特性，但这并非创建灵活、表达性强和简洁的应用程序的唯一途径。函数式编程强调功能设计和函数组合，而非面向对象设计。
- en: 'In Python, functional design often involves using a few object-oriented techniques.
    This is one of the beauties of Python: being able to choose an appropriate set
    of design tools to address the problem effectively.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数式设计通常涉及使用一些面向对象的技术。这是Python的一个优点：能够选择一组适当的设计工具来有效地解决问题。
- en: We often depict object-oriented designs with the classes and their various associations.
    For functional design, we're interested in functions to transform objects. A functional
    design can follow mathematical practices closely.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常用类及其各种关联来描述面向对象的设计。对于函数式设计，我们关注的是用于转换对象的函数。函数式设计可以紧密遵循数学实践。
- en: In this part of the case study, we'll revisit a number of features of the classifier
    as functions mixed with class definitions. We'll step away from a pure object-oriented
    view and adopt a hybrid view. In particular, we'll look closely at segregating
    data into a training set and a testing set.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究的这一部分，我们将回顾分类器作为与类定义混合的功能的多个特性。我们将从纯面向对象的观点中抽身，采用一种混合视图。特别是，我们将仔细研究将数据分割成训练集和测试集的过程。
- en: Processing overview
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理概述
- en: 'The initial analysis from *Chapter 1*, *Object-Oriented Design*, identified
    three distinct processes for gathering training data, testing the classifier,
    and actually doing classification. The context diagram looked like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 从**第一章**，**面向对象设计**的初步分析中，确定了三个不同的过程用于收集训练数据、测试分类器以及实际进行分类。上下文图看起来是这样的：
- en: '![Diagram  Description automatically generated](img/B17070_08_01.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_08_01.png)'
- en: 'Figure 8.1: Context diagram'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：上下文图
- en: 'We can think of these as separate functions to build some collections of sample
    data:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些视为独立的函数来构建一些样本数据集合：
- en: A function based on the "Provide Training Data" use case would transform source
    data into two collections of samples, a training set and a testing set. We'd like
    to avoid placing items in the testing set that are exact matches for items in
    the training set, creating some constraints on this process. We can think of this
    as a mapping from a `KnownSample` to a `TestingKnownSample` or a `TrainingKnownSample`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于的“提供训练数据”用例的函数会将源数据转换成两个样本集合，一个是训练集，另一个是测试集。我们希望避免将测试集中的项目与训练集中的项目完全匹配，这对此过程产生了一些约束。我们可以将此视为从`已知样本`到`测试已知样本`或`训练已知样本`的映射。
- en: A function based on the "Set Parameters and Test Classifier" use case would
    transform a `Hyperparameter` (the *k* value and the distance algorithm) and the
    testing set of samples into a quality score. We can think of this as a mapping
    from `TestingKnownSample` to a correct or incorrect classification, and a reduction
    to a single value showing the number correct out of the number of tests.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于的“设置参数并测试分类器”用例的函数会将一个`超参数`（即*k*值和距离算法）以及样本测试集转换成一个质量分数。我们可以将这视为从`TestingKnownSample`到正确或错误分类的映射，以及将结果缩减为一个单一值，表示测试中正确分类的数量。
- en: A function based on the "Make Classification Request" use case would transform
    a `Hyperparameter` (the *k* value and the distance algorithm) and a single sample
    into a classification result.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于使用案例“创建分类请求”的函数会将一个`超参数`（即*k*值和距离算法）以及单个样本转换为一个分类结果。
- en: We'll look at each of these functions separately. We can build an alternative
    model for our application using these processing steps to define a functional
    approach.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看这些函数。我们可以使用这些处理步骤来定义一种功能方法，为我们的应用程序构建一个替代模型。
- en: Splitting the data
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割数据
- en: In effect, splitting the data into two subsets can be defined around some filter
    functions. We'll avoid Python for a moment and focus on the conceptual math to
    make sure we have the logic completely correct before diving into code. Conceptually,
    we have a pair of functions, ![](img/B17070_08_002.png) and ![](img/B17070_08_003.png),
    that decide if a sample, ![](img/B17070_08_004.png), is for testing, *e*, or training,
    *r*. These functions are used to partition the samples into two subsets. (If testing
    and training didn't both begin with t, we'd have an easier time finding names.
    It might help to think about ![](img/B17070_08_005.png) for evaluation and testing,
    and ![](img/B17070_08_006.png) for running a real classification.)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，将数据分为两个子集可以通过一些过滤函数来定义。我们暂时避开Python，专注于概念性的数学，以确保在深入代码之前逻辑完全正确。从概念上讲，我们有一对函数，![](img/B17070_08_002.png)
    和 ![](img/B17070_08_003.png)，它们决定一个样本，![](img/B17070_08_004.png)，是用于测试，*e*，还是用于训练，*r*。这些函数用于将样本划分为两个子集。（如果测试和训练都不以t开头，我们可能会更容易找到名字。考虑![](img/B17070_08_005.png)用于评估和测试，以及![](img/B17070_08_006.png)用于运行真正的分类可能会有所帮助。）
- en: 'It''s simpler if these two functions are exclusive, ![](img/B17070_08_007.png).
    (We''ll use ¬ instead of the longer `not`.) If they are proper inverses of each
    other, this means we only need to define one of the two functions:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个函数是互斥的，那就更简单了，![](img/B17070_08_007.png)。（我们将使用 ¬ 而不是较长的 `not`。）如果它们是彼此的适当逆函数，这意味着我们只需要定义这两个函数中的任意一个：
- en: '![](img/B17070_08_008.png)![](img/B17070_08_009.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/B17070_08_008.png)![图片2](img/B17070_08_009.png)'
- en: If the above syntax is unfamiliar, it just means that the training set is all
    items, ![](img/B17070_08_010.png), from the source data, *S*, where ![](img/B17070_08_011.png)
    is true. The testing set is all the items from the source where ![](img/B17070_08_012.png)
    is false. This mathematical formalism can help make sure all the cases are properly
    covered.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述语法不熟悉，它仅仅意味着训练集是来自源数据 *S* 中的所有项目，![](img/B17070_08_010.png)，其中 ![](img/B17070_08_011.png)
    为真。测试集是来自源数据中 ![](img/B17070_08_012.png) 为假的所有项目。这种数学形式化可以帮助确保所有情况都得到适当的覆盖。
- en: 'This concept is a kind of "comprehension" or "builder" for a set of samples.
    We can translate the mathematical comprehension into a Python list comprehension
    in a fairly direct way. We''ll implement our conceptual function ![](img/B17070_08_013.png)
    as a Python function, `training()`. We''ll also expose the index value, *i*, as
    a separate parameter to this function:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念是一组样本的“理解”或“构建者”。我们可以相当直接地将数学理解转化为Python列表理解。我们将我们的概念函数 ![](img/B17070_08_013.png)
    实现为Python函数，`training()`。我们还将索引值，*i*，作为单独的参数暴露给这个函数：
- en: '[PRE69]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In *Chapter 10*, *The Iterator Pattern*, we''ll dive into this deeply. For
    now, it''s enough to see that the comprehensions have three parts: an expression,
    a `for` clause, and an `if` condition. The `for` clause provides the values, in
    effect the ![](img/B17070_08_014.png) portion of the formal statement. The `if` condition
    filters the values, in effect the ![](img/B17070_08_015.png) clause. The final
    expression, `s`, determines what is accumulated into the resulting list object.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第10章*，*迭代器模式*中，我们将深入探讨这一点。目前，只需了解理解有三个部分：一个表达式，一个`for`子句和一个`if`条件。`for`子句提供值，实际上就是形式语句中的![](img/B17070_08_014.png)部分。`if`条件过滤值，实际上就是![](img/B17070_08_015.png)子句。最后的表达式`s`决定了什么被积累到结果列表对象中。
- en: We've composed a `TrainingKnownSample` object as a wrapper around the source
    `KnownSample` instances. This leverages the composition-based design from *Chapter
    7*, *Python Data Structures*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个`TrainingKnownSample`对象，作为源`KnownSample`实例的包装器。这利用了来自*第7章*，*Python数据结构*中的基于组合的设计。
- en: We can use the index value to partition the data. The remainder after division,
    the modulo, can be used to break data into subsets. The value of `i % 5`, for
    example, is a value from 0 to 4\. If we use `i % 5 == 0` as test data, 20% of
    the values will be selected. When `i % 5 != 0`, this is the remaining 80% of the
    data that will be used for training.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用索引值来划分数据。除法后的余数，即模数，可以用来将数据分成子集。例如，`i % 5`的值是一个从0到4的值。如果我们使用`i % 5 ==
    0`作为测试数据，将有20%的值被选中。当`i % 5 != 0`时，这是剩余的80%数据，将用于训练。
- en: 'The following is a list comprehension without the `[]` wrapper. We''ve used
    the `list()` function to consume items from the generator and build a list:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个不带`[]`包装器的列表推导。我们使用了`list()`函数来从生成器中消费项目并构建列表：
- en: '[PRE70]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The processing with `[]` or `list()` is the same. Some folks like the clarity
    of `list()`, even though it's wordier than `[]`. If we create our own extension
    to the list class, it's slightly simpler to find `list(...)` than to find all
    the places where `[...]` is used and separate out the list builders from other
    uses of `[]`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[]` 或 `list()` 的处理方式相同。有些人喜欢 `list()` 的清晰度，尽管它比 `[]` 更啰嗦。如果我们为列表类创建自己的扩展，那么找到
    `list(...)` 比找到所有使用 `[...]` 的地方并区分列表构建器和其他 `[]` 的用法要简单一些。
- en: Rethinking classification
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新思考分类
- en: In *Chapter 2*, *Objects in Python*, we wrestled with a number of ways of handling
    the state change that goes with classification. There are two similar processes,
    one for `KnownSample` objects that will be used for testing, and one for `UnknownSample`
    objects being classified by users. The process diagrams are simple-looking but
    conceal an important question.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第二章*，*Python中的对象* 中，我们探讨了处理与分类相关的状态变化的各种方法。这里有两个类似的过程，一个用于测试的 `KnownSample`
    对象，另一个由用户进行分类的 `UnknownSample` 对象。流程图看起来很简单，但隐藏着一个重要的问题。
- en: 'Here''s the user''s classification of an unknown sample:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户对未知样本的分类：
- en: '![Diagram, schematic  Description automatically generated](img/B17070_08_02.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图表，示意图 描述自动生成](img/B17070_08_02.png)'
- en: 'Figure 8.2: UnknownSample classification process diagram'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：未知样本分类流程图
- en: 'We can borrow this (with a few tiny class changes) and use it for testing.
    Here''s an approach to handling classification for test purposes that parallels
    the unknown sample process:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以借鉴这个（进行一些微小的类变化）并用于测试。以下是一个处理测试目的分类的方法，它与未知样本处理过程相类似：
- en: '![Diagram, schematic  Description automatically generated](img/B17070_08_03.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图表，示意图 描述自动生成](img/B17070_08_03.png)'
- en: 'Figure 8.3: TestingKnownSample classification process diagram'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：测试已知样本分类过程图
- en: Ideally, the same code can be used in both cases, reducing the overall complexity
    of the application.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，相同的代码可以在两种情况下使用，从而降低应用程序的整体复杂性。
- en: 'As we consider the different alternatives to the process view, this leads to
    changes in the logical view. Here''s a revised view, thinking of these classes
    as immutable compositions. We''ve included notes to suggest when these objects
    are created during application processing. We''ve highlighted two classes requiring
    careful consideration:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑对流程视图的不同替代方案时，这会导致逻辑视图的变化。这里是一个修订后的视图，将这些类视为不可变组合。我们添加了注释来建议在应用程序处理过程中何时创建这些对象。我们特别强调了两个需要仔细考虑的类：
- en: '![Diagram  Description automatically generated](img/B17070_08_04.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_08_04.png)'
- en: 'Figure 8.4: Revised logical view'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：修订的逻辑视图
- en: 'The `TestingKnownSample` and the `TrainingKnownSample` classes have very minor
    differences. They don''t introduce new attributes or methods. Here are the differences:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestingKnownSample` 和 `TrainingKnownSample` 类之间只有非常小的差异。它们没有引入新的属性或方法。以下是它们的差异：'
- en: '`TrainingKnownSample` instances are never used for classification.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TrainingKnownSample`实例永远不会用于分类。'
- en: '`TestingKnownSample` and `UnknownSample` instances are used for classification
    and testing. We''ll create a `ClassifiedKnownSample` object from a `TestingKnownSample` object
    by repackaging the `KnownSample` instance into a new container. This creates a
    more consistent set of definitions.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestingKnownSample`和`UnknownSample`实例用于分类和测试。我们将通过重新包装`KnownSample`实例到一个新的容器中，从`TestingKnownSample`对象创建一个`ClassifiedKnownSample`对象。这创建了一个更一致的定义集。'
- en: The idea is that the `classifier()` method of the `Hyperparameter` class should
    work with objects of two classes, summarized by the type hint `Union[TestingKnownSample,
    UnknownSample]`. This kind of hint can help us spot application code that uses
    the classes incorrectly.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，`Hyperparameter` 类的 `classifier()` 方法应该与两种类的对象一起工作，通过类型提示 `Union[TestingKnownSample,
    UnknownSample]` 来总结。这种提示可以帮助我们找出使用这些类不正确的应用代码。
- en: This diagram seems to capture the ways in which these objects are used. Having
    these details available can lead to more detailed type hints that can be used
    to clarify our intent.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图似乎捕捉了这些对象的使用方式。拥有这些细节信息可以导致更详细的类型提示，这些提示可以用来阐明我们的意图。
- en: The partition() function
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`partition()` 函数'
- en: 'We can define multiple versions of the `training()` function to divide our
    data into an 80/20, 75/25, or 67/33 split:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义多个版本的`training()`函数，将我们的数据分为80/20、75/25或67/33的分割：
- en: '[PRE71]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here''s a function, `partition()`, that takes one of the `training_xx()` functions
    as an argument. The `training_xx()` function is applied to a sample to decide
    if it''s training data or not:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个函数，`partition()`，它接受一个`training_xx()`函数作为参数。`training_xx()`函数被应用于一个样本，以决定它是否是训练数据：
- en: '[PRE72]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We've built a "higher-order" function that takes another function as an argument
    value. This is a very cool feature of functional programming that is an integral
    part of Python.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个“高阶”函数，它接受另一个函数作为参数值。这是函数式编程的一个非常酷的特性，也是Python的一个核心组成部分。
- en: This `partition()` function builds two lists from a source of data and a function.
    This covers the simple case, where we don't care about introducing values into
    the `testing` list that are duplicates of values in the `training` list.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`partition()`函数从数据源和一个函数中构建两个列表。这涵盖了简单的情况，我们并不关心将`training`列表中的值重复引入到`testing`列表中。
- en: While this is pleasantly succinct and expressive, it has a hidden cost. We'd
    like to avoid examining the data twice. For the small set of known samples in
    this particular problem, the processing is not particularly costly. But we may
    have a generator expression creating the raw data in the first place. Since we
    can only consume a generator once, we'd like to avoid creating multiple copies
    of a large set of data.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很简洁且表达清晰，但它有一个隐藏的成本。我们希望避免对数据进行两次检查。对于这个特定问题中已知的一小部分样本，处理并不特别昂贵。但我们在最初可能有一个生成器表达式来创建原始数据。由于我们只能消费一次生成器，我们希望避免创建大量数据的多份副本。
- en: Also, we'd like to avoid assigning test values that happen to be exact matches
    for training values. This turns into a more complex problem. We'll defer this
    until *Chapter 10*, *The Iterator Pattern*.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望避免分配与训练值恰好匹配的测试值。这变成了一个更复杂的问题。我们将在*第10章*，*迭代器模式*中推迟讨论这个问题。
- en: One-pass partitioning
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单次分区
- en: We can create multiple pools of samples in one pass through the data. There
    are several approaches; we'll show one that has simpler type hints. Again, this
    is a function, not a full class definition. The individual sample instances have
    distinct classes, but this process yields objects of distinct classes, and is
    a better fit for a functional style.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一次数据遍历中创建多个样本池。有几种方法；我们将展示一种具有更简单类型提示的方法。再次强调，这是一个函数，而不是完整的类定义。单个样本实例具有不同的类，但这个过程产生的是不同类的对象，更适合函数式风格。
- en: 'The idea is to create two empty list objects, one for training, the other for
    testing. We can then assign specific type hints to each list, and leverage **mypy** to
    be sure we are using the lists appropriately:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是创建两个空的列表对象，一个用于训练，另一个用于测试。然后我们可以为每个列表分配特定的类型提示，并利用**mypy**来确保我们适当地使用这些列表：
- en: '[PRE73]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this `partition_1()` function, we've used the `rule` function to determine
    if the data will be used for training. We expect one of the `training_xx()` functions
    defined earlier in this case study to be provided as the argument for the `rule` parameter.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `partition_1()` 函数中，我们使用了 `rule` 函数来判断数据是否用于训练。我们期望在当前案例研究中定义的某个 `training_xx()`
    函数作为 `rule` 参数的参数提供。
- en: Based on this output, we can create an appropriate class for each sample instance,
    and then assign the sample to an appropriate list.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此输出，我们可以为每个样本实例创建一个合适的类，然后将样本分配到相应的列表中。
- en: This example doesn't check for duplicates between testing samples and training
    samples. Some data scientists suggest we don't want any test samples that are
    exact matches for training samples; it biases the testing. We can see where that
    needed decision can be inserted between when the `training_use` variable is assigned
    and when the final appends are done to either list. If `training_use` is `False`
    and the item already exists in the training set, this item, too, must be used
    for training.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子没有检查测试样本和训练样本之间的重复项。一些数据科学家建议我们不想有任何与训练样本完全匹配的测试样本；这会偏颇测试结果。我们可以在`training_use`变量分配和最终对列表进行追加操作之间插入所需的决策。如果`training_use`是`False`且项目已存在于训练集中，这个项目也必须用于训练。
- en: 'We can refactor this algorithm slightly by performing the type conversions
    later in the process. This lets us create a dictionary of various "pools" of `KnownSample` objects
    based on the intended usage. So far, we only have two pools – training, where
    a `training_xx()` rule is `True`, and testing:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在处理过程中稍后执行类型转换来稍微重构这个算法。这使我们能够根据预期的使用情况创建一个基于`KnownSample`对象的“池”的字典。到目前为止，我们只有两个池——训练池，其中`training_xx()`规则为`True`，以及测试：
- en: '[PRE74]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `defaultdict` object, `pools`, will map Boolean values to `List[KnownSample]`
    objects. We provided the `list` function to set a default value when a key is
    accessed that did not previously exist. We only anticipate two keys, and this
    could also have been written as `pools: dict[bool, list[KnownSample]] = {True:
    [], False: []}`.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 对象 `pools` 将布尔值映射到 `List[KnownSample]` 对象。我们提供了 `list` 函数来设置当访问一个之前不存在的键时的默认值。我们只预期两个键，这也可以写成
    `pools: dict[bool, list[KnownSample]] = {True: [], False: []}`。'
- en: The partitioning starts by creating a generator function to apply the given `rule` function
    to each sample. The result is a two-tuple; we could write an explicit type hint
    of `tuple[bool, KnownSample]`. This generator expression assigned to the partition
    `variable` is lazy, and doesn't compute anything until the values are consumed
    by the `for` statement.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 分区操作首先通过创建一个生成器函数来将给定的`rule`函数应用于每个样本。结果是两个元素的元组；我们可以写出显式的类型提示`tuple[bool, KnownSample]`。这个分配给分区`变量`的生成器表达式是惰性的，并且直到`for`语句消耗了值之前不会进行任何计算。
- en: The `for` statement consumes values from the generator, appending each sample
    to the appropriate pool. When values are consumed, the generator function is evaluated,
    producing a stream of two-tuples with the pool, a Boolean value, and the `KnownSample` instance.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句从生成器中消耗值，将每个样本追加到适当的池中。当值被消耗时，生成器函数将被评估，生成包含池、布尔值和`KnownSample`实例的两个元组的流。'
- en: Once the `KnownSample` objects have been partitioned, we can wrap them up as
    instances of the `TrainingKnownSample` class or the `TestingKnownSample` class.
    The type hints seem simpler in this example than in the previous version.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`KnownSample`对象被分区，我们可以将它们封装为`TrainingKnownSample`类或`TestingKnownSample`类的实例。在这个例子中，类型提示似乎比上一个版本更简单。
- en: This doesn't actually create two copies of the data. References to the `KnownSample`
    objects are collected into a dictionary. From these, the two lists of `TrainingKnownSample`
    and `TestingKnownSample` objects are created. Each of the derived objects contains
    a reference to the original `KnownSample` object. The structure of the temporary
    dictionary represents some memory overhead, but overall, we've avoided duplicating
    data, reducing the memory required by this application.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不会创建数据的两个副本。对`KnownSample`对象的引用被收集到一个字典中。从这些引用中，创建了两个`TrainingKnownSample`和`TestingKnownSample`对象的列表。每个派生对象都包含对原始`KnownSample`对象的引用。临时字典的结构代表了一些内存开销，但总体来说，我们已经避免了数据的重复，从而减少了该应用程序所需的内存。
- en: This example suffers from a complication. It's not perfectly clear how to prevent
    creating test samples that are exact matches for training samples. An additional
    `if` statement inside the `for` statement could check for an item with `usage_pool` of
    `False` (in other words, a testing item) that also existed in `pools[True]` (in
    other words, the training items). This is quite a bit of extra complexity.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子存在一个复杂问题。并不完全清楚如何防止创建与训练样本完全匹配的测试样本。在`for`循环内部添加一个额外的`if`语句可以检查是否存在`usage_pool`为`False`（换句话说，一个测试项）且同时存在于`pools[True]`（换句话说，训练项）中的项。这增加了很多额外的复杂性。
- en: Rather than add the additional steps here, we'll wait for *Chapter 10*, *The
    Iterator Pattern*, and revise the algorithm to handle duplicate removal that avoids
    too many special cases or extra `if` statements.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里添加额外的步骤，而是等待到第10章，即《迭代器模式》，然后修改算法以处理避免过多特殊情况或额外`if`语句的重复项删除。
- en: In the case study for *Chapter 5*, *When to Use Object-Oriented Programming*,
    we used `with` statements and the `csv` module to load the raw sample data. In
    that chapter, we defined a `SampleReader` class. It's important to review the
    older definition with these newer partitioning functions to create an integrated
    whole that can properly read and partition the source of sample data.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章的案例研究中，即*何时使用面向对象编程*，我们使用了`with`语句和`csv`模块来加载原始样本数据。在该章中，我们定义了一个`SampleReader`类。重要的是要回顾旧的定义，并使用这些新的分区函数来创建一个可以正确读取和分区样本数据源的完整整体。
- en: Recall
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆
- en: 'We''ve touched on a number of ways that object-oriented and functional programming
    techniques are part of Python:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了多种方式，说明面向对象和函数式编程技术在Python中的应用：
- en: Python built-in functions provide access to special methods that can be implemented
    by a wide variety of classes. Almost all classes, most of them utterly unrelated,
    provide an implementation for `__str__( )` and `__repr__()` methods, which can
    be used by the built-in `str()` and `repr()` functions. There are many functions
    like this where a function is provided to access implementations that cut across
    class boundaries.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 内置函数提供了访问特殊方法的能力，这些方法可以被各种类实现。几乎所有的类，其中大多数完全无关，都提供了对 `__str__( )` 和 `__repr__()`
    方法的实现，这些方法可以被内置的 `str()` 和 `repr()` 函数使用。有许多这样的函数，其中提供了一个函数来访问跨越类边界的实现。
- en: Some object-oriented languages rely on "method overloading" – a single name
    can have multiple implementations with different combinations of parameters. Python
    provides an alternative, where one method name can have optional, mandatory, position-only,
    and keyword-only parameters. This provides tremendous flexibility.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些面向对象的语言依赖于“方法重载”——一个单一的名字可以有多个实现，这些实现通过不同的参数组合来区分。Python提供了一种替代方案，其中一个方法名可以包含可选的、必填的、仅位置参数和仅关键字参数。这提供了极大的灵活性。
- en: Functions are objects and can be used in ways that other objects are used. We can
    provide them as argument values; we can return them from functions. A function
    has attributes, also.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是对象，可以像其他对象一样使用。我们可以将它们作为参数值提供；我们也可以从函数中返回它们。函数也有属性。
- en: File I/O leads us to look closely at how we interact with external objects.
    Files are always composed of bytes. Python will convert the bytes to text for
    us. The most common encoding, UTF-8, is the default, but we can specify other
    encodings.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件输入输出让我们仔细思考我们如何与外部对象交互。文件始终由字节组成。Python 会为我们将字节转换为文本。最常见的编码，UTF-8，是默认的，但我们也可以指定其他编码。
- en: Context managers are a way to be sure that the operating system entanglements
    are correctly cleaned up even when there's an exception raised. The use goes beyond
    simply handling files and network connections, however. Anywhere we have a clear
    context where we want consistent processing on entry or exit, we have a place
    where a context manager can be useful.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文管理器是一种确保即使在发生异常时，操作系统纠缠也能正确清理的方法。然而，其用途并不仅限于简单地处理文件和网络连接。在任何我们有明确上下文，希望在进入或退出时进行一致处理的地方，都是一个上下文管理器可以发挥作用的地方。
- en: Exercises
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you haven't encountered `with` statements and context managers before, I
    encourage you, as usual, to go through your old code, find all the places where
    you were opening files, and make sure they are safely closed using the `with` statement.
    Look for places to write your own context managers as well. Ugly or repetitive `try...finally` clauses
    are a good place to start, but you may find them useful any time you need to do
    before and/or after tasks in context.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有遇到过`with`语句和上下文管理器，我鼓励你，像往常一样，回顾一下你的旧代码，找到所有你打开文件的地方，并确保它们使用`with`语句安全关闭。同时，也要寻找可以编写你自己的上下文管理器的地方。丑陋或重复的`try...finally`语句是一个很好的起点，但你会发现它们在任何需要执行上下文中的前后任务时都很有用。
- en: You've probably used many of the basic built-in functions before now. We covered
    several of them, but didn't go into a great deal of detail. Play with `enumerate`, `zip`, `reversed`, `any`,
    and `all` until you know you'll remember to use them when they are the right tool
    for the job. The `enumerate` function is especially important because not using
    it results in some pretty ugly `while` loops.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前已经使用过许多基本的内置函数。我们介绍了几种，但并没有深入细节。多尝试使用`enumerate`、`zip`、`reversed`、`any`和`all`，直到你确信自己会在需要时记得使用它们。`enumerate`函数尤其重要，因为不使用它会导致一些相当丑陋的`while`循环。
- en: Also explore some applications that pass functions around as callable objects,
    as well as using the `__call__()` method to make your own objects callable. You
    can get the same effect by attaching attributes to functions or by creating a `__call__()` method
    on an object. In which case would you use one syntax, and when would it be more
    suitable to use the other?
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以探索一些将函数作为可调用对象传递的应用，以及使用`__call__()`方法使自己的对象可调用。你可以通过给函数附加属性或在一个对象上创建`__call__()`方法来达到相同的效果。在什么情况下你会使用一种语法，而何时又更合适使用另一种语法呢？
- en: The relationship between arguments, keyword arguments, variable arguments, and
    variable keyword arguments can be a bit confusing. We saw how painfully they can
    interact when we covered multiple inheritance. Devise some other examples to see
    how they can work well together, as well as to understand when they don't.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 参数、关键字参数、可变参数和可变关键字参数之间的关系可能会有些令人困惑。当我们讨论多重继承时，我们看到了它们是如何痛苦地相互作用的。设计一些其他例子来看看它们如何协同工作，以及了解它们何时不能协同工作。
- en: The `Options` example for using `**kwargs` has a potential problem. The `update()`
    method inherited from the `dict` class will add or replace keys. What if we only
    want to replace key values? We'd have to write our own version of `update()` that
    will update existing keys and raise a `ValueError` exception when a new key is
    provided
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `**kwargs` 的 `Options` 示例存在一个潜在问题。从 `dict` 类继承的 `update()` 方法会添加或替换键。如果我们只想替换键值呢？我们就必须编写自己的
    `update()` 版本，该版本将更新现有键，并在提供新键时引发 `ValueError` 异常。
- en: The `name_or_number()` function example has a blatant bug. It is not completely
    correct. For a number 15, it will not report both "fizz" and "buzz". Fix the `name_or_number()`
    function to collect all the names of all the true functions. A good exercise.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_or_number()` 函数示例存在一个明显的错误。它并不完全正确。对于数字15，它不会同时报告“fizz”和“buzz”。修复 `name_or_number()`
    函数以收集所有真实函数的所有名称。这是一个很好的练习。'
- en: The `name_or_number()` function example has two test functions, `fizz()`, and
    `buzz()`. We need an additional function, `bazz()`, to be true for multiples of
    seven. Write the function and be sure it works with the `name_or_number()` function.
    Be sure that the number 105 is handled correctly.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_or_number()` 函数示例有两个测试函数，`fizz()` 和 `buzz()`。我们需要一个额外的函数 `bazz()` 来处理七的倍数。编写这个函数，并确保它与
    `name_or_number()` 函数一起正常工作。确保数字 105 被正确处理。'
- en: It's helpful to review the previous case studies and combine them into a more
    complete application. The chapter case studies tend to focus on details, avoiding
    the overall integration of a more complete application. We've left the integration
    as work for the reader to allow them to dig more deeply into the design.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 复习之前的案例研究并将它们结合成一个更完整的应用是有帮助的。章节案例研究往往关注细节，避免对更完整应用的总体整合。我们将整合工作留给读者，以便他们能更深入地研究设计。
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a grab bag of topics in this chapter. Each represented an important
    non-object-oriented feature that is popular in Python. Just because we can use
    object-oriented principles does not always mean we should!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了各种主题。每个主题都代表了一个在Python中流行的、重要的非面向对象特性。仅仅因为我们可以使用面向对象的原则，并不意味着我们总是应该这样做！
- en: However, we also saw that Python typically implements such features by providing
    a syntax shortcut to traditional object-oriented syntax. Knowing the object-oriented
    principles underlying these tools allows us to use them more effectively in our
    own classes.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也看到Python通常通过提供传统面向对象语法的语法捷径来实现这些功能。了解这些工具背后的面向对象原则使我们能够更有效地在我们自己的类中使用它们。
- en: We discussed a series of built-in functions and file I/O operations. There are
    a whole bunch of different syntaxes available to us when calling functions with
    arguments, keyword arguments, and variable argument lists. Context managers are
    useful for the common pattern of sandwiching a piece of code between two method
    calls. Even functions are objects, and, conversely, any normal object can be made
    callable.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一系列内置函数和文件输入输出操作。当我们使用参数、关键字参数和可变参数列表调用函数时，我们有大量的不同语法可供选择。上下文管理器对于在两个方法调用之间嵌入一段代码的常见模式非常有用。即使函数也是对象，反之，任何普通对象也可以被设置为可调用的。
- en: 'In the next chapter, we''ll learn more about string and file manipulation,
    and even spend some time with one of the least object-oriented topics in the standard
    library: regular expressions.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于字符串和文件操作的知识，甚至还会花一些时间探讨标准库中最不面向对象的主题之一：正则表达式。
