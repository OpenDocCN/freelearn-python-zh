<html><head></head><body>
<div><div><h1 id="_idParaDest-42"><em class="italic"><a id="_idTextAnchor044"/>Chapter 3</em>: Understanding Decorators and their Applications</h1>
<p>From this chapter onwards, we will start looking at various concepts that are part of metaprogramming along with examples of how to apply them. We will first take a look at decorators and how decorators can be implemented in Python 3. </p>
<p>Decorators are one<a id="_idIndexMarker111"/> of the metaprogramming concepts that deal with decorating a function without modifying the actual function body. As the name suggests, a decorator adds additional value to a function, a method, or a class by allowing the function to become an argument of another function that <em class="italic">decorates</em> or gives more information on the function, method, or class being decorated. Decorators can be developed on an individual user-defined function or on a method that is defined inside a class, or they can be defined on a class itself too. Understanding decorators will help us to enhance the reusability of functions, methods, and classes by manipulating them externally without impacting the actual implementation.</p>
<p>In the previous chapter, we reviewed the concept of object-oriented programming, which serves as the base for this chapter and the future chapters in this book.</p>
<p>In this chapter, we will be taking a look at the following main topics:</p>
<ul>
<li>Looking into simple function decorators</li>
<li>Exchanging decorators from one function to another</li>
<li>Applying multiple decorators to one function </li>
<li>Exploring class decorators</li>
<li>Getting to know built-in decorators</li>
</ul>
<p>By the end of this chapter, you should be able to create your own decorators, implement user-defined decorators on functions/methods and classes, and reuse built-in decorators.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor045"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter03">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter03</a>.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor046"/>Looking into simple function decorators</h1>
<p>We <a id="_idIndexMarker112"/>will now look at different types of function decorators with an example. We will continue <a id="_idIndexMarker113"/>using the <em class="italic">ABC Megamart</em> example we looked at in the previous chapter. Each user-defined function in Python can perform a different operation. But what if we want different functions to show specific additional information, no matter what the functions perform? We can do this simply by defining another function that decorates any function that is provided as an input. </p>
<p>Let’s take a look at the following steps to understand this better:</p>
<ol>
<li>A function decorator can be defined as follows:<pre>def functiondecorator(inputfunction):  
    def decorator():  
        print("---Decorate function with this line---
          ")  
        return inputfunction()  
    return decorator  </pre></li>
</ol>
<p>This code defines a simple function decorator that takes in any input function as an argument and adds a line above the function result that prints <code>---Decorate function with this line---</code> as the first output line for any input function.</p>
<ol>
<li value="2">This function decorator can be called by a new user-defined function with two different syntaxes. Let us define two simple functions:<pre>def userfunction1():  
    return "A picture is worth a thousand words "  </pre></li>
</ol>
<p>This<a id="_idIndexMarker114"/> function returns the phrase <code>A picture is worth a thousand words</code>. </p>
<ol>
<li value="3">We will be adding one more function that returns a <a id="_idIndexMarker115"/>different phrase: <code>Actions speak louder than words</code>:<pre>def userfunction2():  
    return "Actions speak louder than words"  </pre></li>
<li>In the following step, let us add a function decorator to both the preceding user-defined functions and look at the results:<pre>decoratedfunction1 = functiondecorator(userfunction1)
decoratedfunction2 = functiondecorator(userfunction2)</pre></li>
<li>In the preceding code, we have reassigned the functions by adding a decorator function to them. Executing decorated function 1 results in the following:<pre>decoratedfunction1()  
<strong class="bold">---Decorate function with this line---</strong>
<strong class="bold">'A picture is worth a thousand words'</strong></pre></li>
<li>Similarly, we can also execute decorated function 2:<pre>decoratedfunction2()
<strong class="bold">---Decorate function with this line---</strong>
<strong class="bold">'Actions speak louder than words'</strong></pre></li>
</ol>
<p>Both of the function results added an additional line, <code>---Decorate function with this line---</code>, that was not part of their function definition but was part of the decorator function. These examples show the reusable nature of function decorators. </p>
<ol>
<li value="7">Let us look further into syntax 2, which is the most widely used method of adding decorators to other functions, methods, or classes:<pre>@functiondecorator  
def userfunction1():  
    return "A picture is worth a thousand words"  
@functiondecorator  
def userfunction2():  
    return "Actions speak louder than words"  </pre></li>
</ol>
<p>In the preceding code, while defining the user-defined functions, we added an additional line above the definition of <code>@functiondecorator</code>. This line signifies that we have added a decorator to the function in the definition stage itself. This decorator can be declared once and reused for any relevant function that is newly defined. </p>
<ol>
<li value="8">Executing the <a id="_idIndexMarker116"/>preceding code provides the same results as in the <a id="_idIndexMarker117"/>code execution of examples with syntax 1:<pre>userfunction1()
<strong class="bold">---Decorate function with this line---</strong>
<strong class="bold">'A picture is worth a thousand words'</strong>
userfunction2()
<strong class="bold">---Decorate function with this line---</strong>
<strong class="bold">'A picture is worth a thousand words'</strong></pre></li>
</ol>
<p>Now that you understand simple function decorators, we can look into an example that demonstrates its applications.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor047"/>Understanding function decorators with an application</h2>
<p>We can further look into an example<a id="_idIndexMarker118"/> of function <a id="_idIndexMarker119"/>decorators using a scenario from <em class="italic">ABC Megamart</em>. In this example, we will create a function to add an email signature for a branch manager in a different format for each branch. We will define two functions, <code>manager_albany</code> and <code>manager_manhattan</code>, with different font colors and highlights.</p>
<p>Let’s look at this first piece of code:</p>
<pre class="source-code">def manager_albany(*args):  </pre>
<pre class="source-code">    BLUE = '\033[94m'  </pre>
<pre class="source-code">    BOLD = '\33[5m'  </pre>
<pre class="source-code">    SELECT = '\33[7m'</pre>
<pre class="source-code">    for arg in args:</pre>
<pre class="source-code">        print(BLUE + BOLD + SELECT + str(arg))</pre>
<pre class="source-code">manager_albany('Ron D','ron.d@abcmegamart.com','123 Main Street','Albany','New York', 12084)  </pre>
<p>The preceding code prints<a id="_idIndexMarker120"/> the branch manager’s email <a id="_idIndexMarker121"/>signature with white, bold, and blue highlighted text:</p>
<pre class="source-code"><strong class="bold">Ron D</strong></pre>
<pre class="source-code"><strong class="bold">ron.d@abcmegamart.com</strong></pre>
<pre class="source-code"><strong class="bold">123 Main Street</strong></pre>
<pre class="source-code"><strong class="bold">Albany</strong></pre>
<pre class="source-code"><strong class="bold">New York</strong></pre>
<pre class="source-code"><strong class="bold">12084</strong></pre>
<p>Now let’s take a quick look at this block of code:</p>
<pre class="source-code">def manager_manhattan(*args):</pre>
<pre class="source-code">    GREEN = '\033[92m'</pre>
<pre class="source-code">    SELECT = '\33[7m'</pre>
<pre class="source-code">    for arg in args:</pre>
<pre class="source-code">        print(SELECT + GREEN + str(arg))</pre>
<pre class="source-code">manager_manhattan('John M',  'john.m@abcmegamart.com', '40097 5th Main Street',   'Manhattan', 'New York City',  'New York',  11007)</pre>
<p>This one prints the<a id="_idIndexMarker122"/> branch manager’s email signature with highlighted text:</p>
<pre class="source-code"><strong class="bold">John M</strong></pre>
<pre class="source-code"><strong class="bold">john.m@abcmegamart.com</strong></pre>
<pre class="source-code"><strong class="bold">40097 5th Main Street</strong></pre>
<pre class="source-code"><strong class="bold">Manhattan</strong></pre>
<pre class="source-code"><strong class="bold">New York City</strong></pre>
<pre class="source-code"><strong class="bold">New York</strong></pre>
<pre class="source-code"><strong class="bold">11007</strong></pre>
<p>Now, let us add the name of <a id="_idIndexMarker123"/><em class="italic">ABC Megamart</em> in both the signatures with a yellow highlight and modify the font color of the signature to yellow while keeping the signature highlight colors intact. To do this, we will create a function decorator that takes in the arguments of the preceding functions and add <em class="italic">ABC Megamart</em> with a black font and yellow highlight:</p>
<pre class="source-code">def signature(branch):  </pre>
<pre class="source-code">    def footnote(*args):  </pre>
<pre class="source-code">        LOGO = '\33[43m'  </pre>
<pre class="source-code">        print(LOGO + 'ABC Mega Mart')  </pre>
<pre class="source-code">        return branch(*args)  </pre>
<pre class="source-code">    return footnote  </pre>
<p>The following figure is a representation of how an email signature decorator can be implemented on two different signatures.</p>
<div><div><img alt="Figure 3.1 – Email signature decorator " height="755" src="img/B13426_03_01.jpg" width="715"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Email signature decorator</p>
<p>The <a id="_idIndexMarker124"/>preceding signature decorator adds the name of <a id="_idIndexMarker125"/><em class="italic">ABC Megamart</em> in both the signatures with a yellow highlight and modifies the font color of the signature to yellow while keeping the signature highlight colors intact.</p>
<p>First, let’s add <code>@signature</code> to <code>manager_manhattan</code>: </p>
<pre class="source-code">@signature</pre>
<pre class="source-code">def manager_manhattan(*args):</pre>
<pre class="source-code">    GREEN = '\033[92m'</pre>
<pre class="source-code">    SELECT = '\33[7m'</pre>
<pre class="source-code">    for arg in args:</pre>
<pre class="source-code">        print(SELECT + GREEN + str(arg))</pre>
<pre class="source-code">manager_manhattan('John M',  'john.m@abcmegamart.com', '40097 5th Main Street',   'Manhattan', 'New York City',  'New York',  11007)</pre>
<p>This code returns the following email signature:</p>
<pre class="source-code"><strong class="bold">ABC Mega Mart</strong></pre>
<pre class="source-code"><strong class="bold">John M</strong></pre>
<pre class="source-code"><strong class="bold">john.m@abcmegamart.com</strong></pre>
<pre class="source-code"><strong class="bold">40097 5th Main Street</strong></pre>
<pre class="source-code"><strong class="bold">Manhattan</strong></pre>
<pre class="source-code"><strong class="bold">New York City</strong></pre>
<pre class="source-code"><strong class="bold">New York</strong></pre>
<pre class="source-code"><strong class="bold">11007</strong></pre>
<p>Now let’s add <code>@signature</code> to <code>manager_albany</code>:</p>
<pre class="source-code">@signature</pre>
<pre class="source-code">def manager_albany(*args):  </pre>
<pre class="source-code">    BLUE = '\033[94m'  </pre>
<pre class="source-code">    BOLD = '\33[5m'  </pre>
<pre class="source-code">    SELECT = '\33[7m'</pre>
<pre class="source-code">    for arg in args:</pre>
<pre class="source-code">        print(BLUE + BOLD + SELECT + str(arg))</pre>
<pre class="source-code">manager_albany('Ron D','ron.d@abcmegamart.com','123 Main Street','Albany','New York', 12084)  </pre>
<p>Doing so<a id="_idIndexMarker126"/> returns the<a id="_idIndexMarker127"/> following email signature:</p>
<pre class="source-code"><strong class="bold">ABC Mega Mart</strong></pre>
<pre class="source-code"><strong class="bold">Ron D</strong></pre>
<pre class="source-code"><strong class="bold">ron.d@abcmegamart.com</strong></pre>
<pre class="source-code"><strong class="bold">123 Main Street</strong></pre>
<pre class="source-code"><strong class="bold">Albany</strong></pre>
<pre class="source-code"><strong class="bold">New York</strong></pre>
<pre class="source-code"><strong class="bold">12084</strong></pre>
<p>Adding a <a id="_idIndexMarker128"/>function decorator to different functions in the <a id="_idIndexMarker129"/>preceding code snippets makes them have common functionality – in this case, the <em class="italic">ABC Megamart</em> title with a yellow highlight as a common functionality while keeping the individual branch manager signatures. It’s a simple example of how reusable decorators can be and the nature of adding metadata or additional information to a function while keeping the actual functionality of the function intact.</p>
<p>Now that we understand what function decorators are and how we can use them, let’s look at utilizing decorators for different functions by exchanging them and making them more reusable.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor048"/>Exchanging decorators from one function to another</h1>
<p>We now <a id="_idIndexMarker130"/>have an understanding of what a function decorator is and how a function decorator can be used for more than one function. We will look into further exploring the reusability concept of decorators by creating two different decorators to serve two different purposes and later utilizing them by interchanging the decorators between different functions.</p>
<p>To demonstrate this concept, we will be creating Decorator 1 for function 1 and Decorator 2 for function 2, and then we will be exchanging them from one function to another. Let us create two decorators to decorate two different functions.</p>
<p><strong class="bold">Decorator 1</strong> will be created to convert a date argument that is provided as a holiday date to the function that sets holidays for the Alabama branch of <em class="italic">ABC Megamart</em>.</p>
<p>The following figure is a representation of <strong class="bold">Decorator 1</strong> and its <strong class="bold">Function 1</strong>.</p>
<div><div><img alt="Figure 3.2 – Date converter as a decorator " height="551" src="img/B13426_03_02.jpg" width="811"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Date converter as a decorator</p>
<p>Let’s <a id="_idIndexMarker131"/>take a look at the code we’d be using for our desired example:</p>
<pre class="source-code">def dateconverter(function):  </pre>
<pre class="source-code">    import datetime  </pre>
<pre class="source-code">    def decoratedate(*args):     </pre>
<pre class="source-code">        newargs = []  </pre>
<pre class="source-code">        for arg in args:  </pre>
<pre class="source-code">            if(isinstance(arg,datetime.date)):  </pre>
<pre class="source-code">                arg = arg.weekday(),arg.day,arg.month,</pre>
<pre class="source-code">                  arg.year  </pre>
<pre class="source-code">            newargs.append(arg)  </pre>
<pre class="source-code">        return function(*newargs)  </pre>
<pre class="source-code">    return decoratedate    </pre>
<p>The preceding <code>dateconverter</code> is a decorator function that takes in another function as an argument. To perform this function, we have imported the <code>datetime</code> library that helps us to convert the input date argument into the format of weekday, day of the month, month of the year, and year. This decorator function internally takes in all the arguments passed to the internal function and checks whether any of the function arguments are of the <code>datetime</code> data type, and if it finds a <code>datetime</code> object, it will be converted to display weekday, day of the month, month of the year, and year.</p>
<p>This <a id="_idIndexMarker132"/>decorator also stores the converted format of the <code>datetime</code> object along with the rest of the function arguments in a list and passes the list as an argument to the function that is provided as input to this decorator. Let us now create a function to set a holiday calendar for the Alabama branch and decorate it using this decorator function.</p>
<p><code>*args</code> parameter. The first argument of this function will be set as <code>branch_id</code>, the second argument as <code>holiday_type</code>, the third argument as <code>holiday_name</code>, and the fourth argument as <code>holiday_date</code>. All of these input arguments are converted into a dictionary variable by the function and it returns the dictionary with its key-value pairs denoting each value.</p>
<p>Here is what the code looks like using the details we just discussed:</p>
<pre class="source-code"><strong class="bold">@dateconverter  </strong></pre>
<pre class="source-code">def set_holidays_alabama(*args):  </pre>
<pre class="source-code">    holidaydetails = {}  </pre>
<pre class="source-code">    holidaydetails['branch_id'] = args[0]  </pre>
<pre class="source-code">    holidaydetails['holiday_type'] = args[1]  </pre>
<pre class="source-code">    holidaydetails['holiday_name'] = args[2]  </pre>
<pre class="source-code">    holidaydetails['holiday_date'] = args[3]  </pre>
<pre class="source-code">    return holidaydetails  </pre>
<p>In the preceding code, we have started the function definition by adding the decorator <code>@dateconverter</code>, which takes care of converting the holiday date into the aforementioned format. Let us now call this function by providing the arguments required to create the holiday details dictionary:</p>
<pre class="source-code">from datetime import datetime  </pre>
<pre class="source-code">holiday =datetime.strptime('2021-01-18', '%Y-%m-%d')  </pre>
<p>In the preceding code, we have created a <code>datatime</code> object and stored it in a holiday variable that will be passed as one of the inputs to the <code>set_holidays_alabama</code> function:</p>
<pre class="source-code">set_holidays_alabama('id1000',  </pre>
<pre class="source-code">                   'local',  </pre>
<pre class="source-code">                   'Robert E. Lee's Birthday',  </pre>
<pre class="source-code">                   holiday)  </pre>
<p>The <a id="_idIndexMarker133"/>preceding code gives us the following decorated output:</p>
<pre class="source-code"><strong class="bold">{'branch_id': 'id1000',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'holiday_type': 'local',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'holiday_name': 'Robert E. Lee's Birthday',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'holiday_date': (0, 18, 1, 2021)}  </strong></pre>
<p>We can now go ahead and create another decorator that performs a different manipulation on another function that is provided as input.</p>
<p>Let’s now look at <code>id</code> is present in the input that denotes that the input value is an identifier of any kind and returns the numerical value of the identifier by removing its prefix. This decorator will be added to a function to set promotion details for any input product for the Malibu branch.</p>
<p>The following figure is a representation of <strong class="bold">Decorator 2</strong> and <strong class="bold">Function 2</strong>:</p>
<div><div><img alt="Figure 3.3 – ID identifier as a decorator " height="451" src="img/B13426_03_03.jpg" width="678"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – ID identifier as a decorator</p>
<p>Here is the<a id="_idIndexMarker134"/> code we’ll be using for our decorator:</p>
<pre class="source-code">def identifier(function):  </pre>
<pre class="source-code">    def decorateid(*args):     </pre>
<pre class="source-code">        newargs = []  </pre>
<pre class="source-code">        for arg in args:  </pre>
<pre class="source-code">            if(isinstance(arg,str)):  </pre>
<pre class="source-code">                arg = arg.lower()  </pre>
<pre class="source-code">                if 'id' in arg:  </pre>
<pre class="source-code">                    arg = int(''.join(filter(str.isdigit,</pre>
<pre class="source-code">                      arg)))  </pre>
<pre class="source-code">            newargs.append(arg)  </pre>
<pre class="source-code">        return function(*newargs)  </pre>
<pre class="source-code">    return decorateid   </pre>
<p>The preceding identifier is a decorator function that takes in another function as an argument. This decorator function also internally takes in all the arguments passed to its internal function and navigates through each individual argument to check whether it is a string. If the argument is a string, the decorator converts the string into lowercase and checks whether it has a substring ID. If the substring ID is present in the variable, then all strings will be removed from the variable and only digits will be stored in it with the rest of the function arguments in a list, passing the list as an argument to the function that is provided as input to this decorator. Let us now create a function to set promotion details for the Malibu branch and decorate its ID using this decorator function.</p>
<p><code>*args</code> similar to the <code>set_holidays_alabama</code> function. The first argument of this function will be set as <code>branch_id</code>, the second argument as <code>product_id</code>, the third argument as <code>promotion_date</code>, the fourth as <code>promotion_type</code>, and the fifth as <code>promotion_reason</code>. All of these input arguments are also converted into a dictionary variable by the function and it returns the dictionary with its key-value pairs denoting each value. There are two <code>id</code> arguments in this function that get decorated by the identifier.</p>
<p>Here is what the code looks like using the details we just discussed:</p>
<pre class="source-code"><strong class="bold">@identifier</strong><strong class="bold">  </strong></pre>
<pre class="source-code">def set_promotion_malibu(*args):  </pre>
<pre class="source-code">    promotiondetails = {}  </pre>
<pre class="source-code">    promotiondetails['branch_id'] = args[0]  </pre>
<pre class="source-code">    promotiondetails['product_id'] = args[1]  </pre>
<pre class="source-code">    promotiondetails['product_name'] = args[2]  </pre>
<pre class="source-code">    promotiondetails['promotion_date'] = args[3]  </pre>
<pre class="source-code">    promotiondetails['promotion_type'] = args[4]  </pre>
<pre class="source-code">    promotiondetails['promotion_reason'] = args[5]  </pre>
<pre class="source-code">    return promotiondetails  </pre>
<p>In the preceding code, we have started the function definition by adding the decorator <code>@identifier</code>, which takes care of removing the prefixes from the <code>id</code> variable. Let us now call this function by providing the arguments required to create the product promotion details dictionary:</p>
<pre class="source-code">from datetime import datetime  </pre>
<pre class="source-code">promotion_date = datetime.strptime('2020-12-23', '%Y-%m-%d')  </pre>
<p>Here, we have created a <code>datatime</code> object and stored it in a promotion date, which will be passed as one of the inputs to the <code>set_promotion_malibu</code> function, but this date variable will stay in the same format as defined:</p>
<pre class="source-code">set_promotion_malibu('Id23400','ProdID201','PlumCake',promotion_date,'Buy1Get1','Christmas')  </pre>
<p>The preceding code gives us the decorated output that follows:</p>
<pre class="source-code"><strong class="bold">{'branch_id': 23400,  </strong></pre>
<pre class="source-code"><strong class="bold"> 'product_id': 201,  </strong></pre>
<pre class="source-code"><strong class="bold"> 'product_name': 'plumcake',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'promotion_date': datetime.datetime(2020, 12, 23, 0, 0),  </strong></pre>
<pre class="source-code"><strong class="bold"> 'promotion_type': 'buy1get1',</strong><strong class="bold">  </strong></pre>
<pre class="source-code"><strong class="bold"> 'promotion_reason': 'christmas'}  </strong></pre>
<p>We now<a id="_idIndexMarker136"/> have two decorators and two different functions decorated by them. To check whether these decorators can be exchanged, let us now redefine these functions by swapping the decorators using the following code:</p>
<pre class="source-code"><strong class="bold">@identifier  </strong></pre>
<pre class="source-code">def set_holidays_alabama(*args):  </pre>
<pre class="source-code">    holidaydetails = {}  </pre>
<pre class="source-code">    holidaydetails['branch_id'] = args[0]  </pre>
<pre class="source-code">    holidaydetails['holiday_type'] = args[1]  </pre>
<pre class="source-code">    holidaydetails['holiday_name'] = args[2]  </pre>
<pre class="source-code">    holidaydetails['holiday_date'] = args[3]  </pre>
<pre class="source-code">    return holidaydetails  </pre>
<pre class="source-code"><strong class="bold">@dateconverter  </strong></pre>
<pre class="source-code">def set_promotion_malibu(*args):  </pre>
<pre class="source-code">    promotiondetails = {}  </pre>
<pre class="source-code">    promotiondetails['branch_id'] = args[0]  </pre>
<pre class="source-code">    promotiondetails['product_id'] = args[1]  </pre>
<pre class="source-code">    promotiondetails['product_name'] = args[2]  </pre>
<pre class="source-code">    promotiondetails['promotion_date'] = args[3]  </pre>
<pre class="source-code">    promotiondetails['promotion_type'] = args[4]  </pre>
<pre class="source-code">    promotiondetails['promotion_reason'] = args[5]  </pre>
<pre class="source-code">    return promotiondetails  </pre>
<p>Let us input the required arguments and execute the preceding function, <code>set_holidays_alabama</code>:</p>
<pre class="source-code">from datetime import datetime  </pre>
<pre class="source-code">holiday =datetime.strptime('2021-01-18', '%Y-%m-%d')  </pre>
<pre class="source-code">set_holidays_alabama('id1000',  </pre>
<pre class="source-code">                   'local',  </pre>
<pre class="source-code">                   'Robert E. Lee's Birthday',  </pre>
<pre class="source-code">                   holiday)  </pre>
<p>This code <a id="_idIndexMarker137"/>gives us the decorated output as follows:</p>
<pre class="source-code"><strong class="bold">{'branch_id': 1000,  </strong></pre>
<pre class="source-code"><strong class="bold"> 'holiday_type': 'local',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'holiday_name': 'robert</strong><strong class="bold"> e. lee's birthday',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'holiday_date': datetime.datetime(2021, 1, 18, 0, 0)}  </strong></pre>
<p>In the preceding output, the identifier is applied on the branch ID and there is no change to the holiday date. Similarly, let us execute the following code:</p>
<pre class="source-code">promotion_date = datetime.strptime('2020-12-23', '%Y-%m-%d')  </pre>
<pre class="source-code">set_promotion_malibu('Id23400','ProdID201','PlumCake',promotion_date,'Buy1Get1','Christmas')  </pre>
<p>This code gives us the decorated output that follows:</p>
<pre class="source-code"><strong class="bold">{'branch_id': 'Id23400',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'product_id': 'ProdID201',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'product_name': 'PlumCake',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'promotion_date': (2, 23, 12, 2020),  </strong></pre>
<pre class="source-code"><strong class="bold"> 'promotion_type': 'Buy1Get1',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'promotion_reason': 'Christmas'}</strong>  </pre>
<p>The following<a id="_idIndexMarker138"/> figure is a representation of how the two decorators will be exchanged or swapped between their functions:</p>
<div><div><img alt="Figure 3.4 – Exchange decorators " height="697" src="img/B13426_03_04.jpg" width="777"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Exchange decorators</p>
<p>Let us reuse the previous examples to look further into the concept of applying multiple decorators to one function.</p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor049"/>Applying multiple decorators to one function</h1>
<p>So far, we <a id="_idIndexMarker139"/>have understood that decorators can be created and added to functions to perform metaprogramming on the functions. We also understand that decorators can be reused and exchanged for different functions. We have also understood that decorators add decoration or value to a function from outside of the function body and help in altering the function with additional information. What if we want the function to perform two different actions through decorators and at the same time do not want the decorators to become more specific? Can we create two or more different decorators and apply them to a single function? Yes, we can. We will now look at decorating a function with more than one decorator and understand how it works.</p>
<p>For this example, let us reuse the decorators <code>dateconverter</code> and <code>identifier</code>. To understand this concept, we can reuse one of the previously declared functions, <code>set_promotion_malibu</code>, which has both a <code>datetime</code> object as an input argument – promotion date – and two ID values as input arguments – <code>branch_id</code> and <code>product_id</code>.</p>
<p>The following figure is a representation of adding two decorators to a function:</p>
<div><div><img alt="Figure 3.5 – Multiple decorators for one function " height="672" src="img/B13426_03_05.jpg" width="899"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Multiple decorators for one function</p>
<p>The<a id="_idIndexMarker140"/> following code puts our example into action:</p>
<pre class="source-code"><strong class="bold">@identifier  </strong></pre>
<pre class="source-code"><strong class="bold">@dateconverter  </strong></pre>
<pre class="source-code">def set_promotion_malibu(*args):  </pre>
<pre class="source-code">    promotiondetails = {}  </pre>
<pre class="source-code">    promotiondetails['branch_id'] = args[0]  </pre>
<pre class="source-code">    promotiondetails['product_id'] = args[1]  </pre>
<pre class="source-code">    promotiondetails['product_name'] = args[2]  </pre>
<pre class="source-code">    promotiondetails['promotion_date'] = args[3]  </pre>
<pre class="source-code">    promotiondetails['promotion_type'] = args[4]  </pre>
<pre class="source-code">    promotiondetails['promotion_reason'] = args[5]  </pre>
<pre class="source-code">    return promotiondetails  </pre>
<p>In this code, we have added both decorators to the <code>set_promotion_malibu</code> function:</p>
<pre class="source-code">promotion_date = datetime.strptime('2021-01-01', '%Y-%m-%d')  </pre>
<pre class="source-code">set_promotion_malibu('Id23400','ProdID203','Walnut Cake',promotion_date,'Buy3Get1','New Year')  </pre>
<p>Executing <a id="_idIndexMarker141"/>the preceding code results in the application of both decorators on the input values:</p>
<pre class="source-code"><strong class="bold">{'branch_id': 23400,  </strong></pre>
<pre class="source-code"><strong class="bold"> 'product_id': 203,  </strong></pre>
<pre class="source-code"><strong class="bold"> 'product_name': 'walnut cake',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'promotion_date': (4, 1, 1, 2021),  </strong></pre>
<pre class="source-code"><strong class="bold"> 'promotion_type': 'buy3get1',  </strong></pre>
<pre class="source-code"><strong class="bold"> 'promotion_reason': 'new year'}  </strong></pre>
<p>From the preceding output, we can see that <code>@identifier</code> is applied on <code>branch_id</code> and <code>product_id</code>. At the same time, <code>@dateconverter</code> is applied on the <code>promotion_date</code>. Let us now explore other variants of decorators.</p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor050"/>Exploring class decorators</h1>
<p>A <code>__init__</code> and <code>__call__</code>. Any variable initialized as part of the <code>__init__</code> function of a class while creating an object instance of the class becomes a variable of the class itself. Similarly, the <code>__call__</code> function of a class returns a function object. If we want to use a class as a decorator, we need to make use of the combination of these two built-in methods. </p>
<p>Let us look at what happens if we don’t use the <code>call</code> method. Look at the following piece of code:</p>
<pre class="source-code">class classdecorator:  </pre>
<pre class="source-code">    def __init__(self,inputfunction):  </pre>
<pre class="source-code">        self.inputfunction = inputfunction  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def decorator(self):  </pre>
<pre class="source-code">        result = self.inputfunction()  </pre>
<pre class="source-code">        resultdecorator = ' decorated by a class decorator'  </pre>
<pre class="source-code">        return result + resultdecorator  </pre>
<p>Here, we have <a id="_idIndexMarker144"/>created a class named <code>classdecorator</code> and <a id="_idIndexMarker145"/>have added the <code>init</code> method to take a function as input. We have also created a <code>decorator</code> method that stores the result of the initialized function variable and adds a decorator string decorated by a class decorator to the input function result. </p>
<p>Let us now create an input function to test the preceding <code>classdecorator</code>:</p>
<pre class="source-code"><strong class="bold">@classdecorator  </strong></pre>
<pre class="source-code">def inputfunction():  </pre>
<pre class="source-code">    return 'This is input function'  </pre>
<p>Adding this class decorator should decorate the input function. Let us check what happens when we call this input function:</p>
<pre class="source-code">inputfunction()</pre>
<p>We get the following type error, which states <code>classdecorator</code> is not callable:</p>
<div><div><img alt="Figure 3.6 – Error due to an incorrect definition of the class decorator " height="144" src="img/B13426_03_06.jpg" width="731"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Error due to an incorrect definition of the class decorator</p>
<p>We are receiving this<a id="_idIndexMarker146"/> error since we did not use the right method to make the class <a id="_idIndexMarker147"/>behave as a decorator. The <code>decorator</code> method in the preceding code returns a variable but not a function. To make this class work as a decorator, we need to redefine the class as follows:</p>
<pre class="source-code">class classdecorator:  </pre>
<pre class="source-code">    def __init__(self,inputfunction):  </pre>
<pre class="source-code">        self.inputfunction = inputfunction  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def __call__(self):  </pre>
<pre class="source-code">        result = self.inputfunction()  </pre>
<pre class="source-code">        resultdecorator = ' decorated by a class decorator'  </pre>
<pre class="source-code">        return result + resultdecorator  </pre>
<p>Here, we have replaced the <code>decorator</code> method with the built-in method <code>__call__</code>. Let us now redefine the input function and see what happens:</p>
<pre class="source-code"><strong class="bold">@classdecorator  </strong></pre>
<pre class="source-code">def inputfunction():  </pre>
<pre class="source-code">    return 'This is input function'  </pre>
<p>We can call the preceding function and check the behavior of this class decorator:</p>
<pre class="source-code">inputfunction()
<strong class="bold">'This is input function decorated by a class decorator'</strong></pre>
<p>The following figure is a simple representation that shows an incorrect way of creating a class decorator:</p>
<div><div><img alt="Figure 3.7 – Wrong method for creating a class decorator " height="425" src="img/B13426_03_07.jpg" width="690"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Wrong method for creating a class decorator</p>
<p>Here is the<a id="_idIndexMarker148"/> correct way <a id="_idIndexMarker149"/>of creating it:</p>
<div><div><img alt="Figure 3.8 – Correct method for creating a class decorator " height="435" src="img/B13426_03_08.jpg" width="682"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Correct method for creating a class decorator</p>
<p>Now that you have a better understanding of class decorator, we can proceed to analyze the application of class decorator on <em class="italic">ABC Megamart</em>. </p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor051"/>Understanding class decorators with an application</h2>
<p>We will look into a detailed example<a id="_idIndexMarker150"/> of the class decorator by applying it to a scenario on <em class="italic">ABC Megamart</em>. Let us consider a scenario where <em class="italic">ABC Megamart</em> has a separate class created for each branch. Let us also assume each class has its own method, <code>buy_product</code>, to calculate a product’s sales price by specifically applying the sales tax rate for the specific branch and product being purchased. When the mart wants to apply seasonal promotions that involve eight generic promotion types. Each branch class need not have a promotion calculation method to be applied to its calculated sales price. Instead, we can create a class decorator that can be applied to the <code>buy_product</code> method of each branch and the class decorator will, in turn, calculate the final sales price by applying promotion discounts on the actual sales price calculated by the branch.</p>
<p>We will create two classes and add the <code>buy_product</code> method to each class to calculate the sales price without adding a class decorator. This is to understand the return values of the actual methods:</p>
<pre class="source-code">class Alabama():  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def buy_product(self,product,unitprice,quantity,</pre>
<pre class="source-code">      promotion_type):  </pre>
<pre class="source-code">        alabamataxrate = 0.0522  </pre>
<pre class="source-code">        initialprice = unitprice*quantity   </pre>
<pre class="source-code">        salesprice = initialprice + </pre>
<pre class="source-code">          initialprice*alabamataxrate  </pre>
<pre class="source-code">        return salesprice, product,promotion_type  </pre>
<p>Creating an object instance for the previous class and calling the method with its arguments returns the following result:</p>
<pre class="source-code">alb1 = Alabama()    </pre>
<pre class="source-code">alb1.buy_product('Samsung-Refrigerator',200,1,'20%Off')   </pre>
<pre class="source-code"> </pre>
<pre class="source-code"><strong class="bold">(210.44, 'Samsung-Refrigerator', '20%Off')</strong></pre>
<p>Similarly, we can define the class <code>Arizona</code> and add the method <code>buy_product</code> and execute the following code to verify its return value without a decorator:</p>
<pre class="source-code">class Arizona():  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def buy_product(self,product,unitprice,quantity,</pre>
<pre class="source-code">      promotion_type):  </pre>
<pre class="source-code">        arizonataxrate = 0.028  </pre>
<pre class="source-code">        initialprice = unitprice*quantity   </pre>
<pre class="source-code">        salesprice = initialprice + </pre>
<pre class="source-code">          initialprice*arizonataxrate  </pre>
<pre class="source-code">        return salesprice, product,promotion_type  </pre>
<pre class="source-code">arz1 = Arizona()  </pre>
<pre class="source-code">arz1.buy_product('Oreo-Cookies',0.5,250,'Buy2Get1')  </pre>
<pre class="source-code"><strong class="bold">(128.5, 'Oreo-Cookies', 'Buy2Get1')</strong></pre>
<p>The preceding <code>buy_product</code> method<a id="_idIndexMarker151"/> takes in product name, unit price, quantity, and promotion type as input and calculates the initial price by multiplying the unit price by the quantity of a product. It further calculates the sales price by adding the product of the initial price to the state tax rate along with the initial price calculated in the previous step. Finally, the method returns the sales price, product name, and promotion type. The sales tax rates are different for each state and the sales price calculation differs according to the sales tax rates.</p>
<p>We can now create a class decorator to apply a promotional discount on the sales price and calculate the final sales price for a product by including the offer rate or discount rate.</p>
<p>In the following code, let us define the class <code>applypromotion</code> and add two built-in methods required to make the class behave as a decorator: </p>
<ul>
<li>The<strong class="bold"> __init__ method</strong>: This is a function or method as an input variable in this scenario</li>
<li>The<strong class="bold"> __call__ method</strong>: This method accepts multiple input arguments, which are also the arguments of the function or method being decorated </li>
</ul>
<p>The input<a id="_idIndexMarker152"/> arguments are applied to the function or method being decorated and it further applies various discount rates to the sales price resulting from the input function by checking for eight different promotion types, recalculating the sales price, and storing it as the final sales price, as follows:</p>
<pre class="source-code">class applypromotion:  </pre>
<pre class="source-code">    def __init__(self, inputfunction):  </pre>
<pre class="source-code">        self.inputfunction = inputfunction  </pre>
<pre class="source-code">                      </pre>
<pre class="source-code">    def __call__(self,*arg):  </pre>
<pre class="source-code">        salesprice, product,promotion_type = </pre>
<pre class="source-code">          self.inputfunction(arg[0],arg[1],arg[2],arg[3])  </pre>
<pre class="source-code">        if (promotion_type == 'Buy1Get1'):  </pre>
<pre class="source-code">            finalsalesprice = salesprice * 1/2  </pre>
<pre class="source-code">        elif (promotion_type == 'Buy2Get1'):  </pre>
<pre class="source-code">            finalsalesprice = salesprice * 2/3  </pre>
<pre class="source-code">        elif (promotion_type == 'Buy3Get1'):  </pre>
<pre class="source-code">            finalsalesprice = salesprice * 3/4  </pre>
<pre class="source-code">        elif (promotion_type == '20%Off'):  </pre>
<pre class="source-code">            finalsalesprice = salesprice - salesprice * 0.2  </pre>
<pre class="source-code">        elif (promotion_type == '30%Off'):  </pre>
<pre class="source-code">            finalsalesprice = salesprice - salesprice * 0.3  </pre>
<pre class="source-code">        elif (promotion_type == '40%Off'):  </pre>
<pre class="source-code">            finalsalesprice = salesprice - salesprice * 0.4  </pre>
<pre class="source-code">        elif (promotion_type == '50%Off'):  </pre>
<pre class="source-code">            finalsalesprice = salesprice - salesprice * 0.5  </pre>
<pre class="source-code">        else:  </pre>
<pre class="source-code">            finalsalesprice = salesprice   </pre>
<pre class="source-code">        return "Price of - " + product + ": " + '$' + str(finalsalesprice)  </pre>
<p>The<a id="_idIndexMarker153"/> class decorator to <code>@applypromotion</code> is now ready to be further used by other functions or methods. We can now apply this decorator to the <code>buy_product</code> method from the class <code>Alabama</code>:</p>
<pre class="source-code">class Alabama():  </pre>
<pre class="source-code"><strong class="bold">    @applypromotion  </strong></pre>
<pre class="source-code">    def buy_product(product,unitprice,quantity,promotion_type):  </pre>
<pre class="source-code">        alabamataxrate = 0.0522  </pre>
<pre class="source-code">        initialprice = unitprice*quantity   </pre>
<pre class="source-code">        salesprice = initialprice + initialprice*alabamataxrate  </pre>
<pre class="source-code">        return salesprice, product,promotion_type  </pre>
<p>Creating an object instance for the preceding code and calling its method works as follows:</p>
<pre class="source-code">alb = Alabama()  </pre>
<pre class="source-code">alb.buy_product('Samsung-Refrigerator',200,1,'20%Off')  </pre>
<pre class="source-code"><strong class="bold">'Price of - Samsung-Refrigerator: $168.352'</strong></pre>
<p>Similarly, we<a id="_idIndexMarker154"/> can also redefine the class <code>Arizona</code> and its method <code>buy_product</code> by adding the class decorator as follows:</p>
<pre class="source-code">class Arizona():  </pre>
<pre class="source-code"><strong class="bold">    @applypromotion  </strong></pre>
<pre class="source-code">    def buy_product(product,unitprice,quantity,</pre>
<pre class="source-code">      promotion_type):  </pre>
<pre class="source-code">        arizonataxrate = 0.028  </pre>
<pre class="source-code">        initialprice = unitprice*quantity   </pre>
<pre class="source-code">        salesprice = initialprice + </pre>
<pre class="source-code">          initialprice*arizonataxrate  </pre>
<pre class="source-code">        return salesprice, product,promotion_type  </pre>
<p>Creating an object instance for the preceding code and calling its method works as follows:</p>
<pre class="source-code">arz = Arizona()  </pre>
<pre class="source-code">arz.buy_product('Oreo-Cookies',0.5,250,'Buy2Get1')  </pre>
<pre class="source-code"><strong class="bold">'Price of - Oreo-Cookies: $85.66666666666667'</strong></pre>
<p>Let us review the results of <code>buy_product</code> methods from Arizona before adding the decorator and after adding the decorator. The preceding code has the output after adding the decorator and the following code has the output before adding the decorator:</p>
<pre class="source-code">arz1.buy_product('Oreo-Cookies',0.5,250,'Buy2Get1')  </pre>
<pre class="source-code"><strong class="bold">(128.5, 'Oreo-Cookies', 'Buy2Get1')</strong></pre>
<p>After adding the <code>applypromotion</code> decorator, the sales price for 250 packs of cookies is at a discounted rate of $85.66 compared to the price of $128.50 before applying the promotion. The store need not always add a promotion on a product and the <code>buy_product</code> method can reuse the <code>applypromotion</code> decorator only when it needs to sell a product on promotion, thus making the decorator externally alter the behavior of the class while keeping the <code>buy_product</code> method’s actual functionality intact.</p>
<p>The simple <a id="_idIndexMarker155"/>representation of this example is as follows:</p>
<div><div><img alt="Figure 3.9 – Class decorator to apply promotional discounts on products " height="397" src="img/B13426_03_09.jpg" width="492"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Class decorator to apply promotional discounts on products</p>
<p>Having learned how to apply class decorators to methods or functions from other classes, we will proceed further to look at some of the built-in decorators available in Python.</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor052"/>Getting to know built-in decorators</h1>
<p>Now, the <a id="_idIndexMarker156"/>question is, do we have to always<a id="_idIndexMarker157"/> create user-defined or custom decorators to be applied to classes and methods, or do we have some pre-defined decorators that can be used for specific purposes.</p>
<p>In addition to the user-defined decorators that we’ve looked at throughout this chapter, Python has its own built-in decorators, such as <code>@staticmethod</code> and <code>@classmethod</code>, that can be directly applied to methods. These decorators add certain important functionalities to<a id="_idIndexMarker158"/> methods and classes during the process of the<a id="_idIndexMarker159"/> class definition itself. We will be looking at these two decorators in detail, as follows.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor053"/>The static method</h2>
<p>The <code>@staticmethod</code> – is a decorator that takes in a regular Python function as an input argument <a id="_idIndexMarker160"/>and converts it into a static method. Static methods can be created inside a class but will not use the implicit first argument of the class object instance usually denoted as an argument named <code>self</code> like the other instance-based methods. </p>
<p>To understand this concept, let us first create the class <code>Alabama</code> and add a function to the class <code>buy_product</code> without <code>self</code> as an argument and without the static method decorator and check its behavior:</p>
<pre class="source-code">class Alabama:  </pre>
<pre class="source-code">    def buy_product(product,unitprice,quantity,promotion_type):  </pre>
<pre class="source-code">        alabamataxrate = 0.0522  </pre>
<pre class="source-code">        initialprice = unitprice*quantity   </pre>
<pre class="source-code">        salesprice = initialprice + </pre>
<pre class="source-code">          initialprice*alabamataxrate  </pre>
<pre class="source-code">        return salesprice, product,promotion_type  </pre>
<p>Here we have defined the class <code>Alabama</code> with the function <code>buy_product</code>. Let us now create an object instance and call the function inside the class to check its behavior:</p>
<pre class="source-code">alb = Alabama()  </pre>
<pre class="source-code">alb.buy_product('Samsung-Refrigerator',200,1,'20%Off')  </pre>
<p>Executing this code leads to the following error:</p>
<div><div><img alt="Figure 3.10 – Error on calling a function without static method and self " height="135" src="img/B13426_03_10.jpg" width="731"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Error on calling a function without static method and self</p>
<p>Rerunning the preceding <a id="_idIndexMarker161"/>function without creating an object works as follows:</p>
<pre class="source-code">Alabama.buy_product('Samsung-Refrigerator',200,1,'20%Off')  </pre>
<pre class="source-code"><strong class="bold">(210.44, 'Samsung-Refrigerator', '20%Off')</strong></pre>
<p>To avoid the preceding error and to call a function inside a class with or without creating an object, we can convert the function into a static method by adding the <code>@staticmethod</code> decorator to it. We can now look at how it works:</p>
<pre class="source-code">class Alabama:  </pre>
<pre class="source-code"><strong class="bold">    @staticmethod  </strong></pre>
<pre class="source-code">    def buy_product(product,unitprice,quantity,</pre>
<pre class="source-code">      promotion_type):  </pre>
<pre class="source-code">        alabamataxrate = 0.0522  </pre>
<pre class="source-code">        initialprice = unitprice*quantity   </pre>
<pre class="source-code">        salesprice = initialprice + </pre>
<pre class="source-code">          initialprice*alabamataxrate  </pre>
<pre class="source-code">        return salesprice, product,promotion_type  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def another_method(self):  </pre>
<pre class="source-code">        return "This method needs an object"  </pre>
<p>We have added an additional method named <code>another_method</code>, which can only be called using an object instance. Let us now create an object for the class and call both the preceding methods:</p>
<pre class="source-code">albstatic = Alabama()  </pre>
<pre class="source-code">albstatic.buy_product('Samsung-Refrigerator',200,1,'20%Off')  </pre>
<pre class="source-code"><strong class="bold">(210.44, 'Samsung-Refrigerator', '20%Off')  </strong></pre>
<pre class="source-code">  </pre>
<pre class="source-code">albstatic.another_method()  </pre>
<pre class="source-code"><strong class="bold">'This method needs an object'  </strong></pre>
<p>Both the <a id="_idIndexMarker162"/>methods, <code>static</code> and <code>instance</code>, can be called using the object of the class. At the same time, the static method can also be called using the class itself without creating an object:</p>
<pre class="source-code">Alabama.buy_product('Samsung-Refrigerator',200,1,'20%Off')  </pre>
<pre class="source-code"><strong class="bold">(210.44, 'Samsung-Refrigerator', '20%Off')  </strong></pre>
<pre class="source-code">  </pre>
<pre class="source-code">Alabama.another_method()  </pre>
<p>Executing this code leads to the following error:</p>
<div><div><img alt="Figure 3.11 – Error on calling an instance method using its class " height="125" src="img/B13426_03_11.jpg" width="727"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Error on calling an instance method using its class</p>
<p>The static <a id="_idIndexMarker163"/>method generated the expected output when called using its class, while the instance method did not run. This is the advantage of using a static method to convert a function into a method inside a class.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor054"/>The class method</h2>
<p>The <code>@classmethod</code> – is also a<a id="_idIndexMarker164"/> built-in decorator similar to <code>@staticmethod,</code> and this decorator also converts a function into a static method inside a class. <code>@staticmethod</code> does not have an implicit argument of the object to a class whereas <code>@classmethod</code> has an implicit argument, <code>cls</code>, which gets added to the function, while the <code>@classmethod</code> decorator is added to it as seen in the following code block: </p>
<pre class="source-code">class Alabama:  </pre>
<pre class="source-code">    @classmethod  </pre>
<pre class="source-code">    def buy_product(cls,product,unitprice,quantity,</pre>
<pre class="source-code">      promotion_type):  </pre>
<pre class="source-code">        alabamataxrate = 0.0522  </pre>
<pre class="source-code">        initialprice = unitprice*quantity   </pre>
<pre class="source-code">        salesprice = initialprice + </pre>
<pre class="source-code">          initialprice*alabamataxrate  </pre>
<pre class="source-code">        return cls,salesprice, product,promotion_type  </pre>
<p>This function can be called either with or without creating a class instance. We can look at both in the following code:</p>
<pre class="source-code">Alabama.buy_product('Samsung-Refrigerator',200,1,'20%Off')  </pre>
<pre class="source-code"><strong class="bold">(__main__.Alabama, 210.44, 'Samsung-Refrigerator', '20%Off')  </strong></pre>
<pre class="source-code">  </pre>
<pre class="source-code">alb = Alabama()  </pre>
<pre class="source-code">alb.buy_product('Samsung-Refrigerator',200,1,'20%Off')  </pre>
<pre class="source-code"><strong class="bold">(__main__.Alabama, 210.44, 'Samsung-Refrigerator', '20%Off')  </strong></pre>
<p>In the preceding code, we can<a id="_idIndexMarker165"/> see that a function converted by <code>@classmethod</code> into a class method can be called directly using the class or by creating an object of the class.</p>
<p>These are a few of the built-in decorators and there are more such decorators available in Python 3 that can be explored and reused.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor055"/>Summary</h1>
<p>In this chapter, we have learned how to create simple decorators and how to apply decorators with examples. We saw how to exchange decorators from one function to another along with how to add multiple decorators to one function.</p>
<p>We now understand the concept of class decorators and have looked at an example of how to apply them. And finally, we learned how to use some built-in decorators such as <code>@staticmethod</code> and <code>@classmethod</code>.</p>
<p>All of these concepts are part of Python metaprogramming and they are used to change the behavior of a function or a method externally and without impacting the internal functionalities of the function or method.</p>
<p>In the next chapter, we will be looking at the concept of meta classes with different examples.</p>
</div>
<div><div></div>
</div>
</div></body></html>