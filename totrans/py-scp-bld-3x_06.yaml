- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structuring Our Code and Add-Ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The add-ons we have created so far consist of single Python files. That’s ok,
    but to deal with complexity, we can split our code into related modules contained
    in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: Writing modules that interact with each other rather than a single huge file
    makes design and maintenance easier, allowing us to shift our focus to single
    aspects of our task.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of non-code files, such as images and other media, can be another
    reason for adopting a folder structure. This is because sharing one folder is
    more practical than handling the Python script and the data separately.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to code across separate modules of a package
    and blend everything using the import system. The packaged add-on that we are
    going to create will be easier to distribute, read, and maintain, and it will
    be possible to grasp the functionality of its different parts by just looking
    at the filenames.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Python package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and refreshing code and assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading environment variables in your scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Preferences system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Blender and Visual Studio Code in this chapter. The examples created
    in this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6).
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, on Windows, we can use 7-Zip to create compressed archives. 7-Zip
    is a free application that can be downloaded from [https://www.7zip.org](https://www.7zip.org).
  prefs: []
  type: TYPE_NORMAL
- en: Folders, packages, and add-ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that an add-on consists of Python code accompanied by information for
    the Blender plugin system. While single-file Python scripts are called modules,
    a folder of scripts is called a package.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an add-on folder implies that we will store the Blender information
    at the package level, so we will create a directory and create the package information
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a package folder and the init file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a folder for *this chapter* in our Python project. Then, in the
    `ch6` folder as our **Scripts Folder** and restart Blender. To make a package,
    we need to create a new folder rather than a new file. We can do that using the
    file manager or, like in the following steps, use the files bar of our programmer
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `PythonScriptingBlender/ch6/addons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new folder by clicking the **New** **Folder** icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1: Creating folders in Visual Studio Code](img/Figure_6.1_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Creating folders in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: Name the new folder `structured_addon`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A Python package contains a file named `__init__.py`. This is the **entry point**
    of the folder and Python runs it automatically when it imports a package. To create
    it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `…/``ch6/addons/structured_addon` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file by clicking on the **New** **File** icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2: Creating a new file in Visual Studio Code](img/Figure_6.2_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Creating a new file in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: Name the new file `__init__.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file by double-clicking it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When Blender searches for installed add-ons, it will look for the `bl_info`
    dictionary inside the `__init__.py` files of this folder. We will fill in this
    information in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the init file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `bl_info` dictionary contains the usual attributes for add-on discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Providing a `register()` and an `unregister()` function will allow us to enable
    and disable the add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should be able to see our **Structured Add-on** if we restart Blender
    or refresh the add-ons list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Structured Add-on listed in the “Learning” category](img/Figure_6.03_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Structured Add-on listed in the “Learning” category'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to make it useful by adding some content using different `.``py`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for separating modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a trade-off between partitioning and centralizing the code: excessively
    atomized code risks being unclear and hard to maintain. So, even if there are
    no fixed rules about splitting a program, there are general criteria for writing
    modular code:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-Python files such as *media* (images, sounds, and so on) have their subfolders
    according to their types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generic code* used by unrelated classes can be considered a utility module
    and used like a library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Specific code* relevant to a particular functionality should be a specific
    module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*UI* classes, such as panels and menus, can be separated by non-UI code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Operators* can be separated from non-operator code and split per category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Import* statements relevant to only a part of a script might imply that entire
    sections could go to another file, thus reducing the number of imported libraries
    in one file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will put these concepts into practice and see how, starting with an example
    we are familiar with, the package architecture makes our code clearer and more
    effective:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Execution of an add-on folder – __init__.py glues all the parts
    together](img/Figure_6.04_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Execution of an add-on folder – __init__.py glues all the parts
    together'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the structured panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We wrote a user interface in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100),
    that relied on an external `.png` file to display an icon. That makes the tool
    difficult to share because Blender can only install either one `.py` or `.``zip`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can bundle pictures and code together if we structure it all as a folder.
    According to the guidelines summed up earlier, we can create the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A subfolder for the *icon storage* (media files) named `pictures`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module for *icon loading* (generic functionality) named `img_load.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module that contains the *panel* (UI separation) named `panel.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module for add-on *preferences* (specific functionality) named `preferences.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module to *reload* the import system (maintenance utility) named `_refresh_.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will create a folder for storing the image files and
    the code for loading them.
  prefs: []
  type: TYPE_NORMAL
- en: Packing external images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we use image files for our add-on, we can create a folder in the `structured_addon`
    directory and name it `pictures`. Since we are going to write a module for loading
    icons, this folder can contain a collection of image files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ch6\addons\structured_addon\pictures` folder from the examples, we
    have `pack_64.png`, a clipart representing a package, and `smile_64.png`, the
    smiley face from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: The pictures used for this add-on are stored in a folder](img/Figure_6.05_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: The pictures used for this add-on are stored in a folder'
  prefs: []
  type: TYPE_NORMAL
- en: Once all our images are in this folder, we can write the code to load them.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an icon library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), we wrote a function that
    loads a specific image file from disk. That worked great. Now that we are loading
    two icons, we can just use the same routine twice.
  prefs: []
  type: TYPE_NORMAL
- en: But now that we have an entire module for loading images, we can write a more
    sophisticated solution that works for any number of icons since it doesn’t rely
    on hardcoded full paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new loader scans the pictures folder for images. We will make sure that
    loading times are not increased by multiple calls from other modules so that we
    end up with a more flexible, yet still reliable, loader for custom images. Let’s
    create the module’s file, following the same steps as before:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `…/``ch6/addons/structured_addon` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file by clicking the **New** **File** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `img_loader.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file by double-clicking it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This module will handle icon loading for the entire package.
  prefs: []
  type: TYPE_NORMAL
- en: Loading pictures from a folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `img_loader` module scrolls the image files from a folder, so we need to
    import the `os` package to access directories. And of course, `bpy.utils.previews`
    is needed for loading the images from the file and storing them as icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a global variable, a list, to store the Blender previews `Collection`.
    Following the Python naming convention, the variable name is uppercase since it’s
    global. Also, it starts with an underscore because it is not meant to be used
    in any other module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We create the `register_icons()` function to load the icons from disk. It is
    like the `load_custom_icons` function from the first section of [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
  prefs: []
  type: TYPE_NORMAL
- en: 'If `_CUSTOM_ICONS` tests `True` to the `if` condition, the `return` statement
    will exit the function immediately. That prevents it from loading the icons repeatedly
    every time that the module is used. Otherwise, we create a new collection of icons
    via `previews.new()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than hardcoding filenames, we load all the images contained in the `pictures`
    folder. We don’t want to load non-image files, so we store a list of our viable
    image extensions in the `img_extensions` variable. We are only using the `.png`
    and `.jpg` formats in this example but others, such as `.tif`, can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the path to the pictures folder by adding `''pictures''` to the module’s
    path. When dealing with files, path functions from the `os` utilities are preferred
    to string manipulation since they ensure multi-platform compatibility. So, we
    build the `picture_path` variable using the `os.path.join` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `os.listdir` function returns a list of all the filenames contained in
    a directory. We navigate the list with a `for` loop, and at each iteration, we
    separate the filename from the extension using the `os.path.splitext` function.
    Both lower and uppercase extensions are valid, but string comparison is a case-sensitive
    operation. We convert all file extensions into lowercase letters so that `.jpg`
    or `.png` files can be considered. When a file extension is not found in `img_extensions`,
    the file is skipped by the `continue` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Bail out quickly or stick to it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Escaping one loop iteration using `continue`, an entire loop using `break`,
    or a function using `return` before it’s over is a valid technique to interrupt
    a procedure as soon as its conditions are not met. It avoids nesting too many
    `if` statements, but it is recommended to do that only at the beginning of an
    execution: having exit points at seemingly random points in the code makes it
    hard to read.'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.listdir` lists only the filenames and not their full disk paths. To get
    it, we must join `picture_path` and `img_file` together, using `os.path.join`
    again. We use `img_nam`e – that is, the filename without an extension – as the
    keyword for retrieving the icon from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `for` loop is over, we can store the collection in the `_CUSTOM_ICONS`
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using filenames as keywords is convenient as, for instance, `'smile_64'` will
    be the keyword for the `smile_64.png` file, but it can be ambiguous when our folder
    contains files with the same name but different extensions, such as `smile_64.jpg`.
    Our script will assume that the picture folder doesn’t contain pictures with the
    same filenames.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have created the `register_icons()` function, which initializes
    the icon collection. Now, we need to add a function to clean it up when the add-on
    is disabled; otherwise, the leftover thumbnails in our computer’s RAM will interfere
    with subsequent executions.
  prefs: []
  type: TYPE_NORMAL
- en: Unregistering icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the add-on is disabled, we must discharge its icons from our computer’s
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we must define the `unregister_icons` function. In this function,
    we invoke `previews.remove()` and use `_CUSTOM_ICONS` as its argument. We also
    need to make sure that `_CUSTOM_ICONS` is set to `None` at the end of the function;
    otherwise, Python will keep invalid references to deleted icons and cause Blender
    to crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that `img_loader` can load and unload icons, what we need is a getter to
    access `_CUSTOM_ICONS` from the other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python doesn’t forbid access to module members, even if we mark them as *private*
    using a name with leading underscores. So, we could access the `_CUSTOM_ICONS`
    variable by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Still, we can add more control if we use a function to get the loaded icons:'
  prefs: []
  type: TYPE_NORMAL
- en: In the future, we can change `_CUSTOM_ICONS` to a dictionary or list. That would
    have no repercussions for other modules using the data if the function used to
    get them is changed accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes it easy to check that the conditions are met. In this case, our call
    to `register_icons()` makes sure that the icons are registered in case they weren’t
    for some reason. This practice adheres to **defensive programming**, as it aims
    to make the script work even against unforeseen circumstances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It allows us to set *roadblocks* in case some vital condition was not met.
    For instance, we have added an `assert _CUSTOM_ICONS` statement that will cause
    an error if the variable has not been set, despite the recent call to `register_icons()`.
    This is an example of **offensive programming** because it stops the execution
    when something is wrong:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, the picture loader provides a code interface for loading, unloading, and
    getting all the icons from the pictures folder. The main module can import it
    via relative import.
  prefs: []
  type: TYPE_NORMAL
- en: Using relative imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `import` statement looks for modules installed in the Python search path,
    such as the built-in library or, in our case, the Blender API (`bpy`). Trying
    to import a module that is not in the search path halts the script with a `ModuleNotFoundError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For modules that belong to the same package, we use a slightly different syntax
    that gives access to the other modules of the same package: a **relative** import
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: In relative imports, the package is represented with a dot (`.`), and modules
    are imported using the `from . import` `module` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the import section of our `__init__.py` file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The register and unregister functions will invoke the `register_icons()` and
    `unregister_icons()` functions contained in the `img_loader` namespace, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that the entire process of loading images is handled in one module, we can
    write the `.py` file of the *user interface*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how, once we gain access to our icons system
    via a relative import of `img_loader`, we won’t have to worry about loading icon
    files anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already created the `panel.py` module, which will contain all the *user
    interface* classes and functions, so this file is going to contain our panel class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the UI module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start importing the `bpy` module and our collection of icons via a
    relative import of `img_loader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OBJECT_PT_structured` class is derived from `Panel`. Like the one from
    [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), it contains the `bl_*` identifiers
    required by Blender in its static section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, our `draw` function is a few lines of code that display an icon, followed
    by text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must write the functions for registering and unregistering the class
    from this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Providing registration utilities inside the module relieves `__init__.py` from
    concerns about which classes are defined in `panel` and which ones should be registered/unregistered.
    It is like what we did in *Getting the collection* in section 2 of this chapter,
    *Packing* *external images*.
  prefs: []
  type: TYPE_NORMAL
- en: These designs fall under the practice of **encapsulation** – that is, restricting
    direct access to the components of a module or object. Adhering to it is not inherently
    better, but it can help in keeping the code flexible and clean.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside `__init__.py`, we import `panel` from the `.` namespace, and invoke
    its `register_classes()` and `unregister_classes()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `unregister` order is the reverse of the one in the `register`
    function. That is not relevant to the execution of the add-on, and it is followed
    here only for the sake of clarity.
  prefs: []
  type: TYPE_NORMAL
- en: We can test our code by enabling **Structured Panel** in the **Add-ons** list
    from the **Edit** | **Preferences** menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the panel and our new icon in the object section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: panel.py displays an icon via img_loader.py](img/Figure_6.06_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: panel.py displays an icon via img_loader.py'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will add other elements and complete the panel.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the Objects panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A slightly simpler version of the panel displayed in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100),
    uses pretty much the same code. The maximum number of displayed objects is still
    stored in the `max_objects` static member, but it would work better if implemented
    as a preference of the add-on. We will do that in the *Using addon preferences*
    section, a few pages ahead in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draw` function displays a list of the scene objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, reloading the scripts does not reflect the changes in the preceding
    code: only the `__init__.py` file is refreshed on reload. We are going to cover
    explicitly reloading internal modules in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Reloading cached modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a module is imported, Python caches a copy of it for future access. Since
    the `__init__.py` file is the only one to be updated by the **Reload Scripts**
    operator, we are left with two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Close and restart Blender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly call the `reload` function inside `__init__.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter is preferred over restarting the application as it takes less time.
    The `reload` function is part of the `importlib` module.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading via importlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The utilities contained in the `importlib` library interact with the import
    system, and the `reload` function forces the Python interpreter to reload a module
    from disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `img_loader` module has changed and needs to be reloaded, we can use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to make sure that the changes to our add-on `.py` files are always applied,
    we can add these lines of code to `_init_.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Reloading every relative module soon after it is imported will work, but leaving
    `reload` statements in published code impacts performance and is considered bad
    practice. Next, we will learn how to refresh inside a specific module of the add-on.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a refresh module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling `reload` increases the loading time of an add-on and makes the code
    less readable. Many developers add reload calls while they work and remove them
    when they are finished. However, using packages, we can move the refresh logic
    to another module.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we need to create a file in our add-on package and name it `_refresh_.py`.
    This module doesn’t contain any add-on functionality, but it helps while we edit
    our code by ensuring that all modules are reloaded from disk and are up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading the package modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The refresh module makes use of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The `reload` function from the `importlib` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sys` module, which is used by `_refresh_` to reload an instance of itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bpy` module, to access Blender preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the modules contained in the add-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those requirements translate into the following `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The wildcard character, `*`, stands for all the modules contained in the current
    package (`.`). Now, we can write a function that reloads the add-on modules if
    Blender is set for development. We encountered the **Developer Extras** setting
    in the *Useful features for Python* section, at the beginning of [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033).
    They can be found by going to **Edit** | **Preferences** from the top menu bar
    in the **Interface** tab of the **Preferences** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Enabling Developer Extras in the Preferences window](img/Figure_6.07_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Enabling Developer Extras in the Preferences window'
  prefs: []
  type: TYPE_NORMAL
- en: We can assume that when **Developer Extras** is on, we want the **Reload Scripts**
    operator to reload our submodules as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using Developer Extras as a condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to find the full Python path of **Developer Extras** to read its value.
    To do that, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that **Developer Extras** is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, make sure that **User Tooltips** and **Python Tooltips** are enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover your mouse pointer over the **Developer Extras** checkbox or label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leaving your mouse still, without clicking or moving it, displays a tooltip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the API reference, `PreferencesView` is the `view` member of the
    `Preferences` class, which can be found at `bpy.context.preferences`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml](https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '#bpy.types.Preferences.view'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the full path of the **Developer Extras** setting is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `show_developer_ui` is either `True` or `False`. Using it as a
    condition, we exit `reload_modules` if **Developer Extras** is disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a `reload` call for each `.py` file that we want to refresh. The
    first line reloads `_refresh_.py`, looking up the current filename in the system
    dictionary, `sys.modules`. This way, we can update changes in the `_refresh_`
    module itself. So, the full body of the `reload_modules` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enabling `__init__.py`, as that is the only file to be executed when scripts
    are reloaded. We must invoke `_refresh_.reload_modules()` in the import section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `OBJECT_PT_structured`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Our panel source code has been reloaded](img/Figure_6.08_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Our panel source code has been reloaded'
  prefs: []
  type: TYPE_NORMAL
- en: The limitation of three objects can be set in the `max_objects = 3` static member.
    However, there is a better place for hosting our add-on setting. In the next section,
    we are going to implement proper preferences for our add-on.
  prefs: []
  type: TYPE_NORMAL
- en: Using add-on preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides using Blender preferences, we can use `bpy.types.AddonPreferences` to
    display the add-on-specific custom settings under the add-on activation checkbox.
    It’s an interface, just like `bpy.types.Panel`, and we can add settings to its
    layout using its `draw` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bl_idname` attribute of `AddonPreferences` must match the Python name
    of the add-on. The usage of `__name__` for single files and `__package__` for
    folders makes our code easier to maintain: these variables always match the respective
    Python names, so changes in files and folders’ names would have no consequences.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we are using multiple files, we will create `preferences.py` inside the
    folder of our `structured_addon`. It contains the `StructuredPreferences` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must add a `register_classes` and an `unregister_classes` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add `preferences` to the `import` section of `__init__.py`, which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must register the class from the preferences module alongside the
    others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also make sure that the preferences will be reloaded in `_refresh_.py`.
    This is what the `_reload_modules` function will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use **Reload Scripts** now, we will see our preferences beneath the **Add-on**
    checkbox, in the **Add-Ons** list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Add-ons settings displayed in the Preferences window](img/Figure_6.09_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Add-ons settings displayed in the Preferences window'
  prefs: []
  type: TYPE_NORMAL
- en: The preferences show up but are still empty. Next, we are going to add some
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the preferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to replace `OBJECT_PT_structured .max_objects` with a setting. It’s
    an integer number, so we will add an `IntProperty` to the `StructuredPreferences`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that it contains an integer property, `StructuredPreferences` can store
    the maximum displayed objects setting. To display this property to the user, we
    will add it to the layout in the `draw` method. A simple `layout.prop` instruction
    will be enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also use `split` for a nicer appearance. A split layout creates
    a column for each new entry. Adding an empty widget, a `separator`, as the first
    element, creates an indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Reloading the script will display **Max Objects** as an editable setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Max Objects as a Preferences setting](img/Figure_6.10_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Max Objects as a Preferences setting'
  prefs: []
  type: TYPE_NORMAL
- en: 'This value is saved along with the other user preferences, and Blender remembers
    its value when the application is restarted. We aren’t using this setting yet:
    we need to adjust the code in our panel so that we can use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Using add-on preferences in code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python scripts can access the preferences of an add-on using one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `preferences` is repeated at the end. It might seem redundant but
    it makes sense since `bpy.context.preferences.addons` refers to the application
    preferences, not the ones of the single add-on.
  prefs: []
  type: TYPE_NORMAL
- en: '`bpy.context.preferences.addons[ADDON_NAME]` returns the add-on as a Python
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, we will go back to the `OBJECT_PT_structured` class in the
    *user interface’s* `panel.py` module. Since we are going to use the value from
    the preferences, it should not have a `max_objects` static member anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before we iterate the scene objects in the `draw` function, we must get
    our `add_on` and `preferences` from the context. Using `enumerate`, so that we
    can keep count of the objects while they are displayed, we stop the loop when
    the amount stored in `preferences.max_objects` is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This time, we check `max_objects` with a greater or equal (`>=`) comparison
    because, since the enumeration starts from `0`, breaking after `i > max_objects`
    would display one more object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to be clear, using a separate module for the add-on preferences is not
    required – the entirety of the code written in this chapter could have been contained
    in a single, large `.py` file: we are just splitting the code for the sake of
    readability.'
  prefs: []
  type: TYPE_NORMAL
- en: If our add-on contains operators, we can create modules for those as well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators can be grouped into different files according to their purpose. For
    example, transform-related operators such as `ops_transform.py`, while our first
    few operators, `ops_collections.py` file. All those classes would be then registered
    by `__init__.py` and, if needed, added to the add-on interface via relative import.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution is creating one module for all the operators, which can be
    named `operators.py`. In this section, we will create an operators module for
    our add-on.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the operators module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `structured _addon` folder, we will create the `operators.py` module.
    It will contain our operator class: we will reuse the `bpy`, which is ubiquitous
    in Blender script, we will import the `random` module and use `randint` in the
    `add_random_location` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can proceed with the add-on class. It’s the same as in the *Displaying
    buttons* section in the previous chapter – `poll` returns `True` if there are
    selected objects, while `execute` runs `add_random_location`, with the operator’s
    amount and axis as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Like in the case of `panel.py`, we must add functions for registering the module’s
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can import `operators.py` into the other modules of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Registering operator classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use our operator, we must import `operators.py` in `__init__.py`, whose
    `import` section will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can add and remove our operators with `operator.register_class`
    and `operator.unregister_class`. Since operators might be used as buttons, we
    call `operators.register_classes` before `panel.register_classes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will make `operators.py` to be effective when we reload the script, we
    must add `operators` to `_refresh_.reload_modules`.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing operators on reload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thanks to the work we did in the *Reloading cached modules* section, adding
    operators to the refreshed modules is easy: we add `reload(operators)` to the
    `reload_modules` function. The whole `_refresh_.py` file now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The only thing left to do is display the operator button in the panel.
  prefs: []
  type: TYPE_NORMAL
- en: Adding operator buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add the `panel.py`, whose import section will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our panel can access the `TRANSFORM_OT_random_location` class using `operators`
    as a namespace, so we will add a new element to the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon displaying the `F3` **Search Bar** area to look up and run **Reload Scripts**,
    our panel will display the **Add random** **Location** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Modular panel displaying operators via relative import](img/Figure_6.11_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Modular panel displaying operators via relative import'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our add-on is finished. However, we could refine `panel.py` and add the same
    functionalities that we wrote for `VerySimplePanel` in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100),
    namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Color-coded entries for selected/active objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Delete** button with a context-sensitive label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing those is left as an exercise for you. In the next section, we will
    learn how to distribute our add-on folders to other users.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and installing add-ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to install single `.py` add-ons in the *Installing our add-ons*
    section of [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049). To distribute an add-on
    that consists of more files, we must create a `.zip` archive of it. Most of you
    will be familiar with how a `.zip` file is a compressed archive that can contain
    more files or folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blender can install folders from a standard `.zip` archive, but there are two
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The `.zip` file must contain the add-on as a first-level folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the first-level folder must not contain any dot (`.`) as it won’t
    work with Python’s import system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are third-party tools, such as `.zip` files using the file utilities of
    your operating system. In this section, we will learn how to compress an add-on
    folder on **Windows** **OSX**, and **Ubuntu** systems.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up bytecode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the `structured_addon.zip\structured_addon` folder contains a subfolder
    named `__pycache__`, make sure you delete it: you should not distribute the `.pyc`
    files it contains.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .zip file using 7-Zip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**7-Zip** is a free compression utility for Windows. It is very lightweight
    and integrates with the file manager. Here are the steps to use it for packaging
    our add-ons:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install 7-Zip from [https://www.7-zip.org](https://www.7-zip.org).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **File Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory containing the `structured_addon` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `structured_addon` folder to show the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **7-Zip** | **Add** **to “structured_addon.zip”**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `structured_addon.zip` file will be created alongside the original folder.
    If for some reason it is not possible to install 7-Zip or any other compression
    tool, we can still create `.zip` files using Windows File Explorer alone.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .zip file using Windows File Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open **File Explorer**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to a folder where we want to create the add-on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the context menu by right-clicking on the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the right-click menu, select `structured_addon.zip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12: Creating empty .zip files using Windows File Explorer](img/Figure_6.12_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Creating empty .zip files using Windows File Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have created a `.zip` file, but it is empty. Next, we will copy
    our add-on files there:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `ch6\addons\structured_addon` folder to the clipboard by using *Ctrl*
    + *C* or right-clicking and selecting **Copy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the `structured_addon.zip` archive to display its content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the `ch6\addons\structured_addon` folder into the archive via *Ctrl* +
    *V* or right-clicking and selecting **Paste**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a .zip file on Mac using Finder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `structure_addon` folder in **Finder** or left-click without
    releasing the button. A menu will appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Compress “structured_addon”** from the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13: Compressing folders on a Mac computer](img/Figure_6.13_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Compressing folders on a Mac computer'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .zip file using Gnome
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`.zip` file using Gnome:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `structure_addon` folder in the File Browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the **Compress…** option from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the filename and `.zip` extension of the archive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing .zip add-ons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps for installing a compressed add-on are the same as those we learned
    about in the *Expanding Blender by creating a simple add-on* section of [*Chapter
    3*](B18375_03.xhtml#_idTextAnchor049):'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Preferences** window via **Edit** | **Preferences** from the top
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Add-ons** tab in the left column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Install** button at the top right of **Add-ons Preferences**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the file browser, find the `structured_addon.zip` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Install Add-on** button at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we have gone through the complete development and release of our
    structured add-on. A modular approach is important in programming and works for
    relatively simple tools as well. Plus, it makes our scripts more manageable as
    they increase in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to set up a modular architecture for our code
    by splitting it into different files while keeping it coherent and clear. We also
    learned how to load files procedurally and how to write settings for our add-ons.
  prefs: []
  type: TYPE_NORMAL
- en: This approach confers interoperability and generical usefulness to our code
    and, by applying appropriate separation guidelines, eases our task in navigating
    the different parts of our tools.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171), we will learn how to animate
    with Python and change the animation settings with our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can Blender add-ons consist of multiple files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which file of an add-on folder contains the info dictionary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does relative import work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does reloading an add-on refresh all its modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where do we store the settings of an add-on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we show the add-on properties in the preferences?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we distribute multi-file add-ons?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
