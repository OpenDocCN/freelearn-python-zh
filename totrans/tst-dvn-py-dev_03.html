<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Code Smells and Refactoring</h1></div></div></div><p>In the previous chapter, we went through the TDD cycle in a little more detail. In this chapter, we will look at the related concept of code smells and refactoring.</p><p>One of the biggest advantages of following a test-driven development process is that the tests that we write are always around to make sure that we don't break anything. This gives us a safety net to tinker with the code and make sure that it is easy to read, easy to maintain, and well written. Without tests, we always have a nagging doubt about whether we are about to break something, and more often than not we decide to leave things alone. This leads to the code decaying over time, until it is such a mess that no one wants to touch it anymore. The result is that it takes longer to implement new features, not only because the design is a mess, but also because we have to follow it with extensive testing to make sure none of the existing functionality has broken.</p><p>For this reason, it is vital that we do not skip the third step of the TDD cycle: refactoring.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>This code for this chapter starts at the point after the exercise in the previous chapter has been completed. See the <a class="link" href="apa.html" title="Appendix A. Answers to Exercises">Appendix A</a>, <em>Answers to Exercises</em> for the changes done in the exercise, or download the starting point of the code for this chapter from <a class="ulink" href="https://github.com/siddhi/test_driven_python">https://github.com/siddhi/test_driven_python</a>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>A dual crossover moving average</h1></div></div></div><p>In the <a id="id86" class="indexterm"/>previous chapter, we wrote a method to check for an increasing trend. We will take that example forward in this chapter by developing a method to check for a dual crossover moving average.</p><p>A <strong>dual crossover moving average</strong> (<strong>DMAC</strong>) is a simple indicator to show the short-term trend of a stock compared to a long-term trend.</p><p>The following figure shows how the DMAC works:</p><div><img src="img/3125_03_01.jpg" alt="A dual crossover moving average"/></div><p>Consider a <a id="id87" class="indexterm"/>stock, with closing prices as shown above. First, we calculate two moving average trends. The short-term (5-day) moving average is calculated by taking the moving average for a short number of days. The long-term moving average is calculated by taking the moving average for a longer number of days, for example the moving average of the last 10 days.</p><p>When we plot the values of the long- term and short-term moving average graphs, we see that at certain points, the short-term graph crosses from below the long-term to above the long-term graph. This <a id="id88" class="indexterm"/>point represents a <strong>Buy Signal</strong>. At <a id="id89" class="indexterm"/>other points, the short-term crosses from above to below. This point represents a <strong>Sell Signal</strong>. At all other points, nothing should be done.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Implementing the dual crossover moving average</h1></div></div></div><p>What we <a id="id90" class="indexterm"/>are going to do is to implement a method <code class="literal">get_crossover_signal</code> for the <code class="literal">Stock</code> class. The following are the requirements for the method:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The method takes a date as a parameter, and returns if there is any crossover on that date</li><li class="listitem" style="list-style-type: disc">The method should return <code class="literal">1</code> if there is a <strong>Buy Signal</strong> (5-day moving average crosses 10-day moving average from below to above on that date)</li><li class="listitem" style="list-style-type: disc">The method should return –1 if there is a <strong>Sell Signal</strong> (5-day moving average crosses 10-day moving average from above to below on that date)</li><li class="listitem" style="list-style-type: disc">If there is no crossover, then the method returns 0 (<strong>neutral</strong> signal)</li><li class="listitem" style="list-style-type: disc">The method should only take into account the closing price (the last update for the date), and not the opening or intermediate prices for the date</li><li class="listitem" style="list-style-type: disc">If there are no updates for the date, then the method should use the previous closing price</li><li class="listitem" style="list-style-type: disc">If there is not enough data to calculate the long-term moving average (we need closing prices for at least 11 days), then the method should return 0</li></ul></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Identifying code smells</h1></div></div></div><p>The following is <a id="id91" class="indexterm"/>an implementation that passes the tests (for a listing of the test cases, download the code for this chapter from <a class="ulink" href="https://github.com/siddhi/test_driven_python">https://github.com/siddhi/test_driven_python</a>). The implementation uses the <code class="literal">timedelta</code> class from the <code class="literal">datetime</code> module, so you'll have to import it at the top of the file to get it to work.</p><div><pre class="programlisting">    def get_crossover_signal(self, on_date):
        cpl = []
        for i in range(11):
            chk = on_date.date() - timedelta(i)
            for price_event in reversed(self.price_history):
                if price_event.timestamp.date() &gt; chk:
                    pass
                if price_event.timestamp.date() == chk:
                    cpl.insert(0, price_event)
                    break
                if price_event.timestamp.date() &lt; chk:
                    cpl.insert(0, price_event)
                    break

        # Return NEUTRAL signal
        if len(cpl) &lt; 11:
            return 0

        # BUY signal
        if sum([update.price for update in cpl[-11:-1]])/10 \
                &gt; sum([update.price for update in cpl[-6:-1]])/5 \
            and sum([update.price for update in cpl[-10:]])/10 \
                &lt; sum([update.price for update in cpl[-5:]])/5:
                    return 1

        # BUY signal
        if sum([update.price for update in cpl[-11:-1]])/10 \
                &lt; sum([update.price for update in cpl[-6:-1]])/5 \
            and sum([update.price for update in cpl[-10:]])/10 \
                &gt; sum([update.price for update in cpl[-5:]])/5:
                    return -1

        # NEUTRAL signal
        return 0</pre></div><p>While the above<a id="id92" class="indexterm"/> code implements the functionality, it is totally unreadable. This is what happens when the refactoring step is skipped. It will take a long time to understand when we come back to this code after some months to fix a bug or add functionality. Therefore, refactoring regularly is crucial.</p><p>What are the problems you can find with this code? The following are some problems:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Long method</strong>: Long <a id="id93" class="indexterm"/>methods and classes are difficult to read and understand.</li><li class="listitem" style="list-style-type: disc"><strong>Unclear naming</strong>: For <a id="id94" class="indexterm"/>instance, what is variable <code class="literal">cpl</code> supposed to be?</li><li class="listitem" style="list-style-type: disc"><strong>Complex conditionals</strong>: The <code class="literal">if</code> conditions are quite complicated, and it is unclear <a id="id95" class="indexterm"/>what exactly they are checking for.</li><li class="listitem" style="list-style-type: disc"><strong>Bad comments</strong>: None of the comments are descriptive and, in addition, two comments <a id="id96" class="indexterm"/>both say <code class="literal">BUY signal</code>. Obviously, one of them is wrong.</li><li class="listitem" style="list-style-type: disc"><strong>Magic constants</strong>: In various places, the numbers 5, 10, –11, and so on are hard coded. Suppose <a id="id97" class="indexterm"/>we decide to change the long-term moving average to use a 20-day period, then where are the places we need to change? What is the possibility that we may miss one?</li><li class="listitem" style="list-style-type: disc"><strong>Code duplication</strong>: Both <a id="id98" class="indexterm"/>the conditionals seem almost the same, with a very minor difference.</li></ul></div><p>All these<a id="id99" class="indexterm"/> problems are generally referred to as code smells. <strong>Code smells</strong> are simple patterns that can be easily spotted and refactored to make code better. Sometimes, code smells can be rectified by doing a few simple changes. Other times, it may lead up to a change of the design itself.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Refactoring</h1></div></div></div><p>
<strong>Refactoring</strong> is the process of cleaning up code or changing a design using a sequence of very small<a id="id100" class="indexterm"/> steps. No new functionality is added or removed during the refactoring process. The aim of refactoring is to make the code better by eliminating some code smell. There are many types of refactoring, from the extremely simple going up to much more complex refactorings. Let us apply some of these to the code above.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec13"/>The Rename Variable and Rename Method refactorings</h2></div></div></div><p>These two <a id="id101" class="indexterm"/>are probably the two simplest refactorings. The <a id="id102" class="indexterm"/>names are self explanatory—the refactoring is to rename a variable or a method. Although simple, they are very important because poor variable and method names are very common code smells.</p><p>The following are the steps to apply the <strong>Rename Variable</strong> refactoring:</p><div><ol class="orderedlist arabic"><li class="listitem">Run all the tests to make sure they are passing.</li><li class="listitem">Change the name of the variable, and make the change in all the places where it is being used.</li><li class="listitem">Run all the tests again to make sure we didn't break anything.</li></ol></div><p>The <strong>Rename Method</strong> refactoring<a id="id103" class="indexterm"/> follows the following <a id="id104" class="indexterm"/>sequence of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Run all the tests to make sure they are passing.</li><li class="listitem">Change the name of the method, and make the change in all the places where this method is being called.</li><li class="listitem">Run all the tests again.</li></ol></div><p>Let us now apply the Rename Variable refactoring to our code. The <code class="literal">cpl</code> variable holds the list of the closing prices of the stock for the last 11 days. We should rename this to something more descriptive, like <code class="literal">closing_price_list</code>. Let us do this now:</p><div><ol class="orderedlist arabic"><li class="listitem">Run the tests (a listing of the test cases is given in the <em>Exercise</em> section at the end of this chapter).</li><li class="listitem">Rename <code class="literal">cpl</code> to <code class="literal">closing_price_list</code> at all places in the method.</li><li class="listitem">Run the tests again. If there are any places where we forgot to rename the variable, then the tests will fail and we can fix it and run the tests again.</li></ol></div><div><div><h3 class="title"><a id="note15"/>Note</h3><p>
<strong>Tests as a safety net</strong>
</p><p>Having a solid set of tests is critical before we do refactoring. This is because tests give us the confidence that we haven't broken anything during the refactoring. We will be running the tests multiple times during a refactoring as we proceed from step to step.</p></div></div><p>Let us now apply the Rename Variable refactoring to our code. The <code class="literal">cpl</code> variable holds the list of the closing prices of the stock for the last eleven days. We should rename this to something more descriptive, like <code class="literal">closing_price</code>_list.</p><p>A quick search and replace and the code now looks like this:</p><div><pre class="programlisting">def get_crossover_signal(self, on_date):
    closing_price_list = []
    for i in range(11):
        chk = on_date.date() - timedelta(i)
        for price_event in reversed(self.price_history):
            if price_event.timestamp.date() &gt; chk:
                pass
            if price_event.timestamp.date() == chk:
                closing_price_list.insert(0, price_event)
                break
            if price_event.timestamp.date() &lt; chk:
                closing_price_list.insert(0, price_event)
                break

    # Return NEUTRAL signal
    if len(closing_price_list) &lt; 11:
        return 0

    # BUY signal
    if (sum([update.price
                 for update in closing_price_list[-11:-1]])/10
            &gt; sum([update.price
                       for update in closing_price_list[-6:-1]])/5
        and sum([update.price
                     for update in closing_price_list[-10:]])/10
            &lt; sum([update.price
                       for update in closing_price_list[-5:]])/5):
                return 1

    # BUY signal
    if (sum([update.price
                 for update in closing_price_list[-11:-1]])/10
            &lt; sum([update.price
                 for update in closing_price_list[-6:-1]])/5
        and sum([update.price
                     for update in closing_price_list[-10:]])/10
            &gt; sum([update.price
                       for update in closing_price_list[-5:]])/5):
                return -1

    # NEUTRAL signal
    return 0</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Commenting Styles</h2></div></div></div><p>Next, let us look at the comments in the method. Generally speaking, comments are a code smell <a id="id105" class="indexterm"/>because they indicate that the code itself is not <a id="id106" class="indexterm"/>easy to read. Some comments, like the one in the code above, simply repeat what the code is doing. Often, we put in a comment like this because it is easier to do so rather than clean up the code. So, wherever we see comments, it is worthwhile exploring if a code cleanup might be required. The other problem with comments is that they can very easily go out of sync with the code. It is quite common that when we come back in the future to implement a new feature, we don't update the comments. It leads to a great deal of confusion when we try to understand code where the comments are not in sync with the code.</p><p>not all comments are bad. Helpful comments explain <em>why</em> a certain piece of code has been written that way. This is the information that cannot be deduced by just reading the<a id="id107" class="indexterm"/> code. Consider the following examples:</p><div><pre class="programlisting"># Halve the price if age is 60 or above
if age &gt;= 60:
    price = price * 0.5

# People aged 60 or above are eligible for senior citizen discount
if age &gt;= 60:
    price = price * 0.5

if age &gt;= SENIOR_CITIZEN_AGE:
    price = price * SENIOR_CITIZEN_DISCOUNT</pre></div><p>The first <a id="id108" class="indexterm"/>example shows a comment that just repeats the code below it. There is no value added here by the comments. A cursory glance at the code will tell the reader exactly what the comment says.</p><p>The second example shows a much better comment. This comment doesn't repeat the code, but instead explains the rationale behind why this particular piece of code exists.</p><p>In the third example, the hardcoded numbers have been replaced by constants. In this example, the code is self-explanatory, so we can get rid of the comment altogether.</p><p>The three examples show the ideal process for writing comments. First, we see if we can make the code clearer in such a way that we don't need comments. If that is not possible, then write a comment around why the code has been written in a particular way. If you are tempted to write a comment about what a piece of code does, then stop and think about refactoring the code instead.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Replace Magic Literals with Constants</h2></div></div></div><p>As we saw<a id="id109" class="indexterm"/> in the previous example, replacing hardcoded values with constants accomplishes two things: first, should we <a id="id110" class="indexterm"/>need to change the values, we can do it at a single place, and, second, the constants are more descriptive and help make the code more readable.</p><p>The process for this refactoring is as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Run the tests.</li><li class="listitem">Create the constant and replace one hardcoded value with the constant.</li><li class="listitem">Run the tests again.</li><li class="listitem">Repeat steps 2 and 3 until all values are replaced with the constant.</li></ol></div><p>Our method uses the timespan for the long-term moving average and the short-term moving average in all the calculations. We can create constants to identify these two values like the following:</p><div><pre class="programlisting">class Stock:
    <strong>LONG_TERM_TIMESPAN = 10</strong>
    <strong>SHORT_TERM_TIMESPAN = 5</strong>
</pre></div><p>We can then use the constants in our method like the following:</p><div><pre class="programlisting">    def get_crossover_signal(self, on_date):
        closing_price_list = []
        NUM_DAYS = <strong>self.LONG_TERM_TIMESPAN</strong> + 1
        for i in range(NUM_DAYS):
            chk = on_date.date() - timedelta(i)
            for price_event in reversed(self.price_history):
                if price_event.timestamp.date() &gt; chk:
                    pass
                if price_event.timestamp.date() == chk:
                    closing_price_list.insert(0, price_event)
                    break
                if price_event.timestamp.date() &lt; chk:
                    closing_price_list.insert(0, price_event)
                    break</pre></div><p>Apart from the constants used in the calculation, we can also replace the return value with more descriptive <code class="literal">Enum</code> class. This is a new feature in Python 3.4 that we can use here.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>While <code class="literal">Enum</code> is a part of the standard library in Python 3.4, it has also been backported to earlier versions of Python. Download and install the enum34 package from PyPy if you are using an older Python version.</p></div></div><p>To do this, we first import <code class="literal">Enum</code> as follows:</p><div><pre class="programlisting">from enum import Enum</pre></div><p>We then create the enumeration class.</p><div><pre class="programlisting">class StockSignal(Enum):
    buy = 1
    neutral = 0
    sell = -1</pre></div><p>Finally, we can replace the return value with the enumeration:</p><div><pre class="programlisting">        # NEUTRAL signal
        return <strong>StockSignal.neutral</strong>
</pre></div><p>With this<a id="id111" class="indexterm"/> change, we can also remove <a id="id112" class="indexterm"/>the comments above the return values, as the constants are descriptive enough.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec16"/>The Extract Method refactoring</h2></div></div></div><p>Another way to make comments redundant is to take the code and put it in a method with a descriptive<a id="id113" class="indexterm"/> name. This also helps break down a long method into<a id="id114" class="indexterm"/> smaller methods that are easier to understand. The <strong>Extract Method</strong> refactoring is used for this purpose. The steps for the Extract Method refactoring are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Run the existing tests.</li><li class="listitem">Identify the variables in the code block that we want to refactor, that are also used before the code block. These variables will need to be passed into our method as parameters.</li><li class="listitem">Identify the variables in the code block that are used after the code block. These variables will be the return values from our method.</li><li class="listitem">Create a method with a descriptive name that takes in the above variables as a parameter.</li><li class="listitem">Make the new method return the appropriate values that are needed after the code block.</li><li class="listitem">Move the <a id="id115" class="indexterm"/>code block into the method. Replace the lines with a call to the method.</li><li class="listitem">Run the<a id="id116" class="indexterm"/> tests again.</li></ol></div><p>Let us apply this refactoring to our method. This loop is used to create a list of closing prices for each of the previous eleven days:</p><div><pre class="programlisting">    def _get_closing_price_list(self, on_date, num_days):
        closing_price_list = []
        for i in range(num_days):
            chk = on_date.date() - timedelta(i)
            for price_event in reversed(self.price_history):
                if price_event.timestamp.date() &gt; chk:
                    pass
                if price_event.timestamp.date() == chk:
                    closing_price_list.insert(0, price_event)
                    break
                if price_event.timestamp.date() &lt; chk:
                    closing_price_list.insert(0, price_event)
                    break
        return closing_price_list</pre></div><p>We can extract this code into a separate method. Here are the steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we create a new method called <code class="literal">_get_closing_price_list</code>:<div><pre class="programlisting">def _get_closing_price_list(self, on_date, num_days):
    pass</pre></div><p>This method takes two parameters because those values are used in the loop. Currently they are local variables, but once we extract the loop into this method, we will need to pass those values to the method.</p></li><li class="listitem">We now cut the loop code from the main method and paste it into this new method:<div><pre class="programlisting">def _get_closing_price_list(self, on_date, num_days):
    closing_price_list = []
    for i in range(NUM_DAYS):
        chk = on_date.date() - timedelta(i)
        for price_event in reversed(self.price_history):
            if price_event.timestamp.date() &gt; chk:
                pass
            if price_event.timestamp.date() == chk:
                closing_price_list.insert(0, price_event)
                break
            if price_event.timestamp.date() &lt; chk:
                closing_price_list.insert(0, price_event)
                break</pre></div></li><li class="listitem">At this point, the loop still refers to the <code class="literal">NUM_DAYS</code> constant that was a local variable. We<a id="id117" class="indexterm"/> need to change this to use the value<a id="id118" class="indexterm"/> from the parameter. We also make this method return the <code class="literal">closing_price_list</code>:<div><pre class="programlisting">def _get_closing_price_list(self, on_date, num_days):
    closing_price_list = []
    for i in range(num_days):
        chk = on_date.date() - timedelta(i)
        for price_event in reversed(self.price_history):
            if price_event.timestamp.date() &gt; chk:
                pass
            if price_event.timestamp.date() == chk:
                closing_price_list.insert(0, price_event)
                break
            if price_event.timestamp.date() &lt; chk:
                closing_price_list.insert(0, price_event)
                break
    return closing_price_list</pre></div></li><li class="listitem">Finally, we put in a call to this method where the loop code originally was used:<div><pre class="programlisting">def get_crossover_signal(self, on_date):
    NUM_DAYS = self.LONG_TERM_TIMESPAN + 1
    closing_price_list = \
        self._get_closing_price_list(on_date, NUM_DAYS)</pre></div></li></ol></div><p>Now we run <a id="id119" class="indexterm"/>the tests to make sure we didn't break anything. They<a id="id120" class="indexterm"/> should all pass.</p><p>Our code after refactoring looks like this:</p><div><pre class="programlisting">def _get_closing_price_list(self, on_date, num_days):
    closing_price_list = []
    for i in range(num_days):
        chk = on_date.date() - timedelta(i)
        for price_event in reversed(self.price_history):
            if price_event.timestamp.date() &gt; chk:
                pass
            if price_event.timestamp.date() == chk:
                closing_price_list.insert(0, price_event)
                break
            if price_event.timestamp.date() &lt; chk:
                closing_price_list.insert(0, price_event)
                break
    return closing_price_list

def get_crossover_signal(self, on_date):
    NUM_DAYS = self.LONG_TERM_TIMESPAN + 1
    closing_price_list = \
        self._get_closing_price_list(on_date, NUM_DAYS)
    …</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Replace Calculation with Temporary Variable</h2></div></div></div><p>Let us<a id="id121" class="indexterm"/> now turn our attention to<a id="id122" class="indexterm"/> the conditional statements where we perform the checks for crossover.</p><p>The conditional is messy because we are doing many calculations and comparisons at the same time, which is hard to follow. We can clean this up by using temporary variables to store the calculation values and then using the variables in the conditionals.</p><p>In this refactoring, we are not using the variables for any purpose other than just being able to give a name to the calculations, and thereby making the code easier to read.</p><p>The following is how we do this refactoring:</p><div><ol class="orderedlist arabic"><li class="listitem">Run the tests.</li><li class="listitem">Take the calculation and assign it to a variable. Make the name of the variable explain the purpose of the calculation.</li><li class="listitem">Use the variable in the conditional.</li><li class="listitem">Run the tests.</li></ol></div><p>Let us <a id="id123" class="indexterm"/>extract the four calculations in<a id="id124" class="indexterm"/> our conditional into variables:</p><div><pre class="programlisting">long_term_series = closing_price_list[-self.LONG_TERM_TIMESPAN:]
prev_long_term_series = \
    closing_price_list[-self.LONG_TERM_TIMESPAN-1:-1]
short_term_series = closing_price_list[-self.SHORT_TERM_TIMESPAN:]
prev_short_term_series = \
    closing_price_list[-self.SHORT_TERM_TIMESPAN-1:-1]</pre></div><p>We can then use these variables in the conditional:</p><div><pre class="programlisting">if sum([update.price for update in prev_long_term_series])/10 \
    &gt; sum([update.price for update in prev_short_term_series])/5 \
    and sum([update.price for update in long_term_series])/10 \
        &lt; sum([update.price for update in short_term_series])/5:
            return StockSignal.buy</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Extract Conditional to Method</h2></div></div></div><p>We can now turn our attention to the conditional. It isn't very clear as to what comparison is happening in the conditional. One way to handle this is to continue with the Replace Calculation <a id="id125" class="indexterm"/>with Temporary Variable refactoring<a id="id126" class="indexterm"/> above. Another option is to apply the <strong>Extract Conditional to Method</strong> refactoring. In this refactoring, we take the comparison and move it into its own method with a descriptive name.</p><p>The following are the steps for the refactoring:</p><div><ol class="orderedlist arabic"><li class="listitem">Run the tests.</li><li class="listitem">Take the entire conditional and move it into a method.</li><li class="listitem">Call the method where the conditional was before.</li><li class="listitem">Run the tests.</li></ol></div><p>Here is the conditional code that we currently have:</p><div><pre class="programlisting">if sum([update.price for update in prev_long_term_series])/10 \&gt; sum([update.price for update in prev_short_term_series])/5 \and sum([update.price for update in long_term_series])/10 \&lt; sum([update.price for update in short_term_series])/5:
            return StockSignal.buy</pre></div><p>First we<a id="id127" class="indexterm"/> apply the Replace Calculation <a id="id128" class="indexterm"/>with Temporary Variable refactoring and extract the moving average calculation into a named variable:</p><div><pre class="programlisting">long_term_ma = sum([update.price
                    for update in long_term_series])\
                /self.LONG_TERM_TIMESPAN
prev_long_term_ma = sum([update.price
                         for update in prev_long_term_series])\
                     /self.LONG_TERM_TIMESPAN
short_term_ma = sum([update.price
                     for update in short_term_series])\
                /self.SHORT_TERM_TIMESPAN
prev_short_term_ma = sum([update.price
                          for update in prev_short_term_series])\
                     /self.SHORT_TERM_TIMESPAN</pre></div><p>Next the comparisons being made in the conditional can be extracted to methods like this:</p><div><pre class="programlisting">def _is_short_term_crossover_below_to_above(self, prev_short_term_ma,
                                            prev_long_term_ma,
                                            short_term_ma,
                                            long_term_ma):
    return prev_long_term_ma &gt; prev_short_term_ma \
        and long_term_ma &lt; short_term_ma

def _is_short_term_crossover_above_to_below(self, prev_short_term_ma,
                                            prev_long_term_ma,
                                            short_term_ma,
                                            long_term_ma):
    return prev_long_term_ma &lt; prev_short_term_ma \
        and long_term_ma &gt; short_term_ma</pre></div><p>We now call the method in the <code class="literal">if</code> statement, passing in our temporary variables as parameters:</p><div><pre class="programlisting">if self._is_short_term_crossover_below_to_above(prev_short_term_ma,
                                                prev_long_term_ma,
                                                short_term_ma,
                                                long_term_ma):
            return StockSignal.buy

if self._is_short_term_crossover_above_to_below(prev_short_term_ma,
                                                prev_long_term_ma,
                                                short_term_ma,
                                                long_term_ma):
            return StockSignal.sell

return StockSignal.neutral</pre></div><p>This is <a id="id129" class="indexterm"/>what the method looks like after the<a id="id130" class="indexterm"/> last few refactorings:</p><div><pre class="programlisting">NUM_DAYS = self.LONG_TERM_TIMESPAN + 1
closing_price_list = self._get_closing_price_list(on_date, NUM_DAYS)

if len(closing_price_list) &lt; NUM_DAYS:
    return StockSignal.neutral

long_term_series = closing_price_list[-self.LONG_TERM_TIMESPAN:]
prev_long_term_series = \
    closing_price_list[-self.LONG_TERM_TIMESPAN-1:-1]
short_term_series = closing_price_list[-self.SHORT_TERM_TIMESPAN:]
prev_short_term_series = \
    closing_price_list[-self.SHORT_TERM_TIMESPAN-1:-1]

long_term_ma = sum([update.price
                    for update in long_term_series])\
                /self.LONG_TERM_TIMESPAN
prev_long_term_ma = sum([update.price
                         for update in prev_long_term_series])\
                     /self.LONG_TERM_TIMESPAN
short_term_ma = sum([update.price
                     for update in short_term_series])\
                /self.SHORT_TERM_TIMESPAN
prev_short_term_ma = sum([update.price
                          for update in prev_short_term_series])\
                     /self.SHORT_TERM_TIMESPAN

if self._is_short_term_crossover_below_to_above(prev_short_term_ma,
                                                prev_long_term_ma,
                                                short_term_ma,
                                                long_term_ma):
            return StockSignal.buy

if self._is_short_term_crossover_above_to_below(prev_short_term_ma,
                                                prev_long_term_ma,
                                                short_term_ma,
                                                long_term_ma):
            return StockSignal.sell

return StockSignal.neutral</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec19"/>The DRY principle</h2></div></div></div><p>One of the most important principles in writing good code is the DRY principle. <strong>DRY</strong> stands for <strong>Don't Repeat Yourself</strong>. If you ever find yourself writing the same (or similar) code in <a id="id131" class="indexterm"/>multiple places, there is a good chance that a refactoring <a id="id132" class="indexterm"/>will allow you to put that logic in once place and call it from each place that it is needed. It could be something as simple as moving the code into a function and calling the function from each place, or it could be a more complex refactoring.</p><p>Take another look at the conditionals that we just refactored:</p><div><pre class="programlisting">def _is_short_term_crossover_below_to_above(self, prev_short_term_ma,
                                            prev_long_term_ma,
                                            short_term_ma,
                                            long_term_ma):
    return prev_long_term_ma &gt; prev_short_term_ma \
        and long_term_ma &lt; short_term_ma

def _is_short_term_crossover_above_to_below(self, prev_short_term_ma,
                                            prev_long_term_ma,
                                            short_term_ma,
                                            long_term_ma):
    return prev_long_term_ma &lt; prev_short_term_ma \
        and long_term_ma &gt; short_term_ma</pre></div><p>We can see <a id="id133" class="indexterm"/>that they are almost the same. The only difference <a id="id134" class="indexterm"/>being that the comparisons are the other way around. Is there a way we can eliminate this code duplication?</p><p>One way is to change the order of the comparators in the first method:</p><div><pre class="programlisting">def _is_short_term_crossover_below_to_above(self, prev_short_term_ma,prev_long_term_ma,short_term_ma,long_term_ma):return prev_short_term_ma &lt; prev_long_term_ma \
        and short_term_ma &gt; long_term_ma</pre></div><p>Except for parameter names, it is now identical to the second method:</p><div><pre class="programlisting">def _is_short_term_crossover_above_to_below(self, prev_short_term_ma,
                                            prev_long_term_ma,
                                            short_term_ma,
                                            long_term_ma):
    return prev_long_term_ma &lt; prev_short_term_ma \
        and long_term_ma &gt; short_term_ma</pre></div><p>We can now merge both methods into one:</p><div><pre class="programlisting">def _is_crossover_below_to_above(self, prev_ma, prev_reference_ma,
                                 current_ma, current_reference_ma):
    return prev_ma &lt; prev_reference_ma \
        and current_ma &gt; current_reference_ma</pre></div><p>and call this single method in both conditionals:</p><div><pre class="programlisting">if self._is_crossover_below_to_above(prev_short_term_ma,
                                     prev_long_term_ma,
                                     short_term_ma,
                                     long_term_ma):
            return StockSignal.buy

if self._is_crossover_below_to_above(prev_long_term_ma,
                                     prev_short_term_ma,
                                     long_term_ma,
                                     short_term_ma):
            return StockSignal.sell</pre></div><p>Notice how the order of the short and long term parameters are exchanged between the two calls. The<a id="id135" class="indexterm"/> first checks that the short term moving average <a id="id136" class="indexterm"/>crosses the long term moving average from down to up. The second checks that the long term moving average crosses the short term moving average from down to up—this is the same as checking that the short term crosses from above to below. By doing the same check in both cases (below to above) and exchanging the parameters, we are able to eliminate the duplication in the code.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Single Responsibility Principle</h2></div></div></div><p>At this point, we have performed a number of local refactorings. These are refactorings such as <a id="id137" class="indexterm"/>moving code into or out of <a id="id138" class="indexterm"/>methods, pulling calculations into variables, and so on. These refactorings improve the readability of the code, but are mostly localized changes and don't affect the larger design.</p><p>From a design perspective, the most common reason that classes get cluttered is due to not following the <strong>Single Responsibility Principle</strong> (<strong>SRP</strong>). What this principle states is that a class should have a single, clear, coherent purpose. A class that tries to do too many different things is an indicator of a poor design.</p><p>Let us review whether the <code class="literal">Stock</code> class meets this criterion. The core responsibilities of the class are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Keeping a history of price updates for a particular stock</li><li class="listitem" style="list-style-type: disc">Checking whether the stock meets certain conditions</li></ul></div><p>In addition, the class is also performing the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculating a list of closing prices per day (or, more generally, code for handling a time series)</li><li class="listitem" style="list-style-type: disc">Calculating <a id="id139" class="indexterm"/>the moving average<a id="id140" class="indexterm"/> for various points in time</li></ul></div><p>The latter two responsibilities should be offloaded to a separate class.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Extract Class</h2></div></div></div><p>The <strong>Extract Class</strong> refactoring is used to take some functionality and move it into a separate <a id="id141" class="indexterm"/>class. This is easily the most commonly used design<a id="id142" class="indexterm"/> refactoring. It is an ideal refactoring to apply when we see that a class has become saddled with multiple responsibilities.</p><p>The following is what we want to do:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Move all code relating to managing a time series into a <code class="literal">TimeSeries</code> class</li><li class="listitem" style="list-style-type: disc">Move all code relating to moving averages into a <code class="literal">MovingAverage</code> class</li></ul></div><p>The steps for performing an Extract Class refactoring are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Run all tests.</li><li class="listitem">Create a new class.</li><li class="listitem">Instantiate the new class in the <code class="literal">__init__</code> scope, or pass it in as a parameter.</li><li class="listitem">Move one method from the source class to the new class. If the code to be moved is not in a method, then extract it to a local method using the Extract Method refactoring first.</li><li class="listitem">Change all local calls to call the method in the new class instance.</li><li class="listitem">Run the tests again.</li><li class="listitem">Repeat steps 3 to 5 for each piece of functionality to be moved.</li></ol></div><p>Let us now extract all the time series related functionality into a <code class="literal">TimeSeries </code>class.</p><p>First, we create a file called <code class="literal">timeseries.py</code> in the <code class="literal">stock_alerter</code> directory. We'll create our class here.</p><p>Next, we'll create an empty <code class="literal">TimeSeries</code> class in <code class="literal">timeseries.py</code> as follows:</p><div><pre class="programlisting">class TimeSeries:
    pass</pre></div><p>So far, we've been using <code class="literal">price_history</code>, a list, to store the price history. We now want to store all this information in our <code class="literal">TimeSeries</code> class. We'll make this transition step by step. The first step is to add an instance variable to the <code class="literal">Stock</code> class as follows:</p><div><pre class="programlisting">    def __init__(self, symbol):
        self.symbol = symbol
        self.price_history = []
        self.history = TimeSeries()</pre></div><p>Remember to import <code class="literal">TimeSeries</code> at the top of the file before making this change. Now we can migrate the update functionality into the <code class="literal">TimeSeries</code> class as follows:</p><div><pre class="programlisting">import bisect
import collections

Update = collections.namedtuple("Update", ["timestamp", "value"])

class TimeSeries:
    def __init__(self):
        self.series = []

    def update(self, timestamp, value):
        bisect.insort_left(self.series, Update(timestamp, value))</pre></div><p>Once<a id="id143" class="indexterm"/> migrated, we make a call to the new method in the <code class="literal">Stock</code> class<a id="id144" class="indexterm"/> as follows:</p><div><pre class="programlisting">    def update(self, timestamp, price):
        if price &lt; 0:
            raise ValueError("price should not be negative")
        bisect.insort_left(self.price_history, PriceEvent(timestamp, price))
        self.history.update(timestamp, price)</pre></div><p>Notice how we have just added the call to the timeseries, but we haven't removed the old call that updates <code class="literal">self.price_history</code>. This is because this list is still used directly in other places. By not removing this line yet, we don't break any functionality. All the tests still pass. Once we are done with the migration, we'll come back and remove this line.</p><p>Now we need to change the price and <code class="literal">is_increasing_trend</code> methods to stop using <code class="literal">self.price_history</code> and start using the time series class. This is what they look like currently:</p><div><pre class="programlisting">def price(self):
    return self.price_history[-1].price \
        if self.price_history else None

def is_increasing_trend(self):
    return self.price_history[-3].price &lt; \
        self.price_history[-2].price &lt; self.price_history[-1].price</pre></div><p>Our next step is to add a dictionary access method to <code class="literal">TimeSeries</code>:</p><div><pre class="programlisting">class TimeSeries:
    def __getitem__(self, index):
        return self.series[index]</pre></div><p>This enables us to change the <code class="literal">Stock.price</code> and <code class="literal">Stock.is_increasing_trend</code> methods to use the <code class="literal">TimeSeries</code> class instead of accessing <code class="literal">self.price_history</code>.</p><div><pre class="programlisting">    def price(self):
        try:
           return self.history[-1].value
        except IndexError:
            return None

    def is_increasing_trend(self):
        return self.history[-3].value &lt; \
            self.history[-2].value &lt; self.history[-1].value</pre></div><p>We<a id="id145" class="indexterm"/> should run the tests again to check that the new implementation<a id="id146" class="indexterm"/> of <code class="literal">Stock.price</code> and <code class="literal">Stock.is_increasing_trend</code> still work as expected. All 21 tests should still be passing.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Move Method to Class</h2></div></div></div><p>There is one final place where <code class="literal">self.price_history</code> is used, and this is in the <code class="literal">_get_closing_price_list</code> method. Instead of replacing the usage of <code class="literal">self.price_history</code>, we are instead going to move the whole method into the <code class="literal">TimeSeries</code> class. This<a id="id147" class="indexterm"/> is the <strong>Move Method to Class</strong> refactoring.</p><p>To do<a id="id148" class="indexterm"/> this refactoring, we will do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Run the tests.</li><li class="listitem">Move the method to the target class. If the method uses any instance variables, then we need to add them to the parameter list.</li><li class="listitem">Replace all calls to use the method in the other class, adding any new parameters that need to be passed.</li><li class="listitem">Some callers may not have a reference to the target class. In that case, we need to instantiate the object in the <code class="literal">__init__</code> scope or pass a reference to it as a parameter.</li><li class="listitem">Run the tests again.</li></ol></div><p>Usually, at the end of this refactoring, we need to do some further local refactoring in the target class. So, some of those extra parameters that were added might need to be moved elsewhere or changed. Some parameters might be added to the initializer and callers modified appropriately.</p><p>The following example will make this clearer. Let us start by moving the <code class="literal">_get_closing_price_list</code> method to the <code class="literal">TimeSeries</code> class. Since this will be a public method in the new class, we can drop the initial underscore in the name.</p><div><pre class="programlisting">class TimeSeries:
    def get_closing_price_list(self, on_date, num_days, price_history):
        closing_price_list = []
        for i in range(num_days):
            chk = on_date.date() - timedelta(i)
            for price_event in reversed(price_history):
                if price_event.timestamp.date() &gt; chk:
                    pass
                if price_event.timestamp.date() == chk:
                    closing_price_list.insert(0, price_event)
                    break
                if price_event.timestamp.date() &lt; chk:
                    closing_price_list.insert(0, price_event)
                    break
        return closing_price_list</pre></div><p>Notice the extra <code class="literal">price_history</code> parameter that we added to this method. The original method<a id="id149" class="indexterm"/> used the <code class="literal">self.price_history</code> variable. Since<a id="id150" class="indexterm"/> this is an instance variable of the <code class="literal">Stock</code> class, it is not available in the <code class="literal">TimeSeries</code> class. To fix that, we pass in the <code class="literal">price_history</code> as a parameter and use this in the method.</p><p>The call from the <code class="literal">Stock</code> class now looks like the following:</p><div><pre class="programlisting">    def get_crossover_signal(self, on_date):
        NUM_DAYS = self.LONG_TERM_TIMESPAN + 1
        closing_price_list = self.history.get_closing_price_list(on_date, NUM_DAYS, self.price_history)</pre></div><p>We run the tests at this point to validate that all the tests are still passing.</p><p>Once we verify that the tests are passing, we can now go back and remove the extra parameter that we added. The <code class="literal">TimeSeries</code> class has its own instance variable <code class="literal">self.series</code> that contains the price history. We can use this variable in the method and remove the extra parameter. The method now becomes as follows:</p><div><pre class="programlisting">    def get_closing_price_list(self, on_date, num_days):
        closing_price_list = []
        for i in range(num_days):
            chk = on_date.date() - timedelta(i)
            for price_event in reversed(self.series):
                if price_event.timestamp.date() &gt; chk:
                    pass
                if price_event.timestamp.date() == chk:
                    closing_price_list.insert(0, price_event)
                    break
                if price_event.timestamp.date() &lt; chk:
                    closing_price_list.insert(0, price_event)
                    break
        return closing_price_list</pre></div><p>And the <a id="id151" class="indexterm"/>call becomes as follows:</p><div><pre class="programlisting">    def get_crossover_signal(self, on_date):
        NUM_DAYS = self.LONG_TERM_TIMESPAN + 1
        closing_price_list = self.history.get_closing_price_list(on_date, NUM_DAYS)</pre></div><p>Run the <a id="id152" class="indexterm"/>tests again to check that everything is working, as shown in the following:</p><div><pre class="programlisting"><strong>==================================================================</strong>
<strong>ERROR: test_with_upward_crossover_returns_buy (stock_alerter.stock.StockCrossOverSignalTest)</strong>
<strong>------------------------------------------------------------------</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "c:\Projects\tdd_with_python\src\stock_alerter\stock.py", line 239, in test_with_upward_crossover_returns_buy</strong>
<strong>    self.goog.get_crossover_signal(date_to_check))</strong>
<strong>  File "c:\Projects\tdd_with_python\src\stock_alerter\stock.py", line 63, in get_crossover_signal</strong>
<strong>    for update in long_term_series])\</strong>
<strong>  File "c:\Projects\tdd_with_python\src\stock_alerter\stock.py", line 63, in &lt;listcomp&gt;</strong>
<strong>    for update in long_term_series])\</strong>
<strong>AttributeError: 'Update' object has no attribute 'price'</strong>

<strong>Ran 21 tests in 0.018s</strong>

<strong>FAILED (errors=7)</strong>
</pre></div><p>Oops! Looks like some of the tests are failing!</p><p>The problem is that the updates stored in <code class="literal">self.price_history</code> use the <code class="literal">price</code> attribute to refer to the price, but the <code class="literal">timeseries</code> module calls it value. So, we need to change the places where we calculate the moving average and replace price with value. With that change, the tests pass again and our moving average calculation now looks like the following:</p><div><pre class="programlisting">        long_term_ma = sum([update.value
                            for update in long_term_series])\
                        /self.LONG_TERM_TIMESPAN
        prev_long_term_ma = sum([update.value
                                 for update in prev_long_term_series])\
                             /self.LONG_TERM_TIMESPAN
        short_term_ma = sum([update.value
                             for update in short_term_series])\
                        /self.SHORT_TERM_TIMESPAN
        prev_short_term_ma = sum([update.value
                                  for update in prev_short_term_series])\
                             /self.SHORT_TERM_TIMESPAN</pre></div><p>The above code is the same as before except that we now use <code class="literal">update.value</code> instead of <code class="literal">update.price</code>.</p><p>Now, <code class="literal">price_history</code> is no longer used anywhere in the <code class="literal">Stock</code> class, so we can remove it from the <a id="id153" class="indexterm"/>class. We can also remove the <code class="literal">PriceEvent</code> named<a id="id154" class="indexterm"/> tuple as well as any unused imports. The initializer and update method after those changes are as follows:</p><div><pre class="programlisting">class Stock:
    LONG_TERM_TIMESPAN = 10
    SHORT_TERM_TIMESPAN = 5

    def __init__(self, symbol):
        self.symbol = symbol
        self.history = TimeSeries()

    def update(self, timestamp, price):
        if price &lt; 0:
            raise ValueError("price should not be negative")
        self.history.update(timestamp, price)</pre></div><p>With<a id="id155" class="indexterm"/> this change, our Extract Class refactoring is<a id="id156" class="indexterm"/> complete.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>The importance of tests</h1></div></div></div><p>The Extract Class refactoring shows the importance of having a good unit test suite as well as running<a id="id157" class="indexterm"/> it frequently during the refactoring. It is easy to overlook small things when moving code around, which could end up breaking the code. By running the tests often, we know immediately when we break something. This makes it easy to fix the mistake. Had we done the whole refactoring before running the tests, it would have not been clear which step in the refactoring broke the tests, and we would have to go back and debug the whole refactoring.</p><p>One more thing that we need to do is to adjust the tests after the refactoring is complete. In some refactorings, such as Extract Class, we may find that we have to also move tests to the new class. For instance, if we had any tests for the <code class="literal">_get_closing_price_list</code> method, then we would move those tests over to the <code class="literal">TimeSeries</code> class. In this case, since the method was not public, we didn't write tests for them and we didn't have anything to move.</p><p>After the refactoring, that method has become a public method on the <code class="literal">TimeSeries</code> class, and it currently doesn't have any tests. It is a good idea to go back and write some tests for the method.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Exercise</h1></div></div></div><p>Just as we extracted the time series code into its own class, we can also extract the moving average code into a separate class. Try doing this refactoring as an exercise. Once you are done, check out the Appendix for a walkthrough of one possible solution.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Wrapping up</h1></div></div></div><p>Here is the algorithm for calculating the DMAC in pseudocode:</p><div><ol class="orderedlist arabic"><li class="listitem">Calculate the short term and long term moving averages.</li><li class="listitem">If the short term crosses the long term from bottom to top, then <em>buy</em>.</li><li class="listitem">If the long term crosses the short term from bottom to top, then <em>sell</em>.</li><li class="listitem">Otherwise do nothing.</li></ol></div><p>This is the code we started with, which passed all the tests:</p><div><pre class="programlisting">def get_crossover_signal(self, on_date):
    cpl = []
    for i in range(11):
        chk = on_date.date() - timedelta(i)
        for price_event in reversed(self.price_history):
            if price_event.timestamp.date() &gt; chk:
                pass
            if price_event.timestamp.date() == chk:
                cpl.insert(0, price_event)
                break
            if price_event.timestamp.date() &lt; chk:
                cpl.insert(0, price_event)
                break

    # Return NEUTRAL signal
    if len(cpl) &lt; 11:
        return 0

    # BUY signal
    if sum([update.price for update in cpl[-11:-1]])/10 \
            &gt; sum([update.price for update in cpl[-6:-1]])/5 \
        and sum([update.price for update in cpl[-10:]])/10 \
            &lt; sum([update.price for update in cpl[-5:]])/5:
                return 1

    # BUY signal
    if sum([update.price for update in cpl[-11:-1]])/10 \
            &lt; sum([update.price for update in cpl[-6:-1]])/5 \
        and sum([update.price for update in cpl[-10:]])/10 \
            &gt; sum([update.price for update in cpl[-5:]])/5:
                return -1

    # NEUTRAL signal
    return 0</pre></div><p>After the moving average code is extracted into its own class (see the exercise above to try this, or the <a class="link" href="apa.html" title="Appendix A. Answers to Exercises">Appendix A</a>, <em>Answers to Exercises</em> to see one solution of how we got here), this is what the <code class="literal">get_crossover_signal</code> method looks like:</p><div><pre class="programlisting">def get_crossover_signal(self, on_date):
    long_term_ma = MovingAverage(self.history, self.LONG_TERM_TIMESPAN)
    short_term_ma = MovingAverage(self.history, self.SHORT_TERM_TIMESPAN)

    try:
        if self._is_crossover_below_to_above(
                on_date,
                short_term_ma,
                long_term_ma):
            return StockSignal.buy

        if self._is_crossover_below_to_above(
                on_date,
                long_term_ma,
                short_term_ma):
            return StockSignal.sell
    except NotEnoughDataException:
        return StockSignal.neutral

    return StockSignal.neutral</pre></div><p>The difference is clear. The refactored code reads just like the pseudocode above, with an almost 1:1 correspondence. A person who knows the algorithm will instantly know what this method is doing. We don't need to write a line of comments to make this readable. We cannot say the same for the code we started with.</p><p>The new code is only 9 statements long and delegates all the non-core functionality to the <code class="literal">TimeSeries</code> and <code class="literal">MovingAverage</code> classes. These classes are themselves quite short, and easy to understand. Overall, the refactoring has made a huge improvement in the quality of the code.</p><p>The best part? We made small changes and always had the tests as a safety net so we were sure we didn't break anything. Without the tests, we could not have undertaken these refactorings—the risk of breaking code is just too large. In fact, while writing the code that you see in this chapter, I did break the tests several times. Fortunately the tests were there and the errors were fixed in minutes.</p><p>One might ask about the time taken to perform all the refactorings we have gone through so far. This chapter looks quite huge and intimidating, but once we are comfortable with the techniques, it would take only about 30 to 60 minutes to perform all these refactorings.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, you looked at some of the most common code smells as well as the most common refactorings to fix them. You saw, step by step, how to perform each of the refactorings on our project and how having a good test suite enables us to perform such refactorings with confidence. Test-driven development and refactoring go hand in hand and are invaluable tools in any developer's toolbox. In the next chapter, we will take a look at testing code interactions using mock objects.</p></div></div>
</body></html>