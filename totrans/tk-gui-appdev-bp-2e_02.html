<html><head></head><body>
        

                            
                    <h1 class="header-title">Making a Text Editor</h1>
                
            
            
                
<p class="mce-root">We got a fairly high-level overview of Tkinter in <a href="39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml" target="_blank">Chapter 1</a>, <em>Meet Tkinter</em>. Now that we know some things about Tkinter's core widgets, geometry management, and the binding of commands and events to callbacks, let's use our skills in this project to create a text editor.</p>
<p class="mce-root">We will, in the process of creating a text editor, take a closer look at some widgets and learn how to tweak them to meet our specific needs.</p>
<p class="mce-root">The following are the key objectives for this project:</p>
<ul>
<li class="mce-root">Delving into some commonly used widgets, such as the Menu, Menubutton, Text, Entry, Checkbutton, and Button widgets</li>
<li class="mce-root">Exploring the <kbd>filedialog</kbd> and <kbd>messagebox</kbd> modules of Tkinter</li>
<li class="mce-root">Learning the vital concepts of indexing and tagging, as applied to Tkinter</li>
<li class="mce-root">Identifying the different types of Toplevel windows</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Project overview</h1>
                
            
            
                
<p class="mce-root">The goal here is to build a text editor with some nifty features. Let's call it the Footprint Editor:</p>
<div><img src="img/bd68997a-c934-4d03-b092-ed80b010bf13.png"/></div>
<p>We intend to include the following features in the text editor:</p>
<ul>
<li>Creating new documents, opening and editing existing documents, and saving documents</li>
<li>Implementing common editing options such as cut, copy, paste, undo, and redo</li>
<li>Searching within a file for a given search term</li>
<li>Implementing line numbering and the ability to show/hide line numbers</li>
<li>Implementing theme selection to let a user choose custom color themes for the editor</li>
<li>Implementing the about and help windows</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started – setting up the editor skeleton</h1>
                
            
            
                
<p>Our first goal is to implement the broad visual elements of the text editor. As programmers, we have all used text editors to edit code. We are mostly aware of the common GUI elements of a text editor. So, without further ado, let's get started.</p>
<p>The first phase implements the Menu, Menubutton, Label, Button, Text, and Scrollbar widgets. Although we'll cover all of these in detail, you might find it helpful to look at the widget-specific options in the documentation of Tkinter maintained by its author, Frederick Lundh, at <a href="http://effbot.org/tkinterbook/">http://effbot.org/tkinterbook/</a>. You can also use the interactive shell, as discussed in <a href="39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml">Chapter 1</a><em>, Meet Tkinter</em>.</p>
<p>You might also want to bookmark the official documentation page of Tcl/Tk at <a href="http://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm">http://www.tcl.tk/man/tcl8.6/TkCmd/contents.htm</a>. This site includes the original Tcl/Tk reference. While it does not relate to Python, it provides a detailed overview of each widget and is a useful reference. Remember that Tkinter is just a wrapper around Tk.</p>
<p>In this iteration, we will complete the implementation of broader visual elements of the editor.</p>
<p>We will use the <kbd>pack()</kbd> geometry manager to place all the widgets. We have chosen the pack manager because it is ideally suited for the placing of widgets, either in a side-by-side or top-down position.</p>
<p>Fortunately, in a text editor, we have all the widgets placed either side by side or in top-down positions. Thus, it is beneficial to use the pack manager. We can do the same thing with the grid manager as well.</p>
<p>A note on code styling<br/>
One of the key insights of the Python community is that code is read much more often than it is written. Following good naming conventions and consistency in code styling are key to maintaining readable and scalable programs. We will try to stick to the official Python styling guide, which is specified in the PEP8 documentation at <a href="https://www.python.org/dev/peps/pep-0008">https://www.python.org/dev/peps/pep-0008</a>.</p>
<p>Some important styling conventions that we will stick to include the following:</p>
<ul>
<li>Use four spaces per indentation level</li>
<li>Variable and function names will be lowercase, with words separated by underscores</li>
<li>Class names will use the <kbd>CapWords</kbd> convention</li>
</ul>
<p>Let's start by adding the Toplevel window using the following code:</p>
<pre>from tkinter import Tk<br/>root = Tk()<br/># all our code goes here<br/>root.mainloop()</pre>
<p>Note a slight difference in the way we import <kbd>tkinter</kbd> here. In the last chapter, we imported <kbd>tkinter</kbd> using this code:</p>
<pre>import tkinter as tk</pre>
<p>Since we used <kbd>tk</kbd> as an alias, we had to append the alias name to every call made to a class defined in Tkinter, as in <kbd>tk.Tk()</kbd>, <kbd>tk.Frame</kbd>, <kbd>tk.Button</kbd>, <kbd>tk.END</kbd>, and so on. </p>
<p>From this chapter onward, we will directly import the individual class that we will need for a given program. So, now that we need the <kbd>Tk()</kbd> class from Tkinter, we directly import it into our namespace as:</p>
<pre>from tkinter import Tk</pre>
<p>This, in turn, means that we can now directly reference it as the <kbd>Tk</kbd> class in our program without needing to append any alias name to it as in <kbd>root = Tk()</kbd>.</p>
<p>A third method is to import all (<kbd>*</kbd>) the classes from Tkinter into the namespace by using the following command:</p>
<pre>from tkinter import *</pre>
<p>The asterisk symbol means we want everything from <kbd>tkinter</kbd> to be imported into the namespace, regardless of whether we use it. This is, however, bad programming practice as it leads to namespace pollution. Furthermore, in larger programs, it can be hard to tell which module a particular class has been imported from, thus making debugging a difficult task.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a menu and menu items</h1>
                
            
            
                
<p>Menus offer a very compact way of presenting a large number of choices to the user without cluttering the interface. Tkinter offers the following two widgets to handle menus:</p>
<ul>
<li><strong>Menu widget</strong>: This appears at the top of applications, which is always visible to end users</li>
<li><strong>Menu items</strong>: These show up when a user clicks on a menu </li>
</ul>
<p>We will use the following code to add Toplevel menu buttons:</p>
<pre>my_menu = Menu(parent, **options)</pre>
<p>For example, to add a <kbd>File</kbd> menu, we will use the following code:</p>
<pre># Adding Menubar in the widget<br/>menu_bar = Menu(root)<br/>file_menu = Menu(menu_bar, tearoff=0)<br/># all file menu-items will be added here next<br/>menu_bar.add_cascade(label='File', menu=file_menu)<br/>root.config(menu=menu_bar)</pre>
<p>The following screenshot is the result of the preceding code (<kbd>2.01.py</kbd>):</p>
<div><img src="img/a27eb2da-668c-4f19-b38f-3999e4804f98.png"/></div>
<p>Similarly, we will add the Edit, View, and About menus (<kbd>2.01.py</kbd><em>)</em>.</p>
<p>We will also define a constant as follows:</p>
<pre>PROGRAM_NAME = " Footprint Editor "</pre>
<p>Then, we'll set the root window tile, as follows:</p>
<pre>root.title(PROGRAM_NAME)</pre>
<p>Most Linux platforms support <strong>tear-off menus</strong>. When <kbd>tearoff</kbd> is set to <kbd>1</kbd> (enabled), the menu appears with a dotted line above the menu options. Clicking on the dotted line enables the user to literally tear off or separate the menu from the top. However, as this is not a cross-platform feature, we have decided to disable tear-off, marking it as <kbd>tearoff = 0</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding menu items</h1>
                
            
            
                
<p>Next, we will add menu items in every individual menu. Not surprisingly, the code for the menu items needs to be added in the respective menu instance, as shown in the following screenshot:</p>
<div><img src="img/49bcab0c-fb53-475a-abe7-07cdf34224f9.png"/></div>
<p>In our example, we will add menu items to the File, Edit, and About menus (<kbd>2.02.py</kbd>).</p>
<p>The View menu has certain menu item variations, which will be tackled in the following section and are therefore not dealt with here.</p>
<p>Menu items are added by using the <kbd>add_command()</kbd> method. The format used to add menu items is as follows:</p>
<pre>my_menu.add_command(label="Menu Item Label", accelerator='KeyBoard Shortcut', compound='left', image=my_image, underline=0, command=callback)</pre>
<p>For example, you can create the Undo menu item by using the following syntax:</p>
<pre>edit_menu.add_command(label="Undo", accelerator='Ctrl + Z', compound='left', image=undo_icon, command=undo_callback)</pre>
<p>Some new menu-specific options that are introduced in the preceding code are as follows:</p>
<ul>
<li><kbd>accelerator</kbd>: This option is used to specify a string, typically a keyboard shortcut, that can be used to invoke a menu. The string specified as an <kbd>accelerator</kbd> appears next to the text of the menu item. Please note that this does not automatically create bindings for the keyboard shortcut. We will have to manually set them up. This will be discussed later.</li>
<li><kbd>compound</kbd>: Specifying a <kbd>compound</kbd> option for a menu item lets you add images beside a menu label. A specification such as <kbd>compound='left'</kbd>,  <kbd>label= 'Cut'</kbd>, <kbd>image=cut_icon</kbd> means that the cut icon will appear to the left of the Cut menu label. The icons that we will use here are stored and referenced in a separate folder called <kbd>icons</kbd>.</li>
<li><kbd>underline</kbd>: The <kbd>underline</kbd> option lets you specify the index of a character in the menu text that needs to be underlined. The indexing starts at <kbd>0</kbd>, which means that specifying <kbd>underline=1</kbd> underlines the second character of the text. Besides underlining, Tkinter also uses it to define the default bindings for the keyboard traversal of menus. This means that we can select the menu either with the mouse pointer or with the <em>Alt</em> + <em>&lt;character_at_the_underlined_index&gt;</em> shortcut.</li>
</ul>
<p>To add the <kbd>New</kbd> menu item in the File menu, use the following code:</p>
<pre>file_menu.add_command(label="New", accelerator='Ctrl+N', compound='left', image=new_file_icon, underline=0, command=new_file)</pre>
<p>Menu separators<br/>
Occasionally, in menu items, you will come across code such as <kbd>my_menu.add_separator()</kbd>. This widget displays a separator bar and is solely used to organize similar menu items in groups, separating groups by horizontal bars.</p>
<p>Next, we will add a Frame widget to hold the shortcut icons. We will also add a Text widget to the left to display line numbers, as shown in the following screenshot (<kbd>2.02.py</kbd>):</p>
<div><img height="159" src="img/5542a195-8fa9-46d9-adde-842056ebe5fd.png" width="242"/></div>
<p>When working with the pack geometry manager, it is important to add widgets in the order in which they will appear because <kbd>pack()</kbd> uses the concept of available space to fit the widgets. This is why the text content widget will appear lower in the code compared to the two label widgets.</p>
<p>Having reserved the space, we can later add shortcut icons or line numbers and keep the Frame widget as the parent widget. Adding frames is easy; we have done that in the past. The code is as follows (refer to <kbd>2.02.py</kbd>):</p>
<pre>shortcut_bar = Frame(root, height=25, background='light sea green')<br/>shortcut_bar.pack(expand='no', fill='x')<br/>line_number_bar = Text(root, width=4, padx=3, takefocus=0, border=0, background='khaki', state='disabled', wrap='none')<br/>line_number_bar.pack(side='left', fill='y')</pre>
<p>We have applied a background color to these two widgets, for now, to differentiate them from the body of the Toplevel window.</p>
<p>Lastly, let's add the main Text widget and the Scrollbar widget, as follows (<kbd>2.02.py</kbd>)<em>:</em></p>
<pre>content_text = Text(root, wrap='word')<br/>content_text.pack(expand='yes', fill='both')<br/>scroll_bar = Scrollbar(content_text)<br/>content_text.configure(yscrollcommand=scroll_bar.set)<br/>scroll_bar.config(command=content_text.yview)<br/>scroll_bar.pack(side='right', fill='y')</pre>
<p>The code is similar to how we instantiated all the other widgets so far. However, note that the scrollbar is configured to <kbd>yview</kbd> of the Text widget, and the Text widget is configured to connect to the Scrollbar widget. This way, the widgets are cross-connected to each other.</p>
<p>Now, when you scroll down the Text widget, the scrollbar reacts to it. Alternatively, when you move the scrollbar, the Text widget reacts in turn.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the View menu</h1>
                
            
            
                
<p>Tkinter offers the following three varieties of menu item:</p>
<ul>
<li><strong>Checkbutton menu items</strong>: These let you make a yes/no choice by checking/unchecking the menu item</li>
<li><strong>Radiobutton menu items</strong>: These let you choose an option from many different options</li>
<li><strong>Cascade menu items</strong>: These menu items only open up to show another list of choices</li>
</ul>
<p>The following View menu shows these three menu item types in action:</p>
<div><img height="220" src="img/f3cae6b3-ec45-482f-a8c3-54fb7960cc3b.png" width="400"/></div>
<p>The first three menu items in the View menu let users make a definite yes or no choice by checking or unchecking thems. These are examples of the Checkbutton menu.</p>
<p>The Themes menu item in the preceding screenshot is an example of a Cascade menu. Hovering over this Cascade menu simply opens another list of menu items. However, we can also bind a menu item by using the <kbd>postcommand=callback</kbd> option. This can be used to manage something just before bringing up the cascading menu item's contents and is often used for dynamic list creation.</p>
<p>Within the Cascade menu, you are presented with a list of choices for your editor's theme. However, you can only select one theme. Selecting one theme deselects any previous selections. This is an example of the Radiobutton menu.</p>
<p>We will not present the entire code here (refer to the <kbd>2.03.py</kbd> code in the code bundle). However, the example code used to add these three types of menu item is as follows:</p>
<pre>view_menu.add_checkbutton(label="Show Line Number", variable=show_line_no)<br/>view_menu.add_cascade(label="Themes", menu=themes_menu)<br/>themes_menu.add_radiobutton(label="Default", variable=theme_name)</pre>
<p>Now, we need to track whether a selection has been made by adding a variable, which can be <kbd>BooleanVar()</kbd>, <kbd>IntVar()</kbd>, or <kbd>Stringvar()</kbd>, as discussed in <a href="39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml" target="_blank">Chapter 1</a><em>, Meet Tkinter</em>.</p>
<p>This concludes our first iteration. In this iteration, we laid down the majority of the visual elements of the text editor. Now it's time to add some functionalities to the editor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a built-in functionality</h1>
                
            
            
                
<p>Tkinter's Text widget comes with some handy built-in functionalities to handle common text-related functions. Let's leverage these functionalities to implement some common features in the text editor.</p>
<p>Let's start by implementing the <kbd>cut</kbd>, <kbd>copy</kbd>, and <kbd>paste</kbd> features. We now have the editor GUI ready. If you open the program and play with the Text widget, you will see that you can perform basic functions such as <kbd>cut</kbd>, <kbd>copy</kbd>, and <kbd>paste</kbd> in the text area by using <em>Ctrl</em> + <em>X</em>, <em>Ctrl</em> + <em>C</em>, and <em>Ctrl</em> + <em>V</em>, respectively. All of these functions exist without us having to add a single line of code for these functionalities.</p>
<p>The Text widget clearly comes with these built-in events. Now, we simply want to connect these events to their respective menu items.</p>
<p>The documentation of the Tcl/Tk universal widget methods tells us that we can trigger events without an external stimulus by using the following command:</p>
<pre>widget.event_generate(sequence, **kw)</pre>
<p>To trigger the Cut event, all we need is the following line in the code:</p>
<pre>content_text.event_generate("&lt;&lt;Cut&gt;&gt;")</pre>
<p>Let's call it by using a <kbd>cut</kbd> function and associate it with the Cut menu by using the callback command (<kbd>2.04.py</kbd>):</p>
<pre>def cut():<br/>  content_text.event_generate("&lt;&lt;Cut&gt;&gt;")</pre>
<p>Then, define a callback command from the existing Cut menu, as follows:</p>
<pre>edit_menu.add_command(label='Cut', accelerator='Ctrl+X', compound='left', image=cut_icon, command=cut)</pre>
<p>Similarly, trigger the <kbd>copy</kbd> and <kbd>paste</kbd> functions from their respective menu items.</p>
<p>Next, we will move on to the implementation of the <kbd>undo</kbd> and <kbd>redo</kbd> features. The Tcl/Tk text documentation tells us that the Text widget has an unlimited Undo and Redo mechanism provided we set the undo option to <kbd>true</kbd> or <kbd>1</kbd>. To leverage this option, let's first set the Text widget's undo option to <kbd>true</kbd> or <kbd>1</kbd>, as shown in the following code:</p>
<pre>content_text = Text(root, wrap='word', undo=1)</pre>
<p>Now, if you open the text editor and try out the <kbd>undo</kbd> feature by using <em>Ctrl</em> + <em>Z</em>, it should work well. Now, we only have to associate the events to functions and call back the functions from the Undo menu. This is similar to what we did for <kbd>cut</kbd>, <kbd>copy</kbd>, and <kbd>paste</kbd>. Refer to the code in <kbd>2.03.py</kbd>.</p>
<p>However, <kbd>redo</kbd> has a little quirk that needs to be addressed. By default, <kbd>redo</kbd> is not bound to the <em>Ctrl</em> + <em>Y</em> keys. Instead, <em>Ctrl</em> + <em>Y</em> is bound to the <kbd>paste</kbd> functionality. This is not how we expect the binding to behave, but it exists due to some historical reasons related to Tcl/Tk.</p>
<p>Fortunately, it is easy to override this functionality by adding an event binding, as follows:</p>
<pre>content_text.bind('&lt;Control-y&gt;', redo) # handling Ctrl + small-case y<br/>content_text.bind('&lt;Control-Y&gt;', redo) # handling Ctrl + upper-case y</pre>
<p>Since an event binding like the one in the preceding code sends an event argument, the <kbd>undo</kbd> function must be able to handle this incoming parameter. Therefore, we'll add the <kbd>event=None</kbd> optional parameter to the <kbd>redo</kbd> function, as follows (<kbd>2.04.py</kbd>):</p>
<pre>def redo(event=None):<br/>  content_text.event_generate("&lt;&lt;Redo&gt;&gt;")<br/>  return 'break'</pre>
<p>Events propagate from the operating system level and are accessible to the window that subscribes to the event or wants to make use of it. The <kbd>return 'break'</kbd> expression in the preceding function tells the system that it has performed the event and that it should not be propagated further.</p>
<p>This prevents the same event from firing the <kbd>paste</kbd> event even though it is the default behavior in Tkinter. Now, <em>Ctrl</em> + <em>Y</em> fires the <kbd>redo</kbd> event instead of firing the <kbd>paste</kbd> event.</p>
<p>In fact, once we have performed an event, we do not want it to propagate further. Thus, we will add return <kbd>break</kbd> to all event-driven functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Indexing and tagging</h1>
                
            
            
                
<p>Though we managed to leverage some built-in functionalities to gain a quick advantage, we need more control over the text area so that we can bend it to our will. This will require the ability to target each character or text location with precision.</p>
<p>We will need to know the exact position of each character, the cursor, or the selected area in order to do anything with the contents of the editor.</p>
<p>The Text widget offers us the ability to manipulate its content using <strong>index</strong>, <strong>tags</strong>, and <strong>mark</strong>, which let us target a position or place within the text area for manipulation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Index</h1>
                
            
            
                
<p>Indexing helps you target a particular place within a piece of text. For example, if you want to mark a particular word in bold, red, or in a different font size, you can do so if you know the index of the starting point and the index of the endpoint that needs to be targeted.</p>
<p>The index must be specified in one of the following formats:</p>
<table>
<tbody>
<tr>
<td><strong>The index format</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>x.y</kbd></td>
<td>This refers to the character at row <kbd>x</kbd> and column <kbd>y</kbd>.</td>
</tr>
<tr>
<td><kbd>@x,y</kbd></td>
<td>This refers to the character that covers the <kbd>x,y</kbd> coordinate within the text's window.</td>
</tr>
<tr>
<td><kbd>end</kbd></td>
<td>This refers to the end of the text.</td>
</tr>
<tr>
<td><kbd>mark</kbd></td>
<td>This refers to the character after a named mark.</td>
</tr>
<tr>
<td><kbd>tag.first</kbd></td>
<td>This refers to the first character in the text that has been tagged with a given tag.</td>
</tr>
<tr>
<td><kbd>tag.last</kbd></td>
<td>This refers to the last character in the text that has been tagged with a given tag.</td>
</tr>
<tr>
<td><kbd>selection</kbd> (<kbd>SEL_</kbd><br/>
<kbd>FIRST</kbd>, <kbd>SEL_LAST</kbd>)</td>
<td>This corresponds to the current selection. The <kbd>SEL_FIRST</kbd> and <kbd>SEL_LAST</kbd> constants refer to the start position and end position in the selection. Tkinter raises a <kbd>TclError</kbd> exception if there is no selection.</td>
</tr>
<tr>
<td><kbd>window_name</kbd></td>
<td>This refers to the position of the embedded window named <kbd>window_name</kbd>.</td>
</tr>
<tr>
<td><kbd>image_name</kbd></td>
<td>This refers to the position of the embedded image named <kbd>image_name</kbd>.</td>
</tr>
<tr>
<td><kbd>INSERT</kbd></td>
<td>This refers to the position of the insertion cursor.</td>
</tr>
<tr>
<td><kbd>CURRENT</kbd></td>
<td>This refers to the position of the character that is closest to the mouse pointer.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Note a small quirk here. The counting of rows in a Text widget starts at 1, while the counting of columns starts at 0. Therefore, the index for the starting position of the Text widget is 1.0 (that is, row number 1 and column number 0).</p>
<p>An index can be further manipulated by using modifiers and submodifiers. Some examples of modifiers and submodifiers are as follows:</p>
<ul>
<li><kbd>end - 1 chars</kbd> or <kbd>end - 1 c</kbd>: This refers to the index of the character before the one at the end</li>
<li><kbd>insert +5lines</kbd>: This refers to the index five lines ahead of the insertion cursor</li>
<li><kbd>insertwordstart - 1 c</kbd>: This refers to the character just before the first one in a word containing the insertion cursor</li>
<li><kbd>end linestart</kbd>: This refers to the index of the line start of the end line</li>
</ul>
<p>Indexes are often used as arguments to functions. Refer to the following list for some examples:</p>
<ul>
<li><kbd>my_text.delete</kbd>(<kbd>1.0</kbd>,<kbd>END</kbd>) : This means that you can delete from line <kbd>1</kbd> , column <kbd>0</kbd> until the end</li>
<li><kbd>my_text.get</kbd>(<kbd>1.0,</kbd> <kbd>END</kbd>) : This gets the content from 1.0 (beginning) to the end</li>
<li><kbd>my_text.delete</kbd>('<kbd>insert-1c</kbd>', <kbd>INSERT</kbd>) : This deletes a character at the insertion cursor</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Tags</h1>
                
            
            
                
<p>Tags are used to annotate text with an identification string that can then be used to manipulate the tagged text. Tkinter has a built-in tag called <strong>SEL</strong>, which is automatically applied to the selected text. In addition to SEL, you can define your own tags. A text range can be associated with multiple tags, and the same tag can be used for many different text ranges.</p>
<p>Here are some examples of tagging:</p>
<pre>my_text.tag_add('sel', '1.0', 'end') # add SEL tag from start(1.0) to end<br/>my_text.tag_add('danger', "insert linestart", "insert lineend+1c")<br/>my_text.tag_remove('danger', 1.0, "end")<br/>my_text.tag_config('danger', background=red)<br/>my_text.tag_config('outdated', overstrike=1)</pre>
<p>You can specify the visual style for a given tag with <kbd>tag_config</kbd>, using options such as <kbd>background</kbd> (color), <kbd>bgstipple</kbd> (bitmap), <kbd>borderwidth</kbd> (distance), <kbd>fgstipple</kbd> (bitmap), <kbd>font</kbd> (font), <kbd>foreground</kbd> (color), <kbd>justify</kbd> (constant), <kbd>lmargin1</kbd> (distance), <kbd>lmargin2</kbd> (distance), <kbd>offset</kbd> (distance), <kbd>overstrike</kbd><br/>
(flag), <kbd>relief</kbd> (constant), <kbd>rmargin</kbd> (distance), <kbd>spacing1</kbd> (distance), <kbd>tabs</kbd> (string), <kbd>underline</kbd> (flag), and <kbd>wrap</kbd> (constant).</p>
<p>For a complete reference about text indexing and tagging, type the following command into the Python interactive shell:</p>
<pre><strong>&gt;&gt;&gt; import Tkinter</strong><br/><strong>&gt;&gt;&gt; help(Tkinter.Text)</strong></pre>
<p>Equipped with a basic understanding of indexing and tagging, let's implement some more features in the code editor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the Select All feature</h1>
                
            
            
                
<p>We know that Tkinter has a built-in <kbd>sel</kbd> tag that applies a selection to a given text range. We want to apply this tag to the entire text in the widget.</p>
<p>We can simply define a function to handle this, as follows (<kbd>2.05.py</kbd>):</p>
<pre>def select_all(event=None):<br/>  content_text.tag_add('sel', '1.0', 'end')<br/>  return "break"</pre>
<p>After doing this, add a callback to the <kbd>Select All</kbd> menu item:</p>
<pre>edit_menu.add_command(label='Select All', underline=7, accelerator='Ctrl+A', command=select_all)</pre>
<p>We also need to bind the function to the <em>Ctrl</em> + <em>A</em> keyboard shortcut. We do this by using the following key bindings (<kbd>2.05.py</kbd>):</p>
<pre>content_text.bind('&lt;Control-A&gt;', select_all)<br/>content_text.bind('&lt;Control-a&gt;', select_all)</pre>
<p>The coding of the <kbd>Select All</kbd> feature is complete. To try it out, add some text to the text widget and then click on the menu item, <kbd>Select All</kbd>, or use <em>Ctrl</em> + <em>A</em> (<kbd>accelerator</kbd> shortcut key).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the Find Text feature</h1>
                
            
            
                
<p>Next, let's code the <kbd>Find Text</kbd> feature (<kbd>2.05.py</kbd>). The following screenshot shows an example of the <kbd>Find Text</kbd> feature:</p>
<div><img height="211" src="img/e65263f9-ca09-42f9-9550-1d9176729b9c.png" width="314"/></div>
<p>Here's a quick summary of the desired functionality. When a user clicks on the Find menu item, a new Toplevel window opens up. The user enters a search keyword and specifies whether the search needs to be case-sensitive. When the user clicks on the Find All button, all matches are highlighted.</p>
<p>To search through the document, we rely on the <kbd>text_widget.search()</kbd><em> </em>method. The search method takes in the following arguments:</p>
<pre>search(pattern, startindex, stopindex=None, forwards=None, backwards=None, exact=None, regexp=None, nocase=None, count=None)</pre>
<p>For the editor, define a function called <kbd>find_text</kbd> and attach it as a callback to the Find menu (<kbd>2.05.py</kbd>):</p>
<pre>edit_menu.add_command(label='Find',underline= 0, accelerator='Ctrl+F', command=find_text)</pre>
<p>Also, bind it to the <em>Ctrl</em> + <em>F</em> shortcut, as follows:</p>
<pre>content_text.bind('&lt;Control-f&gt;', find_text)<br/>content_text.bind('&lt;Control-F&gt;', find_text) </pre>
<p>Then, define the <kbd>find_text</kbd> function, as follows (<kbd>2.05.py</kbd>):</p>
<pre>def find_text(event=None):<br/>    search_toplevel = Toplevel(root)<br/>    search_toplevel.title('Find Text')<br/>    search_toplevel.transient(root)<br/>    Label(search_toplevel, text="Find All:").grid(row=0, <br/>                                      column=0,sticky='e')<br/>    search_entry_widget = Entry(search_toplevel, width=25)<br/>    search_entry_widget.grid(row=0, column=1, padx=2, pady=2, <br/>    sticky='we')<br/>    search_entry_widget.focus_set()<br/>    ignore_case_value = IntVar()<br/>    .... more code here to crate checkbox and button <br/>    def close_search_window():<br/>       content_text.tag_remove('match', '1.0', END)<br/>       search_toplevel.destroy()<br/>       search_toplevel.protocol('WM_DELETE_WINDOW', <br/>       close_search_window)<br/>       return "break"</pre>
<p>The following is a description of the preceding code (<kbd>2.05.py</kbd>):</p>
<ul>
<li>When a user clicks on the Find menu item, it invokes a <kbd>find_text</kbd> callback.</li>
<li> The first four lines of the <kbd>find_text()</kbd> function create a new Toplevel window, add a window title, specify its geometry (size, shape, and location), and set it as a <em>transient window</em>. Setting it as a transient window means that it is always drawn on top of its parent or root window. If you comment out this line and click on the root editor window, the Find window will go behind the root window.</li>
<li>The next eight lines of code are pretty self-explanatory; they set the widgets of the Find window. They add the Label, Entry, Button, and Checkbutton widgets, and set up the <kbd>search_string</kbd> and <kbd>ignore_case_value</kbd> variables to track the value a user enters into the Entry widget and whether the user has checked off Checkbutton. The widgets are arranged by using the grid geometry manager to fit into the Find window.</li>
<li>The Find All button has a command option that calls a <kbd>search_output</kbd> function, passing the search string as the first argument and whether the search needs to be case-sensitive as its second argument. The third, fourth, and fifth arguments pass the Toplevel window, the Text widget, and the Entry widget as parameters.</li>
<li>We override the Close button of the Find window and redirect it to a callback named <kbd>close_search()</kbd>. The <kbd>close_search</kbd> function is defined within the <kbd>find_text</kbd> function. This function takes care of removing the match tag that was added during the search. If we do not override the Close button and remove these tags, the matched string will continue to be marked in red and yellow even after the search has ended.</li>
</ul>
<p>Next, we define the <kbd>search_output</kbd> function, which does the actual searching and adds the match tag to the matching text. The code for this is as follows:</p>
<pre>def search_output(needle, if_ignore_case, content_text,<br/> search_toplevel, search_box):<br/> content_text.tag_remove('match', '1.0', END)<br/> matches_found = 0<br/> if needle:<br/>   start_pos = '1.0'<br/>   while True:<br/>      start_pos = content_text.search(needle, start_pos,<br/>           nocase=if_ignore_case, stopindex=END)<br/>      if not start_pos:<br/>           break<br/>      end_pos = '{}+{}c'.format(start_pos, len(needle))<br/>      content_text.tag_add('match', start_pos, end_pos)<br/>      matches_found += 1<br/>      start_pos = end_pos<br/>   content_text.tag_config('match', foreground='red', background='yellow')<br/> search_box.focus_set()<br/> search_toplevel.title('{} matches found'.format(matches_found))</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>This part of the code is the heart of the <kbd>search</kbd> function. It searches through the entire document by using the <kbd>while True</kbd> loop, breaking out of the loop only if no more text items remain to be searched.</li>
<li>The code first removes the previous search-related match tags if there are any, as we do not want to append the results of the new search to the previous search results. The function uses the <kbd>search()</kbd> method, which is provided in Tkinter in the Text widget. The <kbd>search()</kbd> method takes the following arguments:</li>
</ul>
<pre class="mce-root">      search(pattern, index, stopindex=None, forwards=None,<br/>      backwards=None, exact=None, regexp=None, nocase=None, count=None)</pre>
<ul>
<li>The <kbd>search()</kbd> method returns the starting position of the first match. We store it in a variable named <kbd>start_pos</kbd>, calculate the position of the last character in the matched word, and store it in the <kbd>end_pos</kbd> variable.</li>
<li>For every search match that it finds, it adds the match tag to the text ranging from the first position to the last position. After every match, we set the value of <kbd>start_pos</kbd> to be equal to <kbd>end_pos</kbd>. This ensures that the next search starts after <kbd>end_pos</kbd>.</li>
<li>The loop also keeps track of the number of matches by using the <kbd>count</kbd> variable.</li>
<li>Outside the loop, the tag match is configured to have a red font and yellow background. The last line of this function updates the title of the Find window with the number of matches that were found.</li>
</ul>
<p>In case of event bindings, interaction occurs between input devices (keyboard/mouse) and your application. In addition to event binding, Tkinter also supports protocol handling.<br/>
The term protocol refers to the interaction between your application and the window manager. An example of a protocol is <kbd>WM_DELETE_WINDOW</kbd>, which handles the close window event for your window manager.<br/>
Tkinter lets you override these protocol handlers by mentioning your own handler for the root or Toplevel widget. To override the window exit protocol, we use the following command:<br/>
<kbd>root.protocol(WM_DELETE_WINDOW, callback)</kbd><br/>
Once you add this command, Tkinter reroutes protocol handling to the specified callback/handler.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Types of Toplevel window</h1>
                
            
            
                
<p>Previously in this chapter, we used the following line of code:</p>
<pre>search_toplevel.transient(root)</pre>
<p>Let's explore what it means here. Tkinter supports the following four types of Toplevel window:</p>
<ul>
<li><strong>The main Toplevel window</strong>: This is the type we have been constructing so far.</li>
<li><strong>The child Toplevel window</strong>: This type is independent of the root. The Toplevel child behaves independently of its root, but it gets destroyed if its parent is destroyed.</li>
<li><strong>The transient Toplevel window:</strong> This always appears at the top of its parent, but it does not entirely grab the focus. Clicking again on the parent window allows you to interact with it. The transient window is hidden when the parent is minimized, and it is destroyed if the parent is destroyed. Compare this to what is called a <strong>modal window</strong>. A modal window grabs all the focus from the parent window and asks a user to first close the modal window before regaining access to the parent window.</li>
<li><strong>The undecorated Toplevel window:</strong> A Toplevel window is undecorated if it does not have a window manager decoration around it. It is created by setting the <strong>overrideredirect</strong> flag to <kbd>1</kbd>. An undecorated window cannot be resized or moved.</li>
</ul>
<p>Refer to the <kbd>2.06.py</kbd> code for a demonstration of all four types of Toplevel window.</p>
<p>This concludes our second iteration. Congratulations! We have completed coding the <kbd>Select All</kbd> and <kbd>Find Text</kbd> functionality into our program.</p>
<p>More importantly, you have been introduced to indexing and tagging—two very powerful concepts associated with many Tkinter widgets. You will find yourself using these two concepts all the time in your projects.</p>
<p>We also explored the four types of Toplevel window and the use cases for each of them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with forms and dialogs</h1>
                
            
            
                
<p>The goal for this iteration is to implement the functionality of the File menu options: Open, Save, and Save As.</p>
<p>We can implement these dialogs by using the standard Tkinter widgets. However, since these are so commonly used, a specific Tkinter module called <kbd>filedialog</kbd> has been included in the standard Tkinter distribution.</p>
<p>Here's an example of a typical <kbd>filedialog</kbd>:</p>
<div><img height="239" src="img/a40730bd-4116-4362-9a5d-1f382b377be3.png" width="362"/></div>
<p>Tkinter defines the following common use cases for <kbd>filedialogs</kbd>:</p>
<table>
<tbody>
<tr>
<td><strong>Functions</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>askopenfile</kbd></td>
<td>This returns the opened file object</td>
</tr>
<tr>
<td><kbd>askopenfilename</kbd></td>
<td>This returns the filename string, not the opened file object</td>
</tr>
<tr>
<td><kbd>askopenfilenames</kbd></td>
<td>This returns a list of filenames</td>
</tr>
<tr>
<td><kbd>askopenfiles</kbd></td>
<td>This returns a list of open file objects or an empty list if<br/>
Cancel is selected</td>
</tr>
<tr>
<td><kbd>asksaveasfile</kbd></td>
<td>This asks for a filename to save as and returns the opened<br/>
file object</td>
</tr>
<tr>
<td><kbd>asksaveasfilename</kbd></td>
<td>This asks for a filename to save as and returns the filename</td>
</tr>
<tr>
<td><kbd>askdirectory</kbd></td>
<td>This asks for a directory and returns the directory name</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The usage is simple. Import the <kbd>filedialog</kbd> module and call the required function. Here's an example:</p>
<pre>import tkinter.filedialog</pre>
<p>We then call the required function using the following code:</p>
<pre>file_object = tkinter.filedialog.askopenfile(mode='r')</pre>
<p>Or, we use this code:</p>
<pre>my_file_name = tkinter.filedialog.askopenfilename()</pre>
<p>The <kbd>mode='r'</kbd> option specified in the preceding code is one of many configurable options that are available for dialogs. </p>
<p>You can specify the following additional options for <kbd>filedialog</kbd>:</p>
<table>
<tbody>
<tr>
<td><strong>File dialog</strong></td>
<td><strong>Configurable options</strong></td>
</tr>
<tr>
<td><kbd>askopenfile</kbd><br/>
(<kbd>mode='r'</kbd>, <kbd>**options</kbd>)</td>
<td><kbd>parent</kbd>, <kbd>title</kbd>, <kbd>message</kbd>, <kbd>defaultextension</kbd>, <kbd>filetypes</kbd>, <kbd>initialdir</kbd>, <kbd>initialfile</kbd>, and multiple</td>
</tr>
<tr>
<td><kbd>askopenfilename</kbd><br/>
(<kbd>**options</kbd>)</td>
<td><kbd>parent</kbd>, <kbd>title</kbd>, <kbd>message</kbd>, <kbd>defaultextension</kbd>, <kbd>filetypes</kbd>, <kbd>initialdir</kbd>, <kbd>initialfile</kbd>, and multiple</td>
</tr>
<tr>
<td><kbd>asksaveasfile</kbd><br/>
(<kbd>mode='w'</kbd>, <kbd>**options</kbd>)</td>
<td><kbd>parent</kbd>, <kbd>title</kbd>, <kbd>message</kbd>, <kbd>defaultextension</kbd>, <kbd>filetypes</kbd>, <kbd>initialdir</kbd>, <kbd>initialfile</kbd>, and multiple</td>
</tr>
<tr>
<td><kbd>asksaveasfilename</kbd><br/>
(<kbd>**options</kbd>)</td>
<td><kbd>parent</kbd>, <kbd>title</kbd>, <kbd>message</kbd>, <kbd>defaultextension</kbd>, <kbd>filetypes</kbd>, <kbd>initialdir</kbd>, <kbd>initialfile</kbd>, and multiple</td>
</tr>
<tr>
<td><kbd>askdirectory</kbd><br/>
(<kbd>**options</kbd>)</td>
<td><kbd>parent</kbd>, <kbd>title</kbd>, and <kbd>initialdir</kbd> must exist</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Equipped with a basic understanding of the <kbd>filedialog</kbd> module, let's now have a look at its practical usage. We'll begin by implementing the File | Open feature. </p>
<p>Let's start by importing the required modules, as follows:</p>
<pre>import tkinter.filedialog<br/>import os # for handling file operations</pre>
<p>Next, let's create a global variable, which will store the name of the currently open file, as follows:</p>
<pre>file_name = None</pre>
<p>The use of global variables is generally considered bad programming practice because it is very difficult to understand a program that uses lots of global variables.<br/>
A global variable can be modified or accessed from many different places in the program. Therefore, it becomes difficult to remember or work out every possible use of the variable.<br/>
A global variable is not subject to access control, which may pose security hazards in certain situations, say when this program needs to interact with third-party code.<br/>
However, when you work on programs in a procedural style such as this one, global variables are sometimes unavoidable.<br/>
An alternative approach to programming involves writing code in a class structure (also called object-oriented programming), where a variable can only be accessed by members of predefined classes. We will see a lot of examples of object-oriented programming in the chapters that follow.</p>
<p>The following code is present in <kbd>open_file</kbd> (<kbd>2.07.py</kbd>):</p>
<pre>def open_file(event=None):<br/>   input_file_name = <br/>     tkinter.filedialog.askopenfilename(defaultextension=".txt", <br/>       filetypes=[("All Files", "*.*"),("Text Documents", "*.txt")])<br/>   if input_file_name:<br/>     global file_name<br/>     file_name = input_file_name<br/>     root.title('{} - {}'.format(os.path.basename(file_name),PROGRAM_NAME))<br/>     content_text.delete(1.0, END)<br/>     with open(file_name) as _file:<br/>       content_text.insert(1.0, _file.read())<br/>     on_content_changed()</pre>
<p>Modify the Open menu to add a callback command to this newly defined method, as follows:</p>
<pre>file_menu.add_command(label='Open', accelerator='Ctrl+O', compound='left', image=open_file_icon, underline =0, command=open_file)</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>We declared a <kbd>file_name</kbd> variable in the <kbd>global</kbd> scope to keep track of the filename of the opened file. This is required to keep track of whether a file has been opened. We need this variable in the <kbd>global</kbd> scope as we want this variable to be available to other methods, such as <kbd>save()</kbd> and <kbd>save_as()</kbd>.</li>
<li>Not specifying it as <kbd>global</kbd> would mean that it is only available within the function. So, the <kbd>save()</kbd> and <kbd>save_as()</kbd> functions would not be able to check whether a file is already open in the editor.</li>
<li>We use <kbd>askopenfilename</kbd> to fetch the filename of the opened file. If a user cancels opening the file or no file is chosen, the <kbd>file_name</kbd> returned is <kbd>None</kbd>. In that case, we do nothing. </li>
<li>However, if <kbd>filedialog</kbd> returns a valid filename, we isolate the filename using the <kbd>os</kbd> module and add it as the title of the root window.</li>
<li>If the <kbd>Text</kbd> widget already contains some text, we delete it all.</li>
<li>We then open the given file in read mode and insert its content into the Content widget.</li>
<li>We use the context manager (the <kbd>with</kbd> command), which takes care of closing the file properly for us, even in the case of an exception.</li>
<li>Finally, we add a command callback to the File | Open menu item.</li>
</ul>
<p>This completes the coding of File | Open. If you now navigate to File | Open, select a text file, and click on Open, the content area will be populated with the content of the text file.</p>
<p>Next, we will have a look at how to save a file. There are two aspects to saving a file:</p>
<ul>
<li>Save</li>
<li>Save As</li>
</ul>
<p>If the Content text widget already contains a file, we do not prompt the user for a filename. We simply overwrite the contents of the existing file. If there is no filename associated with the current content of the text area, we prompt the user with a Save As dialog. Moreover, if the text area has an open file and the user clicks on Save As, we still prompt them with a Save As dialog to allow them to write the contents to a different filename.</p>
<p>The code for <kbd>save</kbd> and <kbd>save_as</kbd> is as follows (<kbd>2.07.py</kbd>):</p>
<pre>def save(event=None):<br/> global file_name<br/> if not file_name:<br/>    save_as()<br/> else:<br/>    write_to_file(file_name)<br/> return "break"<br/> <br/>def save_as(event=None):<br/> input_file_name = tkinter.filedialog.asksaveasfilename<br/>   (defaultextension=".txt", filetypes=[("All Files", "*.*"),<br/>   ("Text Documents", "*.txt")])<br/> if input_file_name:<br/>     global file_name<br/>     file_name = input_file_name<br/>     write_to_file(file_name)<br/>    root.title('{} - {}'.format(os.path.basename(file_name),PROGRAM_NAME))<br/> return "break"<br/> <br/>def write_to_file(file_name):<br/>    try:<br/>      content = content_text.get(1.0, 'end')<br/>      with open(file_name, 'w') as the_file:<br/>        the_file.write(content)<br/>    except IOError:<br/>      pass  <br/>      # pass for now but we show some warning - we do this in next section</pre>
<p>Having defined the <kbd>save</kbd> and <kbd>save_as</kbd> functions, let's connect them to the respective menu callback:</p>
<pre>file_menu.add_command(label='Save', accelerator='Ctrl+S',  compound='left', image=save_file_icon,underline=0, command= save)<br/>file_menu.add_command(label='Save as',    accelerator='Shift+Ctrl+S', command= save_as)</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>The <kbd>save</kbd> function first tries to check whether a file is open. If a file is open, it simply overwrites the contents of the file with the current contents of the text area. If no file is open, it simply passes the work to the <kbd>save_as</kbd> function.</li>
<li>The <kbd>save_as</kbd> function opens a dialog by using <kbd>asksaveasfilename</kbd> and tries to get the filename provided by the user for the given file. If it succeeds, it opens the new file in write mode and writes the contents of the text under this new filename. After writing, it closes the current file object and changes the title of the window to reflect the new filename.</li>
<li>If the user does not specify a filename or the user cancels the <kbd>save_as</kbd> operation, it simply ignores the process by using a pass command.</li>
<li>We added a <kbd>write_to_file(file_name)</kbd> helper function to do the actual writing to the file.</li>
</ul>
<p>While we are at it, let's complete the functionality of File | New. The code is simple (<kbd>2.07.py</kbd>):</p>
<pre>def new_file(event=None):<br/>   root.title("Untitled")<br/>   global file_name<br/>   file_name = None<br/>   content_text.delete(1.0,END) </pre>
<p>Now, add a callback command to this new function to the File | New menu item:</p>
<pre>file_menu.add_command(label='New', accelerator='Ctrl+N', compound='left', image=new_file_icon, underline=0, command=new_file)</pre>
<p>The following is a description of the preceding code:</p>
<ol>
<li>The <kbd>new_file</kbd> function begins by changing the title attribute of the root window to <kbd>Untitled</kbd>.</li>
<li>It then sets the value of the <kbd>global</kbd> filename variable to <kbd>None</kbd>. This is important because the <kbd>save</kbd> and <kbd>save_as</kbd> functionalities use this global variable name to track whether the file already exists or is new.</li>
<li>The function then deletes all the contents of the <kbd>Text</kbd> widget, creating a fresh document in its place.</li>
</ol>
<p>Let's wrap up this iteration by adding keyboard shortcuts for the newly created features (<kbd>2.07.py</kbd>):</p>
<pre>content_text.bind('&lt;Control-N&gt;', new_file)<br/>content_text.bind('&lt;Control-n&gt;', new_file)<br/>content_text.bind('&lt;Control-O&gt;', open_file)<br/>content_text.bind('&lt;Control-o&gt;', open_file)<br/>content_text.bind('&lt;Control-S&gt;', save)<br/>content_text.bind('&lt;Control-s&gt;',save)</pre>
<p>In this iteration, we implemented the coding functionality for the New, Open, Save, and Save As menu items.  More importantly, we saw how to use the <kbd>filedialog</kbd> module to achieve certain commonly used file features in the program. We also had a look at how to use indexing to achieve a wide variety of tasks for programs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with message boxes</h1>
                
            
            
                
<p>Now, let's complete the code for the About and Help menus. The functionality is simple. When a user clicks on the Help or About menu, a message window pops up and waits for the user to respond by clicking on a button. Though we can easily code new Toplevel windows to show the About and Help messages, we will instead use a module called <kbd>messagebox</kbd> to achieve this functionality.</p>
<p>The <kbd>messagebox</kbd> module provides ready-made message boxes to display a wide variety of messages in applications. The functions available through this module include <kbd>showinfo</kbd>, <kbd>showwarning</kbd>, <kbd>showerror</kbd>, <kbd>askquestion</kbd>, <kbd>askokcancel</kbd>, <kbd>askyesno</kbd>, <kbd>askyesnocancel</kbd>, and <kbd>askretrycancel</kbd>, as shown in the following screenshot:</p>
<div><img src="img/2cf16643-5cbb-4ba8-ab6a-fd7bd085e4e3.png"/></div>
<p>To use this module, we simply import it into the current namespace by using the following command:</p>
<pre>import tkinter.messagebox </pre>
<p>A demonstration of the commonly used functions of <kbd>messagebox</kbd> is provided in <kbd>2.08.py</kbd> in the code bundle. The following are some common usage patterns:</p>
<pre> import tkinter.messagebox as tmb<br/> tmb.showinfo(title="Show Info", message="This is FYI")<br/> tmb.showwarning(title="Show Warning", message="Don't be silly")<br/> tmb.showerror(title="Show Error", message="It leaked")<br/> tmb.askquestion(title="Ask Question", message="Can you read this?")<br/> tmb.askokcancel(title="Ask OK Cancel", message="Say Ok or Cancel?")<br/> tmb.askyesno(title="Ask Yes-No", message="Say yes or no?")<br/> tmb.askyesnocancel(title="Yes-No-Cancel", message="Say yes no cancel")<br/> tmb.askretrycancel(title="Ask Retry Cancel", message="Retry or what?")</pre>
<p>Equipped with an understanding of the <kbd>messagebox</kbd> module, let's code the <kbd>about</kbd> and <kbd>help</kbd> functions for the code editor. The functionality is simple. When a user clicks on the About or Help menu item, a <kbd>showinfomessagebox</kbd> pops up.</p>
<p>To achieve this, include the following code in the editor (<kbd>2.09.py</kbd>):</p>
<pre>def display_about_messagebox(event=None):<br/>     tkinter.messagebox.showinfo("About", "{}{}".format(PROGRAM_NAME,                     <br/>       "\nTkinter GUI Application\n Development Blueprints"))<br/> <br/><br/>def display_help_messagebox(event=None):<br/>     tkinter.messagebox.showinfo("Help", "Help Book: \nTkinter GUI                           <br/>       Application\n Development Blueprints", icon='question')</pre>
<p>Then, attach these functions to the respective menu items, as follows:</p>
<pre>about_menu.add_command(label='About', command=display_about_messagebox)<br/>about_menu.add_command(label='Help', command=display_help_messagebox)</pre>
<p>Next, we will add the quit confirmation feature. Ideally, we should have implemented file saving in the event the text content has been modified, but for the sake of simplicity I am not putting in that logic here and instead am displaying a prompt for the user to determine whether the program should be closed or kept open. Accordingly, when the user clicks on File | Exit, it prompts an Ok-Cancel dialog to confirm the quit action:</p>
<pre>def exit_editor(event=None):<br/>       if tkinter.messagebox.askokcancel("Quit?", "Really quit?"):<br/>            root.destroy() </pre>
<p>Then, we override the Close button and redirect it to the <kbd>exit_editor</kbd> function that we previously defined, as follows:</p>
<pre>root.protocol('WM_DELETE_WINDOW', exit_editor)</pre>
<p>Then, we add a callback command for all the individual menu items, as follows:</p>
<pre>file_menu.add_command(label='Exit', accelerator='Alt+F4', command= exit_editor)<br/>about_menu.add_command(label='About', command = display_about_messagebox)<br/>about_menu.add_command(label='Help', command = display_help_messagebox)</pre>
<p>Finally, add the bindings for the keyboard shortcut to display help: </p>
<pre>content_text.bind('&lt;KeyPress-F1&gt;', display_help_messagebox) </pre>
<p>This completes the iteration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The icons toolbar and View menu functions</h1>
                
            
            
                
<p>In this iteration, we will add the following functionalities to the text editor:</p>
<ul>
<li>Showing shortcut icons on the toolbar</li>
<li>Displaying line numbers</li>
<li>Highlighting the current line</li>
<li>Changing the color theme of the editor</li>
</ul>
<p>Let's start with a simple task first. In this step, we will add shortcut icons to the toolbar, as shown in the following screenshot:</p>
<div><img height="167" src="img/2d7d1652-4c63-4c07-aaf7-a13eb4683fa3.png" width="302"/></div>
<p>You may recall that we have already created a frame to hold these icons. Let's add these icons now.</p>
<p>While adding these icons, we have followed a convention. The icons have been named exactly the same as the corresponding function that handles them. Following this convention has enabled us to loop through a list, simultaneously apply the icon image to each button, and add the command callback from within the loop. All the icons have been placed in the icons folder.</p>
<p>The following code adds icons to the toolbar (<kbd>2.10.py</kbd>):</p>
<pre>icons = ('new_file', 'open_file', 'save', 'cut', 'copy', 'paste', 'undo', 'redo', 'find_text')<br/>for i, icon in enumerate(icons):<br/>   tool_bar_icon = PhotoImage(file='icons/{}.gif'.format(icon))<br/>   cmd = eval(icon)<br/>   tool_bar = Button(shortcut_bar, image=tool_bar_icon, command=cmd)<br/>   tool_bar.image = tool_bar_icon<br/>   tool_bar.pack(side='left')</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>We have already created a shortcut bar in the first iteration. Now, we will simply add buttons with images in the frame.</li>
<li>We create a list of icons, taking care to name them exactly the same as the name of the icons.</li>
<li>We then loop through the list by creating a Button widget, adding an image to the button, and adding the respective callback command.</li>
<li>Before adding the callback command, we have to convert the string to an equivalent expression by using the <kbd>eval</kbd> command. If we do not apply <kbd>eval</kbd>, it cannot be applied as an expression to the callback command.</li>
</ul>
<p>Thus, we've added shortcut icons to the shortcut bar. Now, if you run the code (refer to <kbd>2.10.py</kbd> in the code bundle), it should show all of the shortcut icons. Moreover, as we have linked each button to its callback, all of these shortcut icons should work.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying line numbers</h1>
                
            
            
                
<p>Let's work toward showing line numbers to the left of the Text widget. This will require us to tweak the code in various places. So, before we start coding, let's look at what we are trying to achieve.</p>
<p>The View menu has a menu item that allows users to choose whether to Show Line Number. We only want to show line numbers if the option is selected, as shown in the following screenshot:</p>
<div><img src="img/326c66d9-eb54-493f-b0f0-4630f1b38235.png"/></div>
<p>If the option is selected, we need to display line numbers in the left frame that we created earlier.</p>
<p>The line number should update every time a user enters a new line, deletes a line, cuts or pastes line text, performs an undo or a redo operation, opens an existing file, or clicks on the New menu item. In short, the line number should be updated after every activity results in a change of content. Therefore, we need to define a function called <kbd>on_content_changed()</kbd>. This function should be called after the definitions of every <kbd>press</kbd>, <kbd>cut</kbd>, <kbd>paste</kbd>, <kbd>undo</kbd>, <kbd>redo</kbd>, <kbd>new</kbd>, and <kbd>open</kbd> key, to check whether lines have been added or removed from the text area and accordingly update the line numbers.</p>
<p>We achieve this by using the following two strategies (refer to <kbd>2.10.py</kbd> in the code bundle):</p>
<pre>def on_content_changed(event=None):<br/>     update_line_numbers() </pre>
<p>Bind a key press event to the <kbd>update_line_number()</kbd> function, as follows:</p>
<pre>content_text.bind('&lt;Any-KeyPress&gt;', on_content_changed) </pre>
<p>Next, add a call to the <kbd>on_content_changed()</kbd> function in each of the definitions of <kbd>cut</kbd><em>,</em> <kbd>paste</kbd><em>,</em> <kbd>undo</kbd><em>,</em> <kbd>redo</kbd><em>,</em> <kbd>new</kbd><em>,</em> and <kbd>open</kbd><em>.</em></p>
<p>Then define a <kbd>get_line_numbers()</kbd> function that returns a string containing all the numbers until the last row, separated by line breaks.</p>
<p>So for instance, if the last non-empty row in the content widget is <kbd>5</kbd>, this function returns us a string of the <kbd>1 /n 2 /n 3 /n 4/n 5 /n</kbd> form.</p>
<p>The following is the function definition:</p>
<pre>def get_line_numbers():<br/>  output = ''<br/>  if show_line_number.get():<br/>    row, col = content_text.index("end").split('.')<br/>    for i in range(1, int(row)):<br/>      output += str(i)+ '\n'<br/>  return output </pre>
<p>Now, let's define the <kbd>update_line_numbers()</kbd> function, which simply updates the text widget that displays the line using the string output from the previous function:</p>
<pre>def update_line_numbers(event = None):<br/>   line_numbers = get_line_numbers()<br/>   line_number_bar.config(state='normal')<br/>   line_number_bar.delete('1.0', 'end')<br/>   line_number_bar.insert('1.0', line_numbers)<br/>   line_number_bar.config(state='disabled')</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>You may recall that we assigned a <kbd>show_line_number</kbd> variable to the menu item earlier:<br/>
<kbd>show_line_number = IntVar()</kbd><br/>
<kbd>show_line_number.set(1)</kbd><br/>
<kbd>view_menu.add_checkbutton(label="Show Line Number", variable=show_line_number)</kbd></li>
<li>If the <kbd>show_line_number</kbd> option is set to <kbd>1</kbd> (that is to say, it has been checked off in the menu item), we calculate the last line and last column in the text.</li>
<li>We then create a text string consisting of numbers from <kbd>1</kbd> to the number of the last line, with each number separated by a line break (<kbd>\n</kbd>). This string is then added to the left label by using the <kbd>line_number_bar.config()</kbd> method.</li>
<li>If <kbd>Show Line Number</kbd> is unchecked in the menu, the variable text remains blank, thereby displaying no line numbers.</li>
<li>Finally, we update each of the previously defined <kbd>cut</kbd>, <kbd>paste</kbd>, <kbd>undo</kbd>, <kbd>redo</kbd>, <kbd>new</kbd>, and <kbd>open</kbd> functions to invoke the <kbd>on_content_changed()</kbd> function at its end.</li>
</ul>
<p>We have finished adding the line number functionality to the text editor. However, I would like to add that this implementation, though simple, has some limitations in that it does not handle word wrapping and font size variability very well. A foolproof line numbering solution would require the use of the Canvas widget – something that we discuss Chapter 4 Game of Chess and onward. Meanwhile, if you are curious, take a look at a sample Canvas-based implementation at <a href="https://stackoverflow.com/a/16375233/2348704">https://stackoverflow.com/a/16375233/2348704</a>.</p>
<p>Lastly, in this iteration, we will implement a feature where a user can choose to highlight the current line (<kbd>2.10.py</kbd>).</p>
<p>The idea is simple. We need to locate the line of the cursor and add a tag to the line. We also need to configure the tag so that it appears with a differently colored background to highlight it.</p>
<p>You may recall that we have already provided a menu choice to users to decide whether to highlight the current line. We will now add a callback command from this menu item to a function that we will define as <kbd>toggle_highlight</kbd>:</p>
<pre>to_highlight_line = BooleanVar()<br/>view_menu.add_checkbutton(label='Highlight Current Line', onvalue=1, offvalue=0,     variable=to_highlight_line, command=toggle_highlight)</pre>
<p>Now, we define three functions to handle this for us:</p>
<pre>def highlight_line(interval=100):<br/>   content_text.tag_remove("active_line", 1.0, "end")<br/>   content_text.tag_add("active_line", <br/>                     "insert linestart", "insert lineend+1c")                                                                               <br/>   content_text.after(interval, toggle_highlight)<br/><br/>def undo_highlight():<br/>   content_text.tag_remove("active_line", 1.0, "end")<br/><br/>def toggle_highlight(event=None):<br/>   if to_highlight_line.get():<br/>      highlight_line()<br/>    else:<br/>      undo_highlight()<br/> </pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>Every time a user checks/unchecks View | Highlight Current Line, this invokes the <kbd>toggle_highlight</kbd> function. This function checks whether the menu item is checked. If it is checked, it invokes the <kbd>highlight_line</kbd> function. Otherwise, if the menu item is unchecked, it invokes the <kbd>undo_highlight</kbd> function.</li>
<li>The <kbd>highlight_line</kbd> function simply adds a tag called <kbd>active_line</kbd> to the current line, and after every 100 milliseconds it calls the <kbd>toggle_highlight</kbd> function to check whether the current line should still be highlighted.</li>
<li>The <kbd>undo_highlight</kbd> function is invoked when the user unchecks highlighting in the View menu. Once invoked, it simply removes the <kbd>active_line</kbd> tag from the entire text area. </li>
</ul>
<p>Finally, we can configure the tag named <kbd>active_line</kbd> so that it is displayed with a different background color, as follows:</p>
<pre>content_text.tag_configure('active_line', background='ivory2')</pre>
<p>We used the <kbd>.widget.after(ms, callback)</kbd> handler in the code.<br/>
Methods that let us perform some periodic actions are called alarm handlers. The following are some commonly used Tkinter alarm handlers:<br/>
• <kbd>after(delay_ms, callback, args...)</kbd>: This registers a callback alarm, which can be called after a given number of milliseconds.<br/>
• <kbd>after_cancel(id)</kbd>: This cancels the given callback alarm.<br/>
• <kbd>after_idle(callback, args...)</kbd>: This calls back only when there are no more events to process in <kbd>mainloop</kbd>; that is, after the system becomes idle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the cursor information bar</h1>
                
            
            
                
<p>The cursor information bar is simply a small label at the bottom-right corner of the Text widget that displays the current position of the cursor, as shown in the following screenshot:</p>
<div><img src="img/1028f9ca-8c45-4c73-a0a3-05b66c6c3bc8.png"/></div>
<p>The user can choose to show/hide this info bar from the View menu (<kbd>2.11.py</kbd>).</p>
<p>Begin by creating a Label widget within the Text widget and pack it in the bottom-right corner, as follows:</p>
<pre>cursor_info_bar = Label(content_text, text='Line: 1 | Column: 1')<br/>cursor_info_bar.pack(expand=NO, fill=None, side=RIGHT, anchor='se')</pre>
<p>In many ways, this is similar to displaying line numbers. Here, too, the positions must be calculated after every keystroke, after events such as <kbd>cut</kbd>, <kbd>paste</kbd>, <kbd>undo</kbd>, <kbd>redo</kbd>, <kbd>new</kbd>, and <kbd>open</kbd>, or activities that lead to a change in cursor positions. Because this too needs to be updated for all the changed content, for every keystroke, we will update <kbd>on_content_changed</kbd> to update this, as follows:</p>
<pre>def on_content_changed(event=None):<br/> update_line_numbers()<br/> update_cursor_info_bar()<br/> <br/>def show_cursor_info_bar():<br/> show_cursor_info_checked = show_cursor_info.get()<br/> if show_cursor_info_checked:<br/>   cursor_info_bar.pack(expand='no', fill=None, side='right', anchor='se')<br/> else:<br/>   cursor_info_bar.pack_forget()<br/><br/>def update_cursor_info_bar(event=None):<br/> row, col = content_text.index(INSERT).split('.')<br/> line_num, col_num = str(int(row)), str(int(col)+1) # col starts at 0<br/> infotext = "Line: {0} | Column: {1}".format(line_num, col_num)<br/> cursor_info_bar.config(text=infotext)</pre>
<p>The code is simple. We get the row and column for the current cursor position by using the <kbd>index(INSERT)</kbd> method and update the labels with the latest row and column of the cursor.</p>
<p>Finally, the function is connected to the existing menu item by using a callback command:</p>
<pre>view_menu.add_checkbutton(label='Show Cursor Location at Bottom',<br/>                 variable=show_cursor_info, command=show_cursor_info_bar)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding themes</h1>
                
            
            
                
<p>You may recall that, while defining the Themes menu, we defined a color scheme dictionary containing the name and hexadecimal color codes as a key-value pair, as follows:</p>
<pre>color_schemes = {<br/>'Default': '#000000.#FFFFFF',<br/>'Greygarious':'#83406A.#D1D4D1',<br/>'Aquamarine': '#5B8340.#D1E7E0',<br/>'Bold Beige': '#4B4620.#FFF0E1',<br/>'Cobalt Blue':'#ffffBB.#3333aa',<br/>'Olive Green': '#D1E7E0.#5B8340',<br/>'Night Mode': '#FFFFFF.#000000',<br/>}</pre>
<p>The theme choice menu has already been defined. Let's add a callback command to handle the selected menu (<kbd>2.12.py</kbd>):</p>
<p><kbd>themes_menu.add_radiobutton(label=k, variable=theme_choice, command=change_theme)</kbd>.</p>
<p>Finally, let's define the <kbd>change_theme</kbd> function to handle the changing of themes, as follows:</p>
<pre>def change_theme(event=None):<br/>   selected_theme = theme_choice.get()<br/>   fg_bg_colors = color_schemes.get(selected_theme)<br/>   foreground_color, background_color = fg_bg_colors.split('.')<br/>   content_text.config(background=background_color, fg=foreground_color)</pre>
<p>The function is simple. It picks up the key-value pair from the defined color scheme dictionary. It splits the color into its two components and applies one color each to the Text widget foreground and background using <kbd>widget.config()</kbd>.</p>
<p>Now, if you select a different color from the Themes menu, the background and foreground colors change accordingly.</p>
<p>This completes the iteration. We completed coding the shortcut icon toolbar and the functionality of the View menu in this iteration. In the process, we learned how to handle the <kbd>Checkbutton</kbd> and <kbd>Radiobutton</kbd> menu items. We also had a look at how to create compound buttons while reinforcing several Tkinter options that were covered in the previous sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a context/pop-up menu</h1>
                
            
            
                
<p>Let's complete the editor in this final iteration by adding a contextual menu to the editor <em>(</em><kbd>2.12.py</kbd>)<em>,</em> as shown in the following screenshot:</p>
<div><img height="232" src="img/e8870938-b80e-4be4-b902-e2af2920b8ed.png" width="216"/></div>
<p>The menu that pops up on a right-click at the location of the cursor is called the <strong>context menu</strong> or the <strong>pop-up menu</strong>.</p>
<p>Let's code this feature in the text editor. First, define the context menu, as follows:</p>
<pre>popup_menu = Menu(content_text)<br/>for i in ('cut', 'copy', 'paste', 'undo', 'redo'):<br/>      cmd = eval(i)<br/>     popup_menu.add_command(label=i, compound='left', command=cmd)<br/>     popup_menu.add_separator()<br/>popup_menu.add_command(label='Select All',underline=7, command=select_all)</pre>
<p>Then, bind the right-click of a mouse with a callback named <kbd>show_popup_menu</kbd>, as follows:</p>
<pre>content_text.bind('&lt;Button-3&gt;', show_popup_menu)</pre>
<p>Finally, define the <kbd>show_popup_menu</kbd> function in the following way:</p>
<pre>def show_popup_menu(event):<br/>  popup_menu.tk_popup(event.x_root, event.y_root)</pre>
<p>You can now right-click anywhere on the Text widget in the editor to open the contextual menu.</p>
<p>This concludes the iteration as well as the chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered the following points:</p>
<ul>
<li>We completed coding the editor in twelve iterations. We started by placing all the widgets on the Toplevel window.</li>
<li>We then leveraged some built-in features of the Text widget to code some functionality.</li>
<li>We learned the important concepts of indexing and tagging. </li>
<li>We also saw how to use the <kbd>filedialog</kbd> and <kbd>messagebox</kbd> modules to quickly code some common features in programs.</li>
</ul>
<p>Congratulations! You completed coding your text editor. In the next chapter, we will make a programmable drum machine.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QA section</h1>
                
            
            
                
<p>Here are a few questions to reflect upon:</p>
<ul>
<li>What's the difference between the Checkbutton menu item and the Radio button menu item? </li>
<li>What's the Cascade menu button used for? </li>
<li>Identify different kinds of Toplevel window. </li>
<li>List the different types of <kbd>filedialogs</kbd> and message boxes available in Tkinter. </li>
<li>We used the pack geometry manager to build this text editor. Could we have built this using the grid geometry manager? How would the grid geometry manager fare against pack?</li>
<li>How can we trigger events without an external stimulus in Tkinter?</li>
<li>What are accelerator options in menu items?</li>
<li>What is a transient window?</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>The source code for the <kbd>filedialog</kbd> module can be found within the Tkinter source code in a separate file named <kbd>filedialog.py</kbd>. You are encouraged to take a look at its implementation.</p>
<p>If you are feeling adventurous and want to further explore the Text Editor program, I encourage you to have a look at the source code for Python's built-in editor named IDLE, which is written in Tkinter. The source code for IDLE can be found in your local Python library directory in a folder called <kbd>idlelib</kbd>. On Linux Mint, this is located at <kbd>/usr/lib/python3.4/idlelib</kbd>.</p>
<p>Read the official Python styling guide, which is specified in the PEP8 documentation at <a href="https://www.python.org/dev/peps/pep-0008">https://www.python.org/dev/peps/pep-0008</a>.<a href="https://www.python.org/dev/peps/pep-0008"/></p>
<p>If you like, try to implement syntax highlighting of Python code in the text editor. A naive implementation would first involve defining a list of keywords. Then we can bind the <kbd>&lt;KeyRelease&gt;</kbd> event to check whether the typed word is one of the keywords. We can then add a custom tag to the word using <kbd>tag_add</kbd>. Finally, we can change its color by using code such as <kbd>textarea.tag_config("the_keyword_tag", foreground="blue")</kbd>.</p>
<p>A slightly advanced idea to read up on and implement is called <strong>lazy loading</strong>.  This is particularly helpful if you want to open a very large file in the text editor. In the present implementation, it may take very long time to open a very large file. In contrast, lazy loading will read only the section of the file that is currently visible in the text editor, thus making the program much more responsive.</p>


            

            
        
    </body></html>