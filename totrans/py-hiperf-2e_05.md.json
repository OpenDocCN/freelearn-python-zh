["```py\n    def sum_sq(a):\n        result = 0\n        N = len(a)\n        for i in range(N):\n            result += a[i]\n        return result\n\n```", "```py\n    from numba import nb\n\n    @nb.jit\n    def sum_sq(a):\n        ...\n\n```", "```py\n    import numpy as np\n\n    x = np.random.rand(10000)\n\n    # Original\n    %timeit sum_sq.py_func(x)\n    100 loops, best of 3: 6.11 ms per loop\n\n    # Numba\n    %timeit sum_sq(x)\n    100000 loops, best of 3: 11.7 µs per loop\n\n```", "```py\n    %timeit (x**2).sum()\n    10000 loops, best of 3: 14.8 µs per loop\n\n```", "```py\n    x_list = x.tolist()\n    %timeit sum_sq(x_list)\n    1000 loops, best of 3: 199 µs per loop\n\n    %timeit sum([x**2 for x in x_list])\n    1000 loops, best of 3: 1.28 ms per loop\n\n```", "```py\n    sum_sq.signatures\n    # Output:\n    # []\n\n```", "```py\n    x = np.random.rand(1000).astype('float64')\n    sum_sq(x)\n    sum_sq.signatures\n    # Result:\n    # [(array(float64, 1d, C),)]\n\n    x = np.random.rand(1000).astype('float32')\n    sum_sq(x)\n    sum_sq.signatures\n    # Result:\n    # [(array(float64, 1d, C),), (array(float32, 1d, C),)]\n\n```", "```py\n    @nb.jit((nb.float64[:],))\n    def sum_sq(a):\n\n```", "```py\n    sum_sq(x.astype('float32'))\n    # TypeError: No matching definition for argument type(s) \n    array(float32, 1d, C)\n\n```", "```py\n    @nb.jit(\"float64(float64[:])\")\n    def sum_sq(a):\n\n```", "```py\n    @nb.jit([\"float64(float64[:])\",\n             \"float64(float32[:])\"])\n    def sum_sq(a):\n\n```", "```py\n    sum_sq.inspect_types()\n\n```", "```py\n    # --- LINE 4 --- \n    #   a = arg(0, name=a)  :: array(float64, 1d, A)\n    #   $0.1 = global(len: <built-in function len>)  :: \n    Function(<built-in function len>)\n    #   $0.3 = call $0.1(a)  :: (array(float64, 1d, A),) -> int64\n    #   N = $0.3  :: int64\n\n    N = len(a)\n\n```", "```py\n    @nb.jit\n    def concatenate(strings):\n        result = ''\n        for s in strings:\n            result += s\n        return result\n\n```", "```py\n    concatenate(['hello', 'world'])\n    concatenate.signatures\n    # Output: [(reflected list(str),)]\n    concatenate.inspect_types()\n\n```", "```py\n    # --- LINE 3 --- \n    #   strings = arg(0, name=strings)  :: pyobject\n    #   $const0.1 = const(str, )  :: pyobject\n    #   result = $const0.1  :: pyobject\n    #   jump 6\n    # label 6\n\n    result = ''\n\n```", "```py\n    x = ['hello'] * 1000\n    %timeit concatenate.py_func(x)\n    10000 loops, best of 3: 111 µs per loop\n\n    %timeit concatenate(x)\n    1000 loops, best of 3: 317 µs per loop\n\n```", "```py\n    @nb.jit(nopython=True)\n    def concatenate(strings):\n        result = ''\n        for s in strings:\n            result += s\n        return result\n\n    concatenate(x)\n    # Exception:\n    # TypingError: Failed at nopython (nopython frontend)\n\n```", "```py\n    import numpy as np\n\n    def cantor(a, b):\n        return  int(0.5 * (a + b)*(a + b + 1) + b)\n\n```", "```py\n    @np.vectorize\n    def cantor(a, b):\n        return  int(0.5 * (a + b)*(a + b + 1) + b)\n\n    cantor(np.array([1, 2]), 2)\n    # Result:\n    # array([ 8, 12])\n\n```", "```py\n    # Pure Python\n    %timeit cantor_py(x1, x2)\n    100 loops, best of 3: 6.06 ms per loop\n    # Numba\n    %timeit cantor(x1, x2)\n    100000 loops, best of 3: 15 µs per loop\n    # NumPy\n    %timeit (0.5 * (x1 + x2)*(x1 + x2 + 1) + x2).astype(int)\n    10000 loops, best of 3: 57.1 µs per loop\n\n```", "```py\n    a = np.random.rand(3, 3)\n    b = np.random.rand(3, 3)\n\n    c = np.matmul(a, b)\n    c.shape\n    # Result:\n    # (3, 3)\n\n```", "```py\n    a = np.random.rand(10, 3, 3)\n    b = np.random.rand(10, 3, 3)\n\n    c = np.matmul(a, b)\n    c.shape\n    # Output\n    # (10, 3, 3)\n\n```", "```py\n    a = np.random.rand(10, 3, 3)\n    b = np.random.rand(3, 3) # Broadcasted to shape (10, 3, 3)\n    c = np.matmul(a, b)\n    c.shape\n    # Result:\n    # (10, 3, 3)\n\n```", "```py\n    @nb.guvectorize(['float64[:], float64[:], float64[:]'], '(n), (n) -\n    > ()')\n    def euclidean(a, b, out):\n        N = a.shape[0]\n        out[0] = 0.0\n        for i in range(N):\n            out[0] += (a[i] - b[i])**2\n\n```", "```py\n    a = np.random.rand(2)\n    b = np.random.rand(2)\n    c = euclidean(a, b) # Shape: (1,)\n\n    a = np.random.rand(10, 2)\n    b = np.random.rand(10, 2)\n    c = euclidean(a, b) # Shape: (10,)\n\n    a = np.random.rand(10, 2)\n    b = np.random.rand(2)\n    c = euclidean(a, b) # Shape: (10,)\n\n```", "```py\n    a = np.random.rand(10000, 2)\n    b = np.random.rand(10000, 2)\n\n    %timeit ((a - b)**2).sum(axis=1)\n    1000 loops, best of 3: 288 µs per loop\n\n    %timeit euclidean(a, b)\n    10000 loops, best of 3: 35.6 µs per loop\n\n```", "```py\n    class Node:\n        def __init__(self, value):\n            self.next = None\n            self.value = value\n\n```", "```py\n    class LinkedList:\n\n        def __init__(self):\n            self.head = None\n\n        def push_front(self, value):\n            if self.head == None:\n                self.head = Node(value)\n            else:\n                # We replace the head\n                new_head = Node(value)\n                new_head.next = self.head\n                self.head = new_head\n\n```", "```py\n        def show(self):\n            node = self.head\n            while node is not None:\n                print(node.value)\n                node = node.next\n\n```", "```py\n    lst = LinkedList()\n    lst.push_front(1)\n    lst.push_front(2)\n    lst.push_front(3)\n    lst.show()\n    # Output:\n    # 3\n    # 2\n    # 1\n\n```", "```py\n    @nb.jit\n    def sum_list(lst):\n        result = 0\n        node = lst.head\n        while node is not None:\n            result += node.value\n            node = node.next\n        return result\n\n```", "```py\n    lst = LinkedList()\n    [lst.push_front(i) for i in range(10000)]\n\n    %timeit sum_list.py_func(lst)\n    1000 loops, best of 3: 2.36 ms per loop\n\n    %timeit sum_list(lst)\n    100 loops, best of 3: 1.75 ms per loop\n\n```", "```py\n    node_type = nb.deferred_type()\n\n    node_spec = [\n        ('next', nb.optional(node_type)),\n        ('value', nb.int64)\n    ]\n\n    @nb.jitclass(node_spec)\n    class Node:\n        # Body of Node is unchanged\n\n    node_type.define(Node.class_type.instance_type)\n\n```", "```py\n    ll_spec = [\n        ('head', nb.optional(Node.class_type.instance_type))\n    ]\n\n    @nb.jitclass(ll_spec)\n    class LinkedList:\n        # Body of LinkedList is unchanged\n\n```", "```py\n    lst = LinkedList()\n    [lst.push_front(i) for i in range(10000)]\n\n    %timeit sum_list(lst)\n    1000 loops, best of 3: 345 µs per loop\n\n    %timeit sum_list.py_func(lst)\n    100 loops, best of 3: 3.36 ms per loop\n\n```", "```py\n    a = [[0, 1, 2], \n         [3, 4], \n         [5, 6, 7, 8]]\n\n    @nb.jit\n    def sum_sublists(a):\n        result = []\n        for sublist in a:\n            result.append(sum(sublist))\n        return result\n\n    sum_sublists(a)\n    # ValueError: cannot compute fingerprint of empty list\n\n```", "```py\n    @nb.jit\n    def sum_sublists(a):\n        result = [0]\n        for sublist in a:\n            result.append(sum(sublist))\n        return result[1:]\n\n```", "```py\n$ /path/to/bin/pypy -m ensurepip\n$ /path/to/bin/pypy -m pip install virtualenv\n$ /path/to/bin/virtualenv my-pypy-env\n\n```", "```py\n$ source my-pypy-env/bin/activate \n\n```", "```py\n(my-pypy-env) $ pip install numpy matplotlib\n\n```", "```py\n(my-pypy-env) $ deactivate\n$ python -V\nPython 3.5.2 :: Continuum Analytics, Inc.\n\n```", "```py\n$ python -m timeit --setup \"from simul import benchmark\" \"benchmark()\"\n10 loops, best of 3: 886 msec per loop\n\n```", "```py\n$ export MPLBACKEND='agg'\n\n```", "```py\n$ source my-pypy-env/bin/activate\nPython 2.7.12 (aff251e54385, Nov 09 2016, 18:02:49)\n[PyPy 5.6.0 with GCC 4.8.2]\n\n(my-pypy-env) $ python -m timeit --setup \"from simul import benchmark\" \"benchmark()\"\nWARNING: timeit is a very unreliable tool. use perf or something else for real measurements\n10 loops, average of 7: 106 +- 0.383 msec per loop (using standard deviation)\n\n```", "```py\n(my-pypy-env) $ pip install perf\n(my-pypy-env) $ python -m perf timeit --setup 'from simul import benchmark' 'benchmark()'\n.......\nMedian +- std dev: 97.8 ms +- 2.3 ms\n\n```"]