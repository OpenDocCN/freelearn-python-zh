- en: Chapter 4. Animation Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Static shifting of a ball
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timed shifting of a ball
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation timed draw-and-erase cycles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two balls moving unimpeded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ball that bounces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bouncing in a gravitational field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colliding balls with tracer trails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elastic ball against ball collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trajectory tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating a line and vital trigonometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating lines which rotate lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A digital flower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Animation is about making graphic objects move smoothly around a screen. The
    method to create the sensation of smooth dynamic action is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: First present a picture to the viewer's eye.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow the image to stay in view for about one-twentieth of a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With a minimum of delay, present another picture where objects have been shifted
    by a small amount and repeat the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides the obvious applications of making animated figures move around on a
    screen for entertainment, animating the results of computer code gives you powerful
    insights into how code works at a detailed level. Animation offers an extra dimension
    to the programmers' debugging arsenal. It provides you with an all encompassing,
    holistic view of software execution in progress that nothing else can.
  prefs: []
  type: TYPE_NORMAL
- en: Static shifting of a ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We make an image of a small colored disk and draw it in a sequence of different
    positions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in exactly the same way as all the examples in [Chapter
    2](ch02.html "Chapter 2. Drawing Fundamental Shapes"), *Drawing Fundamental Shapes*
    and you will see a neat row of colored disks laid on top of each other going from
    top left to bottom right. The idea is to demonstrate the method of systematic
    position shifting that we will use again and again throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple ball is drawn on a canvas in a sequence of steps, one on top of the
    other. For each step, the position of the ball is shifted by three pixels as specified
    by the size of `shift_x`. Similarly, a downward shift of two pixels is applied
    by an amount to the value of `shift_y. shift_x` and `shift_y` only specify the
    amount of shift, but they do not make it happen. What makes it happen are the
    two commands `posn_x += shift_x` and `posn_y += shift_y. posn` is the abbreviation
    for position. An important word of explanation of this notation is needed here
    because we use it often throughout the book. It is neat and handy.
  prefs: []
  type: TYPE_NORMAL
- en: '`posn_x += shift_x` means "take the variable `posn_x` and add to it an amount
    `shift_x."` It is the same as `posn_x = posn_x + shift_x`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another minor point to note is the use of the line continuation character, the
    backslash "\". We use this when we want to continue the same Python command onto
    a following line to make reading easier. Strictly speaking for text inside brackets
    "(...)" this is not needed. In this particular case you can just insert a carriage
    return character. However, the backslash makes it clear to anyone reading your
    code what your intention is.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The series of ball images in this recipe were drawn in a few microseconds. To
    create decent looking animation, we need to be able to slow the code execution
    down by just the right amount. We need to draw the equivalent of a movie frame
    onto the screen and keep it there for a measured time and then move on to the
    next, slightly shifted, image. This is done in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Time-controlled shifting of a ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we introduce the time control function `canvas.after(milliseconds)` and
    the `canvas.update()` function that refreshes the image on the canvas. These are
    the cornerstones of animation in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Control of when code gets executed is made possible by the time module that
    comes with the standard Python library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program as previously. What you will see is a diagonal row of disks
    being laid in a line with a short delay of one fifth of a second (200 milliseconds)
    between updates. The result is shown in the following screenshot showing the ball
    shifting in regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is the same as the previous one except for the `canvas.after(...)`
    and the `canvas.update()` methods. These are two functions that come from the
    Python library. The first gives you some control over code execution time by allowing
    you to specify delays in execution. The second forces the canvas to be completely
    redrawn with all the objects that should be there. There are more complicated
    ways of refreshing only portions of the screen, but they create difficulties so
    they will not be dealt with here.
  prefs: []
  type: TYPE_NORMAL
- en: The `canvas.after(your-chosen-milliseconds)` method simply causes a timed-pause
    to the execution of the code. In all the preceding code, the pause is executed
    as fast as the computer can do it, then when the pause, invoked by the `canvas.after()`
    method is encountered, execution simply gets suspended for the specified number
    of milliseconds. At the end of the pause, execution continues as if nothing ever
    happened.
  prefs: []
  type: TYPE_NORMAL
- en: The `canvas.update()` method forces everything on the canvas to be redrawn immediately
    rather than wait for some unspecified event to cause the canvas to be refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step in effective animation is to erase the previous image of the object
    being animated shortly before a fresh, shifted clone is drawn on the canvas. This
    happens in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: The robustness of Tkinter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also worth noting that Tkinter is robust. When you give position coordinates
    that are off the canvas, Python does not crash or freeze. It simply carries on
    drawing the object 'off-the-page'. The Tkinter canvas can be seen as just a tiny
    window into an almost unlimited universe of visual space. We only see objects
    when they move into the view of the camera which is the Tkinter canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Complete animation using draw-move-pause-erase cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe gives you the whole animation procedure. All the actions necessary
    for the human brain to interpret images on the retina as moving objects are present
    in this example. The whole craft of animation and the million dollar movies based
    thereon is demonstrated here in its simplest and purest form.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute this program as we have done before. Note that this time we have reduced
    the timed pause to 50 milliseconds which is 20 times per second. This is close
    to the standard 24 frames per second used in movies. However, without a graphics
    card this time becomes less accurate as shorter pauses are specified. In addition,
    the distance moved between position shifts of the ball has been reduced to one
    pixel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new element in this self-contained animation is the `canvas.delete(ALL)`
    method that clears the entire canvas of everything that was drawn on it. It is
    possible to erase only specific objects on the screen through the use of identification
    tags. This is not needed now. Selective object deletion using tags will be used
    in the last three recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How accurate is the timing of the `pause()` method?.
  prefs: []
  type: TYPE_NORMAL
- en: With modern computers, pauses of five milliseconds are realistic but the animation
    becomes jerky as the pause times get shorter.
  prefs: []
  type: TYPE_NORMAL
- en: More than one moving object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to be able to develop programs where more than one independent graphic
    object co-exists and interacts according to some rules. This is how most computer
    games work. Pilot training simulators and serious engineering design models are
    designed on the same principles. We start this process simply by working up to
    an application that ends up with two balls bouncing off the walls and each other
    under the influence of gravity and energy loss.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code is very similar to that in the previous recipe, except that
    two similar objects are created. They are independent of each other and do not
    interact in any way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main point to note is that these programs, and many others in this book,
    are divided into five parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the environment where objects will exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the individual objects and their attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the rules of engagement between objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a loop to simulate the march of time by changing properties such as position
    at rates that mimic real-time motion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Controlling the environment inside which the objects exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The environment in most of our examples is the Tkinter canvas. The objects that
    are going to exist inside the canvas environment in this example are two colored
    balls. The rules of engagement are that they will not have any effect on each
    other at all and they will not be affected by the edges of the canvas. Another
    rule of engagement is how their positions will shift each time the `for` loop
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally the environment is controlled by the time regulated `canvas.update()`
    and `canvas.delete(ALL)` methods.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principle idea demonstrated in this recipe is that we can create more than
    one similar, but different objects exist and react independently. This gives rise
    to the idea of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python offers more than one way to use the ideas of object-oriented programming.
    In this book, we use three ways of making objects: lists, dictionaries, and classes.'
  prefs: []
  type: TYPE_NORMAL
- en: A ball that bounces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now and in the next three examples, we add rules of engagement that are increasingly
    complex. The overall objective is to introduce behaviors and interactions into
    our artificial world to make it behave more like the real world. We use numbers,
    calculations, and graphical drawings to represent aspects of the real world as
    we know it.
  prefs: []
  type: TYPE_NORMAL
- en: The first new behavior is that our colored disks will bounce elastically off
    the walls of the container that is the Tkinter canvas.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code has purposely been kept as similar as possible to the previous four
    examples so that we feel we are still in familiar territory as the world we create
    gets increasingly more complicated. If we did not do this, we would get lost and
    bewildered. The whole secret in successfully constructing complex computer programs
    is to build it up gradually and systematically piece-by-piece. It is not a planned
    journey along a well-mapped road but rather a strenuous exploration through uncharted
    jungle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new feature here is the function `detect_Wall_Collision()`. Whenever it
    is called, it checks whether the position of the ball has moved outside the boundary
    of the canvas. If it has, the direction of the ball is reversed. This method is
    crude because it does not compensate for the size of the ball. Consequently the
    ball pops out of existence.
  prefs: []
  type: TYPE_NORMAL
- en: Bouncing in a gravity field
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, the influence of a gravitational field is added to the previous
    rule of bouncing off the canvas wall.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What makes this recipe different to all the previous ones is a new attribute
    of the ball named `velocity_y`. With every cycle of the for i in `range(0,300)`
    loop the velocity is modified just as it would be in the gravitational field of
    our real world.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vertical `velocity_y` property of our ball is increased by a constant quantity
    GRAVITY every time a new position is calculated. The net result is that the speed
    gets faster when the ball is falling downward and slower when it moves upward.
    Because the y-direction of a Tkinter canvas is positively increasing downward
    (contrary to our real world) this has the effect of slowing down the ball when
    moving upward and speeding it up when moving downward.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a flaw with this simulation of a bouncing ball. The ball disappears
    off the canvas after about three bounces because the integer arithmetic used in
    calculating each new position of the ball and the criteria used to detect collisions
    with the wall are much too coarse. The result of this is that the ball finds itself
    outside of the conditions we have set up to reverse its direction when it hits
    the floor. The GRAVITY added to its velocity kick it beyond the interval if `posn_y
    > ch ball_height`, and the ball never gets placed back inside the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Positions on the canvas are defined as integers only but we need to deal with
    much greater precision than that when calculating the position of our ball. It
    turns out there is no problem here. In their wisdom the Python designers have
    allowed us to work with all our variables as floating point numbers that are very
    precise and still pass them to the `canvas.create_oval(...)` method which draws
    the ball on the canvas. For the final drawing they obviously get converted into
    integers. Thank you wise Python guys.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, `floating_point_collisions_1.py`, uses floating point position
    calculation to fix the flaws in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Precise collisions using floating point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here the simulation flaws caused by the coarseness of integer arithmetic are
    eliminated by using floating point numbers for all ball position calculations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All position, velocity, and gravity variables are made floating point by writing
    them with explicit decimal points. The result is shown in the following screenshot,
    showing the bouncing balls with trajectory tracing.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use of precision arithmetic has allowed us to notice simulation behavior that
    was previously hidden by the sins of integer-only calculations. This is the UNIQUE
    VALUE OF GRAPHIC SIMULATION AS A DEBUGGING TOOL. If you can represent your ideas
    in a visual way rather than as lists of numbers you will easily pick up subtle
    quirks in your code. The human brain is designed to function best in graphical
    images. It is a direct consequence of being a hunter.
  prefs: []
  type: TYPE_NORMAL
- en: A graphic debugging tool...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another very handy trick in the software debugger's arsenal and that
    is the visual trace. A trace is some kind of visual trail that shows the history
    of dynamic behavior. All of this is revealed in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Trajectory tracing and ball-to-ball collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we introduce one of the more difficult behaviors in our simulation of ever
    increasing complexity the mid-air collision.
  prefs: []
  type: TYPE_NORMAL
- en: The hardest thing when you are debugging a program is to try to hold in your
    short term memory some recently observed behavior and compare it meaningfully
    with present behavior. This kind of memory is an imperfect recorder. The way to
    overcome this is to create a graphic form of memory some sort of picture that
    shows accurately what has been happening in the past. In the same way that military
    cannon aimers use glowing tracer projectiles to adjust their aim, a graphic programmer
    can use trajectory traces to examine the history of execution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our new code there is a new function called `detect_ball_collision (ball_1,
    ball_2)` whose job is to anticipate imminent collisions between the two balls
    no matter where they are. The collisions will come from any direction and therefore
    we need to be able to test all possible collision scenarios and examine the behavior
    of each one and see if it does not work as planned. This can be too difficult
    unless we create tools to test the outcome. In this recipe, the tool for testing
    outcomes is a graphic trajectory trace. It is a line that trails behind the path
    of the ball and shows exactly where it went right since the beginning of the simulation.
    The result is shown in the following screenshot, showing the bouncing with ball-to-ball
    collision rebounds.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mid-air ball against ball collisions are done in two steps. In the first step,
    we test whether the two balls are close to each other inside a vertical strip
    defined by `if math.fabs(ball_1['posn_x'] - ball_2['posn_x']) < 25`. In plain
    English, this asks "Is the horizontal distance between the balls less than 25
    pixels?" If the answer is yes, then the region of examination is narrowed down
    to a small vertical distance less than 25 pixels by the statement `if math.fabs(ball_1['posn_y']
    - ball_2['posn_y']) < 25`. So every time the loop is executed, we sweep the entire
    canvas to see if the two balls are both inside an area where their bottom-left
    corners are closer than 25 pixels to each other. If they are that close then we
    simply cause a rebound off each other by reversing their direction of travel in
    both the horizontal and vertical directions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply reversing the direction is not the mathematically correct way to reverse
    the direction of colliding balls. Certainly billiard balls do not behave that
    way. The law of physics that governs colliding spheres demands that momentum be
    conserved. This requires more complicated mathematics not covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we sometimes get tkinter.TckErrors?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we click the close window button (the X in the top right) while Python is
    paused, when Python revives and then calls on `Tcl` (Tkinter) to draw something
    on the canvas we will get an error message. What probably happens is that the
    application has already shut down, but `Tcl` has unfinished business. If we allow
    the program to run to completion before trying to shut the window then termination
    is orderly.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will see how to handle rotating lines. In any kind of graphic computer
    work, the need to rotate objects arises eventually. By starting off as simply
    as possible and progressively adding behaviors we can handle some increasingly
    complicated situations. This recipe is that first simple step in the art of making
    things rotate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the mathematics of rotation you need to be reasonably familiar
    with the trigonometry functions of sine, cosine, and tangent. The good news for
    those of us whose eyes glaze at the mention of trigonometry is that you can use
    these examples without understanding trigonometry. However, it is much more rewarding
    if you do try to figure out the math. It is like the difference between watching
    football or playing it. Only the players get fit.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You just need to write and run this code and observe the results as you did
    for all the other recipes. The insights come from repeated tinkering and hacking
    the code. Change the values of variables `p1_x` to `p2_y` one at a time and observe
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In essence, all rotation comes down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish a center of rotation or pivot point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick a specific point on the object you want to rotate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the distance from the pivot point to the specific point of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the angle of the line joining the pivot and the specific point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the angle of the line joining the points by a known amount, the rotation
    angle, and re-calculate the new x and y coordinates for that point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For math students what you do is relocate the origin of your rectangular coordinate
    system to the pivot point, express the coordinates of your specific point into
    polar coordinates, add an increment to the angular position, and convert the new
    polar coordinate position into a fresh pair of rectangular coordinates. The preceding
    recipe performs all these actions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pivot point was purposely placed near the bottom corner of the canvas so
    that the point on the end of the line to be rotated would fall outside the canvas
    for much of the rotation process. The rotation continues without errors or bad
    behavior emphasizing a point made earlier in this chapter that Python is mathematically
    robust. However, we need to exercise care when using the `arctangent` function
    `math.atan()` because it flips from a value positive infinity to negative infinity
    as angles move through 90 and 270 degrees. `Atan()` can give ambiguous results.
    Again the Python designers have taken care of business well by creating the math.
    `atan2(y,x)` function that takes into account the signs of both y and x to give
    unambiguous results between 180 degrees and -180.
  prefs: []
  type: TYPE_NORMAL
- en: Trajectory tracing on multiple line rotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example draws a visually appealing kind of Art Noveau arrowhead but that
    is just an issue on the happy-side. The real point of this recipe is to see how
    you can have any number of pivot points all with different motions and that the
    essential arithmetic remains simple and clean looking in Python. The use of animation
    methods to slow the execution down makes it entertaining to watch. We also see
    how tag names given to different parts of the objects drawn onto the canvas allow
    them to be selectively erased when the `canvas.delete(...)` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a skilled drum major marching in a parade whirling a staff in circles.
    Holding onto the end of the staff is a small monkey also twirling a baton but
    at a different speed. At the tip of the monkey's staff is a miniature marmoset
    twirling a baton in the opposite direction...
  prefs: []
  type: TYPE_NORMAL
- en: Now run the program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run the Python code below as we have done before. The result is shown in following
    screenshot showing multiple line rotation traces.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_04_04_new.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we did in the previous recipe we have lines defined by connecting two points,
    each being specified in the rectangular coordinates that Tkinter drawing methods
    use. There are three such lines connected pivot-to-tip. It may help to visualize
    each pivot as a drum major or a monkey. We convert each pivot-to-tip line into
    polar coordinates of length and angle. Then each pivot-to-tip line is rotated
    by its own individual increment angle. If you alter these angles alpha_1 etc.
    or the positions of the various pivot points you will get a limitless variety
    of interesting patterns.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you are able to control and vary color you are able to make extraordinary
    and beautiful patterns never seen before. Color control is the subject of the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A rose for you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This last example of the chapter is simply a gift for the reader. No illustration
    is provided. We will only see the result if we run the code. It is a surprise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structure of this program is similar to the previous example but the rotation
    parameters have been adjusted to evoke the image of a rose. The colors used are
    chosen to remind us that control over color is extremely import in graphics.
  prefs: []
  type: TYPE_NORMAL
