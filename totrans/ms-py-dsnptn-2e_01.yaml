- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Foundational Design Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设计原则
- en: Design principles form the foundation of any well-architected software. They
    serve as the guiding light that helps developers navigate the path of creating
    maintainable, scalable, and robust applications while avoiding the pitfalls of
    bad design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计原则是任何良好架构的软件的基础。它们作为指导之光，帮助开发者导航创建可维护、可扩展和健壮应用程序的道路，同时避免不良设计带来的陷阱。
- en: In this chapter, we will explore the core design principles that all developers
    should know and apply in their projects. We will explore four foundational principles.
    The first one, *Encapsulate What Varies*, teaches you how to isolate the parts
    of your code that are subject to change, making it easier to modify and extend
    your applications. Next, *Favor Composition*, makes you understand why it’s often
    better to assemble complex objects from simple ones rather than inheriting functionalities.
    The third one, *Program to Interfaces*, shows the power of coding to an interface
    rather than to a concrete class, enhancing flexibility and maintainability. Finally,
    with the *Loose Coupling* principle, you will grasp the importance of reducing
    dependencies between components, making your code easier to refactor and test.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨所有开发者都应该了解并应用于其项目的核心设计原则。我们将探讨四个基础原则。第一个，“封装变化”，教您如何隔离代码中易变的部分，使修改和扩展应用程序变得更加容易。接下来，“优先使用组合”，让您理解为什么通常从简单对象组装复杂对象比继承功能更好。第三个，“面向接口编程”，展示了面向接口而非具体类编码的力量，增强了灵活性和可维护性。最后，通过“松耦合”原则，您将掌握减少组件之间依赖关系的重要性，使代码更容易重构和测试。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Following the “Encapsulate What Varies” principle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循“封装变化”原则
- en: Following the “Favor Composition Over Inheritance” principle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循“优先使用组合而非继承”原则
- en: Following the “Program to Interfaces, Not Implementations” principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循“面向接口而非实现编程”原则
- en: Following the “Loose Coupling” principle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循“松耦合”原则
- en: By the end of this chapter, you’ll have a solid understanding of these principles
    and how to implement them in Python, setting the foundation for the rest of the
    book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对这些原则及其在 Python 中的实现有一个扎实的理解，为本书的其余部分打下基础。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the chapters in this book, you will need a running Python 3.12 environment,
    or for some exceptional cases in some chapters, 3.11.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的章节，您需要一个运行中的 Python 3.12 环境或在某些章节的某些特殊情况中，3.11 版本。
- en: 'In addition, install the Mypy static type checker ([https://www.mypy-lang.org](https://www.mypy-lang.org))
    by running the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过运行以下命令安装 Mypy 静态类型检查器（[https://www.mypy-lang.org](https://www.mypy-lang.org)）：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The examples are available in the GitHub repository here: [https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition](https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 示例可以在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition](https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition)
- en: About the Python executable
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 可执行文件
- en: Throughout the book, we will reference the Python executable for executing code
    examples as `python3.12` or `python`. Adapt that to your specific environment,
    practice and/or workflow.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将引用 Python 可执行文件来执行代码示例，作为 `python3.12` 或 `python`。根据您的具体环境、实践和/或工作流程进行适配。
- en: Following the Encapsulate What Varies principle
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循“封装变化”原则
- en: One of the most common challenges in software development is dealing with change.
    Requirements evolve, technologies advance, and user needs also change. Therefore,
    it is crucial to write code that can adapt without causing a ripple effect of
    modifications throughout your program or application. This is where the principle
    of *Encapsulate What Varies* comes into play.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中最常见的挑战之一是处理变化。需求演变、技术进步，以及用户需求也会发生变化。因此，编写能够适应变化而不会在您的程序或应用程序中引起连锁修改的代码至关重要。这就是“封装变化”原则发挥作用的地方。
- en: What does it mean?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是什么意思？
- en: 'The idea behind this principle is straightforward: isolate the parts of your
    code that are most likely to change and encapsulate them. By doing so, you create
    a protective barrier that shields the rest of your code from these elements that
    are subject to change. This encapsulation allows you to make changes to one part
    of your system without affecting others.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则背后的思想很简单：隔离您代码中最可能发生变化的部分，并将它们封装起来。通过这样做，您创建了一个保护屏障，保护代码的其他部分免受这些可能发生变化元素的影响。这种封装允许您在不影响其他部分的情况下对系统的一部分进行更改。
- en: Benefits
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: 'Encapsulating what varies provides several benefits, mainly the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 封装变化的部分提供了几个好处，主要包括以下：
- en: '**Ease of maintenance**: When changes are needed, you must only modify the
    encapsulated parts, reducing the risk of introducing bugs elsewhere'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护**：当需要更改时，您只需修改封装的部分，从而降低在其他地方引入错误的风险'
- en: '**Enhanced flexibility**: Encapsulated components can be easily swapped or
    extended, providing a more adaptable architecture'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强灵活性**：封装的组件可以轻松交换或扩展，提供更适应的架构'
- en: '**Improved readability**: By isolating varying elements, your code becomes
    more organized and easier to understand'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可读性**：通过隔离变化元素，您的代码变得更加有组织，更容易理解'
- en: Techniques for achieving encapsulation
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现封装的技术
- en: 'As we introduced, encapsulation helps in data hiding and exposing only the
    necessary functionalities. Here, we will present key techniques that enhance encapsulation
    in Python: polymorphism and the *getters* and *setters* techniques.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所介绍的，封装有助于数据隐藏，仅暴露必要的功能。在这里，我们将介绍增强 Python 中封装的关键技术：多态性和 *getters* 和 *setters*
    技术。
- en: Polymorphism
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态性
- en: In programming, polymorphism allows objects of different classes to be treated
    as objects of a common superclass. It is one of the core concepts in **object-oriented
    programming** **OOP** that enables a single interface to represent different types.
    Polymorphism allows for implementing elegant software design patterns, such as
    the strategy pattern, and it’s a way to implement clean, maintainable code in
    Python.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，多态性允许将不同类的对象视为公共超类对象。它是 **面向对象编程** **OOP** 的核心概念之一，它使单个接口能够表示不同类型。多态性允许实现优雅的软件设计模式，如策略模式，并且是实现
    Python 中干净、可维护代码的一种方式。
- en: Getters and Setters
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Getters and Setters
- en: These are special methods in a class that enable controlled access to attribute
    values. *getters* allow reading the values of attributes and *setters* enable
    modifying them. By using these methods, you can add validation logic or side effects
    such as logging, thus adhering to the principles of encapsulation. They provide
    a way to control and protect the state of an object and are particularly useful
    when you want to encapsulate complex attributes that are derived from other instance
    variables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在一个类中使用的特殊方法，它们允许对属性值进行受控访问。*getters* 允许读取属性的值，而 *setters* 允许修改它们。通过使用这些方法，您可以添加验证逻辑或副作用，如记录日志，从而遵循封装的原则。它们提供了一种控制和保护对象状态的方法，并且在您想要封装从其他实例变量派生的复杂属性时特别有用。
- en: And there is more. To complement the *getters* and *setters* technique, Python
    offers a more elegant approach known as the *property* technique. This is a built-in
    feature of Python that allows you to convert attribute access into method calls
    seamlessly. With properties, you can ensure that an object retains its internal
    state against incorrect or harmful manipulation without having to explicitly define
    *getter* and *setter* methods.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多。为了补充 *getters* 和 *setters* 技术，Python 提供了一种更优雅的方法，称为 *property* 技术。这是 Python
    的内置功能，允许您无缝地将属性访问转换为方法调用。使用属性，您可以在不显式定义 *getter* 和 *setter* 方法的情况下，确保对象在不受正确或有害操作的情况下保持其内部状态。
- en: The `@property` decorator allows you to define a method that is automatically
    invoked when an attribute is accessed, effectively serving as a *getter*. Similarly,
    the `@attribute_name.setter` decorator allows you to define a method that acts
    as a *setter*, invoked when you attempt to change the value of an attribute. This
    way, you can embed validation or other actions directly within these methods,
    making the code more clean.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`@property` 装饰器允许您定义一个方法，当访问属性时自动调用，有效地充当 *getter*。同样，`@attribute_name.setter`
    装饰器允许您定义一个方法，充当 *setter*，在您尝试更改属性值时调用。这样，您可以直接在这些方法中嵌入验证或其他操作，使代码更加简洁。'
- en: By using the *property* technique, you can achieve the same level of data encapsulation
    and validation as with traditional *Getters* and *Setters* but in a way that is
    more aligned with Python’s design philosophy. It allows you to write code that
    is not just functional but also clean and easy to read, enhancing both encapsulation
    and the overall quality of your Python programs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用*属性*技术，你可以实现与传统的*获取器*和*设置器*相同级别的数据封装和验证，但以一种更符合Python设计哲学的方式。它允许你编写不仅功能性强，而且干净、易于阅读的代码，从而增强封装和Python程序的整体质量。
- en: Next, we will better understand these techniques through examples.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过示例更好地理解这些技术。
- en: An example – encapsulating using polymorphism
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 举例——使用多态进行封装
- en: 'Polymorphism is a powerful way to achieve encapsulation of varying behavior.
    Let’s see that with an example of a payment processing system where the payment
    method option can vary. In such a case, you might encapsulate each method of payment
    in its own class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是实现变化行为封装的强大方式。让我们通过一个支付处理系统的例子来看一下，在这个系统中，支付方式选项可以变化。在这种情况下，你可能会将每种支付方式封装在其自己的类中：
- en: 'You would first define the base class for payment methods, providing a `process_payment()`
    method that each specific payment method will implement. This is where we encapsulate
    what varies—the payment processing logic. That part of the code will be as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先定义支付方法的基类，提供一个`process_payment()`方法，每个具体的支付方法都将实现它。这就是我们封装变化的部分——支付处理逻辑。这部分代码如下：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we introduce the `CreditCard` and `PayPal` classes, inheriting from `PaymentBase`,
    each providing their own implementation of `process_payment`. This is a classic
    way of polymorphism, as you can treat `CreditCard` and `PayPal` objects as instances
    of their common superclass. The code is as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍`CreditCard`和`PayPal`类，它们继承自`PaymentBase`，每个类都提供了自己的`process_payment`实现。这是一种经典的多态方式，因为你可以将`CreditCard`和`PayPal`对象视为它们共同超类实例。代码如下：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To make it possible to test the classes we just created, let’s add some code,
    calling `process_payment()` for each object. The beauty of polymorphism is evident
    when you use these classes, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试我们刚刚创建的类成为可能，让我们添加一些代码，为每个对象调用`process_payment()`。当你使用这些类时，多态的美丽之处显而易见，如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The complete code for this example (`ch01/encapsulate.py`) is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的完整代码（`ch01/encapsulate.py`）如下：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To test the code, run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试代码，请运行以下命令：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should get the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, when the payment method changes, the program adapts to produce
    the expected outcome.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当支付方式改变时，程序会适应以产生预期的结果。
- en: By encapsulating what varies—here, the *payment method*—you can easily add new
    options or modify existing ones without affecting the core payment processing
    logic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过封装变化的部分——在这里是*支付方式*——你可以轻松地添加新选项或修改现有选项，而不会影响核心支付处理逻辑。
- en: An example – encapsulating using a property
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 举例——使用属性进行封装
- en: Let’s define a `Circle` class and show how to use Python’s `@property` technique
    to create a *getter* and a *setter* for its `radius` attribute.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`Circle`类，并展示如何使用Python的`@property`技术为其`radius`属性创建一个*获取器*和一个*设置器*。
- en: Note that the underlying attribute would actually be called `_radius`, but it
    is hidden/protected behind the *property* called `radius`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，底层属性实际上会被称为`_radius`，但它被隐藏/保护在名为`radius`的*属性*后面。
- en: 'Let’s write the code step by step:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步编写代码：
- en: 'We start by defining the `Circle` class with its initialization method, where
    we initialize the `_radius` attribute as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义`Circle`类及其初始化方法，其中我们将`_radius`属性初始化如下：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We add the radius property: a `radius()` method where we return the value from
    the underlying attribute, decorated using the `@property` decorator, as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加半径属性：一个`radius()`方法，其中我们从底层属性返回值，使用`@property`装饰器装饰，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We add the radius setter part: another `radius()` method where we do the actual
    job of modifying the underlying attribute, after a validation check, since we
    do not want to allow a negative value for the radius; this method is decorated
    by the special `@radius.setter` decorator. This part of the code is as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加半径设置器部分：另一个`radius()`方法，其中我们在验证检查后实际修改底层属性，因为我们不希望允许半径为负值；此方法由特殊的`@radius.setter`装饰器装饰。这部分代码如下：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we add some lines that will help us test the class, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一些将帮助我们测试类的代码，如下所示：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The complete code for this example (`ch01/encapsulate_bis.py`) is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码（`ch01/encapsulate_bis.py`）如下所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To test the example, run the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此示例，请运行以下命令：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should get the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this second example, we saw how we can encapsulate the circle’s radius component
    so that we can change the technical aspects if needed, without breaking the class.
    For example, the validation code for the *setter* can evolve. We can even change
    the underlying attribute, `_radius`, and the behavior for the user of our code
    will remain unchanged.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个示例中，我们看到了如何封装圆的半径组件，以便在需要时更改技术细节，而不会破坏类。例如，*setter* 的验证代码可以演变。我们甚至可以更改基础属性
    `_radius`，而我们的代码用户的行为将保持不变。
- en: Following the Favor Composition Over Inheritance principle
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循“优先使用组合而非继承”原则
- en: In OOP, it’s tempting to create complex hierarchies of classes through inheritance.
    While inheritance has its merits, it can lead to tightly coupled code that is
    hard to maintain and extend. This is where the principle of *Favor Composition
    Over Inheritance* comes into the picture.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，通过继承创建复杂的类层次结构是很诱人的。虽然继承有其优点，但它可能导致代码紧密耦合，难以维护和扩展。这就是“优先使用组合而非继承”原则发挥作用的地方。
- en: What does it mean?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是什么意思？
- en: This principle advises that you should prefer composing objects from simpler
    parts to inheriting functionalities from a base class. In other words, build complex
    objects by combining simpler ones.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此原则建议您应该优先从更简单的部分组合对象，而不是从基类继承功能。换句话说，通过组合更简单的对象来构建复杂对象。
- en: Benefits
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: 'Choosing composition over inheritance offers several advantages:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 选择组合而非继承提供了一些优点：
- en: '**Flexibility**: Composition allows you to change objects’ behavior at runtime,
    making your code more adaptable'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：组合允许您在运行时更改对象的行为，使代码更具适应性'
- en: '**Reusability**: Smaller, simpler objects can be reused across different parts
    of your application, promoting code reusability'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：较小的、简单的对象可以在应用程序的不同部分重用，从而促进代码的可重用性'
- en: '**Ease of maintenance**: With composition, you can easily swap out or update
    individual components without affecting the overall system, avoiding border effects'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于维护**：使用组合，您可以轻松地替换或更新单个组件，而不会影响整体系统，避免边界效应'
- en: Techniques for composition
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合的技术
- en: In Python, composition is often achieved through OOP by including instances
    of other classes within a class. This is sometimes referred to as a “has-a” relationship
    between the class that is being composed and the classes that are being included.
    Python makes it particularly easy to use composition by not requiring explicit
    type declarations. You can include other objects by simply instantiating them
    in the class’s `__init__` method or by passing them as parameters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，组合通常通过面向对象编程实现，即在类中包含其他类的实例。这有时被称为被组合的类和被包含的类之间的“具有”关系。Python 通过不需要显式类型声明，特别容易使用组合。您可以通过在类的
    `__init__` 方法中实例化它们或作为参数传递来包含其他对象。
- en: An example – compose a car using the engine
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子 - 使用发动机组合汽车
- en: 'In Python, you can use composition by including instances of other classes
    within your class. For example, consider a `Car` class that includes an instance
    of an `Engine` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，您可以通过在您的类中包含其他类的实例来实现组合。例如，考虑一个包含 `Engine` 类实例的 `Car` 类：
- en: 'Let’s first define the `Engine` class as follows, with its `start` method:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先定义如下所示的 `Engine` 类，其中包含其 `start` 方法：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, let’s define the `Car` class as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们定义如下所示的 `Car` 类：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, add the following lines of code to create an instance of the `Car`
    class and call the `start` method on that instance, when this program is executed:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在程序执行时，添加以下代码行以创建 `Car` 类的实例，并在该实例上调用 `start` 方法：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The complete code for this example (`ch01/composition.py`) is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码（`ch01/composition.py`）如下所示：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To test the code, run the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试代码，请运行以下命令：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should get the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see in this example, the `Car` class is composed of an `Engine` object,
    thanks to the `self.engine = Engine()` line, allowing you to easily swap out the
    engine for another type without altering the `Car` class itself.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个示例中所看到的，`Car` 类由一个 `Engine` 对象组成，这是通过 `self.engine = Engine()` 这一行实现的，这使得您能够轻松地更换发动机类型，而无需更改
    `Car` 类本身。
- en: Following the Program to Interfaces, Not Implementations principle
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循“面向接口而非实现”原则
- en: In software design, it’s easy to get caught up in the specifics of how a feature
    is implemented. However, focusing too much on implementation details can lead
    to code that is tightly coupled and difficult to modify. The principle of *Program
    to Interfaces, Not Implementations* offers a solution to this problem.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计中，很容易陷入如何实现一个功能的细节。然而，过分关注实现细节可能导致代码紧密耦合且难以修改。*面向接口，而非实现*的原则为解决这个问题提供了解决方案。
- en: What does it mean?
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是什么意思？
- en: An interface defines a **contract** for classes, specifying a set of methods
    that must be implemented.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了类的一个**契约**，指定了一组必须实现的方法。
- en: This principle encourages you to code against an interface rather than a concrete
    class. By doing so, you untie your code from the specific classes that provide
    the required behavior, making it easier to swap or extend implementations without
    affecting the rest of the system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则鼓励你针对接口而不是具体类进行编码。通过这样做，你将代码从提供所需行为的特定类解耦，使得在不影响系统其他部分的情况下更容易交换或扩展实现。
- en: Benefits
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: 'Programming to interfaces offers several benefits:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 面向接口编程提供了几个优点：
- en: '**Flexibility**: You can easily switch between different implementations without
    altering the code that uses them'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：你可以轻松地在不同的实现之间切换，而无需更改使用它们的代码'
- en: '**Maintainability**: Losing your code from specific implementations makes it
    easier to update or replace components'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：失去特定实现中的代码使得更新或替换组件变得更加容易'
- en: '**Testability**: Interfaces make it simpler to write unit tests, as you can
    easily mock the interface during testing'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：接口使得编写单元测试更加简单，因为在测试期间你可以轻松地模拟接口'
- en: Techniques for interfaces
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口技术
- en: 'In Python, *interfaces* can be implemented using two primary techniques: **abstract
    base classes** (**ABCs**) and protocols.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，*接口*可以通过两种主要技术实现：**抽象基类**（**ABCs**）和协议。
- en: Abstract base classes
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象基类
- en: '*ABCs*, provided by the `abc` module, allow you to define *abstract methods*
    that must be implemented by any concrete (i.e., non-abstract) subclass.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由`abc`模块提供的*ABCs*（抽象基类），允许你定义必须由任何具体（即非抽象）子类实现的*抽象方法*。
- en: 'Let’s understand this concept with an example, where we will define an abstract
    class (for an interface) and then use it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来理解这个概念，我们将定义一个抽象类（作为接口）然后使用它：
- en: 'First, we need to import the `ABC` class and the `abstractmethod` decorator
    function as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要按照以下方式导入`ABC`类和`abstractmethod`装饰器函数：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we define the interface class as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义接口类如下：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, define a concrete class for that interface; it inherits from the interface
    class and provides an implementation for the `do_something` method as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为该接口定义一个具体类；它从接口类继承并提供了`do_something`方法的实现，如下所示：
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following lines for testing purposes:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试目的，添加以下行：
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The complete code (`ch01/abstractclass.py`) is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码（`ch01/abstractclass.py`）如下：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To test the code, run the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试代码，请运行以下命令：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should get the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now you know how to define an interface and a concrete class implementing that
    interface in Python.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何在Python中定义接口和实现该接口的具体类。
- en: Protocols
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议
- en: Introduced in Python 3.8 via the `typing` module, *Protocols* offer a more flexible
    approach than ABCs, known as *structural duck typing*, where an object is considered
    valid if it has certain attributes or methods, regardless of its actual inheritance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`typing`模块在Python 3.8中引入的*协议*，比ABCs提供了更灵活的方法，称为*结构化鸭子类型*，其中如果对象具有某些属性或方法，则认为它是有效的，而不管其实际继承关系如何。
- en: Unlike traditional duck typing, where type compatibility is determined at runtime,
    structural duck typing allows for type checking at compile time. This means that
    you can catch type errors before your code even runs (while in your IDE, for example),
    making your programs more robust and easier to debug.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与在运行时确定类型兼容性的传统鸭子类型不同，结构化鸭子类型允许在编译时进行类型检查。这意味着你可以在代码甚至运行之前（例如在IDE中）捕获类型错误，使你的程序更加健壮且更容易调试。
- en: The key advantage of using *Protocols* is that they focus on what an object
    can do, rather than what it is. In other words, *if an object walks like a duck
    and quacks like a duck, it’s a duck*, regardless of its actual inheritance hierarchy.
    This is particularly useful in a dynamically typed language such as Python, where
    an object’s behavior is more important than its actual type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*协议*的关键优势是它们关注对象能做什么，而不是它是什么。换句话说，*如果一个对象像鸭子走路，像鸭子嘎嘎叫，那么它就是一只鸭子*，无论它的实际继承层次结构如何。这在像Python这样的动态类型语言中尤其有用，其中对象的行为比其实际类型更重要。
- en: For example, you can define a `Drawable` protocol that requires a `draw()` method.
    Any class that implements this method would implicitly satisfy the protocol without
    having to explicitly inherit from it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以定义一个`Drawable`协议，它需要一个`draw()`方法。任何实现此方法的类都会隐式满足协议，而无需明确从它继承。
- en: 'Here’s a quick example to illustrate the concept. Let’s say you need a Protocol
    named `Flyer` that requires a `fly()` method. You can define it as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速示例来说明这个概念。假设你需要一个名为`Flyer`的协议，它需要一个`fly()`方法。你可以这样定义它：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And that’s it! Now, any class that has a `fly()` method would be considered
    `Flyer`, whether it explicitly inherits from the `Flyer` class or not. This is
    a powerful feature that allows you to write more generic and reusable code and
    adheres to the principle of composition over inheritance, a principle that we
    previously discussed in the *Following the “Favor Composition Over Inheritance”*
    *principle* section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，任何具有`fly()`方法的类都会被认为是`Flyer`，无论它是否明确地从`Flyer`类继承。这是一个强大的功能，允许你编写更通用和可重用的代码，并遵循我们之前在*遵循“优先使用组合而非继承”*原则部分讨论的原则。
- en: In a later example, we will see a practical use of Protocols.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的示例中，我们将看到协议的实际应用。
- en: An example – different types of logger
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 举例说明 – 不同类型的记录器
- en: 'Using ABCs, let’s create a logging interface that allows for different types
    of logging mechanisms. Here’s how you could implement that:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ABCs，让我们创建一个允许不同类型日志记录机制的日志接口。以下是实现方式：
- en: 'Import what is needed from `abc`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`abc`导入所需的模块：
- en: '[PRE28]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define the `Logger` interface with a `log` method:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`log`方法定义`Logger`接口：
- en: '[PRE29]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, define two concrete classes that implement the `Logger` interface for
    two different types of `Logger`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义两个具体的类，它们实现了`Logger`接口，用于两种不同的`Logger`类型：
- en: '[PRE30]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, to use each type of logger, define a function as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了使用每种类型的记录器，请定义一个如下所示的功能：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that the function takes as its first argument an object of type `Logger`,
    meaning an instance of a concrete class that implements the `Logger` interface
    (i.e., `ConsoleLogger` or `FileLogger`).
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，该函数将其第一个参数作为类型为`Logger`的对象，这意味着一个实现了`Logger`接口的具体类的实例（即`ConsoleLogger`或`FileLogger`）。
- en: 'Finally, add the lines needed to test the code, calling the `log_message` function
    as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加测试代码所需的行，如下调用`log_message`函数：
- en: '[PRE32]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The complete code for this example (`ch01/interfaces.py`) is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的完整代码（`ch01/interfaces.py`）如下所示：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To test the code, run the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试代码，请运行以下命令：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should get the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In addition to that output, looking in the folder from which you run the command,
    you will find that a file called `log.txt` has been created, containing the following
    line:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了那个输出之外，查看你运行命令的文件夹，你会发现一个名为`log.txt`的文件已经被创建，其中包含以下行：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you just saw with the `log_message` function, you can easily switch between
    different logging mechanisms without changing the function itself.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚才在`log_message`函数中看到的，你可以轻松地在不同的日志记录机制之间切换，而无需更改函数本身。
- en: An example – different types of logger, now using Protocols
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 举例说明 – 使用协议的不同类型的记录器
- en: 'Let’s revisit the previous example with the *Protocols* way of defining interfaces:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用*协议*方式重新审视之前的示例：
- en: 'First, we need to import the `Protocol` class as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要如下导入`Protocol`类：
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, defining the `Logger` interface is done by inheriting from the `Protocol`
    class as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过从`Protocol`类继承来定义`Logger`接口，如下所示：
- en: '[PRE38]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And the rest of the code stays unchanged.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且其余的代码保持不变。
- en: 'So, the complete code (`ch01/interfaces_bis.py`) is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，完整的代码（`ch01/interfaces_bis.py`）如下所示：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To check the static typing of the code based on the protocol we defined, run
    the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据我们定义的协议检查代码的静态类型，请运行以下命令：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should get the following output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To test the code, run the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试代码，请运行以下命令：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should get the same result as when running the previous version—in other
    words, the `log.txt` file created and the following output in the shell:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到与运行上一个版本相同的结果——换句话说，创建的`log.txt`文件和shell中的以下输出：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is normal since the only thing we changed is the way we define the interface.
    And, the effect of the interface (the protocol) is not enforced at runtime, meaning
    it does not change the actual result of the code execution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正常的，因为我们唯一改变的是定义接口的方式。而且，接口（协议）的效果在运行时没有强制执行，这意味着它不会改变代码执行的实际情况。
- en: Following the Loose Coupling principle
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循松散耦合原则
- en: As software grows in complexity, the relationships between its components can
    become tangled, leading to a system that is hard to understand, maintain, and
    extend. The principle of *Loose Coupling* aims to mitigate this issue.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件的复杂性增加，其组件之间的关系可能会变得复杂，导致系统难以理解、维护和扩展。松散耦合原则旨在减轻这一问题。
- en: What does it mean?
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是什么意思？
- en: '*Loose coupling* refers to minimizing the dependencies between different parts
    of a program. In a loosely coupled system, components are independent and interact
    through well-defined interfaces, making it easier to make changes to one part
    without affecting others.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合指的是最小化程序不同部分之间的依赖关系。在松散耦合系统中，组件是独立的，并通过定义良好的接口进行交互，这使得修改一个部分而不影响其他部分变得更容易。
- en: Benefits
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: 'Loose coupling offers several advantages:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合提供了几个优点：
- en: '**Maintainability**: With fewer dependencies, it’s easier to update or replace
    individual components'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：由于依赖项较少，更新或替换单个组件更容易'
- en: '**Extensibility**: A loosely coupled system can be more easily extended with
    new features or components'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：松散耦合的系统可以更容易地通过添加新功能或组件来扩展'
- en: '**Testability**: Independent components are easier to test in isolation, improving
    the overall quality of your software'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：独立的组件更容易在隔离状态下进行测试，从而提高软件的整体质量'
- en: Techniques for loose coupling
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 松散耦合的技术
- en: Two primary techniques for achieving *loose coupling* are **dependency injection**
    and the **observer pattern**. *Dependency injection* allows a component to receive
    its dependencies from an external source rather than creating them, making it
    easier to swap or mock these dependencies. The *observer pattern*, on the other
    hand, allows an object to publish changes to its state so that other objects can
    react accordingly, without being tightly bound to each other.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实现松散耦合的两个主要技术是**依赖注入**和**观察者模式**。依赖注入允许组件从外部源接收其依赖项，而不是创建它们，这使得交换或模拟这些依赖项更容易。另一方面，观察者模式允许一个对象发布其状态的变化，以便其他对象可以相应地做出反应，而无需紧密绑定在一起。
- en: Both techniques aim to reduce the interdependencies between components, making
    the system you are building more modular and easier to manage.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都旨在减少组件之间的相互依赖性，使你构建的系统更加模块化，更容易管理。
- en: We will discuss the *observer pattern* in detail in [*Chapter 5*](B21896_05.xhtml#_idTextAnchor121),
    *Behavioral Design Patterns*. For now, let’s study an example to understand how
    to use the *dependency* *injection* technique.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第5章*](B21896_05.xhtml#_idTextAnchor121)中详细讨论*观察者模式*，*行为设计模式*。现在，让我们通过一个例子来了解如何使用*依赖注入*技术。
- en: An example – a message service
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 举例来说，一个消息服务
- en: 'In Python, you can achieve loose coupling by using *dependency injection*.
    Let’s see a simple example involving a `MessageService` class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以通过使用*依赖注入*来实现松散耦合。让我们看看一个涉及`MessageService`类的简单例子：
- en: 'First, we define the `MessageService` class as follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义`MessageService`类如下：
- en: '[PRE44]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, the class will be initialized by passing a sender object to
    it; that object has a `send` method to allow sending messages.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，该类将通过传递一个发送对象给它来初始化；该对象有一个`send`方法，允许发送消息。
- en: 'Second, let’s define an `EmailSender` class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，让我们定义一个`EmailSender`类：
- en: '[PRE45]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Third, let’s define an `SMSSender` class:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，让我们定义一个`SMSSender`类：
- en: '[PRE46]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we can instantiate `MessageService` using an `EmailSender` object and use
    it to send a message. We can also instantiate `MessageService` using an `SMSSender`
    object instead. We add code to test both actions as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用一个`EmailSender`对象实例化`MessageService`并使用它来发送消息。我们也可以使用一个`SMSSender`对象来实例化`MessageService`。我们添加了以下代码来测试这两个操作：
- en: '[PRE47]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The complete code for this example, saved in the `ch01/loose_coupling.py` file,
    is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码，保存在`ch01/loose_coupling.py`文件中，如下所示：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To test the code, run the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试代码，请运行以下命令：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should get the following output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, `MessageService` is loosely coupled with `EmailSender` and
    `SMSSender` through dependency injection. This allows you to easily switch between
    different sending mechanisms without modifying the `MessageService` class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`MessageService`通过依赖注入与`EmailSender`和`SMSSender`松散耦合。这允许你轻松地在不同的发送机制之间切换，而无需修改`MessageService`类。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began the book with the foundational design principles that developers should
    follow for writing maintainable, flexible, and robust software. From encapsulating
    what varies to favoring composition, programming to interfaces, and aiming for
    loose coupling, these principles provide a strong foundation for any Python developer.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本书开始，介绍了开发者应该遵循的基础设计原则，以编写可维护、灵活和健壮的软件。从封装变化的部分到偏好组合、面向接口编程以及追求松散耦合，这些原则为任何Python开发者提供了一个强大的基础。
- en: 'As you’ve seen, these principles are not just theoretical constructs but practical
    guidelines that can significantly improve the quality of your code. They set the
    stage for what comes next: diving deeper into more specialized sets of principles
    that guide object-oriented design.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这些原则不仅仅是理论上的构建，而是可以显著提高你代码质量的实用指南。它们为接下来要讨论的内容奠定了基础：深入探讨更多专门化的原则集合，这些原则指导着面向对象的设计。
- en: In the next chapter, we will delve into the SOLID principles, a set of five
    design principles aimed at making software designs more understandable, flexible,
    and maintainable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨SOLID原则，这是一组旨在使软件设计更易于理解、灵活和可维护的五个设计原则。
