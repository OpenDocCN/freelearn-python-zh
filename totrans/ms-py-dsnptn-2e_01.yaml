- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Foundational Design Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design principles form the foundation of any well-architected software. They
    serve as the guiding light that helps developers navigate the path of creating
    maintainable, scalable, and robust applications while avoiding the pitfalls of
    bad design.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the core design principles that all developers
    should know and apply in their projects. We will explore four foundational principles.
    The first one, *Encapsulate What Varies*, teaches you how to isolate the parts
    of your code that are subject to change, making it easier to modify and extend
    your applications. Next, *Favor Composition*, makes you understand why it’s often
    better to assemble complex objects from simple ones rather than inheriting functionalities.
    The third one, *Program to Interfaces*, shows the power of coding to an interface
    rather than to a concrete class, enhancing flexibility and maintainability. Finally,
    with the *Loose Coupling* principle, you will grasp the importance of reducing
    dependencies between components, making your code easier to refactor and test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Following the “Encapsulate What Varies” principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the “Favor Composition Over Inheritance” principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the “Program to Interfaces, Not Implementations” principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the “Loose Coupling” principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a solid understanding of these principles
    and how to implement them in Python, setting the foundation for the rest of the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the chapters in this book, you will need a running Python 3.12 environment,
    or for some exceptional cases in some chapters, 3.11.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, install the Mypy static type checker ([https://www.mypy-lang.org](https://www.mypy-lang.org))
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The examples are available in the GitHub repository here: [https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition](https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: About the Python executable
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we will reference the Python executable for executing code
    examples as `python3.12` or `python`. Adapt that to your specific environment,
    practice and/or workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Following the Encapsulate What Varies principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common challenges in software development is dealing with change.
    Requirements evolve, technologies advance, and user needs also change. Therefore,
    it is crucial to write code that can adapt without causing a ripple effect of
    modifications throughout your program or application. This is where the principle
    of *Encapsulate What Varies* comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea behind this principle is straightforward: isolate the parts of your
    code that are most likely to change and encapsulate them. By doing so, you create
    a protective barrier that shields the rest of your code from these elements that
    are subject to change. This encapsulation allows you to make changes to one part
    of your system without affecting others.'
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Encapsulating what varies provides several benefits, mainly the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ease of maintenance**: When changes are needed, you must only modify the
    encapsulated parts, reducing the risk of introducing bugs elsewhere'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced flexibility**: Encapsulated components can be easily swapped or
    extended, providing a more adaptable architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved readability**: By isolating varying elements, your code becomes
    more organized and easier to understand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for achieving encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we introduced, encapsulation helps in data hiding and exposing only the
    necessary functionalities. Here, we will present key techniques that enhance encapsulation
    in Python: polymorphism and the *getters* and *setters* techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In programming, polymorphism allows objects of different classes to be treated
    as objects of a common superclass. It is one of the core concepts in **object-oriented
    programming** **OOP** that enables a single interface to represent different types.
    Polymorphism allows for implementing elegant software design patterns, such as
    the strategy pattern, and it’s a way to implement clean, maintainable code in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and Setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are special methods in a class that enable controlled access to attribute
    values. *getters* allow reading the values of attributes and *setters* enable
    modifying them. By using these methods, you can add validation logic or side effects
    such as logging, thus adhering to the principles of encapsulation. They provide
    a way to control and protect the state of an object and are particularly useful
    when you want to encapsulate complex attributes that are derived from other instance
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: And there is more. To complement the *getters* and *setters* technique, Python
    offers a more elegant approach known as the *property* technique. This is a built-in
    feature of Python that allows you to convert attribute access into method calls
    seamlessly. With properties, you can ensure that an object retains its internal
    state against incorrect or harmful manipulation without having to explicitly define
    *getter* and *setter* methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `@property` decorator allows you to define a method that is automatically
    invoked when an attribute is accessed, effectively serving as a *getter*. Similarly,
    the `@attribute_name.setter` decorator allows you to define a method that acts
    as a *setter*, invoked when you attempt to change the value of an attribute. This
    way, you can embed validation or other actions directly within these methods,
    making the code more clean.
  prefs: []
  type: TYPE_NORMAL
- en: By using the *property* technique, you can achieve the same level of data encapsulation
    and validation as with traditional *Getters* and *Setters* but in a way that is
    more aligned with Python’s design philosophy. It allows you to write code that
    is not just functional but also clean and easy to read, enhancing both encapsulation
    and the overall quality of your Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will better understand these techniques through examples.
  prefs: []
  type: TYPE_NORMAL
- en: An example – encapsulating using polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymorphism is a powerful way to achieve encapsulation of varying behavior.
    Let’s see that with an example of a payment processing system where the payment
    method option can vary. In such a case, you might encapsulate each method of payment
    in its own class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You would first define the base class for payment methods, providing a `process_payment()`
    method that each specific payment method will implement. This is where we encapsulate
    what varies—the payment processing logic. That part of the code will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we introduce the `CreditCard` and `PayPal` classes, inheriting from `PaymentBase`,
    each providing their own implementation of `process_payment`. This is a classic
    way of polymorphism, as you can treat `CreditCard` and `PayPal` objects as instances
    of their common superclass. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make it possible to test the classes we just created, let’s add some code,
    calling `process_payment()` for each object. The beauty of polymorphism is evident
    when you use these classes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete code for this example (`ch01/encapsulate.py`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when the payment method changes, the program adapts to produce
    the expected outcome.
  prefs: []
  type: TYPE_NORMAL
- en: By encapsulating what varies—here, the *payment method*—you can easily add new
    options or modify existing ones without affecting the core payment processing
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: An example – encapsulating using a property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s define a `Circle` class and show how to use Python’s `@property` technique
    to create a *getter* and a *setter* for its `radius` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the underlying attribute would actually be called `_radius`, but it
    is hidden/protected behind the *property* called `radius`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the `Circle` class with its initialization method, where
    we initialize the `_radius` attribute as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add the radius property: a `radius()` method where we return the value from
    the underlying attribute, decorated using the `@property` decorator, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add the radius setter part: another `radius()` method where we do the actual
    job of modifying the underlying attribute, after a validation check, since we
    do not want to allow a negative value for the radius; this method is decorated
    by the special `@radius.setter` decorator. This part of the code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add some lines that will help us test the class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete code for this example (`ch01/encapsulate_bis.py`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the example, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this second example, we saw how we can encapsulate the circle’s radius component
    so that we can change the technical aspects if needed, without breaking the class.
    For example, the validation code for the *setter* can evolve. We can even change
    the underlying attribute, `_radius`, and the behavior for the user of our code
    will remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Following the Favor Composition Over Inheritance principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OOP, it’s tempting to create complex hierarchies of classes through inheritance.
    While inheritance has its merits, it can lead to tightly coupled code that is
    hard to maintain and extend. This is where the principle of *Favor Composition
    Over Inheritance* comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle advises that you should prefer composing objects from simpler
    parts to inheriting functionalities from a base class. In other words, build complex
    objects by combining simpler ones.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choosing composition over inheritance offers several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: Composition allows you to change objects’ behavior at runtime,
    making your code more adaptable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Smaller, simpler objects can be reused across different parts
    of your application, promoting code reusability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of maintenance**: With composition, you can easily swap out or update
    individual components without affecting the overall system, avoiding border effects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, composition is often achieved through OOP by including instances
    of other classes within a class. This is sometimes referred to as a “has-a” relationship
    between the class that is being composed and the classes that are being included.
    Python makes it particularly easy to use composition by not requiring explicit
    type declarations. You can include other objects by simply instantiating them
    in the class’s `__init__` method or by passing them as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: An example – compose a car using the engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, you can use composition by including instances of other classes
    within your class. For example, consider a `Car` class that includes an instance
    of an `Engine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first define the `Engine` class as follows, with its `start` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s define the `Car` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the following lines of code to create an instance of the `Car`
    class and call the `start` method on that instance, when this program is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete code for this example (`ch01/composition.py`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this example, the `Car` class is composed of an `Engine` object,
    thanks to the `self.engine = Engine()` line, allowing you to easily swap out the
    engine for another type without altering the `Car` class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Following the Program to Interfaces, Not Implementations principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software design, it’s easy to get caught up in the specifics of how a feature
    is implemented. However, focusing too much on implementation details can lead
    to code that is tightly coupled and difficult to modify. The principle of *Program
    to Interfaces, Not Implementations* offers a solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface defines a **contract** for classes, specifying a set of methods
    that must be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: This principle encourages you to code against an interface rather than a concrete
    class. By doing so, you untie your code from the specific classes that provide
    the required behavior, making it easier to swap or extend implementations without
    affecting the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Programming to interfaces offers several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: You can easily switch between different implementations without
    altering the code that uses them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Losing your code from specific implementations makes it
    easier to update or replace components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Interfaces make it simpler to write unit tests, as you can
    easily mock the interface during testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, *interfaces* can be implemented using two primary techniques: **abstract
    base classes** (**ABCs**) and protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract base classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ABCs*, provided by the `abc` module, allow you to define *abstract methods*
    that must be implemented by any concrete (i.e., non-abstract) subclass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand this concept with an example, where we will define an abstract
    class (for an interface) and then use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the `ABC` class and the `abstractmethod` decorator
    function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the interface class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define a concrete class for that interface; it inherits from the interface
    class and provides an implementation for the `do_something` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines for testing purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete code (`ch01/abstractclass.py`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to define an interface and a concrete class implementing that
    interface in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Introduced in Python 3.8 via the `typing` module, *Protocols* offer a more flexible
    approach than ABCs, known as *structural duck typing*, where an object is considered
    valid if it has certain attributes or methods, regardless of its actual inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional duck typing, where type compatibility is determined at runtime,
    structural duck typing allows for type checking at compile time. This means that
    you can catch type errors before your code even runs (while in your IDE, for example),
    making your programs more robust and easier to debug.
  prefs: []
  type: TYPE_NORMAL
- en: The key advantage of using *Protocols* is that they focus on what an object
    can do, rather than what it is. In other words, *if an object walks like a duck
    and quacks like a duck, it’s a duck*, regardless of its actual inheritance hierarchy.
    This is particularly useful in a dynamically typed language such as Python, where
    an object’s behavior is more important than its actual type.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can define a `Drawable` protocol that requires a `draw()` method.
    Any class that implements this method would implicitly satisfy the protocol without
    having to explicitly inherit from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick example to illustrate the concept. Let’s say you need a Protocol
    named `Flyer` that requires a `fly()` method. You can define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! Now, any class that has a `fly()` method would be considered
    `Flyer`, whether it explicitly inherits from the `Flyer` class or not. This is
    a powerful feature that allows you to write more generic and reusable code and
    adheres to the principle of composition over inheritance, a principle that we
    previously discussed in the *Following the “Favor Composition Over Inheritance”*
    *principle* section.
  prefs: []
  type: TYPE_NORMAL
- en: In a later example, we will see a practical use of Protocols.
  prefs: []
  type: TYPE_NORMAL
- en: An example – different types of logger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using ABCs, let’s create a logging interface that allows for different types
    of logging mechanisms. Here’s how you could implement that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import what is needed from `abc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `Logger` interface with a `log` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define two concrete classes that implement the `Logger` interface for
    two different types of `Logger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, to use each type of logger, define a function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the function takes as its first argument an object of type `Logger`,
    meaning an instance of a concrete class that implements the `Logger` interface
    (i.e., `ConsoleLogger` or `FileLogger`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add the lines needed to test the code, calling the `log_message` function
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete code for this example (`ch01/interfaces.py`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to that output, looking in the folder from which you run the command,
    you will find that a file called `log.txt` has been created, containing the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you just saw with the `log_message` function, you can easily switch between
    different logging mechanisms without changing the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: An example – different types of logger, now using Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s revisit the previous example with the *Protocols* way of defining interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the `Protocol` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, defining the `Logger` interface is done by inheriting from the `Protocol`
    class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And the rest of the code stays unchanged.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, the complete code (`ch01/interfaces_bis.py`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the static typing of the code based on the protocol we defined, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the same result as when running the previous version—in other
    words, the `log.txt` file created and the following output in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is normal since the only thing we changed is the way we define the interface.
    And, the effect of the interface (the protocol) is not enforced at runtime, meaning
    it does not change the actual result of the code execution.
  prefs: []
  type: TYPE_NORMAL
- en: Following the Loose Coupling principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As software grows in complexity, the relationships between its components can
    become tangled, leading to a system that is hard to understand, maintain, and
    extend. The principle of *Loose Coupling* aims to mitigate this issue.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Loose coupling* refers to minimizing the dependencies between different parts
    of a program. In a loosely coupled system, components are independent and interact
    through well-defined interfaces, making it easier to make changes to one part
    without affecting others.'
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loose coupling offers several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability**: With fewer dependencies, it’s easier to update or replace
    individual components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility**: A loosely coupled system can be more easily extended with
    new features or components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Independent components are easier to test in isolation, improving
    the overall quality of your software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for loose coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two primary techniques for achieving *loose coupling* are **dependency injection**
    and the **observer pattern**. *Dependency injection* allows a component to receive
    its dependencies from an external source rather than creating them, making it
    easier to swap or mock these dependencies. The *observer pattern*, on the other
    hand, allows an object to publish changes to its state so that other objects can
    react accordingly, without being tightly bound to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Both techniques aim to reduce the interdependencies between components, making
    the system you are building more modular and easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the *observer pattern* in detail in [*Chapter 5*](B21896_05.xhtml#_idTextAnchor121),
    *Behavioral Design Patterns*. For now, let’s study an example to understand how
    to use the *dependency* *injection* technique.
  prefs: []
  type: TYPE_NORMAL
- en: An example – a message service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, you can achieve loose coupling by using *dependency injection*.
    Let’s see a simple example involving a `MessageService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the `MessageService` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the class will be initialized by passing a sender object to
    it; that object has a `send` method to allow sending messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Second, let’s define an `EmailSender` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Third, let’s define an `SMSSender` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can instantiate `MessageService` using an `EmailSender` object and use
    it to send a message. We can also instantiate `MessageService` using an `SMSSender`
    object instead. We add code to test both actions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete code for this example, saved in the `ch01/loose_coupling.py` file,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `MessageService` is loosely coupled with `EmailSender` and
    `SMSSender` through dependency injection. This allows you to easily switch between
    different sending mechanisms without modifying the `MessageService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began the book with the foundational design principles that developers should
    follow for writing maintainable, flexible, and robust software. From encapsulating
    what varies to favoring composition, programming to interfaces, and aiming for
    loose coupling, these principles provide a strong foundation for any Python developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ve seen, these principles are not just theoretical constructs but practical
    guidelines that can significantly improve the quality of your code. They set the
    stage for what comes next: diving deeper into more specialized sets of principles
    that guide object-oriented design.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into the SOLID principles, a set of five
    design principles aimed at making software designs more understandable, flexible,
    and maintainable.
  prefs: []
  type: TYPE_NORMAL
