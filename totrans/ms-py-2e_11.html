<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer203" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">11</h1>&#13;
    <h1 id="_idParaDest-305" class="chapterTitle">Debugging – Solving the Bugs</h1>&#13;
    <p class="normal">The previous chapter showed you how to add logging and tests to your code, but no matter how many tests you have, you will always have bugs. The biggest problem will always be external variables such as user input and different environments. At some point sooner or later, we will need to debug issues with our code, or worse, the code that was written by someone else.</p>&#13;
    <p class="normal">There are many debugging techniques and, most certainly, you have already used a few of them. Within this chapter, we are going to focus on print/trace debugging and interactive debugging.</p>&#13;
    <p class="normal">Debugging using print statements, stack traces, and logging is one of the most versatile methods to work with, and it is most likely the first type of debugging you ever used. Even a <code class="inlineCode">print('Hello world')</code> can be considered this type, as the output will show you that your code is being executed correctly. There is obviously no point in explaining how and where to place print statements to debug your code, but there are quite a few nice tricks using decorators and other Python modules that render this type of debugging a lot more useful, such as <code class="inlineCode">faulthandler</code>.</p>&#13;
    <p class="normal">Interactive debugging is a more complicated debugging method. It allows you to debug a program while it’s still running. Using this method, it’s even possible to change variables while the application is running and pause the application at any point desired. The downside is that it requires some knowledge about the debugger commands to be really useful.</p>&#13;
    <p class="normal">To summarize, we will cover the following topics:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Non-interactive debugging using <code class="inlineCode">print</code>, <code class="inlineCode">trace</code>, <code class="inlineCode">logging</code>, and <code class="inlineCode">faulthandler</code></li>&#13;
      <li class="bulletList">Interactive debugging using <code class="inlineCode">pdb</code>, <code class="inlineCode">ipython</code>, <code class="inlineCode">jupyter</code>, and other debuggers and debugging services</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-306" class="heading-1">Non-interactive debugging</h1>&#13;
    <p class="normal">The most basic form of<a id="_idIndexMarker845"/> debugging is adding a simple print statement into your code to see what is still working and what isn’t. This is useful in a variety of cases and likely to help solve most of your issues. </p>&#13;
    <p class="normal">Later in this chapter, we will show some interactive debugging methods, but those are not always suitable. Interactive debugging tends to become difficult or even impossible in cases such as:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Multithreaded environments</li>&#13;
      <li class="bulletList">Multiple servers</li>&#13;
      <li class="bulletList">Bugs that are hard (or take a long time) to reproduce</li>&#13;
      <li class="bulletList">Closed-off remote servers such as Google App Engine or Heroku</li>&#13;
    </ul>&#13;
    <p class="normal">Both interactive and non-interactive debugging methods have their merits, but I personally opt for non-interactive debugging 90% of the time, since a simple print/log statement is usually enough to analyze the cause of a problem. I find interactive debugging to be mostly helpful when writing code which uses large and complicated external libraries, where it can be hard to analyze which attributes, properties, and methods are available for objects.</p>&#13;
    <p class="normal">A basic example of this (I’ve been known to do similar) with a generator can be as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">hiding_generator</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'a'</span>)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">yield</span> <span class="hljs-con-string">'first value'</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'b'</span>)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">yield</span> <span class="hljs-con-string">'second value'</span>&#13;
<span class="hljs-con-meta">...</span>     print(<span class="hljs-con-string">'c'</span>)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> generator = hiding_generator()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span>(generator)&#13;
a&#13;
'first value'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span>(generator)&#13;
b&#13;
'second value'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span>(generator)&#13;
Traceback (most recent call last):&#13;
<span class="hljs-con-meta">...</span>&#13;
StopIteration&#13;
</code></pre>&#13;
    <p class="normal">This shows exactly where the code does, and consequently, does not reach. Without this example, you might have expected the first <code class="inlineCode">print</code> to come immediately after the <code class="inlineCode">hiding_generator()</code> call. Since it’s a generator, however, nothing will be executed until we <code class="inlineCode">yield</code> an item. Assuming you would have some setup code before the first <code class="inlineCode">yield</code>, it won’t run until <code class="inlineCode">next</code> is actually called. Additionally, <code class="inlineCode">print('c')</code> is never executed and can be considered unreachable code.</p>&#13;
    <p class="normal">Although this is one of <a id="_idIndexMarker846"/>the simplest ways to debug functions using <code class="inlineCode">print</code> calls, it’s not always the most convenient way. We can start by making an auto-print function that prints the line of code that it’s going to execute:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> os&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> inspect&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> linecache&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">print_code</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">while</span> <span class="hljs-con-literal">True</span>:&#13;
<span class="hljs-con-meta">...</span>         info = inspect.stack()[<span class="hljs-con-number">1</span>]&#13;
<span class="hljs-con-meta">...</span>         lineno = info.lineno + <span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span>         function = info.function&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-comment"># Fetch the next line of code</span>&#13;
<span class="hljs-con-meta">...</span>         code = linecache.getline(info.filename, lineno)&#13;
<span class="hljs-con-meta">...</span>         print(<span class="hljs-con-string">f'</span><span class="hljs-con-subst">{lineno:03d}</span><span class="hljs-con-string"> </span><span class="hljs-con-subst">{function}</span><span class="hljs-con-string">: </span><span class="hljs-con-subst">{code.strip()}</span><span class="hljs-con-string">'</span>)&#13;
<span class="hljs-con-meta">...</span>         <span class="hljs-con-keyword">yield</span>&#13;
&#13;
<span class="hljs-con-comment"># Always prime the generator</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> print_code = print_code()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_test_function</span><span class="hljs-con-function">(</span><span class="hljs-con-params">a, b</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-built_in">next</span>(print_code)&#13;
<span class="hljs-con-meta">...</span>     c = a + b&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-built_in">next</span>(print_code)&#13;
<span class="hljs-con-meta">...</span>     <span class="hljs-con-keyword">return</span> c&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_test_function(<span class="hljs-con-string">'a'</span>, <span class="hljs-con-string">'b'</span>)&#13;
003 some_test_function: c = a + b&#13;
005 some_test_function: return c&#13;
'ab'&#13;
</code></pre>&#13;
    <p class="normal">As you can see, it <a id="_idIndexMarker847"/>automatically prints the line number, the name of the function, and the line of code it will execute next for you. That way, if you have a slow bit of code, you can see which line is stalling because it will be printed before execution.</p>&#13;
    <p class="normal">With this specific instance, there’s no real use for a generator, but you could easily incorporate some timings so you can see the delay between two <code class="inlineCode">next(print_code)</code> statements. Or perhaps a counter to see how often this particular bit of code has been run.</p>&#13;
    <h2 id="_idParaDest-307" class="heading-2">Inspecting your script using trace</h2>&#13;
    <p class="normal">Simple <a id="_idIndexMarker848"/>print statements are useful in a lot of cases since you can <a id="_idIndexMarker849"/>easily incorporate print statements in nearly every<a id="_idIndexMarker850"/> application. It does not matter whether it’s remote or local, threaded or using multiprocessing. It works almost everywhere, making it the most universal solution available – in addition to logging, that is. The general solution is often not the best solution for every situation, however. A nice alternative to our previous function is the <code class="inlineCode">trace</code> module. It offers you a way to trace every executed line, including the runtime. The downside of tracing so much data is that it can quickly become overly verbose, as we will see in the next example.</p>&#13;
    <p class="normal">To demonstrate, we will use our previous code but without print statements:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">some_test_function</span><span class="hljs-function">(</span><span class="hljs-params">a, b</span><span class="hljs-function">):</span>&#13;
    c = a + b&#13;
    <span class="hljs-keyword">return</span> c&#13;
&#13;
print(some_test_function(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>))&#13;
</code></pre>&#13;
    <p class="normal">Now we execute the code with the <code class="inlineCode">trace</code> module:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 -m trace --trace --timing T_01_trace.py&#13;
 --- modulename: T_01_trace, funcname: &lt;module&gt;&#13;
0.00 T_01_trace.py(1): def some_test_function(a, b):&#13;
0.00 T_01_trace.py(6): print(some_test_function('a', 'b'))&#13;
 --- modulename: T_01_trace, funcname: some_test_function&#13;
0.00 T_01_trace.py(2):     c = a + b&#13;
0.00 T_01_trace.py(3):     return c&#13;
ab&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">trace</code> module shows you exactly which line is being executed with function names and, more importantly, which line was caused by which statement (or statements). Additionally, it shows you at what time it was executed relative to the start time of the program. This is due to the <code class="inlineCode">--timing</code> flag.</p>&#13;
    <p class="normal">And it still seems fairly reasonable in terms of output, right? Within this example, it does because this is about the most basic code there is. As soon as you add an <code class="inlineCode">import</code>, for example, your <a id="_idIndexMarker851"/>screen will be flooded with output. In spite of the fact that you can opt to ignore specific<a id="_idIndexMarker852"/> modules and directories by using command-line <a id="_idIndexMarker853"/>parameters, it is still too verbose in many cases.</p>&#13;
    <p class="normal">We can also enable the <code class="inlineCode">trace</code> module selectively with a little bit of effort:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> sys&#13;
<span class="hljs-keyword">import</span> trace <span class="hljs-keyword">as</span> trace_module&#13;
<span class="hljs-keyword">import</span> contextlib&#13;
&#13;
<span class="hljs-meta">@contextlib.contextmanager</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">trace</span><span class="hljs-function">(</span><span class="hljs-params">count=</span><span class="hljs-literal">False</span><span class="hljs-params">, trace=</span><span class="hljs-literal">True</span><span class="hljs-params">, timing=</span><span class="hljs-literal">True</span><span class="hljs-function">):</span>&#13;
    tracer = trace_module.Trace(&#13;
        count=count, trace=trace, timing=timing)&#13;
    sys.settrace(tracer.globaltrace)&#13;
    <span class="hljs-keyword">yield</span> tracer&#13;
    sys.settrace(<span class="hljs-literal">None</span>)&#13;
&#13;
    result = tracer.results()&#13;
    result.write_results(show_missing=<span class="hljs-literal">False</span>, summary=<span class="hljs-literal">True</span>)&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">some_test_function</span><span class="hljs-function">(</span><span class="hljs-params">a, b</span><span class="hljs-function">):</span>&#13;
    c = a + b&#13;
    <span class="hljs-keyword">return</span> c&#13;
&#13;
<span class="hljs-keyword">with</span> trace():&#13;
    print(some_test_function(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>))&#13;
</code></pre>&#13;
    <p class="normal">This code shows a context manager that temporarily enables and disables the <code class="inlineCode">trace</code> module to selectively trace code. In this example, we used <code class="inlineCode">sys.settrace</code> with <code class="inlineCode">tracer.globaltrace</code> as an argument, but you could also hook to your own tracing functions to customize the output.</p>&#13;
    <p class="normal">When<a id="_idIndexMarker854"/> executing this, we get this output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 T_02_selective_trace.py&#13;
 --- modulename: T_02_selective_trace, funcname: some_test_function&#13;
0.00 T_02_selective_trace.py(19):     c = a + b&#13;
0.00 T_02_selective_trace.py(20):     return c&#13;
ab&#13;
 --- modulename: contextlib, funcname: __exit__&#13;
0.00 contextlib.py(122):         if type is None:&#13;
0.00 contextlib.py(123):             try:&#13;
0.00 contextlib.py(124):                 next(self.gen)&#13;
 --- modulename: T_02_selective_trace, funcname: trace&#13;
0.00 T_02_selective_trace.py(12):     sys.settrace(None)&#13;
</code></pre>&#13;
    <p class="normal">Now, to illustrate, if <a id="_idIndexMarker855"/>we were to run the same code with the trace module enabled, we would get a lot of output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 -m trace --trace --timing T_02_selective_trace.py | wc&#13;
    256    2940   39984&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">wc</code> (word count) command<a id="_idIndexMarker856"/> shows us that this command gave us <code class="inlineCode">252</code> lines, <code class="inlineCode">2881</code> words, or <code class="inlineCode">38716</code> characters of output, so I would generally recommend using the context decorator instead. Executing a trace on any reasonably sized script will generate a scary amount of output.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">There are a few extra options with the <code class="inlineCode">trace</code> module, such as showing which code is (not) executed, which can be useful to detect code coverage.</p>&#13;
    </div>&#13;
    <p class="normal">In addition to the arguments we already passed to <code class="inlineCode">trace</code>, we can easily change the output or add extra filters by wrapping or replacing <code class="inlineCode">tracer.globaltrace</code> as the <code class="inlineCode">sys.settrace()</code> argument. As arguments, the function needs to accept <code class="inlineCode">frame</code>, <code class="inlineCode">event</code>, and <code class="inlineCode">arg</code>.</p>&#13;
    <p class="normal">The <code class="inlineCode">frame</code> is a Python stack frame that contains references to the code and the filename and can be used to inspect the scope at that point in the stack. This is the same frame you can extract when using the <code class="inlineCode">traceback</code> module.</p>&#13;
    <p class="normal">The <code class="inlineCode">event</code> argument is a string that can have the following values (from the standard Python documentation):</p>&#13;
    <table id="table001-1" class="table-container">&#13;
      <thead>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Parameter</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Description</strong></p>&#13;
          </td>&#13;
        </tr>&#13;
      </thead>&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">call</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">A function is called (or some other code block entered). The global trace function is called; <code class="inlineCode">arg</code> is <code class="inlineCode">None</code>. The return value specifies the local trace function.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">line</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">The interpreter is about to execute a new line of code or re-execute the condition of a loop. The local trace function is called; <code class="inlineCode">arg</code> is <code class="inlineCode">None</code>; the return value specifies the new local trace function. See <code class="inlineCode">Objects/lnotab_notes.txt</code> (in the Python source repository) for a detailed explanation of how this works. Per-line events may be disabled for a frame by setting <code class="inlineCode">f_trace_lines</code> to <code class="inlineCode">False</code> on that <code class="inlineCode">frame</code>.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">return</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">A function (or another code block) is about to return. The local trace function is called; <code class="inlineCode">arg</code> is the value that will be returned, or <code class="inlineCode">None</code> if the event is caused by an exception being raised. The trace function’s return value is ignored.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">exception</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">This means an exception has occurred. The local trace function is called; <code class="inlineCode">arg</code> is a tuple (<code class="inlineCode">exception</code>, <code class="inlineCode">value</code>, <code class="inlineCode">traceback</code>). The return value specifies the new local trace function.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">opcode</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">The interpreter is about to execute a new opcode (see the <code class="inlineCode">dis</code> module for opcode details). The local trace function is called; <code class="inlineCode">arg</code> is <code class="inlineCode">None</code>; the return value specifies the new local trace function. Per-opcode events are not emitted by default: they must be explicitly requested by setting <code class="inlineCode">f_trace_opcodes</code> to <code class="inlineCode">True</code> on the frame.</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="normal">Lastly, the <code class="inlineCode">arg</code> argument<a id="_idIndexMarker857"/> depends on the <code class="inlineCode">event</code> argument as illustrated by the documentation <a id="_idIndexMarker858"/>above. In general, if <code class="inlineCode">arg</code> is <code class="inlineCode">None</code>, the return value of this<a id="_idIndexMarker859"/> function will be used as the local trace function, allowing you to override this for a specific scope. With <code class="inlineCode">exception</code> events, it will be a tuple containing <code class="inlineCode">exception</code>, <code class="inlineCode">value</code>, and <code class="inlineCode">traceback</code>.</p>&#13;
    <p class="normal">Now let’s create a little snippet that can selectively trace our code by filtering on filename:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> sys&#13;
<span class="hljs-keyword">import</span> trace <span class="hljs-keyword">as</span> trace_module&#13;
<span class="hljs-keyword">import</span> contextlib&#13;
&#13;
<span class="hljs-meta">@contextlib.contextmanager</span>&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">trace</span><span class="hljs-function">(</span><span class="hljs-params">filename</span><span class="hljs-function">):</span>&#13;
    tracer = trace_module.Trace()&#13;
&#13;
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">custom_trace</span><span class="hljs-function">(</span><span class="hljs-params">frame, event, arg</span><span class="hljs-function">):</span>&#13;
        <span class="hljs-comment"># Only trace for the given filename</span>&#13;
        <span class="hljs-keyword">if</span> filename != frame.f_code.co_filename:&#13;
            <span class="hljs-keyword">return</span> custom_trace&#13;
&#13;
        <span class="hljs-comment"># Let globaltrace handle the rest</span>&#13;
        <span class="hljs-keyword">return</span> tracer.globaltrace(frame, event, arg)&#13;
&#13;
    sys.settrace(custom_trace)&#13;
    <span class="hljs-keyword">yield</span> tracer&#13;
    sys.settrace(<span class="hljs-literal">None</span>)&#13;
&#13;
    result = tracer.results()&#13;
    result.write_results(show_missing=<span class="hljs-literal">False</span>, summary=<span class="hljs-literal">True</span>)&#13;
&#13;
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">some_test_function</span><span class="hljs-function">(</span><span class="hljs-params">a, b</span><span class="hljs-function">):</span>&#13;
    c = a + b&#13;
    <span class="hljs-keyword">return</span> c&#13;
&#13;
<span class="hljs-comment"># Pass our current filename as '__file__'</span>&#13;
<span class="hljs-keyword">with</span> trace(filename=__file__):&#13;
    print(some_test_function(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>))&#13;
</code></pre>&#13;
    <p class="normal">By using the <code class="inlineCode">frame</code> argument, we can retrieve the code we are currently executing, and from that, the <a id="_idIndexMarker860"/>filename the code<a id="_idIndexMarker861"/> currently exists in. Naturally, you could also filter for different functions or only filter to a specific depth. Since we hand the tracing and outputting<a id="_idIndexMarker862"/> off to <code class="inlineCode">tracer.globaltrace()</code>, we only check the <code class="inlineCode">filename</code> for a place up in the stack. You could return <code class="inlineCode">trace()</code> instead and handle the <code class="inlineCode">print()</code> yourself.</p>&#13;
    <p class="normal">When executing this code, you should get:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_03_filename_trace.py&#13;
 --- modulename: T_03_filename_trace, funcname: some_test_function&#13;
T_03_filename_trace.py(27):     c = a + b&#13;
T_03_filename_trace.py(28):     return c&#13;
ab&#13;
 --- modulename: T_03_filename_trace, funcname: trace&#13;
T_03_filename_trace.py(20):     sys.settrace(None)&#13;
lines   cov%   module   (path)&#13;
    3   100%   T_03_filename_trace   (T_03_filename_trace.py)&#13;
</code></pre>&#13;
    <p class="normal">As you<a id="_idIndexMarker863"/> can see, this excludes the code from <code class="inlineCode">contextlib</code>, which <a id="_idIndexMarker864"/>we<a id="_idIndexMarker865"/> saw in the earlier example.</p>&#13;
    <h2 id="_idParaDest-308" class="heading-2">Debugging using logging</h2>&#13;
    <p class="normal">In <em class="chapterRef">Chapter 10</em>, <em class="italic">Testing and Logging – Preparing for Bugs</em>, we saw <a id="_idIndexMarker866"/>how to create custom loggers, set the levels for them, and add handlers to specific levels. We are going to use the <code class="inlineCode">logging.DEBUG</code> level <a id="_idIndexMarker867"/>to log now, which is nothing special by itself, but with a few decorators, we can add some very useful debug-only code.</p>&#13;
    <p class="normal">Whenever I’m debugging, I always find it very useful to know the input and output for a function. The basic version with a decorator is simple enough to write; just print the <code class="inlineCode">args</code>, <code class="inlineCode">kwargs</code>, and <code class="inlineCode">return</code> value and you are done. The following example goes a little further. By using the <code class="inlineCode">inspect</code> module, we can retrieve the default arguments as well, making it possible to show all arguments with the argument names and values in all cases, even if the argument was not specified:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pprint&#13;
<span class="hljs-keyword">import</span> inspect&#13;
<span class="hljs-keyword">import</span> logging&#13;
<span class="hljs-keyword">import</span> functools&#13;
&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">function</span>):&#13;
<span class="hljs-meta">    @functools.wraps(</span><span class="hljs-params">function</span><span class="hljs-meta">)</span>&#13;
    <span class="hljs-keyword">def</span> <span class="hljs-title">_debug</span>(<span class="hljs-params">*args, **kwargs</span>):&#13;
        <span class="hljs-comment"># Make sure 'result' is always defined</span>&#13;
        result = <span class="hljs-literal">None</span>&#13;
        <span class="hljs-keyword">try</span>:&#13;
            result = function(*args, **kwargs)&#13;
            <span class="hljs-keyword">return</span> result&#13;
        <span class="hljs-keyword">finally</span>:&#13;
            <span class="hljs-comment"># Extract the signature from the function</span>&#13;
            signature = inspect.signature(function)&#13;
            <span class="hljs-comment"># Fill the arguments</span>&#13;
            arguments = signature.bind(*args, **kwargs)&#13;
            <span class="hljs-comment"># </span><span class="hljs-doctag">NOTE:</span><span class="hljs-comment"> This only works for Python 3.5 and up!</span>&#13;
            arguments.apply_defaults()&#13;
            logging.debug(<span class="hljs-string">'%s(%s): %s'</span> % (&#13;
                function.__qualname__,&#13;
                <span class="hljs-string">', '</span>.join(<span class="hljs-string">'%s=%r'</span> % (k, v) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span>&#13;
                          arguments.arguments.items()),&#13;
                pprint.pformat(result),&#13;
            ))&#13;
&#13;
    <span class="hljs-keyword">return</span> _debug&#13;
&#13;
<span class="hljs-meta">@debug</span>&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b=</span><span class="hljs-number">123</span>):&#13;
    <span class="hljs-keyword">return</span> a + b&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    logging.basicConfig(level=logging.DEBUG)&#13;
&#13;
    add(<span class="hljs-number">1</span>)&#13;
    add(<span class="hljs-number">1</span>, <span class="hljs-number">456</span>)&#13;
    add(b=<span class="hljs-number">1</span>, a=<span class="hljs-number">456</span>)&#13;
</code></pre>&#13;
    <p class="normal">Let’s analyze <a id="_idIndexMarker868"/>how this <a id="_idIndexMarker869"/>code executes:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">The decorator executes <code class="inlineCode">function()</code> as normal with the given <code class="inlineCode">*args</code> and <code class="inlineCode">**kwargs</code> passed along unmodified, while storing the result to both display and <code class="inlineCode">return</code> later. </li>&#13;
      <li class="numberedList">The <code class="inlineCode">finally</code> section of the <code class="inlineCode">try</code>/<code class="inlineCode">finally</code> generates an <code class="inlineCode">inspect.Signature()</code> object from <code class="inlineCode">function()</code>.</li>&#13;
      <li class="numberedList">Now we generate an <code class="inlineCode">inspect.BoundArguments()</code> object by binding <code class="inlineCode">*args</code> and <code class="inlineCode">**kwargs</code> using the previously generated <code class="inlineCode">signature</code>.</li>&#13;
      <li class="numberedList">Now we can tell the <code class="inlineCode">inspect.BoundArguments()</code> object to apply the default arguments so we can see the value of arguments not passed in <code class="inlineCode">*args</code> and <code class="inlineCode">**kwargs</code>.</li>&#13;
      <li class="numberedList">Lastly, we output the full function name, the formatted arguments, and the <code class="inlineCode">result</code>.</li>&#13;
    </ol>&#13;
    <p class="normal">When we execute the code, we should see the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 T_04_logging.py&#13;
DEBUG:root:add(a=1, b=123): 124&#13;
DEBUG:root:add(a=1, b=456): 457&#13;
DEBUG:root:add(a=456, b=1): 457&#13;
</code></pre>&#13;
    <p class="normal">Very nice of course, as we have a clear sight of when the function is called, which parameters were used, and what is returned. However, this is something you will probably only execute when you are actively debugging your code. </p>&#13;
    <p class="normal">You can also make the regular <code class="inlineCode">logging.debug</code> statements in your code quite a bit more useful by adding a debug-specific logger, which<a id="_idIndexMarker870"/> shows more information. Simply replace the logging config of the preceding<a id="_idIndexMarker871"/> example with this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging&#13;
&#13;
log_format = (&#13;
    <span class="hljs-string">'[%(relativeCreated)d %(levelname)s] '</span>&#13;
    <span class="hljs-string">'%(filename)s:%(lineno)d:%(funcName)s: %(message)s'</span>&#13;
)&#13;
logging.basicConfig(level=logging.DEBUG, <span class="hljs-built_in">format</span>=log_format)&#13;
</code></pre>&#13;
    <p class="normal">Then your result will be something like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 T_05_logging_config.py&#13;
[DEBUG] T_05_logging_config.py:20:_debug: add(a=1, b=123): 124&#13;
[DEBUG] T_05_logging_config.py:20:_debug: add(a=1, b=456): 457&#13;
[DEBUG] T_05_logging_config.py:20:_debug: add(a=456, b=1): 457&#13;
</code></pre>&#13;
    <p class="normal">It shows the time relative to the start of the application in milliseconds and the log level. This is followed by an identification block that shows the filename, line number, and function name that originated the logs. Of course, there is a <code class="inlineCode">message</code> at the end, which contains the result of our log call.</p>&#13;
    <h2 id="_idParaDest-309" class="heading-2">Showing the call stack without exceptions</h2>&#13;
    <p class="normal">When<a id="_idIndexMarker872"/> looking at how and why a piece of code is being run, it’s often <a id="_idIndexMarker873"/>useful to see the entire <a id="_idIndexMarker874"/>stack trace. Simply raising an exception is, of course, an option. However, that will kill the current code execution, which is generally not something we are looking for. This is where the <code class="inlineCode">traceback</code> module comes in handy. With just a simple call to <code class="inlineCode">traceback.print_stack()</code>, we get a full stack list:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> sys&#13;
<span class="hljs-keyword">import</span> traceback&#13;
&#13;
<span class="hljs-keyword">class</span> <span class="hljs-title">ShowMyStack</span>:&#13;
    <span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self, limit=</span><span class="hljs-literal">None</span>):&#13;
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Before stack print'</span>)&#13;
        traceback.print_stack(limit=limit)&#13;
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'After stack print'</span>)&#13;
&#13;
<span class="hljs-keyword">class</span> <span class="hljs-title">InheritShowMyStack</span>(<span class="hljs-title">ShowMyStack</span>):&#13;
    <span class="hljs-keyword">pass</span>&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    show_stack = InheritShowMyStack()&#13;
&#13;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Stack without limit'</span>)&#13;
    show_stack.run()&#13;
    <span class="hljs-built_in">print</span>()&#13;
&#13;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Stack with limit 1'</span>)&#13;
    show_stack.run(<span class="hljs-number">1</span>)&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">ShowMyStack.run()</code> function shows a regular <code class="inlineCode">traceback.print_stack()</code> call, which shows the entire stack trace to that point in the stack. You could place <code class="inlineCode">traceback.print_stack()</code> anywhere in your code to see where it is being called from.</p>&#13;
    <p class="normal">Since the full stack trace can be quite large, it is often useful to use the <code class="inlineCode">limit</code> argument to only show a few<a id="_idIndexMarker875"/> levels, which is what we do in the second run.</p>&#13;
    <p class="normal">This results in the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_06_stack.py&#13;
Stack without limit&#13;
Before stack print&#13;
  File "T_06_stack.py", line 20, in &lt;module&gt;&#13;
    show_stack.run()&#13;
  File "T_06_stack.py", line 8, in run&#13;
    traceback.print_stack(limit=limit)&#13;
After stack print&#13;
&#13;
Stack with limit 1&#13;
Before stack print&#13;
  File "T_06_stack.py", line 8, in run&#13;
    traceback.print_stack(limit=limit)&#13;
After stack print&#13;
</code></pre>&#13;
    <p class="normal">As you can see, the <a id="_idIndexMarker876"/>traceback simply prints without any exceptions. The <code class="inlineCode">traceback</code> module actually has quite a few other methods for printing tracebacks based on exceptions and such, but you probably won’t need them often. The most useful one is probably the <code class="inlineCode">limit</code> parameter we’ve demonstrated. A positive limit number shows you only a specific number of frames. In most cases, you don’t need a full stack trace, so this can be quite useful to limit the output.</p>&#13;
    <p class="normal">Alternatively, we can<a id="_idIndexMarker877"/> also specify a negative limit, which trims the stack from the other side. This is mostly useful when printing the stack from a decorator where you want to hide the decorator from the trace. If you want to limit both sides, you will have to do it manually using <code class="inlineCode">format_list(stack)</code> with a stack from <code class="inlineCode">extract_stack(f, limit)</code>, the usage of which is similar to the <code class="inlineCode">print_stack()</code> function.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The negative limit support was added in Python 3.5. Before that, only positive limits were supported.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-310" class="heading-2">Handling crashes using faulthandler</h2>&#13;
    <p class="normal">The <code class="inlineCode">faulthandler</code> module <a id="_idIndexMarker878"/>helps when debugging really low-level crashes, that is, crashes that should only be possible when using low-level access to <a id="_idIndexMarker879"/>memory, such as C extensions.</p>&#13;
    <p class="normal">For example, here’s a bit of code that <em class="italic">will</em> cause your Python interpreter to crash:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> ctypes&#13;
&#13;
<span class="hljs-comment"># Get memory address 0, your kernel shouldn't allow this:</span>&#13;
ctypes.string_at(<span class="hljs-number">0</span>)&#13;
</code></pre>&#13;
    <p class="normal">It results in something similar to the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 T_07_faulthandler.py&#13;
zsh: segmentation fault  python3 T_07_faulthandler.py&#13;
</code></pre>&#13;
    <p class="normal">That’s quite an ugly response, of course, and gives you no possibility to handle the error. Just in case you are wondering, having a <code class="inlineCode">try/except</code> structure won’t help you in these cases either. The following code will crash in exactly the same way:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> ctypes&#13;
&#13;
<span class="hljs-keyword">try</span>:&#13;
    <span class="hljs-comment"># Get memory address 0, your kernel shouldn't allow this:</span>&#13;
    ctypes.string_at(<span class="hljs-number">0</span>)&#13;
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:&#13;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got exception:'</span>, e)&#13;
</code></pre>&#13;
    <p class="normal">This is where the <code class="inlineCode">faulthandler</code> module helps. It will still cause your interpreter to crash, but at least you will<a id="_idIndexMarker880"/> see a proper error message raised, so it’s a good default if you (or any of the sub-libraries) have any interaction with raw memory:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> ctypes&#13;
<span class="hljs-keyword">import</span> faulthandler&#13;
&#13;
faulthandler.enable()&#13;
&#13;
<span class="hljs-comment"># Get memory address 0, your kernel shouldn't allow this:</span>&#13;
ctypes.string_at(<span class="hljs-number">0</span>)&#13;
</code></pre>&#13;
    <p class="normal">It results in something along these lines:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 T_09_faulthandler_enabled.py&#13;
Fatal Python error: Segmentation fault&#13;
&#13;
Current thread 0x0000000110382e00 (most recent call first):&#13;
  File python3.9/ctypes/__init__.py", line 517 in string_at&#13;
  File T_09_faulthandler.py", line 7 in &lt;module&gt;&#13;
zsh: segmentation fault  python3 T_09_faulthandler_enabled.py&#13;
</code></pre>&#13;
    <p class="normal">Obviously, it’s<a id="_idIndexMarker881"/> not desirable to have <a id="_idIndexMarker882"/>a Python application exit in this manner as the code won’t exit with a normal cleanup. Resources won’t be closed cleanly and your exit handler won’t be called. If you somehow need to catch this behavior, your best bet is to wrap the Python executable in a separate script using something like <code class="inlineCode">subprocess.run([sys.argv[0], '</code> <code class="inlineCode">T_09_faulthandler_enabled.py'])</code>. </p>&#13;
    <h1 id="_idParaDest-311" class="heading-1">Interactive debugging</h1>&#13;
    <p class="normal">Now that we have <a id="_idIndexMarker883"/>discussed basic debugging methods that will always work, we will look at interactive debugging for some more advanced debugging techniques. The previous debugging methods made variables and stacks visible through modifying the code and/or foresight. This time around, we will look at a slightly smarter method, which constitutes doing the same thing interactively, but once the need arises.</p>&#13;
    <h2 id="_idParaDest-312" class="heading-2">Console on demand</h2>&#13;
    <p class="normal">When testing <a id="_idIndexMarker884"/>some Python code, you may have used the interactive <a id="_idIndexMarker885"/>console a couple of times, since it’s a simple yet effective tool for testing your Python code. What you might not have known is that it is actually simple to start your own shell from within your code. So, whenever you want to drop into a regular shell from a specific point in your code, that’s easily possible:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> code&#13;
&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">start_console</span>():&#13;
    some_variable = <span class="hljs-number">123</span>&#13;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'Launching console, some_variable: </span><span class="hljs-subst">{some_variable}</span><span class="hljs-string">'</span>)&#13;
    code.interact(banner=<span class="hljs-string">'console:'</span>, local=<span class="hljs-built_in">locals</span>())&#13;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'Exited console, some_variable: </span><span class="hljs-subst">{some_variable}</span><span class="hljs-string">'</span>)&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    start_console()&#13;
</code></pre>&#13;
    <p class="normal">When executing that, we will drop into an interactive console halfway:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_10_console.py&#13;
Launching console, some_variable: 123&#13;
console:&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> some_variable = <span class="hljs-con-number">456</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span>&#13;
now exiting InteractiveConsole...&#13;
Exited console, some_variable: 123&#13;
</code></pre>&#13;
    <p class="normal">To exit this console, we can use <em class="keystroke">^d</em> (<em class="keystroke">Ctrl</em> + <em class="keystroke">D</em>) on Linux/Mac systems and <em class="keystroke">^z</em> (<em class="keystroke">Ctrl</em> + <em class="keystroke">Z</em>) on Windows systems.</p>&#13;
    <p class="normal">One<a id="_idIndexMarker886"/> important thing to note here is that the<a id="_idIndexMarker887"/> local scope is not shared between the two. Even though we passed along <code class="inlineCode">locals()</code> to share the local variables for convenience, this relation is not bidirectional. </p>&#13;
    <p class="normal">The result is that even though we set <code class="inlineCode">some_variable</code> to <code class="inlineCode">456</code> in the interactive session, it does not carry over to the outside function. You can modify variables in the outside scope through direct manipulation (for example, setting the properties) if you wish, but all variables declared locally will remain local.</p>&#13;
    <p class="normal">Naturally, modifying mutable variables will affect both scopes.</p>&#13;
    <h2 id="_idParaDest-313" class="heading-2">Debugging using Python debugger (pdb)</h2>&#13;
    <p class="normal">When it comes to <a id="_idIndexMarker888"/>actually debugging code, the <a id="_idIndexMarker889"/>regular interactive console<a id="_idIndexMarker890"/> just isn’t suited. With a bit of effort, you can make it work, but it’s just not all that convenient for debugging since you can only see the current scope and can’t jump around the stack easily. With <code class="inlineCode">pdb</code> (Python debugger), this is easily possible. So, let’s look at a simple example of using <code class="inlineCode">pdb</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pdb&#13;
&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">go_to_debugger</span>():&#13;
    some_variable = <span class="hljs-number">123</span>&#13;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Starting pdb trace'</span>)&#13;
    pdb.set_trace()&#13;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'Finished pdb, some_variable: </span><span class="hljs-subst">{some_variable}</span><span class="hljs-string">'</span>)&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    go_to_debugger()&#13;
</code></pre>&#13;
    <p class="normal">This example is pretty much identical to the one in the previous paragraph, except that this time we end up in the <code class="inlineCode">pdb</code> console instead of a regular interactive console. So let’s give the interactive debugger a try:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 T_11_pdb.py&#13;
Starting pdb trace&#13;
<span class="hljs-con-meta">&gt;</span> T_11_pdb.py(8)go_to_debugger()&#13;
<span class="hljs-con-meta">-&gt;</span> <span class="hljs-con-built_in">print</span>(f<span class="hljs-con-string">'Finished pdb, some_variable: {some_variable}'</span>)&#13;
(Pdb) some_variable&#13;
123&#13;
(Pdb) some_variable = 456&#13;
(Pdb) continue&#13;
Finished pdb, some_variable: 456&#13;
</code></pre>&#13;
    <p class="normal">As you can <a id="_idIndexMarker891"/>see, we’ve actually modified the<a id="_idIndexMarker892"/> value of <code class="inlineCode">some_variable</code> now. In this <a id="_idIndexMarker893"/>case, we used the full <code class="inlineCode">continue</code> command, but all the <code class="inlineCode">pdb</code> commands have short versions as well. So, using <code class="inlineCode">c</code> instead of <code class="inlineCode">continue</code> gives the same result. Just typing <code class="inlineCode">some_variable</code> (or any other variable) will show the contents and setting the variable will simply set it, just as we would expect from an interactive session.</p>&#13;
    <p class="normal">To get started with <code class="inlineCode">pdb</code>, first of all, a list of the most useful (full) stack movement and manipulation commands with shorthands is shown here:</p>&#13;
    <table id="table002" class="table-container">&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Command</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Explanation</strong></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">h(elp)</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">This shows the list of commands (this list).</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">h(elp) command</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">This shows the help for the given command.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">w(here)</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Current stack trace with an arrow at the current frame.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">d(own)</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Move down/to a newer frame in the stack.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">u(p)</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Move up/to an older frame in the stack.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">s(tep)</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Execute the current line and stop as soon as possible.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">n(ext)</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Execute the current line and stop at the next line within the current function.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">r(eturn)</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Continue execution until the function returns.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">c(ont(inue))</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Continue execution up to the next breakpoint.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">l(ist) [first[, last]]</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">List the lines of source code (by default, 11 lines) around the current line.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">ll | longlist</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">List all of the source code for the current function or frame.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">source expression</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">List the source code for the given object. This is similar to <code class="inlineCode">longlist</code>.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">a(rgs)</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Print the arguments for the current function.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">pp expression</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Pretty-print the given expression.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">! statement</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Execute the statement at the current point in the stack. Normally, the <code class="inlineCode">!</code> sign is not needed, but this can be useful if there are collisions with debugger commands. For example, try <code class="inlineCode">b = 123</code>.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">interact</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Open an interactive Python shell session similar to the previous paragraph.</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="normal">Many more commands are available and some of them will be covered by the following paragraphs. All commands are covered by the built-in help, however, so be sure to use the <code class="inlineCode">h/help [command]</code> command if needed.</p>&#13;
    <h3 id="_idParaDest-314" class="heading-3">Breakpoints</h3>&#13;
    <p class="normal">Breakpoints are <a id="_idIndexMarker894"/>points where the debugger will halt the code execution and allow you to debug from that point. We can create breakpoints using either code or commands. First, let’s enter the debugger using <code class="inlineCode">pdb.set_trace()</code>. This is effectively a hardcoded breakpoint:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pdb&#13;
&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">print_value</span>(<span class="hljs-params">value</span>):&#13;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'value:'</span>, value)&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    pdb.set_trace()&#13;
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):&#13;
        print_value(i)&#13;
</code></pre>&#13;
    <p class="normal">So far, nothing new has happened, but let’s now open the interactive debugging session and try a few breakpoint commands. Here’s a list of the most useful breakpoint commands<a id="_idIndexMarker895"/> before we start:</p>&#13;
    <table id="table003" class="table-container">&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Command</strong></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><strong class="keyWord">Explanation</strong></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">b(reak)</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Show the list of breakpoints.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">b(reak) [filename:]lineno</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Place a breakpoint at the given line number and, optionally, file.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">b(reak) function[, condition]</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Place a breakpoint at the given function. The condition is an expression that must evaluate to <code class="inlineCode">True</code> for the breakpoint to work.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">cl(ear) [filename:]lineno</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Clear the breakpoint (or breakpoints) at this line.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">cl(ear) breakpoint [breakpoint ...]</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Clear the breakpoint (or breakpoints) with these numbers.</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="normal">Now let’s execute this code and<a id="_idIndexMarker896"/> enter the interactive debugger to try the commands:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 T_12_pdb_loop.py&#13;
<span class="hljs-con-meta">&gt; </span>T_12_pdb_loop.py (10)&lt;module&gt;()&#13;
<span class="hljs-con-meta">-&gt; </span><span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> range(5):&#13;
(Pdb) source print_value  <span class="hljs-con-comment"># View the source of print_value</span>&#13;
  4     def print_value(value):&#13;
  5         print('value:', value)&#13;
(Pdb) b 5  <span class="hljs-con-comment"># Add a breakpoint to line 5</span>&#13;
Breakpoint 1 at T_12_pdb_loop.py:5&#13;
(Pdb) w  <span class="hljs-con-comment"># Where shows the current line</span>&#13;
<span class="hljs-con-meta">&gt; </span>T_12_pdb_loop.py (10)&lt;module&gt;()&#13;
<span class="hljs-con-meta">-&gt; </span><span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> range(5):&#13;
(Pdb) c  <span class="hljs-con-comment"># Continue (until the next breakpoint or exception)</span>&#13;
<span class="hljs-con-meta">&gt; </span>T_12_pdb_loop.py(5)print_value()&#13;
<span class="hljs-con-meta">-&gt; </span><span class="hljs-con-built_in">print</span>(<span class="hljs-con-string">'value:'</span>, value)&#13;
(Pdb) w  <span class="hljs-con-comment"># Where shows the current line and the calling functions</span>&#13;
  T_12_pdb_loop.py(11)&lt;module&gt;()&#13;
<span class="hljs-con-meta">-&gt; </span>print_value(i)&#13;
<span class="hljs-con-meta">&gt; </span>T_12_pdb_loop.py(5)print_value()&#13;
<span class="hljs-con-meta">-&gt; </span><span class="hljs-con-built_in">print</span>(<span class="hljs-con-string">'value:'</span>, value)&#13;
(Pdb) ll  <span class="hljs-con-comment"># List the lines of the current function</span>&#13;
  4     def print_value(value):&#13;
  5 B-&gt;     print('value:', value)&#13;
(Pdb) b  <span class="hljs-con-comment"># Show the breakpoints</span>&#13;
Num Type         Disp Enb   Where&#13;
1   breakpoint   keep yes   at T_12_pdb_loop.py:5&#13;
        breakpoint already hit 1 time&#13;
(Pdb) cl 1  <span class="hljs-con-comment"># Clear breakpoint 1</span>&#13;
Deleted breakpoint 1 at T_12_pdb_loop.py:5&#13;
(Pdb) c  <span class="hljs-con-comment"># Continue the application until the end</span>&#13;
value: 0&#13;
value: 1&#13;
value: 2&#13;
value: 3&#13;
value: 4&#13;
</code></pre>&#13;
    <p class="normal">That was a lot of output, but it’s actually not as complex as it seems:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">First, we used the <code class="inlineCode">source print_value</code> command to see the source for the <code class="inlineCode">print_value</code> function.</li>&#13;
      <li class="numberedList">After that, we knew the line number of the first <code class="inlineCode">print</code> statement, which we used to place a breakpoint (<code class="inlineCode">b 5</code>) at line 5.</li>&#13;
      <li class="numberedList">To check whether we were still at the right position, we used the <code class="inlineCode">w</code> command.</li>&#13;
      <li class="numberedList">Since the breakpoint was set, we used <code class="inlineCode">c</code> to continue up to the next breakpoint.</li>&#13;
      <li class="numberedList">Having stopped at the breakpoint at line 5, we used <code class="inlineCode">w</code> again to confirm that and show the current stack.</li>&#13;
      <li class="numberedList">We listed the code of the current function using <code class="inlineCode">ll</code>.</li>&#13;
      <li class="numberedList">We listed the breakpoints using <code class="inlineCode">b</code>.</li>&#13;
      <li class="numberedList">We removed the<a id="_idIndexMarker897"/> breakpoint again using <code class="inlineCode">cl 1</code> with the breakpoint number from the previous command.</li>&#13;
      <li class="numberedList">We continued (<code class="inlineCode">c</code>) until the program exits or reaches the next breakpoint if available.</li>&#13;
    </ol>&#13;
    <p class="normal">It all seems a bit complicated in the beginning, but you’ll see that it’s actually a very convenient way of debugging once you’ve tried a few times.</p>&#13;
    <p class="normal">To make it even better, this time we will execute the breakpoint only when <code class="inlineCode">value = 3</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 T_12_pdb_loop.py&#13;
<span class="hljs-con-meta">&gt; </span>T_12_pdb_loop.py(10)&lt;module&gt;()&#13;
<span class="hljs-con-meta">-&gt; </span><span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> range(5):&#13;
<span class="hljs-con-comment"># print the source to find the variable name and line number:</span>&#13;
(Pdb) source print_value&#13;
  4     def print_value(value):&#13;
  5         print('value:', value)&#13;
(Pdb) b 5, value == 3  <span class="hljs-con-comment"># add a breakpoint at line 5 when value=3</span>&#13;
Breakpoint 1 at T_12_pdb_loop.py:5&#13;
(Pdb) c  <span class="hljs-con-comment"># continue until breakpoint</span>&#13;
value: 0&#13;
value: 1&#13;
value: 2&#13;
<span class="hljs-con-meta">&gt; </span>T_12_pdb_loop.py(5)print_value()&#13;
<span class="hljs-con-meta">-&gt; </span><span class="hljs-con-built_in">print</span>(<span class="hljs-con-string">'value:'</span>, value)&#13;
(Pdb) a  <span class="hljs-con-comment"># show the arguments for the function</span>&#13;
value = 3&#13;
(Pdb) value = 123  <span class="hljs-con-comment"># change the value before the print</span>&#13;
(Pdb) c  <span class="hljs-con-comment"># continue, we see the new value now</span>&#13;
value: 123&#13;
value: 4&#13;
</code></pre>&#13;
    <p class="normal">To list what we have done:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">First, using <code class="inlineCode">source print_value</code>, we looked for the line number and variable name.</li>&#13;
      <li class="numberedList">After that, we placed a breakpoint with the <code class="inlineCode">value == 3</code> condition.</li>&#13;
      <li class="numberedList">Then we continued execution using <code class="inlineCode">c</code>. As you can see, the values <code class="inlineCode">0</code>, <code class="inlineCode">1</code>, and <code class="inlineCode">2</code> are printed as normal.</li>&#13;
      <li class="numberedList">The <a id="_idIndexMarker898"/>breakpoint was reached at value <code class="inlineCode">3</code>. To verify, we used <code class="inlineCode">a</code> to see the function arguments.</li>&#13;
      <li class="numberedList">We changed the variable before <code class="inlineCode">print()</code> was executed.</li>&#13;
      <li class="numberedList">We continued to execute the rest of the code.</li>&#13;
    </ol>&#13;
    <h3 id="_idParaDest-315" class="heading-3">Catching exceptions</h3>&#13;
    <p class="normal">All of these have <a id="_idIndexMarker899"/>been manual calls to the <code class="inlineCode">pdb.set_trace()</code> function, but in general, you are just running your application and not really expecting issues. This is where exception catching can be very handy. In addition to importing <code class="inlineCode">pdb</code> yourself, you can run scripts through <code class="inlineCode">pdb</code> as a module as well. Let’s examine this bit of code, which dies as soon as it reaches zero division:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">print(<span class="hljs-string">'This still works'</span>)&#13;
<span class="hljs-number">1</span> / <span class="hljs-number">0</span>&#13;
print(<span class="hljs-string">'We will never reach this'</span>)&#13;
</code></pre>&#13;
    <p class="normal">If we run it through the <code class="inlineCode">pdb</code> module, we can end up in the Python debugger whenever it crashes:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 -m pdb T_13_pdb_catching_exceptions&#13;
<span class="hljs-con-meta">&gt; </span>T_13_pdb_catching_exceptions(1)&lt;module&gt;()&#13;
<span class="hljs-con-meta">-&gt; </span><span class="hljs-con-built_in">print</span>(<span class="hljs-con-string">'This still works'</span>)&#13;
(Pdb) w  <span class="hljs-con-comment"># Where</span>&#13;
  bdb.py(431)run()&#13;
<span class="hljs-con-meta">-&gt; </span><span class="hljs-con-built_in">exec</span>(cmd, globals, locals)&#13;
  &lt;string&gt;(1)&lt;module&gt;()&#13;
<span class="hljs-con-meta">&gt; </span>T_13_pdb_catching_exceptions(1)&lt;module&gt;()&#13;
<span class="hljs-con-meta">-&gt; </span><span class="hljs-con-built_in">print</span>(<span class="hljs-con-string">'This still works'</span>)&#13;
(Pdb) s  <span class="hljs-con-comment"># Step into the next statement</span>&#13;
This still works&#13;
<span class="hljs-con-meta">&gt; </span>T_13_pdb_catching_exceptions(2)&lt;module&gt;()&#13;
<span class="hljs-con-meta">-&gt; </span>1/0&#13;
(Pdb) c  <span class="hljs-con-comment"># Continue</span>&#13;
Traceback (most recent call last):&#13;
  File "pdb.py", line 1661, in main&#13;
    pdb._runscript(mainpyfile)&#13;
  File "pdb.py", line 1542, in _runscript&#13;
    self.run(statement)&#13;
  File "bdb.py", line 431, in run&#13;
    exec(cmd, globals, locals)&#13;
  File "&lt;string&gt;", line 1, in &lt;module&gt;&#13;
  File "T_13_pdb_catching_exceptions", line 2, in &lt;module&gt;&#13;
    1/0&#13;
ZeroDivisionError: division by zero&#13;
Uncaught exception. Entering post mortem debugging&#13;
Running 'cont' or 'step' will restart the program&#13;
<span class="hljs-con-meta">&gt; </span>T_13_pdb_catching_exceptions(2)&lt;module&gt;()&#13;
<span class="hljs-con-meta">-&gt; </span>1/0&#13;
</code></pre>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">A useful little trick within <code class="inlineCode">pdb</code> is to use the <em class="keystroke">Enter </em>button, which, by default, will execute the previously executed command again. This is very useful when stepping through the program.</p>&#13;
    </div>&#13;
    <h3 id="_idParaDest-316" class="heading-3">Aliases</h3>&#13;
    <p class="normal">Aliases can <a id="_idIndexMarker900"/>be a really useful feature to make your life easier. If you “live” in a Linux/Unix shell like I do, you are probably already familiar with them, but essentially an alias is just a shorthand to save you from having to type (or even remember) a long and complicated command.</p>&#13;
    <p class="normal">Which aliases are useful for you depends on your preferences of course, but I personally like an alias for the <code class="inlineCode">pprint</code> (pretty print) module. Within my projects, I often use <code class="inlineCode">pf=pprint.pformat</code> and <code class="inlineCode">pp=pprint.pprint</code> as aliases, but the same goes for <code class="inlineCode">pdb</code> where I find <code class="inlineCode">pd</code> a useful shorthand for pretty printing the <code class="inlineCode">__dict__</code> for a given object.</p>&#13;
    <p class="normal">The <code class="inlineCode">pdb</code> commands<a id="_idIndexMarker901"/> for aliases are relatively straightforward and very easy to use:</p>&#13;
    <table id="table004" class="table-container">&#13;
      <tbody>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">alias</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">List all aliases.</p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">alias name command</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Create an alias. The command can be any valid Python expression, so you can do the following to print all properties for an object:</p>&#13;
            <p class="normal"><code class="inlineCode">alias pd pp %1.__dict__ </code></p>&#13;
          </td>&#13;
        </tr>&#13;
        <tr>&#13;
          <td class="table-cell">&#13;
            <p class="normal"><code class="inlineCode">unalias name</code></p>&#13;
          </td>&#13;
          <td class="table-cell">&#13;
            <p class="normal">Remove an alias.</p>&#13;
          </td>&#13;
        </tr>&#13;
      </tbody>&#13;
    </table>&#13;
    <p class="normal">Make sure to use <a id="_idIndexMarker902"/>these to your <a id="_idIndexMarker903"/>advantage. Within Linux/Unix systems, you have probably noticed that many commands (<code class="inlineCode">ls</code>, <code class="inlineCode">rm</code>, <code class="inlineCode">cd</code>) are very short to save you some typing; you can do the same with these aliases.</p>&#13;
    <h3 id="_idParaDest-317" class="heading-3">commands</h3>&#13;
    <p class="normal">The <code class="inlineCode">commands</code> command<a id="_idIndexMarker904"/> is a little complicated but very useful. It allows you to execute commands whenever a specific breakpoint is encountered. To illustrate this, let’s start from a simple example again:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">do_nothing</span>(<span class="hljs-params">i</span>):&#13;
    <span class="hljs-keyword">pass</span>&#13;
&#13;
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):&#13;
    do_nothing(i)&#13;
</code></pre>&#13;
    <p class="normal">The code is simple enough, so now we’ll add the breakpoint and the commands, as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 -m pdb T_14_pdb_commands.py&#13;
<span class="hljs-con-meta">&gt; </span>T_14_pdb_commands.py(1)&lt;module&gt;()&#13;
<span class="hljs-con-meta">-&gt; </span>def do_nothing(i):&#13;
(Pdb) b do_nothing  <span class="hljs-con-comment"># Add a breakpoint to function do_nothing</span>&#13;
Breakpoint 1 at T_14_pdb_commands.py:1&#13;
(Pdb) commands 1  <span class="hljs-con-comment"># add command to breakpoint 1</span>&#13;
(com) print(f'The passed value: {i}')&#13;
(com) end  <span class="hljs-con-comment"># end command</span>&#13;
(Pdb) c  <span class="hljs-con-comment"># continue</span>&#13;
The passed value: 0&#13;
<span class="hljs-con-meta">&gt; </span>16_pdb_commands.py(2)do_nothing()&#13;
<span class="hljs-con-meta">-&gt; </span>pass&#13;
(Pdb) q  # quit&#13;
</code></pre>&#13;
    <p class="normal">As you can see, we can easily add commands to the breakpoint. After removing the breakpoint, these commands won’t be executed anymore because they are linked to the breakpoint.</p>&#13;
    <p class="normal">These can be really useful to add some automatic debug <code class="inlineCode">print</code> statements to your breakpoint; for example, to see the value of all of the variables in the local scope. You can always manually do a <code class="inlineCode">print(locals())</code> of course, but these can save you a lot of time while debugging.</p>&#13;
    <h2 id="_idParaDest-318" class="heading-2">Debugging with IPython</h2>&#13;
    <p class="normal">While <a id="_idIndexMarker905"/>the generic Python console is useful, it can be a little <a id="_idIndexMarker906"/>rough around the edges. The IPython console offers a <a id="_idIndexMarker907"/>whole new world of extra features, which make it a much nicer console to work with. One of those features is a more convenient debugger.</p>&#13;
    <p class="normal">First, make sure you have <code class="inlineCode">ipython</code> installed:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install ipython&#13;
</code></pre>&#13;
    <p class="normal">Next, let’s try the debugger with a very basic script:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">print_value</span>(<span class="hljs-params">value</span>):&#13;
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'value:'</span>, value)&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):&#13;
        print_value(i)&#13;
</code></pre>&#13;
    <p class="normal">Next, we run IPython and tell it to run the script in debug mode:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>ipython&#13;
Python 3.10.0&#13;
Type 'copyright', 'credits' or 'license' for more information&#13;
IPython 7.19.0 -- An enhanced Interactive Python. Type '?' for help.&#13;
&#13;
In [1]: %run -d T_15_ipython.py&#13;
Breakpoint 1 at T_15_ipython.py:1&#13;
NOTE: Enter 'c' at the ipdb&gt;  prompt to continue execution.&#13;
<span class="hljs-con-meta">&gt; </span>T_15_ipython.py(1)&lt;module&gt;()&#13;
<span class="hljs-con-meta">1---&gt; </span>1 def print_value(value):&#13;
      2     print('value:', value)&#13;
      3&#13;
      4&#13;
      5 if __name__ == '__main__':&#13;
&#13;
<span class="hljs-con-meta">ipdb&gt; </span>b print_value, value == 3  <span class="hljs-con-comment"># Add a breakpoint when value=3</span>&#13;
Breakpoint 2 at T_15_ipython.py:1&#13;
<span class="hljs-con-meta">ipdb&gt; </span>c&#13;
value: 0&#13;
value: 1&#13;
value: 2&#13;
<span class="hljs-con-meta">&gt; </span>T_15_ipython.py(2)print_value()&#13;
2     1 def print_value(value):&#13;
<span class="hljs-con-meta">----&gt; </span>2     <span class="hljs-con-built_in">print</span>(<span class="hljs-con-string">'value:'</span>, value)&#13;
      3&#13;
      4&#13;
      5 if __name__ == '__main__':&#13;
<span class="hljs-con-meta">ipdb&gt; </span>value&#13;
3&#13;
<span class="hljs-con-meta">ipdb&gt; </span>value = 123  <span class="hljs-con-comment"># Change the value</span>&#13;
<span class="hljs-con-meta">ipdb&gt; </span>c  <span class="hljs-con-comment"># Continue</span>&#13;
value: 123&#13;
value: 4&#13;
</code></pre>&#13;
    <p class="normal">As you can<a id="_idIndexMarker908"/> see, not all that different from <code class="inlineCode">pdb</code>. But it automatically <a id="_idIndexMarker909"/>shows the surrounding code in a readable format, which <a id="_idIndexMarker910"/>is very useful. Additionally, the shown code has syntax highlighting, which helps with readability as well.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">If you install the <code class="inlineCode">ipdb</code> module, you get features similar to the <code class="inlineCode">pdb</code> module, which allow for triggering breakpoints from your code.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-319" class="heading-2">Debugging with Jupyter</h2>&#13;
    <p class="normal">Jupyter <a id="_idIndexMarker911"/>is amazing for ad hoc development and makes it really easy to <a id="_idIndexMarker912"/>see what’s going on in your code for small <a id="_idIndexMarker913"/>scripts. For larger scripts, it can quickly become more difficult because you normally only get the non-interactive stack trace and have to resort to a different method for changing external code.</p>&#13;
    <p class="normal">Since 2020, however, Jupyter has added a (currently experimental) visual debugger to make it possible to debug your code as it happens in a very convenient way. To get started, make sure you have a recent version of Jupyter and install both the <code class="inlineCode">@jupyterlab/debugger</code> extension and the <code class="inlineCode">xeus-python</code> (XPython) kernel for Jupyter. To make sure everything works without too much effort, I strongly recommend using <code class="inlineCode">conda</code> for this operation:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>conda create -n jupyter-debugger -c conda-forge xeus-python=0.8.6 notebook=6 jupyterlab=2 ptvsd nodejs&#13;
...&#13;
<span class="hljs-con-comment">## Package Plan ##</span>&#13;
&#13;
  added / updated specs:&#13;
    - jupyterlab=2&#13;
    - nodejs&#13;
    - notebook=6&#13;
    - ptvsd&#13;
    - xeus-python=0.8.6&#13;
...&#13;
<span class="hljs-con-meta">$ </span>conda activate jupyter-debugger&#13;
&#13;
(jupyter-debugger) <span class="hljs-con-meta">$</span> jupyter labextension install @jupyterlab/debugger&#13;
&#13;
Building jupyterlab assets (build:prod:minimize)&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="normal">The current installation instructions for Conda can be found on the JupyterLab debugger GitHub page: <a href="Chapter_11.xhtml"><span class="url">https://jupyterlab.readthedocs.io/en/latest/user/debugger.html</span></a></p>&#13;
      <p class="normal">For a regular Python virtual environment, you can try the binary wheel (<code class="inlineCode">.whl</code>) packages so you don’t have to compile anything. Due to the currently experimental nature of this feature, it is not supported in all environments yet. At the time of writing, binary wheels are available for Python 3.6, 3.7 and 3.8 for OS X, Linux, and Windows. A list of available versions can be found here: <a href="Chapter_11.xhtml"><span class="url">https://pypi.org/project/xeus-python/#files</span></a></p>&#13;
    </div>&#13;
    <p class="normal">Now <a id="_idIndexMarker914"/>we <a id="_idIndexMarker915"/>can start <code class="inlineCode">jupyter lab</code> as<a id="_idIndexMarker916"/> normal:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">(jupyter-debugger) <span class="hljs-con-meta">$</span> jupyter lab&#13;
[I LabApp] JupyterLab extension loaded from jupyterlab&#13;
[I LabApp] Jupyter Notebook 6.1.4 is running at:&#13;
[I LabApp] http://localhost:8888/?token=...&#13;
[I LabApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).&#13;
</code></pre>&#13;
    <p class="normal">If everything is working as expected, you should see the JupyterLab launcher now, with both Python 3 and the XPython kernels available:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_11_01.png" alt="" width="322" height="219"/></figure>&#13;
    <p class="packt_figref">Figure 11.1: JupyterLab Python and XPython kernels</p>&#13;
    <p class="normal">Since <a id="_idIndexMarker917"/>only <code class="inlineCode">xeus-python</code> (XPython) currently supports debugging, we <a id="_idIndexMarker918"/>will have to open that one. Now we will add our <a id="_idIndexMarker919"/>script from before so we can demonstrate the debugger. If everything is working correctly, you should see the debug buttons at the top-right part of your screen:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_11_02.png" alt="" width="878" height="320"/></figure>&#13;
    <p class="packt_figref">Figure 11.2: Regular Jupyter console output</p>&#13;
    <p class="normal">Now we can start debugging by following these steps:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">Enable the debug toggle at the top right.</li>&#13;
      <li class="numberedList">Click on a line to add a breakpoint.</li>&#13;
      <li class="numberedList">Run the code.</li>&#13;
    </ol>&#13;
    <p class="normal">If everything is set up correctly, it should look something like this:</p>&#13;
    <figure class="mediaobject"><img src="Images/B15882_11_03.png" alt="" width="876" height="229"/></figure>&#13;
    <p class="packt_figref">Figure 11.3: Debugging using Jupyter</p>&#13;
    <p class="normal">From this point on, you can use the buttons in the debugging pane on the right to step over/in/out of the next statement to walk through the code.</p>&#13;
    <h2 id="_idParaDest-320" class="heading-2">Other debuggers</h2>&#13;
    <p class="normal">The <code class="inlineCode">pdb</code> debugger is <a id="_idIndexMarker920"/>simply the Python default, but far from the only option to debug Python code. Some of the currently noteworthy debuggers are as follows:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">ipdb</code>: The <code class="inlineCode">pdb</code> debugger <a id="_idIndexMarker921"/>wrapped in an IPython shell</li>&#13;
      <li class="bulletList"><code class="inlineCode">pudb</code>: A full-screen <a id="_idIndexMarker922"/>command-line debugger</li>&#13;
      <li class="bulletList"><code class="inlineCode">pdbpp</code> (pdb++): An <a id="_idIndexMarker923"/>extension to the regular <code class="inlineCode">pdb</code> module, which adds tab completion, syntax highlighting, and a few other useful features to <code class="inlineCode">pdb</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">Werkzeug</code>: A <a id="_idIndexMarker924"/>web-based debugger that allows debugging of web applications while they are running</li>&#13;
    </ul>&#13;
    <p class="normal">There are many others, of course, and there isn’t a single one that’s the absolute best. As is the case with all tools, they all have their advantages and their flaws, and the one that is best for your current purpose can be properly decided only by you. Chances are that your current Python IDE already has an integrated debugger. The PyCharm IDE, for example, even offers built-in remote debugging so you can debug applications running on cloud providers from your local graphical interface.</p>&#13;
    <h3 id="_idParaDest-321" class="heading-3">Debugging services</h3>&#13;
    <p class="normal">In addition to debugging<a id="_idIndexMarker925"/> when you encounter a problem, there are times when you simply need to keep track of errors for later debugging. This can be especially difficult if your application is running on remote servers or on computers not controlled by you. For this type of error tracking, there are a few very useful open-source packages available.</p>&#13;
    <h4 class="heading-4">Elastic APM</h4>&#13;
    <p class="normal">Elastic APM<a id="_idIndexMarker926"/> is part of the Elastic Stack and can keep track of errors, performance, logs, and other data for you. This system can help you track not only Python applications but supports a whole range of other languages and applications as well. The Elastic Stack (which is built around Elasticsearch) is an extremely versatile and very well-maintained stack of software which I highly recommend.</p>&#13;
    <p class="normal">The only downside of the Elastic Stack is that it is a very heavy set of applications, which quickly requires a number of dedicated servers to maintain reasonable performance. It does scale very well, however; if you ever need more processing power, you can simply add a new machine to your cluster and everything will automatically rebalance for you.</p>&#13;
    <h4 class="heading-4">Sentry</h4>&#13;
    <p class="normal">Sentry<a id="_idIndexMarker927"/> is an open-source error management system that allows you to collect errors from a wide<a id="_idIndexMarker928"/> range of languages and frameworks. Some notable features are:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Grouping of errors so you only get one (or a configurable number of) notification of errors per type of error</li>&#13;
      <li class="bulletList">Being able to mark an error as “fixed” so it re-alerts you when it occurs again while still showing you the previous occurrences</li>&#13;
      <li class="bulletList">Showing a full stack trace including surrounding code</li>&#13;
      <li class="bulletList">Keeping track of code versions/releases so you know which version (re-)introduced an error</li>&#13;
      <li class="bulletList">Assign errors to a specific <strong class="keyWord">developer</strong> to fix</li>&#13;
    </ul>&#13;
    <p class="normal">While the Sentry application is mainly focused on web applications, it can easily be used for regular applications and scripts as well.</p>&#13;
    <p class="normal">Historically, Sentry started as a small error-grouping application that could be used as an app within an existing Django application, or as a separate installation depending on your needs. Since that time, very little of that lightweight structure remains; it has grown into a fully fledged error tracking system that has native support for many programming languages and frameworks.</p>&#13;
    <p class="normal">Over time, Sentry has gravitated more and more toward the commercial hosted platform, however, so hosting the application yourself has become more difficult with that. The time that a simple <code class="inlineCode">pip install sentry</code> was enough to get it running is long gone. These days, Sentry is a heavy application that relies on the following running services:</p>&#13;
    <ul>&#13;
      <li class="bulletList">PostgreSQL</li>&#13;
      <li class="bulletList">Redis</li>&#13;
      <li class="bulletList">Memcached</li>&#13;
      <li class="bulletList">Symbolicator</li>&#13;
      <li class="bulletList">Kafka</li>&#13;
      <li class="bulletList">Snuba</li>&#13;
    </ul>&#13;
    <p class="normal">So if you wish to try<a id="_idIndexMarker929"/> Sentry, I would recommend trying the free tier of the hosted Sentry to see if you like it first. Manually installing is not really a valid option anymore, so if you wish to run it self-hosted, your only realistic option is to use the <code class="inlineCode">docker-compose</code> files provided.</p>&#13;
    <p class="normal">When self-hosting, you should keep in mind that it is a heavy application that requires a significant amount of resources to run and can easily fill a decently sized dedicated server. It is still lighter than Elastic APM, however.</p>&#13;
    <div class="note">&#13;
      <p class="normal">In my experience, you need at least about 2-3 GiB of RAM and about 2 CPU cores to run current versions of Sentry. Depending on your load, you might need something much heavier, but that is the bare minimum.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-322" class="heading-1">Exercises</h1>&#13;
    <p class="normal">For local development, a few small utility functions can make your life much easier. We have already seen an example of this with the <code class="inlineCode">print_code</code> generator and the <code class="inlineCode">trace</code> context wrapper. See if you can extend one of these to:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Execute code with a timeout so you can see where your application is stalling</li>&#13;
      <li class="bulletList">Measure the duration of the execution</li>&#13;
      <li class="bulletList">Show how often that specific bit of code has been executed</li>&#13;
      <li class="bulletList">&#13;
        <div class="note">&#13;
          <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_11.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
        </div>&#13;
      </li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-323" class="heading-1">Summary</h1>&#13;
    <p class="normal">This chapter explained a few different debugging techniques and gotchas. There is, of course, much more that can be said about debugging, but I hope you have acquired a nice vantage point for debugging your Python code now. Interactive debugging techniques are very useful for single-threaded applications and locations where interactive sessions are available. </p>&#13;
    <p class="normal">But since that’s not always the case, we also discussed some non-interactive options.</p>&#13;
    <p class="normal">To recap, in this chapter, we talked about non-interactive debugging with <code class="inlineCode">print</code> statements, <code class="inlineCode">logging</code>, <code class="inlineCode">trace</code>, <code class="inlineCode">traceback</code>, <code class="inlineCode">asyncio</code>, and <code class="inlineCode">faulthandler</code>. We also explored interactive debugging with the Python debugger, IPython, and Jupyter, as well as learning about alternative debuggers. </p>&#13;
    <p class="normal">In the next chapter, we will see how to monitor and improve both CPU and memory performance, as well as finding and fixing memory leaks.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="Chapter_11.xhtml"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>