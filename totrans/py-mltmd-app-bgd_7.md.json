["```py\n    import time\n    import thread\n    import gobject\n    import pygst\n    pygst.require(\"0.10\")\n    import gst\n    import os\n    class VideoPlayer:\n    def __init__(self):\n    pass\n    def constructPipeline(self):\n    pass\n    def connectSignals(self):\n    pass\n    def decodebin_pad_added(self, decodebin, pad):\n    pass\n    def play(self):\n    pass\n    def message_handler(self, bus, message):\n    pass\n    # Run the program\n    player = VideoPlayer()\n    thread.start_new_thread(player.play, ())\n    gobject.threads_init()\n    evt_loop = gobject.MainLoop()\n    evt_loop.run()\n\n    ```", "```py\n    1 def constructPipeline(self):\n    2 # Create the pipeline instance\n    3 self.player = gst.Pipeline()\n    4\n    5 # Define pipeline elements\n    6 self.filesrc = gst.element_factory_make(\"filesrc\")\n    7 self.filesrc.set_property(\"location\",\n    8 self.inFileLocation)\n    9 self.decodebin = gst.element_factory_make(\"decodebin\")\n    10\n    11 # audioconvert for audio processing pipeline\n    12 self.audioconvert = gst.element_factory_make(\n    13 \"audioconvert\")\n    14 # Autoconvert element for video processing\n    15 self.autoconvert = gst.element_factory_make(\n    16 \"autoconvert\")\n    17 self.audiosink = gst.element_factory_make(\n    18 \"autoaudiosink\")\n    19\n    20 self.videosink = gst.element_factory_make(\n    21 \"autovideosink\")\n    22\n    23 # As a precaution add videio capability filter\n    24 # in the video processing pipeline.\n    25 videocap = gst.Caps(\"video/x-raw-yuv\")\n    26 self.filter = gst.element_factory_make(\"capsfilter\")\n    27 self.filter.set_property(\"caps\", videocap)\n    28 # Converts the video from one colorspace to another\n    29 self.colorSpace = gst.element_factory_make(\n    30 \"ffmpegcolorspace\")\n    31\n    32 self.videoQueue = gst.element_factory_make(\"queue\")\n    33 self.audioQueue = gst.element_factory_make(\"queue\")\n    34\n    35 # Add elements to the pipeline\n    36 self.player.add(self.filesrc,\n    37 self.decodebin,\n    38 self.autoconvert,\n    39 self.audioconvert,\n    40 self.videoQueue,\n    41 self.audioQueue,\n    42 self.filter,\n    43 self.colorSpace,\n    44 self.audiosink,\n    45 self.videosink)\n    46\n    47 # Link elements in the pipeline.\n    48 gst.element_link_many(self.filesrc, self.decodebin)\n    49\n    50 gst.element_link_many(self.videoQueue, self.autoconvert,\n    51 self.filter, self.colorSpace,\n    52 self.videosink)\n    53\n    54 gst.element_link_many(self.audioQueue,self.audioconvert,\n    55 self.audiosink)\n\n    ```", "```py\n    1 def decodebin_pad_added(self, decodebin, pad):\n    2 compatible_pad = None\n    3 caps = pad.get_caps()\n    4 name = caps[0].get_name()\n    5 print \"\\n cap name is =%s\"%name\n    6 if name[:5] == 'video':\n    7 compatible_pad = (\n    8 self.videoQueue.get_compatible_pad(pad, caps) )\n    9 elif name[:5] == 'audio':\n    10 compatible_pad = (\n    11 self.audioQueue.get_compatible_pad(pad, caps) )\n    12\n    13 if compatible_pad:\n    14 pad.link(compatible_pad)\n\n    ```", "```py\n    $python PlayingVideo.py\n\n    ```", "```py\ndef constructPipeline(self):\nself.player = gst.element_factory_make(\"playbin\")\nself.player.set_property(\"uri\",\n\"file:///\" + self.inFileLocation)\n\n```", "```py\npython VideoConverter.py [options]\n\n```", "```py\n    import os, sys, time\n    import thread\n    import getopt, glob\n    import gobject\n    import pygst\n    pygst.require(\"0.10\")\n    import gst\n    class VideoConverter:\n    def __init__(self):\n    pass\n    def constructPipeline(self):\n    pass\n    def connectSignals(self):\n    pass\n    def decodebin_pad_added(self, decodebin, pad):\n    pass\n    def processArgs(self):\n    pass\n    def printUsage(self):\n    pass\n    def printFinalStatus(self, starttime, endtime):\n    pass\n    def convert(self):\n    pass\n    def message_handler(self, bus, message):\n    pass\n    # Run the converter\n    converter = VideoConverter()\n    thread.start_new_thread(converter.convert, ())\n    gobject.threads_init()\n    evt_loop = gobject.MainLoop()\n\n    ```", "```py\n    evt_loop.run()\n\n    ```", "```py\n    1 def __init__(self):\n    2 # Initialize various attrs\n    3 self.inFileLocation = \"\"\n    4 self.outFileLocation = \"\"\n    5 self.inputFormat = \"ogg\"\n    6 self.outputFormat = \"\"\n    7 self.error_message = \"\"\n    8 # Create dictionary objects for\n    9 # Audio / Video encoders for supported\n    10 # file format\n    11 self.audioEncoders = {\"mp4\":\"lame\",\n    12 \"ogg\": \"vorbisenc\"}\n    13\n    14 self.videoEncoders={\"mp4\":\"ffenc_mpeg4\",\n    15 \"ogg\": \"theoraenc\"}\n    16\n    17 self.muxers = {\"mp4\":\"ffmux_mp4\",\n    18 \"ogg\":\"oggmux\" }\n    19\n    20 self.supportedOutputFormats = self.audioEncoders.keys()\n    21\n    22 self.supportedInputFormats = (\"ogg\", \"mp4\",\n    23 \"avi\", \"mov\")\n    24\n    25 self.pipeline = None\n    26 self.is_playing = False\n    27\n    28 self.processArgs()\n    29 self.constructPipeline()\n    30 self.connectSignals()\n\n    ```", "```py\n    1 def constructPipeline(self):\n    2 self.pipeline = gst.Pipeline(\"pipeline\")\n    3\n    4 self.filesrc = gst.element_factory_make(\"filesrc\")\n    5 self.filesrc.set_property(\"location\",\n    6 self.inFileLocation)\n    7\n    8 self.filesink = gst.element_factory_make(\"filesink\")\n    9 self.filesink.set_property(\"location\",\n    10 self.outFileLocation)\n    11\n    12 self.decodebin = gst.element_factory_make(\"decodebin\")\n    13 self.audioconvert = gst.element_factory_make(\n    14 \"audioconvert\")\n    15\n    16 audio_encoder = self.audioEncoders[self.outputFormat]\n    17 muxer_str = self.muxers[self.outputFormat]\n    18 video_encoder = self.videoEncoders[self.outputFormat]\n    19\n    20 self.audio_encoder= gst.element_factory_make(\n    21 audio_encoder)\n    22 self.muxer = gst.element_factory_make(muxer_str)\n    23 self.video_encoder = gst.element_factory_make(\n    24 video_encoder)\n    25\n    26 self.videoQueue = gst.element_factory_make(\"queue\")\n    27 self.audioQueue = gst.element_factory_make(\"queue\")\n    28 self.queue3 = gst.element_factory_make(\"queue\")\n    29\n    30 self.pipeline.add( self.filesrc,\n    31 self.decodebin,\n    32 self.video_encoder,\n    33 self.muxer,\n    34 self.videoQueue,\n    35 self.audioQueue,\n    36 self.queue3,\n    37 self.audioconvert,\n    38 self.audio_encoder,\n    39 self.filesink)\n    40\n    41 gst.element_link_many(self.filesrc, self.decodebin)\n    42\n    43 gst.element_link_many(self.videoQueue,\n    44 self.video_encoder, self.muxer, self.filesink)\n    45\n    46 gst.element_link_many(self.audioQueue,self.audioconvert,\n    47 self.audio_encoder, self.queue3,\n    48 self.muxer)\n\n    ```", "```py\n    1 def convert(self):\n    2 # Record time before beginning Video conversion\n    3 starttime = time.clock()\n    4\n    5 print \"\\n Converting Video file..\"\n    6 print \"\\n Input File: %s, Conversion STARTED...\" %\n    7 self.inFileLocation\n    8\n    9 self.is_playing = True\n    10 self.pipeline.set_state(gst.STATE_PLAYING)\n    11 while self.is_playing:\n    12 time.sleep(1)\n    13\n    14 if self.error_message:\n    15 print \"\\n Input File: %s, ERROR OCCURED.\" %\n    16 self.inFileLocation\n    17 print self.error_message\n    18 else:\n    19 print \"\\n Input File: %s, Conversion COMPLETE \" %\n    20 self.inFileLocation\n    21\n    22 endtime = time.clock()\n    23 self.printFinalStatus(starttime, endtime)\n    24 evt_loop.quit()\n\n    ```", "```py\n    1 def constructVideoPipeline(self):\n    2 # Autoconvert element for video processing\n    3 self.autoconvert = gst.element_factory_make(\n    4 \"autoconvert\")\n    5 self.videosink = gst.element_factory_make(\n    6 \"autovideosink\")\n    7\n    8 # Set the capsfilter\n    9 if self.video_width and self.video_height:\n    10 videocap = gst.Caps(\n    11 \"video/x-raw-yuv,\" \"width=%d, height=%d\"%\n    12 (self.video_width,self.video_height))\n    13 else:\n    14 videocap = gst.Caps(\"video/x-raw-yuv\")\n    15\n    16 self.capsFilter = gst.element_factory_make(\n    17 \"capsfilter\")\n    18 self.capsFilter.set_property(\"caps\", videocap)\n    19\n    20 # Converts the video from one colorspace to another\n    21 self.colorSpace = gst.element_factory_make(\n    22 \"ffmpegcolorspace\")\n    23\n    24 self.videoQueue = gst.element_factory_make(\"queue\")\n    25\n    26 self.player.add(self.videoQueue,\n    27 self.autoconvert,\n    28 self.capsFilter,\n    29 self.colorSpace,\n    30 self.videosink)\n    31\n    32 gst.element_link_many(self.videoQueue,\n    33 self.autoconvert,\n    34 self.capsFilter,\n    35 self.colorSpace,\n    36 self.videosink)\n\n    ```", "```py\n    $python VideoManipulations.py\n\n    ```", "```py\n    1 self.videobox = gst.element_factory_make(\"videobox\")\n    2 self.videobox.set_property(\"bottom\", self.crop_bottom )\n    3 self.videobox.set_property(\"top\", self.crop_top )\n    4 self.videobox.set_property(\"left\", self.crop_left )\n    5 self.videobox.set_property(\"right\", self.crop_right )\n    6\n    7 self.player.add(self.videoQueue,\n    8 self.autoconvert,\n    9 self.videobox,\n    10 self.capsFilter,\n    11 self.colorSpace,\n    12 self.videosink)\n    13\n    14 gst.element_link_many(self.videoQueue,\n    15 self.autoconvert,\n    16 self.videobox,\n    17 self.capsFilter,\n    18 self.colorSpace,\n    19 self.videosink)\n\n    ```", "```py\n    $python VideoManipulations.py\n\n    ```", "```py\nself.videobalance = gst.element_factory_make(\"videobalance\")\nself.videobalance.set_property(\"brightness\", 0.5)\nself.videobalance.set_property(\"contrast\", 0.5)\n\n```", "```py\ngst.element_link_many(self.videoQueue,\nself.autoconvert,\nself.videobalance,\nself.capsFilter,\nself.colorSpace,\nself.videosink)\n\n```", "```py\nself.videobalance.set_property(\"saturation\", 0.0)\n\n```", "```py\n    1 def constructVideoPipeline(self):\n    2 # Autoconvert element for video processing\n    3 self.autoconvert = gst.element_factory_make(\n    4 \"autoconvert\")\n    5 self.videosink = gst.element_factory_make(\n    6 \"autovideosink\")\n    7\n    8 # Set the capsfilter\n    9 videocap = gst.Caps(\"video/x-raw-yuv\")\n    10 self.capsFilter = gst.element_factory_make(\n    11 \"capsfilter\")\n    12 self.capsFilter.set_property(\"caps\", videocap)\n    13\n    14 # Converts the video from one colorspace to another\n    15 self.colorSpace = gst.element_factory_make(\n    16 \"ffmpegcolorspace\")\n    17\n    18 self.videoQueue = gst.element_factory_make(\"queue\")\n    19\n    20 self.textOverlay = gst.element_factory_make(\n    21 \"textoverlay\")\n    22 self.textOverlay.set_property(\"text\", \"hello\")\n    23 self.textOverlay.set_property(\"shaded-background\",\n    24 True)\n    25\n    26 self.timeOverlay = gst.element_factory_make(\n    27 \"timeoverlay\")\n    28 self.timeOverlay.set_property(\"valign\", \"top\")\n    29 self.timeOverlay.set_property(\"shaded-background\",\n    30 True)\n    31\n    32 self.clockOverlay = gst.element_factory_make(\n    33 \"clockoverlay\")\n    34 self.clockOverlay.set_property(\"valign\", \"bottom\")\n    35 self.clockOverlay.set_property(\"halign\", \"right\")\n    36 self.clockOverlay.set_property(\"shaded-background\",\n    37 True)\n    38\n    39 self.player.add(self.videoQueue,\n    40 self.autoconvert,\n    41 self.textOverlay,\n    42 self.timeOverlay,\n    43 self.clockOverlay,\n    44 self.capsFilter,\n    45 self.colorSpace,\n    46 self.videosink)\n    47\n    48 gst.element_link_many(self.videoQueue,\n    49 self.autoconvert,\n    50 self.capsFilter,\n    51 self.textOverlay,\n    52 self.timeOverlay,\n    53 self.clockOverlay,\n    54 self.colorSpace,\n    55 self.videosink)\n\n    ```", "```py\n    $python VideoTextOverlay.py\n\n    ```", "```py\nself.subtitlesrc = gst.element_factory_make(\"filesrc\")\nself.subtitlesrc.set_property(\"location\",\n\"/path/to/subtitles/file\")\nself.subparse = gst.element_factory_make(\"subparse\")\n\n```", "```py\n    1 def constructPipeline(self):\n    2 # Create the pipeline instance\n    3 self.player = gst.Pipeline()\n    4\n    5 # Define pipeline elements\n    6 self.filesrc = gst.element_factory_make(\"filesrc\")\n    7\n    8 self.filesrc.set_property(\"location\",\n    9 self.inFileLocation)\n    10\n    11 self.decodebin = gst.element_factory_make(\"decodebin\")\n    12\n    13 self.autoconvert = gst.element_factory_make(\n    14 \"autoconvert\")\n    15\n    16 self.audioconvert = gst.element_factory_make(\n    17 \"audioconvert\")\n    18\n    19 self.audio_encoder = gst.element_factory_make(\"lame\")\n    20\n    21 self.audiosink = gst.element_factory_make(\"filesink\")\n    22 self.audiosink.set_property(\"location\",\n    23 self.audioOutLocation)\n    24\n    25 self.video_encoder = gst.element_factory_make(\"\n    26 ffenc_mpeg4\")\n    27 self.muxer = gst.element_factory_make(\"ffmux_mp4\")\n    28\n    29 self.videosink = gst.element_factory_make(\"filesink\")\n    30 self.videosink.set_property(\"location\",\n    31 self.videoOutLocation)\n    32\n    33 self.videoQueue = gst.element_factory_make(\"queue\")\n    34 self.audioQueue = gst.element_factory_make(\"queue\")\n    35 # Add elements to the pipeline\n    36 self.player.add(self.filesrc,\n    37 self.decodebin,\n    38 self.videoQueue,\n    39 self.autoconvert,\n    40 self.video_encoder,\n    41 self.muxer,\n    42 self.videosink,\n    43 self.audioQueue,\n    44 self.audioconvert,\n    45 self.audio_encoder,\n    46 self.audiosink)\n    47\n    49 # Link elements in the pipeline.\n    50 gst.element_link_many(self.filesrc, self.decodebin)\n    51\n    52 gst.element_link_many(self. videoQueue,\n    53 self.autoconvert,\n    54 self.video_encoder,\n    55 self.muxer,\n    56 self.videosink)\n    57\n    58 gst.element_link_many(self.audioQueue,\n    59 self.audioconvert,\n    60 self.audio_encoder,\n    61 self.audiosink)\n\n    ```", "```py\n    1 def decodebin_pad_added(self, decodebin, pad):\n    2 compatible_pad = None\n    3 caps = pad.get_caps()\n    4 name = caps[0].get_name()\n    5 print \"\\n cap name is = \", name\n    6 if name[:5] == 'video':\n    7 compatible_pad = (\n    8 self.videoQueue.get_compatible_pad(pad, caps) )\n    9 elif name[:5] == 'audio':\n    10 compatible_pad = (\n    11 self. audioQueue.get_compatible_pad(pad,caps) )\n    12\n    13 if compatible_pad:\n    14 pad.link(compatible_pad)\n\n    ```", "```py\n    $python SeparatingAudio.py\n\n    ```", "```py\n    1 def constructPipeline(self):\n    2 self.pipeline = gst.Pipeline(\"pipeline\")\n    3\n    4 self.audiosrc = gst.element_factory_make(\"filesrc\")\n    5 self.audiosrc.set_property(\"location\",\n    6 self.audioInLocation)\n    7\n    8 self.videosrc = gst.element_factory_make(\"filesrc\")\n    9 self.videosrc.set_property(\"location\",\n    10 self.videoInLocation)\n    11\n    12 self.filesink = gst.element_factory_make(\"filesink\")\n    13 self.filesink.set_property(\"location\",\n    14 self.outFileLocation)\n    15\n    16 self.audio_decodebin = gst.element_factory_make(\n    17 \"decodebin\")\n    18 self.video_decodebin= gst.element_factory_make(\n    19 \"decodebin\")\n    20\n    21 self.audioconvert = gst.element_factory_make(\n    22 \"audioconvert\")\n    23 self.audio_encoder= gst.element_factory_make(\"lame\")\n    24\n    25 self.video_encoder = (\n    26 gst.element_factory_make(\"ffenc_mpeg4\") )\n    27 self.muxer = gst.element_factory_make(\"ffmux_mp4\")\n    28 self.queue = gst.element_factory_make(\"queue\")\n    29\n    audio-video track mixerdeveloping30\n    31 videocap = gst.Caps(\"video/x-raw-yuv\")\n    32 self.capsFilter = gst.element_factory_make(\n    33 \"capsfilter\")\n    34 self.capsFilter.set_property(\"caps\", videocap)\n    35 # Converts the video from one colorspace to another\n    36 self.colorSpace = gst.element_factory_make(\n    37 \"ffmpegcolorspace\")\n    38\n    39 self.pipeline.add( self.videosrc,\n    40 self. video_decodebin,\n    41 self.capsFilter,\n    42 self.colorSpace,\n    43 self.video_encoder,\n    44 self.muxer,\n    45 self.filesink)\n    46\n    47 self.pipeline.add(self.audiosrc,\n    48 self.audio_decodebin,\n    49 self.audioconvert,\n    50 self.audio_encoder,\n    51 self.queue)\n    52\n    53 # Link audio elements\n    54 gst.element_link_many(self.audiosrc,\n    55 self.audio_decodebin)\n    56 gst.element_link_many( self.audioconvert,\n    57 self.audio_encoder,\n    58 self.queue, self.muxer)\n    59 #Link video elements\n    60 gst.element_link_many(self.videosrc,\n    61 self.video_decodebin)\n    62 gst.element_link_many(self.capsFilter,\n    63 self.colorSpace,\n    64 self.video_encoder,\n    65 self.muxer,\n    66 self.filesink)\n\n    ```", "```py\n    1 def decodebin_pad_added(self, decodebin, pad):\n    2 compatible_pad = None\n    3 caps = pad.get_caps()\n    4 name = caps[0].get_name()\n    5 print \"\\n cap name is =%s\"%name\n    6 if ( name[:5] == 'video' and\n    7 (decodebin is self.video_decodebin) ):\n    8 compatible_pad = (\n    9 self.capsFilter.get_compatible_pad(pad, caps) )\n    10 elif ( name[:5] == 'audio' and\n    11 (decodebin is self.audio_decodebin) ):\n    12 compatible_pad = (\n    13 self.audioconvert.get_compatible_pad(pad, caps) )\n    14\n    15 if compatible_pad:\n    16 pad.link(compatible_pad)\n\n    ```", "```py\n    $python AudioVideoMixer.py\n\n    ```", "```py\npython ImagesFromVideo.py [options]\n\n```", "```py\n    import os, sys, time\n    import thread\n    import gobject\n    import pygst\n    pygst.require(\"0.10\")\n    import gst\n    from optparse import OptionParser\n    class ImageCapture:\n    def __init__(self):\n    pass\n    def connectSignals(self):\n    pass\n    def constructPipeline(self):\n    pass\n    def gnonlin_pad_added(self, gnonlin_elem, pad):\n    pass\n    def captureImage(self):\n    pass\n    def capture_single_image(self, media_start_time):\n    pass\n    def message_handler(self, bus, message):\n    pass\n    def printUsage(self):\n    pass\n    def printFinalStatus(self, starttime, endtime):\n    pass\n    # Run the program\n    imgCapture = ImageCapture()\n    thread.start_new_thread(imgCapture.captureImage, ())\n    gobject.threads_init()\n    evt_loop = gobject.MainLoop()\n    evt_loop.run()\n\n    ```", "```py\n    1 def constructPipeline(self):\n    2 self.pipeline = gst.Pipeline()\n    3 self.gnlfilesrc = (\n    4 gst.element_factory_make(\"gnlfilesource\") )\n    5\n    6 self.gnlfilesrc.set_property(\"uri\",\n    7 \"file:///\" + self.inFileLocation)\n    8 self.colorSpace = gst.element_factory_make(\n    9 \"ffmpegcolorspace\")\n    10\n    11 self.encoder= gst.element_factory_make(\"ffenc_png\")\n    12\n    13 self.filesink = gst.element_factory_make(\"filesink\")\n    14\n    15 self.pipeline.add(self.gnlfilesrc,\n    16 self.colorSpace,\n    17 self.encoder,\n    18 self.filesink)\n    19\n    20 gst.element_link_many(self.colorSpace,\n    21 self.encoder,\n    22 self.filesink)\n\n    ```", "```py\n    1 def captureImage(self):\n    2 # Record start time\n    3 starttime = time.clock()\n    4\n    5 # Note: all times are in nano-seconds\n    6 media_end = self.media_start_time + self.media_duration\n    7 start = self.media_start_time\n    8 while start < media_end:\n    9 self.capture_single_image(start)\n    10 start += self.deltaTime\n    11\n    12 endtime = time.clock()\n    13 self.printFinalStatus(starttime, endtime)\n    14 evt_loop.quit()\n\n    ```", "```py\n    self.deltaTime = int(self.media_duration / self.numberOfCaptures)\n\n    ```", "```py\n    1 def capture_single_image(self, media_start_time):\n    2 # Set media_duration as int as\n    3 # gnlfilesrc takes it as integer argument\n    4 media_duration = int(0.01*gst.SECOND)\n    5\n    6 self.gnlfilesrc.set_property(\"media-start\",\n    7 media_start_time)\n    8 self.gnlfilesrc.set_property(\"media-duration\",\n    9 media_duration)\n    10\n    11 # time stamp in seconds, added to the name of the\n    12 # image to be saved.\n    13 time_stamp = float(media_start_time)/gst.SECOND\n    14 outFile = os.path.join(self.outputDirPath,\n    15 \"still_%.4f.png\"%time_stamp )\n    16 print \"\\n outfile = \", outFile\n    17 self.filesink.set_property(\"location\", outFile)\n    18 self.is_playing = True\n    19 self.pipeline.set_state(gst.STATE_PLAYING)\n    20 while self.is_playing:\n    21 time.sleep(1)\n\n    ```"]