<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Vertex Groups and Materials</h1></div></div></div><p>Complex meshes might be difficult to handle when the number of vertices is large. In this chapter we will look at how we can make life easier for the end user by defining vertex groups to label collections of vertices. We will also explore some of the many uses of vertex groups including their use in armatures and modifiers, and we will look into methods to apply different materials to different parts of mesh.</p><p>In this chapter, we will learn how to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Define vertex groups</li><li class="listitem" style="list-style-type: disc">Assign vertices to a vertex group</li><li class="listitem" style="list-style-type: disc">Assign materials to faces</li><li class="listitem" style="list-style-type: disc">Assign vertex colors to vertices</li><li class="listitem" style="list-style-type: disc">Set edge properties</li><li class="listitem" style="list-style-type: disc">Add modifiers</li><li class="listitem" style="list-style-type: disc">Skin bones</li></ul></div><div><img alt="Vertex Groups and Materials" src="img/0400-03-01.jpg"/></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Vertex groups</h1></div></div></div><a class="indexterm" id="id171"/><p>
<strong>Vertex</strong> <strong>groups</strong> are a way to organize collections of vertices within a mesh. A mesh may have any number of vertex groups and any vertex within a mesh may be a member of more than one vertex group or may belong to no vertex group at all. A newly created <code class="literal">Mesh</code> object does not have any vertex groups defined.</p><p>In their basic form, vertex groups are a valuable tool in identifying distinct parts of a complex mesh. By assigning vertices to vertex groups, the modeler eventually provides people, such as the rigger or the people who texture a model, with the means to easily identify and select the parts of the model they want to work on.</p><a class="indexterm" id="id172"/><p>The use of vertex groups goes far beyond simple identification though. Many mesh modifiers restrict their influence to a designated vertex group and an armature can be configured to deform a mesh by linking the influence of each bone to a single vertex group. We will see examples of that later.</p><p>A vertex group is not merely a collection of vertices. Each vertex of a vertex group may have an associated <em>weight</em> (between zero and one) that many modifiers use to fine-tune their influence. A vertex may have a different weight associated with it in each vertex group it belongs to.</p><a class="indexterm" id="id173"/><p>The bugs we create with <code class="literal">creepycrawlies.py</code> are an excellent example of a rather complex mesh with many distinct parts that would benefit greatly from defining vertex groups. Not only to make it simpler to select a part by name, for instance the head, but also to make life easier for ourselves if we want to rig the model.</p><p>Our primary tools in creating vertex groups are the methods of <code class="literal">Mesh</code> objects listed in the following table:<a class="indexterm" id="id174"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th><th style="text-align: left" valign="bottom">
<p>Remarks</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">addVertGroup(group)</code><a class="indexterm" id="id175"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Adds a new empty vertex group.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">assignVertsToGroup(group,vertices,weight,mode)</code><a class="indexterm" id="id176"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Adds a list of vertex indices to an existing vertex group with the given weight.</p>
</td><td style="text-align: left" valign="top">
<p>Mode determines what to do when a vertex is already a member of the vertex group. See main text for details.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getVertsFromGroup(group,weightsFlag=0,vertices)</code><a class="indexterm" id="id177"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns a list of vertex indices (the default) or a list of (index, weight) tuples (<code class="literal">if</code> <code class="literal">weightsFlag</code> <code class="literal">=</code> <code class="literal">1</code>). If the vertices list is specified only those vertices that are in the group and in the given list are returned.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">removeVertsFromGroup(group,vertices)</code><a class="indexterm" id="id178"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Removes a list of vertices from an existing vertex group. If the list is not specified all vertices are removed.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">renameVertGroup(groupName, newName)</code><a class="indexterm" id="id179"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Renames a vertex group.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getVertGroupNames()</code><a class="indexterm" id="id180"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns a list of all vertex group names.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">removeVertGroup(group)</code><a class="indexterm" id="id181"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Deletes a vertex group.</p>
</td><td style="text-align: left" valign="top">
<p>Will NOT delete the actual vertices.</p>
</td></tr></tbody></table></div><a class="indexterm" id="id182"/><p>The important concept to grasp here is that creating a vertex group and assigning vertices to it are two separate actions. Creating a new empty vertex group is done by calling the <a class="indexterm" id="id183"/>
<code class="literal">addVertGroup()</code> method of your <code class="literal">Mesh</code> object. It takes a single string as an argument and that will be the name of the vertex group. If there is already a vertex group with the same name, the name will have a numerical suffix added to prevent a name clash, so for example: <code class="literal">TailSegment</code> may become <code class="literal">TailSegment.001</code>.</p><a class="indexterm" id="id184"/><p>Adding vertices to an existing vertex group is done by calling the <code class="literal">assignVertsToGroup()</code> method of your mesh. <a class="indexterm" id="id185"/>This method will take four mandatory arguments—the name of the vertex group to assign the vertices to, a list of vertex indices, a weight, and an <em>assign</em> mode.<a class="indexterm" id="id186"/> If the vertex group does not exist, or one of the vertex indices points to a nonexistent vertex, an exception is raised.</p><p>The weight must be a value between 0.0 and 1.0; any weight larger than 1.0 is clamped to 1.0. A weight smaller or equal to 0.0 will remove a vertex from the vertex group. If you want to assign different weights to vertices in the same vertex group, you have to assign them to the group with separate calls to <code class="literal">assignVertsToGroup()</code>.</p><p>The <em>assign</em> mode comes in three flavors: <code class="literal">ADD</code>, <code class="literal">REPLACE</code>, and <code class="literal">SUBTRACT</code>. <code class="literal">ADD</code> will add new vertices to the vertex group and will associate the given weight with them. If any of the vertices in the list already exist they get the weight added to them. <code class="literal">REPLACE</code> will replace the weight associated with the indices in the list if they are members of the vertex group or do nothing otherwise. <code class="literal">SUBTRACT</code> will try to subtract the weight from the vertices in the list and again do nothing if they are not members of the vertex group. Most often when adding completely new vertex groups to a mesh you will use the <code class="literal">ADD</code> mode.</p><div><div><div><div><h2 class="title"><a id="ch03lvl1sec27"/></h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl2sec37"/>A weighty issue</h3></div></div></div><p>For our first example we will add two new vertex groups to an existing mesh object—one that will contain all vertices that have a positive x-coordinate and one that will contain the vertices with a negative x-coordinate. We will name these groups <strong>Right</strong> and <strong>Left</strong> respectively.<a class="indexterm" id="id187"/>
</p><p>Additionally, we will give each vertex in these groups a weight depending on its distance from its object center with larger weights for vertices that are farther away from the center.</p><div><div><div><div><h4 class="title"><a id="ch03lvl3sec01"/>Code outline: leftright.py</h4></div></div></div><p>Schematically we will take the following steps:<a class="indexterm" id="id188"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Get the active object.</li><li class="listitem">Verify that it is a mesh and get the mesh data.</li><li class="listitem">Add two new vertex groups to the object—Left and Right.</li><li class="listitem">For all vertices in the mesh:<div><ol class="orderedlist arabic"><li class="listitem">Calculate the weight</li><li class="listitem">If the x-coordinate &gt; 0:</li><li class="listitem">Add vertex index and weight to vertex group <em>right</em></li><li class="listitem">If the x-coordinate &lt; 0:</li><li class="listitem">Add vertex index and weight to vertex group <em>left</em></li></ol></div></li></ol></div><p>In order to make certain that a new vertex group is empty we check if the group already exists and remove it if that is the case. This checking is highlighted in the code:</p><div><pre class="programlisting">def leftright(me,maximum=1.0):
   center=vec(0,0,0)
   left =[]
   right=[]
   for v in me.verts:
      weight = (v.co-center).length/maximum
      if v.co.x &gt; 0.0 :
         right.append((v.index, weight))
      elif v.co.x &gt; 0.0 :
         left.append((v.index, weight))
   return left,right   
         
if __name__ == "__main__":
   try:
      ob = Blender.Scene.GetCurrent().objects.active
      me = ob.getData(mesh=True)
      
      <strong>vgroups = me.getVertGroupNames()</strong>
 <strong>     if 'Left' in vgroups:</strong>
 <strong>        me.removeVertsFromGroup('Left')</strong>
 <strong>     else:</strong>
 <strong>        me.addVertGroup('Left')</strong>
 <strong>     if 'Right' in vgroups:</strong>
 <strong>        me.removeVertsFromGroup('Right')</strong>
 <strong>     else:</strong>
 <strong>        me.addVertGroup('Right')</strong>
      
      left,right = leftright(me,vec(ob.getSize()).length)
      
      for v,w in left:
         me.assignVertsToGroup('Left',[v],w,Blender.Mesh.AssignModes.ADD)
      for v,w in right:
         me.assignVertsToGroup('Right',[v],w,Blender.Mesh.AssignModes.ADD)
      
      Blender.Window.Redraw()
      
   except Exception as e:
      Blender.Draw.PupMenu('Error%t|'+str(e)[:80])
      </pre></div><a class="indexterm" id="id189"/><p>The full script is available as <code class="literal">leftright.py</code>. The formula to calculate the weight may need some explanation: in order to assign a maximum weight of 1.0 to the points lying at the greatest distance from the center of the object we have to scale by the maximum distance possible. We could loop over all vertices to determine that maximum first, but here we choose to approximate this maximum by the root mean square of the size. This will exaggerate the maximum distance so the maximum weight assigned to any vertex will probably be less than 1.0. However, getting the size is much faster than calculating the exact maximum for large meshes. Also, note that we calculate the distance to the object center (the object center from the point of view of the vertices in a mesh is always at (0, 0, 0)).</p><p>This may be completely different from what may be perceived by the user as the center of the mesh. (The object center is normally displayed as a pink dot in Blender and may be changed to lie at the average position of all vertices by selecting <strong>Object | Transform | Center new</strong>.)</p><p>The resulting weights for a mesh might looks like this:</p><div><img alt="Code outline: leftright.py" src="img/0400-03-02.jpg"/></div></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Modifiers</h1></div></div></div><a class="indexterm" id="id190"/><p>
<strong>Modifiers</strong> are tools that change a mesh in a non-destructive way and that can be adjusted interactively. Other objects may have modifiers as well: <code class="literal">Text3d</code>, <code class="literal">Metaballs</code>, and <code class="literal">Curves</code> for example. These objects may be represented as meshes so they can be modified as well. Not all modifiers can be associated with these objects though. If desired, the effects of modifiers can be made permanent by <em>applying</em> them. Blender provides a whole host of modifiers ranging from subsurface modifiers to all sorts of deformation modifiers. The table shows the list of available modifiers:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Modifier</p>
</th><th style="text-align: left" valign="bottom">
<p>Vertex group influence</p>
</th><th style="text-align: left" valign="bottom">
<p>Remarks</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>displacement<a class="indexterm" id="id191"/>
</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>curve</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>explode</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>lattice</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>mask</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>meshdeform</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>shrinkwrap</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>simpledeform</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>smooth</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>wave</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>array</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>bevel</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>boolean<a class="indexterm" id="id192"/>
</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>build</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>cast</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>decimate</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>edgesplit</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>mirror</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>subsurface</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>uvproject</p>
</td><td style="text-align: left" valign="top">
<p>no</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Particle system</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top">
<p>Many parameters influenced by different vertex groups</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>armature</p>
</td><td style="text-align: left" valign="top">
<p>yes</p>
</td><td style="text-align: left" valign="top">
<p>Each bone may be restricted to influence a single vertex group</p>
</td></tr></tbody></table></div><p>Many modifiers can be made to restrict their influence to a specific vertex group and a few modifiers are special. A particle system is considered a modifier although generally particle systems are managed via their own set of tools. Also, its relation to vertex groups is in a way reversed; instead of restricting its influence to the vertices within a vertex group, the weights of the vertices of vertex groups may influence all sorts of parameters of the particle system, such as emission density and velocity of the particles. We will see an example of that in the <em>Flying sparks</em> section.<a class="indexterm" id="id193"/>
</p><a class="indexterm" id="id194"/><p>Armature modifiers are also somewhat special as they do not restrict their influence to a single vertex group. However, they may be configured to restrict the influence of each separate bone to a specific vertex group as we will examine in the <em>Bones</em> section.</p><p>From a Python programmer's point of view the list of modifiers is a property of an object (that is, <em>not</em> of the underlying mesh). Objects referring to the same mesh may have different modifiers. This list contains <code class="literal">Modifier</code> objects and these can be added to and removed from this list, and individual modifiers can be moved up or down in the list. The order of modifiers is important in some cases. For example, adding a subsurface modifier after a mirror modifier may look different from adding the mirror modifier before the subsurface modifier.</p><p>A <code class="literal">Modifier</code> object has a type and a name (initially representing its type but it may be set to something more appropriate). The type is one of the types from the list of constants in <code class="literal">Modifier.Types</code>. Each modifier object may have many settings indexed by keys that are defined in <code class="literal">Modifier.Settings</code>. Not all settings are appropriate for all types.<a class="indexterm" id="id195"/>
</p><p>If we had two objects, a mesh object named <code class="literal">Target</code> and a lattice object named <code class="literal">Deformer,</code> and we would like to associate the <code class="literal">Deformer</code> object as a lattice modifier to the <code class="literal">Target</code> object, the following code snippet would do the trick:<a class="indexterm" id="id196"/>
</p><div><pre class="programlisting">import Blender
from Blender import Modifier

target  = Blender.Object.Get('Target')
deformer= Blender.Object.Get('Deformer')

mod = target.modifiers.append(Modifier.Types.LATTICE)
mod[Modifier.Settings.OBJECT] = deformer
target.makeDisplayList()
Blender.Window.RedrawAll()</pre></div><p>If the <code class="literal">Target</code> object had a vertex group named <code class="literal">Right</code> consisting of the vertices in the right half of the <code class="literal">Target</code> object we could restrict the influence of the modifier by changing the <code class="literal">VERTGROUP</code> attribute. Our snippet would change to the following (added line highlighted):<a class="indexterm" id="id197"/>
</p><div><pre class="programlisting">import Blender
from Blender import Modifier

target  = Blender.Object.Get('Target')
deformer= Blender.Object.Get('Deformer')

mod = target.modifiers.append(Modifier.Types.LATTICE)
mod[Modifier.Settings.OBJECT] = deformer
<strong>mod[Modifier.Settings.VERTGROUP] = 'Right'</strong>

target.makeDisplayList()
Blender.Window.RedrawAll()</pre></div><div><img alt="Modifiers" src="img/0400-03-03.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Engraving</h2></div></div></div><a class="indexterm" id="id198"/><p>Consider the following problem: given some text, we want to render this text as sunken grooves in a surface, just like it was engraved. This is not as simple as it seems. It is simple enough to create a text object, of course, but in order to manipulate this text we would like to convert this text object to a mesh. The Blender GUI offers this possibility in the object menu but strangely enough, the Blender API does not provide an equivalent function. So, our first hurdle would be to convert a text object to a mesh.<a class="indexterm" id="id199"/>
</p><p>The second problem that we have to solve is how to extrude a collection of vertices or edges in order to gauge out a depression in a surface. Again, there is no function in the Blender API for this so we will have to add this to our toolkit ourselves.</p><p>The final problem is more subtle. If we have somehow managed to create some sunken grooves we might want to make the edges somewhat less sharp as nothing in real life has perfectly sharp edges. There are various ways to go about this but many involve adding a modifier to our mesh. <a class="indexterm" id="id200"/>A <strong>bevel</strong> <strong>modifier</strong> might be enough to take away just the sharp edges but it is likely we would want to add a subsurface modifier to our mesh as a whole. Here we have a problem, when filling the gaps between the characters of our text it is very likely that we encounter many narrow triangles. These triangles mess up the appearance of our subsurface modifier as can be observed in the following figure:</p><div><img alt="Engraving" src="img/0400-03-04.jpg"/></div><a class="indexterm" id="id201"/><p>Two things might help to mitigate this problem. One is to add a crease weight to the edges of our engraved text thereby weighing these edges more than the default when calculating the subsurface. These may help but might also defeat the purpose of the modifier as it makes those edges sharper. The following figure shows the result: better, but still not looking great.</p><div><img alt="Engraving" src="img/0400-03-05.jpg"/></div><p>Another approach is to add an extra edge loop just outside the engraved text. This will add a ring of quad faces around the text making the subsurface around the text behave a lot better as can be seen below. In our final implementation we apply both solutions but first we tackle each issue one at a time.</p><div><img alt="Engraving" src="img/0400-03-06.jpg"/></div><a class="indexterm" id="id202"/><div><div><div><div><h3 class="title"><a id="ch03lvl3sec02"/>Converting a Text3d object to a mesh</h3></div></div></div><a class="indexterm" id="id203"/><p>A <code class="literal">Text3d</code> object is basically a curve with some additional parameters. The data block it refers to is a Blender <code class="literal">Curve</code> object and once we know how to access the individual parts in the curve that make up each character in our text, we can convert these curves to vertices and edges. All relevant functionality can be found in the <code class="literal">Blender.Curve</code> and <code class="literal">Blender.Geometry</code> modules.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>In Blender, the relation between a <code class="literal">Text3d</code> object and a <code class="literal">Curve</code> object is rather more subtle and confusing than described in the main text. A <code class="literal">Text3d</code> object is a specialized version of a <code class="literal">Curve</code> object, rather like a subclass in object-oriented parlance. However, in the Blender API, the <code class="literal">Text3d</code> object is not a subclass of <code class="literal">Curve</code>, nor are the extra attributes available on the same object instance. Sound confusing? It is. How would you retrieve all attributes then? The trick is that you can use the name of the <code class="literal">Text3d</code> object to get access to its associated <code class="literal">Curve</code> object as this small example shows: </p><div><pre class="programlisting">txt = ob.getData()
curve = Blender.Curve.Get(txt.getName())</pre></div><p>Now we can use <code class="literal">txt</code> to access <code class="literal">Text3d</code>-specific information (for example, <code class="literal">txt.setText('foo')</code>) and curve to access <code class="literal">Curve</code>-specific information (for example, <code class="literal">curve.getNumCurves()</code>).</p></div></div><a class="indexterm" id="id204"/><p>A Blender <code class="literal">Curve</code> object consists of a number of <code class="literal">CurNurb</code> objects that represent sections of a curve. A single text character typically consists of one or two curve segments. The small letter <em>e</em> for example, consists of an outer curve segment and a small inner curve segment. <code class="literal">CurNurb</code> objects in turn consist of a number of<a class="indexterm" id="id205"/> <strong>nodes</strong> or <strong>control points</strong><a class="indexterm" id="id206"/> that define the curve segment. These nodes are always <code class="literal">BezTriple</code> objects in the case of <code class="literal">Text3d</code> objects and Blender's <code class="literal">Geometry</code> module provides us with the <code class="literal">BezierInterp()</code> function<a class="indexterm" id="id207"/> that returns a list of coordinates interpolated between two points. These points and the direction the curve takes at those points (often called a <strong>handle</strong>) <a class="indexterm" id="id208"/>can be taken from the <code class="literal">BezTriple</code> objects. The resulting code looks this (the full code is part of our toolkit in <code class="literal">Tools.py</code>):</p><div><pre class="programlisting">import Blender

from Blender.Geometry import BezierInterp as interpolate
from Blender.Mathutils import Vector as vec

def curve2mesh(c):
   vlists=[]
   for cn in c:
      npoints = len(cn)
      
      points=[]
      first=True
      for segment in range(npoints-1):
         a=cn[segment].vec
         b=cn[segment+1].vec
         <strong>lastpoints = interpolate(vec(a[1]),vec(a[2]),vec(b[0]),vec(b[1]),6)</strong>
         if first:
            first = False
            points.append(lastpoints[0])
            points.extend(lastpoints[1:])
      <strong>if cn.isCyclic():</strong>
         a=cn[-1].vec
         b=cn[0].vec
         lastpoints=interpolate(vec(a[1]),vec(a[2]),vec(b[0]),vec(b[1]),6)
         points.extend(lastpoints[:-2])
      
      vlists.append(points)
   
   return vlists   </pre></div><a class="indexterm" id="id209"/><p>The highlighted lines show two important aspects. The first one shows the actual interpolation. We have renamed the rather awkwardly name <code class="literal">BezierInterp()</code> function to <code class="literal">interpolate()</code> and it takes five arguments. The first four are taken from the two <code class="literal">BezTriple</code> objects that we are interpolating between. Each <code class="literal">BezTriple</code> object can be accessed as a list of three vectors—the incoming handle, the position of the point, and the outgoing handle (see the next figure). We pass the position of the first point and its outgoing handle and the position of the second point and its ingoing handle. The fifth argument is the number of points we want the <code class="literal">interpolate()</code> function to return.<a class="indexterm" id="id210"/>
</p><div><img alt="Converting a Text3d object to a mesh" src="img/0400-03-07.jpg"/></div><p>The second highlighted line takes care of <strong>closed</strong> <strong>curves</strong>, that is curves that have their first and last points connected. This is the case for all curves that form characters in a text. The function returns a list of lists. Each list contains all of the interpolated points (tuples of x, y, z coordinates) for each curve. Note that some characters consist of more than one curve. For example, the small letter <em>e</em> in many fonts or the letter <em>o</em> consist of two curves, one defining the outline of the letter and one the interior. A <code class="literal">Text3d</code> object containing the text <code class="literal">Foo</code> for example will return a list of five lists—the first one will contain the vertices defining the capital letter <em>F</em> and the second and third will contain the vertices for the two curves that make up the small letter <em>o</em> as will the fourth and fifth.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Extruding an edge loop</h3></div></div></div><a class="indexterm" id="id211"/><p>
<strong>Extrusion</strong> is the process where we duplicate vertices (and possibly their connecting edges) and move them out in some direction, after which we connect these duplicated vertices to their origins by new edges and finish up the operation by creating a new face between the old and new vertices. We need it in order to sink the outline of our text to create a groove with vertical walls. <a class="indexterm" id="id212"/>The function <code class="literal">extrude_selected_edges()</code> in <code class="literal">Tools.py</code> takes a mesh and a vector as arguments and will extrude the vertices on selected edges in the mesh in the direction of the vector, adding any necessary new edges and faces. Because the techniques are extensions of things we've seen earlier the code is not shown here.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Expanding an edge loop</h3></div></div></div><a class="indexterm" id="id213"/><p>If we have a list of edges forming a closed curve (or more than one) defining a character, we would like to surround those edges with an extra edge loop to create a better "flow" in any subsurface modifier that the end user may associate with our mesh. This would be a rather involved process if we would have to calculate this in 3D, but fortunately our converted characters have all their vertices in the xy plane (this is because all of the characters in a newly instantiated <code class="literal">Text3d</code> object lie in the xy plane)..</p><div><img alt="Expanding an edge loop" src="img/0400-03-08.jpg"/></div><p>In just two dimensions this is quite a tractable problem. For each point on our edge loop we determine the direction of the vertex normal. <a class="indexterm" id="id214"/>The <strong>vertex</strong> <strong>normal</strong> is the line bisecting the angle between the two edges that share the point we are considering. If the two edges are co-linear (or nearly so), we take the vertex normal to be a line perpendicular to one of the edges. The position of the point to create on the new edge loop will be somewhere on this normal. In order to determine if we have to move outward or inward along this normal, we simply try one direction and check whether the new position is within the outline of our character. If so, we reverse the direction.</p><a class="indexterm" id="id215"/><p>One issue needs addressing still, a character may consist of more than one curve. If we want to draw additional edge loops around such a character, such an edge loop should be beyond the outline of a character but inside any interior curve. In other words, if we construct a new edge loop we have to know whether a curve lies within another curve. If so, it is not an outline and the new edge loop should be constructed to lie within the curve. Therefore, our <code class="literal">expand()</code> function (shown in the next snippet, full code is part of <code class="literal">Tools.py</code>) takes an extra optional argument <code class="literal">plist</code>, which is a list of lists containing <code class="literal">MVert</code> objects defining additional polygons to check against. If the first point of the curve that we want to expand lies within any of these additional curves, we assume that the curve we are expanding is an <a class="indexterm" id="id216"/>
<strong>interior</strong> <strong>curve</strong>. (This would be wrong if the interior curve would cross the exterior curve at some point, but for curves defining a character in a font this is never so.)</p><div><pre class="programlisting">def expand(me,loop,offset=0.05,plist=[]):

 <strong>  ov = [me.verts[i] for i in verts_from_edgeloop(loop)]</strong>
   
   inside=False
   for polygon in plist:
      if in_polygon(loop[0].v1.co,polygon):
         inside=True
         break   # we don't deal with multiple inclusions
   
   n=len(ov)
   points=[]
   for i in range(n):
      va = (ov[i].co-ov[(i+1)%n].co).normalize()
      vb = (ov[i].co-ov[(i-1)%n].co).normalize()
      cosa=abs(vec(va).dot(vb))
      if cosa&gt;0.99999 :   # almost colinear
         c = vec(va[1],va[0],va[2])
      else:
         c = va+vb
      l = offset/c.length
      p = ov[i].co+l*c
      if in_polygon(p,ov) != inside:
         p = ov[i].co-l*c
      print i,ov[i].co,va,vb,c,l,cosa,p
      points.append(p)
      
   return points</pre></div><a class="indexterm" id="id217"/><p>The highlighted code calls a function (provided in <code class="literal">Tools.py</code>) that takes a list of edges that form an edge loop and returns a sorted list of vertices. <a class="indexterm" id="id218"/>This is necessary because our <code class="literal">in_polygon()</code> function takes a list of vertices rather than edges and assumes that this list is sorted, that is adjacent vertices form edges that do not cross.</p><p>To determine whether a point is inside a closed polygon defined by a list of vertices, we count the number of edges that are crossed by a line (often called a <strong>ray</strong>) <a class="indexterm" id="id219"/>that starts at the point and extends to infinity. If the number of edges crossed is odd, the point will lie inside the polygon; if it's even, it lies outside of the polygon. The following figure illustrates the concept:</p><div><img alt="Expanding an edge loop" src="img/0400-03-09.jpg"/></div><a class="indexterm" id="id220"/><p>The function <code class="literal">in_polygon()</code> shown here is part of <code class="literal">Tools.py</code>. It takes a point (a <code class="literal">Vector</code>) and a list of vertices (<code class="literal">MVert</code> objects) and returns either <code class="literal">True</code> or <code class="literal">False</code>. Note that any z-coordinate in either the point or the vertices in the polygon is ignored.</p><div><pre class="programlisting">from Blender.Geometry import LineIntersect2D
from Blender.Mathutils import Vector as vec

def in_polygon(p,polygon):
   intersections = 0
   n = len(polygon)
   if n&lt;3 : return False
   for i in range(n):
      <strong>if LineIntersect2D (p,vec(1.0,0.0,0.0),polygon[i].</strong>co,polygon[(i+1)%n].co):
         intersections+=1
   return intersections % 2 == 1</pre></div><a class="indexterm" id="id221"/><p>The heavy lifting is done in the highlighted line by the <code class="literal">LineIntersect2D()</code> function available in the <code class="literal">Blender.Geometry</code> module. The <em>modulo</em> (<code class="literal">%</code>) operation in the <code class="literal">return</code> statement is a way to determine whether the encountered number of intersections is odd.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Putting it all together: Engrave.py</h2></div></div></div><a class="indexterm" id="id222"/><p>Armed with all the supporting functions developed in the previous sections, we can make a list of the steps that we'll have to undertake in order to engrave a text:</p><div><ol class="orderedlist arabic"><li class="listitem">Show a pop up to enter a string to engrave.</li><li class="listitem">Check whether the active object is a mesh and has faces selected.</li><li class="listitem">Create a <code class="literal">Text3d</code> object.</li><li class="listitem">Convert it to a mesh, with appropriate vertex groups.</li><li class="listitem">Add extra edge loops to the characters.</li><li class="listitem">Extrude the original characters downward.</li><li class="listitem">Fill the bottom of the extruded characters.</li><li class="listitem">Add a "cartouche" (a rectangle) around the text.</li><li class="listitem">Fill the space between the cartouche and the characters.</li><li class="listitem">Add a subsurface modifier.</li><li class="listitem">Set a crease value in the edges contained in <code class="literal">TextTop</code> and <code class="literal">TextBottom</code> vertex groups.</li></ol></div><p>Our final script follows this outline almost exactly and makes use of the tools that we developed earlier in this chapter. We show the most relevant sections here (the full script is available as <code class="literal">engrave.py</code>). We start off by converting a <code class="literal">Text3d</code> object (<code class="literal">c</code> in the following code) to a list containing a list of vertex positions for each curve segment in the text and we add a new empty <code class="literal">Mesh</code> object to the scene with some empty vertex groups:</p><div><pre class="programlisting">   vlist = curve2mesh(c)
   
   me = Blender.Mesh.New('Mesh')
   ob = Blender.Scene.GetCurrent().objects.new(me,'Mesh')
   
   me.addVertGroup('TextTop')
   me.addVertGroup('TextBottom')
   me.addVertGroup('Outline')</pre></div><p>The next step is to add these vertices to the mesh and create connecting edges. As all curve segments in a character are closed, we have to take care to add an extra edge to bridge the gap between the last and first vertex as shown in the highlighted line. For good measure, we remove any doubles that may be present in the interpolated curve segment. We add the vertices to the <code class="literal">TextTop</code> vertex group and store the list of new edges for future reference.</p><div><pre class="programlisting">   loop=[]
   for v in vlist:
      offset=len(me.verts)
      me.verts.extend(v)
      edgeoffset=len(me.edges)
      me.edges.extend([(i+offset,i+offset+1) for i in range(len(v)-1)])
      <strong>me.edges.extend([(len(v)-1+offset,offset)])</strong>
      me.remDoubles(0.001)
   
      me.assignVertsToGroup('TextTop', range(offset,len(me.verts)),1.0, Blender.Mesh.AssignModes.ADD)
      loop.append([me.edges[i] for i in range(edgeoffset,len(me.edges) )])</pre></div><a class="indexterm" id="id223"/><p>For each edge loop that we stored in the previous part we construct a new, and slightly larger, edge loop around it and add these new vertices and edges to our mesh. We want to construct faces between these edge loops as well and that is started at the highlighted line: here we use the Python <a class="indexterm" id="id224"/>built-in function <code class="literal">zip()</code> to pair the edges of the two edge loops. Each edge loop is ordered by a <code class="literal">utility</code> function <a class="indexterm" id="id225"/>(available in <code class="literal">Tools.py</code>) that sorts edges to lie in the order in which they are connected to each other. For each pair of edges we construct two possible arrangements of vertex indices and calculate which of them forms an untwisted face. This calculation is done by the <code class="literal">least_warped()</code> function <a class="indexterm" id="id226"/>(code not shown) that basically compares the circumference of the faces defined by the two different orderings of vertices. The untwisted face will have the shortest circumference, which is then added to the mesh.</p><div><pre class="programlisting">   for l in range(len(loop)):
      points = expand.expand(me,loop[l],0.02,loop[:l]+loop[l+1:])
      offset=len(me.verts)
      me.verts.extend(points)
      edgeoffset=len(me.edges)
      me.edges.extend([(i+offset,i+offset+1) for i in range(len(points)-1)])
      me.edges.extend([(len(points)-1+offset,offset)])
      eloop=[me.edges[i] for i in range(edgeoffset,len(me.edges))]
      me.assignVertsToGroup('Outline',range(offset,len(me.verts)),1.0,Blender.Mesh.AssignModes.ADD)
      faces=[]
      <strong>for e1,e2 in zip( expand.ordered_edgeloop(loop[l]),expand.ordered_edgeloop(eloop)):</strong>
         f1=(e1.v1.index,e1.v2.index,e2.v2.index,e2.v1.index)
         f2=(e1.v2.index,e1.v1.index,e2.v2.index,e2.v1.index)
         faces.append(least_warped(me,f1,f2))
      me.faces.extend(faces)</pre></div><p>We omitted the code to extrude the character edge loop, but the following lines are informative as they show how to fill an edge loop. First, we select all relevant edges by using two utility functions (these are the extruded edges of the characters). Next, we call the <code class="literal">fill()</code> method. This method will fill any collection of closed edge loops as long as they lie in the same plane. It even takes cares of holes (like the little island in the letter <em>e</em>):</p><div><pre class="programlisting">   deselect_all_edges(me)
   select_edges(me,'TextBottom')
   me.fill()</pre></div><p>Adding the cartouche is simply a matter of adding a rectangular edge loop around our characters. If this edge loop is selected together with the vertices in the <code class="literal">Outline</code> vertex group, the <code class="literal">fill()</code> method can be used again to fill up this cartouche. This is not shown here. We end with some finishing touches: we convert the triangles in our mesh as much as possible to quads by using the <code class="literal">triangleToQuad()</code> method and then subdivide the mesh. We also add a subsurface modifier, set the <code class="literal">smooth</code> attribute on all the faces, and recalculate all face normals to point consistently outward.</p><div><pre class="programlisting">   me.triangleToQuad()
   me.subdivide()
   
   mod = ob.modifiers.append(Blender.Modifier.Types.SUBSURF)
   mod[Blender.Modifier.Settings.LEVELS]=2
   
   select_all_faces(me)
   set_smooth(me)
   select_all_edges(me)
   me.recalcNormals()</pre></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>
<strong>The hidden Hook modifier:</strong>
</p><p>We have seen that the modifiers available in Blender can be added to an object in Python. There is, however, one modifier that can be added but seems to have no equivalent within the Blender GUI. This is the so-called <strong>Hook</strong> <strong>modifier</strong>. A Hook in Blender is a way to parent vertices to an object (so it's the reverse of vertex parenting where we parent an object to a vertex) and in the application itself can be accessed through the <strong>Mesh | Vertex | Add Hook</strong> menu in <em>edit</em> mode. Once added, it will show up in the list of modifiers. From a programmer's view the Hook modifier is no different from other modifiers but alas neither its type nor the settings needed are documented in the API.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Flying sparks</h2></div></div></div><p>Sparks and all sorts of glowing effects can readily be created by adding a suitable particle system to an object. Many of the particle systems' parameters can be controlled by the weight of vertices in a vertex group, including the local density of the emitted particles.</p><p>In this example we would like to mimic the behavior of the electrical phenomenon called "St Elmo's fire". This is the effect that under certain circumstances, especially in the advance of a thunderstorm, some objects start to glow. This glow is called <strong>corona discharge</strong> (<a class="ulink" href="http://en.wikipedia.org/wiki/St._Elmo%27s_fire">http://en.wikipedia.org/wiki/St._Elmo%27s_fire</a>) and  is most prominent at sharp and protruding parts of larger structures, for example, radio antennae or lightning rods where the electric field that causes the effect is strongest.</p><p>In order to influence the number of particles emitted from the mesh in a believable manner we need to calculate a quantity named local curvature and store this curvature suitably scaled as weights in a vertex group. Then, we can apply this vertex group to the density parameter in the <strong>extra</strong> panel of the particle's context to control the emission.</p><p>A mesh may have any form, and most of the time there is no neat formula that approximates the form. Therefore, we approximate the local curvature in a necessarily crude way (for more details and some heavy math, see <a class="ulink" href="http://en.wikipedia.org/wiki/Mean_curvature">http://en.wikipedia.org/wiki/Mean_curvature</a>) by calculating the average of all edge curvatures of the connected edges for every vertex in the mesh. Here we define the <strong>edge</strong> <strong>curvature</strong> as the dot product of the normalized vertex normal and the edge vector (that is, the vector form the vertex to its neighbor). This product will be negative if the edge curves down relative to the normal and positive if it curves up. We will reverse this sign as we are more accustomed with the notion of a positive curvature for spikes rather than for troughs. Another way to look at this is that in areas of positive curvature, the angle between the vertex normal and an edge starting at the same vertex is larger than 90°.</p><p>The following figure illustrates the concept—it depicts a series of vertices linked by edges. Each vertex has an associated vertex normal shown (the arrows). The vertices marked <strong>a</strong> have a positive curvature, the ones marked <strong>b</strong> a negative curvature. Two of the shown vertices labeled with <strong>c</strong> are in an area of zero curvature—that is, at those locations the surface is flat and the vertex normal perpendicular to the edges.</p><div><img alt="Flying sparks" src="img/0400-03-10.jpg"/></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec05"/>Calculating the local curvature</h3></div></div></div><p>The function that calculates the local curvature for each vertex in a mesh and returns a list of normalized weights may be implemented as follows:</p><div><pre class="programlisting">from collections import defaultdict

def localcurvature(me,positive=False):
   
   end=defaultdict(list)
   for e in me.edges:
      end[e.v1.index].append(e.v2)
      end[e.v2.index].append(e.v1)
      
   <strong>weights=[]</strong>
 <strong>  for v1 in me.verts:</strong>
 <strong>     dvdn = []</strong>
      <strong>for v2 in end[v1.index]:</strong>
 <strong>        dv = v1.co-v2.co</strong>
 <strong>        dvdn.append(dv.dot(v1.no.normalize()))</strong>
 <strong>     weights.append((v1.index,sum(dvdn)/max(len(dvdn),1.0)))</strong>
   
   if positive:
      weights = [(v,max(0.0,w)) for v,w in weights]
      
   minimum = min(w for v,w in weights)
   maximum = max(w for v,w in weights)
   span = maximum - minimum
   
   if span &gt; 1e-9:
      return [(v,(w-minimum)/span) for v,w in weights]
   return weights</pre></div><p>The function <code class="literal">localcurvature()</code> takes a mesh and one optional argument and returns a list of tuples with the vertex index and its weight. If the optional argument is <code class="literal">true</code> any negative weight calculated is discarded.</p><p>The hard work is done in the highlighted lines. Here we loop over all vertices and then, in an inner loop, check each connected edge to retrieve the vertex at the other end from a precomputed dictionary. We then calculate <code class="literal">dv</code> as the edge vector and append the dot-product of this edge vector and the normalized vertex normal to the list <code class="literal">dvdn</code>.</p><div><pre class="programlisting">weights.append((v1.index,sum(dvdn)/max(len(dvdn),1.0)))</pre></div><p>The previous line may look strange but it appends a tuple consisting of the vertex index and its average curvature, where the average is computed by summing the list of curvatures and dividing it by the number of values in the list. Because the list may be empty (this happens when the mesh contains unconnected vertices), we safeguard against a divide by zero error by dividing it by the length of the list or by one, whichever is the largest. In this way, we keep our code a little more readable by avoiding <code class="literal">if</code> statements.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec06"/>Code outline: curvature.py</h3></div></div></div><p>With the <code class="literal">localcurvature()</code> function at our disposal, the actual curvature script becomes quite terse (full script available as <code class="literal">curvature.py</code>):</p><div><pre class="programlisting">if __name__ == "__main__":
   try:
      choice = Blender.Draw.PupMenu("Normalization%t|Onlypositive|Full range")
      if choice&gt;0:
         ob = Blender.Scene.GetCurrent().objects.active
         me = ob.getData(mesh=True)
         
         try:
            <strong>me.removeVertGroup('Curvature')</strong>
         except AttributeError:
            pass
         
         <strong>me.addVertGroup('Curvature')</strong>
         
         for v,w in localcurvature(me,positive=(choice==1)):
            <strong>me.assignVertsToGroup('Curvature',[v],w,Blender.Mesh.AssignModes.ADD)</strong>
         
         Blender.Window.Redraw()
         
   except Exception as e:
      Blender.Draw.PupMenu('Error%t|'+str(e)[:80])</pre></div><p>The highlighted lines show how we remove a possible existing <code class="literal">Curvature</code> vertex group from the <code class="literal">Mesh</code> object by just trying and catching an <code class="literal">AtrributeError</code> that is raised when the group is not present. Next, we add again the group with the same name so it will be completely empty. The last highlighted line shows how we add each vertex separately because any vertex may have a different weight.</p><p>All actions are surrounded by a <code class="literal">try … except</code> construct that will catch any errors and that will pop up a nice informational message if anything out of the ordinary occurs. Most likely this will be in situations where the user forgets to select a <code class="literal">Mesh</code> object.</p><div><img alt="Code outline: curvature.py" src="img/0400-03-11.jpg"/></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec07"/>Putting it all together: St. Elmo's fire</h3></div></div></div><p>The illustration of the discharge from the sharp-tipped rod was made by modeling a simple rod object by hand and then calculating the curvature with <code class="literal">curvature.py</code>.</p><div><img alt="Putting it all together: St. Elmo's fire" src="img/0400-03-12.jpg"/></div><p>Then, a particle system was added and the density parameter in the extra tab was set to the <code class="literal">Curvature</code> vertex group. The rod and the particle system were given separate materials: a simple gray and white halo respectively. The particles were simulated for 250 frames and frame 250 was rendered for the illustration.</p><div><img alt="Putting it all together: St. Elmo's fire" src="img/0400-03-13.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Bones</h1></div></div></div><p>An armature might be considered the backbone of animation because deforming a mesh in a controllable way, which can be keyed at given frames, is necessary to enable animators to pose their characters in a well-controlled way.</p><p>Blender's armature implementation provides the rigger and animator with an overwhelmingly large amount of possibilities, but at the end of the day an armature is foremost a collection of connected bones where each bone will deform part of a mesh. The movements of these bones in respect to each other can be governed by several different constraints.</p><a class="indexterm" id="id227"/><p>While bones may be configured to work their influence via an <strong>envelope</strong>, <a class="indexterm" id="id228"/>thereby basically deforming any vertex of the target mesh within a certain radius, they may also be configured to deform only those vertices that belong to a vertex group with the same name as the name of the bone. This deformation is further controlled by the weight of the vertices in the vertex group enabling us to fine-tune the bone influence.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Tick-Tock</h2></div></div></div><p>To illustrate the basic possibilities of an armature we will be rigging a simple clock model. <a class="indexterm" id="id229"/>The clock is of a single mesh consisting of three separate, non-connected submeshes—the body, the little hand, and the big hand. The vertices of each clock hand belong to two separate vertex groups—one for the bit of the clock hand connected to the center of the clock, and for the end of the hand itself. This setup allows for a cartoon-like animation where we can make the tip of the hand trail the actual motion for instance.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Code outline: clock.py</h3></div></div></div><p>We will have to take the following steps to rig our clock in the way we intend:</p><div><ol class="orderedlist arabic"><li class="listitem">Import mesh data.</li><li class="listitem">Create clock mesh.</li><li class="listitem">Create vertex groups.</li><li class="listitem">Create armature object.</li><li class="listitem">Create bones within armature.</li><li class="listitem">Associate armature modifier.</li></ol></div><p>The translation from the outline to code is almost one on one and a little repetitive as many instructions are repeated for each bone (full code available as <code class="literal">clock.py</code>):<a class="indexterm" id="id230"/>
<a class="indexterm" id="id231"/>
</p><div><pre class="programlisting">   me=Blender.Mesh.New('Clock')
   me.verts.extend(clockmesh.Clock_verts)
   me.faces.extend(clockmesh.Clock_faces)
   
   scn=Blender.Scene.GetCurrent()
   ob=scn.objects.new(me)
   scn.objects.active=ob

   me.addVertGroup('BigHand')
   me.assignVertsToGroup('BigHand',clockmesh.Clock_vertexgroup_BigHand,1.0, Blender.Mesh.AssignModes.ADD)
   
   … &lt;similar code for LittleHand, BigArm and LittleArm vertex groupsomitted&gt; ...   

   ar = Blender.Armature.New('ClockBones')
   <strong>ar.envelopes=False</strong>
 <strong>  ar.vertexGroups=False</strong>
   obbones = scn.objects.new(ar)
   
   mod = ob.modifiers.append(Blender.Modifier.Types.ARMATURE)
   mod[Blender.Modifier.Settings.OBJECT]=obbones
   <strong>mod[Blender.Modifier.Settings.ENVELOPES]=False</strong>
 <strong>  mod[Blender.Modifier.Settings.VGROUPS]=True</strong>

   <strong>ar.makeEditable()</strong>
   bigarm = Blender.Armature.Editbone()
   bigarm.head = vec(0.0,0.0 ,0.57)
   bigarm.tail = vec(0.0,0.75,0.57)
   ar.bones['BigArm'] = bigarm
   bighand = Blender.Armature.Editbone()
   bighand.head = bigarm.tail
   bighand.tail = vec(0.0,1.50,0.57)
   bighand.parent = bigarm
   ar.bones['BigHand'] = bighand
   
   … &lt;similar code for the little hand omitted&gt; …

   <strong>ar.update</strong>()
   
   obbones.makeParent([ob])</pre></div><a class="indexterm" id="id232"/><p>The important things are highlighted. First, we disable the envelopes and the <code class="literal">vertexGroups</code> properties on the armature <em>object</em>. This may seem strange but these properties are remnants of a time where an armature was not a modifier applied to a mesh, but worked its influence by being parented to the <code class="literal">Mesh</code> object (at least as far as I can tell, the available documentation is a bit vague about this).. We determine what kind of influence to use by setting properties on the armature <em>modifier</em>.</p><p>After associating an armature modifier with our <code class="literal">Mesh</code> object we construct our armature bone by bone. Before we add any bones to an armature we have to call its <code class="literal">makeEditable()</code> method. <a class="indexterm" id="id233"/>Note that this <strong>edit</strong> <strong>mode</strong> <strong>for</strong> <strong>armatures</strong> is distinct from the <em>edit</em> mode for other objects that can be set with the <code class="literal">Blender.Window.editMode()</code> function! Once we are done, we revert to <em>normal</em> mode again by calling the <code class="literal">update()</code> method.<a class="indexterm" id="id234"/>
</p><p>You may have noticed that when constructing our armature we created instances of <code class="literal">Editbone</code> objects. Outside of the <em>edit</em> mode, these same bones are referred to as <code class="literal">Bone</code> objects. Both refer to the same bone but offer different functionality and attributes appropriate for either <em>edit</em> mode or in <em>object</em> mode. To accommodate the same sort of approach, Blender also provides <code class="literal">PoseBone</code> objects to manipulate bones in <strong>Pose mode</strong>.</p><p>The bones are positioned in the armature by specifying their head and tail positions (the blunt and sharp end respectively when representing a bone as an octagon). To connect bones it is not sufficient to make the tail position of one bone equal to the head position of another. In order to let a bone follow the movements of another bone it must be parented to it. Parenting is effected by setting the <code class="literal">parent</code> attribute of the child to point to the parent bone object. In our example, we have parented each hand bone to its corresponding arm bone.</p><a class="indexterm" id="id235"/><p>Bones within an armature are indexed by their name. If the <code class="literal">VGROUPS</code> property of an armature modifier is set, the name of the bone should be identical to the name of the vertex group that it influences.</p><p>The final line of our example code is important as well; it is necessary to parent the <code class="literal">Mesh</code> object to the armature. This might seem superfluous in situations where the armature and the mesh will stay in the same location and only the individual bones in the armature will move; but failing to do so will result in an erratic display of the mesh when interactively changing a pose (you will have to change the mesh to <em>edit</em> mode and back, for example to see the effect of the pose on the armature, which is completely unworkable). The result of our rigging will look like this (we set the display mode of the armature to x-ray to make it visible through the mesh):<a class="indexterm" id="id236"/>
</p><div><img alt="Code outline: clock.py" src="img/0400-03-14.jpg"/></div><p>The rendered result may look like this:</p><div><img alt="Code outline: clock.py" src="img/0400-03-15.jpg"/></div><a class="indexterm" id="id237"/><p>We might want to limit the motion of the individual bones to just rotations around the z-axis and this may be accomplished by adding constraints. We will encounter constraints in the next chapter.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Get a bit of backbone boy!</h2></div></div></div><p>What we have learned so far about rigging can be applied to <code class="literal">creepycrawlies.py</code> as well. If we want to extend the functionality of the generated model, we may associate an armature modifier with the generated mesh. We have to create an armature object as well, with an appropriate set of bones.</p><p>Our task is made light as we already have the vertices grouped by body part in the <code class="literal">mymesh</code> module, so associating them with a vertex group and a matching bone is trivial. Not so trivial is to create the bones themselves as these might be many and should be positioned and connected in the correct way.</p><a class="indexterm" id="id238"/><p>Let's look at how some of the essential elements might be implemented (the full code is in <code class="literal">creepycrawlies.py</code>). First we have to create an armature and make it editable in order to add bones:</p><div><pre class="programlisting">ar = Blender.Armature.New('BugBones')
   ar.autoIK = True
   obbones = scn.objects.new(ar)
   ar.makeEditable()</pre></div><p>We may also set any attributes that alter the behavior of the armature or the way it is displayed. Here we just enable the <code class="literal">autoIK</code> feature as this will make manipulating the possibly very long tail of our creature a lot simpler for the animator.</p><p>The next step is to create a bone for each set of vertices. The <code class="literal">vgroup</code> list in the following code contains tuples (<code class="literal">vg,vlist,parent,connected</code>) where <code class="literal">vg</code> is the name of the vertex group and <code class="literal">vlist</code> is the list of vertex indices belonging to this group. Each bone that we create may have a parent and it may be physically connected to the parent. These conditions are signaled by the <code class="literal">parent</code> and <code class="literal">connected</code> members of the tuple:</p><div><pre class="programlisting">   for vg,vlist,parent,connected in vgroup:
      
      bone = Blender.Armature.Editbone()
      bb = bounding_box([verts[i] for i in vlist])</pre></div><a class="indexterm" id="id239"/><p>For each bone we create we calculate the bounding box of all the vertices in the vertex group that this bone will influence. The next thing will be to position the bone. The way we have set up our creature, all segments of its body will extend along the y-axis except for the wings and legs. These extend along the x-axis. We check this first and set the <code class="literal">axis</code> variable accordingly:</p><div><pre class="programlisting">      axis=1
      if vg.startswith('wing') or vg.startswith('leg'): axis = 0</pre></div><p>Bones within the armature are indexed by name and the positions of the bone ends are stored in its <code class="literal">head</code> and <code class="literal">tail</code> attributes respectively. So, if we have a parent bone and we want to determine its average y-coordinate we can calculate that in the following manner:</p><div><pre class="programlisting">      
      if parent != None : 
         parenty = (ar.bones[parent].head[1] +ar.bones[parent].tail[1])/2.0</pre></div><p>We calculate this position because parts such as legs and wings have parent bones (that is, they move along with the parent bone) but are not connected from head to tail. We will position these bones starting at the center of the parent bone and for that we need the y-position of the parent. The bones of segments lying along the y-axis are positioned along the y-axis themselves and so have zero x and z-coordinates. The x and z-coordinates of leg and wing segments are taken from their bounding boxes. If the bone <em>is</em> connected, we simply set its head position to a copy of the position of the tail of the parent (highlighted below).</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>The Blender <code class="literal">Vector</code> class provides the <code class="literal">copy()</code> function but oddly enough not the <code class="literal">__copy__()</code> function, so it won't play nice with the functions from Python's <code class="literal">copy</code> module.<a class="indexterm" id="id240"/>
</p></div></div><div><pre class="programlisting">      if connected:
         bone.head = <strong>ar.bones[parent].tail.copy()</strong>
      else:
         if axis==1:
            bone.head=Blender.Mathutils.Vector(0,bb[1][0],0)
         else:
            bone.head=Blender.Mathutils.Vector(bb[0][1],parenty,bb[2][1])</pre></div><div><pre class="programlisting">
<a class="indexterm" id="id241"/>The tail position of the bone is calculated in a similar manner:if axis==1:
         bone.tail=Blender.Mathutils.Vector(0,bb[1][1],0)
      else:
         bone.tail=Blender.Mathutils.Vector(bb[0][0],parenty,bb[2][0])</pre></div><p>The final steps in creating a bone are adding it to the armature and setting bone-specific options and any parent relationship.</p><div><pre class="programlisting">      ar.bones[vg] = bone
      
      if parent != None :
         bone.parent=ar.bones[parent]
      else:
         bone.clearParent()
      
      if connected: bone.options=Blender.Armature.CONNECTED</pre></div><p>Note that in the preceding code, the order of the operations is significant: the <code class="literal">parent</code> attribute may only be cleared on bones that are added to an armature and the <code class="literal">CONNECTED</code> option may only be set on a bone with a parent.</p><p>Again, we should beware of some Blender peculiarity here. A parent may be set on a bone by assigning to its <code class="literal">parent</code> attribute. If it has no parent, this attribute will return <code class="literal">None</code>. We cannot <em>assign</em> <code class="literal">None</code> to this attribute <a class="indexterm" id="id242"/>however, we must use the <code class="literal">clearParent()</code> function to remove a parent relationship.</p><div><img alt="Get a bit of backbone boy!" src="img/0400-03-16.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Materials</h1></div></div></div><a class="indexterm" id="id243"/><p>Materials are what give an object its outward appearance. In Blender, materials are extremely versatile and because of that rather complex. Almost any aspect of the way light behaves when reflecting from an object may be controlled and that not only by simple parameters, but by image maps and node networks as well.</p><p>Up to 16 materials can be associated with an object and, within an object, individual parts can refer to one of these 16 materials. In <code class="literal">Text3d</code> objects, each individual character may refer to a different material and in curves this is true for each control point.</p><p>From a developer's point of view, assigning materials to objects is a two-step process. First, we have to define a new material, and then we have to assign a material or materials to an object. The first step may be omitted if we can refer to already existing materials.</p><p>If an object like a mesh already has faces defined we then still have to assign a material to each face. Newly created faces will have the active material assigned if the active material is defined.</p><p>A small code snippet illustrates how we can assign materials to a <code class="literal">Mesh</code> object. <a class="indexterm" id="id244"/>Here we assign a material with a white diffuse color to all even numbered faces and one with a black diffuse color to all odd numbered faces in a <code class="literal">Mesh</code> object referred to as <code class="literal">ob</code>.</p><div><pre class="programlisting">me=ob.getData(mesh=1)

mats=[ Blender.Material.New(), Blender.Material.New()]
mats[0].rgbCol=[1.0,1.0,1.0]
mats[1].rgbCol=[0.0,0.0,0.0]
   
ob.setMaterials(mats)
<strong>ob.colbits=3</strong>

for f in me.faces:
   if f.index%2 == 0 :
      f.mat=0
   else:
      f.mat=1</pre></div><p>The highlighted line makes sure that the material indices used in each face refer to the materials assigned to the object. (It is also possible to associate materials with the mesh data as we will see in the next section.)</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Object materials versus ObData materials</h2></div></div></div><a class="indexterm" id="id245"/><p>In Blender, both a <code class="literal">Mesh</code> object and the top-level Blender object containing the <code class="literal">Mesh</code> object may have their own list of 16 materials. This is convenient if we would want to instance many copies of the same mesh but with different materials applied. However, in some situations we might want to apply some or all of the materials to the <code class="literal">Mesh</code> instead of to the object. This is controlled by the <code class="literal">colbits</code> attribute of the object. This attribute consists of 16 bits, each bit indicating whether to use the material from the Object or that from the <code class="literal">Mesh</code>. We saw an example of that already in the previous section.</p><p>A <code class="literal">Curve</code> object may also have its own set of materials, and selecting the actual material obeys the same rules as for a <code class="literal">Mesh</code> object. Metaballs do have their own set of materials as well and switching between the sets of materials is effected in the same way, but unlike many types of objects that consist of parts (see next section) there is no way to associate different materials with different elements within a Metaball (this is true in the GUI as well: the buttons in the Links and Materials of the Edit context exist to assign material indices to individual metaball elements but they have no effect). Just the first slot of the list of materials is used.</p><p>Note that objects that are not rendered themselves, such as armatures and lattices, have no associated materials (that is, any materials associated with the top-level Object containing the armature or lattice is ignored). Some objects that do not have associated materials may have textures associated to them. The <code class="literal">World</code> and <code class="literal">Lamp</code> objects for example may have associated textures to control their colors.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Assigning materials to parts of an Object</h2></div></div></div><a class="indexterm" id="id246"/><p>Within a mesh each face may have its own associated material. This material is identified by its index into the list of materials and stored in the <code class="literal">mat</code> attribute. Within a <code class="literal">Text3d</code> object, each character may have its own material, again identified by its index into the list of materials. This time, this index is not stored directly in an attribute but may be set or retrieved by <code class="literal">accessor</code> methods that take the index of the character in the text as argument.</p><p>Sections within a <code class="literal">Curve</code> (<code class="literal">CurNurb</code> objects) may be assigned a material index by their <code class="literal">setMatIndex()</code> method. <a class="indexterm" id="id247"/>The index might be retrieved from it by the corresponding <code class="literal">getMatIndex()</code> method.<a class="indexterm" id="id248"/> Note that associating materials with curves that consist of a single line without an extrusion width set or a bevel object associated will have no visible effects as these curves are not rendered.</p><p>The following snippet shows how to assign different materials to different characters within a <code class="literal">Text3d</code> object. The code itself is straightforward but as you may notice we define a list of three materials but use only one. This is wasteful but necessary to work around a peculiarity in <code class="literal">setMaterial()</code>. Its material index argument should be offset by one, for example, index 2 refers to the second material in the list, however, the largest index may pass is not offset by one. So if we would like to use two materials, we would have to use indices 1 and 2 to access materials 0 and 1, but the actual list of materials should contain three materials, otherwise we can't pass 2 as an argument to <code class="literal">setMaterial()</code>.</p><div><pre class="programlisting">mats=[Material.New(),Material.New(),Material.New()]
mats[0].rgbCol=[1.0,1.0,1.0]
mats[1].rgbCol=[0.0,0.0,0.0]
mats[2].rgbCol=[1.0,0.0,0.0]
ob.setMaterials(mats)
ob.colbits=3
txt=ob.getData()

for i in range(len(txt.getText())):
 <strong>  txt.setMaterial(i,1+i%2)</strong>
</pre></div><p>The highlighted code shows the correction by <code class="literal">1</code>. The full code is provided as <code class="literal">TextColors.py</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Vertex colors versus face materials</h2></div></div></div><a class="indexterm" id="id249"/><p>One important aspect of dealing with materials that we have not dealt with so far is <strong>vertex</strong> <strong>colors</strong>. In meshes, each vertex may have its own vertex color. A vertex color is distinct from a material, but whether vertex colors have any visible effect is controlled by a material's mode flags. For a material to use any vertex colors its <code class="literal">VColPaint</code> bit should be set by calling its <code class="literal">setMode()</code> method.<a class="indexterm" id="id250"/> When used this way, vertex colors determine the diffuse color of a material while all the materials' regular attributes control the way this diffuse color is rendered. A common use for vertex colors is to <em>bake</em> computationally expensive effects such as ambient occlusion. Since vertex colors can be rendered very quickly, ambient occlusion might be approximated this way even in real-time setups such as in the game engine. (Approximated because it will not respond in the same way to changes in lighting.)</p><p>Vertex colors are stored as <code class="literal">Mesh</code>, <code class="literal">MCol</code> objects (basically RGBA tuples) in the <code class="literal">col</code> attribute of a face. The <code class="literal">col</code> attribute is a list containing a reference to an <code class="literal">MCol</code> object for each vertex in the face. This arrangement makes sense when you consider the fact that materials are associated with faces, not with vertices. When the vertex colors of vertices are different they are linearly interpolated across the face.</p><p>It is only possible to assign to the <code class="literal">col</code> attribute of a face if the mesh has its <code class="literal">vertexColors</code> attribute set to <code class="literal">True</code>.</p><p>The following example snippet shows how we might set the vertex colors of a mesh. We choose shades of gray depending on the z-coordinate of the vertices (highlighted).</p><div><pre class="programlisting">import Blender
ob=Blender.Scene.getCurrent().objects.active
me=ob.getData(mesh=1)

me.vertexColors=True
for f in me.faces:
   for i,v in enumerate(f.verts):
      <strong>g = int(max(0.0,min(1.0,v.co.z))*255)</strong>
      f.col[i].r=g
      f.col[i].g=g
      f.col[i].b=g

mats=[Blender.Material.New()]
mats[0].setMode(Blender.Material.Modes['VCOL_PAINT'])
ob.setMaterials(mats)
ob.colbits=1
ob.makeDisplayList()
      
Blender.Window.RedrawAll()</pre></div><a class="indexterm" id="id251"/><p>The full code is available as <code class="literal">VertexColors.py</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Adding materials to our engraving</h2></div></div></div><a class="indexterm" id="id252"/><p>As a finishing touch to our engraving activities we will add two materials. One material index is assigned to the vertices on the surface and another one to the vertices in the chiseled grooves. This way we can, for instance, create the appearance of newly created lettering in a slab of weathered stone.</p><p>As we have earlier defined some convenient vertex groups, assigning material indices is a matter of iterating over all faces and assigning to each vertex of a face the appropriate material index depending on which vertex group a vertex is a member of. The function shown below takes a slightly more general approach as it takes a mesh and a list of regular expressions and assigns a material index to each face depending on whether it belongs to a vertex group that has a name that matches one of the regular expressions.</p><p>This functions makes it very easy to assign the same material index to all vertex groups that have similar names, for example all tail and thorax segments of the mesh created by <code class="literal">creepycrawlies.py</code> (these all have names such as <code class="literal">tail.0</code>, <code class="literal">tail.1</code>, …, and so on).</p><p>The function is available in <code class="literal">Tools.py</code>. <a class="indexterm" id="id253"/>It depends on Python's <code class="literal">re.search()</code> function that will match a regular expression against a string. The highlighted line shows that we embed the regular string in so-called anchors (<code class="literal">^</code> and <code class="literal">$</code>). This way a regular expression such as <code class="literal">aaaa</code> will match only a vertex group with the name <code class="literal">aaaa</code> and not one with the name <code class="literal">aaaa.0</code> so we can distinguish between them if we want. If we want to match all vertex group names that start with <code class="literal">tail</code>, we could pass the regular expression <code class="literal">tail.*</code> for example.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Regular expressions are an extremely powerful way to match strings. If you are unfamiliar with them you should consult the documentation of the Python module (<a class="ulink" href="http://docs.python.org/library/re.html">http://docs.python.org/library/re.html</a>). Start with a gentler tutorial, for example, <a class="ulink" href="http://docs.python.org/howto/regex.html">http://docs.python.org/howto/regex.html</a>.</p></div></div><a class="indexterm" id="id254"/><p>Another thing to note in this function is the way we use set operations. These speed up things quite a bit as the Python set operations are extremely fast. We use them here to check efficiently whether the set of vertices (or rather their indices) that comprises a face are all in the set of vertex indices that are in some vertex group. We compute, in advance, both the sets of vertex indices that belong to a vertex group and the sets of vertex indices of each face and store them in dictionaries for easy access. In this way, we create those sets only once for each vertex group and each face respectively instead of recreating each set every time we match against a regular expression. For large meshes, this saves potentially a lot of time (at the expense of storage).</p><div><pre class="programlisting">import re

def matindex2vertgroups(me,matgroups):
   if len(matgroups)&gt;16 :
      raise ArgumentError("number of groups larger than number ofmaterials possible (16)")
   
   groupnames = me.getVertGroupNames()
   
   vertexgroupset={}
   for name in groupnames:
      vertexgroupset[name]=set(me.getVertsFromGroup(name))
      print name,len(vertexgroupset[name])
   
   faceset={}
   for f in me.faces:
      faceset[f.index]=set([v.index for v in f.verts])
      
   for i,matgroup in enumerate(matgroups):
      for name in groupnames:
 <strong>        if re.search('^'+matgroup+'$',name):</strong>
            for f,vset in faceset.items():
               if vset.issubset(vertexgroupset[name]) :
                  me.faces[f].mat = i
            break</pre></div><div><img alt="Adding materials to our engraving" src="img/0400-03-17.jpg"/></div><a class="indexterm" id="id255"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we saw how to make life easier for our end users by defining vertex groups in meshes to aid in an easy selection of certain features. We also saw how to assign materials to vertices and how to create new materials if needed. First steps were taken to rig a mesh. Specifically, we learned:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to define vertex groups</li><li class="listitem" style="list-style-type: disc">How to assign vertices to a vertex group</li><li class="listitem" style="list-style-type: disc">How to assign materials to faces</li><li class="listitem" style="list-style-type: disc">How to assign vertex colors to vertices</li><li class="listitem" style="list-style-type: disc">How to set edge properties</li><li class="listitem" style="list-style-type: disc">How to add modifiers</li><li class="listitem" style="list-style-type: disc">How to skin bones</li></ul></div><p>Next up we go beyond static objects and see how to control the movement of objects.</p></div></body></html>