- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Securing Your Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的服务
- en: 'So far in this book, all the interactions between services were done without
    any form of authentication or authorization; each HTTP request would happily return
    a result. This cannot happen in production for two simple reasons: we need to
    know who is calling the service (authentication), and we need to make sure that
    the caller is allowed to perform the call (authorization). For instance, we probably
    don''t want an anonymous caller to delete entries in a database.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这本书中所有服务之间的交互都没有进行任何形式的身份验证或授权；每个HTTP请求都会愉快地返回结果。但在实际生产中，这不可能发生，有两个简单的原因：我们需要知道谁在调用服务（身份验证），并且我们需要确保调用者有权执行调用（授权）。例如，我们可能不希望匿名调用者删除数据库中的条目。
- en: In a monolithic web application, simple authentication can happen with a login
    form, and once the user is identified a cookie is set with a session identifier
    so that the client and server can collaborate on all subsequent requests. In a
    microservice-based architecture, we cannot use this scheme everywhere because
    services are not users and won't use web forms for authentication. We need a way
    to accept or reject calls between services automatically.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体Web应用程序中，简单的身份验证可以通过登录表单实现，一旦用户被识别，就会设置一个带有会话标识符的cookie，以便客户端和服务器可以在所有后续请求上协作。在基于微服务的架构中，我们不能在所有地方使用这种方案，因为服务不是用户，也不会使用Web表单进行身份验证。我们需要一种自动接受或拒绝服务之间调用的方式。
- en: The OAuth2 authorization protocol gives us the flexibility to add authentication
    and authorization in our microservices, which can be used to authenticate both
    users and services. In this chapter, we will discover the essential features of
    OAuth2 and how to implement an authentication microservice. This service will
    be used to secure service-to-service interactions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2授权协议为我们提供了在微服务中添加身份验证和授权的灵活性，这可以用来验证用户和服务。在本章中，我们将了解OAuth2的基本特性和如何实现一个身份验证微服务。这个服务将被用来保护服务之间的交互。
- en: A few things can be done at the code level to protect your services, such as
    controlling system calls, or making sure HTTP redirects are not ending up on hostile
    web pages. We will discuss how to add protection against badly formed data, some
    common pitfalls to avoid, and demonstrate how you can scan your code against potential
    security issues.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码层面可以做一些事情来保护你的服务，例如控制系统调用，或者确保HTTP重定向不会结束在敌对网页上。我们将讨论如何添加对不良格式数据的保护，一些常见的陷阱以及如何扫描你的代码以发现潜在的安全问题。
- en: Lastly, securing services also means we want to filter out any suspicious or
    malicious network traffic before it reaches our application. We will look at setting
    up a basic web application firewall to defend our services.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，保护服务还意味着我们希望在恶意网络流量到达我们的应用程序之前将其过滤掉。我们将探讨设置基本Web应用程序防火墙来保护我们的服务。
- en: The OAuth2 protocol
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth2协议
- en: If you are reading this book, you are in all likelihood someone who has logged
    in to a web page with a username and password. It's a straightforward model to
    confirm who you are, but there are drawbacks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，你很可能是那些使用用户名和密码登录网页的人。这是一个简单的模型来确认你是谁，但也有一些缺点。
- en: Many different websites exist, and each needs to properly handle someone's identity
    and password. The potential for security leaks multiplies with the number of different
    places an identity is stored, and how many routes a password can take through
    the different systems involved. It also becomes easier for attackers to create
    fake sites, as people become used to entering their username and password in multiple
    different places that may all look slightly different. Instead, you have probably
    come across websites that let you "Login with Google," Microsoft, Facebook, or
    GitHub. This feature uses OAuth2, or tools built on top of it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多不同的网站存在，每个网站都需要妥善处理某人的身份和密码。随着存储身份的地方增多，以及密码可以通过不同系统采取的路径增多，安全漏洞的可能性也会增加。这也使得攻击者更容易创建假冒网站，因为人们习惯于在多个可能略有不同的地方输入他们的用户名和密码。相反，你可能遇到过允许你“使用Google”、“Microsoft”、“Facebook”或“GitHub”登录的网站。这个功能使用了OAuth2，或者基于它的工具。
- en: OAuth2 is a standard that is widely adopted for securing web applications and
    their interactions with users and other web applications. Only one service ever
    gets told your password or multi-factor authentication codes, and any site that
    needs to authenticate you directs you there. There are two types of authentication
    that we will cover here, the first being the Authentication Code Grant, which
    is initiated by a human using a browser or mobile app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2是一个广泛采用的标准，用于保护Web应用程序及其与用户和其他Web应用程序的交互。只有一个服务会被告知你的密码或多因素认证码，任何需要认证你的网站都会将你引导到那里。在这里我们将介绍两种认证类型，第一种是认证代码授权，它是由人类使用浏览器或移动应用程序发起的。
- en: The process for a user-driven Authentication Code Grant looks complicated as
    it is depicted in *Figure 7.1*, but it serves an important purpose. Following
    the figure through, when a client requests a resource—whether it is a web page
    or some data, say—that they must log in to view, the application sends a `302`
    redirection to visit the authentication service. In that URL will be another address
    that the authentication service can use to send the client back to the application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用户驱动的认证代码授权流程看起来很复杂，如*图7.1*所示，但它发挥着重要的作用。按照图中的流程进行，当客户端请求一个资源——无论是网页还是某些数据，例如——他们必须登录才能查看时，应用程序会将`302`重定向发送到认证服务。在那个URL中会有另一个地址，认证服务可以使用它将客户端送回应用程序。
- en: Once the client connects, the authentication service does the things you might
    expect—it asks for a username, password, and multi-factor authentication codes,
    and some may even display a picture or some text to demonstrate that you are visiting
    the right place. After logging in correctly, the authentication service redirects the
    client back to the application, this time with a token to present.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端连接，认证服务就会执行你可能预期的事情——它会要求用户名、密码和多重因素认证码，有些人甚至还会显示图片或文本来证明你访问的是正确的位置。登录正确后，认证服务将客户端重定向回应用程序，这次带有用于展示的令牌。
- en: The application can validate the token with the authentication service, and
    can remember that result until the token expires, or for some other configurable
    length of time, occasionally rechecking it to check that the token hasn't been
    revoked. This way the application never has to deal with a username or password,
    and only has to learn enough to uniquely identify the client.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用认证服务验证令牌，并记住该结果直到令牌过期，或者对于某些可配置的时间长度，偶尔重新检查以确保令牌没有被撤销。这样，应用程序就永远不需要处理用户名或密码，只需要学习足够的信息来唯一标识客户端。
- en: '![](img/B17108_07_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17108_07_01.png)'
- en: 'Figure 7.1: The OAuth2 authentication flow'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：OAuth2认证流程
- en: 'When setting up OAuth2 for a program to use, so that one service can connect
    to another, there is a similar process called **Client Credentials Grant** (**CCG**)
    in which a service can connect to the authentication microservice and ask for
    a token that it can use. You can refer to the CCG scenario described in *section
    4.4* of the OAuth2 Authorization Framework for more information: [https://tools.ietf.org/html/rfc6749#section-4.4](https://tools.ietf.org/html/rfc6749#section-4.4).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当为程序设置OAuth2以便使用，使一个服务能够连接到另一个服务时，有一个类似的过程称为**客户端凭证授权**（**CCG**），其中服务可以连接到认证微服务并请求一个它可以使用的令牌。你可以参考OAuth2授权框架中*第4.4节*描述的CCG场景以获取更多信息：[https://tools.ietf.org/html/rfc6749#section-4.4](https://tools.ietf.org/html/rfc6749#section-4.4)。
- en: This works like the authorization code, but the service is not redirected to
    a web page as a user is. Instead, it's implicitly authorized with a secret key
    that can be traded for a token.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这与授权代码的工作方式类似，但服务不会像用户一样重定向到网页。相反，它通过一个可以交换为令牌的秘密密钥隐式授权。
- en: For a microservices-based architecture, using these two types of grants will
    let us centralize every aspect of authentication and authorization of the system.
    Building a microservice that implements part of the OAuth2 protocol to authenticate
    services and keep track of how they interact with each other is a good solution
    to reduce security issues—everything is centralized in a single place.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于微服务的架构，使用这两种类型的授权将使我们能够集中管理系统的每个方面的认证和授权。构建一个实现OAuth2协议一部分的微服务，用于认证服务和跟踪它们之间的交互，是减少安全问题的良好解决方案——所有内容都集中在一个地方。
- en: The CCG flow is by far the most interesting aspect to look at in this chapter,
    because it allows us to secure our microservice interactions independently from
    the users. It also simplifies permission management, since we can issue tokens
    with different scopes depending on the context. The applications are still responsible
    for enforcing what those scopes can and cannot do.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，CCG 流程是迄今为止最有趣的部分，因为它允许我们独立于用户来保护我们的微服务交互。它还简化了权限管理，因为我们可以根据上下文发行具有不同作用域的令牌。应用程序仍然负责执行那些作用域可以做什么和不能做什么的强制措施。
- en: 'If you do not want to implement and maintain the authentication part of your
    application and you can trust a third party to manage this process, then Auth0
    is an excellent commercial solution that provides all the APIs needed for a microservice-based
    application: [https://auth0.com/](https://auth0.com/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想实现和维护应用程序的认证部分，并且可以信任第三方来管理此过程，那么 Auth0 是一个出色的商业解决方案，它为基于微服务的应用程序提供了所有所需的
    API：[https://auth0.com/](https://auth0.com/)。
- en: X.509 certificate-based authentication
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 X.509 证书的认证
- en: The `X.509` standard ([https://datatracker.ietf.org/doc/html/rfc5280](https://datatracker.ietf.org/doc/html/rfc5280))
    is used to secure the web. Every website using TLS—the ones with `https://` URLs—has
    an `X.509` certificate on its web server, and uses it to verify the server's identity
    and set up the encryption the connection will use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`X.509` 标准 ([https://datatracker.ietf.org/doc/html/rfc5280](https://datatracker.ietf.org/doc/html/rfc5280))
    用于保护网络。每个使用 TLS 的网站——即带有 `https://` URL 的网站——在其网络服务器上都有一个 `X.509` 证书，并使用它来验证服务器的身份并设置连接将使用的加密。'
- en: How does a client verify a server's identity when it is presented with such
    a certificate? Each properly issued certificate is cryptographically signed by
    a trusted authority. A **Certificate Authority** (**CA**) will often be the one
    issuing the certificate to you and will be the ultimate organization that browsers
    rely on to know who to trust. When the encrypted connection is being negotiated,
    a client will examine the certificate it's given and check who has signed it.
    If it is a trusted CA and the cryptographic checks are passed, then we can assume
    the certificate represents who it claims to. Sometimes the signer is an intermediary,
    so this step should be repeated until the client reaches a trusted CA.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端面对这样的证书时，它是如何验证服务器身份的？每个正确发行的证书都是由受信任的机构进行加密签名的。**证书颁发机构**（**CA**）通常会向您颁发证书，并且是浏览器依赖的最终组织，以了解可以信任谁。当加密连接正在协商时，客户端将检查它所获得的证书，并检查谁签发了它。如果它是一个受信任的
    CA 并且加密检查通过，那么我们可以假设该证书代表它所声称的。有时签发者是一个中间机构，因此此步骤应重复进行，直到客户端达到一个受信任的 CA。
- en: It is possible to create a self-signed certificate, and this can be useful in
    test suites or for local development environments—although it is the digital equivalent
    of saying, "trust me, because I said so." A production service should not use
    self-signed certificates, and if the browser issues a warning, the human sitting
    in front of it will be right to be wary of the site they're accessing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一个自签名证书，这在测试套件或本地开发环境中可能很有用——尽管这在数字上等同于说，“相信我，因为我这么说。”生产服务不应使用自签名证书，如果浏览器发出警告，坐在它前面的人有理由对访问的网站保持警惕。
- en: Obtaining a good certificate is significantly easier than it used to be, thanks
    to Let's Encrypt ([https://letsencrypt.org/](https://letsencrypt.org/)). Organizations
    that charge money for a certificate still offer value—there are features such
    as Extended Validation that aren't easily automated, and sometimes that extra
    display in the browser, often as a green padlock in the address bar, is worth
    it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个好的证书比以前容易得多，这要归功于 Let's Encrypt ([https://letsencrypt.org/](https://letsencrypt.org/))。仍然收取证书费用的组织仍然提供价值——例如，扩展验证等特性不容易自动化，有时浏览器中的额外显示（通常在地址栏中的绿色锁形图标）也是值得的。
- en: 'Let us generate a certificate using Let''s Encrypt, and use some command-line
    tools to examine it. On the Let''s Encrypt website there are instructions to install
    a utility called `certbot`. The instructions will vary slightly depending on the
    platform being used, so we won''t include them here. Once `certbot` is installed,
    obtaining a certificate for a web server such as `nginx` is simple:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Let's Encrypt 生成一个证书，并使用一些命令行工具来检查它。在 Let's Encrypt 网站上有安装名为 `certbot`
    的实用程序的说明。根据所使用的平台，说明可能会有所不同，因此我们在这里不包括它们。一旦安装了 `certbot`，为 `nginx` 等网络服务器获取证书就变得简单：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use the OpenSSL toolkit to examine our certificate, both by looking at
    the file and by sending a query to the web server. Examining the certificate will
    provide a lot of information, although the important pieces for us include the
    sections on **Validity** and **Subject**. A certificate expiring without being
    renewed is a common error condition when running a service; `certbot` includes
    helpers to automatically refresh certificates that are about to expire, and so
    if we use the provided tools, this should not be a problem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用OpenSSL工具包来检查我们的证书，无论是通过查看文件还是通过向Web服务器发送查询。检查证书将提供大量信息，尽管对我们来说，重要的部分包括**有效期**和**主题**部分。服务运行时证书未续期而过期是一个常见的错误条件；`certbot`包括帮助程序，可以自动刷新即将到期的证书，因此如果我们使用提供的工具，这应该不会成为问题。
- en: A certificate subject describes the entity that the certificate has been created
    for, and in this instance, that is a hostname. The certificate presented here
    has a subject **Common Name** (**CN**) of `certbot-test.mydomain.org`, but if
    that's not the hostname we are using then the clients connecting to our service
    will rightfully complain.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 证书主题描述了证书是为哪个实体创建的，在这个例子中，是一个主机名。这里展示的证书的主题**通用名称**（**CN**）为`certbot-test.mydomain.org`，但如果这不是我们使用的主机名，那么连接到我们服务的客户端将有权抱怨。
- en: 'In order to examine a certificate''s details, including the subject, we can
    use the `openssl` utility to display the certificate:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查证书的详细信息，包括主题，我们可以使用`openssl`实用程序来显示证书：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is also possible to connect to a running web server using the `openssl`
    utility, which may be useful to confirm that the correct certificate is being
    used, to run monitoring scripts for certificates that will soon expire, or for
    other such diagnostics. Using the `nginx` instance we configured above, we can
    establish an encrypted session over which we can send HTTP commands:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`openssl`实用程序连接到正在运行的Web服务器，这可能有助于确认正在使用正确的证书，运行即将到期的证书的监控脚本，或其他类似的诊断。使用我们上面配置的`nginx`实例，我们可以建立一个加密会话，通过这个会话我们可以发送HTTP命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can easily read the public certificate in this exchange, and confirm it is
    the one we are expecting the server to use, from its configuration file. We can
    also discover which encryption suites have been negotiated between the client
    and server, and identify any that might be a cause of problems if older client
    libraries or web browsers are being used.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地读取这个交换中的公共证书，并确认这是我们期望服务器从其配置文件中使用的证书。我们还可以发现客户端和服务器之间协商了哪些加密套件，并识别出任何可能成为问题的套件，如果正在使用较旧的客户端库或Web浏览器。
- en: So far, we have only discussed the server using certificates to verify its identity
    and to establish a secure connection. It is also possible for the client to present
    a certificate to authenticate itself. The certificate would allow our application
    to verify that the client is who they claim to be, but we should be careful, as
    it does not automatically mean that the client is allowed to do something—that
    control still lies with our own application. Managing these certificates, setting
    up a CA to issue the appropriate certificates for clients, and how to properly
    distribute the files, are beyond the scope of this book. If it is the right choice
    for an application you are creating, a good place to start is the `nginx` documentation
    at [http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_verify_client](http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_verify_client).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了服务器使用证书来验证其身份并建立安全连接的情况。客户端也可以出示证书来验证自身。证书将允许我们的应用程序验证客户端是否是他们声称的身份，但我们应该小心，因为这并不意味着客户端被允许做某事——这种控制仍然掌握在我们自己的应用程序手中。管理这些证书、设置CA以向客户端颁发适当的证书以及如何正确分发文件，这些都超出了本书的范围。如果您正在创建的应用程序选择这样做，一个好的起点是查看`nginx`文档中的[http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_verify_client](http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_verify_client)。
- en: Let's take a look at authenticating clients that use our services, and how we
    can set up a microservice dedicated to validating client access.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何验证使用我们服务的客户端，以及我们如何设置一个专门用于验证客户端访问的微服务。
- en: Token-based authentication
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的认证
- en: As we said earlier, when one service wants to get access to another without
    any user intervention, we can use a CCG flow. The idea behind CCG is that a service
    can connect to an authentication service and ask for a token that it can then
    use to authenticate against other services.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，当一个服务想要在不进行任何用户干预的情况下访问另一个服务时，我们可以使用 CCG 流。CCG 的理念是，一个服务可以连接到身份验证服务并请求一个令牌，然后它可以使用这个令牌来对其他服务进行身份验证。
- en: Authentication services could issue multiple tokens in systems where different
    sets of permissions are needed, or identities vary.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要不同权限集或身份不同的系统中，身份验证服务可以发行多个令牌。
- en: 'Tokens can hold any information that is useful for the authentication and authorization
    process. Some of these are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌可以包含对身份验证和授权过程有用的任何信息。以下是一些例子：
- en: The `username` or `ID`, if it's pertinent to the context
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果与上下文相关，`username` 或 `ID`
- en: The scope, which indicates what the caller can do (`read`, `write`, and so on)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围，它表示调用者可以做什么（读取、写入等）
- en: A `timestamp` indicating when the token was issued
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示令牌签发时间的 `时间戳`
- en: An expiration `timestamp`, indicating how long the token is valid for
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示令牌有效期的 `过期时间戳`
- en: A token is usually built as a complete proof that you have permission to use
    a service. It is complete because it is possible to validate the token with the
    authentication service without knowing anything else, or having to query an external
    resource. Depending on the implementation, a token can also be used to access
    different microservices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌通常构建为一个完整的证明，表明你有权使用一项服务。它是完整的，因为可以在不知道其他任何信息或无需查询外部资源的情况下，通过身份验证服务验证令牌。根据实现方式，令牌还可以用来访问不同的微服务。
- en: OAuth2 uses the JWT standard for its tokens. There is nothing in OAuth2 that
    requires the use of JWT—it just happens to be a good fit for what OAuth2 wants
    to do.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2 使用 JWT 标准作为其令牌。OAuth2 中没有要求必须使用 JWT 的内容——它只是恰好适合 OAuth2 想要实现的功能。
- en: The JWT standard
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT 标准
- en: 'The **JSON Web Token** (**JWT**) described in RFC 7519 is a standard that is
    commonly used to represent tokens: [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RFC 7519 中描述的 **JSON Web Token**（JWT）是一个常用的标准，用于表示令牌：[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)。
- en: 'A JWT is a long string composed of three dot-separated parts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 是由三个点分隔的长字符串组成：
- en: '**A header**: This provides information on the token, such as which hashing
    algorithm is used'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：它提供了有关令牌的信息，例如使用了哪种哈希算法'
- en: '**A payload**: This is the actual data'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效载荷**：这是实际数据'
- en: '**A signature**: This is a signed hash of the header and payload to verify
    that it is legitimate'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：这是头部和有效载荷的签名哈希，用于验证其合法性'
- en: 'JWTs are Base64-encoded so they can be safely used in query strings. Here''s
    a JWT in its encoded form:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JWTs 是 Base64 编码的，因此它们可以安全地用于查询字符串。以下是一个 JWT 的编码形式：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each part in the token above is separated by a line break for display purposes—the
    original token is a single line. You can experiment with JWT encoding and decoding
    using a utility provided by Auth0 at [https://jwt.io/](https://jwt.io/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌上方的每个部分在显示时通过换行符分隔——原始令牌是一行。你可以使用 Auth0 提供的实用工具来实验 JWT 编码和解码，该实用工具位于 [https://jwt.io/](https://jwt.io/)。
- en: 'If we use Python to decode it, the data is simply in Base64:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 Python 来解码它，数据就是简单的 Base64：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Every part of the JWT is a JSON mapping except the signature. The header usually
    contains just the `typ` and the `alg` keys: the `typ` key says that it is a JWT,
    and the `alg` key indicates which hashing algorithm is used. In the following
    header example, we have `HS256`, which stands for `HMAC-SHA256`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 的每一部分都是一个 JSON 映射，除了签名。头部通常只包含 `typ` 和 `alg` 键：`typ` 键表示这是一个 JWT，而 `alg`
    键指示使用了哪种哈希算法。在下面的头部示例中，我们有 `HS256`，代表 `HMAC-SHA256`：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The payload contains whatever you need, and each field is called a **JWT claim**
    in the RFC 7519 jargon. The RFC has a predefined list of claims that a token may
    contain, called **Registered Claim Names**. Here''s a subset of them:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷包含你需要的内容，每个字段在 RFC 7519 的术语中被称为 **JWT 断言**。RFC 有一个预定义的断言列表，令牌可能包含这些断言，称为
    **注册的断言名称**。以下是一些子集：
- en: '`iss`: This is the issuer, which is the name of the entity that generated the
    token. It''s typically the fully qualified hostname, so the client can use it
    to discover its public keys by requesting `/.well-known/jwks.json`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`：这是发行者，即生成令牌的实体的名称。通常是完全限定的主机名，因此客户端可以使用它通过请求 `/.well-known/jwks.json`
    来发现其公钥。'
- en: '`exp`: This is the expiration time, which is a timestamp after which the token
    is invalid.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp`: 这是过期时间，是一个令牌无效的戳记。'
- en: '`nbf`: This stands for *not before time*, which is a timestamp before which
    the token is invalid.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nbf`: 这代表**不可用之前时间**，是一个令牌无效的戳记。'
- en: '`aud`: This indicates the audience, which is the recipient for whom the token
    was issued.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aud`: 这表示受众，即令牌发行的接收者。'
- en: '`iat`: Stands for *issued at*, which is a timestamp for when the token was
    issued.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`: 代表**发行于**，这是一个表示令牌发行时间的戳记。'
- en: 'In the following payload example, we''re providing the custom `user_id` value
    along with timestamps that make the token valid for the 24 hours after it was
    issued; once valid, that token can be used for 24 hours:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下有效载荷示例中，我们提供了自定义的`user_id`值以及使令牌在发行后24小时内有效的时戳；一旦有效，该令牌可以用于24小时：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These headers give us a lot of flexibility to control how long our tokens will
    stay valid. Depending on the nature of the microservice, the token **Time-To-Live**
    (**TTL**) can be anything from very short to infinite. For instance, a microservice
    that interacts with others within your system should probably rely on tokens that
    are valid for long enough to avoid having to regenerate tokens unnecessarily,
    multiple times. On the other hand, if your tokens are distributed in the wild,
    or if they relate to changing something highly important, it's a good idea to
    make them short-lived.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头部为我们提供了很多灵活性，以控制我们的令牌将保持有效的时间。根据微服务的性质，令牌的**生存时间**（**TTL**）可以是极短到无限。例如，与系统内其他服务交互的微服务可能需要依赖足够长的令牌，以避免不必要地多次重新生成令牌。另一方面，如果你的令牌在野外分发，或者它们与改变高度重要的事情相关，使它们短暂有效是一个好主意。
- en: The last part of a JWT is the signature. It contains a signed hash of the header
    and the payload. There are several algorithms used to sign the hash; some are
    based on a secret key, while others are based on a public and private key pair.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的最后部分是签名。它包含头部和有效载荷的签名哈希。用于签名哈希的算法有几种；一些基于密钥，而另一些基于公钥和私钥对。
- en: PyJWT
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyJWT
- en: 'In Python, the `PyJWT` library provides all the tools you need to generate
    and read back JWTs: [https://pyjwt.readthedocs.io/](https://pyjwt.readthedocs.io/).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`PyJWT`库提供了你生成和读取JWT所需的所有工具：[https://pyjwt.readthedocs.io/](https://pyjwt.readthedocs.io/)。
- en: 'Once you''ve pip-installed `pyjwt` (and `cryptography`), you can use the `encode()`
    and the `decode()` functions to create tokens. In the following example, we''re
    creating a JWT using `HMAC-SHA256` and reading it back. The signature is verified
    when the token is read, by providing the secret:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用pip安装了`pyjwt`（和`cryptography`），你就可以使用`encode()`和`decode()`函数来创建令牌。在以下示例中，我们使用`HMAC-SHA256`创建JWT并读取它。在读取令牌时，通过提供密钥来验证签名：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When executing this code, the token is displayed in both its compressed and
    uncompressed forms. If you use one of the registered claims, `PyJWT` will control
    them. For instance, if the `exp` field is provided and the token is outdated,
    the library will raise an error.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，令牌会以压缩和未压缩两种形式显示。如果你使用已注册的声明之一，`PyJWT`将控制它们。例如，如果提供了`exp`字段且令牌已过期，库将引发错误。
- en: Using a secret for signing and verifying the signature is great when you have
    a few services running, but it can soon become a problem due to it requiring you
    to share the secret among all services that need to verify the signature. So,
    when the secret needs to be changed, it can be a challenge to change it across
    your stack securely. Basing your authentication on a secret that you are sharing
    around is also a weakness. If a single service is compromised and the secret is
    stolen, your whole authentication system is compromised.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密钥进行签名和验证签名在运行少量服务时很好，但很快可能会成为问题，因为它要求你需要在所有需要验证签名的服务之间共享密钥。因此，当需要更改密钥时，在堆栈中安全地更改它可能是一个挑战。基于你共享的密钥进行身份验证也是一种弱点。如果单个服务被破坏且密钥被盗，你的整个身份验证系统都会受到破坏。
- en: A better technique is to use an asymmetric key composed of a public key and
    a private key. The private key is used by the token issuer to sign the tokens,
    and the public key can be utilized by anyone to verify that the signature was
    signed by that issuer. Of course, if an attacker has access to the private key,
    or can convince clients that a forged public key is the legitimate one, you would
    still be in trouble.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的技术是使用由公钥和私钥组成的非对称密钥。私钥由令牌发行者用来签名令牌，而公钥可以被任何人用来验证签名是否由该发行者签名。当然，如果攻击者能够访问私钥，或者能够说服客户端伪造的公钥是合法的，你仍然会遇到麻烦。
- en: But using a public/private key pair does still reduce the attack surface of
    your authentication process, often sufficiently to discourage most attackers;
    and, since the authentication microservice will be the only place that contains
    the private key, you can focus on adding extra security to it. For instance, such
    sensible services are often deployed in a firewalled environment where all access
    is strictly controlled. Let us now see how we can create asymmetric keys in practice.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用公私钥对确实减少了您认证过程的攻击面，通常足以阻止大多数攻击者；并且，由于认证微服务将是唯一包含私钥的地方，您可以专注于增加额外的安全性。例如，这样的明智服务通常部署在防火墙环境中，所有访问都受到严格控制。现在让我们看看我们如何在实践中创建非对称密钥。
- en: Using a certificate with JWT
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JWT证书
- en: To simplify matters for this example, we will use the `letsencrypt` certificates
    we generated for `nginx` earlier on. If you are developing on a laptop or container
    that is not available from the internet, you may need to generate those certificates
    using a cloud instance or a `certbot` DNS plugin and copy them to the right place.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个例子，我们将使用之前为`nginx`生成的`letsencrypt`证书。如果您在笔记本电脑或无法从互联网访问的容器上开发，您可能需要使用云实例或`certbot`
    DNS插件生成这些证书，并将它们复制到正确的位置。
- en: 'If `certbot` generated the certificates directly, they will be available in
    `/etc/letsencrypt/live/your-domain/`. To start with, we are interested in these
    two files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`certbot`直接生成证书，它们将保存在`/etc/letsencrypt/live/your-domain/`。首先，我们关注以下两个文件：
- en: '`cert.pem`, which contains the certificate'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cert.pem`，其中包含证书'
- en: '`privkey.pem`, which has the RSA private key'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`privkey.pem`，其中包含RSA私钥'
- en: 'In order to use these with PyJWT, we need to extract the public key from the
    certificate:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这些与PyJWT，我们需要从证书中提取公钥：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**RSA** stands for **Rivest, Shamir, and Adleman**, the three authors. The
    RSA encryption algorithm generates crypto keys that can go up to 4,096 bytes,
    and are considered secure.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**RSA**代表**Rivest, Shamir, 和 Adleman**，这三位作者。RSA加密算法生成的密钥可以长达4,096字节，被认为是安全的。'
- en: 'From there, we can use `pubkey.pem` and `privkey.pem` in our PyJWT script to
    sign and verify the signature of the token, using the `RSASSA-PKCS1-v1_5` signature
    algorithm and the `SHA-512` hash algorithm:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以在我们的PyJWT脚本中使用`pubkey.pem`和`privkey.pem`来签名和验证令牌的签名，使用`RSASSA-PKCS1-v1_5`签名算法和`SHA-512`哈希算法：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result is similar to the previous run, except that we get a much bigger
    token:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前的运行相似，只是我们得到了一个更大的令牌：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding that much extra data to each request can have consequences for the amount
    of network traffic generated, so the secret-based JWT technique is an option to
    keep in mind if you need to reduce the network overhead.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求中添加如此多的额外数据可能会对产生的网络流量产生影响，因此，基于密钥的JWT技术是一个可以考虑的选项，如果您需要减少网络开销。
- en: The TokenDealer microservice
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TokenDealer微服务
- en: Our first step in building the authentication microservice will be to implement
    everything needed to perform a CCG flow. For that, the app receives requests from
    services that want a token and generates them on demand, assuming the request
    has a known secret in it. The generated tokens will have a lifespan of one day.
    This approach has the most flexibility, without the complexity of generating our
    own `X.509` certificates, while allowing us to have one service responsible for
    generating the tokens.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建认证微服务的第一步，我们将实现执行CCG流程所需的一切。为此，应用程序接收来自需要令牌的服务请求，并在需要时生成它们，假设请求中包含已知的密钥。生成的令牌将有一个一天的寿命。这种方法具有最大的灵活性，没有生成我们自己的`X.509`证书的复杂性，同时允许我们有一个服务负责生成令牌。
- en: This service will be the only service to possess the private key that is used
    to sign the tokens, and will expose the public key for other services that want
    to verify tokens. This service will also be the only place where all the client
    IDs and secret keys are kept.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务将是唯一一个拥有用于签署令牌的私钥的服务，并将公开公钥供其他想要验证令牌的服务使用。这个服务也将是唯一一个保存所有客户端 ID 和密钥的地方。
- en: We will greatly simplify the implementation by stating that once a service gets
    a token, it can access any other service in our ecosystem. When a service is accessed
    with a token, it can verify that token locally or call the TokenDealer to perform
    the verification. The choice between a network request and some CPU usage in the
    microservice will depend on what the application does and where its bottlenecks
    are. When balancing the security and performance requirements it might be necessary
    to validate the token, at most, once every few minutes, rather than every single
    time. This will cause a delay if the token needs to be invalidated, though, so
    we should consult the user stories and, if necessary, discuss the topic with the
    people who will be using the service to see which is most important.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过声明一旦服务获取到令牌，它就可以访问我们生态系统中的任何其他服务来大大简化实现。当服务使用令牌访问时，它可以本地验证该令牌或调用 TokenDealer
    来执行验证。网络请求和微服务中的某些 CPU 使用之间的选择将取决于应用程序做什么以及它的瓶颈在哪里。在平衡安全和性能要求时，可能有必要最多每几分钟验证一次令牌，而不是每次都验证。然而，如果需要使令牌无效，这将会造成延迟，因此我们应该参考用户故事，并在必要时与将使用该服务的人讨论，以确定哪个最重要。
- en: 'To implement everything we''ve described, three endpoints will be created in
    this microservice:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们所描述的，这个微服务将创建三个端点：
- en: '`GET /.well-known/jwks.json`: This is the public key published in the **JSON
    Web Key** (**JWK**) format, as described in RFC 7517, when other microservices
    want to verify tokens on their own. For more information, see the following: [https://tools.ietf.org/html/rfc7517](https://tools.ietf.org/html/rfc7517).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /.well-known/jwks.json`: 当其他微服务想要自行验证令牌时，这是以 RFC 7517 中描述的 **JSON Web
    Key** (**JWK**) 格式发布的公钥。有关更多信息，请参阅以下链接：[https://tools.ietf.org/html/rfc7517](https://tools.ietf.org/html/rfc7517)。'
- en: '`POST /oauth/token`: This endpoint accepts a request with credentials and returns
    a token. Adding the `/oauth` prefix is a widely adopted convention, since it is
    used in the OAuth RFC.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /oauth/token`: 这个端点接受带有凭证的请求并返回一个令牌。添加 `/oauth` 前缀是一个广泛采用的约定，因为它在 OAuth
    RFC 中被使用。'
- en: '`POST /verify_token`: This endpoint returns the token payload, given a token.
    If the token is not valid, it returns an HTTP 400 error code.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /verify_token`: 这个端点在给定一个令牌的情况下返回令牌的有效负载。如果令牌无效，它将返回 HTTP 400 错误代码。'
- en: Using the microservice skeleton, we can create a very simple Quart application
    that implements these three views. The skeleton is available at [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务骨架，我们可以创建一个非常简单的 Quart 应用程序，该应用程序实现了这三个视图。骨架可在[https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/)找到。
- en: Let's look at these three OAuth views.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这三个 OAuth 视图。
- en: The OAuth implementation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth 实现
- en: 'For the CCG flow, the service that wants a token sends a `POST` request with
    a URL-encoded body that contains the following fields:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CCG 流程，需要令牌的服务会发送一个包含以下字段的 URL 编码体的 `POST` 请求：
- en: '`client_id`: This is a unique string identifying the requester.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_id`: 这是一个唯一字符串，用于标识请求者。'
- en: '`client_secret`: This is a secret key that authenticates the requester. It
    should be a random string generated upfront and registered with the auth service.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_secret`: 这是一个用于验证请求者的密钥。它应该是一个预先生成并注册到认证服务的随机字符串。'
- en: '`grant_type`: This is the grant type, which here must be `client_credentials`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grant_type`: 这是授权类型，在这里必须是 `client_credentials`。'
- en: We'll make a few assumptions to simplify the implementation. Firstly, we will
    keep the list of secrets in a Python data structure, for demonstration purposes.
    In a production service, they should be encrypted at rest and kept in a resilient
    data store. We will also assume that `client_id` is the name of the calling microservice,
    and for now we will generate secrets using `binascii.hexlify(os.urandom(16))`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做出一些假设以简化实现。首先，为了演示目的，我们将保持秘密列表在Python数据结构中。在生产服务中，它们应该在静态时加密，并保存在具有弹性的数据存储中。我们还将假设`client_id`是调用微服务的名称，并且现在我们将使用`binascii.hexlify(os.urandom(16))`生成秘密。
- en: The first view will be the one that actually generates the tokens needed by
    the other services. In our example we are reading in the private key each time
    we create a token—this may be better stored in the application configuration for
    a real service, just to reduce the time spent waiting to read a file from the
    disk. We make sure the client has sent us a reasonable request, and that it wants
    some `client_credentials`. The error handling functions and utilities are available
    in the full source code samples for this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个视图将是实际生成其他服务所需令牌的视图。在我们的例子中，我们每次创建令牌时都会读取私钥——对于实际服务来说，最好将其存储在应用程序配置中，以减少从磁盘读取文件所需的时间。我们确保客户端已经向我们发送了一个合理的请求，并且它想要一些`client_credentials`。错误处理函数和实用工具可以在本章的完整源代码示例中找到。
- en: 'The token itself is a data structure with several fields: The issuer (`iss`)
    of the token, commonly the URL of the service; the intended audience (`aud`) for
    the token, that is, who the token is intended for; the time the token was issued
    (`iat`); as well as its expiry (`exp`) time. We then sign this data using the
    `jwt.encode` method and return it to the requesting client:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌本身是一个具有多个字段的复杂数据结构：令牌的发行者（`iss`），通常是服务的URL；令牌的目标受众（`aud`），即令牌的目标对象；令牌签发的时间（`iat`）；以及其过期时间（`exp`）。然后我们使用`jwt.encode`方法对数据进行签名，并将其返回给请求客户端：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next view to add is a function that returns the public keys used by our
    token generation, so that any client can verify the tokens without making further
    HTTP requests. This is often located at a well-known URL—the address literally
    contains the string `.well-known/`, which is a practice encouraged by the IETF
    to provide a way for a client to discover metadata about a service. Here we are
    responding with the JWKS.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要添加的视图是一个返回我们令牌生成所使用的公钥的功能，这样任何客户端都可以验证令牌而无需进行进一步的HTTP请求。这通常位于一个众所周知的URL——地址中实际上包含字符串`.well-known/`，这是IETF鼓励的做法，为客户端提供发现有关服务元数据的方式。在这里，我们响应的是JWKS。
- en: 'In the data returned are the key type (`kty`), the algorithm (`alg`), the public
    key use (`use`)—here a signature—and two values used by the RSA algorithm that
    our cryptographic keys are generated with:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据中包含密钥类型（`kty`）、算法（`alg`）、公钥使用（`use`）——这里是一个签名——以及我们使用RSA算法生成的加密密钥所用的两个值：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final view lets clients verify a token without doing the work themselves.
    Much more straightforward than the token generation, we simply extract the right
    fields from the input data and call the `jwt.decode` function to provide the values.
    Note that this function verifies the token is valid, but not that the token allows
    any particular access — that part is up to the service that has been presented
    with the token:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个视图允许客户端验证令牌而无需自己进行工作。与令牌生成相比，这要简单得多，我们只需从输入数据中提取正确的字段，并调用`jwt.decode`函数来提供值。请注意，此函数验证令牌是否有效，但并不验证令牌是否允许任何特定的访问——这部分取决于已经向其展示令牌的服务：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The whole source code of the TokenDealer microservice can be found on GitHub:
    [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: TokenDealer微服务的全部源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition).
- en: The microservice could offer more features around token generation. For instance,
    the ability to manage scopes and make sure microservice A is not allowed to generate
    a token that can be used in microservice B, or managing a whitelist of services
    that are authorized to ask for some tokens. A client could also request a token
    that is intended for read-only use. Despite this, however, the pattern we have
    implemented is the basis for a simple token-based authentication system in a microservice
    environment that you can develop on your own, while also being good enough for
    our Jeeves app.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以提供更多关于令牌生成的功能。例如，管理作用域并确保微服务A不允许生成在微服务B中使用的令牌，或者管理一个授权请求某些令牌的服务白名单。客户端还可以请求一个仅用于只读用途的令牌。然而，尽管如此，我们已实现的模式是微服务环境中简单基于令牌的认证系统的基石，您可以在自己的基础上进行开发，同时它也足够好，适用于我们的Jeeves应用。
- en: 'Looking back at our example microservice, TokenDealer now sits as a separate
    microservice in the ecosystem, creating and verifying keys that allow access to
    our data service, and authorizing access to the third-party tokens and API keys
    we need to query other sites:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的示例微服务，TokenDealer现在作为生态系统中的一个独立微服务存在，创建和验证允许访问我们的数据服务的密钥，并授权访问我们查询其他网站所需的第三方令牌和API密钥：
- en: '![](img/B17108_07_02.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17108_07_02.png](img/B17108_07_02.png)'
- en: 'Figure 7.2: The microservice ecosystem with the CCG TokenDealer'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：带有CCG TokenDealer的微服务生态系统
- en: Those services that require a JWT may validate it by calling the TokenDealer
    microservice. The Quart app in *Figure 7.2* needs to obtain tokens from TokenDealer
    on behalf of its users.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那些需要JWT的服务可以通过调用TokenDealer微服务来验证它。*图7.2*中的Quart应用需要代表其用户从TokenDealer获取令牌。
- en: Now that we have a TokenDealer service that implements CCG, let us see how it
    can be used by our services in the next section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个实现了CCG的TokenDealer服务，让我们看看它如何在下一节中由我们的服务使用。
- en: Using TokenDealer
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TokenDealer
- en: 'In Jeeves, the **Data Service** is a good example of a place where authentication
    is required. Adding information via the **Data Service** needs to be restricted
    to authorized services:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jeeves中，**数据服务**是一个需要认证的好例子。通过**数据服务**添加信息需要限制在授权的服务范围内：
- en: '![image1.png](img/B17108_07_03.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image1.png](img/B17108_07_03.png)'
- en: 'Figure 7.3: Requesting a CCG workflow'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：请求CCG工作流
- en: 'Adding authentication for that link is done in four steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为该链接添加认证分为四个步骤：
- en: '**TokenDealer** manages a `client_id` and `client_secret` pair for the Strava
    worker and shares it with the Strava worker developers'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TokenDealer**为Strava工作者管理一个`client_id`和`client_secret`对，并与Strava工作者开发者共享'
- en: The Strava worker uses `client_id` and `client_secret` to retrieve a token from
    **TokenDealer**
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Strava工作者使用`client_id`和`client_secret`从**TokenDealer**检索令牌
- en: The worker adds the token to the header for each request to the **Data Service**
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作者将令牌添加到每个请求到**数据服务**的头部
- en: The **Data Service** verifies the token by calling the verification API of **TokenDealer**
    or by performing a local **JWT** verification
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据服务**通过调用**TokenDealer**的验证API或执行本地**JWT**验证来验证令牌'
- en: In a full implementation, the first step can be partially automated. Generating
    a client secret is usually done through a web administration panel in the authentication
    service. That secret is then provided to the client microservice developers. Each
    microservice that requires a token can now get one, whether it is the first time
    connecting, or because the tokens it has already obtained have expired. All they
    need to do to use it is add that token to the Authorization header when calling
    the Data Service.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在完整实现中，第一步可以部分自动化。生成客户端密钥通常是通过认证服务的Web管理面板完成的。然后，该密钥提供给客户端微服务开发者。现在，每个需要令牌的微服务都可以获取一个，无论是首次连接，还是因为它们已经获得的令牌已过期。他们要做的只是在使用时将令牌添加到调用数据服务的授权头中。
- en: 'The following is an example of such a call using the `requests` library—assuming
    our TokenDealer is already running on `localhost:5000`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`requests`库进行此类调用的示例——假设我们的TokenDealer已经在`localhost:5000`上运行：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `get_token()` function retrieves a token that can then be used in the Authorization
    header when the code calls the Data Service, which we assume is listening on port
    `5001` for this example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_token()` 函数检索一个令牌，该令牌随后可以在代码调用数据服务时用于授权头，我们假设数据服务在本例中监听端口 `5001`：'
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `call_data_service()` function will try to get a new token if the call to
    the Data Service leads to a 401 response. This refresh-token-on-401 pattern can
    be used in all your microservices to automate token generation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_data_service()` 函数会在调用数据服务并返回401响应时尝试获取新的令牌。这种在401响应上刷新令牌的模式可以用于你所有的微服务来自动化令牌生成。'
- en: This covers service-to-service authentication. You can find the full implementation
    in the example GitHub repository to play with this JWT-based authentication scheme
    and use it as a basis for building your authentication process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括服务间的身份验证。你可以在示例GitHub仓库中找到完整的实现，以尝试基于JWT的身份验证方案，并将其作为构建你的身份验证过程的基础。
- en: The next section looks at another important aspect of securing your web services,
    and that is securing the code itself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将探讨保护你的网络服务的重要方面之一，即保护代码本身。
- en: Securing your code
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的代码
- en: Whatever we do, an application must receive data and act on it, somehow, or
    it will not be very useful. If a service receives data, then as soon as you expose
    your app to the world, it is open to numerous possible types of attack, and your
    code needs to be designed with this in mind.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们做什么，应用程序都必须接收数据并对其采取行动，否则它将不会非常有用。如果一个服务接收数据，那么一旦你将你的应用程序暴露给世界，它就会面临众多可能的攻击类型，你的代码需要考虑到这一点进行设计。
- en: Anything that is published to the web can be attacked, although we have the
    advantage that most microservices are not exposed to the public internet, which
    reduces the possible ways they could be exploited. The expected inputs and outputs
    of the system are narrower, and often better defined using specification tools,
    such as OpenAPI.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 任何发布到网络上的内容都可能受到攻击，尽管我们有优势，即大多数微服务没有暴露在公共互联网上，这减少了它们可能被利用的方式。系统的预期输入和输出更窄，通常可以使用如OpenAPI之类的规范工具更好地定义。
- en: Attacks are not always due to hostile intent, either. If the caller has a bug
    or is just not calling your service correctly, the expected behavior should be
    to send back a `4xx` response and explain to the client why the request was rejected.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击并不总是由于恶意意图。如果调用者有错误或者只是没有正确调用你的服务，预期的行为应该是发送回一个`4xx`响应，并向客户端解释为什么请求被拒绝。
- en: 'The **Open Web Application Security Project** (**OWASP**) ([https://www.owasp.org](https://www.owasp.org))
    is an excellent resource to learn about ways to protect your web apps from bad
    behaviors. Let''s look at some of the most common forms of attack:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放网络应用安全项目**（**OWASP**）（[https://www.owasp.org](https://www.owasp.org)）是一个学习如何保护你的网络应用程序免受不良行为侵害的优秀资源。让我们看看一些最常见的攻击形式：'
- en: '**Injection**: In an application that receives data, an attacker sends SQL
    statements, shell commands, or some other instructions inside the request. If
    your application is not careful about how it uses that data, you can end up running
    code that is meant to damage your application. In Python, SQL injection attacks
    can be avoided by using SQLAlchemy, which constructs the SQL statements for you
    in a safe way. If you do use SQL directly, or provide arguments to shell scripts,
    LDAP servers, or some other structured query, you must make sure that every variable
    is quoted correctly.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注入**：在一个接收数据的程序中，攻击者通过请求发送SQL语句、shell命令或其他指令。如果你的应用程序在使用这些数据时不够小心，你可能会运行旨在损害应用程序的代码。在Python中，可以通过使用SQLAlchemy来避免SQL注入攻击，它会以安全的方式为你构造SQL语句。如果你直接使用SQL，或者向shell脚本、LDAP服务器或其他结构化查询提供参数，你必须确保每个变量都被正确地引用。'
- en: '**Cross-Site Scripting** (**XSS**): This attack happens only on web pages that
    display some HTML. The attacker uses some of the query attributes to try to inject
    their piece of HTML on the page to trick the user into performing some set of
    actions, thinking they are on the legitimate website.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站脚本**（**XSS**）：这种攻击只发生在显示HTML的网页上。攻击者使用一些查询属性尝试在页面上注入他们的HTML片段，以欺骗用户执行一系列操作，让他们以为自己在合法网站上。'
- en: '**Cross-Site Request Forgery** (**XSRF**/**CSRF**): This attack is based on
    attacking a service by reusing the user''s credentials from another website. The
    typical CSRF attack happens with `POST` requests. For instance, a malicious website
    displays a link to a user to trick that user into performing the `POST` request
    on your site using their existing credentials.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**XSRF**/**CSRF**）：这种攻击基于通过重用用户从另一个网站的用户凭据来攻击服务。典型的CSRF攻击发生在`POST`请求中。例如，一个恶意网站显示一个链接给用户，诱骗该用户使用他们现有的凭据在你的网站上执行`POST`请求。'
- en: Things such as **Local File Inclusion** (**LFI**), **Remote File Inclusion**
    (**RFI**), or **Remote Code Execution** (**RCE**) are all attacks that trick the
    server into executing something via client input, or revealing server files. They
    can happen of course in applications written in most languages and toolkits, but
    we will examine some of Python's tools to protect against these attacks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 像本地文件包含（**LFI**）、远程文件包含（**RFI**）或远程代码执行（**RCE**）这样的攻击都是通过客户端输入欺骗服务器执行某些操作或泄露服务器文件的攻击。当然，这些攻击可能发生在大多数语言和工具包编写的应用程序中，但我们将检查一些Python的工具来防止这些攻击。
- en: 'The idea behind secure code is simple, yet hard to do well in practice. The
    two fundamental principles are:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 安全代码背后的理念简单，但在实践中很难做好。两个基本的原则是：
- en: Every request from the outside world should be carefully assessed before it
    does something in your application and data.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序和数据中执行任何操作之前，都应该仔细评估来自外部世界的每个请求。
- en: Everything your application is doing on a system should have a well-defined
    and limited scope.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序在系统上所做的每一件事都应该有一个明确和有限的作用域。
- en: Let's look at how to implement these principles in practice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在实践中实施这些原则。
- en: Limiting your application scope
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制应用程序的作用域
- en: Even if you trust the authentication system, you should make sure that whoever
    connects has the minimum level of access required to perform their work. If there
    is a client that connects to your microservice and can authenticate themselves,
    that doesn't mean they should be allowed to perform any action. If they only need
    read-only access, then that's all they should be granted.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你信任认证系统，你也应该确保连接的人拥有完成工作所需的最小访问级别。如果有客户端连接到你的微服务并能够进行认证，这并不意味着他们应该被允许执行任何操作。如果他们只需要只读访问，那么他们应该只被授予这一点。
- en: This isn't just protecting against malicious code, but also bugs and accidents.
    Any time you think, "the client should never call this endpoint," then there should
    be something in place that actively prevents the client using it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是保护免受恶意代码的侵害，还包括错误和意外。每次当你认为“客户端永远不应该调用这个端点”时，就应该有某种机制来积极阻止客户端使用它。
- en: That scope limitation can be done with JWTs by defining roles (such as read/write)
    and adding that information in the token under a permissions or scope key, for
    example. The target microservice will then be able to reject a call on a `POST`
    that is made with a token that is supposed to only read data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种作用域限制可以通过JWTs通过定义角色（如读写）并在令牌中添加该信息来实现，例如，在权限或作用域键下。然后目标微服务将能够拒绝使用仅应读取数据的令牌进行的`POST`调用。
- en: This is what happens when you grant access to an application on your GitHub
    account, or on your Android phone. A detailed list of what the app wants to do
    is displayed, and you can grant or reject access.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是当你授予GitHub账户或Android手机上的应用程序访问权限时会发生的情况。会显示应用程序想要执行的操作的详细列表，你可以授予或拒绝访问。
- en: This is in addition to network-level controls and firewalls. If you are controlling
    all parts of your microservices ecosystem, you can also use strict firewall rules
    at the system level to whitelist the IPs that are allowed to interact with each
    microservice, but that kind of setup greatly depends on where you are deploying
    your application. In the **Amazon Web Services** (**AWS**) cloud environment,
    you don't need to configure a Linux firewall; all you have to do is set up the
    access rules in the AWS Console. *Chapter 10*, *Deploying on AWS*, covers the
    basics of deploying your microservices on the Amazon cloud.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在网络级控制和防火墙的基础上。如果你控制着微服务生态系统的所有部分，你还可以在系统级别使用严格的防火墙规则来白名单允许与每个微服务交互的IP地址，但这种设置在很大程度上取决于你部署应用程序的位置。在**亚马逊网络服务**（**AWS**）云环境中，你不需要配置Linux防火墙；你只需要在AWS控制台中设置访问规则即可。*第10章*，*在AWS上部署*，涵盖了在亚马逊云上部署微服务的基本知识。
- en: Besides network access, any other resource your application can access should
    be limited whenever possible. Running the application as a root user on Linux
    is not a good idea because if your application has full administrative privileges,
    then so does an attacker who successfully breaks in.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网络访问之外，任何其他应用程序可以访问的资源都应在可能的情况下进行限制。在Linux上以root用户运行应用程序不是一个好主意，因为如果你的应用程序拥有完整的行政权限，那么成功入侵的攻击者也会有。
- en: 'In essence, if a layer of security fails, there should be another behind it.
    If an application''s web server is successfully attacked, any attacker should
    ideally be as limited as possible in what they can do, as they only have access
    to the well-defined interfaces between the services in the application—instead
    of full administrative control over the computer running the code. Root access
    to a system has become an indirect threat in modern deployments, since most applications
    are running in containers or a **Virtual Machine** (**VM**), but a process can
    still do a lot of damage even if its abilities are limited by the VM it is running
    in. If an attacker gains access to one of your VMs, they have achieved the first
    step in getting control over the whole system. To mitigate the problem, there
    are two rules you should follow:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，如果一层安全措施失败，后面应该还有另一层。如果一个应用程序的 web 服务器被成功攻击，任何攻击者理想情况下都应尽可能有限制，因为他们只能访问应用程序中服务之间定义良好的接口——而不是对运行代码的计算机拥有完整的行政控制。在现代部署中，系统根访问已成为一种间接威胁，因为大多数应用程序都在容器或一个
    **虚拟机**（**VM**）中运行，但即使其能力被运行的 VM 限制，一个进程仍然可以造成很多损害。如果攻击者访问到您的其中一个 VM，他们已经实现了控制整个系统的第一步。为了减轻这个问题，您应该遵循以下两条规则：
- en: All software should run with the smallest set of permissions possible
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有软件都应该以尽可能小的权限集运行
- en: Be very cautious when executing processes from your web service, and avoid it
    if you can
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行来自您的网络服务的进程时，要非常谨慎，并在可能的情况下避免
- en: For the first rule, the default behavior for web servers such as `nginx` is
    to run its processes using the `www-data` user and group, so that standard user
    controls prevent the server accessing other files, and the account itself can
    be set up to not be allowed to run a shell or any other interactive commands.
    The same rules apply to your Quart processes. We will see in *Chapter 9*, *Packaging
    and Running Python*, the best practices to run a stack in the user space on a
    Linux system.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一条规则，像 `nginx` 这样的 web 服务器的默认行为是使用 `www-data` 用户和组来运行其进程，这样标准用户控制可以防止服务器访问其他文件，并且账户本身可以设置成不允许运行
    shell 或任何其他交互式命令。同样的规则也适用于您的 Quart 进程。我们将在 *第 9 章*，*打包和运行 Python* 中看到在 Linux 系统上以用户空间运行堆栈的最佳实践。
- en: For the second rule, any Python call to `os.system()` should be avoided unless
    absolutely necessary, as it creates a new user shell on the computer, adding risks
    associated with badly formed commands being run, and increasing the risk of uncontrolled
    access to the system. The `subprocess` module is better, although it, too, must
    be used carefully to avoid unwanted side effects—avoid using the `shell=True`
    argument, which will result in the same trouble as `os.system()`, and avoid using
    input data as arguments and commands. This is also true for high-level network
    modules that send emails or connect to third-party servers via FTP, via the local
    system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二条规则，除非绝对必要，否则应避免使用任何 Python 对 `os.system()` 的调用，因为它在计算机上创建一个新的用户 shell，增加了运行不良命令的风险，并增加了对系统无控制访问的风险。`subprocess`
    模块更好，尽管它也必须谨慎使用以避免不希望的结果——避免使用 `shell=True` 参数，这将导致与 `os.system()` 相同的问题，并避免使用输入数据作为参数和命令。这也适用于发送电子邮件或通过
    FTP 连接到第三方服务器的高级网络模块，通过本地系统。
- en: Untrusted incoming data
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不受信任的传入数据
- en: 'The majority of applications accept data as input: whose account to look up;
    which city to fetch a weather report for; which account to transfer money into,
    and so forth. The trouble is that data that comes from outside our system is not
    easily trusted.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序接受数据作为输入：要查找哪个账户；为哪个城市获取天气预报；要将钱转入哪个账户，等等。问题是来自我们系统之外的数据不容易被信任。
- en: 'Earlier, we discussed SQL injection attacks; let us now consider a very naive
    example, where we use a SQL query to look up a user. We have a function that treats
    the query as a string to be formatted, and fills it in using standard Python syntax:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了 SQL 注入攻击；现在让我们考虑一个非常简单的例子，其中我们使用 SQL 查询来查找用户。我们有一个函数，它将查询视为要格式化的字符串，并使用标准的
    Python 语法填充它：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This looks fine when the `user_id` is always a sensible value. However, what
    if someone presents a carefully crafted malicious value? If we allow people to
    enter data for `get_user()`, above, and instead of entering a number as a `user_id`,
    they enter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `user_id` 总是合理的值时，这看起来是正常的。然而，如果有人提供了一个精心制作的恶意值呢？如果我们允许人们为上面的 `get_user()`
    函数输入数据，并且他们不是输入一个数字作为 `user_id`，而是输入：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now our SQL statement is really two statements:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 SQL 语句实际上是两个语句：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`get_user` will perform the expected query, and a second query that will add
    a new user! It could also delete a table, or perform any other action available
    to SQL statements. Some damage limitation is there if the authenticated client
    has limited permissions, but a large amount of data could still be exposed. This
    scenario can be prevented by quoting any value used to build raw SQL queries.
    In `PyMySQL`, you just need to pass the values as parameters to the `execute`
    argument to avoid this problem:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_user` 将执行预期的查询，以及一个将添加新用户的查询！它还可以删除表，或执行 SQL 语句可用的任何其他操作。如果认证客户端权限有限，则有一些限制措施，但仍然可能暴露大量数据。可以通过引用构建原始
    SQL 查询时使用的任何值来防止这种情况。在 `PyMySQL` 中，您只需将值作为参数传递给 `execute` 参数以避免此问题：'
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Every database library has this feature, so as long as you are correctly using
    these libraries when building raw SQL, you should be fine. Better still is to
    avoid using raw SQL completely, and instead use a database model through SQLAlchemy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库库都有这个功能，所以只要您在构建原始 SQL 时正确使用这些库，就应该没问题。更好的做法是完全避免使用原始 SQL，而是通过 SQLAlchemy
    使用数据库模型。
- en: If you have a view that grabs JSON data from the incoming request and uses it
    to push data to a database, you should verify that the incoming request has the
    data you are expecting, and not blindly pass it over to your database backend.
    That's why it can be interesting to use Swagger to describe your data as schemas,
    and use them to validate incoming data. Microservices usually use JSON, but if
    you happen to use templates to provide formatted output, that's yet another place
    where you need to be careful with respect to what the template is doing with variables.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个视图，它从传入的请求中获取 JSON 数据并将其用于向数据库推送数据，您应该验证传入的请求包含您期望的数据，而不是盲目地将其传递给您的数据库后端。这就是为什么使用
    Swagger 将数据描述为模式并使用它们来验证传入数据可能很有趣。微服务通常使用 JSON，但如果你碰巧使用模板提供格式化输出，那么这也是你需要小心处理模板如何处理变量的另一个地方。
- en: '**Server-Side Template Injection** (**SSTI**) is a possible attack in which
    your templates blindly execute Python statements. In 2016, such an injection vulnerability
    was found on Uber''s website on a Jinja2 template, because raw formatting was
    done before the template was executed. See more at [https://hackerone.com/reports/125980](https://hackerone.com/reports/125980).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器端模板注入**（**SSTI**）是一种可能的攻击，其中您的模板盲目执行 Python 语句。在 2016 年，在 Uber 网站的一个 Jinja2
    模板上发现了一个这样的注入漏洞，因为原始格式化是在模板执行之前完成的。更多信息请参阅[https://hackerone.com/reports/125980](https://hackerone.com/reports/125980)。'
- en: 'The code was something similar to this small app:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码类似于这个小应用程序：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By doing this preformatting on the template with a raw `%` formatting syntax,
    the view creates a huge security hole in the app, since it allows attackers to
    inject what they want into the Jinja script before it is executed. In the following
    example, the `user_id` variable security hole is exploited to read the value of
    the `SECRET` global variable from the module:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在模板中使用原始的 `%` 格式化语法进行预格式化，视图在应用程序中创建了一个巨大的安全漏洞，因为它允许攻击者在 Jinja 脚本执行之前注入他们想要的内容。在下面的示例中，`user_id`
    变量的安全漏洞被利用来从模块中读取 `SECRET` 全局变量的值：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's why it is important to avoid string formatting with input data unless
    there is a template engine or some other layer that provides protection.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么避免使用输入数据进行字符串格式化很重要，除非有模板引擎或其他提供保护的层。
- en: If you need to evaluate untrusted code in a template, you can use Jinja's sandbox;
    refer to [http://jinja.pocoo.org/docs/latest/sandbox/](http://jinja.pocoo.org/docs/latest/sandbox/).
    This sandbox will reject any access to methods and attributes from the object
    being evaluated. For instance, if you're passing a callable in your template,
    you will be sure that its attributes, such as `;__class__`, cannot be used.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在模板中评估不受信任的代码，您可以使用 Jinja 的沙盒；请参阅[http://jinja.pocoo.org/docs/latest/sandbox/](http://jinja.pocoo.org/docs/latest/sandbox/)。这个沙盒将拒绝访问正在评估的对象的方法和属性。例如，如果您在模板中传递一个可调用对象，您将确保其属性，如
    `;__class__`，不能被使用。
- en: That said, Python sandboxes are tricky to get right due to the nature of the
    language. It's easy to misconfigure a sandbox, and the sandbox itself can be compromised
    with a new version of the language. The safest bet is to avoid evaluating untrusted
    code altogether and make sure you're not directly relying on incoming data for
    templates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，由于语言本身的性质，Python沙盒很难配置正确。很容易误配置沙盒，而且沙盒本身也可能因为语言的新版本而被破坏。最安全的做法是完全避免评估不受信任的代码，并确保你不会直接依赖于传入数据用于模板。
- en: Redirecting and trusting queries
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向和信任查询
- en: 'The same precaution applies when dealing with redirects. One common mistake
    is to create a login view that makes the assumption that the caller will be redirected
    to an internal page and use a plain URL for that redirect:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理重定向时，也适用相同的预防措施。一个常见的错误是创建一个登录视图，假设调用者将被重定向到内部页面，并使用一个普通的URL进行重定向：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This view can redirect the caller to any website, which is a significant threat—particularly
    during the login process. Good practice involves avoiding free strings when calling
    `redirect()`, by using the `url_for()` function, which will create a link to your
    app domain. If you need to redirect to third parties, you cannot use the `url_for()`
    and `redirect()` functions, as they can potentially send your clients to unwanted
    places.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图可以将调用者重定向到任何网站，这是一个重大的威胁——尤其是在登录过程中。良好的做法是在调用`redirect()`时避免使用自由字符串，而是使用`url_for()`函数，这将创建一个指向你的应用域的链接。如果你需要重定向到第三方，你不能使用`url_for()`和`redirect()`函数，因为它们可能会将你的客户端发送到不受欢迎的地方。
- en: One solution is to create a restricted list of third-party domains that your
    application is allowed to redirect to and make sure any redirection done by your
    application or underlying third-party libraries is checked against that list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是创建一个受限制的第三方域名列表，你的应用程序允许重定向到这些域名，并确保应用程序或底层第三方库执行的重定向都经过该列表的检查。
- en: 'This can be done with the `after_request()` hook that will be called after
    our views have generated a response, but before Quart has sent it back to the
    client. If the application tries to send back a `302`, you can check that its
    location is safe, given a list of domains and ports:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在视图生成响应后、Quart将响应发送回客户端之前调用的`after_request()`钩子来完成。如果应用程序尝试发送回一个`302`状态码，你可以检查其位置是否安全，给定一个域名和端口号列表：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Sanitizing input data
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洗输入数据
- en: In addition to the other practices for handling untrusted data, we can ensure
    the fields themselves match what we expect. Faced with the examples above, it
    is tempting to think that we should filter out any semicolons, or perhaps all
    the curly braces, but this leaves us in the position of having to think of all
    the ways in which the data could be malformed, and trying to outwit the inventiveness
    of both malicious programmers and also random bugs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理不受信任数据的其他做法之外，我们可以确保字段本身符合我们的预期。面对上述示例，我们可能会想过滤掉任何分号，或者可能所有花括号，但这让我们处于必须考虑数据可能出现的所有错误格式的位置，并试图战胜恶意程序员和随机错误的独创性。
- en: Instead, we should concentrate on what we know about what our data should look
    like—instead of what it should not. This is a much narrower question, and the
    answer can often be much easier to define. As an example, if we know that an endpoint
    accepts an ISBN to look up a book, then we know that we should only expect a series
    of numbers either 10 or 13 digits long, perhaps with dashes as separators. When
    it comes to people, however, data is much harder to clean up.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该专注于我们对我们数据外观的了解——而不是它不应该是什么样子。这是一个更窄的问题，答案通常更容易定义。例如，如果我们知道一个端点接受ISBN来查找一本书，那么我们知道我们只应该期望一个由10或13位数字组成的序列，可能带有分隔符。然而，对于人来说，数据清理要困难得多。
- en: 'There are several fantastic lists of falsehoods that programmers believe about
    various topics at [https://github.com/kdeldycke/awesome-falsehood](https://github.com/kdeldycke/awesome-falsehood).
    These lists are not meant to be exhaustive or authoritative, but they are helpful
    in reminding us that we may have false notions about how human information works.
    Human names, postal addresses, phone numbers: we should not make assumptions about
    what any of this data looks like, how many lines it has, or what order the elements
    are in. The best we can do is ensure that the human entering the information has
    the best chance to check that it is all correct, and then use the quoting and
    sandboxing techniques described earlier to avoid any incidents.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://github.com/kdeldycke/awesome-falsehood](https://github.com/kdeldycke/awesome-falsehood)上，有一些关于程序员对各种主题的错误认识的精彩列表。这些列表并不旨在详尽或具有权威性，但它们有助于提醒我们，我们可能对人类信息工作方式存在错误观念。人类姓名、邮政地址、电话号码：我们不应假设这些数据的任何样子，它们有多少行，或元素排列的顺序。我们能做的最好的事情是确保输入信息的人有最好的机会检查其正确性，然后使用前面描述的引用和沙箱技术来避免任何事故。
- en: Even an email address is extremely complicated to validate. The permitted format
    has a lot of different parts to it, and not all of them are supported by every
    email system. An oft-quoted saying is that the best way to validate an email address
    is to try sending it an email, and this validation method is used by both legitimate
    websites—sending an email and informing you that they "have sent an email to confirm
    your account"—and by spammers who send nonsensical messages to millions of addresses
    and record which ones don't return an error.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是电子邮件地址的验证也非常复杂。允许的格式有很多不同的部分，并不是所有的电子邮件系统都支持这些部分。有一句经常引用的话是，验证电子邮件地址的最佳方式是尝试发送一封电子邮件，这种方法既被合法网站使用——发送电子邮件并通知你“已发送电子邮件以确认您的账户”——也被垃圾邮件发送者使用，他们向数百万个地址发送无意义的消息，并记录哪些地址没有返回错误。
- en: To summarize, you should always treat incoming data as a potential threat, as
    a source of attacks to be injected into your system. Escape or remove any special
    characters, avoid using the data directly in database queries or templates without
    a layer of isolation between them, and ensure your data looks as you would expect
    it to.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你应该始终将传入的数据视为潜在的威胁，将其视为可能注入你系统的攻击源。转义或删除任何特殊字符，避免在没有隔离层的情况下直接在数据库查询或模板中使用数据，并确保你的数据看起来是你预期的样子。
- en: There is also a way to continuously check your code for potential security issues
    using the Bandit linter, explored in the next section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用Bandit代码检查器持续检查代码中的潜在安全问题，这在下一节中进行了探讨。
- en: Using Bandit linter
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bandit代码检查器
- en: Managed by the Python Code Quality Authority, Bandit ([https://github.com/PyCQA/bandit](https://github.com/PyCQA/bandit))
    is another tool to scan your source code for potential security risks. It can
    be run in CI systems for the automatic testing of any changes before they get
    deployed. The tool uses the `ast` module to parse the code in the same way that
    `flake8` and `pylint` do. Bandit will also scan for some known security issues
    in your code. Once you have installed it with the `pip install bandit` command,
    you can run it against your Python module using the `bandit` command.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由Python代码质量权威机构管理，Bandit（[https://github.com/PyCQA/bandit](https://github.com/PyCQA/bandit)）是另一个用于扫描源代码中潜在安全风险的工具。它可以在CI系统中运行，以在部署之前自动测试任何更改。该工具使用`ast`模块以与`flake8`和`pylint`相同的方式解析代码。Bandit还将扫描你代码中的一些已知安全问题。一旦使用`pip
    install bandit`命令安装它，你就可以使用`bandit`命令针对你的Python模块运行它。
- en: 'Adding Bandit to your continuous integration pipeline alongside other checks,
    as described in *Chapter 3*, *Coding, Testing, and Documentation: the Virtuous
    Cycle*, is a good way to catch potential security issues in your code.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如第3章所述，将Bandit添加到与其他检查并行的持续集成管道中，即《编码、测试和文档：良性循环》，是捕捉代码中潜在安全问题的好方法。
- en: Dependencies
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项
- en: Most projects will use other libraries, as programmers build on the work of
    others, and oftentimes there is not enough time to keep a close eye on how those
    other projects are doing. If there's a security vulnerability in one of our dependencies,
    we want to know about it quickly so that we can update our own software, without
    manually checking.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目都会使用其他库，因为程序员是在他人的工作上构建的，而且通常没有足够的时间密切关注那些其他项目的发展。如果我们的依赖项中存在安全漏洞，我们希望快速了解这一点，以便我们可以更新我们的软件，而无需手动检查。
- en: Dependabot ([https://dependabot.com/](https://dependabot.com/)) is a tool that
    will perform security sweeps of your project's dependencies. Dependabot is a built-in
    component of GitHub, and its reports should be visible in your project's **Security**
    tab. Turning on some extra features in the project's **Settings** page allows
    Dependabot to automatically create pull requests with any changes that need making
    to remain secure.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Dependabot ([https://dependabot.com/](https://dependabot.com/)) 是一个会对你的项目依赖进行安全扫描的工具。Dependabot
    是 GitHub 的内置组件，其报告应显示在你的项目 **安全** 选项卡中。在项目的 **设置** 页面上开启一些额外功能，可以让 Dependabot
    自动创建需要进行的任何更改以保持安全的拉取请求。
- en: PyUp has a similar set of features but requires manually setting up—as does
    Dependabot if you're not using GitHub.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: PyUp 拥有一组类似的功能，但需要手动设置——如果你不使用 GitHub，Dependabot 也是如此。
- en: Web application firewall
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用防火墙
- en: Even with the safest handling of data, our application can still be vulnerable
    to attack. When you're exposing HTTP endpoints to the world, this is always a
    risk. You will be hoping for callers to behave as intended, with each HTTP conversation
    following a scenario that you have programmed in the service.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数据处理得再安全，我们的应用程序仍然可能容易受到攻击。当你向世界公开 HTTP 端点时，这始终是一个风险。你希望调用者按预期行事，每个 HTTP 会话都遵循你在服务中编程的场景。
- en: A client can send legitimate requests and just hammer your service with it,
    leading to a **Denial of Service** (**DoS**) due to all the resources then being
    used to handle requests from the attacker. When many hundreds or thousands of
    clients are used to do this, it's known as a **Distributed Denial of Service**
    (**DDoS**) attack. This problem sometimes occurs within distributed systems when
    clients have replay features that are automatically recalling the same API. If
    nothing is done on the client side to throttle calls, you might end up with a
    service overloaded by legitimate clients.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个客户端可以发送合法的请求，并不断地用这些请求轰炸你的服务，导致由于所有资源都用于处理来自攻击者的请求而出现 **服务拒绝** （**DoS**）。当使用数百或数千个客户端进行此类操作时，这被称为
    **分布式拒绝服务** （**DDoS**） 攻击。当客户端具有自动回放相同 API 的功能时，这个问题有时会在分布式系统中发生。如果客户端侧没有采取措施来限制调用，你可能会遇到由合法客户端过载的服务。
- en: Adding protection on the server side to make such zealous clients back off is
    usually not hard to do, and goes a long way to protect your microservice stack.
    Some cloud providers also supply protection against DDoS attacks and a lot of
    the features mentioned here.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端添加保护以使这些热情的客户退却通常并不困难，并且这可以大大保护你的微服务堆栈。一些云服务提供商还提供针对 DDoS 攻击的保护以及这里提到的许多功能。
- en: 'OWASP, mentioned earlier in this chapter, provides a set of rules for the `ModSecurity`
    toolkit''s WAF that can be used to avoid many types of attacks: [https://github.com/coreruleset/coreruleset/](https://github.com/coreruleset/coreruleset/).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面提到的 OWASP 提供了一套规则，可用于 `ModSecurity` 工具包的 WAF，以避免许多类型的攻击：[https://github.com/coreruleset/coreruleset/](https://github.com/coreruleset/coreruleset/)。
- en: In this section, we will focus on creating a basic WAF that will explicitly
    reject a client that's making too many requests on our service. The intention
    of this section is not to create a full WAF, but rather to give you a good understanding
    of how WAFs are implemented and used. We could build our WAF in a Python microservice,
    but it would add a lot of overhead if all the traffic has to go through it. A
    much better solution is to rely directly on the web server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于创建一个基本的 WAF，该 WAF 将明确拒绝在我们的服务上请求过多的客户端。本节的目的不是创建一个完整的 WAF，而是让你更好地理解
    WAF 的实现和使用方式。我们可以在 Python 微服务中构建我们的 WAF，但如果所有流量都必须通过它，这将增加很多开销。一个更好的解决方案是直接依赖
    Web 服务器。
- en: 'OpenResty: Lua and nginx'
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenResty：Lua 和 nginx
- en: OpenResty ([http://openresty.org/en/](http://openresty.org/en/)) is an `nginx`
    distribution that embeds a Lua ([http://www.lua.org/](http://www.lua.org/)) interpreter
    that can be used to script the web server. We can then use scripts to apply rules
    and filters to the traffic.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: OpenResty ([http://openresty.org/en/](http://openresty.org/en/)) 是一个嵌入 Lua ([http://www.lua.org/](http://www.lua.org/))
    解释器的 `nginx` 发行版，可以用来编写 Web 服务器脚本。然后我们可以使用脚本将规则和过滤器应用于流量。
- en: Lua is an excellent, dynamically typed programming language that has a lightweight
    and fast interpreter. The language offers a complete set of features and has built-in
    async features. You can write coroutines directly in vanilla Lua.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 是一种优秀、动态类型的编程语言，它拥有轻量级且快速的解释器。该语言提供了一套完整的特性，并内置了异步特性。你可以在纯 Lua 中直接编写协程。
- en: 'If you install Lua (refer to [http://www.lua.org/start.html](http://www.lua.org/start.html)),
    you can play with the language using the Lua **Read-Eval-Print Loop** (**REPL**),
    exactly as you would with Python:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了 Lua（参考 [http://www.lua.org/start.html](http://www.lua.org/start.html)），你可以使用
    Lua **读取-评估-打印循环**（**REPL**）来玩转这门语言，就像使用 Python 一样：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To discover the Lua language, this is your starting page: [http://www.lua.org/docs.html](http://www.lua.org/docs.html).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Lua 语言，这是你的起点页面：[http://www.lua.org/docs.html](http://www.lua.org/docs.html)。
- en: Lua is often the language of choice to be embedded in compiled apps. Its memory
    footprint is ridiculously small, and it allows for fast dynamic scripting features—this
    is what is happening in `OpenResty`. Instead of building `nginx` modules you can
    extend the web server using Lua scripts and deploy them directly with OpenResty.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 经常是嵌入到编译应用程序中的首选语言。它的内存占用非常小，并且允许快速动态脚本功能——这就是在 `OpenResty` 中发生的事情。你不需要构建
    `nginx` 模块，而是可以使用 Lua 脚本来扩展 Web 服务器，并通过 OpenResty 直接部署它们。
- en: 'When you invoke some Lua code from your `nginx` configuration, the `LuaJIT`
    ([http://luajit.org/](http://luajit.org/)) interpreter that''s employed by OpenResty
    will run them, running at the same speed as the `nginx` code itself. Some performance
    benchmarks find that Lua can be faster than C or C++ in some cases; refer to:
    [http://luajit.org/performance.html](http://luajit.org/performance.html).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从你的 `nginx` 配置中调用一些 Lua 代码时，OpenResty 使用的 `LuaJIT`（[http://luajit.org/](http://luajit.org/)）解释器将运行它们，运行速度与
    `nginx` 代码本身相同。一些性能基准测试发现，在某些情况下 Lua 的速度可能比 C 或 C++ 快；请参考：[http://luajit.org/performance.html](http://luajit.org/performance.html)。
- en: Lua functions are coroutines, and so will run asynchronously in `nginx`. This
    leads to a low overhead even when your server receives a lot of concurrent requests,
    which is exactly what is needed for a WAF.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 函数是协程，因此将在 `nginx` 中异步运行。这导致即使服务器收到大量并发请求时，开销也很低，这正是 WAF 所需要的。
- en: OpenResty comes as a Docker image and a package for some Linux distributions.
    It can also be compiled from the source code if needed; refer to [http://openresty.org/en/installation.html](http://openresty.org/en/installation.html).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: OpenResty 以 Docker 镜像和一些 Linux 发行版的软件包的形式提供。如果需要，也可以从源代码编译；请参考 [http://openresty.org/en/installation.html](http://openresty.org/en/installation.html)。
- en: On macOS, you can use `Brew` and the `brew install openresty` command.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用 `Brew` 和 `brew install openresty` 命令。
- en: 'Once OpenResty is installed, you will get an `openresty` command, which can
    be used exactly like `nginx` to serve your applications. In the following example,
    the `nginx` configuration will proxy requests to a Quart application running on
    port `5000`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 OpenResty 后，你将获得一个 `openresty` 命令，它可以像 `nginx` 一样使用来服务你的应用程序。在以下示例中，`nginx`
    配置将代理请求到运行在端口 `5000` 上的 Quart 应用程序：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This configuration can be used with the `openresty` command line, and will
    run in the foreground (daemon off) on port `8888` to proxy pass all requests to
    the Quart app running on port `5000`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置可以使用 `openresty` 命令行，并在端口 `8888` 上以前台（守护进程关闭）模式运行，以代理转发到运行在端口 `5000` 上的 Quart
    应用程序：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that this configuration can also be used in a plain `nginx` server since
    we are not using any Lua yet. That''s one of the great things about OpenResty:
    it''s a drop-in replacement for `nginx`, and can run your existing configuration
    files.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此配置也可以用于普通的 `nginx` 服务器，因为我们还没有使用任何 Lua。这就是 OpenResty 的一个优点：它是 `nginx` 的直接替换品，可以运行你的现有配置文件。
- en: The code and configuration demonstrated in this section can be found at [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的代码和配置可以在 [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample)
    找到。
- en: 'Lua can be invoked at different moments when a request comes in; the two that
    are most attractive to this chapter are:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 可以在请求到来时被调用；本章中最吸引人的两个时刻是：
- en: '`access_by_lua_block`: This is called on every incoming request before a response
    is built, and is where we can build access rules in our WAF'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access_by_lua_block`: 这在构建响应之前对每个传入请求进行调用，并且是我们构建 WAF 访问规则的地方。'
- en: '`content_by_lua_block`: This uses Lua to generate a response'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content_by_lua_block`: 这使用 Lua 生成响应'
- en: Let us now see how we can rate-limit incoming requests.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何对传入请求进行速率限制。
- en: Rate and concurrency limiting
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速率和并发限制
- en: Rate limiting consists of counting how many requests a server accepts within
    a given period of time, and rejecting new ones when a limit is reached.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制包括在给定时间段内统计服务器接受的请求数量，并在达到限制时拒绝新的请求。
- en: Concurrency limiting consists of counting how many concurrent requests are being
    served by the web server to the same remote user, and rejecting new ones when
    it reaches a defined threshold. Since many requests can reach the server simultaneously,
    a concurrency limiter needs to have a small allowance in its threshold.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 并发限制包括统计由Web服务器为同一远程用户服务的并发请求数量，并在达到定义的阈值时拒绝新的请求。由于许多请求可以同时到达服务器，并发限制器需要在阈值中留有小的余量。
- en: These techniques avoid any trouble within our application when we know there
    is an upper limit to how many requests it can respond to concurrently, and that
    can be a factor in load balancing across multiple instances of our app. Both are
    implemented using the same technique. Let's look at how to build a concurrency
    limiter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术在我们知道应用可以同时响应多少请求的上限时，可以避免应用内部出现任何问题，并且这可能是跨多个应用实例进行负载均衡的一个因素。这两个功能都是使用相同的技巧实现的。让我们看看如何构建一个并发限制器。
- en: 'OpenResty ships with a rate-limiting library written in Lua called `lua-resty-limit-traffic`;
    you can use it in an `access_by_lua_block` section: [https://github.com/openresty/lua-resty-limit-traffic](https://github.com/openresty/lua-resty-limit-traffic).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: OpenResty附带了一个用Lua编写的速率限制库，名为`lua-resty-limit-traffic`；你可以在`access_by_lua_block`部分中使用它：[https://github.com/openresty/lua-resty-limit-traffic](https://github.com/openresty/lua-resty-limit-traffic)。
- en: The function uses Lua *Shared Dict*, which is a memory mapping that is shared
    by all `nginx` workers within the same process. Using an in-memory dictionary
    means that rate limiting will work at the process level.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用Lua的*Shared Dict*，这是一个由同一进程内的所有`nginx`工作进程共享的内存映射。使用内存字典意味着速率限制将在进程级别上工作。
- en: Since we're typically deploying one `nginx` per service node, rate limiting
    will happen per web server. So, if you are deploying several nodes for the same
    microservice, our effective rate limit will be the number of connections a single
    node can handle multiplied by the number of nodes—this will be important to take
    into account when deciding on the overall rate limit and how many concurrent requests
    the microservices can process.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通常在每个服务节点上部署一个`nginx`，因此速率限制将按每个Web服务器进行。所以，如果你为同一个微服务部署了多个节点，我们的有效速率限制将是单个节点可以处理的连接数乘以节点数——这在决定整体速率限制和微服务可以处理的并发请求数量时将非常重要。
- en: 'In the following example, we''re adding a `lua_shared_dict` definition and
    a section called `access_by_lua_block` to activate the rate limiting. Note that
    this example is a simplified version of the example in the project''s documentation:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们添加了一个`lua_shared_dict`定义和一个名为`access_by_lua_block`的部分来激活速率限制。请注意，这个示例是项目文档中示例的简化版本：
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `access_by_lua_block` section can be considered as a Lua function, and can
    use some of the variables and functions that `OpenResty` exposes. For instance,
    `ngx.var` is a table containing all the `nginx` variables, and `ngx.exit()` is
    a function that can be used to immediately return a response to the user—in our
    case, a `503` when we need to reject a call because of rate limiting.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`access_by_lua_block`部分可以被视为一个Lua函数，并且可以使用`OpenResty`公开的一些变量和函数。例如，`ngx.var`是一个包含所有`nginx`变量的表，而`ngx.exit()`是一个可以用来立即向用户返回响应的函数——在我们的例子中，当因为速率限制需要拒绝调用时，返回一个`503`。'
- en: The library uses the `my_limit_req_store` dictionary that is passed to the `resty.limit.req`
    function; every time a request reaches the server, it calls the `incoming()` function
    with the `binary_remote_addr` value, which is the client address.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 该库使用传递给`resty.limit.req`函数的`my_limit_req_store`字典；每次请求到达服务器时，它都会使用`binary_remote_addr`值调用`incoming()`函数，这是客户端地址。
- en: The `incoming()` function will use the shared dictionary to maintain the number
    of active connections per remote address, and send back a rejected value when
    that number reaches the threshold; for example, when there are more than `300`
    concurrent requests.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`incoming()`函数将使用共享字典来维护每个远程地址的活跃连接数，并在该数字达到阈值时返回一个拒绝值；例如，当并发请求超过`300`时。'
- en: If the connection is accepted, the `incoming()` function sends back a delay
    value. Lua will hold the request using that delay and the asynchronous `ngx.sleep()`
    function. The delay will be `0` when the remote client has not reached the threshold
    of `200`, and a small delay when between `200` and `300`, so the server has a
    chance to unstack all the pending requests.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接被接受，`incoming()` 函数会发送回一个延迟值。Lua 将使用该延迟和异步的 `ngx.sleep()` 函数保持请求。当远程客户端未达到
    `200` 的阈值时，延迟将为 `0`，当在 `200` 和 `300` 之间时，会有一个小的延迟，这样服务器就有机会处理所有挂起的请求。
- en: This design is quite efficient to prevent a service from becoming overwhelmed
    by many requests. Setting up a ceiling like this is also a good way to avoid reaching
    a point at which you know your microservice will start to break. For instance,
    if some of your benchmarks concluded that your service could not serve more than
    100 simultaneous requests before starting to crash, you can set the rate limit
    appropriately, so it is `nginx` that rejects requests instead of letting your
    Quart microservice try to process all those incoming connections only to reject
    them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计非常高效，可以防止服务因过多请求而超负荷。设置这样的上限也是避免达到一个你知道你的微服务将开始崩溃的点的好方法。例如，如果你的基准测试得出结论，你的服务在开始崩溃之前无法处理超过
    100 个并发请求，你可以适当地设置速率限制，这样 `nginx` 就会拒绝请求，而不是让你的 Quart 微服务尝试处理所有这些传入的连接，然后再拒绝它们。
- en: The key used to calculate the rate in this example is the remote address header
    of the request. If your `nginx` server is itself behind a proxy, make sure you
    are using a header that contains the real remote address. Otherwise, you will
    rate limit a single remote client, the proxy server. It's usually in the `X-Forwarded-For`
    header in that case.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用于计算速率的关键是请求的远程地址头。如果你的 `nginx` 服务器本身位于代理后面，确保你使用包含真实远程地址的头。否则，你将对单个远程客户端和代理服务器进行速率限制。在这种情况下，通常在
    `X-Forwarded-For` 头中。
- en: If you want a WAF with more features, the `lua-resty-waf` ([https://github.com/p0pr0ck5/lua-resty-waf](https://github.com/p0pr0ck5/lua-resty-waf))
    project works like `lua-resty-limit-traffic`, but offers a lot of other protections.
    It is also able to read `ModSecurity` rule files, so you can use the rule files
    from the OWASP project without having to use `ModSecurity` itself.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个功能更丰富的 WAF，`lua-resty-waf` ([https://github.com/p0pr0ck5/lua-resty-waf](https://github.com/p0pr0ck5/lua-resty-waf))
    项目就像 `lua-resty-limit-traffic` 一样工作，但提供了很多其他保护。它还能够读取 `ModSecurity` 规则文件，因此你可以使用
    OWASP 项目中的规则文件，而无需使用 `ModSecurity` 本身。
- en: Other OpenResty features
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 OpenResty 功能
- en: 'OpenResty comes with many Lua scripts that can be useful to enhance `nginx`.
    Some developers are even using it to serve their data directly. The following
    components page contains some useful tools for having `nginx` interact with databases,
    cache servers, and so on: [http://openresty.org/en/components.html](http://openresty.org/en/components.html).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: OpenResty 内置了许多 Lua 脚本，这些脚本可以用来增强 `nginx`。一些开发者甚至用它来直接提供数据。以下组件页面包含了一些有用的工具，用于让
    `nginx` 与数据库、缓存服务器等交互：[http://openresty.org/en/components.html](http://openresty.org/en/components.html)。
- en: 'There''s also a website for the community to publish OpenResty components:
    [https://opm.openresty.org/](https://opm.openresty.org/).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个网站供社区发布 OpenResty 组件：[https://opm.openresty.org/](https://opm.openresty.org/)。
- en: If you are using OpenResty in front of your Quart microservices, there will
    probably be other use cases where you can transfer some code that is in the Quart
    app to a few lines of Lua in OpenResty. The goal should not be to move the app's
    logic to OpenResty, but rather to leverage the web server to do anything that
    can be done before or after your Quart app is called. Let Python focus on the
    application logic and OpenResty work on a layer of protection.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在你的 Quart 微服务前面使用 OpenResty，可能还有其他用例，你可以将 Quart 应用中的一些代码转移到 OpenResty 的几行
    Lua 代码中。目标不应该是将应用的逻辑移动到 OpenResty，而应该是利用 Web 服务器在调用你的 Quart 应用之前或之后执行任何可以执行的操作。让
    Python 专注于应用逻辑，而 OpenResty 则专注于一层保护。
- en: For instance, if you are using a Redis or a Memcached server to cache some of
    your `GET` resources, you can directly call them from Lua to add or fetch a cached
    version for a given endpoint. The `srcache-nginx-module` ([https://github.com/openresty/srcache-nginx-module](https://github.com/openresty/srcache-nginx-module))
    is an implementation of such behavior, and will reduce the number of `GET` calls
    made to your Quart apps if you can cache them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在使用Redis或Memcached服务器来缓存一些`GET`资源，你可以直接从Lua调用它们，为特定的端点添加或检索缓存的版本。`srcache-nginx-module`（[https://github.com/openresty/srcache-nginx-module](https://github.com/openresty/srcache-nginx-module)）就是这样一种行为的实现，如果你能缓存它们，它将减少对Quart应用程序的`GET`调用次数。
- en: 'To conclude this section about WAFs: OpenResty is a powerful `nginx` distribution
    that can be used to create a simple WAF to protect your microservices. It also
    offers abilities that go beyond firewalling. In fact, if you adopt OpenResty to
    run your microservices, it opens a whole new world of possibilities, thanks to
    Lua.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结关于WAF的这一部分：OpenResty是一个强大的`nginx`发行版，可以用来创建一个简单的WAF来保护你的微服务。它还提供了超出防火墙功能的特性。实际上，如果你采用OpenResty来运行你的微服务，Lua将打开一个全新的可能性世界。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at how to centralize authentication and authorization
    in a microservices-based application environment using OAuth2 and JWTs. Tokens
    give us the ability to limit what a caller can do with one of the microservices,
    and for how long they can do it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在基于微服务应用程序环境中使用OAuth2和JWT来集中式地处理认证和授权。令牌赋予我们限制调用者使用某个微服务的能力，以及他们可以持续使用多长时间。
- en: When used with public and private keys, it also limits the damage an attacker
    can inflict if one component of the whole application is compromised. It also
    ensures that each connection is cryptographically validated.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当与公钥和私钥一起使用时，它还限制了攻击者在整个应用程序的一个组件被攻破时可能造成的损害。它还确保每个连接都经过加密验证。
- en: A secure code base is the first step to a secure application. You should follow
    good coding practices and make sure your code does not do anything bad when interacting
    with incoming user data and resources. While a tool like Bandit will not guarantee
    the safety and security of your code, it will catch the most obvious potential
    security issues, so there should be no hesitation about continuously running it
    on your code base.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的代码库是构建安全应用程序的第一步。你应该遵循良好的编码实践，并确保你的代码在与传入的用户数据和资源交互时不会做任何坏事。虽然像Bandit这样的工具不能保证你代码的安全性和安全性，但它会捕捉到最明显的潜在安全问题，因此你完全没有必要犹豫是否在你的代码库上持续运行它。
- en: Lastly, a WAF is also a good way to prevent some fraud and abuse on your endpoints
    and is very easy to do with a tool such as OpenResty, thanks to the power of the
    Lua programming language.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，WAF（Web应用防火墙）也是防止端点上的某些欺诈和滥用的好方法，使用像OpenResty这样的工具来做这件事非常简单，这要归功于Lua编程语言的力量。
- en: OpenResty is also an excellent way to empower and speed up your microservices
    by doing a few things at the web server level when they do not need to be done
    within the Quart application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: OpenResty也是通过在Web服务器级别做一些事情来赋予和加速你的微服务的好方法，当这些事情不需要在Quart应用程序内部完成时。
