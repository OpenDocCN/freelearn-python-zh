<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Improving Application Performance</h1></div></div></div><p>Even if our Notes application lacks many details, at this point, we are using a number of key components of the Cloud Platform, and so it can be considered a fully fledged web application. This is a good opportunity to stop adding major features and trying to delve into some implementation details involving Datastore, Memcache, and the Modules service in order to optimize application performance.</p><p>While going through this chapter, we have to take into consideration how optimizing a web application running on a pay-per-use service such as App Engine is crucial both to maximize performance and lower costs.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Gain a deeper knowledge of Datastore: properties, queries, caching, indexing and administration</li><li class="listitem" style="list-style-type: disc">How to store transient data into Memcache</li><li class="listitem" style="list-style-type: disc">How to structure our application with the help of the Modules service</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Advanced use of Datastore</h1></div></div></div><p>We have <a id="id255" class="indexterm"/>already learned a lot about Datastore so far, including how to define entity kinds with model classes, the property concept, and how to make simple queries.</p><p>There is a lot more we can do with the NDB Python API to optimize an application, as we will see shortly.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>More on properties – arrange composite data with StructuredProperty</h2></div></div></div><p>In <a id="id256" class="indexterm"/>our Notes application, we<a id="id257" class="indexterm"/> defined the <code class="literal">CheckListItem</code> model class to represent <a id="id258" class="indexterm"/>checkable items, and then<a id="id259" class="indexterm"/> we added a property to the <code class="literal">Note</code> model named <code class="literal">checklist_items</code> that references a list of that kind of entities. This is what we usually call a one-to-many relationship between notes and checklist items, and it is a common way to structure application data. By following this strategy, though, every time we add an item to a note, we have to create and store a new entity on Datastore. This is not a bad practice at all, but we have to take into consideration that we are charged for the use of Datastore depending on the number of operations we make; so, if we have a lot of data, keeping a low rate of write operations can potentially save a lot of money.</p><p>The Python NDB API provides a property type called <code class="literal">StructuredProperty</code> we can use to include one kind of model inside another; instead of referencing the <code class="literal">CheckListItem</code> model from a property of the type <code class="literal">KeyProperty</code> in the <code class="literal">Note</code> model, we store it in a property of the type <code class="literal">StructuredProperty</code>. In our <code class="literal">models.py</code> module, we change the Note model as follows:</p><div><pre class="programlisting">class Note(ndb.Model):
    title = ndb.StringProperty()
    content = ndb.TextProperty(required=True)
    date_created = ndb.DateTimeProperty(auto_now_add=True)
    checklist_items = ndb.StructuredProperty(CheckListItem,
                                             repeated=True)
    files = ndb.KeyProperty("NoteFile", repeated=True)</pre></div><p>In the <code class="literal">main.py</code> module, we need to adjust the code to store checklist items when we create a new note, so we refactor the <code class="literal">create_note</code> method in this way:</p><div><pre class="programlisting">@ndb.transactional
def _create_note(self, user, file_name, file_path):
    note = Note(parent=ndb.Key("User", user.nickname()),
                title=self.request.get('title'),
                content=self.request.get('content'))

    item_titles = self.request.get('checklist_items').split(',')
    for item_title in item_titles:
        if not item_title:
            continue
        item = CheckListItem(title=item_title)
        note.checklist_items.append(item)
    note.put()

    if file_name and file_path:
        url, thumbnail_url = self._get_urls_for(file_name)

        f = NoteFile(parent=note.key, name=file_name,
                     url=url, thumbnail_url=thumbnail_url,
                     full_path=file_path)
        f.put()
        note.files.append(f.key)
        note.put()</pre></div><p>First <a id="id260" class="indexterm"/>of all, we move the<a id="id261" class="indexterm"/> call to the <code class="literal">note.put()</code> method right below the note <a id="id262" class="indexterm"/>creation; we don't need to<a id="id263" class="indexterm"/> provide a valid key to the <code class="literal">parent</code> parameter in the <code class="literal">CheckListItem</code> constructor, so we can persist the <code class="literal">Note</code> instance later, at the end of the method. We then instance a <code class="literal">CheckListItem</code> object for every item we want to add to the note as before, but without actually creating any entity in Datastore; these objects will be transparently serialized by the NDB API within the <code class="literal">Note</code> entity.</p><p>We need to adjust the HTML template as well, as the <code class="literal">checklist_items</code> property in notes entities does not contain a list of keys anymore; it contains a list of <code class="literal">CheckListItem</code> objects instead. In the <code class="literal">main.html</code> file, we change the code accordingly, removing the <code class="literal">get()</code> method calls:</p><div><pre class="programlisting">{% if note.checklist_items %}
&lt;ul&gt;
  {% for item in note.checklist_items %}
  &lt;li class="{%if item.checked%}checked{%endif%}"&gt;
    {{item.title}}
  &lt;/li&gt;
  {% endfor %}
&lt;/ul&gt;
{% endif %}</pre></div><p>To see how it's easy to work with structured properties, we add a very small feature to the app: a link to toggle the checked status for items in checklists. To toggle the status of an item, we have to provide the request handler with the key of the note containing the item and the index of the item itself inside the <code class="literal">checklist_items</code> list, so we build a URL with the scheme <code class="literal">/toggle/&lt;note_key&gt;/&lt;item_index&gt;</code>. In the <code class="literal">main.html</code> file, we add this:</p><div><pre class="programlisting">{% if note.checklist_items %}
&lt;ul&gt;
  {% for item in note.checklist_items %}
  &lt;li class="{%if item.checked%}checked{%endif%}"&gt;
    &lt;a href="/toggle/{{note.key.urlsafe()}}/{{ loop.index }}"&gt;
      {{item.title}}
    &lt;/a&gt;
  &lt;/li&gt;
  {% endfor %}
&lt;/ul&gt;
{% endif %}</pre></div><p>Instances of the <code class="literal">Key</code> class have a <code class="literal">urlsafe()</code> method that serializes key objects into a string that can be safely used as part of URLs. To retrieve the current index inside a loop, we use <a id="id264" class="indexterm"/>the <code class="literal">loop.index</code> expression<a id="id265" class="indexterm"/> provided by Jinja2. We can also add a<a id="id266" class="indexterm"/> simple CSS rule to the <code class="literal">notes.css</code> file<a id="id267" class="indexterm"/> to make the items<a id="id268" class="indexterm"/> look a little better:</p><div><pre class="programlisting">div.note &gt; ul &gt; li &gt; a {
    text-decoration: none;
    color: inherit;
}</pre></div><p>To implement the toggling logic, we add the <code class="literal">ToggleHandler</code> class in the <code class="literal">main.py</code> module:</p><div><pre class="programlisting">class ToggleHandler(webapp2.RequestHandler):
    def get(self, note_key, item_index):
        item_index = int(item_index) - 1
        note = ndb.Key(urlsafe=note_key).get()
        item = note.checklist_items[item_index]
        item.checked = not item.checked
        note.put()
        self.redirect('/')</pre></div><p>We normalize the item index so that it is zero-based, and then we load a note entity from Datastore using its key. We instantiate a <code class="literal">Key</code> object passing the string generated with the <code class="literal">urlsafe()</code> method to the constructor with the <code class="literal">urlsafe</code> keyword parameter, then we retrieve the entity with the <code class="literal">get()</code> method. After toggling the state of the item at the requested index, we update the note content in Datastore calling the <code class="literal">put()</code> method. We finally redirect users to the main page of the application.</p><p>Eventually, we add the URL mapping to the application constructor with a regular expression matching our URL scheme, <code class="literal">/toggle/&lt;note_key&gt;/&lt;item_index&gt;</code>:</p><div><pre class="programlisting">app = webapp2.WSGIApplication([
    (r'/', MainHandler),
    (r'/media/(?P&lt;file_name&gt;[\w.]{0,256})', MediaHandler),
    (r'/shrink', ShrinkHandler),
    (r'/shrink_all', ShrinkCronJob),
    (r'/toggle/(?P&lt;note_key&gt;[\w\-]+)/(?P&lt;item_index&gt;\d+)', ToggleHandler),
    (r'/_ah/mail/create@book-123456\.appspotmail\.com', CreateNoteHandler),
], debug=True)</pre></div><p>Working with structured properties is straightforward; we simply access properties and fields of the objects contained in the <code class="literal">checklist_items</code> property as they were actual entities.</p><p>The <a id="id269" class="indexterm"/>only drawback of this<a id="id270" class="indexterm"/> approach is that <code class="literal">CheckListItem</code> entities are not actually<a id="id271" class="indexterm"/> stored in Datastore; they <a id="id272" class="indexterm"/>don't have a key and we cannot load them independently from the <code class="literal">Note</code> entity they belong to, but this is perfectly fine for our use case. Instead of loading the <code class="literal">CheckListItem</code> entity we want to update, we load the <code class="literal">Note</code> entity and we use the index to access the item. In exchange, during notes creation, we save a <code class="literal">put()</code> method call for the note and a <code class="literal">put()</code> method call for each item in the checklist and when retrieving a note, we save a <code class="literal">get()</code> method call for each item in the checklist. Needless to say, this kind of optimization can impact favorably on application costs.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>More on queries – save space with projections and optimize iterations with mapping</h2></div></div></div><p>Queries <a id="id273" class="indexterm"/>are used within an application to search Datastore <a id="id274" class="indexterm"/>for entities that match a search criteria we <a id="id275" class="indexterm"/>can define through filters. We have already used Datastore queries to retrieve entities with a filter; for example, every time we perform an ancestor query, we are actually filtering out these entities that have a different parent from the one we provided to the NDB API <code class="literal">query()</code> function.</p><p>There is much more we can do with query filters though, and in this section, we will see, in detail, two features provided by the NDB API that can be used to optimize application performance: projection queries and mapping.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Projection queries</h3></div></div></div><p>When we <a id="id276" class="indexterm"/>retrieve an entity with a query, we get all the properties<a id="id277" class="indexterm"/> and data for that entity as expected; sometimes though, after retrieving an entity, we use a small subset of its data. For example, take the <code class="literal">post()</code> method in our <code class="literal">ShrinkHandler</code> class; we perform an ancestor query to retrieve only the notes belonging to the currently logged in user, then we invoke the <code class="literal">_shrink_note()</code> method on each of them. The <code class="literal">_shrink_note()</code> method only accesses the <code class="literal">files</code> property from note entities, so we are keeping in memory and passing around a rather large object even if we only need a very small part of it.</p><p>With the NDB API, we can pass a projection parameter to the <code class="literal">fetch()</code> method that contains a list of properties we want to be set for the entities retrieved. For example, in the <code class="literal">post()</code> method of the <code class="literal">ShrinkHandler</code> class, we can modify the code in this way:</p><div><pre class="programlisting">notes = Note.owner_query(ancestor_key).fetch(
    projection=[Note.files])</pre></div><p>This is<a id="id278" class="indexterm"/> a so-called projection query and the entities fetched in this <a id="id279" class="indexterm"/>way will have only the <code class="literal">files</code> property set. The fetch is much more efficient because it retrieves and serializes less data and entities use less space while in memory. If we try to access any other property than <code class="literal">files</code> on such entities, an <code class="literal">UnprojectedPropertyError</code> error will be raised.</p><p>Projections have some limitations we must be aware of. First of all, as we can expect, entities fetched with a projection cannot be saved back on Datastore because they are only partially populated. Another limitation is regarding indexes; in fact, we can only specify indexed properties in a projection and this makes it impossible to project properties with unindexed types such as the <code class="literal">TextProperty</code> type.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Mapping</h3></div></div></div><p>Sometimes, we <a id="id280" class="indexterm"/>need to call the same function on a set of entities<a id="id281" class="indexterm"/> returned by a query. For example, in the <code class="literal">post()</code> method of the <code class="literal">ShrinkHandler</code> class, we need to call the <code class="literal">_shrink_note()</code> method on all the note entities for the current user:</p><div><pre class="programlisting">ancestor_key = ndb.Key("User", user.nickname())
notes = Note.owner_query(ancestor_key).fetch()
for note in notes:
    self._shrink_note(note)</pre></div><p>We first fetch all the entities matching the query in the notes list, then we call the same function for every item in the list. We can rewrite that code replacing the <code class="literal">for</code> iteration with a single call to the <code class="literal">map()</code> method provided by the NDB API:</p><div><pre class="programlisting">ancestor_key = ndb.Key("User", user.nickname())
Note.owner_query(ancestor_key).map(self._shrink_note)</pre></div><p>We call the <code class="literal">map()</code> method passing the callback function we want to be called on each result of the query; the callback function receives an entity object of kind Note as its only parameter, unless we invoke the <code class="literal">map()</code> method with the <code class="literal">keys_only=True</code> parameter. In this case, the callback will receive a <code class="literal">Key</code> instance when invoked.</p><p>Since the <code class="literal">map()</code> method<a id="id282" class="indexterm"/> accepts the standard set of query options (that's why we can pass the <code class="literal">keys_only</code> parameter), we can perform the mapping for a projection query too:</p><div><pre class="programlisting">Note.owner_query(ancestor_key).map(
    self._shrink_note, projection=[Note.files])</pre></div><p>Besides the projection, this version of the code is slightly more efficient because the Datastore can apply some concurrency while loading entities and the results are retrieved in batches instead of fetching the entire dataset in memory. If we want to get information regarding <a id="id283" class="indexterm"/>the current batch inside the callback function, we need to pass the <code class="literal">pass_batch_into_callback=True</code> parameter when calling the <code class="literal">map()</code> method. In<a id="id284" class="indexterm"/> this case, the callback will receive three parameters: a <code class="literal">Batch</code> object provided by App Engine that wraps a lot of information about the current batch, the index of the current item inside the current batch, and the entity object (or the entity key if the <code class="literal">keys_only</code> parameter was used) fetched from Datastore.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>NDB asynchronous operations</h2></div></div></div><p>As we <a id="id285" class="indexterm"/>can expect, Datastore is a key component<a id="id286" class="indexterm"/> when considering application performance; adjusting queries and using the right idioms can dramatically improve efficiency and lower costs but there's more. Thanks to the NDB API, we can speed up our applications by performing Datastore actions in parallel with other jobs, or performing a number of Datastore actions concurrently.</p><p>Several functions provided by the NDB API have an <code class="literal">_async</code> counterpart that takes exactly the same arguments, such as the <code class="literal">put</code> and <code class="literal">put_async</code> functions. Every async function returns a <strong>future</strong>, an object that represents an operation that was started but possibly not completed. We get the result of an async operation from the future itself calling the <code class="literal">get_result()</code> method.</p><p>In our Notes application, we can use asynchronous operations in the <code class="literal">_render_template()</code> method of the <code class="literal">MainHandler</code> class:</p><div><pre class="programlisting">def _render_template(self, template_name, context=None):
    if context is None:
        context = {}

    user = users.get_current_user()
    ancestor_key = ndb.Key("User", user.nickname())
    qry = Note.owner_query(ancestor_key)
    context['notes'] = qry.fetch()

    template = jinja_env.get_template(template_name)
    return template.render(context)</pre></div><p>Currently, we wait for the notes to be fetched before loading the template but we can load the template while Datastore is working:</p><div><pre class="programlisting">def _render_template(self, template_name, context=None):
    if context is None:
        context = {}

    user = users.get_current_user()
    ancestor_key = ndb.Key("User", user.nickname())
    qry = Note.owner_query(ancestor_key)
    future = qry.fetch_async()

    template = jinja_env.get_template(template_name)

    context['notes'] = future.get_result()
    return template.render(context)</pre></div><p>In this way, the application doesn't block on fetching data because the <code class="literal">fetch_async()</code> method returns immediately; we then proceed loading the template while the Datastore is working. When it's time to fill the context variable, we call the <code class="literal">get_result()</code> method on the future object. At this point, either the result is available and we proceed with rendering <a id="id287" class="indexterm"/>operations, or the <code class="literal">get_result()</code> method blocks, waiting for Datastore to be ready. In both cases, we managed to <a id="id288" class="indexterm"/>perform two tasks in parallel, thereby increasing the performance.</p><p>With the NDB API, we<a id="id289" class="indexterm"/> can also implement asynchronous tasks called <strong>tasklets</strong> that return a future while performing other work. For example, earlier in this chapter, we used the <code class="literal">map()</code> method in the <code class="literal">ShrinkHandler</code> class to call the same function on a set of entities retrieved from Datastore. We know that code is slightly more efficient than the version with the explicit <code class="literal">for</code> iteration, but it's not much faster actually; the callback function blocks on a synchronous <code class="literal">get()</code> method, so every step of the mapping waits for the previous to finish.</p><p>If we turn the callback function into a tasklet, App Engine can run the mapping in parallel, dramatically speeding up application performance. Writing tasklets is simple, thanks to the NDB API; for example the <code class="literal">_shrink_note()</code> method of the <code class="literal">ShrinkHandler</code> class can be transformed in a tasklet with just two lines of code, as follows:</p><div><pre class="programlisting">@ndb.tasklet
def _shrink_note(self, note):
    for file_key in note.files:
        file = yield file_key.get_async()
        try:
            with cloudstorage.open(file.full_path) as f:
                image = images.Image(f.read())
                image.resize(640)
                new_image_data = image.execute_transforms()

            content_t = images_formats.get(str(image.format))
            with cloudstorage.open(file.full_path, 'w',
                                   content_type=content_t) as f:
                f.write(new_image_data)

        except images.NotImageError:
            pass</pre></div><p>We <a id="id290" class="indexterm"/>first apply the <code class="literal">ndb.tasklet</code> decorator <a id="id291" class="indexterm"/>to the function we want to turn into a tasklet; the decorator provides all the logic to support the future mechanism with the <code class="literal">get_result()</code> method. We then use the <code class="literal">yield</code> statement to tell App Engine that we will suspend at that point of the execution, waiting for the result of the <code class="literal">get_async()</code> method. While we suspend, the <code class="literal">map()</code> method can execute another tasklet with a different entity instead of waiting for us to finish.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Caching</h2></div></div></div><p>Caching is <a id="id292" class="indexterm"/>a critical component on a system such as App Engine because it impacts on application performance and Datastore roundtrips and thus on application costs. The NDB API automatically manages the cache for us and provides a set of tools to configure the caching system. It's important to understand how NDB cache works if we want to take advantage of such features.</p><p>NDB uses two caching levels: the <strong>in-context</strong> cache that runs in process memory and a gateway <a id="id293" class="indexterm"/>to the App Engine Memcache service. The <a id="id294" class="indexterm"/>in-context cache stores data only for the duration of a single HTTP request and is local to the code that processes the request, so it is extremely fast. When we use a NDB function to write data on the Datastore, it first populates the in-context cache. Symmetrically, when we use a NDB function to fetch an entity from Datastore, it first searches for it in the in-context cache without even accessing Datastore in the best-case scenario.</p><p>Memcache is<a id="id295" class="indexterm"/> slower than the in-context cache but still <a id="id296" class="indexterm"/>way faster than Datastore. By default, every Datastore operation performed outside a transaction is cached on Memcache and App Engine ensures that data resides on the same server to maximize performance. The NDB ignores Memcache when it operates inside a transaction but when a transaction is committed, it will attempt to remove all the entities involved from Memcache, and we must take into account that some of these deletions can fail.</p><p>Both the caches are managed by a so-called context, represented by an instance of the class <code class="literal">Context</code> provided by App Engine. Each incoming HTTP request and each transaction is executed in a new context, and we can access the current context using the <code class="literal">get_context()</code> method provided by the NDB API.</p><p>In our Notes application, we've already experienced one of these rare situations where NDB automatic caching is actually an issue; in the <code class="literal">_reload_user()</code> method in <code class="literal">CreateNoteHandler</code> class, we had to force a reload of the <code class="literal">UserLoader</code> entity from Datastore as a workaround to populate a <code class="literal">User</code> object. Between the <code class="literal">put()</code> method and the <code class="literal">get()</code> method of the <code class="literal">UserLoader</code> entity, we wrote this instruction to remove the entity from any location except Datastore:</p><div><pre class="programlisting">UserLoader(user=user_instance).put()
key.delete(use_datastore=False)
u_loader = UserLoader.query(
    UserLoader.user == user_instance).get()</pre></div><p>Without this instruction, the NDB caching system would not have fetched the entity from Datastore from scratch as we needed. Now that we know how NDB caching works, we can rewrite that method in an equivalent way, thus being more explicit about cache management, using the <code class="literal">Context</code> instance:</p><div><pre class="programlisting">ctx = ndb.get_context()
ctx.set_cache_policy(lambda key: key.kind() != 'UserLoader')
UserLoader(user=user_instance).put()
u_loader = UserLoader.query(
    UserLoader.user == user_instance).get()</pre></div><p>The <code class="literal">set_cache_policy()</code> method exposed by the context object accepts a key object and returns<a id="id297" class="indexterm"/> a Boolean result. When the method returns the <code class="literal">False</code> parameter, the <a id="id298" class="indexterm"/>entity identified by that key won't be saved in any cache; in our case, we return the <code class="literal">False</code> parameter only when the entity is of the kind <code class="literal">UserLoader</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Backup and restore functionalities</h2></div></div></div><p>In order <a id="id299" class="indexterm"/>to use the backup and restore functionalities <a id="id300" class="indexterm"/>provided by App Engine for Datastore, we <a id="id301" class="indexterm"/>first need to enable <strong>Datastore Admin</strong>, which is disabled by default. Datastore Admin is a web application that provides a set of tools very useful <a id="id302" class="indexterm"/>for administrative tasks. At the time writing this, the only way to enable and access Datastore Admin is via the old Admin Console available<a id="id303" class="indexterm"/> at <a class="ulink" href="https://appengine.google.com">https://appengine.google.com</a>.</p><p>We access the console for our project and then we have to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Click on the <strong>Datastore Admin</strong> menu under the <strong>Data</strong> section on the left of the page.</li><li class="listitem">Click on the button to enable the admin.</li><li class="listitem">Select one or more entity kinds we want to backup or restore.</li></ol></div><p>To perform a complete backup, we first have to put our application in read-only mode. From the console, we need to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Click on <strong>Application Settings</strong> under the <strong>Administration</strong> menu on the left.</li><li class="listitem">At the bottom of the page, click on the <strong>Disable Writes...</strong> button under the <strong>Disable Datastore Writes</strong> option.</li><li class="listitem">Return to the <strong>Datastore Admin</strong> section and select all the entity kinds we want to backup.</li><li class="listitem">Click on the <strong>Backup Entities</strong> button.</li><li class="listitem">Select the destination of the backup and choose between <strong>blobstore</strong> and <strong>Cloud Storage</strong>. Specify a name for the backup file.</li><li class="listitem">Click on the <strong>Backup Entities</strong> button.</li><li class="listitem">The backup runs in the background; once finished, it is listed in <strong>Datastore Admin</strong>.</li><li class="listitem">Re-enable writings for our application.</li></ol></div><p>From Datastore Admin, we can select a backup and perform a restore. After starting a restore<a id="id304" class="indexterm"/> operation, Datastore Admin will ask us which<a id="id305" class="indexterm"/> entity kinds we want to restore, and then it'll proceed in<a id="id306" class="indexterm"/> background.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Indexing</h2></div></div></div><p>Indexes are<a id="id307" class="indexterm"/> tables that list Datastore entities in a sequence determined by certain properties of the index and optionally by entities' ancestors. Every time we write <a id="id308" class="indexterm"/>on Datastore, indexes are updated to reflect the changes to their respective entities; when we read from Datastore, results are fetched accessing indexes. This is basically the reason why reading from Datastore is way much faster than writing.</p><p>Our Notes application performs several queries, which means that some index must be in place, but we have never directly managed or created indexes. This is because of two reasons. The first reason is that when we run the local development server, it scans our source code, searching for queries and automatically generates the code to create all the indexes needed. The other reason is that Datastore automatically generates basic indexes called predefined indexes for each property of every kind, functional for simple queries.</p><p>Indexes are declared in the <code class="literal">index.yaml</code> file at the application root with the following syntax:</p><div><pre class="programlisting">- kind: Note
  ancestor: yes
  properties:
  - name: date_created
    direction: desc
  - name: NoteFile</pre></div><p>These are the properties needed to define and create the index that allows us to perform queries against Note entities that belong to the currently logged-in user and sort them in reverse by date. When we deploy the application, the <code class="literal">index.yaml</code> file is uploaded and App Engine starts to build the indexes.</p><p>If our application exercises every possible kind of query, including every sorting combination, then the entries generated by the development server will represent a complete set of indexes. This is why, in the vast majority of the cases, we don't need to declare indexes or customize existing ones unless we have a very special case to deal with. Anyway, in order to optimize our application, we can disable indexing for properties we know we will never make a query on. Predefined indexes are not listed in the <code class="literal">index.yaml</code> file but we can use the properties' constructors inside the <code class="literal">models.py</code> module to disable them. For example, if we know in advance that we will never search for <code class="literal">NoteFile</code> entities directly with a query, we can disable indexing for all its properties:</p><div><pre class="programlisting">class NoteFile(ndb.Model):
    name = ndb.StringProperty(indexed=False)
    url = ndb.StringProperty(indexed=False)
    thumbnail_url = ndb.StringProperty(indexed=False)
    full_path = ndb.StringProperty(indexed=False)</pre></div><p>By <a id="id309" class="indexterm"/>passing the <code class="literal">indexed=False</code> parameter to constructors, we avoid App <a id="id310" class="indexterm"/>Engine to create indexes for those properties so that every time we store a <code class="literal">NoteFile</code> entity, there will be less indexes to update, speeding up writing operations. The <code class="literal">NoteFile</code> entities can be still retrieved from the <code class="literal">files</code> property within the <code class="literal">Note</code> entity because App Engine will keep on creating the predefined index to retrieve entities by kind and key.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Using Memcache</h1></div></div></div><p>We already<a id="id311" class="indexterm"/> know that Memcache is the distributed in-memory data cache provided by App Engine. A typical use case would be to use it as a cache for rapid data retrieval from persistent storage such as Datastore, but we already know that the NDB API does this for us, so there's no need to explicitly cache entities.</p><p>Data stored in Memcache can be evicted at any time, so we should cache only data that we can safely lose without affecting integrity. For example, in our Notes application, we can cache the total number of notes globally stored for every user and display this nice kind of metric on the home page. We can perform a Datastore query counting <code class="literal">Note</code> entities every time a user visits the main page but this would be cumbersome, possibly nullifying every optimization we made so far. A better strategy would be to keep a counter in the Memcache and increment that counter every time a note is created within the application; if Memcache data expires, we make the counting query again without losing any data and start over incrementing the in-memory counter.</p><p>We implement two functions to wrap Memcache operations: one to get the value of the counter and another to increment it. We first create a new Python module in the <code class="literal">utils.py</code> file that contains the following code:</p><div><pre class="programlisting">from google.appengine.api import memcache
from models import Note
def get_note_counter():
    data = memcache.get('note_count')
    if data is None:
        data = Note.query().count()
        memcache.set('note_count', data)

    return data</pre></div><p>We first try<a id="id312" class="indexterm"/> to access counter value from Memcache calling the <code class="literal">get()</code> method asking for the <code class="literal">note_count</code> key. If the return value is <code class="literal">None</code>, we assume the key is not in cache and we proceed querying Datastore. We then store the result of the query in Memcache and return that value.</p><p>We want to display the counter on the main page, so we add it to the template context in the <code class="literal">_render_template()</code> method of the <code class="literal">MainHandler</code> class:</p><div><pre class="programlisting">def _render_template(self, template_name, context=None):
    if context is None:
        context = {}
    user = users.get_current_user()
    ancestor_key = ndb.Key("User", user.nickname())
    qry = Note.owner_query(ancestor_key)
    future = qry.fetch_async()

    template = jinja_env.get_template(template_name)

    context['notes'] = future.get_result()
    context['note_count'] = get_note_counter()

    return template.render(context)</pre></div><p>Before using the function to get the counter, we need to import it from the <code class="literal">main</code> module:</p><div><pre class="programlisting">from utils import get_note_counter</pre></div><p>We have to modify the HTML template as well:</p><div><pre class="programlisting">&lt;body&gt;
  &lt;div class="container"&gt;

    &lt;h1&gt;Welcome to Notes!&lt;/h1&gt;
    &lt;h5&gt;{{ note_count }} notes stored so far!&lt;/h5&gt;</pre></div><p>We can then refresh the main page of the Notes application to see the counter in action. Now it's time to write the code that increments the counter, but there's something we should be aware of before proceeding.</p><p>Multiple<a id="id313" class="indexterm"/> requests can try to increment the value in Memcache concurrently, potentially causing race conditions. To avoid this scenario, Memcache provides two functions, <code class="literal">incr()</code> and <code class="literal">decr()</code>, which atomically increment and decrement a 64-bit integer value. These would be perfectly suitable for our counter but we can provide a more general solution that works also for cache values that are not integers using the <strong>compare</strong> and <strong>set</strong> feature of the App Engine Python API.</p><p>In the <code class="literal">utils.py</code> module, we add the following function:</p><div><pre class="programlisting">def inc_note_counter():
    client = memcache.Client()
    retry = 0
    while retry &lt; 10:
        data = client.gets('note_count')
        if client.cas('note_count', data+1):
            break
        retry += 1</pre></div><p>We use an instance of the <code class="literal">Client</code> class because the compare and set functionalities are not provided as functions in the <code class="literal">memcache</code> module. After getting a <code class="literal">Client</code> instance, we enter the so-called <code class="literal">retry</code> loop that we reiterate up to 10 times if we detect a rare condition. We then try to get the value for the <code class="literal">note_count</code> key using the <code class="literal">gets</code> method of the client. This method alters the internal state of the client storing a timestamp value provided by the Memcache service. We then try to increment the value corresponding to the same key calling the <code class="literal">cas()</code> method on the client object; the method transmits the new value for the key to Memcache, plus the previously mentioned timestamp. If the timestamp matches, the value is updated and the <code class="literal">cas()</code> method returns the <code class="literal">True</code> parameter causing the <code class="literal">retry</code> loop to exit; otherwise, it returns the <code class="literal">False</code> parameter and we try again.</p><p>After importing the <code class="literal">inc_note_counter()</code> function in the main module, we can call it to increment the counter wherever we create a new note: within the <code class="literal">_create_note</code> of the <code class="literal">MainHandler</code> class and within the <code class="literal">_create_note</code> method in the <code class="literal">CreateNoteHandler</code> class.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Breaking our application into modules</h1></div></div></div><p>At the <a id="id314" class="indexterm"/>moment, our Notes application provides <a id="id315" class="indexterm"/>some frontend functionalities such as serving the main page, together with backend functionalities such as handling cron jobs. This is fine for most use cases but if the application architecture is complex and we have a lot of traffic, having several backend jobs around that steal resources from the frontend cannot be always acceptable. To face this kind of problems, App Engine provides an extremely flexible way to lay out a web application with the use of <strong>modules</strong>.</p><p>Every App Engine application is made up of at least on module; even if we didn't already know it, so far we have worked on the default module of our Notes application. A module is identified by a name, consists of source code and configuration files, and can reside in the application root or in a subfolder. Every module has a version and we can deploy multiple versions of the same module; each version will spawn one or more App Engine instances depending on how we configured it for scaling. The ability to deploy multiple versions of the same module, in particular, is very useful for testing new components or deploying progressive upgrades. Modules that are part of the same application share services such as Memcache, Datastore, and task queues, and can communicate in a secure fashion using the modules of the Python API.</p><p>To delve into some other detail, we can refactor our Notes application by adding a new module solely dedicated to handle cron jobs. We don't need to add any feature; we just break up and refactor existing code. As the architecture of our application is very simple, we can add the module directly in the application root. First of all, we need to configure this new module, we will name <code class="literal">backend</code> inside a new file, <code class="literal">backend.yaml</code>, which contains the following:</p><div><pre class="programlisting">application: notes
module: backend
version: 1
runtime: python27
api_version: 1
threadsafe: yes

handlers:
- url: .*
  script: backend.app</pre></div><p>This is quite similar to any application configuration file, but the main difference is the <code class="literal">module</code> property that contains the name of the module. When this property is not in the configuration file, or it contains the <code class="literal">default</code> string as value, App Engine assumes this is the default module for the application. We then tell App Engine we want the <code class="literal">app</code> application from the <code class="literal">backend_main</code> file Python module handle every request the module will receive. When we do not specify any scaling option in the configuration file, <strong>automatic scaling</strong> will be assumed.</p><p>We write a brand new Python module with a dedicated WSGI-compliant application in the <code class="literal">backend_main.py</code> file:</p><div><pre class="programlisting">app = webapp2.WSGIApplication([
    (r'/shrink_all', ShrinkCronJob),
], debug=True)</pre></div><p>As we <a id="id316" class="indexterm"/>see from the mapping, this application will only <a id="id317" class="indexterm"/>handle requests for the shrink cron job. We take the handler code from the main module, and to avoid depending on it, we rewrite the <code class="literal">ShrinkCronJob</code> class so that it doesn't need to derive from the <code class="literal">ShrinkHandler</code> class anymore. Again, in the <code class="literal">backend_main.py</code> module, we add the following:</p><div><pre class="programlisting">class ShrinkCronJob(webapp2.RequestHandler):
    @ndb.tasklet
    def _shrink_note(self, note):
        for file_key in note.files:
            file = yield file_key.get_async()
            try:
                with cloudstorage.open(file.full_path) as f:
                    image = images.Image(f.read())
                    image.resize(640)
                    new_image_data = image.execute_transforms()

                content_t = images_formats.get(str(image.format))
                with cloudstorage.open(file.full_path, 'w',
                                       content_type=content_t) as f:
                    f.write(new_image_data)

            except images.NotImageError:
                pass

    def get(self):
        if 'X-AppEngine-Cron' not in self.request.headers:
            self.error(403)

        notes = Note.query().fetch()
        for note in notes:
            self._shrink_note(note)</pre></div><p>For convenience, we can move the <code class="literal">image_formats</code> dictionary into the <code class="literal">utils.py</code> module so that we can reuse it from here and from the <code class="literal">main.py</code> module.</p><p>Now that we have two modules, we need to route the requests coming to our application to the right module, and we can do this by creating a file called <code class="literal">dispatch.yaml</code> in the application root that contains the following:</p><div><pre class="programlisting">dispatch:

  - url: "*/shrink_all"
    module: backend

  - url: "*/*"
    module: default</pre></div><p>Basically, this is the highest level URL mapping we can have on App Engine. We can use wildcards<a id="id318" class="indexterm"/> instead of a regular expression to route URLs <a id="id319" class="indexterm"/>of incoming requests to the right module; in this case, we route requests to the <code class="literal">/shrink_all</code> URL to the backend module, leaving all the rest to the default module.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>Ideally, we could have moved to the backend module also the code implementing notes creation by e-mail but unfortunately App Engine only allows inbound services on default modules.</p></div></div><p>Working with modules, both on the local development environment and on production, adds some complications because we cannot use the App Engine Launcher graphical interface to start and stop the development server or deploy the application; we must use the command-line tools instead.</p><p>For example, we can check out how modules works in the local environment, but we have to start the development server passing the <code class="literal">YAML</code> files for each module together with the <code class="literal">dispatch.yaml</code> file as arguments. In our case, we issue the following on the command line:</p><div><pre class="programlisting">
<strong>dev_appserver.py app.yaml backend.yaml dispatch.yaml</strong>
</pre></div><p>To deploy the application on App Engine, we use the <code class="literal">appcfg</code> command-line tool passing the <code class="literal">YAML</code> files of the modules we want to deploy, making sure that the configuration file of the default module is the first of the list during the very first deploy, for example we can use the <code class="literal">YAML</code> files as follows:</p><div><pre class="programlisting">
<strong>appcfg.py update app.yaml backend.yaml</strong>
</pre></div><p>When the application restarts, we should be able to see an instance running for the additional backend module using Development Console or Admin Console.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Since working with modules on a small application such as Notes is less practical and provides no benefits for the purpose of the book, we can switch back to the layout with only one module.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we delved into several details of most of the Cloud Platform components we have used so far. As mentioned before, when using a pay-per-use service such as the Cloud Platform, mastering the details and the best practices provides benefits for performance as well as costs. The majority of this chapter was dedicated to Cloud Datastore, confirming that this is a critical component for almost any web application; knowing how to lay out data or perform queries can determine the success of our application.</p><p>We also learned how to safely use Memcache from a Python application, avoiding race conditions and strange behaviors that are difficult to debug. In the last part of the chapter, we covered the modules features of App Engine; even if we have to work on a complex application to completely appreciate the benefits of a modular architecture, knowing what modules are and what they can do for us is an important piece of information if we want to deploy our applications on App Engine.</p><p>The next chapter is completely dedicated to the Google Cloud SQL service. We will learn how to create and manage database instances and how to make connections and perform queries.</p></div></body></html>