<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer157">
   <h1 class="chapterNumber">
    <span class="koboSpan" id="kobo.1.1">
     9
    </span>
   </h1>
   <h1 class="chapterTitle" id="_idParaDest-251">
    <span class="koboSpan" id="kobo.2.1">
     Cryptography and Tokens
    </span>
   </h1>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.3.1">
      ”Three may keep a secret, if two of them are dead.”
     </span>
    </p>
    <p class="cite">
     <span class="koboSpan" id="kobo.4.1">
      – Benjamin Franklin, Poor Richard’s Almanack
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.5.1">
     In this short chapter, we are going to give you a brief overview of the cryptographic services offered by the Python standard library.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     We are also going to touch upon JSON Web Tokens, an interesting standard for representing claims securely between two parties.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.6.1">
     We are going to explore the following:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.7.1">
      Hashlib
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.8.1">
      HMAC
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.9.1">
      Secrets
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.10.1">
      JSON Web Tokens with PyJWT, which seems to be the most popular Python library for dealing with JWTs
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.11.1">
     Let us start by taking a moment to talk about cryptography and why it is so important.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-252">
    <span class="koboSpan" id="kobo.12.1">
     The need for cryptography
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.13.1">
     It is estimated that, as
    </span>
    <a id="_idIndexMarker852">
    </a>
    <span class="koboSpan" id="kobo.14.1">
     of 2024, there are approximately 5.35 to 5.44 billion people using the internet worldwide.
    </span>
    <span class="koboSpan" id="kobo.14.2">
     Every year, more people are using online banking services, shopping online, or just talking to friends and family on social media.
    </span>
    <span class="koboSpan" id="kobo.14.3">
     All these people expect that their money will be safe, their transactions secure, and their conversations private.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.15.1">
     Therefore, if you are an application developer, you must take security very seriously.
    </span>
    <span class="koboSpan" id="kobo.15.2">
     It doesn’t matter how small or insignificant your application is: security should always be a concern for you.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.16.1">
     Security in
    </span>
    <a id="_idIndexMarker853">
    </a>
    <span class="koboSpan" id="kobo.17.1">
     information technology is achieved by employing several different means, but by far the most important one is cryptography.
    </span>
    <span class="koboSpan" id="kobo.17.2">
     Almost everything you do with your computer or phone should include a layer where cryptography takes place.
    </span>
    <span class="koboSpan" id="kobo.17.3">
     For example, cryptography is used to secure online payments, to transfer messages over a network in such a way that even if someone intercepts them, they will not be able to read them, and to encrypt your files when you back them up in the cloud.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.18.1">
     The purpose of this chapter is not to teach you all the intricacies of cryptography—there are entire books dedicated to the subject.
    </span>
    <span class="koboSpan" id="kobo.18.2">
     Instead, we will show you how you can use the tools that Python offers you to create digests, tokens, and, in general, to be on the safe(r) side when you need to implement something cryptography-related.
    </span>
    <span class="koboSpan" id="kobo.18.3">
     As you read this chapter, it is worth bearing in mind that there is much more to cryptography than just encrypting and decrypting data; in fact, you will not find any examples of encryption or decryption in the entire chapter!
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-253">
    <span class="koboSpan" id="kobo.19.1">
     Useful guidelines
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.20.1">
     Always
    </span>
    <a id="_idIndexMarker854">
    </a>
    <span class="koboSpan" id="kobo.21.1">
     remember the following rule: do not attempt to create your own hash or encryption functions.
    </span>
    <span class="koboSpan" id="kobo.21.2">
     Simply don’t.
    </span>
    <span class="koboSpan" id="kobo.21.3">
     Use tools and functions that are there already.
    </span>
    <span class="koboSpan" id="kobo.21.4">
     It is incredibly tough to invent a good, solid, robust algorithm to do hashing or encryption, so it is best to leave it to professional cryptographers.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.22.1">
     It is important to understand cryptography, so try and learn as much as you can about this subject.
    </span>
    <span class="koboSpan" id="kobo.22.2">
     There is plenty of information on the web, but for your convenience, we will put some useful references at the end of this chapter.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.23.1">
     Now, let us dig into the first of the standard library modules we want to show you:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.24.1">
      hashlib
     </span>
    </code>
    <span class="koboSpan" id="kobo.25.1">
     .
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-254">
    <span class="koboSpan" id="kobo.26.1">
     Hashlib
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.27.1">
     This
    </span>
    <a id="_idIndexMarker855">
    </a>
    <span class="koboSpan" id="kobo.28.1">
     module provides access to a variety of cryptographic hash algorithms.
    </span>
    <span class="koboSpan" id="kobo.28.2">
     These are mathematical functions that take a message of any size and produce a fixed-size result, which is referred to as a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.29.1">
      hash
     </span>
    </strong>
    <span class="koboSpan" id="kobo.30.1">
     or
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.31.1">
      digest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.32.1">
     .
    </span>
    <span class="koboSpan" id="kobo.32.2">
     Cryptographic hashes have many uses, from verifying data integrity to securely storing and verifying passwords.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.33.1">
     Ideally, cryptographic hash algorithms should be:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.34.1">
       Deterministic
      </span>
     </strong>
     <span class="koboSpan" id="kobo.35.1">
      : The same message should always produce the same hash.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.36.1">
       Irreversible
      </span>
     </strong>
     <span class="koboSpan" id="kobo.37.1">
      : It should not be feasible to determine the original message from the hash.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.38.1">
       Collision resistant
      </span>
     </strong>
     <span class="koboSpan" id="kobo.39.1">
      : It should be difficult to find two different messages that produce the same hash.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.40.1">
     These properties are
    </span>
    <a id="_idIndexMarker856">
    </a>
    <span class="koboSpan" id="kobo.41.1">
     crucial for the secure application of hashes.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     For example, it is considered imperative that passwords are only stored in hashed form.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.42.1">
     The irreversibility property ensures that even if a data breach occurs and an attacker gets hold of a password database, it would not be feasible for them to obtain the original passwords.
    </span>
    <span class="koboSpan" id="kobo.42.2">
     Having the passwords stored only as hashes means that the only way to verify a user’s password when they log in is to compute the hash of the password they provided and compare it against the stored hash.
    </span>
    <span class="koboSpan" id="kobo.42.3">
     Of course, this will not work if the hash algorithm is not deterministic.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.43.1">
     Collision resistance is also important.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     It ensures data integrity in that if a hash is used to provide a fingerprint for data, it is crucial that when the data changes, the fingerprint changes too.
    </span>
    <span class="koboSpan" id="kobo.43.3">
     Collision resistance prevents an attacker from replacing a document with a different one that has the same hash.
    </span>
    <span class="koboSpan" id="kobo.43.4">
     Moreover, many security protocols rely on the uniqueness guaranteed by collision-resistant hash functions.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.44.1">
     The exact set of algorithms that are available through
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.45.1">
      hashlib
     </span>
    </code>
    <span class="koboSpan" id="kobo.46.1">
     vary depending on the underlying libraries used on your platform.
    </span>
    <span class="koboSpan" id="kobo.46.2">
     Some algorithms, however, are guaranteed to be present in all systems.
    </span>
    <span class="koboSpan" id="kobo.46.3">
     Let us see how to find out what is available (note that your results might be different from ours):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.47.1"># hlib.txt
&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; hashlib.algorithms_available
{'sha3_256', 'sha224', 'blake2b', 'sha512_224', 'ripemd160',
 'sha1', 'sha512_256', 'sha3_512', 'sha512', 'sha384', 'sha3_384',
'sha3_224', 'shake_256', 'shake_128', 'sm3', 'md5-sha1', 'sha256',
'md5', 'blake2s'}
&gt;&gt;&gt; hashlib.algorithms_guaranteed
{'sha512', 'sha3_256', 'shake_128', 'sha224', 'blake2b',
 'shake_256', 'sha384', 'sha1', 'sha3_512', 'sha3_384', 'sha256',
 'sha3_224', 'md5', 'blake2s'}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.48.1">
     By opening a
    </span>
    <a id="_idIndexMarker857">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     Python shell, we can get the set of available algorithms for our system.
    </span>
    <span class="koboSpan" id="kobo.49.2">
     If our application talks to third-party applications, it is always best to pick an algorithm out of the guaranteed set, as that means every platform supports them.
    </span>
    <span class="koboSpan" id="kobo.49.3">
     Notice that a lot of them start with
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.50.1">
      sha
     </span>
    </em>
    <span class="koboSpan" id="kobo.51.1">
     , which stands for
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.52.1">
      secure hash algorithm
     </span>
    </em>
    <span class="koboSpan" id="kobo.53.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.54.1">
     Let us keep going in the same shell; we are going to create a hash for the byte string
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.55.1">
      b"Hash me now!"
     </span>
    </code>
    <span class="koboSpan" id="kobo.56.1">
     :
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.57.1">&gt;&gt;&gt; h = hashlib.blake2b()
&gt;&gt;&gt; h.update(b"Hash me")
&gt;&gt;&gt; h.update(b" now!")
&gt;&gt;&gt; h.hexdigest()
'56441b566db9aafcf8cdad3a4729fa4b2bfaab0ada36155ece29f52ff70e1e9d'
'7f54cacfe44bc97c7e904cf79944357d023877929430bc58eb2dae168e73cedf'
&gt;&gt;&gt; h.digest()
b'VD\x1bVm\xb9\xaa\xfc\xf8\xcd\xad:G)\xfaK+\xfa\xab\n\xda6\x15^'
b'\xce)\xf5/\xf7\x0e\x1e\x9d\x7fT\xca\xcf\xe4K\xc9|~\x90L\xf7'
b'\x99D5}\x028w\x92\x940\xbcX\xeb-\xae\x16\x8es\xce\xdf'
&gt;&gt;&gt; h.block_size
128
&gt;&gt;&gt; h.digest_size
64
&gt;&gt;&gt; h.name
'blake2b'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.58.1">
     Here, we have used the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.59.1">
      blake2b()
     </span>
    </code>
    <span class="koboSpan" id="kobo.60.1">
     cryptographic function, which is quite sophisticated and was added in Python 3.6.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     After creating the hash object,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.61.1">
      h
     </span>
    </code>
    <span class="koboSpan" id="kobo.62.1">
     , we update its message in two steps.
    </span>
    <span class="koboSpan" id="kobo.62.2">
     Not that we needed to, but sometimes we need to hash data that is not available all at once, so it is good to know we can do it in steps.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.63.1">
     Once we have added the entire message, we get the hexadecimal representation of the digest.
    </span>
    <span class="koboSpan" id="kobo.63.2">
     This will use two characters per byte (as each character represents four bits, which is half a byte).
    </span>
    <span class="koboSpan" id="kobo.63.3">
     We also get the byte representation of the digest, and then we inspect its details: it has a block size (the internal block size of the hash algorithm in bytes) of 128 bytes, a digest size (the size of the resulting hash in bytes) of 64 bytes, and a name.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.64.1">
     Let us see what we get if, instead of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.65.1">
      blake2b()
     </span>
    </code>
    <span class="koboSpan" id="kobo.66.1">
     function, we use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.67.1">
      sha512()
     </span>
    </code>
    <span class="koboSpan" id="kobo.68.1">
     :
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.69.1">&gt;&gt;&gt; hashlib.sha512(b"Hash me too!").hexdigest()
'a0d169ac9487fc6c78c7db64b54aefd01bd245bbd1b90b6fe5648c3c4eb0ea7d'
'93e1be50127164f21bc8ddb3dd45a6b4306dfe9209f2677518259502fed27686'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.70.1">
     The resulting hash is as long as the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.71.1">
      blake2b
     </span>
    </code>
    <span class="koboSpan" id="kobo.72.1">
     one.
    </span>
    <span class="koboSpan" id="kobo.72.2">
     Notice that we can construct the hash object with the message and compute the digest in one line.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.73.1">
     Hashing is an
    </span>
    <a id="_idIndexMarker858">
    </a>
    <span class="koboSpan" id="kobo.74.1">
     interesting topic, and of course, the simple examples we have seen so far are just the start.
    </span>
    <span class="koboSpan" id="kobo.74.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.75.1">
      blake2b()
     </span>
    </code>
    <span class="koboSpan" id="kobo.76.1">
     function allows us a great deal of flexibility thanks to a number of parameters that can be adjusted.
    </span>
    <span class="koboSpan" id="kobo.76.2">
     This means that it can be adapted for different applications or adjusted to protect against particular types of attacks.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.77.1">
     Here, we will just briefly discuss one of these parameters; for the full details, please refer to the official documentation at
    </span>
    <a href="https://docs.python.org/3/library/hashlib.html">
     <span class="url">
      <span class="koboSpan" id="kobo.78.1">
       https://docs.python.org/3/library/hashlib.html
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.79.1">
     .
    </span>
    <span class="koboSpan" id="kobo.79.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.80.1">
      person
     </span>
    </code>
    <span class="koboSpan" id="kobo.81.1">
     parameter is quite interesting.
    </span>
    <span class="koboSpan" id="kobo.81.2">
     It is used to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.82.1">
      personalize
     </span>
    </em>
    <span class="koboSpan" id="kobo.83.1">
     the hash, forcing it to produce different digests for the same message.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     This can help to improve security when the same hash function is used for different purposes within the same application:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.84.1">&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; h1 = hashlib.blake2b(
...    </span><span class="koboSpan" id="kobo.84.2">b"Important data", digest_size=16, person=b"part-1")
&gt;&gt;&gt; h2 = hashlib.blake2b(
...    </span><span class="koboSpan" id="kobo.84.3">b"Important data", digest_size=16, person=b"part-2")
&gt;&gt;&gt; h3 = hashlib.blake2b(
...    </span><span class="koboSpan" id="kobo.84.4">b"Important data", digest_size=16)
&gt;&gt;&gt; h1.hexdigest()
'c06b9af95d5aa6307e7e3fd025a15646'
&gt;&gt;&gt; h2.hexdigest()
'9cb03be8f3114d0f06bddaedce2079c4'
&gt;&gt;&gt; h3.hexdigest()
'7d35308ca3b042b5184728d2b1283d0d'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.85.1">
     Here, we have also used the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.86.1">
      digest_size
     </span>
    </code>
    <span class="koboSpan" id="kobo.87.1">
     parameter to get hashes that are only 16 bytes long.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.88.1">
     General-purpose hash functions, like
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.89.1">
      blake2b()
     </span>
    </code>
    <span class="koboSpan" id="kobo.90.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.91.1">
      sha512()
     </span>
    </code>
    <span class="koboSpan" id="kobo.92.1">
     , are not suitable for securely storing passwords.
    </span>
    <span class="koboSpan" id="kobo.92.2">
     General-purpose hash functions are quite fast to compute on modern computers, which makes it feasible for an attacker to reverse the hash by
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.93.1">
      brute force
     </span>
    </strong>
    <span class="koboSpan" id="kobo.94.1">
     (trying millions of possibilities per second until they find a match).
    </span>
    <span class="koboSpan" id="kobo.94.2">
     Key derivation algorithms like
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.95.1">
      pbkdf2_hmac()
     </span>
    </code>
    <span class="koboSpan" id="kobo.96.1">
     are designed to be slow enough to make such brute-force attacks infeasible.
    </span>
    <span class="koboSpan" id="kobo.96.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.97.1">
      pbkdf2_hmac()
     </span>
    </code>
    <span class="koboSpan" id="kobo.98.1">
     key derivation algorithm achieves this by using many repeated applications of a general-purpose hash function (the number of iterations can be specified as a parameter).
    </span>
    <span class="koboSpan" id="kobo.98.2">
     As computers get more powerful, it is important to increase the number of iterations we do over time; otherwise, the likelihood of a successful brute-force attack on our data increases as time passes.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.99.1">
     Good password hash functions
    </span>
    <a id="_idIndexMarker859">
    </a>
    <span class="koboSpan" id="kobo.100.1">
     should also use
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.101.1">
      salt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.102.1">
     .
    </span>
    <span class="koboSpan" id="kobo.102.2">
     Salt is a random piece of data used to initialize the hash function; this randomizes the output of the algorithm and protects against attacks where hashes are compared to tables of known hashes.
    </span>
    <span class="koboSpan" id="kobo.102.3">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.103.1">
      pbkdf2_hmac()
     </span>
    </code>
    <span class="koboSpan" id="kobo.104.1">
     function supports salting via a required
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.105.1">
      salt
     </span>
    </code>
    <span class="koboSpan" id="kobo.106.1">
     parameter.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.107.1">
     Here’s how you can use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.108.1">
      pbkdf2_hmac()
     </span>
    </code>
    <span class="koboSpan" id="kobo.109.1">
     to hash a password:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.110.1">&gt;&gt;&gt; import os
&gt;&gt;&gt; dk = hashlib.pbkdf2_hmac("sha256", b"password123",
...     </span><span class="koboSpan" id="kobo.110.2">salt=os.urandom(16), iterations=200000)
&gt;&gt;&gt; dk.hex()
'ac34579350cf6d05e01e745eb403fc50ac0e62fbeb553cbb895e834a77c37aed'
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.111.1">
     Notice that we have used
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.112.1">
      os.urandom()
     </span>
    </code>
    <span class="koboSpan" id="kobo.113.1">
     to provide a 16-byte random salt, as recommended by the documentation.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.114.1">
      Normally, the value of the salt is stored alongside the hash.
     </span>
     <span class="koboSpan" id="kobo.114.2">
      When a user attempts to log in, your program uses the stored salt to create the hash of the given password, which is then compared to the stored hash.
     </span>
     <span class="koboSpan" id="kobo.114.3">
      Using the same value for the salt ensures that the hash will be the same when the password is correct.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.115.1">
     We encourage you to explore and experiment with this module, as eventually, you will have to use it.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     Now, let us move on to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.116.1">
      hmac
     </span>
    </code>
    <span class="koboSpan" id="kobo.117.1">
     module.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-255">
    <span class="koboSpan" id="kobo.118.1">
     HMAC
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.119.1">
     This
    </span>
    <a id="_idIndexMarker860">
    </a>
    <span class="koboSpan" id="kobo.120.1">
     module implements the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.121.1">
      HMAC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.122.1">
     algorithm, as described by RFC 2104 (
    </span>
    <a href="https://datatracker.ietf.org/doc/html/rfc2104.html">
     <span class="url">
      <span class="koboSpan" id="kobo.123.1">
       https://datatracker.ietf.org/doc/html/rfc2104.html
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.124.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.124.2">
     HMAC (which stands
    </span>
    <a id="_idIndexMarker861">
    </a>
    <span class="koboSpan" id="kobo.125.1">
     for
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.126.1">
      hash-based message authentication code
     </span>
    </strong>
    <span class="koboSpan" id="kobo.127.1">
     or
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.128.1">
      keyed-hash message authentication code
     </span>
    </strong>
    <span class="koboSpan" id="kobo.129.1">
     , depending on who you ask) is a
    </span>
    <a id="_idIndexMarker862">
    </a>
    <span class="koboSpan" id="kobo.130.1">
     widely used mechanism for authenticating messages and verifying that they have not been tampered with.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.131.1">
     The algorithm combines a message with a secret key and generates a hash of the combination.
    </span>
    <span class="koboSpan" id="kobo.131.2">
     This hash is referred
    </span>
    <a id="_idIndexMarker863">
    </a>
    <span class="koboSpan" id="kobo.132.1">
     to as a
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.133.1">
      message authentication code
     </span>
    </strong>
    <span class="koboSpan" id="kobo.134.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.135.1">
      MAC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     ) or
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.137.1">
      signature
     </span>
    </strong>
    <span class="koboSpan" id="kobo.138.1">
     .
    </span>
    <span class="koboSpan" id="kobo.138.2">
     The signature is stored or transmitted along with the message.
    </span>
    <span class="koboSpan" id="kobo.138.3">
     You can verify that the message has not been tampered with by re-computing the signature using the same secret key and comparing it to the previously computed signature.
    </span>
    <span class="koboSpan" id="kobo.138.4">
     The secret key must be carefully protected; otherwise, an attacker with access to the key would be able to modify
    </span>
    <a id="_idIndexMarker864">
    </a>
    <span class="koboSpan" id="kobo.139.1">
     the message and replace the signature, thereby defeating the authentication mechanism.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.140.1">
     Let us see a
    </span>
    <a id="_idIndexMarker865">
    </a>
    <span class="koboSpan" id="kobo.141.1">
     small example of how to compute a MAC:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.142.1"># hmc.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.143.1">import</span></span><span class="koboSpan" id="kobo.144.1"> hmac
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.145.1">import</span></span><span class="koboSpan" id="kobo.146.1"> hashlib
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.147.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.148.1">calc_digest</span></span><span class="koboSpan" id="kobo.149.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.150.1">key, message</span></span><span class="koboSpan" id="kobo.151.1">):
    key = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.152.1">bytes</span></span><span class="koboSpan" id="kobo.153.1">(key, </span><span class="hljs-string"><span class="koboSpan" id="kobo.154.1">"utf-8"</span></span><span class="koboSpan" id="kobo.155.1">)
    message = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.156.1">bytes</span></span><span class="koboSpan" id="kobo.157.1">(message, </span><span class="hljs-string"><span class="koboSpan" id="kobo.158.1">"utf-8"</span></span><span class="koboSpan" id="kobo.159.1">)
    dig = hmac.new(key, message, hashlib.sha256)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.160.1">return</span></span><span class="koboSpan" id="kobo.161.1"> dig.hexdigest()
mac = calc_digest("secret-key", "Important Message")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.162.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.163.1">
      hmac.new()
     </span>
    </code>
    <span class="koboSpan" id="kobo.164.1">
     function takes a secret key, a message, and the hash algorithm to use.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     It returns an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.165.1">
      hmac
     </span>
    </code>
    <span class="koboSpan" id="kobo.166.1">
     object, which has a similar interface to the hash objects from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.167.1">
      hashlib
     </span>
    </code>
    <span class="koboSpan" id="kobo.168.1">
     .
    </span>
    <span class="koboSpan" id="kobo.168.2">
     The key must be a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.169.1">
      bytes
     </span>
    </code>
    <span class="koboSpan" id="kobo.170.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.171.1">
      bytearray
     </span>
    </code>
    <span class="koboSpan" id="kobo.172.1">
     object and the message can be any
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.173.1">
      bytes
     </span>
    </code>
    <span class="koboSpan" id="kobo.174.1">
     -like object.
    </span>
    <span class="koboSpan" id="kobo.174.2">
     Therefore, we convert our
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.175.1">
      key
     </span>
    </code>
    <span class="koboSpan" id="kobo.176.1">
     and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.177.1">
      message
     </span>
    </code>
    <span class="koboSpan" id="kobo.178.1">
     into bytes before creating an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.179.1">
      hmac
     </span>
    </code>
    <span class="koboSpan" id="kobo.180.1">
     instance (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.181.1">
      dig
     </span>
    </code>
    <span class="koboSpan" id="kobo.182.1">
     ), which we use to get a hexadecimal representation of the hash.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.183.1">
     We will see a bit more of how HMAC signatures can be used later in this chapter when we talk about JWTs.
    </span>
    <span class="koboSpan" id="kobo.183.2">
     Before that, however, we will take a quick look at the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.184.1">
      secrets
     </span>
    </code>
    <span class="koboSpan" id="kobo.185.1">
     module.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-256">
    <span class="koboSpan" id="kobo.186.1">
     Secrets
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.187.1">
     This small
    </span>
    <a id="_idIndexMarker866">
    </a>
    <span class="koboSpan" id="kobo.188.1">
     module was added in Python 3.6 and deals with three things: random numbers, tokens, and digest comparison.
    </span>
    <span class="koboSpan" id="kobo.188.2">
     It uses the most secure random number generators provided by the underlying operating system to generate tokens and random numbers suitable for use in cryptographic applications.
    </span>
    <span class="koboSpan" id="kobo.188.3">
     Let us have a quick look at what it provides.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-257">
    <span class="koboSpan" id="kobo.189.1">
     Random objects
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.190.1">
     We can
    </span>
    <a id="_idIndexMarker867">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     use three functions to produce random objects:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.192.1"># secrs/secr_rand.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.193.1">import</span></span><span class="koboSpan" id="kobo.194.1"> secrets
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.195.1">print</span></span><span class="koboSpan" id="kobo.196.1">(secrets.choice("Choose one of these words".split()))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.197.1">print</span></span><span class="koboSpan" id="kobo.198.1">(secrets.randbelow(</span><span class="hljs-number"><span class="koboSpan" id="kobo.199.1">10</span></span><span class="koboSpan" id="kobo.200.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.201.1">6</span></span><span class="koboSpan" id="kobo.202.1">))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.203.1">print</span></span><span class="koboSpan" id="kobo.204.1">(secrets.randbits(</span><span class="hljs-number"><span class="koboSpan" id="kobo.205.1">32</span></span><span class="koboSpan" id="kobo.206.1">))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.207.1">
     The first one,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.208.1">
      choice()
     </span>
    </code>
    <span class="koboSpan" id="kobo.209.1">
     , returns an element at random from a non-empty sequence.
    </span>
    <span class="koboSpan" id="kobo.209.2">
     The second,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.210.1">
      randbelow()
     </span>
    </code>
    <span class="koboSpan" id="kobo.211.1">
     , generates a random integer between 0 and the argument you call it with, and the third,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.212.1">
      randbits()
     </span>
    </code>
    <span class="koboSpan" id="kobo.213.1">
     , generates an integer with the given number of random bits in it.
    </span>
    <span class="koboSpan" id="kobo.213.2">
     Running that code produces the following output (which will, of course, be different every time it is run):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.214.1">$ python secr_rand.py
one
133025
1509555468
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.215.1">
     You should use these functions instead of those from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.216.1">
      random
     </span>
    </code>
    <span class="koboSpan" id="kobo.217.1">
     module whenever you need randomness in the context of cryptography, as these are specially designed for this task.
    </span>
    <span class="koboSpan" id="kobo.217.2">
     Let us see what the module provides for tokens.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-258">
    <span class="koboSpan" id="kobo.218.1">
     Token generation
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.219.1">
     Again, we
    </span>
    <a id="_idIndexMarker868">
    </a>
    <span class="koboSpan" id="kobo.220.1">
     have three functions for generating tokens, each in a different format.
    </span>
    <span class="koboSpan" id="kobo.220.2">
     Let us see the example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.221.1"># secrs/secr_rand.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.222.1">import</span></span><span class="koboSpan" id="kobo.223.1"> secrets
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.224.1">print</span></span><span class="koboSpan" id="kobo.225.1">(secrets.token_bytes(</span><span class="hljs-number"><span class="koboSpan" id="kobo.226.1">16</span></span><span class="koboSpan" id="kobo.227.1">))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.228.1">print</span></span><span class="koboSpan" id="kobo.229.1">(secrets.token_hex(</span><span class="hljs-number"><span class="koboSpan" id="kobo.230.1">32</span></span><span class="koboSpan" id="kobo.231.1">))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.232.1">print</span></span><span class="koboSpan" id="kobo.233.1">(secrets.token_urlsafe(</span><span class="hljs-number"><span class="koboSpan" id="kobo.234.1">32</span></span><span class="koboSpan" id="kobo.235.1">))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.236.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.237.1">
      token_bytes()
     </span>
    </code>
    <span class="koboSpan" id="kobo.238.1">
     function simply returns a random byte string containing the specified number of bytes (16, in this example).
    </span>
    <span class="koboSpan" id="kobo.238.2">
     The other two do the same, but
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.239.1">
      token_hex()
     </span>
    </code>
    <span class="koboSpan" id="kobo.240.1">
     returns a token in hexadecimal format, and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.241.1">
      token_urlsafe()
     </span>
    </code>
    <span class="koboSpan" id="kobo.242.1">
     returns a token that only contains characters suitable for being included in a URL.
    </span>
    <span class="koboSpan" id="kobo.242.2">
     Here is the output (which is a continuation of the previous run):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.243.1">b'\x0f\x8b\x8f\x0f\xe3\xceJ\xbc\x18\xf2\x1e\xe0i\xee1\x99'
98e80cddf6c371811318045672399b0950b8e3207d18b50d99d724d31d17f0a7
63eNkRalj8dgZqmkezjbEYoGddVcutgvwJthSLf5kho
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.244.1">
     Let us see
    </span>
    <a id="_idIndexMarker869">
    </a>
    <span class="koboSpan" id="kobo.245.1">
     how we can use these tools to write our own random password generator:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.246.1"># secrs/secr_gen.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.247.1">import</span></span><span class="koboSpan" id="kobo.248.1"> secrets
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.249.1">from</span></span><span class="koboSpan" id="kobo.250.1"> string </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.251.1">import</span></span><span class="koboSpan" id="kobo.252.1"> digits, ascii_letters
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.253.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.254.1">generate_pwd</span></span><span class="koboSpan" id="kobo.255.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.256.1">length=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.257.1">8</span></span><span class="koboSpan" id="kobo.258.1">):
    chars = digits + ascii_letters
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.259.1">return</span></span><span class="koboSpan" id="kobo.260.1"> "".join(secrets.choice(chars) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.261.1">for</span></span><span class="koboSpan" id="kobo.262.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.263.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.264.1">range</span></span><span class="koboSpan" id="kobo.265.1">(length))
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.266.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.267.1">generate_secure_pwd</span></span><span class="koboSpan" id="kobo.268.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.269.1">length=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.270.1">16</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.271.1">, upper=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.272.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.273.1">, digits=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.274.1">3</span></span><span class="koboSpan" id="kobo.275.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.276.1">if</span></span><span class="koboSpan" id="kobo.277.1"> length &lt; upper + digits + </span><span class="hljs-number"><span class="koboSpan" id="kobo.278.1">1</span></span><span class="koboSpan" id="kobo.279.1">:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.280.1">raise</span></span><span class="koboSpan" id="kobo.281.1"> ValueError(</span><span class="hljs-string"><span class="koboSpan" id="kobo.282.1">"Nice try!"</span></span><span class="koboSpan" id="kobo.283.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.284.1">while</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.285.1">True</span></span><span class="koboSpan" id="kobo.286.1">:
        pwd = generate_pwd(length)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.287.1">if</span></span><span class="koboSpan" id="kobo.288.1"> (
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.289.1">any</span></span><span class="koboSpan" id="kobo.290.1">(c.islower() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.291.1">for</span></span><span class="koboSpan" id="kobo.292.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.293.1">in</span></span><span class="koboSpan" id="kobo.294.1"> pwd)
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.295.1">and</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.296.1">sum</span></span><span class="koboSpan" id="kobo.297.1">(c.isupper() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.298.1">for</span></span><span class="koboSpan" id="kobo.299.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.300.1">in</span></span><span class="koboSpan" id="kobo.301.1"> pwd) &gt;= upper
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.302.1">and</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.303.1">sum</span></span><span class="koboSpan" id="kobo.304.1">(c.isdigit() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.305.1">for</span></span><span class="koboSpan" id="kobo.306.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.307.1">in</span></span><span class="koboSpan" id="kobo.308.1"> pwd) &gt;= digits
        ):
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.309.1">return</span></span><span class="koboSpan" id="kobo.310.1"> pwd
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.311.1">print</span></span><span class="koboSpan" id="kobo.312.1">(generate_secure_pwd())
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.313.1">print</span></span><span class="koboSpan" id="kobo.314.1">(generate_secure_pwd(length=</span><span class="hljs-number"><span class="koboSpan" id="kobo.315.1">3</span></span><span class="koboSpan" id="kobo.316.1">, upper=</span><span class="hljs-number"><span class="koboSpan" id="kobo.317.1">1</span></span><span class="koboSpan" id="kobo.318.1">, digits=</span><span class="hljs-number"><span class="koboSpan" id="kobo.319.1">1</span></span><span class="koboSpan" id="kobo.320.1">))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.321.1">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.322.1">
      generate_pwd()
     </span>
    </code>
    <span class="koboSpan" id="kobo.323.1">
     function simply generates a random string of a given length by joining together
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.324.1">
      length
     </span>
    </code>
    <span class="koboSpan" id="kobo.325.1">
     characters, picked at random from a string that contains all the letters of the alphabet (lowercase and uppercase), and the 10 decimal digits.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.326.1">
     Then, we define another function,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.327.1">
      generate_secure_pwd()
     </span>
    </code>
    <span class="koboSpan" id="kobo.328.1">
     , that simply keeps calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.329.1">
      generate_pwd()
     </span>
    </code>
    <span class="koboSpan" id="kobo.330.1">
     until the random string we get matches some basic requirements.
    </span>
    <span class="koboSpan" id="kobo.330.2">
     The password must be
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.331.1">
      length
     </span>
    </code>
    <span class="koboSpan" id="kobo.332.1">
     characters long, have at least one lowercase character,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.333.1">
      upper
     </span>
    </code>
    <span class="koboSpan" id="kobo.334.1">
     uppercase characters, and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.335.1">
      digits
     </span>
    </code>
    <span class="koboSpan" id="kobo.336.1">
     digits.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.337.1">
     If the total number of uppercase characters, lowercase characters, and digits specified by the parameters is greater than the length of the password we are generating, we can never satisfy the conditions.
    </span>
    <span class="koboSpan" id="kobo.337.2">
     We check for this before starting the loop and raise a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.338.1">
      ValueError
     </span>
    </code>
    <span class="koboSpan" id="kobo.339.1">
     if the given parameters would result in an infinite loop.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.340.1">
     The body
    </span>
    <a id="_idIndexMarker870">
    </a>
    <span class="koboSpan" id="kobo.341.1">
     of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.342.1">
      while
     </span>
    </code>
    <span class="koboSpan" id="kobo.343.1">
     loop is straightforward: first, we generate the random password, and then we verify the conditions by using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.344.1">
      any()
     </span>
    </code>
    <span class="koboSpan" id="kobo.345.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.346.1">
      sum()
     </span>
    </code>
    <span class="koboSpan" id="kobo.347.1">
     .
    </span>
    <span class="koboSpan" id="kobo.347.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.348.1">
      any()
     </span>
    </code>
    <span class="koboSpan" id="kobo.349.1">
     function returns
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.350.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.351.1">
     if any of the items in the iterable it is called with evaluate to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.352.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.353.1">
     .
    </span>
    <span class="koboSpan" id="kobo.353.2">
     The use of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.354.1">
      sum()
     </span>
    </code>
    <span class="koboSpan" id="kobo.355.1">
     is actually slightly trickier here, in that it exploits
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.356.1">
      polymorphism
     </span>
    </strong>
    <span class="koboSpan" id="kobo.357.1">
     .
    </span>
    <span class="koboSpan" id="kobo.357.2">
     As you
    </span>
    <a id="_idIndexMarker871">
    </a>
    <span class="koboSpan" id="kobo.358.1">
     may recall from
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.359.1">
      Chapter 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.360.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.361.1">
      Built-In Data Types
     </span>
    </em>
    <span class="koboSpan" id="kobo.362.1">
     , the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.363.1">
      bool
     </span>
    </code>
    <span class="koboSpan" id="kobo.364.1">
     type is a subclass of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.365.1">
      int
     </span>
    </code>
    <span class="koboSpan" id="kobo.366.1">
     , therefore when summing on an iterable of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.367.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.368.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.369.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.370.1">
     values, they will automatically be interpreted as integers (with the values 1 and 0) by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.371.1">
      sum()
     </span>
    </code>
    <span class="koboSpan" id="kobo.372.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.372.2">
     This is an example of polymorphism, which we briefly discussed in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.373.1">
      Chapter 6
     </span>
    </em>
    <span class="koboSpan" id="kobo.374.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.375.1">
      OOP, Decorators, and Iterators
     </span>
    </em>
    <span class="koboSpan" id="kobo.376.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.377.1">
     Running the example produces the following result:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.378.1">$ python secr_gen.py
mgQ3Hj57KjD1LI7M
b8G
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.379.1">
     Of course, you wouldn’t want to use a password of length 3.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.380.1">
     One common use of random tokens is in password reset URLs for websites.
    </span>
    <span class="koboSpan" id="kobo.380.2">
     Here is an example of how we can generate such a URL:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.381.1"># secrs/secr_reset.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.382.1">import</span></span><span class="koboSpan" id="kobo.383.1"> secrets
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.384.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.385.1">get_reset_pwd_url</span></span><span class="koboSpan" id="kobo.386.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.387.1">token_length=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.388.1">16</span></span><span class="koboSpan" id="kobo.389.1">):
    token = secrets.token_urlsafe(token_length)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.390.1">return</span></span><span class="koboSpan" id="kobo.391.1"> f"https://example.com/reset-pwd/{token}"
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.392.1">print</span></span><span class="koboSpan" id="kobo.393.1">(get_reset_pwd_url())
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.394.1">
     Running the above produced this output:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.395.1">$ python secr_reset.py
https://example.com/reset-pwd/ML_6_2wxDpXmDJLHrDnrRA
</span></code></pre>
   <h2 class="heading-2" id="_idParaDest-259">
    <span class="koboSpan" id="kobo.396.1">
     Digest comparison
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.397.1">
     This
    </span>
    <a id="_idIndexMarker872">
    </a>
    <span class="koboSpan" id="kobo.398.1">
     is probably quite surprising, but the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.399.1">
      secrets
     </span>
    </code>
    <span class="koboSpan" id="kobo.400.1">
     module also provides a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.401.1">
      compare_digest(a, b)
     </span>
    </code>
    <span class="koboSpan" id="kobo.402.1">
     function, which is the equivalent of comparing two digests by simply doing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.403.1">
      a == b
     </span>
    </code>
    <span class="koboSpan" id="kobo.404.1">
     .
    </span>
    <span class="koboSpan" id="kobo.404.2">
     So, why would we need that function?
    </span>
    <span class="koboSpan" id="kobo.404.3">
     It is because it has been designed to prevent timing attacks.
    </span>
    <span class="koboSpan" id="kobo.404.4">
     These kinds of attacks can infer information about where the two digests start being different, according to the time it takes for the comparison to fail.
    </span>
    <span class="koboSpan" id="kobo.404.5">
     So,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.405.1">
      compare_digest()
     </span>
    </code>
    <span class="koboSpan" id="kobo.406.1">
     prevents this attack by removing the correlation between time and failures.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     We think this is a brilliant example of how sophisticated attacking methods can be.
    </span>
    <span class="koboSpan" id="kobo.406.3">
     If you raised your eyebrows in astonishment, maybe now it is clearer why we said never to implement cryptography functions by yourself.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.407.1">
     This brings us to the end of our tour of the cryptographic services in the Python standard library.
    </span>
    <span class="koboSpan" id="kobo.407.2">
     Now, let us move on to a different type of token: JWTs.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-260">
    <span class="koboSpan" id="kobo.408.1">
     JSON Web Tokens
    </span>
   </h1>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.409.1">
      JSON Web Token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.410.1">
     , or
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.411.1">
      JWT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.412.1">
     , is a
    </span>
    <a id="_idIndexMarker873">
    </a>
    <span class="koboSpan" id="kobo.413.1">
     JSON-based open standard for creating tokens that assert a
    </span>
    <a id="_idIndexMarker874">
    </a>
    <span class="koboSpan" id="kobo.414.1">
     number of
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.415.1">
      claims
     </span>
    </strong>
    <span class="koboSpan" id="kobo.416.1">
     .
    </span>
    <span class="koboSpan" id="kobo.416.2">
     JWTs are frequently used as authentication tokens.
    </span>
    <span class="koboSpan" id="kobo.416.3">
     In this context, the claims typically are statements about the identity and permissions of an authenticated user.
    </span>
    <span class="koboSpan" id="kobo.416.4">
     The tokens are cryptographically signed, which makes it possible to verify that the content of the token has not been modified since it was issued.
    </span>
    <span class="koboSpan" id="kobo.416.5">
     You
    </span>
    <a id="_idIndexMarker875">
    </a>
    <span class="koboSpan" id="kobo.417.1">
     can learn all about this technology on the website (
    </span>
    <a href="https://jwt.io">
     <span class="url">
      <span class="koboSpan" id="kobo.418.1">
       https://jwt.io
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.419.1">
     ).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.420.1">
     This type of token consists of three sections, joined together by dots, in the format
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.421.1">
      A.B.C
     </span>
    </em>
    <span class="koboSpan" id="kobo.422.1">
     .
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.423.1">
      B
     </span>
    </em>
    <span class="koboSpan" id="kobo.424.1">
     is the payload, which is where we put the claims.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.425.1">
      C
     </span>
    </em>
    <span class="koboSpan" id="kobo.426.1">
     is the signature, which is used to verify the validity of the token, and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.427.1">
      A
     </span>
    </em>
    <span class="koboSpan" id="kobo.428.1">
     is a header, which identifies the token as a JWT, and indicates the algorithm used to compute the signature.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.429.1">
      A
     </span>
    </em>
    <span class="koboSpan" id="kobo.430.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.431.1">
      B
     </span>
    </em>
    <span class="koboSpan" id="kobo.432.1">
     , and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.433.1">
      C
     </span>
    </em>
    <span class="koboSpan" id="kobo.434.1">
     are all encoded with a URL-safe Base64 encoding (which we will refer to as Base64URL).
    </span>
    <span class="koboSpan" id="kobo.434.2">
     The Base64URL encoding makes it possible to use JWTs as part of URLs (typically as query parameters); however, JWTs do also appear in other places, including HTTP headers.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.435.1">
       Base64
      </span>
     </code>
     <span class="koboSpan" id="kobo.436.1">
      is a popular binary-to-text encoding scheme that represents binary data in an ASCII string format by translating it into a Radix-64 representation.
     </span>
     <span class="koboSpan" id="kobo.436.2">
      The Radix-64 representation uses the letters A-Z, a-z, and the digits 0-9, plus the two symbols + and /, giving a total of 64 symbols.
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.437.1">
       Base64
      </span>
     </code>
     <span class="koboSpan" id="kobo.438.1">
      is used, for example, to encode images attached to an email.
     </span>
     <span class="koboSpan" id="kobo.438.2">
      It happens seamlessly, so the vast majority of users are completely oblivious to this fact.
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.439.1">
       Base64URL
      </span>
     </code>
     <span class="koboSpan" id="kobo.440.1">
      is a variant of
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.441.1">
       Base64
      </span>
     </code>
     <span class="koboSpan" id="kobo.442.1">
      encoding where the + and / characters (which have specific meanings in the context of a URL) are replaced with - and _.
     </span>
     <span class="koboSpan" id="kobo.442.2">
      The = character (which is used for padding in
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.443.1">
       Base64
      </span>
     </code>
     <span class="koboSpan" id="kobo.444.1">
      ) also has a special meaning within URLs and is omitted in
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.445.1">
       Base64URL
      </span>
     </code>
     <span class="koboSpan" id="kobo.446.1">
      .
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.447.1">
     The
    </span>
    <a id="_idIndexMarker876">
    </a>
    <span class="koboSpan" id="kobo.448.1">
     way this type of token works is slightly different from what we have seen so far in this chapter.
    </span>
    <span class="koboSpan" id="kobo.448.2">
     In fact, the information that the token carries is always visible.
    </span>
    <span class="koboSpan" id="kobo.448.3">
     You just need to decode
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.449.1">
      A
     </span>
    </em>
    <span class="koboSpan" id="kobo.450.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.451.1">
      B
     </span>
    </em>
    <span class="koboSpan" id="kobo.452.1">
     from Base64URL to get the algorithm and the payload.
    </span>
    <span class="koboSpan" id="kobo.452.2">
     The security lies in part
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.453.1">
      C
     </span>
    </em>
    <span class="koboSpan" id="kobo.454.1">
     , which is an HMAC signature of the header and payload.
    </span>
    <span class="koboSpan" id="kobo.454.2">
     If you try to modify either the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.455.1">
      A
     </span>
    </em>
    <span class="koboSpan" id="kobo.456.1">
     or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.457.1">
      B
     </span>
    </em>
    <span class="koboSpan" id="kobo.458.1">
     part by editing the header or the payload, encoding it back to Base64URL, and replacing it in the token, the signature will not match, and therefore the token will be invalid.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.459.1">
     This means that we can build a payload with claims such as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.460.1">
      logged in as admin
     </span>
    </em>
    <span class="koboSpan" id="kobo.461.1">
     , or something along those lines, and as long as the token is valid, we know we can trust that that user is logged in as an admin.
    </span>
   </p>
   <div class="packt_tip">
    <p class="normal">
     <span class="koboSpan" id="kobo.462.1">
      When dealing with JWTs, you want to make sure you have researched how to handle them safely.
     </span>
     <span class="koboSpan" id="kobo.462.2">
      Things like not accepting unsigned tokens or restricting the list of algorithms you use to encode and decode, as well as other security measures, are very important and you should take the time to investigate and learn them.
     </span>
    </p>
    <p class="normal">
     <span class="koboSpan" id="kobo.463.1">
      For this part of the code, you will have to have the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.464.1">
       PyJWT
      </span>
     </code>
     <span class="koboSpan" id="kobo.465.1">
      and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.466.1">
       cryptography
      </span>
     </code>
     <span class="koboSpan" id="kobo.467.1">
      Python packages installed.
     </span>
     <span class="koboSpan" id="kobo.467.2">
      As always, you will find them in the requirements of the source code for this chapter.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.468.1">
     Let us start with a simple example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.469.1"># jwt/tok.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.470.1">import</span></span><span class="koboSpan" id="kobo.471.1"> jwt
data = {"payload": "data", "id": </span><span class="hljs-number"><span class="koboSpan" id="kobo.472.1">123456789</span></span><span class="koboSpan" id="kobo.473.1">}
algs = ["HS256", "HS512"]
token = jwt.encode(data, "secret-key")
data_out = jwt.decode(token, "secret-key", algorithms=algs)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.474.1">print</span></span><span class="koboSpan" id="kobo.475.1">(token)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.476.1">print</span></span><span class="koboSpan" id="kobo.477.1">(data_out)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.478.1">
     We
    </span>
    <a id="_idIndexMarker877">
    </a>
    <span class="koboSpan" id="kobo.479.1">
     define the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.480.1">
      data
     </span>
    </code>
    <span class="koboSpan" id="kobo.481.1">
     payload, which contains an ID and some payload data.
    </span>
    <span class="koboSpan" id="kobo.481.2">
     We create a token using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.482.1">
      jwt.encode()
     </span>
    </code>
    <span class="koboSpan" id="kobo.483.1">
     function, which takes the payload and a secret key.
    </span>
    <span class="koboSpan" id="kobo.483.2">
     The secret key is used to generate the HMAC signature of the token header and payload.
    </span>
    <span class="koboSpan" id="kobo.483.3">
     Next, we decode the token again, specifying the signature algorithms that we are willing to accept.
    </span>
    <span class="koboSpan" id="kobo.483.4">
     The default algorithm used to calculate the token is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.484.1">
      HS256
     </span>
    </code>
    <span class="koboSpan" id="kobo.485.1">
     ; in this example, we accept either
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.486.1">
      HS256
     </span>
    </code>
    <span class="koboSpan" id="kobo.487.1">
     or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.488.1">
      HS512
     </span>
    </code>
    <span class="koboSpan" id="kobo.489.1">
     when decoding (if the token had been generated using a different algorithm, it would be rejected with an exception).
    </span>
    <span class="koboSpan" id="kobo.489.2">
     Here is the output:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.490.1">$ python jwt/tok.py
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXlsb2FkIjoiZGF0YSIsIm...
</span><span class="koboSpan" id="kobo.490.2">{'payload': 'data', 'id': 123456789}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.491.1">
     As you can see, the token is a binary string of Base64URL-encoded pieces of data (abridged to fit on one line).
    </span>
    <span class="koboSpan" id="kobo.491.2">
     We called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.492.1">
      jwt.decode()
     </span>
    </code>
    <span class="koboSpan" id="kobo.493.1">
     , providing the correct secret key.
    </span>
    <span class="koboSpan" id="kobo.493.2">
     If we had supplied the wrong key, we would have gotten an error, since the signature can only be verified with the same secret that was used to generate it.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.494.1">
      JWTs are often used to transmit information between two parties.
     </span>
     <span class="koboSpan" id="kobo.494.2">
      For example, authentication protocols that allow websites to rely on third-party identity providers to authenticate users often use JWTs.
     </span>
     <span class="koboSpan" id="kobo.494.3">
      In such cases, the secret key used to sign tokens needs to be shared between the two parties.
     </span>
     <span class="koboSpan" id="kobo.494.4">
      Therefore, it is often
     </span>
     <a id="_idIndexMarker878">
     </a>
     <span class="koboSpan" id="kobo.495.1">
      referred to as a
     </span>
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.496.1">
       shared secret
      </span>
     </strong>
     <span class="koboSpan" id="kobo.497.1">
      .
     </span>
    </p>
    <p class="normal">
     <span class="koboSpan" id="kobo.498.1">
      Care must be taken to protect the shared secret since anyone with access to it can generate valid tokens.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.499.1">
     Sometimes, you might want to be able to inspect the content of the token without verifying the signature first.
    </span>
    <span class="koboSpan" id="kobo.499.2">
     You can do so by simply calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.500.1">
      decode()
     </span>
    </code>
    <span class="koboSpan" id="kobo.501.1">
     this way:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.502.1"># jwt/tok.py</span></span><span class="koboSpan" id="kobo.503.1">
jwt.decode(token, options={"verify_signature": </span><span class="hljs-literal"><span class="koboSpan" id="kobo.504.1">False</span></span><span class="koboSpan" id="kobo.505.1">})
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.506.1">
     This is useful, for example, when values in the token payload are needed to recover the secret key, but that technique is quite advanced so we will not be spending time on it in this context.
    </span>
    <span class="koboSpan" id="kobo.506.2">
     Instead, let us see how we can specify a different algorithm for computing the signature:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.507.1"># jwt/tok.py</span></span><span class="koboSpan" id="kobo.508.1">
token512 = jwt.encode(data, "secret-key", algorithm="HS512")
data_out = jwt.decode(
    token512, "secret-key", algorithms=["HS512"]
)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.509.1">print</span></span><span class="koboSpan" id="kobo.510.1">(data_out)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.511.1">
     Here, we
    </span>
    <a id="_idIndexMarker879">
    </a>
    <span class="koboSpan" id="kobo.512.1">
     have used the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.513.1">
      HS512
     </span>
    </code>
    <span class="koboSpan" id="kobo.514.1">
     algorithm to generate the token and, on decoding, specified that we would only accept tokens generated using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.515.1">
      HS512
     </span>
    </code>
    <span class="koboSpan" id="kobo.516.1">
     algorithm.
    </span>
    <span class="koboSpan" id="kobo.516.2">
     The output is the original payload dictionary.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.517.1">
     Now, while you are free to put whatever you want in the token payload, there are some claims that have been standardized; they are essential for ensuring security, consistency, and interoperability across different systems and applications.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-261">
    <span class="koboSpan" id="kobo.518.1">
     Registered claims
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.519.1">
     The JWT standard
    </span>
    <a id="_idIndexMarker880">
    </a>
    <span class="koboSpan" id="kobo.520.1">
     defines the following
    </span>
    <a id="_idIndexMarker881">
    </a>
    <span class="koboSpan" id="kobo.521.1">
     official
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.522.1">
      registered claims
     </span>
    </strong>
    <span class="koboSpan" id="kobo.523.1">
     :
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.524.1">
       iss
      </span>
     </code>
     <span class="koboSpan" id="kobo.525.1">
      : The issuer of the token
     </span>
    </li>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.526.1">
       sub
      </span>
     </code>
     <span class="koboSpan" id="kobo.527.1">
      : The subject information about the party this token is carrying information about
     </span>
    </li>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.528.1">
       aud
      </span>
     </code>
     <span class="koboSpan" id="kobo.529.1">
      : The audience for the token
     </span>
    </li>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.530.1">
       exp
      </span>
     </code>
     <span class="koboSpan" id="kobo.531.1">
      : The expiration time, after which the token is invalid
     </span>
    </li>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.532.1">
       nbf
      </span>
     </code>
     <span class="koboSpan" id="kobo.533.1">
      : The not before (time), or the time before which the token is not considered to be valid yet
     </span>
    </li>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.534.1">
       iat
      </span>
     </code>
     <span class="koboSpan" id="kobo.535.1">
      : The time at which the token was issued
     </span>
    </li>
    <li class="bulletList">
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.536.1">
       jti
      </span>
     </code>
     <span class="koboSpan" id="kobo.537.1">
      : The token ID
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.538.1">
     Claims that are not defined in the standard can be categorized as public or private:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.539.1">
       Public
      </span>
     </strong>
     <span class="koboSpan" id="kobo.540.1">
      : Claims
     </span>
     <a id="_idIndexMarker882">
     </a>
     <span class="koboSpan" id="kobo.541.1">
      that are publicly allocated for a particular purpose.
     </span>
     <span class="koboSpan" id="kobo.541.2">
      Public claim names can be reserved by registering them with the IANA JSON Web Token Claims Registry.
     </span>
     <span class="koboSpan" id="kobo.541.3">
      Alternatively, the claims should be named in a way that ensures that they do not clash with any other public or official claim names (one way of achieving this could be to prepend a registered domain name to the claim name).
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.542.1">
       Private
      </span>
     </strong>
     <span class="koboSpan" id="kobo.543.1">
      : Any
     </span>
     <a id="_idIndexMarker883">
     </a>
     <span class="koboSpan" id="kobo.544.1">
      other claims that do not fall under the above category are referred to as private claims.
     </span>
     <span class="koboSpan" id="kobo.544.2">
      The meaning of such claims is typically defined within the context of a particular application, and they are meaningless outside that context.
     </span>
     <span class="koboSpan" id="kobo.544.3">
      To prevent ambiguity and confusion, care must be taken to avoid name clashes.
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.545.1">
     To learn about
    </span>
    <a id="_idIndexMarker884">
    </a>
    <span class="koboSpan" id="kobo.546.1">
     claims, please refer to the official website.
    </span>
    <span class="koboSpan" id="kobo.546.2">
     Now, let us see a couple of code examples involving a subset of these claims.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-262">
    <span class="koboSpan" id="kobo.547.1">
     Time-related claims
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.548.1">
     This is
    </span>
    <a id="_idIndexMarker885">
    </a>
    <span class="koboSpan" id="kobo.549.1">
     how we might use the claims related
    </span>
    <a id="_idIndexMarker886">
    </a>
    <span class="koboSpan" id="kobo.550.1">
     to time:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.551.1"># jwt/claims_time.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.552.1">from</span></span><span class="koboSpan" id="kobo.553.1"> datetime </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.554.1">import</span></span><span class="koboSpan" id="kobo.555.1"> datetime, timedelta, UTC
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.556.1">from</span></span><span class="koboSpan" id="kobo.557.1"> time </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.558.1">import</span></span><span class="koboSpan" id="kobo.559.1"> sleep, time
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.560.1">import</span></span><span class="koboSpan" id="kobo.561.1"> jwt
iat = datetime.now(tz=UTC)
nfb = iat + timedelta(seconds=</span><span class="hljs-number"><span class="koboSpan" id="kobo.562.1">1</span></span><span class="koboSpan" id="kobo.563.1">)
exp = iat + timedelta(seconds=</span><span class="hljs-number"><span class="koboSpan" id="kobo.564.1">3</span></span><span class="koboSpan" id="kobo.565.1">)
data = {"payload": "data", "nbf": nfb, "exp": exp, "iat": iat}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.566.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.567.1">decode</span></span><span class="koboSpan" id="kobo.568.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.569.1">token, secret</span></span><span class="koboSpan" id="kobo.570.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.571.1">print</span></span><span class="koboSpan" id="kobo.572.1">(f"{time():</span><span class="hljs-number"><span class="koboSpan" id="kobo.573.1">.2</span></span><span class="koboSpan" id="kobo.574.1">f}")
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.575.1">try</span></span><span class="koboSpan" id="kobo.576.1">:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.577.1">print</span></span><span class="koboSpan" id="kobo.578.1">(jwt.decode(token, secret, algorithms=["HS256"]))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.579.1">except</span></span><span class="koboSpan" id="kobo.580.1"> (
        jwt.ImmatureSignatureError,
        jwt.ExpiredSignatureError,
    ) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.581.1">as</span></span><span class="koboSpan" id="kobo.582.1"> err:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.583.1">print</span></span><span class="koboSpan" id="kobo.584.1">(err)
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.585.1">print</span></span><span class="koboSpan" id="kobo.586.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.587.1">type</span></span><span class="koboSpan" id="kobo.588.1">(err))
secret = "secret-key"
token = jwt.encode(data, secret)
decode(token, secret)
sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.589.1">2</span></span><span class="koboSpan" id="kobo.590.1">)
decode(token, secret)
sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.591.1">2</span></span><span class="koboSpan" id="kobo.592.1">)
decode(token, secret)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.593.1">
     In this example, we
    </span>
    <a id="_idIndexMarker887">
    </a>
    <span class="koboSpan" id="kobo.594.1">
     set the issued at (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.595.1">
      iat
     </span>
    </code>
    <span class="koboSpan" id="kobo.596.1">
     ) claim to the current UTC time (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.597.1">
      UTC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.598.1">
     stands for
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.599.1">
      Coordinated Universal Time
     </span>
    </strong>
    <span class="koboSpan" id="kobo.600.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.600.2">
     We then set the “not before” (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.601.1">
      nbf
     </span>
    </code>
    <span class="koboSpan" id="kobo.602.1">
     ) and “expire time” (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.603.1">
      exp
     </span>
    </code>
    <span class="koboSpan" id="kobo.604.1">
     ) claims to 1 and 3 seconds from now, respectively.
    </span>
    <span class="koboSpan" id="kobo.604.2">
     We define a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.605.1">
      decode()
     </span>
    </code>
    <span class="koboSpan" id="kobo.606.1">
     helper function that reacts to a token not being valid yet, or being expired, by trapping the appropriate exceptions, and then we call it three times, interspersed by two calls to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.607.1">
      sleep()
     </span>
    </code>
    <span class="koboSpan" id="kobo.608.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.609.1">
     This way, we
    </span>
    <a id="_idIndexMarker888">
    </a>
    <span class="koboSpan" id="kobo.610.1">
     will try to decode the token before it is valid, then when it is valid, and finally, after it has expired.
    </span>
    <span class="koboSpan" id="kobo.610.2">
     This function also prints a useful timestamp before attempting to decode the token.
    </span>
    <span class="koboSpan" id="kobo.610.3">
     Let us see how it goes (blank lines have been added for readability):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.611.1">$ python jwt/claims_time.py
1716674892.39
The token is not yet valid (nbf)
&lt;class 'jwt.exceptions.ImmatureSignatureError'&gt;
1716674894.39
{'payload': 'data', 'nbf': 1716674893, 'exp': 1716674895, 'iat': 1716674892}
1716674896.39
Signature has expired
&lt;class 'jwt.exceptions.ExpiredSignatureError'&gt;
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.612.1">
     As you can see, it executed as expected.
    </span>
    <span class="koboSpan" id="kobo.612.2">
     We get descriptive messages from the exceptions and get the original payload back when the token is valid.
    </span>
   </p>
   <h3 class="heading-3" id="_idParaDest-263">
    <span class="koboSpan" id="kobo.613.1">
     Authentication-related claims
    </span>
   </h3>
   <p class="normal">
    <span class="koboSpan" id="kobo.614.1">
     Here we
    </span>
    <a id="_idIndexMarker889">
    </a>
    <span class="koboSpan" id="kobo.615.1">
     have another quick
    </span>
    <a id="_idIndexMarker890">
    </a>
    <span class="koboSpan" id="kobo.616.1">
     example, this time, involving the issuer (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.617.1">
      iss
     </span>
    </code>
    <span class="koboSpan" id="kobo.618.1">
     ) and audience (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.619.1">
      aud
     </span>
    </code>
    <span class="koboSpan" id="kobo.620.1">
     ) claims.
    </span>
    <span class="koboSpan" id="kobo.620.2">
     The code is conceptually very similar to the previous example, and we are going to exercise it in the same way:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.621.1"># jwt/claims_auth.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.622.1">import</span></span><span class="koboSpan" id="kobo.623.1"> jwt
data = {"payload": "data", "iss": "hein", "aud": "learn-python"}
secret = "secret-key"
token = jwt.encode(data, secret)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.624.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.625.1">decode</span></span><span class="koboSpan" id="kobo.626.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.627.1">token, secret, issuer=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.628.1">None</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.629.1">, audience=</span></span><span class="hljs-literal"><span class="koboSpan" id="kobo.630.1">None</span></span><span class="koboSpan" id="kobo.631.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.632.1">try</span></span><span class="koboSpan" id="kobo.633.1">:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.634.1">print</span></span><span class="koboSpan" id="kobo.635.1">(
            jwt.decode(
                token,
                secret,
                issuer=issuer,
                audience=audience,
                algorithms=["HS256"],
            )
        )
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.636.1">except</span></span><span class="koboSpan" id="kobo.637.1"> (
        jwt.InvalidIssuerError,
        jwt.InvalidAudienceError,
    ) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.638.1">as</span></span><span class="koboSpan" id="kobo.639.1"> err:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.640.1">print</span></span><span class="koboSpan" id="kobo.641.1">(err)
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.642.1">print</span></span><span class="koboSpan" id="kobo.643.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.644.1">type</span></span><span class="koboSpan" id="kobo.645.1">(err))
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.646.1"># Not providing both the audience and issuer will fail</span></span><span class="koboSpan" id="kobo.647.1">
decode(token, secret)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.648.1"># Not providing the issuer will succeed</span></span><span class="koboSpan" id="kobo.649.1">
decode(token, secret, audience="learn-python")
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.650.1"># Not providing the audience will fail</span></span><span class="koboSpan" id="kobo.651.1">
decode(token, secret, issuer="hein")
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.652.1"># Both will fail</span></span><span class="koboSpan" id="kobo.653.1">
decode(token, secret, issuer="wrong", audience="learn-python")
decode(token, secret, issuer="hein", audience="wrong")
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.654.1"># This will succeed</span></span><span class="koboSpan" id="kobo.655.1">
decode(token, secret, issuer="hein", audience="learn-python")
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.656.1">
     As you
    </span>
    <a id="_idIndexMarker891">
    </a>
    <span class="koboSpan" id="kobo.657.1">
     can see, this time, we
    </span>
    <a id="_idIndexMarker892">
    </a>
    <span class="koboSpan" id="kobo.658.1">
     specified both issuer (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.659.1">
      iss
     </span>
    </code>
    <span class="koboSpan" id="kobo.660.1">
     ) and audience (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.661.1">
      aud
     </span>
    </code>
    <span class="koboSpan" id="kobo.662.1">
     ) when creating the token.
    </span>
    <span class="koboSpan" id="kobo.662.2">
     Decoding this token succeeds even if we omit the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.663.1">
      issuer
     </span>
    </code>
    <span class="koboSpan" id="kobo.664.1">
     argument to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.665.1">
      jwt.decode()
     </span>
    </code>
    <span class="koboSpan" id="kobo.666.1">
     .
    </span>
    <span class="koboSpan" id="kobo.666.2">
     However, if the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.667.1">
      issuer
     </span>
    </code>
    <span class="koboSpan" id="kobo.668.1">
     is provided but does not match the iss field in the token, decoding fails.
    </span>
    <span class="koboSpan" id="kobo.668.2">
     On the other hand, if the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.669.1">
      audience
     </span>
    </code>
    <span class="koboSpan" id="kobo.670.1">
     argument is omitted or does not match the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.671.1">
      aud
     </span>
    </code>
    <span class="koboSpan" id="kobo.672.1">
     field in the token,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.673.1">
      jwt.decode()
     </span>
    </code>
    <span class="koboSpan" id="kobo.674.1">
     will fail.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.675.1">
     As in the previous example, we have written a custom
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.676.1">
      decode()
     </span>
    </code>
    <span class="koboSpan" id="kobo.677.1">
     function that reacts to the appropriate exceptions.
    </span>
    <span class="koboSpan" id="kobo.677.2">
     See if you can follow along with the calls and the relative output that follows (we will help with some blank lines):
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.678.1">$ python jwt/claims_time.py
Invalid audience
&lt;class 'jwt.exceptions.InvalidAudienceError'&gt;
{'payload': 'data', 'iss': 'hein', 'aud': 'learn-python'}
Invalid audience
&lt;class 'jwt.exceptions.InvalidAudienceError'&gt;
Invalid issuer
&lt;class 'jwt.exceptions.InvalidIssuerError'&gt;
Audience doesn't match
&lt;class 'jwt.exceptions.InvalidAudienceError'&gt;
{'payload': 'data', 'iss': 'hein', 'aud': 'learn-python'}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.679.1">
     Note that, in this
    </span>
    <a id="_idIndexMarker893">
    </a>
    <span class="koboSpan" id="kobo.680.1">
     example, we
    </span>
    <a id="_idIndexMarker894">
    </a>
    <span class="koboSpan" id="kobo.681.1">
     varied the arguments to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.682.1">
      jwt.decode()
     </span>
    </code>
    <span class="koboSpan" id="kobo.683.1">
     to show you the behavior in various scenarios.
    </span>
    <span class="koboSpan" id="kobo.683.2">
     In real-world usage, however, you would typically use fixed values for both
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.684.1">
      audience
     </span>
    </code>
    <span class="koboSpan" id="kobo.685.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.686.1">
      issuer
     </span>
    </code>
    <span class="koboSpan" id="kobo.687.1">
     and reject any tokens that cannot be decoded successfully.
    </span>
    <span class="koboSpan" id="kobo.687.2">
     Omitting the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.688.1">
      issuer
     </span>
    </code>
    <span class="koboSpan" id="kobo.689.1">
     when decoding means you will accept tokens from any issuer.
    </span>
    <span class="koboSpan" id="kobo.689.2">
     Omitting the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.690.1">
      audience
     </span>
    </code>
    <span class="koboSpan" id="kobo.691.1">
     means you will only accept tokens that do not specify an audience.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.692.1">
     Now, let us see one final example for a more complex use case.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-264">
    <span class="koboSpan" id="kobo.693.1">
     Using asymmetric (public key) algorithms
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.694.1">
     Sometimes, using
    </span>
    <a id="_idIndexMarker895">
    </a>
    <span class="koboSpan" id="kobo.695.1">
     a shared secret is not the best option.
    </span>
    <span class="koboSpan" id="kobo.695.2">
     In such cases, it is possible to use an asymmetric key
    </span>
    <a id="_idIndexMarker896">
    </a>
    <span class="koboSpan" id="kobo.696.1">
     pair instead of HMAC to generate the JWT signature.
    </span>
    <span class="koboSpan" id="kobo.696.2">
     In this example, we are going to create a token (and decode it) using an
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.697.1">
      RSA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.698.1">
     key pair.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.699.1">
     Public key cryptography, or asymmetrical cryptography, is any cryptographic system that uses pairs of keys: public keys, which may be disseminated widely, and private keys, which are known only to the owner.
    </span>
    <span class="koboSpan" id="kobo.699.2">
     If you are interested in learning more about this topic, please see the end of this chapter for recommendations.
    </span>
    <span class="koboSpan" id="kobo.699.3">
     A signature can be generated using the private key, and the public key can be used to verify the signature.
    </span>
    <span class="koboSpan" id="kobo.699.4">
     Thus, two parties can exchange JWTs and the signatures can be verified without any need for a shared secret.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.700.1">
     First, let us create an RSA key pair.
    </span>
    <span class="koboSpan" id="kobo.700.2">
     We are going
    </span>
    <a id="_idIndexMarker897">
    </a>
    <span class="koboSpan" id="kobo.701.1">
     to use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.702.1">
      ssh-keygen
     </span>
    </code>
    <span class="koboSpan" id="kobo.703.1">
     utility from OpenSSH (
    </span>
    <a href="https://www.ssh.com/academy/ssh/keygen">
     <span class="url">
      <span class="koboSpan" id="kobo.704.1">
       https://www.ssh.com/academy/ssh/keygen
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.705.1">
     ) to do this.
    </span>
    <span class="koboSpan" id="kobo.705.2">
     In the folder where our scripts for this chapter are, we created a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.706.1">
      jwt/rsa
     </span>
    </code>
    <span class="koboSpan" id="kobo.707.1">
     subfolder.
    </span>
    <span class="koboSpan" id="kobo.707.2">
     Within it, run the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.708.1">$ ssh-keygen -t rsa –m PEM
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.709.1">
     Give
    </span>
    <a id="_idIndexMarker898">
    </a>
    <span class="koboSpan" id="kobo.710.1">
     the name
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.711.1">
      key
     </span>
    </code>
    <span class="koboSpan" id="kobo.712.1">
     when
    </span>
    <a id="_idIndexMarker899">
    </a>
    <span class="koboSpan" id="kobo.713.1">
     asked for a filename (it will be saved in the current folder), and simply hit the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.714.1">
      Enter
     </span>
    </em>
    <span class="koboSpan" id="kobo.715.1">
     key when asked for a passphrase.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.716.1">
     Having generated our keys, we can now change back to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.717.1">
      ch09
     </span>
    </code>
    <span class="koboSpan" id="kobo.718.1">
     folder and run this code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.719.1"># jwt/token_rsa.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.720.1">import</span></span><span class="koboSpan" id="kobo.721.1"> jwt
data = {"payload": "data"}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.722.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.723.1">encode</span></span><span class="koboSpan" id="kobo.724.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.725.1">data, priv_filename, algorithm="RS256"</span></span><span class="koboSpan" id="kobo.726.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.727.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.728.1">open</span></span><span class="koboSpan" id="kobo.729.1">(priv_filename, "rb") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.730.1">as</span></span><span class="koboSpan" id="kobo.731.1"> key:
        private_key = key.read()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.732.1">return</span></span><span class="koboSpan" id="kobo.733.1"> jwt.encode(data, private_key, algorithm=algorithm)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.734.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.735.1">decode</span></span><span class="koboSpan" id="kobo.736.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.737.1">data, pub_filename, algorithm="RS256"</span></span><span class="koboSpan" id="kobo.738.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.739.1">with</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.740.1">open</span></span><span class="koboSpan" id="kobo.741.1">(pub_filename, "rb") </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.742.1">as</span></span><span class="koboSpan" id="kobo.743.1"> key:
        public_key = key.read()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.744.1">return</span></span><span class="koboSpan" id="kobo.745.1"> jwt.decode(data, public_key, algorithms=[algorithm])
token = encode(data, "jwt/rsa/key")
data_out = decode(token, "jwt/rsa/key.pub")
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.746.1">print</span></span><span class="koboSpan" id="kobo.747.1">(data_out)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.748.1"># {'payload': 'data'}</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.749.1">
     In this example, we defined a couple of custom functions to encode and decode tokens using private/public keys.
    </span>
    <span class="koboSpan" id="kobo.749.2">
     As you can see in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.750.1">
      encode()
     </span>
    </code>
    <span class="koboSpan" id="kobo.751.1">
     function, we are using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.752.1">
      RS256
     </span>
    </code>
    <span class="koboSpan" id="kobo.753.1">
     algorithm this time.
    </span>
    <span class="koboSpan" id="kobo.753.2">
     Notice that when we encode, we provide the private key, which is used to generate the JWT signature.
    </span>
    <span class="koboSpan" id="kobo.753.3">
     When we decode the JWT, we instead supply the public key, which is used to verify the signature.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.754.1">
     The logic is straightforward, and we would encourage you to think about at least one use case where this technique might be more suitable than using a shared key.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-265">
    <span class="koboSpan" id="kobo.755.1">
     Useful references
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.756.1">
     Here, you can find a list of useful references if you want to dig deeper into the fascinating world of cryptography:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.757.1">
      Cryptography:
     </span>
     <a href="https://en.wikipedia.org/wiki/Cryptography">
      <span class="url">
       <span class="koboSpan" id="kobo.758.1">
        https://en.wikipedia.org/wiki/Cryptography
       </span>
      </span>
     </a>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.759.1">
      JSON Web Tokens:
     </span>
     <a href="https://jwt.io">
      <span class="url">
       <span class="koboSpan" id="kobo.760.1">
        https://jwt.io
       </span>
      </span>
     </a>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.761.1">
      RFC standard for JSON Web Tokens:
     </span>
     <a href="https://datatracker.ietf.org/doc/html/rfc7519">
      <span class="url">
       <span class="koboSpan" id="kobo.762.1">
        https://datatracker.ietf.org/doc/html/rfc7519
       </span>
      </span>
     </a>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.763.1">
      Hash functions:
     </span>
     <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">
      <span class="url">
       <span class="koboSpan" id="kobo.764.1">
        https://en.wikipedia.org/wiki/Cryptographic_hash_function
       </span>
      </span>
     </a>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.765.1">
      HMAC:
     </span>
     <a href="https://en.wikipedia.org/wiki/HMAC">
      <span class="url">
       <span class="koboSpan" id="kobo.766.1">
        https://en.wikipedia.org/wiki/HMAC
       </span>
      </span>
     </a>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.767.1">
      Cryptography services (Python STD library):
     </span>
     <a href="https://docs.python.org/3/library/crypto.html">
      <span class="url">
       <span class="koboSpan" id="kobo.768.1">
        https://docs.python.org/3/library/crypto.html
       </span>
      </span>
     </a>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.769.1">
      IANA JSON Web Token Claims Registry:
     </span>
     <a href="https://www.iana.org/assignments/jwt/jwt.xhtml">
      <span class="url">
       <span class="koboSpan" id="kobo.770.1">
        https://www.iana.org/assignments/jwt/jwt.xhtml
       </span>
      </span>
     </a>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.771.1">
      PyJWT library:
     </span>
     <a href="https://pyjwt.readthedocs.io/">
      <span class="url">
       <span class="koboSpan" id="kobo.772.1">
        https://pyjwt.readthedocs.io/
       </span>
      </span>
     </a>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.773.1">
      Cryptography library:
     </span>
     <a href="https://cryptography.io/">
      <span class="url">
       <span class="koboSpan" id="kobo.774.1">
        https://cryptography.io/
       </span>
      </span>
     </a>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.775.1">
     There is a lot of information on the web and plenty of books you can study, but we would recommend that you start with the main concepts and then gradually dive into the specifics you want to understand more thoroughly.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-266">
    <span class="koboSpan" id="kobo.776.1">
     Summary
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.777.1">
     In this short chapter, we explored the world of cryptography in the Python standard library.
    </span>
    <span class="koboSpan" id="kobo.777.2">
     We learned how to create a hash (or digest) for a message using different cryptographic functions.
    </span>
    <span class="koboSpan" id="kobo.777.3">
     We also learned how to create tokens and deal with random data in the context of cryptography.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.778.1">
     We then took a small tour outside the standard library to learn about JSON Web Tokens, which are commonly used in authentication and claims-related functionalities by modern systems and applications.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.779.1">
     The most important thing is to understand that doing things manually can be very risky when it comes to cryptography, so it is always best to leave it to the professionals and simply use the tools we have available.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.780.1">
     The next chapter will be about testing our code so that we can be confident that it works the way it is supposed to.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-267">
    <span class="koboSpan" id="kobo.781.1">
     Join our community on Discord
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.782.1">
     Join our community’s Discord space for discussions with the authors and other readers:
    </span>
   </p>
   <p class="normal">
    <a href="Chapter_9.xhtml">
     <span class="url">
      <span class="koboSpan" id="kobo.783.1">
       https://discord.com/invite/uaKmaz7FEC
      </span>
     </span>
    </a>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.784.1">
     <img alt="img" src="../Images/QR_Code119001106417026468.png"/>
    </span>
   </p>
  </div>
 </body></html>