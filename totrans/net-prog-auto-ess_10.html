<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-226"><a id="_idTextAnchor227"/>10</h1>
<h1 id="_idParaDest-227"><a id="_idTextAnchor228"/>Hands-On and Going Forward</h1>
<p>Congratulations, you have reached the last chapter of this book, and nothing is better than having some real examples using network automation to help consolidate all of the knowledge learned. We probably won’t be able to write examples on all the subjects covered in this book, but the idea is to have at least a foundation for further experimentation and learning.</p>
<p>In this chapter, we are going to build a network from scratch using our network automation skills and emulated routers. The finished network emulated will have enough components for us to experiment with several techniques described in this book. You will be able to use it for your own experimentation whenever you need it.</p>
<p>We are also going to add a few remarks and some guidance for future studies and work, which should be good enough to wrap up the book.</p>
<p>At the end of this chapter, you are going to be able to build your own network emulation and experiment with your own network automation projects within your own computer, which will give you a great environment foundation for future experimentation and learning.</p>
<p>We are going to cover the following topics in this chapter:</p>
<ul>
<li>Using a network lab</li>
<li>Building our network lab</li>
<li>Connecting the devices</li>
<li>Adding automation</li>
<li>Going forward and further studies</li>
</ul>
<h1 id="_idParaDest-228"><a id="_idTextAnchor229"/>Technical requirements</h1>
<p>The source code described in this chapter is stored in the GitHub repository at  <a href="https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10">https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10</a>.</p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor230"/>Using a network lab</h1>
<p>It’s time for <a id="_idIndexMarker1130"/>us to do some real code automation tests in a virtual environment. Certain open source and commercial products can be used in your environment for testing network automation. The differences between the commercial and open source solutions rely on the number of different types of devices that are supported and how to scale. Using an open source solution, you might be able to scale up thousands of devices, but it would be limited in terms of the types of devices that can be emulated. A combination of a commercial and open source network might be more useful.</p>
<p>Cisco has a program that allows the public to access emulated routers in a virtual lab; they are called sandboxes. Cisco offers free 24/7 remote access to its sandboxes, but the number of devices is limited. More <a id="_idIndexMarker1131"/>on Cisco sandboxes can be found at <a href="https://developer.cisco.com/site/sandbox/">https://developer.cisco.com/site/sandbox/</a>.</p>
<p>As an example, the <code>scrapligo</code> project, described in <a href="B18165_06.xhtml#_idTextAnchor166"><em class="italic">Chapter 6</em></a>, uses Cisco sandboxes; check details on the usage at <a href="https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14">https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14</a>. There are also other commercial products, such as Cisco Packet Tracer, which is part of<a id="_idIndexMarker1132"/> the Cisco Network Academy (https://www.netacad.com/courses/packet-tracer), and <a id="_idIndexMarker1133"/>EVE-NG (<a href="https://www.eve-ng.net/">https://www.eve-ng.net/</a>).</p>
<p>In terms of open source, the most popular ones <a id="_idIndexMarker1134"/>are GNS3 (<a href="https://gns3.com/">https://gns3.com/</a>) and<a id="_idIndexMarker1135"/> Mininet (<a href="http://mininet.org">http://mininet.org</a>/). Mininet uses Linux containers to scale up the network, while GNS3 is more focused on virtual machines such as<a id="_idIndexMarker1136"/> Dynamips. Therefore, GNS3 can run with several different router types but is limited in scale. On the other hand, Mininet can scale to thousands, but with only one router type, which is more appropriate for testing network concepts and network topologies instead of functionalities.</p>
<p>For us, it will be more interesting to start from the ground and build our own network lab, which will give us more insights on how to use it and how we can use network automation tools, which, in fact, will be helpful later for real networks. The basis of our network lab<a id="_idIndexMarker1137"/> will be Linux containers. Consequently, we need to use routers that can be easily containerized, and because of license issues, we should stick with open source solutions such as FRRouting, Quagga, OpenWRT, or DD-WRT, as described in <a href="B18165_09.xhtml#_idTextAnchor209"><em class="italic">Chapter 9</em></a>.</p>
<p>Our network lab will use FRRouting as the basis of our routers, which has an interface configuration close to Cisco routers and can be accessed via the <code>vtysh</code> command. More details on<a id="_idIndexMarker1138"/> FRRouting setup and configuration can be found at <a href="https://docs.frrouting.org/en/latest/basic.html">https://docs.frrouting.org/en/latest/basic.html</a>.</p>
<p>Let’s now build our own network lab.</p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor231"/>Building our network lab</h1>
<p>In our <a id="_idIndexMarker1139"/>network lab, we are going to use Linux containers for all our devices. There will basically be two types of devices, one running a router and one running Linux. The Linux containers that are not working as routers are going to be used to generate traffic or to receive traffic; they are going to mimic a user’s PC and a server on the internet.</p>
<p>The intended topology is described in the following diagram:</p>
<div><div><img alt="Figure 10.1 – Network lab topology" src="img/B18165_10_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Network lab topology</p>
<p>The containers that are going to work as routers are the white rectangles in <em class="italic">Figure 10.1</em>, the yellow rectangles are going to work as user PCs, and the green rectangle is going to emulate the servers on the internet.</p>
<p>In total, the <a id="_idIndexMarker1140"/>network lab will have 16 routers, 3 PCs, and 1 server. The container images to be used in the network lab were created using Docker and stored in<a id="_idIndexMarker1141"/> Docker Hub (<a href="https://hub.docker.com/">https://hub.docker.com/</a>), which are publicly available and can be used for image download. The routers were created based on the<a id="_idIndexMarker1142"/> FRRouting docker image (<a href="https://hub.docker.com/r/frrouting/frr">https://hub.docker.com/r/frrouting/frr</a>) and the PCs and server were created based on the<a id="_idIndexMarker1143"/> Alpine Linux Docker image (<a href="https://hub.docker.com/_/alpine">https://hub.docker.com/_/alpine</a>).</p>
<p>The original images were slightly modified with a few more tools and configuration changes to create three new images. The image for the routers is <a href="https://hub.docker.com/r/brnuts/routerlab">hub.docker.com/r/brnuts/routerlab</a>, the image for the PCs is <a href="https://hub.docker.com/r/brnuts/pclab">hub.docker.com/r/brnuts/pclab</a>, and the image for the internet is <a href="https://hub.docker.com/r/brnuts/internetlab">hub.docker.com/r/brnuts/internetlab</a>.</p>
<p>Let’s see now how we can launch our lab host.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor232"/>Launching the lab host</h2>
<p>The<a id="_idIndexMarker1144"/> Linux containers need a host to run from. Therefore, you will first need to launch the Linux host where the routers will be running. I prepared two pre-built images to help, one for VirtualBox and another for Qemu. You can get instructions on how to download them and launch them on GitHub: <code>Chapter10/NetworkLab/README.md</code>. These virtual machine images use Debian Linux.</p>
<p>However, if you don’t want to use the pre-built virtual machine, I have also included instructions on how to build your own host, which is basically any Linux distribution with additional packages and some configuration changes. If you build your own image, you will need to start all containers by yourself. I have added a script in Shell that should be able to do that, called <code>start-containers.sh</code>.</p>
<p>Once you have launched the host, let’s see how we can check whether it was launched properly.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor233"/>Checking the lab host</h2>
<p>After <a id="_idIndexMarker1145"/>uncompressing and launching the pre-built image, you should be able to see all devices running once the host has finished the boot sequence. The reason is that I have updated the containers so that they restart automatically unless explicitly stopped.</p>
<p>To verify whether the containers representing the devices are running, you just need to use the <code>docker ps</code> command, as in the following screenshot:</p>
<div><div><img alt="Figure 10.2 – Output showing all devices running on the network lab" src="img/B18165_10_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Output showing all devices running on the network lab</p>
<p>The output of the <code>docker ps</code> command should show all running devices, which should be, in total, 20 containers, 16 representing routers (using the <code>brnuts/routerlab</code> image), 3 representing PCs (using the <code>brnuts/pclab</code> image), and 1 representing the internet (using the <code>brnuts/internetlab</code> image).</p>
<p>I have also added volumes to all containers and attached them as persistent storage, so configuration changes won’t be removed even on restarting the container. To see the volumes, you can just type in <code>docker volume list</code>.</p>
<p>Now, check whether <code>/etc/hosts</code> was updated with the IPs of the containers. You should be able to see several lines after <code># BEGIN DOCKER CONTAINERS</code>, as in the example in the following screenshot. This file is updated by the <code>update-hosts.sh</code> script included by <code>systemctl</code>:</p>
<div><div><img alt="Figure 10.3 – Checking the /etc/hosts file" src="img/B18165_10_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Checking the /etc/hosts file</p>
<p>We are <a id="_idIndexMarker1146"/>going to explain later why we need LLDP in the next section, but for now, let’s just check whether <code>lldpd</code> is running on the host using the <code>systemctl status lldpd.service</code> command:</p>
<div><div><img alt="Figure 10.4 – Checking whether lldpd is running on the host" src="img/B18165_10_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Checking whether lldpd is running on the host</p>
<p>If the <code>lldpd</code> daemon is running correctly, you should be able to see <code>active (running)</code> in green, as in the preceding screenshot.</p>
<p>Now, we should be ready to start doing some network automation to finish building our lab. Let’s now see how we connect the devices.</p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor234"/>Connecting the devices</h1>
<p>Connecting <a id="_idIndexMarker1147"/>the devices in our network lab will be done by using <code>veth</code> peer interfaces as was explained in <a href="B18165_09.xhtml#_idTextAnchor209"><em class="italic">Chapter 9</em></a>. If we need to connect two different labs from two different hosts, we can use VXLAN, but for our exercise in this section, we are only making connections on the same host. Therefore, <code>veth</code> peer interfaces will do the job.</p>
<p>One protocol that I have included in the pre-built virtual machine image and will be very important to <a id="_idIndexMarker1148"/>us is <strong class="bold">Link Layer Discovery Protocol</strong> (<strong class="bold">LLDP</strong>). LLDP is one IETF standard that came after the successful Cisco proprietary protocol <a id="_idIndexMarker1149"/>called <strong class="bold">Cisco Discovery Protocol</strong> (<strong class="bold">CDP</strong>). It is used to obtain information about the other side of a layer 2 connection by sending specific Ethernet frames. We are going to use it to validate the connections between devices in our network lab.</p>
<p>Before we proceed with our connections, let’s check how Docker created our <strong class="bold">out-of-band</strong> (<strong class="bold">OOB</strong>) management network.</p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor235"/>The OOB management network</h2>
<p>Docker, by <a id="_idIndexMarker1150"/>default, creates a <a id="_idIndexMarker1151"/>network connecting all containers, which we are going to use as our OOB management network (described in <a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>). To do that, Docker creates <code>veth</code> interface peers between the container and the host. On the container side, Docker attributes <code>eth0</code> as the name, and on the other side, uses <code>veth</code> followed by some hexadecimal characters to make it unique – for instance, <code>veth089f94f</code>.</p>
<p>All <code>veth</code> interfaces located on the host are then connected to a software bridge called <code>docker0</code>. To use the <code>brctl</code> command, you might need to install the <code>bridge-utils</code> package by doing <code>sudo apt install bridge-utils</code>:</p>
<div><div><img alt="Figure 10.5 – Checking interfaces on the docker0 bridge" src="img/B18165_10_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Checking interfaces on the docker0 bridge</p>
<p>To verify<a id="_idIndexMarker1152"/> which <code>veth</code> interface<a id="_idIndexMarker1153"/> belongs to which container, you might need to perform two commands, as in the following example:</p>
<div><div><img alt="Figure 10.6 – Checking the veth peer name on the host for a container" src="img/B18165_10_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Checking the veth peer name on the host for a container</p>
<p>As you can see in the output of the preceding screenshot, to identify which <code>veth</code> peer interface belongs to the <code>border</code> router, you need to execute a command inside the container to obtain an index for the <code>eth0</code> interface, which, in this case, was <code>23</code>. Once you have the index, you can check which <code>veth</code> interface on the host has the index by using a <code>grep</code> command on all files.</p>
<p>We can also use LLDP to find out the <code>veth</code> interface name by doing the command directly on the router:</p>
<div><div><img alt="Figure 10.7 – Showing the LLDP neighbor inside the border router" src="img/B18165_10_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Showing the LLDP neighbor inside the border router</p>
<p>The <a id="_idIndexMarker1154"/>preceding screenshot <a id="_idIndexMarker1155"/>shows a successful output of <code>lldpctl</code> showing the <code>eth0</code> interface’s neighbor, which, in this case, is the host Debian Linux, with a <code>SysName</code> of <code>netlab</code>. The interface that peers with <code>eth0</code> on the border router is described in the <code>PortDescr</code> field as <code>veth089f94f</code> – the same interface that we discovered using the commands in <em class="italic">Figure 10.6</em>.</p>
<p>However, why not use the first method described in <em class="italic">Figure 10.6</em> to find out the connection instead of LLDP? Because in real networks, LLDP is used to identify the connections between devices. Thus, writing an automation code to verify all the network connections in the lab using LLDP can also be used in production. Our lab will be used as the first place to test our automation code – in this case, checking the LLDP topology.</p>
<p>By now, you have probably noticed that we can access the routers just by using the <code>docker exec &lt;name of the router&gt;</code> command, so why do we need the OOB management network to access the devices? The answer is like the LLDP case – with OOB network access, the devices can be accessed via SSH, which is what we are going to do in production. Consequently, any code developed for the lab can be used in production.</p>
<p>To test <a id="_idIndexMarker1156"/>our lab OOB management<a id="_idIndexMarker1157"/> network, we just need to access the device via the IP using <code>ping</code> or <code>ssh</code> commands – the <code>ping cpe-a</code> command, for example:</p>
<div><div><img alt="Figure 10.8 – Testing connection to a router from the host using OOB" src="img/B18165_10_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Testing connection to a router from the host using OOB</p>
<p>You should also be able to SSH to any container, using <code>netlab</code> for the username and password:</p>
<div><div><img alt="Figure 10.9 – Testing whether you can access a device via SSH using OOB" src="img/B18165_10_009.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – Testing whether you can access a device via SSH using OOB</p>
<p>Now that we know how our OOB management network works in our lab, let’s connect the devices using the OOB network.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor236"/>Looking at the topology</h2>
<p><em class="italic">Figure 10.1</em> shows<a id="_idIndexMarker1158"/> the topology that we are aiming to create. The devices in our lab are running and connected to an OOB network, but they do not have connections like the topology described in <em class="italic">Figure 10.1</em>.</p>
<p>In addition to the diagram, there is also a formal topology description in a file on GitHub, which can be accessed at <code>Chapter10/NetworkLab/topology.yaml</code>. The file describes the routers in the topology and their connections. It is a simple version of network definition in YAML format as we discussed in <a href="B18165_04.xhtml#_idTextAnchor100"><em class="italic">Chapter 4</em></a>.</p>
<p>The topology file has basically two main keys, <code>devices</code> and <code>links</code>. These keys should describe the same connections shown in <em class="italic">Figure 10.1</em>. The following is a sample of the file for the <code>devices</code> and <code>links</code> keys:</p>
<pre class="source-code">
devices:
  - name: acc-a
    type: router_acc
    image: brnuts/routerlab
  - name: acc-b
    type: router_acc
    image: brnuts/routerlab
links:
  - name: [pc, cpe]
    connection: [pc-a, cpe-a]
  - name: [cpe, acc]
    connection: [cpe-a, acc-a]</pre>
<p>The file should contain all the links that are depicted in <em class="italic">Figure 10.1</em>. Ideally, the diagram in <em class="italic">Figure 10.1</em> should be created automatically by a tool reading from <code>topology.yaml</code>. In our example, the diagram and the YAML file are the same, but I have built the diagram manually myself, and for any topology change, I need to update the <code>topology.yaml</code> file and the diagram. This problem was discussed as well in <a href="B18165_04.xhtml#_idTextAnchor100"><em class="italic">Chapter 4</em></a>, and the update synchronization<a id="_idIndexMarker1159"/> between a  file and a diagram tends to break as the topology gets more complex. But, for our examples using this small topology, an automated diagram builder is not necessary.</p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor237"/>Creating the connections between devices</h2>
<p>To connect the<a id="_idIndexMarker1160"/> devices, like in the topology, we have to use <code>veth</code> peer interfaces, and as we discussed in <a href="B18165_09.xhtml#_idTextAnchor209"><em class="italic">Chapter 9</em></a>, we need the namespace numbers for each side of the peer and the interface names we going to use. Most of the connections in <em class="italic">Figure 10.1</em> are point-to-point between devices, except for the connections to the <strong class="bold">backbone</strong> or <strong class="bold">WAN</strong>.</p>
<p>The following diagram shows all the <code>veth</code> peers that we must configure; the majority are connected between two containers in a point-to-point configuration. However, the core routers will use, let’s say, backbone veth or WAN veth, because they are connected in a multi-to-multi-point environment, similar to a WAN. For that, we are going to use a software bridge in the host to provide connectivity between the backbone veth – latency and packet loss can be added to the bridge interfaces if tests for network degradation are required:</p>
<div><div><img alt="Figure 10.10 – Lab topology showing all veth peer interfaces" src="img/B18165_10_010.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Lab topology showing all veth peer interfaces</p>
<p>When we start creating the <code>veth</code> interfaces for the backbone to connect all core routers, we are going to use one namespace on the host and the other in the core router. This<a id="_idIndexMarker1161"/> is different from all other veth, which will have two namespaces. The following is one example of how to create a connection manually between <code>pc-a</code> and <code>cpe-a</code>:</p>
<pre class="console">
netlab@netlab:~$ docker inspect -f '{{.State.Pid}}' pc-a
1069
netlab@netlab:~$ docker inspect -f '{{.State.Pid}}' cpe-a
1063
netlab@netlab:~$ sudo ip link add pc-cpe type veth peer name cpe-pc
netlab@netlab:~$ sudo ip link set pc-cpe netns 1069
netlab@netlab:~$ sudo ip link set cpe-pc netns 1063
netlab@netlab:~$ docker exec pc-a ip link set pc-cpe up
netlab@netlab:~$ docker exec cpe-a ip link set cpe-pc up</pre>
<p>As we can see in these commands, first, we need to obtain the network namespace IDs of each router we want to connect, and then we can create the <code>veth</code> peer and attribute each side of the peer to a namespace ID. Finally, we bring the interfaces up on each router. Note that the interface name on <code>pc-a</code> is <code>pc-cpe</code> and on <code>cpe-a</code> is <code>cpe-pc</code>, to help identify the direction in which the interface goes.</p>
<p>To verify whether our connection between the routers was created properly, we can run the following command:</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 10.11 – Checking the connection between pc-a and cpe-a" src="img/B18165_10_011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Checking the connection between pc-a and cpe-a</p>
<p>Now, we can <a id="_idIndexMarker1162"/>confirm that <code>pc-a</code> is connected to <code>cpe-a</code> by looking into the <code>lldpctl</code> command output in <em class="italic">Figure 10.11</em>. The output shows the name for <code>SysName</code>, which is <code>cpe-a</code>, confirming the connection. We can also see the interface name on the other side, which is <code>cpe-pc</code>.</p>
<p>Let’s now see how we automate the device connections.</p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor238"/>Automating the connections</h2>
<p>Our lab now<a id="_idIndexMarker1163"/> has all devices running, and we are going to connect all devices using a program that will connect all devices. You can get access to the program on <code>Chapter10/NetworkLab/AUTOMATION.md</code>.</p>
<p>To install it on your computer, just need to clone it using the following:</p>
<pre class="console">
claus@dev % <strong class="bold">git clone https://github.com/brnuts/netlab.git</strong>
Cloning into 'netlab'…
remote: Enumerating objects: 103, done.
remote: Counting objects: 100% (103/103), done.
remote: Compressing objects: 100% (79/79), done.
remote: Total 103, reused 44 (delta 12), pack-reused 0
Receiving objects: 100% (103/103), 58 KiB | .9 MiB/s, done.
Resolving deltas: 100% (36/36), done.</pre>
<p>Then, you need to build the Go program:</p>
<pre class="console">
claus@dev % <strong class="bold">go build</strong>
claus@dev % ls -lah netlab
-rwxr-xr-x  1 user  staff   5.3M Feb  8 11:54 netlab</pre>
<p>If you are <a id="_idIndexMarker1164"/>using the pre-build VirtualBox image, you probably are accessing the network lab via SSH on localhost port <code>22</code>. Then, you just need to run it like so:</p>
<pre class="console">
claus@dev % ./netlab</pre>
<p>If you are using QEMU or your own Linux virtual machine with the network lab, you can pass the username, password, and IP of the host as follows:</p>
<pre class="console">
claus@dev % ./netlab -host 10.0.4.1 -user oper -pw secret</pre>
<p>A small help guide can be accessed by adding <code>-help</code>, like here:</p>
<pre class="console">
claus@dev % ./netlab -help
Usage of ./netlab:
  -host string
      Host IP for netlab (default "localhost")
  -port uint
      SSH port to access Host IP for netlab (default 22)
  -pw string
      Password to access netlab host (default "netlab")
  -topo string
      Topology yaml file (default "topology.yaml")
  -user string
      Username to access netlab host (default "netlab")</pre>
<p>The program<a id="_idIndexMarker1165"/> shows some logs on the output, and a successful run should show similar lines to the following:</p>
<div><div><img alt="Figure 10.12 – Running the Go automation program to connect devices" src="img/B18165_10_012.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Running the Go automation program to connect devices</p>
<p>As you can see in the preceding screenshot, the program takes around 12 seconds to run, and it should show <code>all done successfully</code> at the end.</p>
<p>Let’s have a look at this program and what it is doing.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor239"/>Looking into the automation program</h2>
<p>In our <a id="_idIndexMarker1166"/>example, the program was written in Go, and the directory where it is located consists of nine files, of which six are Go source code with <code>.go</code> extensions as shown here:</p>
<pre class="console">
claus@dev % ls –1
go.mod
go.sum
hostconnect.go
netlab.go
readtopology.go
runcommand.go
topology.yaml
types.go
vethcommands.go</pre>
<p>Let’s discuss each file.</p>
<h3>go.mod and go.sum</h3>
<p>These<a id="_idIndexMarker1167"/> files are used by the Go builder for package dependency<a id="_idIndexMarker1168"/> management; they contain all the necessary information to add the third-party library to our program. Every time we import a package, it automatically updates these files. More on these files can be obtained at <a href="https://go.dev/ref/mod">https://go.dev/ref/mod</a>.</p>
<h3>topology.yaml</h3>
<p>This contains <a id="_idIndexMarker1169"/>the description of the topology that is shown in <em class="italic">Figure 10.1</em>.</p>
<h3>types.go</h3>
<p>This <a id="_idIndexMarker1170"/>contains all the data structure definitions used in the program, which include variable types and the YAML topology data structure. Different from Python, in Go, it is better to specify the data structure that you are going to read from a YAML file. In our case, the <code>TopologyConfType</code> struct type is used to define the YAML file structure, like so:</p>
<pre class="source-code">
type DeviceTopologyType struct {
        Name  string
        Type  string
        Image string
}
type LinkTopologyType struct {
        Name       []string
        Connection []string
}
type <strong class="bold">TopologyConfType</strong> struct {
        Devices []DeviceTopologyType
        Links   []LinkTopologyType
}</pre>
<h3>readtopology.go</h3>
<p>This <a id="_idIndexMarker1171"/>contains the function that is used to read the <code>topology.yaml</code> file. The data structure of this file is defined in the <code>TopologyConfType</code> structure type.</p>
<h3>runcommand.go</h3>
<p>This <a id="_idIndexMarker1172"/>contains generic functions that wrap the command to run on the host of the lab. If an error occurs by running a command, the output is combined with the error message to be returned in the error message, as in this example:</p>
<pre class="source-code">
fmt.Errorf("failed '%s', out: %s ,err: %v", cmd, out, err)</pre>
<p>The idea to add the output to the error message is because when running remote commands via SSH and shell, the error might not be easy to interpret without the <code>stdout</code> messages.</p>
<h3>veth.go</h3>
<p>This contains <a id="_idIndexMarker1173"/>the functions that form the command strings that will be used to run on the host to create or manipulate <code>veth</code> interfaces. It also contains all functions that are used to populate the <code>conf.Veths</code> list, such as <code>loadVeth()</code> and <code>createPeerVeths()</code>.</p>
<h3>hostconnect.go</h3>
<p>This file <a id="_idIndexMarker1174"/>contains the function used to connect to our lab. In our case, we are using a third-party package called <code>melbahja/goph</code>, which is an SSH client that allows the execution of a command and immediate output. For faster and better performance, we should use vSSH instead, as explained in <a href="B18165_06.xhtml#_idTextAnchor166"><em class="italic">Chapter 6</em></a>.</p>
<h3>netlab.go</h3>
<p>This is <a id="_idIndexMarker1175"/>the main program file that contains the <code>main()</code> and <code>init()</code> functions. The library called <code>flags</code> is used to pass arguments during the command execution in the shell. By default, they are initiated in the <code>init()</code> function, and they use default values if the arguments are not passed.</p>
<p>The <code>main()</code> function also describes the flow of the whole process, which consists of five main calls – <code>readTopologyFile</code>, <code>connectToHost</code>, <code>loadVeths</code>, <code>createVeths</code>, and <code>addVethsToBackbone</code>.</p>
<p>Now that we have all devices connected and we understand how the automation works, let’s do some manual checks to verify that the connections have been created properly.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor240"/>Checking the connections manually</h2>
<p>To <a id="_idIndexMarker1176"/>create automation for checking connections, we have to understand how the process of checking connections works first. Once we know how a manual check works, we can later automate it.</p>
<p>Once the <code>netlab</code> program has run without errors, it should have created the connections and the software bridge called <code>backbone</code>, and attached the WAN interfaces to it. Let’s use the following figure as guidance for our manual verification of the connections:</p>
<div><div><img alt="Figure 10.13 – Diagram showing where we manually check the connections" src="img/B18165_10_013.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Diagram showing where we manually check the connections</p>
<p>The figure <a id="_idIndexMarker1177"/>shows numbers to indicate where we are going to do the manual checks. Let’s first start checking the connection that is represented by <strong class="bold">1</strong>. We are going to use LLDP to validate the connection in all cases.</p>
<p>The following screenshot shows the output of the <code>sudo lldpctl cpe-acc</code> command, which runs inside the <code>cpe-a</code> router via SSH. Note that in the example, we start from the <code>netlab</code> host:</p>
<div><div><img alt="Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection to acc-a" src="img/B18165_10_014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection to acc-a</p>
<p>As you can <a id="_idIndexMarker1178"/>see, the <code>cpe-acc</code> interface in the <code>cpe-a</code> router is connected to the <code>acc-cpe</code> interface in the <code>acc-a</code> router.</p>
<p>To validate the connection for case <code>core-a1</code>:</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection to the backbone" src="img/B18165_10_015.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection to the backbone</p>
<p>As you can <a id="_idIndexMarker1179"/>see, the <code>core-a1</code> router’s interface, <code>core-a1-wan</code>, is connected to the <code>netlab</code> host via <code>wan-core-a1</code>. To verify whether the <code>wan-core-a1</code> interface belongs to the <code>backbone</code> bridge, we need to perform one of the extra commands:</p>
<div><div><img alt="Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone bridge" src="img/B18165_10_016.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone bridge</p>
<p>Either of the commands shown in <em class="italic">Figure 10.16</em> confirms that <code>wan-core-a1</code> belongs to <code>backbone</code>. The difference is the second command presents the output in a JSON format, which is easier to parse by software. <code>lldpctl</code> also supports JSON output using <code>lldpctl -f json</code>.</p>
<p>Now, let’s discuss how we can add more automation.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor241"/>Adding automation</h1>
<p>There <a id="_idIndexMarker1180"/>are infinite possibilities for processes for which you might want to create automation. Most of the operational procedures are repetitive and prone to errors if manually operated. So, we need to automate our network as much as possible.</p>
<p>Let’s then describe a few simple forms of automation that can help our network operation.</p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor242"/>Link connection check automation</h2>
<p>One of <a id="_idIndexMarker1181"/>the procedures <a id="_idIndexMarker1182"/>that is very important and requires lots of attention is the build and construction of the physical network, in particular a physical rack and its cables. Its complexity will vary, depending on whether a star topology configuration or a Clos topology configuration is used, which we discussed in <a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>.</p>
<p>A mixed topology configuration that combines all possible topologies is even more complex, and its complexity will increase the chances of building a network incorrectly. For instance, a Clos network, as shown in <em class="italic">Figure 10.17</em>, has a total of 32 connections, and imagine the complexity added if three more routers were included.</p>
<div><div><img alt="Figure 10.17 – Clos network connections" src="img/B18165_10_017.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Clos network connections</p>
<p>Having<a id="_idIndexMarker1183"/> included <strong class="bold">E5</strong>, <strong class="bold">S5</strong>, and <strong class="bold">L5</strong>, the Clos network will have now 50 connections. So, for us, connection check automation<a id="_idIndexMarker1184"/> is important to avoid operation failures down the network setup.</p>
<p>Most importantly, our network lab can be used for us to test the automation of the link connection check, which can be used later in production.</p>
<p>In a production environment, a bastion host normally needs to be accessed first, before accessing the devices using the OOB network. In our network lab, the bastion is the same as the network lab host. Once logged in to the bastion, the automation code can then access the router via the OOB network, which is the same as in the network lab.</p>
<p>Let’s now write some code to automate this process</p>
<h3>Link check example code</h3>
<p>I have <a id="_idIndexMarker1185"/>added a Python script that returns a JSON list format with all interfaces and the device connected to each interface for a particular device. The Python code can be accessed at <code>Chapter10/NetworkLab/AUTOMATION.md</code>.</p>
<p>Let’s run a few examples to see how the Python script works; the following screenshot is showing results for the <code>internet</code> device:</p>
<div><div><img alt="Figure 10.18 – Output for checking connections to the internet device" src="img/B18165_10_018.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – Output for checking connections to the internet device</p>
<p>As you <a id="_idIndexMarker1186"/>can see, the <code>internet</code> device has only two interfaces, one connected via the OOB network with the <code>eth0</code> interface to the <code>netlab</code> device, and one interface called <code>internet-border</code> connected to the <code>border</code> device, which confirms the connections in <em class="italic">Figure 10.1</em>.</p>
<p>Let’s now check how the <code>border</code> device is connected.</p>
<div><div><img alt="Figure 10.19 – Output for checking connections of the border device" src="img/B18165_10_019.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.19 – Output for checking connections of the border device</p>
<p>As you<a id="_idIndexMarker1187"/> can see in <em class="italic">Figure 10.19</em>, the <code>border</code> device is connected to the <code>internet</code> device and three core routers, <code>core-i1</code>, <code>core-i2</code>, and <code>core-i3</code>, as in <em class="italic">Figure 10.1</em>.</p>
<p>If you run this for all devices, you should confirm all the connections. But can we automate confirming connections for all routers in just one run? Yes, of course, but for that, we will need to read <code>topology.yaml</code>, and then create a loop that will run on each device to confirm the connections. I will leave completing this as an exercise for you.</p>
<p>Let’s now explain some parts of the <code>show-connections.py</code> code.</p>
<h3>Looking into the code</h3>
<p>The <code>show-connections.py</code> Python <a id="_idIndexMarker1188"/>code uses the <code>paramiko</code> third-party library as the base for the SSH connection, which we discussed in <a href="B18165_06.xhtml#_idTextAnchor166"><em class="italic">Chapter 6</em></a>, (<code>paramiko</code> can be installed using <code>pip install paramiko</code>).</p>
<p>Paramiko is a <a id="_idIndexMarker1189"/>lower-level SSH connectivity library that allows us to create an SSH session within an SSH session because we are using a bastion to connect to our devices in the network lab, which<a id="_idIndexMarker1190"/> is the lab host. The details of this stacked SSH connection are described in the code by the <code>NetLab()</code> class, which has a method to connect to the bastion called <code>connectBastion()</code>, and a method to connect to a device called <code>connectDevice()</code>. Note that these methods use a class attribute called <code>self.transport</code> to pass the bastion <code>paramiko</code> handler to the device channel described in the code and shown here:</p>
<pre class="source-code">
device_channel = <strong class="bold">self.transport</strong>.open_channel(
    "direct-tcpip", target_socket, source_socket
)</pre>
<p>There are other ways to use bastion, such as using SSH proxies or SSH agents. However, in our example, I wanted to show how to natively create an SSH stack connection. Because if you do have two bastions before connecting a device, it is also possible to use <code>paramiko</code>, but perhaps not that easy using SSH agents and proxies.</p>
<p>In the Python code, we use <code>argparser</code> to add arguments to our command line, so you can change the address of the bastion or the username and password. The arguments and default values are located in <code>parse_arguments()</code>. A help guide is also automatically produced if you type <code>--help</code>.</p>
<div><div><img alt="Figure 10.20 – help output for the Python code show-connections.py" src="img/B18165_10_020.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.20 – help output for the Python code show-connections.py</p>
<p>I will leave<a id="_idIndexMarker1191"/> you to improve this Python script to read the <code>topology.yaml</code> file and then verify all the connections in the network lab depicted in <em class="italic">Figure 10.1</em>.</p>
<p>Now, let’s see how we can automate the IP configuration for the interfaces.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor243"/>IP configuration automation</h2>
<p>Before<a id="_idIndexMarker1192"/> we can use our network<a id="_idIndexMarker1193"/> for IP traffic, we need to attribute IPs to our network interfaces, which can be done manually by adding IPs to each interface, or we can create an automated code that distributes the IPs and configure them on the devices in the network lab.</p>
<p>For our network lab, there are basically two types of IP allocation, one that is point-to-point between devices, and one that is multi-point for the WAN on the backbone interfaces. Let’s give an example of automation for the WAN interfaces. The Python code called <code>configure-ip-wan.py</code> is located at <code>Chapter10/NetworkLab/AUTOMATION.md</code>.</p>
<p>The following screenshot shows the output after running the <code>configure-ip-wan.py</code> program:</p>
<div><div><img alt="Figure 10.21 – Output of the configure-ip-wan.py Python code" src="img/B18165_10_021.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.21 – Output of the configure-ip-wan.py Python code</p>
<p>Note<a id="_idIndexMarker1194"/> that<a id="_idIndexMarker1195"/> the IPs are configured on the devices using Paramiko, as in the previous example. The code uses the <code>ipaddress</code> Python library, which allocates the IPs that will be used in the WAN interfaces by creating a list of IPs using the following commands:</p>
<pre class="console">
network = ipaddress.ip_network(args.subnet)
valid_ips = list(network.hosts())</pre>
<p>Then, each IP is obtained by using <code>pop()</code> in the <code>valid_ips</code> list, like in the following loop:</p>
<pre class="source-code">
prefix = network.prefixlen
for device, interface in wan_interfaces.items():
    ip = valid_ips.pop(0)
    cmd = "sudo ip addr add {}/{} dev {}".format(ip, prefix, interface)
    run_device_command(args, device, cmd)</pre>
<p>Now, we can test the IP connectivity between devices in the WAN using the Python script included at <code>Chapter10/NetworkLab/AUTOMATION.md</code>:</p>
<div><div><img alt="Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via the WAN" src="img/B18165_10_022.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via the WAN</p>
<p>From<a id="_idIndexMarker1196"/> the <a id="_idIndexMarker1197"/>output shown in <em class="italic">Figure 10.21</em>, we can assume the <code>core-b1</code> interface IP is <code>10.200.200.4</code>. So, the test executed on <code>core-a1</code> is testing the IP connectivity between <code>core-a1</code> and <code>core-b1</code> via the <code>backbone</code> bridge.</p>
<p>To finish the IP configuration, you will have to also configure IPs for all other interfaces. I will leave adding the IPs to other network lab interfaces as an exercise, but for now, the example is sufficient to guide you to proceed.</p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor244"/>Additional network lab automation</h2>
<p>Let’s <a id="_idIndexMarker1198"/>discuss briefly what other possible automation we can add to our lab.</p>
<h3>Adding and removing devices</h3>
<p>We can <a id="_idIndexMarker1199"/>add code that can read the <code>topology.yaml</code> file and then, based<a id="_idIndexMarker1200"/> on what is running, determine whether certain modifications are required, such as adding devices or removing devices. I will say that is easier for us to just tear down a network lab and start another one from scratch instead of removing and adding devices because, in our network emulation, the shutdown and startup are quick.</p>
<p>So, adding code to remove and add devices is more of an exercise than a real utility in our network lab.</p>
<h3>Using gRPC for automation</h3>
<p>We also <a id="_idIndexMarker1201"/>can do some automation using gRPC, as FRRouting supports this interface. With this, we eliminate the necessity to access the devices via SSH. You can find more on gRPC for FRRouting at <a href="https://docs.frrouting.org/en/latest/grpc.html">https://docs.frrouting.org/en/latest/grpc.html</a>.</p>
<h3>Using NETCONF for automation</h3>
<p>To use <a id="_idIndexMarker1202"/>NETCONF for automation, you need to have <code>libyang</code> installed in the router image, which, in our network lab, is FRRouting running on Alpine Linux. To add <code>libyang</code>, just type the <code>sudo apk add libyang</code> command on the router device. Using FRRouting and NETCONF together is not a very well-documented option, so good luck doing so.</p>
<h3>Adding network degradation</h3>
<p>You<a id="_idIndexMarker1203"/> can add latency, jitter, packet loss, congestion, and other degradations to your network lab, which can be permanent or vary over time. To remove and add these degradations, the best thing to do is to write automated code that can apply the necessary traffic shaping mechanisms and then remove them. We discussed these degradation methods in <a href="B18165_09.xhtml#_idTextAnchor209"><em class="italic">Chapter 9</em></a>.</p>
<p>As an example, we can add some latency to the backbone interfaces in our network lab by using Linux <code>tc</code> like so:</p>
<pre class="console">
sudo tc qdisc add dev wan-core-a1 root netem delay 100ms</pre>
<p>This command should run on the lab host, and it will add a 100 ms delay to the <code>wan-core-a1</code> interface that connects <code>core-a1</code> to the backbone.</p>
<p><em class="italic">Figure 10.23</em> show the same test done in <em class="italic">Figure 10.22</em> but with WAN latency added.</p>
<div><div><img alt="Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to WAN" src="img/B18165_10_023.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to WAN</p>
<p>Feel <a id="_idIndexMarker1204"/>free to add other network degradations to your network lab by automating how Linux traffic control can be used in the network lab interfaces.</p>
<h3>Configure routing</h3>
<p>At this <a id="_idIndexMarker1205"/>stage, our network lab does not provide IP traffic capabilities because it does not know how to route IP packets. Two kinds of routing can be done using static routes by configuring the interfaces with them or adding dynamic protocol for the devices to talk and exchange routing tables.</p>
<p>As all routers in our network lab are FRRouting; the protocols available that can be used are EIGRP, OSPF, ISIS, RIP, or BGP. A complete list and more details can be found at <a href="https://docs.frrouting.org/">https://docs.frrouting.org/</a>.</p>
<p>Many more kinds of automation are possible. Some will only work for the network lab, but some could be used in a production network. Hopefully, you can use the network lab to improve your network automation code skills, and then gain more confidence on building a solution for a production network.</p>
<p>Let’s now discuss what to do next and further study.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor245"/>Going forward and further study</h1>
<p>You are probably now thinking about what to do next and how you can progress to the next topic in network automation. I have put together a few suggestions here that I would recommend following, but keep in mind that there might be many other paths to follow. So, it is just a humble suggestion, and I hope you can enjoy the journey.</p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor246"/>Checking popular platforms and tools</h2>
<p>There are<a id="_idIndexMarker1206"/> many automation platforms that you can use and perhaps investigate how they work. This list will be dynamic and may change from one year to another. So, keep in mind how to search for them and how to evaluate them.</p>
<p>I have done superficial research on some of the platforms, but I would recommend going deeper if you want to improve your knowledge and get even sharper on how to automate a network. You may get some ideas, and perhaps improve what you are doing today.</p>
<p>Here is a small list of the most popular automation <a id="_idIndexMarker1207"/>platforms and tools that you might want to have a look at, not in any particular order:</p>
<ul>
<li>The<a id="_idIndexMarker1208"/> Salt project:<ul><li>Short description: A remote execution manager</li><li>Source: <a href="https://github.com/saltstack/salt ">https://github.com/saltstack/salt</a></li><li>Contributors: Over 2K</li><li>Repository creation date: February 2011</li><li>Top languages: Python 98%</li><li>License: Apache 2.0</li><li>Sponsor: VMware/public</li><li>Popularity: 13K stars, 5.4K forks, 544 watching</li></ul></li>
<li>The <a id="_idIndexMarker1209"/>Ansible project:<ul><li>Short description: A simple automation system for configuration management, deployment, and orchestration</li><li>Source: <a href="https://github.com/ansible/ansible ">https://github.com/ansible/ansible</a></li><li>Contributors: Over 5K</li><li>Repository <a id="_idIndexMarker1210"/>creation date: March 2012</li><li>Top languages: Python 88%, PowerShell 6.9%</li><li>License: GPL 3.0</li><li>Sponsor: Red Hat</li><li>Popularity: 56K stars, 23K forks, 2K watching</li></ul></li>
<li>The <a id="_idIndexMarker1211"/>Puppet project:<ul><li>Short <a id="_idIndexMarker1212"/>description: A<a id="_idIndexMarker1213"/> general administrative management system designed to configure, update, and install systems</li><li>Source: <a href="https://github.com/puppetlabs/puppet ">https://github.com/puppetlabs/puppet</a></li><li>Contributors: Over 1K</li><li>Repository creation date: September 2010</li><li>Top languages: Ruby 99%</li><li>License: Apache 2.0</li><li>Sponsor/Owner: Puppet by Perforce</li><li>Popularity: 6.8K stars, 2.3K forks, 475 watching</li></ul></li>
<li>The Chef project:<ul><li>Short description: A <a id="_idIndexMarker1214"/>configuration management tool designed to cover the automation of all IT infrastructure</li><li>Source: <a href="https://github.com/chef/chef">https://github.com/chef/chef</a></li><li>Contributors: Over 1K</li><li>Repository creation date: January 2009</li><li>Top languages: Ruby 98%</li><li>License: Apache 2.0</li><li>Sponsor/Owner: Progress <a id="_idIndexMarker1215"/>Software Corporation</li><li>Popularity: 7.1K stars, 2.6K forks, 374 watching</li></ul></li>
<li>The <a id="_idIndexMarker1216"/>Stackstorm project:<ul><li>Short description: An<a id="_idIndexMarker1217"/> event-driven automation tool</li><li>Source: <a href="https://github.com/StackStorm/st2 ">https://github.com/StackStorm/st2</a></li><li>Contributors: Over 300</li><li>Repository creation date: April 2014</li><li>Top languages: Python 94%</li><li>License: Apache 2.0</li><li>Sponsor/Owner: Linux Foundation</li><li>Popularity: 5.4K stars, 696 forks, 168 watching</li></ul></li>
<li>The eNMS<a id="_idIndexMarker1218"/> automation project:<ul><li>Short description: A<a id="_idIndexMarker1219"/> higher-level management system to create workflow-based network automation solutions</li><li>Source: <a href="https://github.com/eNMS-automation/eNMS ">https://github.com/eNMS-automation/eNMS</a></li><li>Contributors: 30</li><li>Repository creation date: October 2017</li><li>Top languages: Python 53%, JavaScript 26%, HTML 16%</li><li>License: GLP 3.0</li><li>Sponsor: N/A</li><li>Popularity: 700 stars, 148 forks, 73 watching</li></ul></li>
<li>NetBrain products:<ul><li>Short description: NetBrain <a id="_idIndexMarker1220"/>has developed several products for network <a id="_idIndexMarker1221"/>automation, including <strong class="bold">Problem Diagnosis Automation System</strong> (<strong class="bold">PDAS</strong>)</li><li>Site: <a href="https://www.netbraintech.com/ ">https://www.netbraintech.com/</a></li><li>Owner: NetBrain Automation</li></ul></li>
<li>SolarWinds Network Automation Manager:<ul><li>Short description: Proprietary<a id="_idIndexMarker1222"/> product developed by SolarWinds for network automation</li><li>Site: <a href="https://www.solarwinds.com/network-automation-manager ">https://www.solarwinds.com/network-automation-manager</a></li><li>Owner: SolarWinds</li></ul></li>
</ul>
<p>Besides the <a id="_idIndexMarker1223"/>tools and platforms that you can investigate, you <a id="_idIndexMarker1224"/>also can participate in working groups related to network automation. Let’s have a look at some of them.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor247"/>Joining the network automation community</h2>
<p>One of the <a id="_idIndexMarker1225"/>strategies to improve your knowledge and get updated with new technologies is to participate in the community. The following is a small list of possible groups that you might be interested in watching or participating in:</p>
<ul>
<li>IETF netmgmt working group:<ul><li>Short description: A <a id="_idIndexMarker1226"/>group that has a focus on working on standards for automated network management, such as RESTCONF, NETCONF, and YANG</li><li>Site: <a href="https://www.ietf.org/topics/netmgmt/ ">https://www.ietf.org/topics/netmgmt/</a></li></ul></li>
<li>Meetup groups:<ul><li>Short description: One <a id="_idIndexMarker1227"/>good idea is to join a local meetup group that has regular meetings. Then, you can talk with professionals in the same area and improve your network and knowledge. <a href="https://www.meetup.com/">https://www.meetup.com/</a> is a site where people can organize and meet.</li><li>Example in New York: <a href="https://www.meetup.com/Network-to-Coders/">https://www.meetup.com/Network-to-Coders/</a>.</li><li>Example in Sydney: <a href="https://www.meetup.com/it-automation/">https://www.meetup.com/it-automation/</a>.</li><li>Example in San Francisco: <a href="https://www.meetup.com/sf-network-automation/">https://www.meetup.com/sf-network-automation/</a>.</li></ul></li>
<li><strong class="bold">North American Network Operators’ Group</strong> (<strong class="bold">NANOG</strong>):<ul><li>Short description: NANOG <a id="_idIndexMarker1228"/>has tons of <a id="_idIndexMarker1229"/>documents and presentations, and also organizes conferences where you can find multiple topics on network automation</li><li>Site: <a href="https://www.nanog.org/ ">https://www.nanog.org/</a></li></ul></li>
<li><strong class="bold">Global Network Advancement Group</strong> (<strong class="bold">GNA-G</strong>):<ul><li>Short description: GNA-G is a <a id="_idIndexMarker1230"/>community of network professionals from several areas, including research, operation, and education all over the world. They organize meetings and have some documentation resources.</li><li>Site: <a href="https://www.gna-g.net/">https://www.gna-g.net/</a>.</li></ul></li>
<li>The <a id="_idIndexMarker1231"/>Network to Code company community:<ul><li>Short description: Network to Code is a consulting company that maintains GitHub repositories and a <a href="https://slack.com">slack.com</a> group that discusses network automation, which<a id="_idIndexMarker1232"/> can be joined for free</li><li>GitHub: <a href="https://github.com/networktocode/awesome-network-automation ">https://github.com/networktocode/awesome-network-automation</a></li><li>Slack group: <a href="https://networktocode.slack.com ">networktocode.slack.com</a></li></ul></li>
<li>IP Fabric company community:<ul><li>Short description: The<a id="_idIndexMarker1233"/> IP Fabric company also maintains GitHub repositories and has a <a href="http://slack.com">slack.com</a> group open to anyone to join</li><li>GitHub: <a href="https://github.com/community-fabric">https://github.com/community-fabric</a></li><li>Slack group: <a href="http://ipfabric-community.slack.com">ipfabric-community.slack.com</a></li></ul></li>
</ul>
<p>Other <a id="_idIndexMarker1234"/>communities also can be found attached to some private companies, such as IBM, Oracle, VMware, Google, and Amazon. They might even use public tools such as Slack, LinkedIn, or GitHub to communicate, and they are maybe more focused on products that these companies offer instead of generic discussion. They are worth checking out, because they might have something to add.</p>
<p>Another idea to improve your knowledge and skills is to contribute to a platform that already exists as a developer, or to build your own if you dare.</p>
<p>I hope this section can give you ideas on the path forward.</p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor248"/>Summary</h1>
<p>This chapter was focused on getting your hands dirty in a network lab, checking how some code automation works in Go and Python, and, finally, exploring the possibilities of how to go forward with network automation.</p>
<p>At this point, you should be very confident about how to build your own network lab, how to improve your network automation code, and what to do next to continue improving.</p>
<p>On behalf of all the people who worked hard on this book, we want to thank you for investing the time to read this book. It was a hard accomplishment to gather so much information and pass it on to others in an easy and pleasurable way. I hope you have made the most of it by reading it and discovering new technologies and techniques in the realm of network automation.</p>
<p>Now, you can embark on further challenges that will take you deeper into network automation, which you will find when building a complete solution and putting into practice everything that you have learned.</p>
</div>
</body></html>