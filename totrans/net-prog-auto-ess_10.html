<html><head></head><body>
<div id="_idContainer090">
<h1 class="chapter-number" id="_idParaDest-226"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-227"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.2.1">Hands-On and Going Forward</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Congratulations, you have reached the last chapter of this book, and nothing is better than having some real examples using network automation to help consolidate all of the knowledge learned. </span><span class="koboSpan" id="kobo.3.2">We probably won’t be able to write examples on all the subjects covered in this book, but the idea is to have at least a foundation for further experimentation and learning.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In this chapter, we are going to build a network from scratch using our network automation skills and emulated routers. </span><span class="koboSpan" id="kobo.4.2">The finished network emulated will have enough components for us to experiment with several techniques described in this book. </span><span class="koboSpan" id="kobo.4.3">You will be able to use it for your own experimentation whenever you need it.</span></p>
<p><span class="koboSpan" id="kobo.5.1">We are also going to add a few remarks and some guidance for future studies and work, which should be good enough to wrap up the book.</span></p>
<p><span class="koboSpan" id="kobo.6.1">At the end of this chapter, you are going to be able to build your own network emulation and experiment with your own network automation projects within your own computer, which will give you a great environment foundation for future experimentation and learning.</span></p>
<p><span class="koboSpan" id="kobo.7.1">We are going to cover the following topics in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">Using a network lab</span></li>
<li><span class="koboSpan" id="kobo.9.1">Building our network lab</span></li>
<li><span class="koboSpan" id="kobo.10.1">Connecting the devices</span></li>
<li><span class="koboSpan" id="kobo.11.1">Adding automation</span></li>
<li><span class="koboSpan" id="kobo.12.1">Going forward and further studies</span></li>
</ul>
<h1 id="_idParaDest-228"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">The source code described in this chapter is stored in the GitHub repository at  </span><a href="https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10"><span class="koboSpan" id="kobo.15.1">https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10</span></a><span class="koboSpan" id="kobo.16.1">.</span></p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.17.1">Using a network lab</span></h1>
<p><span class="koboSpan" id="kobo.18.1">It’s time for </span><a id="_idIndexMarker1130"/><span class="koboSpan" id="kobo.19.1">us to do some real code automation tests in a virtual environment. </span><span class="koboSpan" id="kobo.19.2">Certain open source and commercial products can be used in your environment for testing network automation. </span><span class="koboSpan" id="kobo.19.3">The differences between the commercial and open source solutions rely on the number of different types of devices that are supported and how to scale. </span><span class="koboSpan" id="kobo.19.4">Using an open source solution, you might be able to scale up thousands of devices, but it would be limited in terms of the types of devices that can be emulated. </span><span class="koboSpan" id="kobo.19.5">A combination of a commercial and open source network might be more useful.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Cisco has a program that allows the public to access emulated routers in a virtual lab; they are called sandboxes. </span><span class="koboSpan" id="kobo.20.2">Cisco offers free 24/7 remote access to its sandboxes, but the number of devices is limited. </span><span class="koboSpan" id="kobo.20.3">More </span><a id="_idIndexMarker1131"/><span class="koboSpan" id="kobo.21.1">on Cisco sandboxes can be found at </span><a href="https://developer.cisco.com/site/sandbox/"><span class="koboSpan" id="kobo.22.1">https://developer.cisco.com/site/sandbox/</span></a><span class="koboSpan" id="kobo.23.1">.</span></p>
<p><span class="koboSpan" id="kobo.24.1">As an example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">scrapligo</span></strong><span class="koboSpan" id="kobo.26.1"> project, described in </span><a href="B18165_06.xhtml#_idTextAnchor166"><em class="italic"><span class="koboSpan" id="kobo.27.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.28.1">, uses Cisco sandboxes; check details on the usage at </span><a href="https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14"><span class="koboSpan" id="kobo.29.1">https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14</span></a><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">There are also other commercial products, such as Cisco Packet Tracer, which is part of</span><a id="_idIndexMarker1132"/><span class="koboSpan" id="kobo.31.1"> the Cisco Network Academy (https://www.netacad.com/courses/packet-tracer), and </span><a id="_idIndexMarker1133"/><span class="koboSpan" id="kobo.32.1">EVE-NG (</span><a href="https://www.eve-ng.net/"><span class="koboSpan" id="kobo.33.1">https://www.eve-ng.net/</span></a><span class="koboSpan" id="kobo.34.1">).</span></p>
<p><span class="koboSpan" id="kobo.35.1">In terms of open source, the most popular ones </span><a id="_idIndexMarker1134"/><span class="koboSpan" id="kobo.36.1">are GNS3 (</span><a href="https://gns3.com/"><span class="koboSpan" id="kobo.37.1">https://gns3.com/</span></a><span class="koboSpan" id="kobo.38.1">) and</span><a id="_idIndexMarker1135"/><span class="koboSpan" id="kobo.39.1"> Mininet (</span><a href="http://mininet.org"><span class="koboSpan" id="kobo.40.1">http://mininet.org</span></a><span class="koboSpan" id="kobo.41.1">/). </span><span class="koboSpan" id="kobo.41.2">Mininet uses Linux containers to scale up the network, while GNS3 is more focused on virtual machines such as</span><a id="_idIndexMarker1136"/><span class="koboSpan" id="kobo.42.1"> Dynamips. </span><span class="koboSpan" id="kobo.42.2">Therefore, GNS3 can run with several different router types but is limited in scale. </span><span class="koboSpan" id="kobo.42.3">On the other hand, Mininet can scale to thousands, but with only one router type, which is more appropriate for testing network concepts and network topologies instead of functionalities.</span></p>
<p><span class="koboSpan" id="kobo.43.1">For us, it will be more interesting to start from the ground and build our own network lab, which will give us more insights on how to use it and how we can use network automation tools, which, in fact, will be helpful later for real networks. </span><span class="koboSpan" id="kobo.43.2">The basis of our network lab</span><a id="_idIndexMarker1137"/><span class="koboSpan" id="kobo.44.1"> will be Linux containers. </span><span class="koboSpan" id="kobo.44.2">Consequently, we need to use routers that can be easily containerized, and because of license issues, we should stick with open source solutions such as FRRouting, Quagga, OpenWRT, or DD-WRT, as described in </span><a href="B18165_09.xhtml#_idTextAnchor209"><em class="italic"><span class="koboSpan" id="kobo.45.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.46.1">.</span></p>
<p><span class="koboSpan" id="kobo.47.1">Our network lab will use FRRouting as the basis of our routers, which has an interface configuration close to Cisco routers and can be accessed via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">vtysh</span></strong><span class="koboSpan" id="kobo.49.1"> command. </span><span class="koboSpan" id="kobo.49.2">More details on</span><a id="_idIndexMarker1138"/><span class="koboSpan" id="kobo.50.1"> FRRouting setup and configuration can be found at </span><a href="https://docs.frrouting.org/en/latest/basic.html"><span class="koboSpan" id="kobo.51.1">https://docs.frrouting.org/en/latest/basic.html</span></a><span class="koboSpan" id="kobo.52.1">.</span></p>
<p><span class="koboSpan" id="kobo.53.1">Let’s now build our own network lab.</span></p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.54.1">Building our network lab</span></h1>
<p><span class="koboSpan" id="kobo.55.1">In our </span><a id="_idIndexMarker1139"/><span class="koboSpan" id="kobo.56.1">network lab, we are going to use Linux containers for all our devices. </span><span class="koboSpan" id="kobo.56.2">There will basically be two types of devices, one running a router and one running Linux. </span><span class="koboSpan" id="kobo.56.3">The Linux containers that are not working as routers are going to be used to generate traffic or to receive traffic; they are going to mimic a user’s PC and a server on the internet.</span></p>
<p><span class="koboSpan" id="kobo.57.1">The intended topology is described in the following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.58.1"><img alt="Figure 10.1 – Network lab topology" src="image/B18165_10_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.59.1">Figure 10.1 – Network lab topology</span></p>
<p><span class="koboSpan" id="kobo.60.1">The containers that are going to work as routers are the white rectangles in </span><em class="italic"><span class="koboSpan" id="kobo.61.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.62.1">, the yellow rectangles are going to work as user PCs, and the green rectangle is going to emulate the servers on the internet.</span></p>
<p><span class="koboSpan" id="kobo.63.1">In total, the </span><a id="_idIndexMarker1140"/><span class="koboSpan" id="kobo.64.1">network lab will have 16 routers, 3 PCs, and 1 server. </span><span class="koboSpan" id="kobo.64.2">The container images to be used in the network lab were created using Docker and stored in</span><a id="_idIndexMarker1141"/><span class="koboSpan" id="kobo.65.1"> Docker Hub (</span><a href="https://hub.docker.com/"><span class="koboSpan" id="kobo.66.1">https://hub.docker.com/</span></a><span class="koboSpan" id="kobo.67.1">), which are publicly available and can be used for image download. </span><span class="koboSpan" id="kobo.67.2">The routers were created based on the</span><a id="_idIndexMarker1142"/><span class="koboSpan" id="kobo.68.1"> FRRouting docker image (</span><a href="https://hub.docker.com/r/frrouting/frr"><span class="koboSpan" id="kobo.69.1">https://hub.docker.com/r/frrouting/frr</span></a><span class="koboSpan" id="kobo.70.1">) and the PCs and server were created based on the</span><a id="_idIndexMarker1143"/><span class="koboSpan" id="kobo.71.1"> Alpine Linux Docker image (</span><a href="https://hub.docker.com/_/alpine"><span class="koboSpan" id="kobo.72.1">https://hub.docker.com/_/alpine</span></a><span class="koboSpan" id="kobo.73.1">).</span></p>
<p><span class="koboSpan" id="kobo.74.1">The original images were slightly modified with a few more tools and configuration changes to create three new images. </span><span class="koboSpan" id="kobo.74.2">The image for the routers is </span><a href="https://hub.docker.com/r/brnuts/routerlab"><span class="koboSpan" id="kobo.75.1">hub.docker.com/r/brnuts/routerlab</span></a><span class="koboSpan" id="kobo.76.1">, the image for the PCs is </span><a href="https://hub.docker.com/r/brnuts/pclab"><span class="koboSpan" id="kobo.77.1">hub.docker.com/r/brnuts/pclab</span></a><span class="koboSpan" id="kobo.78.1">, and the image for the internet is </span><a href="https://hub.docker.com/r/brnuts/internetlab"><span class="koboSpan" id="kobo.79.1">hub.docker.com/r/brnuts/internetlab</span></a><span class="koboSpan" id="kobo.80.1">.</span></p>
<p><span class="koboSpan" id="kobo.81.1">Let’s see now how we can launch our lab host.</span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.82.1">Launching the lab host</span></h2>
<p><span class="koboSpan" id="kobo.83.1">The</span><a id="_idIndexMarker1144"/><span class="koboSpan" id="kobo.84.1"> Linux containers need a host to run from. </span><span class="koboSpan" id="kobo.84.2">Therefore, you will first need to launch the Linux host where the routers will be running. </span><span class="koboSpan" id="kobo.84.3">I prepared two pre-built images to help, one for VirtualBox and another for Qemu. </span><span class="koboSpan" id="kobo.84.4">You can get instructions on how to download them and launch them on GitHub: </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">Chapter10/NetworkLab/README.md</span></strong><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">These virtual machine images use Debian Linux.</span></p>
<p><span class="koboSpan" id="kobo.87.1">However, if you don’t want to use the pre-built virtual machine, I have also included instructions on how to build your own host, which is basically any Linux distribution with additional packages and some configuration changes. </span><span class="koboSpan" id="kobo.87.2">If you build your own image, you will need to start all containers by yourself. </span><span class="koboSpan" id="kobo.87.3">I have added a script in Shell that should be able to do that, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">start-containers.sh</span></strong><span class="koboSpan" id="kobo.89.1">.</span></p>
<p><span class="koboSpan" id="kobo.90.1">Once you have launched the host, let’s see how we can check whether it was launched properly.</span></p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.91.1">Checking the lab host</span></h2>
<p><span class="koboSpan" id="kobo.92.1">After </span><a id="_idIndexMarker1145"/><span class="koboSpan" id="kobo.93.1">uncompressing and launching the pre-built image, you should be able to see all devices running once the host has finished the boot sequence. </span><span class="koboSpan" id="kobo.93.2">The reason is that I have updated the containers so that they restart automatically unless explicitly stopped.</span></p>
<p><span class="koboSpan" id="kobo.94.1">To verify whether the containers representing the devices are running, you just need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">docker ps</span></strong><span class="koboSpan" id="kobo.96.1"> command, as in the following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.97.1"><img alt="Figure 10.2 – Output showing all devices running on the network lab" src="image/B18165_10_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.98.1">Figure 10.2 – Output showing all devices running on the network lab</span></p>
<p><span class="koboSpan" id="kobo.99.1">The output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">docker ps</span></strong><span class="koboSpan" id="kobo.101.1"> command should show all running devices, which should be, in total, 20 containers, 16 representing routers (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">brnuts/routerlab</span></strong><span class="koboSpan" id="kobo.103.1"> image), 3 representing PCs (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">brnuts/pclab</span></strong><span class="koboSpan" id="kobo.105.1"> image), and 1 representing the internet (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">brnuts/internetlab</span></strong><span class="koboSpan" id="kobo.107.1"> image).</span></p>
<p><span class="koboSpan" id="kobo.108.1">I have also added volumes to all containers and attached them as persistent storage, so configuration changes won’t be removed even on restarting the container. </span><span class="koboSpan" id="kobo.108.2">To see the volumes, you can just type in </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">docker volume list</span></strong><span class="koboSpan" id="kobo.110.1">.</span></p>
<p><span class="koboSpan" id="kobo.111.1">Now, check whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.113.1"> was updated with the IPs of the containers. </span><span class="koboSpan" id="kobo.113.2">You should be able to see several lines after </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1"># BEGIN DOCKER CONTAINERS</span></strong><span class="koboSpan" id="kobo.115.1">, as in the example in the following screenshot. </span><span class="koboSpan" id="kobo.115.2">This file is updated by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">update-hosts.sh</span></strong><span class="koboSpan" id="kobo.117.1"> script included by </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">systemctl</span></strong><span class="koboSpan" id="kobo.119.1">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.120.1"><img alt="Figure 10.3 – Checking the /etc/hosts file" src="image/B18165_10_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.121.1">Figure 10.3 – Checking the /etc/hosts file</span></p>
<p><span class="koboSpan" id="kobo.122.1">We are </span><a id="_idIndexMarker1146"/><span class="koboSpan" id="kobo.123.1">going to explain later why we need LLDP in the next section, but for now, let’s just check whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">lldpd</span></strong><span class="koboSpan" id="kobo.125.1"> is running on the host using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">systemctl status lldpd.service</span></strong><span class="koboSpan" id="kobo.127.1"> command:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.128.1"><img alt="Figure 10.4 – Checking whether lldpd is running on the host" src="image/B18165_10_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.129.1">Figure 10.4 – Checking whether lldpd is running on the host</span></p>
<p><span class="koboSpan" id="kobo.130.1">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">lldpd</span></strong><span class="koboSpan" id="kobo.132.1"> daemon is running correctly, you should be able to see </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">active (running)</span></strong><span class="koboSpan" id="kobo.134.1"> in green, as in the preceding screenshot.</span></p>
<p><span class="koboSpan" id="kobo.135.1">Now, we should be ready to start doing some network automation to finish building our lab. </span><span class="koboSpan" id="kobo.135.2">Let’s now see how we connect the devices.</span></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.136.1">Connecting the devices</span></h1>
<p><span class="koboSpan" id="kobo.137.1">Connecting </span><a id="_idIndexMarker1147"/><span class="koboSpan" id="kobo.138.1">the devices in our network lab will be done by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">veth</span></strong><span class="koboSpan" id="kobo.140.1"> peer interfaces as was explained in </span><a href="B18165_09.xhtml#_idTextAnchor209"><em class="italic"><span class="koboSpan" id="kobo.141.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.142.1">. </span><span class="koboSpan" id="kobo.142.2">If we need to connect two different labs from two different hosts, we can use VXLAN, but for our exercise in this section, we are only making connections on the same host. </span><span class="koboSpan" id="kobo.142.3">Therefore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">veth</span></strong><span class="koboSpan" id="kobo.144.1"> peer interfaces will do the job.</span></p>
<p><span class="koboSpan" id="kobo.145.1">One protocol that I have included in the pre-built virtual machine image and will be very important to </span><a id="_idIndexMarker1148"/><span class="koboSpan" id="kobo.146.1">us is </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">Link Layer Discovery Protocol</span></strong><span class="koboSpan" id="kobo.148.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.149.1">LLDP</span></strong><span class="koboSpan" id="kobo.150.1">). </span><span class="koboSpan" id="kobo.150.2">LLDP is one IETF standard that came after the successful Cisco proprietary protocol </span><a id="_idIndexMarker1149"/><span class="koboSpan" id="kobo.151.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">Cisco Discovery Protocol</span></strong><span class="koboSpan" id="kobo.153.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.154.1">CDP</span></strong><span class="koboSpan" id="kobo.155.1">). </span><span class="koboSpan" id="kobo.155.2">It is used to obtain information about the other side of a layer 2 connection by sending specific Ethernet frames. </span><span class="koboSpan" id="kobo.155.3">We are going to use it to validate the connections between devices in our network lab.</span></p>
<p><span class="koboSpan" id="kobo.156.1">Before we proceed with our connections, let’s check how Docker created our </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">out-of-band</span></strong><span class="koboSpan" id="kobo.158.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.159.1">OOB</span></strong><span class="koboSpan" id="kobo.160.1">) management network.</span></p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.161.1">The OOB management network</span></h2>
<p><span class="koboSpan" id="kobo.162.1">Docker, by </span><a id="_idIndexMarker1150"/><span class="koboSpan" id="kobo.163.1">default, creates a </span><a id="_idIndexMarker1151"/><span class="koboSpan" id="kobo.164.1">network connecting all containers, which we are going to use as our OOB management network (described in </span><a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic"><span class="koboSpan" id="kobo.165.1">Chapter 1</span></em></a><span class="koboSpan" id="kobo.166.1">). </span><span class="koboSpan" id="kobo.166.2">To do that, Docker creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">veth</span></strong><span class="koboSpan" id="kobo.168.1"> interface peers between the container and the host. </span><span class="koboSpan" id="kobo.168.2">On the container side, Docker attributes </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">eth0</span></strong><span class="koboSpan" id="kobo.170.1"> as the name, and on the other side, uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">veth</span></strong><span class="koboSpan" id="kobo.172.1"> followed by some hexadecimal characters to make it unique – for instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">veth089f94f</span></strong><span class="koboSpan" id="kobo.174.1">.</span></p>
<p><span class="koboSpan" id="kobo.175.1">All </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">veth</span></strong><span class="koboSpan" id="kobo.177.1"> interfaces located on the host are then connected to a software bridge called </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">docker0</span></strong><span class="koboSpan" id="kobo.179.1">. </span><span class="koboSpan" id="kobo.179.2">To use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">brctl</span></strong><span class="koboSpan" id="kobo.181.1"> command, you might need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">bridge-utils</span></strong><span class="koboSpan" id="kobo.183.1"> package by doing </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">sudo apt install bridge-utils</span></strong><span class="koboSpan" id="kobo.185.1">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.186.1"><img alt="Figure 10.5 – Checking interfaces on the docker0 bridge" src="image/B18165_10_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.187.1">Figure 10.5 – Checking interfaces on the docker0 bridge</span></p>
<p><span class="koboSpan" id="kobo.188.1">To verify</span><a id="_idIndexMarker1152"/><span class="koboSpan" id="kobo.189.1"> which </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">veth</span></strong><span class="koboSpan" id="kobo.191.1"> interface</span><a id="_idIndexMarker1153"/><span class="koboSpan" id="kobo.192.1"> belongs to which container, you might need to perform two commands, as in the following example:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.193.1"><img alt="Figure 10.6 – Checking the veth peer name on the host for a container" src="image/B18165_10_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.194.1">Figure 10.6 – Checking the veth peer name on the host for a container</span></p>
<p><span class="koboSpan" id="kobo.195.1">As you can see in the output of the preceding screenshot, to identify which </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">veth</span></strong><span class="koboSpan" id="kobo.197.1"> peer interface belongs to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">border</span></strong><span class="koboSpan" id="kobo.199.1"> router, you need to execute a command inside the container to obtain an index for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">eth0</span></strong><span class="koboSpan" id="kobo.201.1"> interface, which, in this case, was </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">23</span></strong><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">Once you have the index, you can check which </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">veth</span></strong><span class="koboSpan" id="kobo.205.1"> interface on the host has the index by using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">grep</span></strong><span class="koboSpan" id="kobo.207.1"> command on all files.</span></p>
<p><span class="koboSpan" id="kobo.208.1">We can also use LLDP to find out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">veth</span></strong><span class="koboSpan" id="kobo.210.1"> interface name by doing the command directly on the router:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.211.1"><img alt="Figure 10.7 – Showing the LLDP neighbor inside the border router" src="image/B18165_10_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.212.1">Figure 10.7 – Showing the LLDP neighbor inside the border router</span></p>
<p><span class="koboSpan" id="kobo.213.1">The </span><a id="_idIndexMarker1154"/><span class="koboSpan" id="kobo.214.1">preceding screenshot </span><a id="_idIndexMarker1155"/><span class="koboSpan" id="kobo.215.1">shows a successful output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">lldpctl</span></strong><span class="koboSpan" id="kobo.217.1"> showing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">eth0</span></strong><span class="koboSpan" id="kobo.219.1"> interface’s neighbor, which, in this case, is the host Debian Linux, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">SysName</span></strong><span class="koboSpan" id="kobo.221.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">netlab</span></strong><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">The interface that peers with </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">eth0</span></strong><span class="koboSpan" id="kobo.225.1"> on the border router is described in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">PortDescr</span></strong><span class="koboSpan" id="kobo.227.1"> field as </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">veth089f94f</span></strong><span class="koboSpan" id="kobo.229.1"> – the same interface that we discovered using the commands in </span><em class="italic"><span class="koboSpan" id="kobo.230.1">Figure 10.6</span></em><span class="koboSpan" id="kobo.231.1">.</span></p>
<p><span class="koboSpan" id="kobo.232.1">However, why not use the first method described in </span><em class="italic"><span class="koboSpan" id="kobo.233.1">Figure 10.6</span></em><span class="koboSpan" id="kobo.234.1"> to find out the connection instead of LLDP? </span><span class="koboSpan" id="kobo.234.2">Because in real networks, LLDP is used to identify the connections between devices. </span><span class="koboSpan" id="kobo.234.3">Thus, writing an automation code to verify all the network connections in the lab using LLDP can also be used in production. </span><span class="koboSpan" id="kobo.234.4">Our lab will be used as the first place to test our automation code – in this case, checking the LLDP topology.</span></p>
<p><span class="koboSpan" id="kobo.235.1">By now, you have probably noticed that we can access the routers just by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">docker exec &lt;name of the router&gt;</span></strong><span class="koboSpan" id="kobo.237.1"> command, so why do we need the OOB management network to access the devices? </span><span class="koboSpan" id="kobo.237.2">The answer is like the LLDP case – with OOB network access, the devices can be accessed via SSH, which is what we are going to do in production. </span><span class="koboSpan" id="kobo.237.3">Consequently, any code developed for the lab can be used in production.</span></p>
<p><span class="koboSpan" id="kobo.238.1">To test </span><a id="_idIndexMarker1156"/><span class="koboSpan" id="kobo.239.1">our lab OOB management</span><a id="_idIndexMarker1157"/><span class="koboSpan" id="kobo.240.1"> network, we just need to access the device via the IP using </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">ping</span></strong><span class="koboSpan" id="kobo.242.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">ssh</span></strong><span class="koboSpan" id="kobo.244.1"> commands – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">ping cpe-a</span></strong><span class="koboSpan" id="kobo.246.1"> command, for example:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.247.1"><img alt="Figure 10.8 – Testing connection to a router from the host using OOB" src="image/B18165_10_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.248.1">Figure 10.8 – Testing connection to a router from the host using OOB</span></p>
<p><span class="koboSpan" id="kobo.249.1">You should also be able to SSH to any container, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">netlab</span></strong><span class="koboSpan" id="kobo.251.1"> for the username and password:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.252.1"><img alt="Figure 10.9 – Testing whether you can access a device via SSH using OOB" src="image/B18165_10_009.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.253.1">Figure 10.9 – Testing whether you can access a device via SSH using OOB</span></p>
<p><span class="koboSpan" id="kobo.254.1">Now that we know how our OOB management network works in our lab, let’s connect the devices using the OOB network.</span></p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.255.1">Looking at the topology</span></h2>
<p><em class="italic"><span class="koboSpan" id="kobo.256.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.257.1"> shows</span><a id="_idIndexMarker1158"/><span class="koboSpan" id="kobo.258.1"> the topology that we are aiming to create. </span><span class="koboSpan" id="kobo.258.2">The devices in our lab are running and connected to an OOB network, but they do not have connections like the topology described in </span><em class="italic"><span class="koboSpan" id="kobo.259.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.260.1">.</span></p>
<p><span class="koboSpan" id="kobo.261.1">In addition to the diagram, there is also a formal topology description in a file on GitHub, which can be accessed at </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Chapter10/NetworkLab/topology.yaml</span></strong><span class="koboSpan" id="kobo.263.1">. </span><span class="koboSpan" id="kobo.263.2">The file describes the routers in the topology and their connections. </span><span class="koboSpan" id="kobo.263.3">It is a simple version of network definition in YAML format as we discussed in </span><a href="B18165_04.xhtml#_idTextAnchor100"><em class="italic"><span class="koboSpan" id="kobo.264.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.265.1">.</span></p>
<p><span class="koboSpan" id="kobo.266.1">The topology file has basically two main keys, </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">devices</span></strong><span class="koboSpan" id="kobo.268.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">links</span></strong><span class="koboSpan" id="kobo.270.1">. </span><span class="koboSpan" id="kobo.270.2">These keys should describe the same connections shown in </span><em class="italic"><span class="koboSpan" id="kobo.271.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.272.1">. </span><span class="koboSpan" id="kobo.272.2">The following is a sample of the file for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">devices</span></strong><span class="koboSpan" id="kobo.274.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">links</span></strong><span class="koboSpan" id="kobo.276.1"> keys:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
devices:
  - name: acc-a
    type: router_acc
    image: brnuts/routerlab
  - name: acc-b
    type: router_acc
    image: brnuts/routerlab
links:
  - name: [pc, cpe]
    connection: [pc-a, cpe-a]
  - name: [cpe, acc]
    connection: [cpe-a, acc-a]</span></pre>
<p><span class="koboSpan" id="kobo.278.1">The file should contain all the links that are depicted in </span><em class="italic"><span class="koboSpan" id="kobo.279.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">Ideally, the diagram in </span><em class="italic"><span class="koboSpan" id="kobo.281.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.282.1"> should be created automatically by a tool reading from </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">topology.yaml</span></strong><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">In our example, the diagram and the YAML file are the same, but I have built the diagram manually myself, and for any topology change, I need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">topology.yaml</span></strong><span class="koboSpan" id="kobo.286.1"> file and the diagram. </span><span class="koboSpan" id="kobo.286.2">This problem was discussed as well in </span><a href="B18165_04.xhtml#_idTextAnchor100"><em class="italic"><span class="koboSpan" id="kobo.287.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.288.1">, and the update synchronization</span><a id="_idIndexMarker1159"/><span class="koboSpan" id="kobo.289.1"> between a  file and a diagram tends to break as the topology gets more complex. </span><span class="koboSpan" id="kobo.289.2">But, for our examples using this small topology, an automated diagram builder is not necessary.</span></p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.290.1">Creating the connections between devices</span></h2>
<p><span class="koboSpan" id="kobo.291.1">To connect the</span><a id="_idIndexMarker1160"/><span class="koboSpan" id="kobo.292.1"> devices, like in the topology, we have to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">veth</span></strong><span class="koboSpan" id="kobo.294.1"> peer interfaces, and as we discussed in </span><a href="B18165_09.xhtml#_idTextAnchor209"><em class="italic"><span class="koboSpan" id="kobo.295.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.296.1">, we need the namespace numbers for each side of the peer and the interface names we going to use. </span><span class="koboSpan" id="kobo.296.2">Most of the connections in </span><em class="italic"><span class="koboSpan" id="kobo.297.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.298.1"> are point-to-point between devices, except for the connections to the </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">backbone</span></strong><span class="koboSpan" id="kobo.300.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">WAN</span></strong><span class="koboSpan" id="kobo.302.1">.</span></p>
<p><span class="koboSpan" id="kobo.303.1">The following diagram shows all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">veth</span></strong><span class="koboSpan" id="kobo.305.1"> peers that we must configure; the majority are connected between two containers in a point-to-point configuration. </span><span class="koboSpan" id="kobo.305.2">However, the core routers will use, let’s say, backbone veth or WAN veth, because they are connected in a multi-to-multi-point environment, similar to a WAN. </span><span class="koboSpan" id="kobo.305.3">For that, we are going to use a software bridge in the host to provide connectivity between the backbone veth – latency and packet loss can be added to the bridge interfaces if tests for network degradation are required:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.306.1"><img alt="Figure 10.10 – Lab topology showing all veth peer interfaces" src="image/B18165_10_010.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.307.1">Figure 10.10 – Lab topology showing all veth peer interfaces</span></p>
<p><span class="koboSpan" id="kobo.308.1">When we start creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">veth</span></strong><span class="koboSpan" id="kobo.310.1"> interfaces for the backbone to connect all core routers, we are going to use one namespace on the host and the other in the core router. </span><span class="koboSpan" id="kobo.310.2">This</span><a id="_idIndexMarker1161"/><span class="koboSpan" id="kobo.311.1"> is different from all other veth, which will have two namespaces. </span><span class="koboSpan" id="kobo.311.2">The following is one example of how to create a connection manually between </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">pc-a</span></strong><span class="koboSpan" id="kobo.313.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">cpe-a</span></strong><span class="koboSpan" id="kobo.315.1">:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.316.1">
netlab@netlab:~$ docker inspect -f '{{.State.Pid}}' pc-a
1069
netlab@netlab:~$ docker inspect -f '{{.State.Pid}}' cpe-a
1063
netlab@netlab:~$ sudo ip link add pc-cpe type veth peer name cpe-pc
netlab@netlab:~$ sudo ip link set pc-cpe netns 1069
netlab@netlab:~$ sudo ip link set cpe-pc netns 1063
netlab@netlab:~$ docker exec pc-a ip link set pc-cpe up
netlab@netlab:~$ docker exec cpe-a ip link set cpe-pc up</span></pre>
<p><span class="koboSpan" id="kobo.317.1">As we can see in these commands, first, we need to obtain the network namespace IDs of each router we want to connect, and then we can create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">veth</span></strong><span class="koboSpan" id="kobo.319.1"> peer and attribute each side of the peer to a namespace ID. </span><span class="koboSpan" id="kobo.319.2">Finally, we bring the interfaces up on each router. </span><span class="koboSpan" id="kobo.319.3">Note that the interface name on </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">pc-a</span></strong><span class="koboSpan" id="kobo.321.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">pc-cpe</span></strong><span class="koboSpan" id="kobo.323.1"> and on </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">cpe-a</span></strong><span class="koboSpan" id="kobo.325.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">cpe-pc</span></strong><span class="koboSpan" id="kobo.327.1">, to help identify the direction in which the interface goes.</span></p>
<p><span class="koboSpan" id="kobo.328.1">To verify whether our connection between the routers was created properly, we can run the following command:</span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.329.1"><img alt="Figure 10.11 – Checking the connection between pc-a and cpe-a" src="image/B18165_10_011.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.330.1">Figure 10.11 – Checking the connection between pc-a and cpe-a</span></p>
<p><span class="koboSpan" id="kobo.331.1">Now, we can </span><a id="_idIndexMarker1162"/><span class="koboSpan" id="kobo.332.1">confirm that </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">pc-a</span></strong><span class="koboSpan" id="kobo.334.1"> is connected to </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">cpe-a</span></strong><span class="koboSpan" id="kobo.336.1"> by looking into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">lldpctl</span></strong><span class="koboSpan" id="kobo.338.1"> command output in </span><em class="italic"><span class="koboSpan" id="kobo.339.1">Figure 10.11</span></em><span class="koboSpan" id="kobo.340.1">. </span><span class="koboSpan" id="kobo.340.2">The output shows the name for </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">SysName</span></strong><span class="koboSpan" id="kobo.342.1">, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">cpe-a</span></strong><span class="koboSpan" id="kobo.344.1">, confirming the connection. </span><span class="koboSpan" id="kobo.344.2">We can also see the interface name on the other side, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">cpe-pc</span></strong><span class="koboSpan" id="kobo.346.1">.</span></p>
<p><span class="koboSpan" id="kobo.347.1">Let’s now see how we automate the device connections.</span></p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.348.1">Automating the connections</span></h2>
<p><span class="koboSpan" id="kobo.349.1">Our lab now</span><a id="_idIndexMarker1163"/><span class="koboSpan" id="kobo.350.1"> has all devices running, and we are going to connect all devices using a program that will connect all devices. </span><span class="koboSpan" id="kobo.350.2">You can get access to the program on </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">Chapter10/NetworkLab/AUTOMATION.md</span></strong><span class="koboSpan" id="kobo.352.1">.</span></p>
<p><span class="koboSpan" id="kobo.353.1">To install it on your computer, just need to clone it using the following:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.354.1">
claus@dev % </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">git clone https://github.com/brnuts/netlab.git</span></strong><span class="koboSpan" id="kobo.356.1">
Cloning into 'netlab'…
remote: Enumerating objects: 103, done.
</span><span class="koboSpan" id="kobo.356.2">remote: Counting objects: 100% (103/103), done.
</span><span class="koboSpan" id="kobo.356.3">remote: Compressing objects: 100% (79/79), done.
</span><span class="koboSpan" id="kobo.356.4">remote: Total 103, reused 44 (delta 12), pack-reused 0
Receiving objects: 100% (103/103), 58 KiB | .9 MiB/s, done.
</span><span class="koboSpan" id="kobo.356.5">Resolving deltas: 100% (36/36), done.</span></pre>
<p><span class="koboSpan" id="kobo.357.1">Then, you need to build the Go program:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.358.1">
claus@dev % </span><strong class="bold"><span class="koboSpan" id="kobo.359.1">go build</span></strong><span class="koboSpan" id="kobo.360.1">
claus@dev % ls -lah netlab
-rwxr-xr-x  1 user  staff   5.3M Feb  8 11:54 netlab</span></pre>
<p><span class="koboSpan" id="kobo.361.1">If you are </span><a id="_idIndexMarker1164"/><span class="koboSpan" id="kobo.362.1">using the pre-build VirtualBox image, you probably are accessing the network lab via SSH on localhost port </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">22</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">Then, you just need to run it like so:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.365.1">
claus@dev % ./netlab</span></pre>
<p><span class="koboSpan" id="kobo.366.1">If you are using QEMU or your own Linux virtual machine with the network lab, you can pass the username, password, and IP of the host as follows:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.367.1">
claus@dev % ./netlab -host 10.0.4.1 -user oper -pw secret</span></pre>
<p><span class="koboSpan" id="kobo.368.1">A small help guide can be accessed by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">-help</span></strong><span class="koboSpan" id="kobo.370.1">, like here:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.371.1">
claus@dev % ./netlab -help
Usage of ./netlab:
  -host string
      Host IP for netlab (default "localhost")
  -port uint
      SSH port to access Host IP for netlab (default 22)
  -pw string
      Password to access netlab host (default "netlab")
  -topo string
      Topology yaml file (default "topology.yaml")
  -user string
      Username to access netlab host (default "netlab")</span></pre>
<p><span class="koboSpan" id="kobo.372.1">The program</span><a id="_idIndexMarker1165"/><span class="koboSpan" id="kobo.373.1"> shows some logs on the output, and a successful run should show similar lines to the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.374.1"><img alt="Figure 10.12 – Running the Go automation program to connect devices" src="image/B18165_10_012.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.375.1">Figure 10.12 – Running the Go automation program to connect devices</span></p>
<p><span class="koboSpan" id="kobo.376.1">As you can see in the preceding screenshot, the program takes around 12 seconds to run, and it should show </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">all done successfully</span></strong><span class="koboSpan" id="kobo.378.1"> at the end.</span></p>
<p><span class="koboSpan" id="kobo.379.1">Let’s have a look at this program and what it is doing.</span></p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.380.1">Looking into the automation program</span></h2>
<p><span class="koboSpan" id="kobo.381.1">In our </span><a id="_idIndexMarker1166"/><span class="koboSpan" id="kobo.382.1">example, the program was written in Go, and the directory where it is located consists of nine files, of which six are Go source code with </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">.go</span></strong><span class="koboSpan" id="kobo.384.1"> extensions as shown here:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.385.1">
claus@dev % ls –1
go.mod
go.sum
hostconnect.go
netlab.go
readtopology.go
runcommand.go
topology.yaml
types.go
vethcommands.go</span></pre>
<p><span class="koboSpan" id="kobo.386.1">Let’s discuss each file.</span></p>
<h3><span class="koboSpan" id="kobo.387.1">go.mod and go.sum</span></h3>
<p><span class="koboSpan" id="kobo.388.1">These</span><a id="_idIndexMarker1167"/><span class="koboSpan" id="kobo.389.1"> files are used by the Go builder for package dependency</span><a id="_idIndexMarker1168"/><span class="koboSpan" id="kobo.390.1"> management; they contain all the necessary information to add the third-party library to our program. </span><span class="koboSpan" id="kobo.390.2">Every time we import a package, it automatically updates these files. </span><span class="koboSpan" id="kobo.390.3">More on these files can be obtained at </span><a href="https://go.dev/ref/mod"><span class="koboSpan" id="kobo.391.1">https://go.dev/ref/mod</span></a><span class="koboSpan" id="kobo.392.1">.</span></p>
<h3><span class="koboSpan" id="kobo.393.1">topology.yaml</span></h3>
<p><span class="koboSpan" id="kobo.394.1">This contains </span><a id="_idIndexMarker1169"/><span class="koboSpan" id="kobo.395.1">the description of the topology that is shown in </span><em class="italic"><span class="koboSpan" id="kobo.396.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.397.1">.</span></p>
<h3><span class="koboSpan" id="kobo.398.1">types.go</span></h3>
<p><span class="koboSpan" id="kobo.399.1">This </span><a id="_idIndexMarker1170"/><span class="koboSpan" id="kobo.400.1">contains all the data structure definitions used in the program, which include variable types and the YAML topology data structure. </span><span class="koboSpan" id="kobo.400.2">Different from Python, in Go, it is better to specify the data structure that you are going to read from a YAML file. </span><span class="koboSpan" id="kobo.400.3">In our case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">TopologyConfType</span></strong><span class="koboSpan" id="kobo.402.1"> struct type is used to define the YAML file structure, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
type DeviceTopologyType struct {
        Name  string
        Type  string
        Image string
}
type LinkTopologyType struct {
        Name       []string
        Connection []string
}
type </span><strong class="bold"><span class="koboSpan" id="kobo.404.1">TopologyConfType</span></strong><span class="koboSpan" id="kobo.405.1"> struct {
        Devices []DeviceTopologyType
        Links   []LinkTopologyType
}</span></pre>
<h3><span class="koboSpan" id="kobo.406.1">readtopology.go</span></h3>
<p><span class="koboSpan" id="kobo.407.1">This </span><a id="_idIndexMarker1171"/><span class="koboSpan" id="kobo.408.1">contains the function that is used to read the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">topology.yaml</span></strong><span class="koboSpan" id="kobo.410.1"> file. </span><span class="koboSpan" id="kobo.410.2">The data structure of this file is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">TopologyConfType</span></strong><span class="koboSpan" id="kobo.412.1"> structure type.</span></p>
<h3><span class="koboSpan" id="kobo.413.1">runcommand.go</span></h3>
<p><span class="koboSpan" id="kobo.414.1">This </span><a id="_idIndexMarker1172"/><span class="koboSpan" id="kobo.415.1">contains generic functions that wrap the command to run on the host of the lab. </span><span class="koboSpan" id="kobo.415.2">If an error occurs by running a command, the output is combined with the error message to be returned in the error message, as in this example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
fmt.Errorf("failed '%s', out: %s ,err: %v", cmd, out, err)</span></pre>
<p><span class="koboSpan" id="kobo.417.1">The idea to add the output to the error message is because when running remote commands via SSH and shell, the error might not be easy to interpret without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">stdout</span></strong><span class="koboSpan" id="kobo.419.1"> messages.</span></p>
<h3><span class="koboSpan" id="kobo.420.1">veth.go</span></h3>
<p><span class="koboSpan" id="kobo.421.1">This contains </span><a id="_idIndexMarker1173"/><span class="koboSpan" id="kobo.422.1">the functions that form the command strings that will be used to run on the host to create or manipulate </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">veth</span></strong><span class="koboSpan" id="kobo.424.1"> interfaces. </span><span class="koboSpan" id="kobo.424.2">It also contains all functions that are used to populate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">conf.Veths</span></strong><span class="koboSpan" id="kobo.426.1"> list, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">loadVeth()</span></strong><span class="koboSpan" id="kobo.428.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">createPeerVeths()</span></strong><span class="koboSpan" id="kobo.430.1">.</span></p>
<h3><span class="koboSpan" id="kobo.431.1">hostconnect.go</span></h3>
<p><span class="koboSpan" id="kobo.432.1">This file </span><a id="_idIndexMarker1174"/><span class="koboSpan" id="kobo.433.1">contains the function used to connect to our lab. </span><span class="koboSpan" id="kobo.433.2">In our case, we are using a third-party package called </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">melbahja/goph</span></strong><span class="koboSpan" id="kobo.435.1">, which is an SSH client that allows the execution of a command and immediate output. </span><span class="koboSpan" id="kobo.435.2">For faster and better performance, we should use vSSH instead, as explained in </span><a href="B18165_06.xhtml#_idTextAnchor166"><em class="italic"><span class="koboSpan" id="kobo.436.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.437.1">.</span></p>
<h3><span class="koboSpan" id="kobo.438.1">netlab.go</span></h3>
<p><span class="koboSpan" id="kobo.439.1">This is </span><a id="_idIndexMarker1175"/><span class="koboSpan" id="kobo.440.1">the main program file that contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">main()</span></strong><span class="koboSpan" id="kobo.442.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">init()</span></strong><span class="koboSpan" id="kobo.444.1"> functions. </span><span class="koboSpan" id="kobo.444.2">The library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">flags</span></strong><span class="koboSpan" id="kobo.446.1"> is used to pass arguments during the command execution in the shell. </span><span class="koboSpan" id="kobo.446.2">By default, they are initiated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">init()</span></strong><span class="koboSpan" id="kobo.448.1"> function, and they use default values if the arguments are not passed.</span></p>
<p><span class="koboSpan" id="kobo.449.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">main()</span></strong><span class="koboSpan" id="kobo.451.1"> function also describes the flow of the whole process, which consists of five main calls – </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">readTopologyFile</span></strong><span class="koboSpan" id="kobo.453.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">connectToHost</span></strong><span class="koboSpan" id="kobo.455.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">loadVeths</span></strong><span class="koboSpan" id="kobo.457.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">createVeths</span></strong><span class="koboSpan" id="kobo.459.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">addVethsToBackbone</span></strong><span class="koboSpan" id="kobo.461.1">.</span></p>
<p><span class="koboSpan" id="kobo.462.1">Now that we have all devices connected and we understand how the automation works, let’s do some manual checks to verify that the connections have been created properly.</span></p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.463.1">Checking the connections manually</span></h2>
<p><span class="koboSpan" id="kobo.464.1">To </span><a id="_idIndexMarker1176"/><span class="koboSpan" id="kobo.465.1">create automation for checking connections, we have to understand how the process of checking connections works first. </span><span class="koboSpan" id="kobo.465.2">Once we know how a manual check works, we can later automate it.</span></p>
<p><span class="koboSpan" id="kobo.466.1">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">netlab</span></strong><span class="koboSpan" id="kobo.468.1"> program has run without errors, it should have created the connections and the software bridge called </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">backbone</span></strong><span class="koboSpan" id="kobo.470.1">, and attached the WAN interfaces to it. </span><span class="koboSpan" id="kobo.470.2">Let’s use the following figure as guidance for our manual verification of the connections:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.471.1"><img alt="Figure 10.13 – Diagram showing where we manually check the connections" src="image/B18165_10_013.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.472.1">Figure 10.13 – Diagram showing where we manually check the connections</span></p>
<p><span class="koboSpan" id="kobo.473.1">The figure </span><a id="_idIndexMarker1177"/><span class="koboSpan" id="kobo.474.1">shows numbers to indicate where we are going to do the manual checks. </span><span class="koboSpan" id="kobo.474.2">Let’s first start checking the connection that is represented by </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">1</span></strong><span class="koboSpan" id="kobo.476.1">. </span><span class="koboSpan" id="kobo.476.2">We are going to use LLDP to validate the connection in all cases.</span></p>
<p><span class="koboSpan" id="kobo.477.1">The following screenshot shows the output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">sudo lldpctl cpe-acc</span></strong><span class="koboSpan" id="kobo.479.1"> command, which runs inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">cpe-a</span></strong><span class="koboSpan" id="kobo.481.1"> router via SSH. </span><span class="koboSpan" id="kobo.481.2">Note that in the example, we start from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">netlab</span></strong><span class="koboSpan" id="kobo.483.1"> host:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.484.1"><img alt="Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection to acc-a" src="image/B18165_10_014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.485.1">Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection to acc-a</span></p>
<p><span class="koboSpan" id="kobo.486.1">As you can </span><a id="_idIndexMarker1178"/><span class="koboSpan" id="kobo.487.1">see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">cpe-acc</span></strong><span class="koboSpan" id="kobo.489.1"> interface in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">cpe-a</span></strong><span class="koboSpan" id="kobo.491.1"> router is connected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">acc-cpe</span></strong><span class="koboSpan" id="kobo.493.1"> interface in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">acc-a</span></strong><span class="koboSpan" id="kobo.495.1"> router.</span></p>
<p><span class="koboSpan" id="kobo.496.1">To validate the connection for case </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">2</span></strong><span class="koboSpan" id="kobo.498.1"> in </span><em class="italic"><span class="koboSpan" id="kobo.499.1">Figure 10.14</span></em><span class="koboSpan" id="kobo.500.1">, we will run LLDP on </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">core-a1</span></strong><span class="koboSpan" id="kobo.502.1">:</span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.503.1"><img alt="Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection to the backbone" src="image/B18165_10_015.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.504.1">Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection to the backbone</span></p>
<p><span class="koboSpan" id="kobo.505.1">As you can </span><a id="_idIndexMarker1179"/><span class="koboSpan" id="kobo.506.1">see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">core-a1</span></strong><span class="koboSpan" id="kobo.508.1"> router’s interface, </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">core-a1-wan</span></strong><span class="koboSpan" id="kobo.510.1">, is connected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">netlab</span></strong><span class="koboSpan" id="kobo.512.1"> host via </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">wan-core-a1</span></strong><span class="koboSpan" id="kobo.514.1">. </span><span class="koboSpan" id="kobo.514.2">To verify whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">wan-core-a1</span></strong><span class="koboSpan" id="kobo.516.1"> interface belongs to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">backbone</span></strong><span class="koboSpan" id="kobo.518.1"> bridge, we need to perform one of the extra commands:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.519.1"><img alt="Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone bridge" src="image/B18165_10_016.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.520.1">Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone bridge</span></p>
<p><span class="koboSpan" id="kobo.521.1">Either of the commands shown in </span><em class="italic"><span class="koboSpan" id="kobo.522.1">Figure 10.16</span></em><span class="koboSpan" id="kobo.523.1"> confirms that </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">wan-core-a1</span></strong><span class="koboSpan" id="kobo.525.1"> belongs to </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">backbone</span></strong><span class="koboSpan" id="kobo.527.1">. </span><span class="koboSpan" id="kobo.527.2">The difference is the second command presents the output in a JSON format, which is easier to parse by software. </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">lldpctl</span></strong><span class="koboSpan" id="kobo.529.1"> also supports JSON output using </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">lldpctl -f json</span></strong><span class="koboSpan" id="kobo.531.1">.</span></p>
<p><span class="koboSpan" id="kobo.532.1">Now, let’s discuss how we can add more automation.</span></p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.533.1">Adding automation</span></h1>
<p><span class="koboSpan" id="kobo.534.1">There </span><a id="_idIndexMarker1180"/><span class="koboSpan" id="kobo.535.1">are infinite possibilities for processes for which you might want to create automation. </span><span class="koboSpan" id="kobo.535.2">Most of the operational procedures are repetitive and prone to errors if manually operated. </span><span class="koboSpan" id="kobo.535.3">So, we need to automate our network as much as possible.</span></p>
<p><span class="koboSpan" id="kobo.536.1">Let’s then describe a few simple forms of automation that can help our network operation.</span></p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.537.1">Link connection check automation</span></h2>
<p><span class="koboSpan" id="kobo.538.1">One of </span><a id="_idIndexMarker1181"/><span class="koboSpan" id="kobo.539.1">the procedures </span><a id="_idIndexMarker1182"/><span class="koboSpan" id="kobo.540.1">that is very important and requires lots of attention is the build and construction of the physical network, in particular a physical rack and its cables. </span><span class="koboSpan" id="kobo.540.2">Its complexity will vary, depending on whether a star topology configuration or a Clos topology configuration is used, which we discussed in </span><a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic"><span class="koboSpan" id="kobo.541.1">Chapter 1</span></em></a><span class="koboSpan" id="kobo.542.1">.</span></p>
<p><span class="koboSpan" id="kobo.543.1">A mixed topology configuration that combines all possible topologies is even more complex, and its complexity will increase the chances of building a network incorrectly. </span><span class="koboSpan" id="kobo.543.2">For instance, a Clos network, as shown in </span><em class="italic"><span class="koboSpan" id="kobo.544.1">Figure 10.17</span></em><span class="koboSpan" id="kobo.545.1">, has a total of 32 connections, and imagine the complexity added if three more routers were included.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.546.1"><img alt="Figure 10.17 – Clos network connections" src="image/B18165_10_017.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.547.1">Figure 10.17 – Clos network connections</span></p>
<p><span class="koboSpan" id="kobo.548.1">Having</span><a id="_idIndexMarker1183"/><span class="koboSpan" id="kobo.549.1"> included </span><strong class="bold"><span class="koboSpan" id="kobo.550.1">E5</span></strong><span class="koboSpan" id="kobo.551.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.552.1">S5</span></strong><span class="koboSpan" id="kobo.553.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.554.1">L5</span></strong><span class="koboSpan" id="kobo.555.1">, the Clos network will have now 50 connections. </span><span class="koboSpan" id="kobo.555.2">So, for us, connection check automation</span><a id="_idIndexMarker1184"/><span class="koboSpan" id="kobo.556.1"> is important to avoid operation failures down the network setup.</span></p>
<p><span class="koboSpan" id="kobo.557.1">Most importantly, our network lab can be used for us to test the automation of the link connection check, which can be used later in production.</span></p>
<p><span class="koboSpan" id="kobo.558.1">In a production environment, a bastion host normally needs to be accessed first, before accessing the devices using the OOB network. </span><span class="koboSpan" id="kobo.558.2">In our network lab, the bastion is the same as the network lab host. </span><span class="koboSpan" id="kobo.558.3">Once logged in to the bastion, the automation code can then access the router via the OOB network, which is the same as in the network lab.</span></p>
<p><span class="koboSpan" id="kobo.559.1">Let’s now write some code to automate this process</span></p>
<h3><span class="koboSpan" id="kobo.560.1">Link check example code</span></h3>
<p><span class="koboSpan" id="kobo.561.1">I have </span><a id="_idIndexMarker1185"/><span class="koboSpan" id="kobo.562.1">added a Python script that returns a JSON list format with all interfaces and the device connected to each interface for a particular device. </span><span class="koboSpan" id="kobo.562.2">The Python code can be accessed at </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">Chapter10/NetworkLab/AUTOMATION.md</span></strong><span class="koboSpan" id="kobo.564.1">.</span></p>
<p><span class="koboSpan" id="kobo.565.1">Let’s run a few examples to see how the Python script works; the following screenshot is showing results for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">internet</span></strong><span class="koboSpan" id="kobo.567.1"> device:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.568.1"><img alt="Figure 10.18 – Output for checking connections to the internet device" src="image/B18165_10_018.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.569.1">Figure 10.18 – Output for checking connections to the internet device</span></p>
<p><span class="koboSpan" id="kobo.570.1">As you </span><a id="_idIndexMarker1186"/><span class="koboSpan" id="kobo.571.1">can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">internet</span></strong><span class="koboSpan" id="kobo.573.1"> device has only two interfaces, one connected via the OOB network with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">eth0</span></strong><span class="koboSpan" id="kobo.575.1"> interface to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">netlab</span></strong><span class="koboSpan" id="kobo.577.1"> device, and one interface called </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">internet-border</span></strong><span class="koboSpan" id="kobo.579.1"> connected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">border</span></strong><span class="koboSpan" id="kobo.581.1"> device, which confirms the connections in </span><em class="italic"><span class="koboSpan" id="kobo.582.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.583.1">.</span></p>
<p><span class="koboSpan" id="kobo.584.1">Let’s now check how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">border</span></strong><span class="koboSpan" id="kobo.586.1"> device is connected.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.587.1"><img alt="Figure 10.19 – Output for checking connections of the border device" src="image/B18165_10_019.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.588.1">Figure 10.19 – Output for checking connections of the border device</span></p>
<p><span class="koboSpan" id="kobo.589.1">As you</span><a id="_idIndexMarker1187"/><span class="koboSpan" id="kobo.590.1"> can see in </span><em class="italic"><span class="koboSpan" id="kobo.591.1">Figure 10.19</span></em><span class="koboSpan" id="kobo.592.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">border</span></strong><span class="koboSpan" id="kobo.594.1"> device is connected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">internet</span></strong><span class="koboSpan" id="kobo.596.1"> device and three core routers, </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">core-i1</span></strong><span class="koboSpan" id="kobo.598.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">core-i2</span></strong><span class="koboSpan" id="kobo.600.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">core-i3</span></strong><span class="koboSpan" id="kobo.602.1">, as in </span><em class="italic"><span class="koboSpan" id="kobo.603.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.604.1">.</span></p>
<p><span class="koboSpan" id="kobo.605.1">If you run this for all devices, you should confirm all the connections. </span><span class="koboSpan" id="kobo.605.2">But can we automate confirming connections for all routers in just one run? </span><span class="koboSpan" id="kobo.605.3">Yes, of course, but for that, we will need to read </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">topology.yaml</span></strong><span class="koboSpan" id="kobo.607.1">, and then create a loop that will run on each device to confirm the connections. </span><span class="koboSpan" id="kobo.607.2">I will leave completing this as an exercise for you.</span></p>
<p><span class="koboSpan" id="kobo.608.1">Let’s now explain some parts of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">show-connections.py</span></strong><span class="koboSpan" id="kobo.610.1"> code.</span></p>
<h3><span class="koboSpan" id="kobo.611.1">Looking into the code</span></h3>
<p><span class="koboSpan" id="kobo.612.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">show-connections.py</span></strong><span class="koboSpan" id="kobo.614.1"> Python </span><a id="_idIndexMarker1188"/><span class="koboSpan" id="kobo.615.1">code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">paramiko</span></strong><span class="koboSpan" id="kobo.617.1"> third-party library as the base for the SSH connection, which we discussed in </span><a href="B18165_06.xhtml#_idTextAnchor166"><em class="italic"><span class="koboSpan" id="kobo.618.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.619.1">, (</span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">paramiko</span></strong><span class="koboSpan" id="kobo.621.1"> can be installed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">pip install paramiko</span></strong><span class="koboSpan" id="kobo.623.1">).</span></p>
<p><span class="koboSpan" id="kobo.624.1">Paramiko is a </span><a id="_idIndexMarker1189"/><span class="koboSpan" id="kobo.625.1">lower-level SSH connectivity library that allows us to create an SSH session within an SSH session because we are using a bastion to connect to our devices in the network lab, which</span><a id="_idIndexMarker1190"/><span class="koboSpan" id="kobo.626.1"> is the lab host. </span><span class="koboSpan" id="kobo.626.2">The details of this stacked SSH connection are described in the code by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">NetLab()</span></strong><span class="koboSpan" id="kobo.628.1"> class, which has a method to connect to the bastion called </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">connectBastion()</span></strong><span class="koboSpan" id="kobo.630.1">, and a method to connect to a device called </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">connectDevice()</span></strong><span class="koboSpan" id="kobo.632.1">. </span><span class="koboSpan" id="kobo.632.2">Note that these methods use a class attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">self.transport</span></strong><span class="koboSpan" id="kobo.634.1"> to pass the bastion </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">paramiko</span></strong><span class="koboSpan" id="kobo.636.1"> handler to the device channel described in the code and shown here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.637.1">
device_channel = </span><strong class="bold"><span class="koboSpan" id="kobo.638.1">self.transport</span></strong><span class="koboSpan" id="kobo.639.1">.open_channel(
    "direct-tcpip", target_socket, source_socket
)</span></pre>
<p><span class="koboSpan" id="kobo.640.1">There are other ways to use bastion, such as using SSH proxies or SSH agents. </span><span class="koboSpan" id="kobo.640.2">However, in our example, I wanted to show how to natively create an SSH stack connection. </span><span class="koboSpan" id="kobo.640.3">Because if you do have two bastions before connecting a device, it is also possible to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">paramiko</span></strong><span class="koboSpan" id="kobo.642.1">, but perhaps not that easy using SSH agents and proxies.</span></p>
<p><span class="koboSpan" id="kobo.643.1">In the Python code, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">argparser</span></strong><span class="koboSpan" id="kobo.645.1"> to add arguments to our command line, so you can change the address of the bastion or the username and password. </span><span class="koboSpan" id="kobo.645.2">The arguments and default values are located in </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">parse_arguments()</span></strong><span class="koboSpan" id="kobo.647.1">. </span><span class="koboSpan" id="kobo.647.2">A help guide is also automatically produced if you type </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">--help</span></strong><span class="koboSpan" id="kobo.649.1">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.650.1"><img alt="Figure 10.20 – help output for the Python code show-connections.py" src="image/B18165_10_020.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.651.1">Figure 10.20 – help output for the Python code show-connections.py</span></p>
<p><span class="koboSpan" id="kobo.652.1">I will leave</span><a id="_idIndexMarker1191"/><span class="koboSpan" id="kobo.653.1"> you to improve this Python script to read the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">topology.yaml</span></strong><span class="koboSpan" id="kobo.655.1"> file and then verify all the connections in the network lab depicted in </span><em class="italic"><span class="koboSpan" id="kobo.656.1">Figure 10.1</span></em><span class="koboSpan" id="kobo.657.1">.</span></p>
<p><span class="koboSpan" id="kobo.658.1">Now, let’s see how we can automate the IP configuration for the interfaces.</span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.659.1">IP configuration automation</span></h2>
<p><span class="koboSpan" id="kobo.660.1">Before</span><a id="_idIndexMarker1192"/><span class="koboSpan" id="kobo.661.1"> we can use our network</span><a id="_idIndexMarker1193"/><span class="koboSpan" id="kobo.662.1"> for IP traffic, we need to attribute IPs to our network interfaces, which can be done manually by adding IPs to each interface, or we can create an automated code that distributes the IPs and configure them on the devices in the network lab.</span></p>
<p><span class="koboSpan" id="kobo.663.1">For our network lab, there are basically two types of IP allocation, one that is point-to-point between devices, and one that is multi-point for the WAN on the backbone interfaces. </span><span class="koboSpan" id="kobo.663.2">Let’s give an example of automation for the WAN interfaces. </span><span class="koboSpan" id="kobo.663.3">The Python code called </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">configure-ip-wan.py</span></strong><span class="koboSpan" id="kobo.665.1"> is located at </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">Chapter10/NetworkLab/AUTOMATION.md</span></strong><span class="koboSpan" id="kobo.667.1">.</span></p>
<p><span class="koboSpan" id="kobo.668.1">The following screenshot shows the output after running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">configure-ip-wan.py</span></strong><span class="koboSpan" id="kobo.670.1"> program:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.671.1"><img alt="Figure 10.21 – Output of the configure-ip-wan.py Python code" src="image/B18165_10_021.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.672.1">Figure 10.21 – Output of the configure-ip-wan.py Python code</span></p>
<p><span class="koboSpan" id="kobo.673.1">Note</span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.674.1"> that</span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.675.1"> the IPs are configured on the devices using Paramiko, as in the previous example. </span><span class="koboSpan" id="kobo.675.2">The code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">ipaddress</span></strong><span class="koboSpan" id="kobo.677.1"> Python library, which allocates the IPs that will be used in the WAN interfaces by creating a list of IPs using the following commands:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.678.1">
network = ipaddress.ip_network(args.subnet)
valid_ips = list(network.hosts())</span></pre>
<p><span class="koboSpan" id="kobo.679.1">Then, each IP is obtained by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">pop()</span></strong><span class="koboSpan" id="kobo.681.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">valid_ips</span></strong><span class="koboSpan" id="kobo.683.1"> list, like in the following loop:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.684.1">
prefix = network.prefixlen
for device, interface in wan_interfaces.items():
    ip = valid_ips.pop(0)
    cmd = "sudo ip addr add {}/{} dev {}".format(ip, prefix, interface)
    run_device_command(args, device, cmd)</span></pre>
<p><span class="koboSpan" id="kobo.685.1">Now, we can test the IP connectivity between devices in the WAN using the Python script included at </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">Chapter10/NetworkLab/AUTOMATION.md</span></strong><span class="koboSpan" id="kobo.687.1">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.688.1"><img alt="Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via the WAN" src="image/B18165_10_022.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.689.1">Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via the WAN</span></p>
<p><span class="koboSpan" id="kobo.690.1">From</span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.691.1"> the </span><a id="_idIndexMarker1197"/><span class="koboSpan" id="kobo.692.1">output shown in </span><em class="italic"><span class="koboSpan" id="kobo.693.1">Figure 10.21</span></em><span class="koboSpan" id="kobo.694.1">, we can assume the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">core-b1</span></strong><span class="koboSpan" id="kobo.696.1"> interface IP is </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">10.200.200.4</span></strong><span class="koboSpan" id="kobo.698.1">. </span><span class="koboSpan" id="kobo.698.2">So, the test executed on </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">core-a1</span></strong><span class="koboSpan" id="kobo.700.1"> is testing the IP connectivity between </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">core-a1</span></strong><span class="koboSpan" id="kobo.702.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">core-b1</span></strong><span class="koboSpan" id="kobo.704.1"> via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">backbone</span></strong><span class="koboSpan" id="kobo.706.1"> bridge.</span></p>
<p><span class="koboSpan" id="kobo.707.1">To finish the IP configuration, you will have to also configure IPs for all other interfaces. </span><span class="koboSpan" id="kobo.707.2">I will leave adding the IPs to other network lab interfaces as an exercise, but for now, the example is sufficient to guide you to proceed.</span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.708.1">Additional network lab automation</span></h2>
<p><span class="koboSpan" id="kobo.709.1">Let’s </span><a id="_idIndexMarker1198"/><span class="koboSpan" id="kobo.710.1">discuss briefly what other possible automation we can add to our lab.</span></p>
<h3><span class="koboSpan" id="kobo.711.1">Adding and removing devices</span></h3>
<p><span class="koboSpan" id="kobo.712.1">We can </span><a id="_idIndexMarker1199"/><span class="koboSpan" id="kobo.713.1">add code that can read the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">topology.yaml</span></strong><span class="koboSpan" id="kobo.715.1"> file and then, based</span><a id="_idIndexMarker1200"/><span class="koboSpan" id="kobo.716.1"> on what is running, determine whether certain modifications are required, such as adding devices or removing devices. </span><span class="koboSpan" id="kobo.716.2">I will say that is easier for us to just tear down a network lab and start another one from scratch instead of removing and adding devices because, in our network emulation, the shutdown and startup are quick.</span></p>
<p><span class="koboSpan" id="kobo.717.1">So, adding code to remove and add devices is more of an exercise than a real utility in our network lab.</span></p>
<h3><span class="koboSpan" id="kobo.718.1">Using gRPC for automation</span></h3>
<p><span class="koboSpan" id="kobo.719.1">We also </span><a id="_idIndexMarker1201"/><span class="koboSpan" id="kobo.720.1">can do some automation using gRPC, as FRRouting supports this interface. </span><span class="koboSpan" id="kobo.720.2">With this, we eliminate the necessity to access the devices via SSH. </span><span class="koboSpan" id="kobo.720.3">You can find more on gRPC for FRRouting at </span><a href="https://docs.frrouting.org/en/latest/grpc.html"><span class="koboSpan" id="kobo.721.1">https://docs.frrouting.org/en/latest/grpc.html</span></a><span class="koboSpan" id="kobo.722.1">.</span></p>
<h3><span class="koboSpan" id="kobo.723.1">Using NETCONF for automation</span></h3>
<p><span class="koboSpan" id="kobo.724.1">To use </span><a id="_idIndexMarker1202"/><span class="koboSpan" id="kobo.725.1">NETCONF for automation, you need to have </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">libyang</span></strong><span class="koboSpan" id="kobo.727.1"> installed in the router image, which, in our network lab, is FRRouting running on Alpine Linux. </span><span class="koboSpan" id="kobo.727.2">To add </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">libyang</span></strong><span class="koboSpan" id="kobo.729.1">, just type the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">sudo apk add libyang</span></strong><span class="koboSpan" id="kobo.731.1"> command on the router device. </span><span class="koboSpan" id="kobo.731.2">Using FRRouting and NETCONF together is not a very well-documented option, so good luck doing so.</span></p>
<h3><span class="koboSpan" id="kobo.732.1">Adding network degradation</span></h3>
<p><span class="koboSpan" id="kobo.733.1">You</span><a id="_idIndexMarker1203"/><span class="koboSpan" id="kobo.734.1"> can add latency, jitter, packet loss, congestion, and other degradations to your network lab, which can be permanent or vary over time. </span><span class="koboSpan" id="kobo.734.2">To remove and add these degradations, the best thing to do is to write automated code that can apply the necessary traffic shaping mechanisms and then remove them. </span><span class="koboSpan" id="kobo.734.3">We discussed these degradation methods in </span><a href="B18165_09.xhtml#_idTextAnchor209"><em class="italic"><span class="koboSpan" id="kobo.735.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.736.1">.</span></p>
<p><span class="koboSpan" id="kobo.737.1">As an example, we can add some latency to the backbone interfaces in our network lab by using Linux </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">tc</span></strong><span class="koboSpan" id="kobo.739.1"> like so:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.740.1">
sudo tc qdisc add dev wan-core-a1 root netem delay 100ms</span></pre>
<p><span class="koboSpan" id="kobo.741.1">This command should run on the lab host, and it will add a 100 ms delay to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">wan-core-a1</span></strong><span class="koboSpan" id="kobo.743.1"> interface that connects </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">core-a1</span></strong><span class="koboSpan" id="kobo.745.1"> to the backbone.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.746.1">Figure 10.23</span></em><span class="koboSpan" id="kobo.747.1"> show the same test done in </span><em class="italic"><span class="koboSpan" id="kobo.748.1">Figure 10.22</span></em><span class="koboSpan" id="kobo.749.1"> but with WAN latency added.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.750.1"><img alt="Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to WAN" src="image/B18165_10_023.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.751.1">Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to WAN</span></p>
<p><span class="koboSpan" id="kobo.752.1">Feel </span><a id="_idIndexMarker1204"/><span class="koboSpan" id="kobo.753.1">free to add other network degradations to your network lab by automating how Linux traffic control can be used in the network lab interfaces.</span></p>
<h3><span class="koboSpan" id="kobo.754.1">Configure routing</span></h3>
<p><span class="koboSpan" id="kobo.755.1">At this </span><a id="_idIndexMarker1205"/><span class="koboSpan" id="kobo.756.1">stage, our network lab does not provide IP traffic capabilities because it does not know how to route IP packets. </span><span class="koboSpan" id="kobo.756.2">Two kinds of routing can be done using static routes by configuring the interfaces with them or adding dynamic protocol for the devices to talk and exchange routing tables.</span></p>
<p><span class="koboSpan" id="kobo.757.1">As all routers in our network lab are FRRouting; the protocols available that can be used are EIGRP, OSPF, ISIS, RIP, or BGP. </span><span class="koboSpan" id="kobo.757.2">A complete list and more details can be found at </span><a href="https://docs.frrouting.org/"><span class="koboSpan" id="kobo.758.1">https://docs.frrouting.org/</span></a><span class="koboSpan" id="kobo.759.1">.</span></p>
<p><span class="koboSpan" id="kobo.760.1">Many more kinds of automation are possible. </span><span class="koboSpan" id="kobo.760.2">Some will only work for the network lab, but some could be used in a production network. </span><span class="koboSpan" id="kobo.760.3">Hopefully, you can use the network lab to improve your network automation code skills, and then gain more confidence on building a solution for a production network.</span></p>
<p><span class="koboSpan" id="kobo.761.1">Let’s now discuss what to do next and further study.</span></p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.762.1">Going forward and further study</span></h1>
<p><span class="koboSpan" id="kobo.763.1">You are probably now thinking about what to do next and how you can progress to the next topic in network automation. </span><span class="koboSpan" id="kobo.763.2">I have put together a few suggestions here that I would recommend following, but keep in mind that there might be many other paths to follow. </span><span class="koboSpan" id="kobo.763.3">So, it is just a humble suggestion, and I hope you can enjoy the journey.</span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.764.1">Checking popular platforms and tools</span></h2>
<p><span class="koboSpan" id="kobo.765.1">There are</span><a id="_idIndexMarker1206"/><span class="koboSpan" id="kobo.766.1"> many automation platforms that you can use and perhaps investigate how they work. </span><span class="koboSpan" id="kobo.766.2">This list will be dynamic and may change from one year to another. </span><span class="koboSpan" id="kobo.766.3">So, keep in mind how to search for them and how to evaluate them.</span></p>
<p><span class="koboSpan" id="kobo.767.1">I have done superficial research on some of the platforms, but I would recommend going deeper if you want to improve your knowledge and get even sharper on how to automate a network. </span><span class="koboSpan" id="kobo.767.2">You may get some ideas, and perhaps improve what you are doing today.</span></p>
<p><span class="koboSpan" id="kobo.768.1">Here is a small list of the most popular automation </span><a id="_idIndexMarker1207"/><span class="koboSpan" id="kobo.769.1">platforms and tools that you might want to have a look at, not in any particular order:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.770.1">The</span><a id="_idIndexMarker1208"/><span class="koboSpan" id="kobo.771.1"> Salt project:</span><ul><li><span class="koboSpan" id="kobo.772.1">Short description: A remote execution manager</span></li><li><span class="koboSpan" id="kobo.773.1">Source: </span><a href="https://github.com/saltstack/salt "><span class="koboSpan" id="kobo.774.1">https://github.com/saltstack/salt</span></a></li><li><span class="koboSpan" id="kobo.775.1">Contributors: Over 2K</span></li><li><span class="koboSpan" id="kobo.776.1">Repository creation date: February 2011</span></li><li><span class="koboSpan" id="kobo.777.1">Top languages: Python 98%</span></li><li><span class="koboSpan" id="kobo.778.1">License: Apache 2.0</span></li><li><span class="koboSpan" id="kobo.779.1">Sponsor: VMware/public</span></li><li><span class="koboSpan" id="kobo.780.1">Popularity: 13K stars, 5.4K forks, 544 watching</span></li></ul></li>
<li><span class="koboSpan" id="kobo.781.1">The </span><a id="_idIndexMarker1209"/><span class="koboSpan" id="kobo.782.1">Ansible project:</span><ul><li><span class="koboSpan" id="kobo.783.1">Short description: A simple automation system for configuration management, deployment, and orchestration</span></li><li><span class="koboSpan" id="kobo.784.1">Source: </span><a href="https://github.com/ansible/ansible "><span class="koboSpan" id="kobo.785.1">https://github.com/ansible/ansible</span></a></li><li><span class="koboSpan" id="kobo.786.1">Contributors: Over 5K</span></li><li><span class="koboSpan" id="kobo.787.1">Repository </span><a id="_idIndexMarker1210"/><span class="koboSpan" id="kobo.788.1">creation date: March 2012</span></li><li><span class="koboSpan" id="kobo.789.1">Top languages: Python 88%, PowerShell 6.9%</span></li><li><span class="koboSpan" id="kobo.790.1">License: GPL 3.0</span></li><li><span class="koboSpan" id="kobo.791.1">Sponsor: Red Hat</span></li><li><span class="koboSpan" id="kobo.792.1">Popularity: 56K stars, 23K forks, 2K watching</span></li></ul></li>
<li><span class="koboSpan" id="kobo.793.1">The </span><a id="_idIndexMarker1211"/><span class="koboSpan" id="kobo.794.1">Puppet project:</span><ul><li><span class="koboSpan" id="kobo.795.1">Short </span><a id="_idIndexMarker1212"/><span class="koboSpan" id="kobo.796.1">description: A</span><a id="_idIndexMarker1213"/><span class="koboSpan" id="kobo.797.1"> general administrative management system designed to configure, update, and install systems</span></li><li><span class="koboSpan" id="kobo.798.1">Source: </span><a href="https://github.com/puppetlabs/puppet "><span class="koboSpan" id="kobo.799.1">https://github.com/puppetlabs/puppet</span></a></li><li><span class="koboSpan" id="kobo.800.1">Contributors: Over 1K</span></li><li><span class="koboSpan" id="kobo.801.1">Repository creation date: September 2010</span></li><li><span class="koboSpan" id="kobo.802.1">Top languages: Ruby 99%</span></li><li><span class="koboSpan" id="kobo.803.1">License: Apache 2.0</span></li><li><span class="koboSpan" id="kobo.804.1">Sponsor/Owner: Puppet by Perforce</span></li><li><span class="koboSpan" id="kobo.805.1">Popularity: 6.8K stars, 2.3K forks, 475 watching</span></li></ul></li>
<li><span class="koboSpan" id="kobo.806.1">The Chef project:</span><ul><li><span class="koboSpan" id="kobo.807.1">Short description: A </span><a id="_idIndexMarker1214"/><span class="koboSpan" id="kobo.808.1">configuration management tool designed to cover the automation of all IT infrastructure</span></li><li><span class="koboSpan" id="kobo.809.1">Source: </span><a href="https://github.com/chef/chef"><span class="koboSpan" id="kobo.810.1">https://github.com/chef/chef</span></a></li><li><span class="koboSpan" id="kobo.811.1">Contributors: Over 1K</span></li><li><span class="koboSpan" id="kobo.812.1">Repository creation date: January 2009</span></li><li><span class="koboSpan" id="kobo.813.1">Top languages: Ruby 98%</span></li><li><span class="koboSpan" id="kobo.814.1">License: Apache 2.0</span></li><li><span class="koboSpan" id="kobo.815.1">Sponsor/Owner: Progress </span><a id="_idIndexMarker1215"/><span class="koboSpan" id="kobo.816.1">Software Corporation</span></li><li><span class="koboSpan" id="kobo.817.1">Popularity: 7.1K stars, 2.6K forks, 374 watching</span></li></ul></li>
<li><span class="koboSpan" id="kobo.818.1">The </span><a id="_idIndexMarker1216"/><span class="koboSpan" id="kobo.819.1">Stackstorm project:</span><ul><li><span class="koboSpan" id="kobo.820.1">Short description: An</span><a id="_idIndexMarker1217"/><span class="koboSpan" id="kobo.821.1"> event-driven automation tool</span></li><li><span class="koboSpan" id="kobo.822.1">Source: </span><a href="https://github.com/StackStorm/st2 "><span class="koboSpan" id="kobo.823.1">https://github.com/StackStorm/st2</span></a></li><li><span class="koboSpan" id="kobo.824.1">Contributors: Over 300</span></li><li><span class="koboSpan" id="kobo.825.1">Repository creation date: April 2014</span></li><li><span class="koboSpan" id="kobo.826.1">Top languages: Python 94%</span></li><li><span class="koboSpan" id="kobo.827.1">License: Apache 2.0</span></li><li><span class="koboSpan" id="kobo.828.1">Sponsor/Owner: Linux Foundation</span></li><li><span class="koboSpan" id="kobo.829.1">Popularity: 5.4K stars, 696 forks, 168 watching</span></li></ul></li>
<li><span class="koboSpan" id="kobo.830.1">The eNMS</span><a id="_idIndexMarker1218"/><span class="koboSpan" id="kobo.831.1"> automation project:</span><ul><li><span class="koboSpan" id="kobo.832.1">Short description: A</span><a id="_idIndexMarker1219"/><span class="koboSpan" id="kobo.833.1"> higher-level management system to create workflow-based network automation solutions</span></li><li><span class="koboSpan" id="kobo.834.1">Source: </span><a href="https://github.com/eNMS-automation/eNMS "><span class="koboSpan" id="kobo.835.1">https://github.com/eNMS-automation/eNMS</span></a></li><li><span class="koboSpan" id="kobo.836.1">Contributors: 30</span></li><li><span class="koboSpan" id="kobo.837.1">Repository creation date: October 2017</span></li><li><span class="koboSpan" id="kobo.838.1">Top languages: Python 53%, JavaScript 26%, HTML 16%</span></li><li><span class="koboSpan" id="kobo.839.1">License: GLP 3.0</span></li><li><span class="koboSpan" id="kobo.840.1">Sponsor: N/A</span></li><li><span class="koboSpan" id="kobo.841.1">Popularity: 700 stars, 148 forks, 73 watching</span></li></ul></li>
<li><span class="koboSpan" id="kobo.842.1">NetBrain products:</span><ul><li><span class="koboSpan" id="kobo.843.1">Short description: NetBrain </span><a id="_idIndexMarker1220"/><span class="koboSpan" id="kobo.844.1">has developed several products for network </span><a id="_idIndexMarker1221"/><span class="koboSpan" id="kobo.845.1">automation, including </span><strong class="bold"><span class="koboSpan" id="kobo.846.1">Problem Diagnosis Automation System</span></strong><span class="koboSpan" id="kobo.847.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.848.1">PDAS</span></strong><span class="koboSpan" id="kobo.849.1">)</span></li><li><span class="koboSpan" id="kobo.850.1">Site: </span><a href="https://www.netbraintech.com/ "><span class="koboSpan" id="kobo.851.1">https://www.netbraintech.com/</span></a></li><li><span class="koboSpan" id="kobo.852.1">Owner: NetBrain Automation</span></li></ul></li>
<li><span class="koboSpan" id="kobo.853.1">SolarWinds Network Automation Manager:</span><ul><li><span class="koboSpan" id="kobo.854.1">Short description: Proprietary</span><a id="_idIndexMarker1222"/><span class="koboSpan" id="kobo.855.1"> product developed by SolarWinds for network automation</span></li><li><span class="koboSpan" id="kobo.856.1">Site: </span><a href="https://www.solarwinds.com/network-automation-manager "><span class="koboSpan" id="kobo.857.1">https://www.solarwinds.com/network-automation-manager</span></a></li><li><span class="koboSpan" id="kobo.858.1">Owner: SolarWinds</span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.859.1">Besides the </span><a id="_idIndexMarker1223"/><span class="koboSpan" id="kobo.860.1">tools and platforms that you can investigate, you </span><a id="_idIndexMarker1224"/><span class="koboSpan" id="kobo.861.1">also can participate in working groups related to network automation. </span><span class="koboSpan" id="kobo.861.2">Let’s have a look at some of them.</span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.862.1">Joining the network automation community</span></h2>
<p><span class="koboSpan" id="kobo.863.1">One of the </span><a id="_idIndexMarker1225"/><span class="koboSpan" id="kobo.864.1">strategies to improve your knowledge and get updated with new technologies is to participate in the community. </span><span class="koboSpan" id="kobo.864.2">The following is a small list of possible groups that you might be interested in watching or participating in:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.865.1">IETF netmgmt working group:</span><ul><li><span class="koboSpan" id="kobo.866.1">Short description: A </span><a id="_idIndexMarker1226"/><span class="koboSpan" id="kobo.867.1">group that has a focus on working on standards for automated network management, such as RESTCONF, NETCONF, and YANG</span></li><li><span class="koboSpan" id="kobo.868.1">Site: </span><a href="https://www.ietf.org/topics/netmgmt/ "><span class="koboSpan" id="kobo.869.1">https://www.ietf.org/topics/netmgmt/</span></a></li></ul></li>
<li><span class="koboSpan" id="kobo.870.1">Meetup groups:</span><ul><li><span class="koboSpan" id="kobo.871.1">Short description: One </span><a id="_idIndexMarker1227"/><span class="koboSpan" id="kobo.872.1">good idea is to join a local meetup group that has regular meetings. </span><span class="koboSpan" id="kobo.872.2">Then, you can talk with professionals in the same area and improve your network and knowledge. </span><a href="https://www.meetup.com/"><span class="koboSpan" id="kobo.873.1">https://www.meetup.com/</span></a><span class="koboSpan" id="kobo.874.1"> is a site where people can organize and meet.</span></li><li><span class="koboSpan" id="kobo.875.1">Example in New York: </span><a href="https://www.meetup.com/Network-to-Coders/"><span class="koboSpan" id="kobo.876.1">https://www.meetup.com/Network-to-Coders/</span></a><span class="koboSpan" id="kobo.877.1">.</span></li><li><span class="koboSpan" id="kobo.878.1">Example in Sydney: </span><a href="https://www.meetup.com/it-automation/"><span class="koboSpan" id="kobo.879.1">https://www.meetup.com/it-automation/</span></a><span class="koboSpan" id="kobo.880.1">.</span></li><li><span class="koboSpan" id="kobo.881.1">Example in San Francisco: </span><a href="https://www.meetup.com/sf-network-automation/"><span class="koboSpan" id="kobo.882.1">https://www.meetup.com/sf-network-automation/</span></a><span class="koboSpan" id="kobo.883.1">.</span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.884.1">North American Network Operators’ Group</span></strong><span class="koboSpan" id="kobo.885.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.886.1">NANOG</span></strong><span class="koboSpan" id="kobo.887.1">):</span><ul><li><span class="koboSpan" id="kobo.888.1">Short description: NANOG </span><a id="_idIndexMarker1228"/><span class="koboSpan" id="kobo.889.1">has tons of </span><a id="_idIndexMarker1229"/><span class="koboSpan" id="kobo.890.1">documents and presentations, and also organizes conferences where you can find multiple topics on network automation</span></li><li><span class="koboSpan" id="kobo.891.1">Site: </span><a href="https://www.nanog.org/ "><span class="koboSpan" id="kobo.892.1">https://www.nanog.org/</span></a></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.893.1">Global Network Advancement Group</span></strong><span class="koboSpan" id="kobo.894.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.895.1">GNA-G</span></strong><span class="koboSpan" id="kobo.896.1">):</span><ul><li><span class="koboSpan" id="kobo.897.1">Short description: GNA-G is a </span><a id="_idIndexMarker1230"/><span class="koboSpan" id="kobo.898.1">community of network professionals from several areas, including research, operation, and education all over the world. </span><span class="koboSpan" id="kobo.898.2">They organize meetings and have some documentation resources.</span></li><li><span class="koboSpan" id="kobo.899.1">Site: </span><a href="https://www.gna-g.net/"><span class="koboSpan" id="kobo.900.1">https://www.gna-g.net/</span></a><span class="koboSpan" id="kobo.901.1">.</span></li></ul></li>
<li><span class="koboSpan" id="kobo.902.1">The </span><a id="_idIndexMarker1231"/><span class="koboSpan" id="kobo.903.1">Network to Code company community:</span><ul><li><span class="koboSpan" id="kobo.904.1">Short description: Network to Code is a consulting company that maintains GitHub repositories and a </span><a href="https://slack.com"><span class="koboSpan" id="kobo.905.1">slack.com</span></a><span class="koboSpan" id="kobo.906.1"> group that discusses network automation, which</span><a id="_idIndexMarker1232"/><span class="koboSpan" id="kobo.907.1"> can be joined for free</span></li><li><span class="koboSpan" id="kobo.908.1">GitHub: </span><a href="https://github.com/networktocode/awesome-network-automation "><span class="koboSpan" id="kobo.909.1">https://github.com/networktocode/awesome-network-automation</span></a></li><li><span class="koboSpan" id="kobo.910.1">Slack group: </span><a href="https://networktocode.slack.com "><span class="koboSpan" id="kobo.911.1">networktocode.slack.com</span></a></li></ul></li>
<li><span class="koboSpan" id="kobo.912.1">IP Fabric company community:</span><ul><li><span class="koboSpan" id="kobo.913.1">Short description: The</span><a id="_idIndexMarker1233"/><span class="koboSpan" id="kobo.914.1"> IP Fabric company also maintains GitHub repositories and has a </span><a href="http://slack.com"><span class="koboSpan" id="kobo.915.1">slack.com</span></a><span class="koboSpan" id="kobo.916.1"> group open to anyone to join</span></li><li><span class="koboSpan" id="kobo.917.1">GitHub: </span><a href="https://github.com/community-fabric"><span class="koboSpan" id="kobo.918.1">https://github.com/community-fabric</span></a></li><li><span class="koboSpan" id="kobo.919.1">Slack group: </span><a href="http://ipfabric-community.slack.com"><span class="koboSpan" id="kobo.920.1">ipfabric-community.slack.com</span></a></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.921.1">Other </span><a id="_idIndexMarker1234"/><span class="koboSpan" id="kobo.922.1">communities also can be found attached to some private companies, such as IBM, Oracle, VMware, Google, and Amazon. </span><span class="koboSpan" id="kobo.922.2">They might even use public tools such as Slack, LinkedIn, or GitHub to communicate, and they are maybe more focused on products that these companies offer instead of generic discussion. </span><span class="koboSpan" id="kobo.922.3">They are worth checking out, because they might have something to add.</span></p>
<p><span class="koboSpan" id="kobo.923.1">Another idea to improve your knowledge and skills is to contribute to a platform that already exists as a developer, or to build your own if you dare.</span></p>
<p><span class="koboSpan" id="kobo.924.1">I hope this section can give you ideas on the path forward.</span></p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.925.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.926.1">This chapter was focused on getting your hands dirty in a network lab, checking how some code automation works in Go and Python, and, finally, exploring the possibilities of how to go forward with network automation.</span></p>
<p><span class="koboSpan" id="kobo.927.1">At this point, you should be very confident about how to build your own network lab, how to improve your network automation code, and what to do next to continue improving.</span></p>
<p><span class="koboSpan" id="kobo.928.1">On behalf of all the people who worked hard on this book, we want to thank you for investing the time to read this book. </span><span class="koboSpan" id="kobo.928.2">It was a hard accomplishment to gather so much information and pass it on to others in an easy and pleasurable way. </span><span class="koboSpan" id="kobo.928.3">I hope you have made the most of it by reading it and discovering new technologies and techniques in the realm of network automation.</span></p>
<p><span class="koboSpan" id="kobo.929.1">Now, you can embark on further challenges that will take you deeper into network automation, which you will find when building a complete solution and putting into practice everything that you have learned.</span></p>
</div>
</body></html>