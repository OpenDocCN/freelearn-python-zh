- en: '*Chapter 8*: Defining Templates for Algorithms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at what templates are and how to implement template
    programming in Python.
  prefs: []
  type: TYPE_NORMAL
- en: What are templates and where are they useful? The main usage of applying the
    concepts of metaprogramming during the process of developing an application is
    to design a reusable framework that can be manipulated externally through the
    programming of metadata of Python objects rather than modifying the object itself.
    Templates, as the name suggests, can act as a template, a format, or a model on
    how a sequence of operations can be performed on a Python object. These templates
    can be used to define the common functionalities of methods within a class and
    to reuse them through the application of the object-oriented programming concept
    of **inheritance**.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will look at understanding how templates can be
    defined and used in Python and how a sequence of common operations can be designed
    into a template that fits into a framework. Speaking of designs, template programming
    is one of the main concepts within the design patterns of Python. Design patterns
    will be covered in detail in [*Chapter 12*](B13426_12_Final_PG_epub.xhtml#_idTextAnchor154)
    on design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be taking a look at the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining a sequence of operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the sequence of methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the common functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to apply generics and type checking
    on Python variables. You should also be able to create your own domain-specific
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter08](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining a sequence of operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing algorithms is always interesting, especially in a language like Python
    where less code needs to be written to complete an action compared to any other
    programming language. An **algorithm** is a simple sequence of steps that need
    to be performed to accomplish a task. While developing any algorithm, the most
    important aspect is to ensure that we are following the steps to perform the action
    in the right sequence. This section covers examples of a sequence of operations
    and how they can be defined in a Python program.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our core example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will continue using our core example of *ABC Megamart*,
    and we will specifically look at the billing counter where we can perform a sequence
    of operations. The reason we are focusing on a sequence of operations here is
    to especially understand how **templates** can be utilized to perform a set of
    tasks, and also how they can be reused to perform similar kinds of other tasks
    too. So, let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'At *ABC Megamart*, we have four different checkout counters to check out the
    shopping items from the cart. The details of the counters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is to check out items that contain vegetables and dairy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is to check out items that contain less than 10 assorted items,
    excluding electronics, vegetables, and dairy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third one is to check out items that contain more than 10 assorted items,
    excluding electronics, vegetables, and dairy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth one is to check out electronic goods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these counters is performing a sequence of operations and at this point
    in time, they might look like they are an independent set of operations. The goal
    of this chapter is to create templates and look at a common way of connecting
    these independent operations. To connect them and create a template, we need to
    understand the sequence of operations in each of these counters.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at what each of the counters will work on.
  prefs: []
  type: TYPE_NORMAL
- en: The vegetables and dairy counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The journey of a customer to the billing counter starts from the vegetable section,
    where vegetables are added to the shopping cart, the customer then stands in a
    queue at the respective billing counter, vegetables and fruit are weighed and
    packed, a price tag with a bar code is added on the packet, the bar code is scanned
    and the bill is added to the invoice for each item, a tax component is added for
    each item, and the bill is totaled, printed, and handed over to the customer,
    who then pays the bill.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graphical representation of the steps is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Vegetables counter ](img/Figure_8.1_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Vegetables counter
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions will be defined to perform each of these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let’s further look at the next counter, which handles less than 10 items.
  prefs: []
  type: TYPE_NORMAL
- en: Less than 10 items counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a customer adds less than 10 items to the cart and the items do not contain
    vegetables, fruit, dairy, or electronics, then the customer goes to the less than
    10 items counter where the bar code on each item is scanned and the bill is added
    to the invoice for each item, a tax component is added for each item, and the
    bill is totaled, printed, and handed over to the customer, who then pays the bill.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graphical representation of the steps is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Less than 10 items counter ](img/Figure_8.2_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Less than 10 items counter
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions will be defined to perform each of these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let’s further look at the next counter, which handles more than 10 items.
  prefs: []
  type: TYPE_NORMAL
- en: The greater than 10 items counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a customer adds more than 10 items to the cart and the items do not contain
    vegetables, fruit, dairy, or electronics, then the customer goes to the greater
    than 10 items counter where the bar code on each item is scanned and the bill
    is added to the invoice for each item, coupons are applied, a tax component is
    added for each item, and the bill is totaled, printed, and handed over to the
    customer, who then pays the bill.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graphical representation of the steps is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Greater than 10 items counter ](img/Figure_8.3_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Greater than 10 items counter
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions will be defined to perform each of these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let’s further look at the next counter, which handles electronic items.
  prefs: []
  type: TYPE_NORMAL
- en: Electronics counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last counter is the electronics counter, where a customer goes to the counter,
    gets the electronic items tested, the item is scanned, and the bill is added to
    the invoice for each item. A tax component is added for each item and the bill
    is totaled, printed, and handed over to the customer, who then pays the bill.
  prefs: []
  type: TYPE_NORMAL
- en: 'The graphical representation of the steps is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Electronics counter ](img/Figure_8.4_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Electronics counter
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions will be defined to perform each of these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In each of the preceding billing counters, we looked at the sequence of operations
    that happens for a sale to complete.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s look at defining each of the operations into
    methods in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the sequence of methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining the methods helps us in understanding each of the operations performed
    at each counter in detail. Let’s define the classes and methods required to fulfill
    the actions to be performed in each operation. We will be covering the following
    counters in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: The vegetable counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than 10 items counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than 10 items counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The electronics counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin with the vegetable counter.
  prefs: []
  type: TYPE_NORMAL
- en: The vegetable counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps for the operation of this counter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create the `VegCounter` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, we will be defining the `return_cart` method that returns
    the list of items added to the shopping cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now return the name of the counter to be included in the bill. For this
    example, the counter name is `Vegetables & Dairy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s define the method to weigh the items in the cart
    and return a dictionary of items and their corresponding weights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s define a method to take the unit price and weights as input and
    calculate the price of each item by multiplying the weights and unit price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following method, let’s input bar codes to each of the items in the
    cart and return the bar codes as a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s add a method to add price tags to the bar codes by creating a dictionary
    object and adding the codes and their corresponding price tags as key-value pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s add tax percentages for each of the items and return the tax values
    as a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further use the price tags and the tax values and calculate the bill
    for each of the items in the cart, and create a dictionary to add the items and
    their corresponding billing amount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following method, let’s print the invoice with the counter name, items
    in the cart, price, and the total bill amount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s print the invoice with a statement stating that the invoice is
    paid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the preceding code results in the following. The methods are called
    in a sequence so that the results from one method are provided as input to the
    next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the printed invoice looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s print the invoice that has been paid by the customer, `veg.receive_payment(finalbill)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output of the paid invoice looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Less than 10 items counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the class defined for the vegetable counter, we can also define the
    methods for the remaining three counters. The detailed code for the remaining
    counters is available at [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter08](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code for this counter, let’s create the `LessThan10Counter` class and
    add all of its methods, which includes `return_cart`, `goto_less_t10_counter`,
    `review_items`, `count_items`, `scan_bar_code`, `add_billing`, `add_tax`, `calc_bill`,
    `print_invoice`, and `receive_payment`. For simplicity, let’s look at the additional
    methods that we have in each counter instead of repeating all of the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the `LessThan10Counter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this class, we have a `goto_less_t10_counter` method, which returns the
    name of the counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also have the following method to review the items in the cart to make sure
    that they are not electronic, vegetable, fruit, or dairy products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following method, let’s count the items to make sure that the total
    number of items in the cart is less than `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing all of the methods for this class in a sequence results in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the paid invoice looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Greater than 10 items counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let’s define the class and methods for the counter for greater
    than 10 items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code here, let’s create the `GreaterThan10Counter` class and add all
    of its methods, which includes `return_cart`, `goto_greater_t10_counter`, `review_items`,
    `count_items`, `scan_bar_code`, `add_billing`, `add_tax`, `apply_coupon`, `calc_bill`,
    `print_invoice`, and `receive_payment`. For simplicity, let’s look at the additional
    methods that we have in each counter instead of repeating all of the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create the `GreaterThan10Counter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this class, we have a `goto_greater_t10_counter` method counter that returns
    the name of the counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s add a method to apply a discount coupon to the items purchased:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing all of the methods for this class in a sequence results in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the paid invoice looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we had a different method definition for `goto_greater_t10_counter`
    and a new `apply_coupon` method.
  prefs: []
  type: TYPE_NORMAL
- en: The electronics counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, let’s define the class and methods for the electronic items
    counter. In the following code, let’s create the `ElectronicsCounter` class and
    add all of its methods, which includes `return_cart`, `goto_electronics_counter`,
    `review_items`, `test_electronics`, `scan_bar_code`, `add_billing`, `add_tax`,
    `apply_coupon`, `calc_bill`, `print_invoice`, and `receive_payment`. For simplicity,
    let’s look at the additional methods that we have in each counter instead of repeating
    all of the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create the class for the electronics counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this class, we have a method to go to the electronics counter that returns
    the name of the counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s define a method that provides the status of the electronic goods
    and checks whether they are working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing all of the methods for this class in a sequence results in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the paid invoice looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we had different method definitions for `goto_electronics_counter`
    and a new `test_electronics` method.
  prefs: []
  type: TYPE_NORMAL
- en: Having defined the sequences, let’s proceed further to look at the common functionalities
    of each of these counters.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the common functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let’s look at a graphical representation that shows the list
    of functions to be performed at each counter and the common functionalities between
    all four of them as follows. The common functionalities are highlighted in bold
    font in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Common operations performed across each counter ](img/Figure_8.5_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Common operations performed across each counter
  prefs: []
  type: TYPE_NORMAL
- en: From *Figure 8.5*, all the functions highlighted in the bold font are common
    across all four counters. The `review_items` function is common across the less
    than 10 items counter, greater than 10 items counter, and electronics counter.
    The `count_items` function is common across the less than 10 items counter and
    greater than 10 items counter. The `apply_coupon` function is common across the
    greater than 10 items counter and the electronics counter. Since there are common
    functions or operations performed across all of the counters, we can look at creating
    a common way of designing them, too. This is where we can introduce the concept
    of templates.
  prefs: []
  type: TYPE_NORMAL
- en: Designing templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, **templates** define a common template or format in which
    we can design an algorithmic flow of operations and reuse them when similar kinds
    of activities are performed. A template is one of the methods of design patterns
    in Python and can be used effectively while developing frameworks or libraries.
    Templates emphasize the concept of reusability in programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at creating a class that handles all the common
    functions of all four counters discussed throughout this chapter, and create a
    method that handles the template that sequences or pipelines the steps to be executed
    in all the counters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let’s create an abstract class named `CommonCounter`, and initialize
    the class with all the variables that will be used across all four counters. Refer
    to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will be defining the `return_cart`, `goto_counter`, and `scan_bar_code`
    methods to take the input variables that are initialized in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will be defining the `add_billing`, `add_tax`, and `calc_bill` methods
    to take the input variables that are initialized in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For simplicity, we will not be defining the print invoice method, and instead,
    will define the `receive_payment` method, which contains the definition of the
    print invoice method as well within the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will be defining the `apply_coupon` method, which returns a `0` value.
    This method can be redefined in the child classes if required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code snippets, we defined all the methods that are common
    across all four counters, whereas in the following code, we will be defining methods
    without statements so that they can be redefined within the child classes as and
    when required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s create review items as an abstract method that needs to have a
    definition within the child classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the most important concept of templates is defined in the next code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a method that handles the sequence of operations of a billing
    counter, and let’s use this method as a template for all the child classes that
    will be created for each billing counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have defined the common class for all counters along with its template method,
    which can be reused for each individual billing counter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following code, we will create a child class for `VegeCounter`, with
    `CommonCounter` as a parent class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we have defined the `review_items` abstract method and
    we have also added statements in the definition of the `weight_items` and `add_price_tag`
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, in the following code, let’s create a child class for `ElectronicsCounter`
    and define `review_items` (which is an abstract method), followed by redefining
    `test_electronics` (which did not have a definition in the `CommonCounter` base
    class):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now create a function to run the `pipeline_template` method for each
    of its child classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the `run_pipeline` method for each of the child classes results in
    the sequence of steps executed according to each billing counter. Let’s execute
    the `pipeline` method for the vegetable counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output after running the pipeline for `VegeCounter` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now execute the `pipeline` method for `ElectronicsCounter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output after running the pipeline for `ElectronicsCounter` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have created a template, but we have not repeated the same
    methods in multiple class definitions. The same `CommonCounter` abstract class
    can be reused for the definitions of the less than 10 items counter and the greater
    than 10 items counter as well. We learned how to create a template and implement
    template programming that emphasizes reusability in Python application development.
    We created a template that covers all the common functionalities across multiple
    sets of operations and reused the template multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the concepts of defining methods for a sequence
    of operations that follows an algorithm. We also defined classes that follow a
    sequence of operations from our core example. We created an abstract class that
    defines all the common functionalities of our core example, and we applied the
    templates design pattern to understand the concept of templates using the sequences
    from our core example.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other chapters covered in this book, this chapter also covered templates,
    which is a design pattern applied in metaprogramming to change the behavior of
    Python objects externally.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at the concept of abstract syntax trees
    with some interesting examples.
  prefs: []
  type: TYPE_NORMAL
