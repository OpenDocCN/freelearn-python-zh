["```py\n$ python3\nPython 3.9.0\n[GCC 7.4.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> 'Hello world!'\n'Hello world!' \n```", "```py\n$ export PYTHONSTARTUP=~/.config/python/init.py \n```", "```py\nfrom pprint import pprint as pp\nfrom pprint import pformat as pf \n```", "```py\n>>> pp(dict(spam=0xA, eggs=0xB))\n{'eggs': 11, 'spam': 10}\n>>> pf(dict(spam=0xA, eggs=0xB))\n\"{'eggs': 11, 'spam': 10}\" \n```", "```py\n# Modifying prompt\n>>> if True:\n...     print('Hello!')\nHello! \n```", "```py\n>>> import sys\n\n>>> sys.ps1 = '> '\n>>> sys.ps2 = '. '\n\n# With modified prompt\n> if True:\n.     print('Hello!')\nHello! \n```", "```py\n$ pip3 install pyreadline \n```", "```py\n>>> sandwich = dict(spam=2, eggs=1, sausage=1)\n>>> sandwich.<TAB>\nsandwich.clear(       sandwich.fromkeys(    sandwich.items(       sandwich.pop(\nsandwich.setdefault(  sandwich.values(      sandwich.copy(        sandwich.get(\nsandwich.keys(        sandwich.popitem(     sandwich.update(\n>>> sandwich[<TAB> \n```", "```py\nimport __main__\nimport re\nimport atexit\nimport readline\nimport rlcompleter\n\nclass Completer(rlcompleter.Completer):\n    ITEM_RE = re.compile(r'(?P<expression>.+?)\\[(?P<key>[^\\[]*)')\n\n    def complete(self, text, state):\n        # Init namespace. From 'rlcompleter.Completer.complete'\n        if self.use_main_ns:\n            self.namespace = __main__.__dict__\n\n        # If we find a [, try and return the keys\n        if '[' in text:\n            # At state 0 we need to prefetch the matches, after\n            # that we use the cached results\n            if state == 0:\n                self.matches = list(self.item_matches(text))\n\n            # Try and return the match if it exists\n            try:\n                return self.matches[state]\n            except IndexError:\n                pass\n        else:\n            # Fallback to the normal completion\n            return super().complete(text, state)\n\n    def item_matches(self, text):\n        # Look for the pattern expression[key\n        match = self.ITEM_RE.match(text)\n        if match:\n            search_key = match.group('key').lstrip()\n            expression = match.group('expression')\n\n            # Strip quotes from the key\n            if search_key and search_key[0] in {\"'\", '\"'}:\n                search_key = search_key.strip(search_key[0])\n\n            # Fetch the object from the namespace\n            object_ = eval(expression, self.namespace)\n\n            # Duck typing, check if we have a 'keys()' attribute\n            if hasattr(object_, 'keys'):\n                # Fetch the keys by executing the 'keys()' method\n                # Can you guess where the bug is?\n                keys = object_.keys()\n                for i, key in enumerate(keys):\n                    # Limit to 25 items for safety, could be infinite\n                    if i >= 25:\n                        break\n\n                    # Only return matching results\n                    if key.startswith(search_key):\n                        yield f'{expression}[{key!r}]'\n\n# By default readline doesn't call the autocompleter for [ because\n# it's considered a delimiter. With a little bit of work we can\n# fix this however :)\ndelims = readline.get_completer_delims()\n# Remove [, ' and \" from the delimiters\ndelims = delims.replace('[', '').replace('\"', '').replace(\"'\", '')\n# Set the delimiters\nreadline.set_completer_delims(delims)\n\n# Create and set the completer\ncompleter = Completer()\nreadline.set_completer(completer.complete)\n# Add a cleanup call on Python exit\natexit.register(lambda: readline.set_completer(None))\nprint('Done initializing the tab completer') \n```", "```py\nDone initializing the tab completer\n>>> sandwich = dict(spam=2, eggs=1, sausage=1)\n>>> sandwich['<TAB>\nsandwich['eggs']     sandwich['sausage']  sandwich['spam'] \n```", "```py\n$ pip3 install bpython \n```", "```py\n$ bpython\nbpython version 0.21 on top of Python 3.9.6\n>>> sandwich = dict(spam=2, eggs=1, sausage=1)\n┌────────────────────────────────────────────────────────────────┐\n│ dict: (self, *args, **kwargs)                                  │\n│ Initialize self.  See help(type(self)) for accurate signature. │\n└────────────────────────────────────────────────────────────────┘\n>>> sandwich.\n┌────────────────────────────────────────────────────────────────┐\n│ clear               copy                fromkeys               │\n│ get                 items               keys                   │\n│ pop                 popitem             setdefault             │\n│ update              values                                     │\n└────────────────────────────────────────────────────────────────┘\n>>> sandwich[\n┌────────────────────────────────────────────────────────────────┐\n│ 'eggs'     'sausage'  'spam'                                   │\n└────────────────────────────────────────────────────────────────┘ \n```", "```py\n>>> with open('bpython.txt', 'a') as fh:\n...     fh.write('x')\n...\n1\n\n>>> with open('bpython.txt') as fh:\n...     print(fh.read())\n...\nx\n\n>>> sandwich = dict(spam=2, eggs=1, sausage=1) \n```", "```py\n>>> with open('bpython.txt', 'a') as fh:\n...     fh.write('x')\n...\n1\n\n>>> with open('bpython.txt') as fh:\n...     print(fh.read())\n...\nxx\n\n>>> \n```", "```py\nwith open('reload.txt', 'a+') as fh:\n    fh.write('x')\n    fh.seek(0)\n    print(fh.read()) \n```", "```py\n>>> import bpython_reload\nx \n```", "```py\n>>> import bpython_reload\nxx\nReloaded at ... by user. \n```", "```py\n$ pip3 install ptpython \n```", "```py\n$ ptpython\n>>> \n```", "```py\n$ pip3 install ipython \n```", "```py\n$ conda install ipython \n```", "```py\n$ ipython\nPython 3.9.6 (default, Jun 29 2021, 05:25:02)\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.25.0 -- An enhanced Interactive Python. Type '?' for help.\nIn [1]: sandwich = dict(spam=2, eggs=1, sausage=1)\n\nIn [2]: sandwich\nOut[2]: {'spam': 2, 'eggs': 1, 'sausage': 1}\n\nIn [3]: sandwich = dict(spam=2, eggs=1, sausage=1, bacon=1, chees\n   ...: e=2, lettuce=1, tomatoes=3, pickles=1)\n\nIn [4]: sandwich\nOut[4]:\n{'spam': 2,\n 'eggs': 1,\n 'sausage': 1,\n 'bacon': 1,\n 'cheese': 2,\n 'lettuce': 1,\n 'tomatoes': 3,\n 'pickles': 1}\n\nIn [5]: _i1\nOut[5]: 'sandwich = dict(spam=2, eggs=1, sausage=1)'\n\nIn [6]: !echo \"$_i2\"\nsandwich \n```", "```py\nIn [1]: %load ~1/\n\nIn [2]: # %load ~1/\n   ...: sandwich = dict(spam=2, eggs=1, sausage=1)\n\nIn [3]: sandwich\nOut[3]: {'spam': 2, 'eggs': 1, 'sausage': 1} \n```", "```py\nIn [1]: %logstart\nActivating auto-logging. Current session state plus future input saved.\nFilename       : ipython_log.py\nMode           : rotate\nOutput logging : False\nRaw input log  : False\nTimestamping   : False\nState          : active \n```", "```py\nIn [1]: %load ipython_log.py\n\nIn [2]: # %load ipython_log.py\n   ...: # IPython log file\n   ...:\n   ...: get_ipython().run_line_magic('logstart', '')\n   ...:\nActivating auto-logging. Current session state plus future input saved.\nFilename       : ipython_log.py\nMode           : rotate\nOutput logging : False\nRaw input log  : False\nTimestamping   : False\nState          : active \n```", "```py\nIn [1]: %save session_filename ~0/\nThe following commands were written to file 'session_filename.py':\nget_ipython().run_line_magic('save', 'session_filename ~0/')\n\nIn [2]: %save -r raw_session ~0/\nThe following commands were written to file 'raw_session.ipy':\n%save session_filename ~0/\n%save -r raw_session ~0/ \n```", "```py\nIn [1]: sandwich = dict(spam=2, eggs=1, sausage=1, bacon=1, chees\n   ...: e=2, lettuce=1, tomatoes=3, pickles=1)\n\nIn [2]: sandwich\nOut[2]:\n{'spam': 2,\n 'eggs': 1,\n 'sausage': 1,\n 'bacon': 1,\n 'cheese': 2,\n 'lettuce': 1,\n 'tomatoes': 3,\n 'pickles': 1}\n\nIn [3]: %doctest_mode\nException reporting mode: Plain\nDoctest mode is: ON\n>>> sandwich\n{'spam': 2, 'eggs': 1, 'sausage': 1, 'bacon': 1, 'cheese': 2, 'lettuce': 1, 'tomatoes': 3, 'pickles': 1} \n```", "```py\nIn [1]: import pathlib\n\nIn [2]: pathlib.Path.name?\nType:        property\nString form: <property object at 0x10c540ef0>\nDocstring:   The final path component, if any.\n\nIn [3]: pathlib.Path.name??\nType:        property\nString form: <property object at 0x10c540ef0>\nSource:\n# pathlib.Path.name.fget\n@property\ndef name(self):\n    \"\"\"The final path component, if any.\"\"\"\n    parts = self._parts\n    if len(parts) == (1 if (self._drv or self._root) else 0):\n        return ''\n    return parts[-1] \n```", "```py\nIn [1]: class CompletionExample:\n   ...:     def __dir__(self):\n   ...:         return ['attribute', 'autocompletion']\n   ...:\n   ...:     def _ipython_key_completions_(self):\n   ...:         return ['key', 'autocompletion']\n   ...:\n\nIn [2]: completion = CompletionExample()\n\nIn [3]: completion.a<TAB>\n                     attribute\n                     autocompletion\n\nIn [4]: completion['aut<TAB>\n                        %autoawait     %autoindent\n                        %autocall      %automagic\n                        autocompletion \n```", "```py\nIn [1]: '\\pi<TAB>'\n\nIn [1]: 'π \n```", "```py\n$ pip3 install --upgrade jupyterlab \n```", "```py\n$ jupyter lab \n```", "```py\n$ docker run -p 8888:8888 jupyter/tensorflow-notebook \n```", "```py\nhttp://127.0.0.1:8888/?token=.......... \n```"]