- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions and Context Managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best-laid schemes o’ mice an’ men Gang aft agley.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Robert Burns
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This famous line by Robert Burns should be etched into the mind of every programmer.
    Even if our code is correct, errors will happen. If we do not deal with them properly,
    they can cause our best-laid schemes to go awry.
  prefs: []
  type: TYPE_NORMAL
- en: Unhandled errors can cause software to crash or misbehave. Depending on the
    nature of the software in question, this could have serious consequences. Therefore,
    it is important to learn how to detect and handle errors. We encourage you to
    cultivate the habit of always thinking about what errors can occur and how your
    code should respond when they do.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is all about errors and dealing with the unexpected. We will be
    learning about **exceptions** , which are Python’s way of signaling that an error
    or other exceptional event has occurred. We will also talk about **context managers**
    , which provide a mechanism to encapsulate and reuse error-handling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we have not covered the topic yet, we expect that by now you have
    at least a vague idea of what an exception is. In the previous chapters, we saw
    that when an iterator is exhausted, calling `next()` on it raises a `StopIteration`
    exception. We got an `IndexError` when we tried accessing a list at a position
    that was outside the valid range. We also encountered `AttributeError` when we
    tried accessing an attribute that did not exist on an object, and `KeyError` when
    we tried to access a nonexistent key in a dictionary. In this chapter, we will
    discuss exceptions in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Even when an operation or a piece of code is correct, there are often conditions
    in which something may go wrong. For example, if we are converting user input
    from `str` to `int` , the user could have accidentally typed a letter in place
    of a digit, making it impossible for us to convert that value into a number. When
    dividing numbers, we may not know in advance whether we might attempt a division
    by 0. When opening a file, it could be missing or corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an error is detected during execution, it is called an **exception** .
    Exceptions are not necessarily lethal; in fact, the `StopIteration` exception
    is deeply integrated into the Python generator and iterator mechanisms. Normally,
    however, if you do not take the necessary precautions, an exception will cause
    your application to break. Sometimes, this is the desired behavior, but in other
    cases, we want to prevent and control problems such as these. For example, if
    a user tries to open a corrupted file, we can alert them to the problem and give
    them an opportunity to fix it. Let us see an example of a few exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the Python shell is quite forgiving. We can see `Traceback`
    so that we have information about the error, but the shell itself still runs normally.
    This is a special behavior; a regular program or a script would normally exit
    immediately if nothing were done to handle exceptions. Let us see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because we did nothing to handle the exception, Python immediately exits once
    an exception occurs (after printing out information about the error).
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exceptions we have seen so far were raised by the Python interpreter when
    it detected an error. However, you can also raise exceptions yourself, when a
    situation occurs that your own code considers to be an error. To raise an exception,
    use the `raise` statement. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are no restrictions on which exception types you can raise. This allows
    you to choose the exception type that best describes the error condition that
    has occurred. You can also define your own exception types (we will see how to
    do that in a moment). Notice that the argument we passed to the `Exception` class
    is printed out as part of the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Python has too many built-in exceptions to list here, but they are all documented
    at [https://docs.python.org/3.12/library/exceptions.html#bltin-exceptions](https://docs.python.org/3.12/library/exceptions.html#bltin-exceptions)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Defining your own exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, you can define your own custom exceptions.
    In fact, it is pretty common for libraries, for example, to define their own exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do is define a class that inherits from any other exception
    class. All exceptions derive from `BaseException` ; however, this class is not
    intended to be directly subclassed. Your custom exceptions should inherit from
    `Exception` instead. In fact, nearly all built-in exceptions also inherit from
    `Exception` . Exceptions that do not inherit from `Exception` are meant for internal
    use by the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Tracebacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **traceback** that Python prints when an unhandled exception occurs may
    initially look intimidating, but it is quite useful for understanding what happened
    to cause the exception. For this example, we are using a mathematical formula
    to solve quadratic equations; it is not important if you are not familiar with
    it, as you do not need to understand it. Let us look at a traceback and see what
    it can tell us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we defined a function called `quadratic()` , which uses the famous quadratic
    formula to find the solution of a quadratic equation. Instead of using the `sqrt()`
    function from the `math` module, we wrote our own version ( `squareroot()` ),
    which raises an exception if the number is negative. When we call `quadratic(1,
    0, 1)` to solve the equation *x* ² *+1=0* , we will get a `ValueError` because
    `d` is negative. When we run this, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is often useful to read tracebacks from bottom to top. On the very last
    line, we have the error message, telling us what went wrong: `ValueError: No negative
    numbers please` . The preceding lines tell us where the exception was raised (line
    4 of `exceptions/trace.back.py` in the `squareroot()` function).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see the sequence of function calls that got us to the point where
    the exception was raised: `squareroot()` was called on line 11 by the function
    `quadratic()` , which was called on line 16, at the top level of the module. As
    you can see, the traceback is like a map that shows us the path through the code
    to where the exception happened. Following that path and examining the code in
    each function along the way is often helpful when you want to understand why an
    exception happened.'
  prefs: []
  type: TYPE_NORMAL
- en: There have been several improvements to error messages in Python 3.10, 3.11,
    and 3.12. For example, the `^^^^` characters underlining the exact part of each
    statement or expression in the traceback that led to the exception were added
    in Python 3.11.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To handle an exception in Python, you use the `try` statement. When you enter
    the `try` clause, Python will watch out for one or more different types of exceptions
    (according to how you instruct it), and if they are raised, it allows you to react.
  prefs: []
  type: TYPE_NORMAL
- en: The `try` statement is composed of the `try` clause, which opens the statement,
    followed by one or more `except` clauses that define what to do when an exception
    is caught. The `except` clauses may optionally be followed by an `else` clause,
    which is executed when the `try` clause is exited without any exception raised.
    After the `except` and `else` clauses, we can have a `finally` clause (also optional),
    whose code is executed regardless of whatever happened in the other clauses. The
    `finally` clause is typically used to clean up resources. You are also allowed
    to omit the `except` and `else` clauses and only have a `try` clause followed
    by a `finally` clause. This is helpful if we want exceptions to be propagated
    and handled elsewhere, but we do have some cleanup code that must be executed
    regardless of whether an exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of the clauses is important. It must be `try` , `except` , `else`
    , then `finally` . Also, remember that `try` must be followed by at least one
    `except` clause or a `finally` clause. Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example defines a simple `try_syntax()` function. We perform the division
    of two numbers. We are prepared to catch a `ZeroDivisionError` exception, which
    will occur if we call the function with `denominator = 0` . Initially, the code
    enters the `try` block. If `denominator` is not `0` , `result` is calculated and,
    after leaving the `try` block, execution resumes in the `else` block. We print
    `result` and return it. Take a look at the output, and you’ll notice that just
    before returning `result` , which is the exit point of the function, Python executes
    the `finally` clause.
  prefs: []
  type: TYPE_NORMAL
- en: When `denominator` is `0` , things change. Our attempt to calculate `numerator
    / denominator` raises a `ZeroDivisionError` . As a result, we enter the `except`
    block and print `zde` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `else` block is not executed because an exception was raised in the `try`
    block. Before (implicitly) returning `None` , we still execute the `finally` block.
    Look at the output and see whether it makes sense to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute a `try` block, you may want to catch more than one exception.
    For example, when calling the `divmod()` function, you can get a `ZeroDivisionError`
    if the second argument is `0` , or `TypeError` if either argument is not a number.
    If you want to handle both in the same way, you can structure your code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code will catch both `ZeroDivisionError` and `TypeError` . Try changing
    `values = (1, 2)` to `values = (1, 0)` or `values = ('one', 2)` , and you will
    see the output change.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to handle different exception types differently, you can use multiple
    `except` clauses, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that an exception is handled in the first block that matches that
    exception class or any of its base classes. Therefore, when you stack multiple
    `except` clauses like we have done here, make sure that you put specific exceptions
    at the top and generic ones at the bottom. In OOP terms, derived classes should
    be placed before their base classes. Moreover, remember that only one `except`
    handler is executed when an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Python also allows you to use an `except` clause without specifying any exception
    type (this is equivalent to writing `except BaseException` ). You should, however,
    avoid doing this as it means you will also capture exceptions that are intended
    for internal use by the interpreter. They include the so-called *system-exiting
    exceptions* . These are `SystemExit` , which is raised when the interpreter exits
    via a call to the `exit()` function, and `KeyboardInterrupt` , which is raised
    when the user terminates the application by pressing *Ctrl* + *C* (or *Delete*
    on some systems).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also raise exceptions from within an `except` clause. For example,
    you might want to replace a built-in exception (or one from a third-party library)
    with your own custom exception. This is quite a common technique when writing
    libraries, as it helps shield users from the implementation details of the library.
    Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Python assumes that an exception that happens within an `except`
    clause is an unexpected error and helpfully prints out tracebacks for both exceptions.
    We can tell the interpreter that we are deliberately raising the new exception
    by using a `raise from` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The error message has changed, but we still get both tracebacks, which is very
    handy for debugging. If you really wanted to completely suppress the original
    exception, you could use `from None` instead of `from e` (try this yourself).
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `raise` by itself, without specifying a new exception, to re-raise
    the original exception. This is sometimes useful if you want to log the fact that
    an exception has occurred without suppressing or replacing the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python 3.11, it is also possible to add notes to exceptions. This allows
    you to add extra information to be displayed as part of the traceback without
    suppressing or replacing the original exception. To see how this works, we will
    modify the quadratic formula example from earlier in the chapter, and add a note
    to the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have highlighted the lines where we added a note and re-raised the exception.
    The output when we run this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The note has been printed below the original error message. You can add as many
    notes as you need, by calling `add_note()` multiple times. The notes must all
    be strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming with exceptions can be tricky. You could inadvertently hide bugs
    by trapping exceptions that would have alerted you to their presence. Play it
    safe by keeping these simple guidelines in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the `try` clause as short as possible. It should contain only the code
    that may cause the exception(s) that you want to handle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the `except` clauses as specific as you can. It may be tempting to just
    write `except Exception` , but if you do, you will almost certainly end up catching
    exceptions you did not actually intend to catch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use tests to ensure that your code handles both expected and unexpected errors
    correctly. We shall talk more about writing tests in *Chapter 10, Testing* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you follow these suggestions, you will minimize the chance of getting it
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Exception groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with large collections of data, it can be inconvenient to immediately
    stop and raise an exception when an error occurs. It is often better to process
    all the data and report on all errors that occurred at the end. This allows the
    user to deal with all the errors at once, rather than having to rerun the process
    multiple times, fixing errors one by one.
  prefs: []
  type: TYPE_NORMAL
- en: One way of achieving this is to build up a list of errors and return it. However,
    this has the disadvantage that you cannot use a `try` / `except` statement to
    handle the errors. Some libraries have worked around this by creating a container
    exception class and wrapping the collected errors in an instance of this class.
    This allows you to handle the container exception in an `except` clause and inspect
    it to access the nested exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Since Python 3.11, there is a new built-in exception class, `ExceptionGroup`
    , that was specifically designed as such a container exception. Having this feature
    built into the language has the advantage that the traceback also shows the tracebacks
    of each of the nested exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we need to validate a list of ages to ensure that the
    values are all positive integers. We could write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `validate_ages()` function calls `validate_age()` for each element of `ages`
    . It catches any exceptions that occur and appends them to the `errors` list.
    If the list of errors is not empty after the loops complete, we raise `ExceptionGroup`
    , passing in the error message `"Validation errors"` and the list of errors that
    occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call this from a Python console with a list containing some invalid ages,
    we get the following traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that we get the traceback for the `ExceptionGroup` , including the error
    message we specified when raising it ( `"Validation errors"` ) and an indication
    that the group contains three sub-exceptions. Indented below this, we get the
    traceback for each of the nested sub-exceptions. To aid readability, the sub-exception
    tracebacks are numbered and separated by dashed lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can handle `ExceptionGroup` exceptions just like any other type of exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can access the nested list of sub-exceptions via the (read-only)
    `exceptions` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 654 ( [https://peps.python.org/pep-0654/](https://peps.python.org/pep-0654/)
    ), which introduced `ExceptionGroup` to the language, also introduced a new variant
    of the `try` / `except` statement that allows us to handle nested sub-exceptions
    of particular types within an `ExceptionGroup` . This new syntax uses the keyword
    `except*` instead of `except` . In our validation example, this allows us to have
    separate handling for invalid types and invalid values without having to manually
    iterate and filter the exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `validate_ages()` raises an exception group containing three exceptions:
    two instances of `TypeError` and a `ValueError` . The interpreter matches each
    `except*` clause to the nested exceptions. The first clause matches, so the interpreter
    creates a new `ExceptionGroup` containing all the `TypeError` instances from the
    original group and assigns this to `e` within the body of this clause. We print
    the string `"Invalid types"` , followed by the type and value of `e` and then
    `e.exceptions` . The remaining exceptions are then matched against the next `except*`
    clause.'
  prefs: []
  type: TYPE_NORMAL
- en: This time, all the `ValueError` instances match, so `e` is assigned to a new
    `ExceptionGroup` containing these. We print the string `"Invalid values"` , again
    followed by `type(e)` , `e` , and `e.exceptions` . At this point, there are no
    unhandled exceptions left in the group, so execution resumes normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to be aware that this behavior is different from a normal `try`
    / `except` statement. In a normal `try` / `except` statement, only one `except`
    clause is executed: the first that matches the raised exception. In a `try` /
    `except*` statement, each matching `except*` clause is executed until there are
    no unhandled exceptions remaining in the group. If any unhandled exceptions remain
    after all the `except*` clauses have been processed, they will be reraised at
    the end as a new `ExceptionGroup` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important point to note is that if an exception is raised within a
    `try` / `except*` statement that is not an `ExceptionGroup` instance, its type
    will be matched against the `except*` clauses. If a match is found, the exception
    will be wrapped in an `ExceptionGroup` before being passed to the `except*` body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This means that it is always safe to assume that the exception being handled
    within an `except*` clause is an `ExceptionGroup` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Not only for errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we move on to talk about context managers, we want to show you a different
    use of exceptions. In this example, we will demonstrate that exceptions can be
    used for more than just errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code above, we use three nested loops to find a combination of three
    integers ( `a` , `b` , and `c` ) that satisfy a particular equation. At the start
    of each of the outer loops, we check the value of a flag ( `found` ), which is
    set to `True` when we find a solution to the equation. This allows us to break
    out of all three loops as quickly as possible when we have a solution. We find
    the logic to check the flag rather inelegant, as it obscures the rest of the code,
    so we came up with an alternative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, you can appreciate how much more elegant this is. Now the breakout
    logic is entirely handled with a simple exception whose name even hints at its
    purpose. As soon as the result is found, we raise `ExitLoopException` with the
    values that satisfy our condition, and immediately the control is given to the
    `except` clause that handles it. Notice that we can use the `args` attribute of
    the exception to get the values that were passed to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should have a good understanding of what exceptions are, and how they
    are used to manage errors, flow, and exceptional situations. We are ready to move
    on to the next topic: **context managers** .'
  prefs: []
  type: TYPE_NORMAL
- en: Context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with external resources, we usually need to perform some cleanup
    steps when we are done. For example, after writing data to a file, we then need
    to close the file. Failing to clean up properly could result in all manner of
    bugs. Therefore, we must ensure that our cleanup code will be executed even if
    an exception happens. We could use `try` / `finally` statements, but this is not
    always convenient and could result in a lot of repetition, as we often have to
    perform similar cleanup steps whenever we work with a particular type of resource.
    **Context managers** solve this problem by creating an execution context in which
    we can work with a resource and automatically perform any necessary cleanup when
    we leave that context, even if an exception was raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use case of context managers is to make temporary changes to the global
    state of our program. One example of a global state that we may want to modify
    temporarily is the precision for decimal computations. For example, in data science
    applications, we sometimes need to perform a particular computation to a specific
    precision, but we want to retain the default precision for the rest of our computations.
    We could achieve this by doing something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we store the current context, set a new context (with a modified
    precision), perform our calculation, and finally restore the original context.
  prefs: []
  type: TYPE_NORMAL
- en: You may recall that the `Decimal` class allows us to perform arbitrary precision
    computations with decimal numbers. If not, you may want to review the relevant
    section of *Chapter 2* , *Built-In Data Types* , now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, we have printed the `context` object to show you what
    it contains. The rest of the code seems fine, but if an exception happened before
    we could restore the original context, the results of all subsequent computations
    would be incorrect. We can fix this by using a `try` / `finally` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That is much safer. Even if an exception does happen in that `try` block, we
    will always restore the original context. It is not very convenient to have to
    save the context and then restore it in a `try` / `finally` statement every time
    we need to work with a modified precision, though. Doing so would also violate
    the **DRY** principle. We can avoid that by using the `localcontext` context manager
    from the `decimal` module. This context manager will set and restore the context
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `with` statement is used to enter a runtime context defined by the `localcontext`
    context manager. When exiting the code block delimited by the `with` statement,
    any cleanup operation defined by the context manager (in this case, restoring
    the decimal context) is executed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to combine multiple context managers in one `with` statement.
    This is quite useful for situations where you need to work with multiple resources
    at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we enter a local context and open a file (which acts as a context manager)
    in one `with` statement. We perform a calculation and write the result to the
    file. When we exit the `with` block, the file is automatically closed, and the
    default decimal context is restored. Do not worry too much about the details of
    working with files for now; we will discuss that in detail in *Chapter 8* , *Files
    and Data Persistence* .
  prefs: []
  type: TYPE_NORMAL
- en: Before Python 3.10, surrounding multiple context managers in parentheses, as
    we did here, would have resulted in a `SyntaxError` . In older versions of Python,
    we would have had to fit both context managers into a single line of code or put
    the line break inside the parentheses of the `localcontext()` or `open()` calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from decimal contexts and files, many other objects in the Python standard
    library can be used as context managers. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Socket objects, which implement a low-level networking interface, can be used
    as context managers to automatically close network connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lock classes used for synchronization in concurrent programming use the
    context manager protocol to automatically release locks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the rest of this chapter, we will show you how you can implement your own
    context managers.
  prefs: []
  type: TYPE_NORMAL
- en: Class-based context managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Context managers work via two magic methods: `__enter__()` is called just before
    entering the body of the `with` statement and `__exit__()` is called when exiting
    the `with` statement body. This means that you can create your own context manager
    simply by writing a class that implements these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a context manager class called `MyContextManager` . There
    are a few interesting things to note about this class. Notice that the `__enter__()`
    method returns `self` . This is quite common, but by no means required; you can
    return whatever you want from `__enter__()` , even `None` . The return value of
    the `__enter__()` method will be assigned to the variable named in the `as` clause
    of the `with` statement. Also, notice the `exc_type` , `exc_val` , and `exc_tb`
    parameters of the `__exit__()` function. If an exception is raised within the
    body of the `with` statement, the interpreter will pass the *type* , *value* ,
    and *traceback* of the exception as arguments through these parameters. If no
    exception is raised, all three arguments will be `None` .
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that the `__exit__()` method returns `True` . This will cause any
    exception raised within the `with` statement body to be suppressed (as if we had
    handled it in a `try` / `except` statement). If we had returned `False` instead,
    such an exception would continue to be propagated after our `__exit__()` method
    has executed. The ability to suppress exceptions means that a context manager
    can be used as an exception handler. The benefit of this is that we can write
    our exception-handling logic once and reuse it wherever we need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see our context manager in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have instantiated our context manager in a separate statement, before
    the `with` statement. We did this to make it easier for you to see what is happening.
    However, it is much more common for those steps to be combined, like `with MyContextManager()
    as mgr` . Running this code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Study this output carefully to make sure you understand what is happening. We
    have printed some IDs to help verify that the object assigned to `mgr` is really
    the same object that we returned from `__enter__()` . Try changing the return
    values from the `__enter__()` and `__exit__()` methods and see what effect that
    has.
  prefs: []
  type: TYPE_NORMAL
- en: Generator-based context managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are implementing a class that represents some resource that needs to
    be acquired and released, it makes sense to implement that class as a context
    manager. Sometimes, however, we want to implement context manager behavior, but
    we do not have a class that it makes sense to attach that behavior to. For example,
    we may just want to use a context manager to reuse some error-handling logic.
    In such situations, it would be rather tedious to have to write an additional
    class purely to implement the desired context manager behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contextmanager` decorator from the `contextlib` module is useful for situations
    like this. It takes a *generator function* and converts it into a context manager
    (if you do not remember how generator functions work, you should review *Chapter
    5* , *Comprehensions and Generators* ). The decorator wraps the generator in a
    context manager object. The `__enter__()` method of this object starts the generator
    and returns whatever the generator yields. If an exception occurs within the `with`
    statement body, the `__exit__()` method passes the exception into the generator
    (using the generator’s `throw` method). Otherwise, `__exit__()` simply calls `next`
    on the generator. Note that the generator must only yield once; a `RuntimeError`
    will be raised if the generator yields a second time. Let us convert our previous
    example into a generator-based context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from running this is similar to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Most context manager generators have a similar structure to `my_context_manager()`
    in this example. They have some setup code, followed by a `yield` inside a `try`
    statement. Here, we yielded an arbitrary object so that you can see that the same
    object is made available via the `as` clause of the `with` statement. It is also
    common to have just a bare `yield` with no value (in which case, `None` is yielded).
    This is equivalent to returning `None` from the `__enter__()` method of a context
    manager class. In such cases, the `as` clause of the `with` statement will typically
    be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature of generator-based context managers is that they can
    also be used as function decorators. This means that if the entire body of a function
    needs to be inside a `with` statement context, you could save a level of indentation
    and just decorate the function instead.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `contextmanager` decorator, the `contextlib` module also
    contains many useful context managers. The documentation also provides several
    helpful examples of using and implementing context managers. Make sure you read
    it at [https://docs.python.org/3/library/contextlib.html](https://docs.python.org/3/library/contextlib.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The examples we gave in this section do not do anything useful. They were created
    purely to show you how context managers work. Study these examples carefully until
    you are confident that you understand them completely. Then start writing your
    own context managers (both as classes and generators). Try to convert the `try`
    / `except` statement for breaking out of a nested loop that we saw earlier in
    this chapter into a context manager. The `measure` decorator that we wrote in
    *Chapter 6* , *OOP, Decorators, and Iterators* , is also a good candidate for
    converting to a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at exceptions and context managers.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that exceptions are Python’s way of signaling that an error has occurred.
    We showed you how to catch exceptions so that your program does not fail when
    errors inevitably do happen.
  prefs: []
  type: TYPE_NORMAL
- en: We also showed you how you can raise exceptions yourself when your own code
    detects an error, and that you can even define your own exception types. We saw
    exception groups and the new syntax that extends the `except` clause. We ended
    our exploration of exceptions by seeing that they are not only useful for signaling
    errors but can also be used as a flow-control mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter with a brief overview of context managers. We saw how to
    use the `with` statement to enter a context defined by a context manager that
    performs cleanup operations when we exit the context. We also showed you how to
    create your own context managers, either as part of a class or by using a generator
    function.
  prefs: []
  type: TYPE_NORMAL
- en: We will see more context managers in action in the next chapter, which focuses
    on files and data persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_7.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
