<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Stacks and Queues</h1>
            </header>

            <article>
                
<p>In this chapter, we are going to build upon the skills we learned in the last chapter in order to create special list implementations. We are still sticking to linear structures. We will get to more complex data structures in the coming chapters.</p>
<p>In this chapter, we are going to look at the following:</p>
<ul>
<li>Implementing stacks and queues</li>
<li>Some applications of stacks and queues</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Stacks</h1>
            </header>

            <article>
                
<p>A stack is a data structure that is often likened to a stack of plates. If you have just washed a plate, you put it on top of the stack. When you need a plate, you take it off the top of the stack. So the last plate to be added to the stack will be the first to be removed from the stack. Thus, a stack is a <strong>last in, first out</strong> (<strong>LIFO</strong>) structure:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="119" src="assets/image_05_001.jpg" width="222"/></div>
<p>The preceding figure depicts a stack of plates. Adding a plate to the pile is only possible by leaving that plate on top of the pile. To remove a plate from the pile of plates means to remove the plate that is on top of the pile.</p>
<p>There are two primary operations that are done on stacks: <kbd>push</kbd> and <kbd>pop</kbd>. When an element is added to the top of the stack, it is pushed onto the stack. When an element is taken off the top of the stack, it is popped off the stack. Another operation which is used sometimes is <kbd>peek</kbd>, which makes it possible to see the element on the stack without popping it off.</p>
<p>Stacks are used for a number of things. One very common usage for stacks is to keep track of the return address during function calls. Let's imagine that we have the following little program:</p>
<pre>
def b(): <br/>    print('b') <br/><br/>def a(): <br/>    b() <br/><br/>a() <br/>print("done") 
</pre>
<p>When the program execution gets to the call to <kbd>a()</kbd>, it first pushes the address of the following instruction onto the stack, then jumps to <kbd>a</kbd>. Inside <kbd>a</kbd>, <kbd>b()</kbd> is called, but before that, the return address is pushed onto the stack. Once in <kbd>b()</kbd> and the function is done, the return address is popped off the stack, which takes us back to <kbd>a()</kbd>. When <kbd>a</kbd> has completed, the return address is popped off the stack, which takes us back to the <kbd>print</kbd> statement.</p>
<p>Stacks are actually also used to pass data between functions. Say you have the following function call somewhere in your code:</p>
<pre>
   somefunc(14, 'eggs', 'ham', 'spam') 
</pre>
<p>What is going to happen is that <kbd>14, 'eggs', 'ham'</kbd> and <kbd>'spam'</kbd> will be pushed onto the stack, one at a time:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="156" src="assets/image_05_002.jpg" width="247"/></div>
<p>When the code jumps into the function, the values for <kbd>a, b, c, d</kbd> will be popped off the stack. The <kbd>spam</kbd> element will be popped off first and assigned to <kbd>d</kbd>, then <kbd>"ham"</kbd> will be assigned to <kbd>c</kbd>, and so on:</p>
<pre>
    def somefunc(a, b, c, d): <br/>        print("function executed")
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Stack implementation</h1>
            </header>

            <article>
                
<p>Now let us study an implementation of a stack in Python. We start off by creating a <kbd>node</kbd> class, just as we did in the previous chapter with lists:</p>
<pre>
class Node: <br/>    def __init__(self, data=None): <br/>        self.data = data <br/>        self.next = None 
</pre>
<p>This should be familiar to you by now: a node holds data and a reference to the next item in a list. We are going to implement a stack instead of a list, but the same principle of nodes linked together still applies.</p>
<p>Now let us look at the <kbd>stack</kbd> class. It starts off similar to a singly linked list. We need to know the node at the top of the stack. We would also like to keep track of the number of nodes in the stack. So we will add these fields to our class:</p>
<pre>
class Stack: <br/>    def __init__(self): <br/>        self.top = None <br/>        self.size = 0 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Push operation</h1>
            </header>

            <article>
                
<p>The <kbd>push</kbd> operation is used to add an element to the top of the stack. Here is an implementation:</p>
<pre>
   def push(self, data): <br/>       node = Node(data) <br/>       if self.top: <br/>           node.next = self.top <br/>           self.top = node                 <br/>       else: <br/>           self.top = node <br/>       self.size += 1 
</pre>
<p>In the following figure, there is no existing node after creating our new node. Thus <kbd>self.top</kbd> will point to this new node. The else part of the <kbd>if</kbd> statement guarantees that this happens:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="190" src="assets/image_05_003.jpg" width="145"/></div>
<p>In a scenario where we have an existing stack, we move <kbd>self.top</kbd> so that it points to the newly created node. The newly created node must have its <strong>next</strong> pointer, pointing to the node that used to be the top node on the stack:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="157" src="assets/image_05_004.jpg" width="268"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Pop operation</h1>
            </header>

            <article>
                
<p>Now we need a <kbd>pop</kbd> method to remove the top element from the stack. As we do so, we need to return the topmost element as well. We will make the stack return <kbd>None</kbd> if there are no more elements:</p>
<pre>
    def pop(self): <br/>        if self.top: <br/>            data = self.top.data <br/>            self.size -= 1  <br/>            if self.top.next: <br/>                self.top = self.top.next <br/>            else: <br/>                self.top = None <br/>            return data <br/>        else: <br/>            return None 
</pre>
<p>The thing to pay attention to here is the inner <kbd>if</kbd> statement. If the top node has its <strong>next</strong> attribute pointing to another node, then we must set the top of the stack to now point to that node:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="113" src="assets/image_05_005.jpg" width="233"/></div>
<p>When there is only one node in the stack, the <kbd>pop</kbd> operation will proceed as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="35" src="assets/image_05_006.jpg" width="255"/></div>
<p>Removing such a node results in <kbd>self.top</kbd> pointing to <kbd>None</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="80" src="assets/image_05_007.jpg" width="257"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Peek</h1>
            </header>

            <article>
                
<p>As we said earlier, we could also add a <kbd>peek</kbd> method. This will just return the top of the stack without removing it from the stack, allowing us to look at the top element without changing the stack itself. This operation is very straightforward. If there is a top element, return its data, otherwise return <kbd>None</kbd> (so that the behavior of <kbd>peek</kbd> matches that of <kbd>pop</kbd>):</p>
<pre>
    def peek(self): <br/>        if self.top <br/>            return self.top.data <br/>        else: <br/>            return None 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Bracket-matching application</h1>
            </header>

            <article>
                
<p>Now let us look at an example of how we can use our stack implementation. We are going to write a little function that will verify whether a statement containing brackets--(, [, or {--is balanced, that is, whether the number of closing brackets matches the number of opening brackets. It will also ensure that one pair of brackets really is contained in another:</p>
<pre>
    def check_brackets(statement): <br/>        stack = Stack() <br/>        for ch in statement: <br/>            if ch in ('{', '[', '('): <br/>                stack.push(ch) <br/>            if ch in ('}', ']', ')'): <br/>                last = stack.pop() <br/>            if last is '{' and ch is '}': <br/>                continue <br/>            elif last is '[' and ch is ']': <br/>                continue <br/>            elif last is '(' and ch is ')': <br/>                continue <br/>            else: <br/>                return False <br/>    if stack.size &gt; 0: <br/>        return False <br/>    else: <br/>        return True 
</pre>
<p>Our function parses each character in the statement passed to it. If it gets an open bracket, it pushes it onto the stack. If it gets a closing bracket, it pops the top element off the stack and compares the two brackets to make sure their types match: ( should match ), [ should match ], and { should match }. If they don't, we return <kbd>False</kbd>, otherwise we continue parsing.</p>
<p>Once we have got to the end of the statement, we need to do one last check. If the stack is empty, then we are fine and we can return <kbd>True</kbd>. But if the stack is not empty, then we have some opening bracket which does not have a matching closing bracket and we shall return <kbd>False</kbd>.</p>
<p>We can test the bracket-matcher with the following little code:</p>
<pre>
sl = ( <br/>   "{(foo)(bar)}[hello](((this)is)a)test", <br/>   "{(foo)(bar)}[hello](((this)is)atest", <br/>   "{(foo)(bar)}[hello](((this)is)a)test))" <br/>) <br/><br/>for s in sl: <br/>   m = check_brackets(s) <br/>   print("{}: {}".format(s, m)) 
</pre>
<p>Only the first of the three statements should match. And when we run the code, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="289" src="assets/image_05_008.png" width="446"/></div>
<p><kbd>True</kbd>, <kbd>False</kbd>, <kbd>False</kbd>. The code works. In summary, the <kbd>push</kbd> and <kbd>pop</kbd> operations of the stack data structure attract a <strong>O</strong>(<em>1</em>). The stack data structure is simply enough but is used to implement a whole range of functionality in the real world. The back and forward buttons on the browser are made possible by stacks. To be able to have undo and redo functionality in word processors, stacks are also used.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Queues</h1>
            </header>

            <article>
                
<p>Another special type of list is the queue data structure. This data structure is no different from the regular queue you are accustomed to in real life. If you have stood in line at an airport or to be served your favorite burger at your neighborhood shop, then you should know how things work in a queue.</p>
<p>Queues are also a very fundamental and important concept to grasp since many other data structures are built on them.</p>
<p>The way a queue works is that the first person to join the queue usually gets served first, all things being equal. The acronym FIFO best explains this. <strong>FIFO</strong> stands for <strong>first in, first out</strong>. When people are standing in a queue waiting for their turn to be served, service is only rendered at the front of the queue. The only time people exit the queue is when they have been served, which only occurs at the very front of the queue. By strict definition, it is illegal for people to join the queue at the front where people are being served:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="115" src="assets/image_05_009.jpg" width="475"/></div>
<p>To join the queue, participants must first move behind the last person in the queue. The length of the queue does not matter. This is the only legal or permitted way by which the queue accepts new entrants.</p>
<p>As human as we are, the queues that we form do not conform to strict rules. It may have people who are already in the queue deciding to fall out or even have others substituting for them. It is not our intent to model all the dynamics that happen in a real queue. Abstracting what a queue is and how it behaves enables us to solve a plethora of challenges, especially in computing.</p>
<p>We shall provide various implementations of a queue but all will revolve around the same idea of FIFO. We shall call the operation to add an element to the queue enqueue. To remove an element from the queue, we will create a <kbd>dequeue</kbd> operation. Anytime an element is enqueued, the length or size of the queue increases by one. Conversely, dequeuing items reduce the number of elements in the queue by one.</p>
<p>To demonstrate the two operations, the following table shows the effect of adding and removing elements from a queue:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Queue operation</strong></p>
</td>
<td>
<p><strong>Size</strong></p>
</td>
<td>
<p><strong>Contents</strong></p>
</td>
<td>
<p><strong>Operation results</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>Queue()</kbd></p>
</td>
<td>
<p>0</p>
</td>
<td>
<p><kbd>[]</kbd></p>
</td>
<td>
<p>Queue object created</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Enqueue</kbd> "Mark"</p>
</td>
<td>
<p>1</p>
</td>
<td>
<p><kbd>['mark']</kbd></p>
</td>
<td>
<p>Mark added to queue</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Enqueue</kbd> "John"</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p><kbd>['mark','john']</kbd></p>
</td>
<td>
<p>John added to queue</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Size()</kbd></p>
</td>
<td>
<p>2</p>
</td>
<td>
<p><kbd>['mark','john']</kbd></p>
</td>
<td>
<p>Number of items in queue returned</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Dequeue()</kbd></p>
</td>
<td>
<p>1</p>
</td>
<td>
<p><kbd>['mark']</kbd></p>
</td>
<td>
<p>John is dequeued and returned</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Dequeue()</kbd></p>
</td>
<td>
<p>0</p>
</td>
<td>
<p><kbd>[]</kbd></p>
</td>
<td>
<p>Mark is dequeued and returned</p>
</td>
</tr>
</tbody>
</table>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">List-based queue</h1>
            </header>

            <article>
                
<p>To put into code everything discussed about queues to this point, let's go ahead and implement a very simple queue using Python's <kbd>list</kbd> class. This is to help us develop quickly and learn about queues. The operations that must be performed on the queue are encapsulated in the <kbd>ListQueue</kbd> class<span class="HeaderFooterPACKT">:</span></p>
<pre>
class ListQueue: <br/>    def __init__(self): <br/>        self.items = [] <br/>        self.size = 0 
</pre>
<p>In the initialization method <kbd>__init__</kbd>, the <kbd>items</kbd> instance variable is set to <kbd>[]</kbd>, which means the queue is empty when created. The size of the queue is also set to <kbd>zero</kbd>. The more interesting methods are the <kbd>enqueue</kbd> and <kbd>dequeue</kbd> methods.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Enqueue operation</h1>
            </header>

            <article>
                
<p>The <kbd>enqueue</kbd> operation or method uses the <kbd>insert</kbd> method of the <kbd>list</kbd> class to insert items (or data) at the front of the list:</p>
<pre>
    def enqueue(self, data): <br/>        self.items.insert(0, data) <br/>        self.size += 1 
</pre>
<p>Do note how we implement insertions to the end of the queue. Index 0 is the first position in any list or array. However, in our implementation of a queue using a Python list, the array index 0 is the only place where new data elements are inserted into the queue. The <kbd>insert</kbd> operation will shift existing data elements in the list by one position up and then insert the new data in the space created at index 0. The following figure visualizes this process:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="224" src="assets/image_05_010.jpg" width="360"/></div>
<p>To make our queue reflect the addition of the new element, the size is increased by one:</p>
<pre>
self.size += 1 
</pre>
<div class="packt_infobox">We could have used Python's <kbd>shift</kbd> method on the list as another way of implementing the "insert at 0". At the end of the day, an implementation is the overall objective of the exercise.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Dequeue operation</h1>
            </header>

            <article>
                
<p>The <kbd>dequeue</kbd> operation is used to remove items from the queue. With reference to the introduction to the topic of queues, this operation captures the point where we serve the customer who joined the queue first and also waited the longest:</p>
<pre>
    def dequeue(self):<br/>        data = self.items.pop()<br/>        self.size -= 1<br/>        return data
</pre>
<p>The Python <kbd>list</kbd> class has a method called <kbd>pop()</kbd>. The <kbd>pop</kbd> method does the following:</p>
<ol>
<li>Removes the last item from the list.</li>
<li>Returns the removed item from the list back to the user or code that called it.</li>
</ol>
<p>The last item in the list is popped and saved in the <kbd>data</kbd> variable. In the last line of the method, the data is returned.</p>
<p>Consider the tunnel in the following figure as our queue. To perform a <kbd>dequeue</kbd> operation, the node with data <kbd>1</kbd> is removed from the front of the queue:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="125" src="assets/image_05_011.jpg" width="400"/></div>
<p>The resulting elements in the queue are as shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="127" src="assets/image_05_012.jpg" width="403"/></div>
<div class="packt_infobox">What can we say about the <kbd>enqueue</kbd> operation? It is highly inefficient in more than one way. The method has to first shift all the elements by one space. Imagine when there are 1 million elements in a list which need to be shifted around anytime a new element is being added to the queue. This will generally make the enqueue process very slow for large lists.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Stack-based queue</h1>
            </header>

            <article>
                
<p>Yet another implementation of a queue is to use two stacks. Once more, the Python <kbd>list</kbd> class will be used to simulate a stack:</p>
<pre>
class Queue: <br/>    def __init__(self): <br/>        self.inbound_stack = [] <br/>        self.outbound_stack = [] 
</pre>
<p>The preceding <kbd>queue</kbd> class sets the two instance variables to empty lists upon initialization. These are the stacks that will help us implement a queue. The stacks in this case are simply Python lists that allow us to call <kbd>push</kbd> and <kbd>pop</kbd> methods on them.</p>
<p>The <kbd>inbound_stack</kbd> is only used to store elements that are added to the queue. No other operation can be performed on this stack.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Enqueue operation</h1>
            </header>

            <article>
                
<p>The <kbd>enqueue</kbd> method is what adds elements to the queue:</p>
<pre>
def enqueue(self, data): <br/>    self.inbound_stack.append(data) 
</pre>
<p>The method is a simple one that only receives the <kbd>data</kbd> the client wants to append to the queue. This data is then passed to the <kbd>append</kbd> method of the <kbd>inbound_stack</kbd> in the <kbd>queue</kbd> class. Furthermore, the <kbd>append</kbd> method is used to mimic the <kbd>push</kbd> operation, which pushes elements to the top of the stack.</p>
<p>To <kbd>enqueue</kbd> data onto the <kbd>inbound_stack</kbd>, the following code does justice:</p>
<pre>
queue = Queue() <br/>queue.enqueue(5) <br/>queue.enqueue(6) <br/>queue.enqueue(7) <br/>print(queue.inbound_stack) 
</pre>
<p>A command-line output of the <kbd>inbound_stack</kbd> inside the queue is as follows:</p>
<pre>
    <strong>[5, 6, 7]</strong>
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Dequeue operation</h1>
            </header>

            <article>
                
<p>The <kbd>dequeue</kbd> operation is a little more involved than its <kbd>enqueue</kbd> counterpart operation. New elements added to our queue end up in the <kbd>inbound_stack</kbd>. Instead of removing elements from the <kbd>inbound_stack</kbd>, we shift our attention to the <kbd>outbound_stack</kbd>. As we said, elements can be deleted from our queue only through the <kbd>outbound_stack</kbd>:</p>
<pre>
    if not self.outbound_stack: <br/>        while self.inbound_stack: <br/>            self.outbound_stack.append(self.inbound_stack.pop()) <br/>    return self.outbound_stack.pop() 
</pre>
<p>The <kbd>if</kbd> statement first checks whether the <kbd>outbound_stack</kbd> is empty or not. If it is not empty, we proceed to remove the element at the front of the queue by doing the following:</p>
<pre>
return self.outbound_stack.pop() 
</pre>
<p>If the <kbd>outbound_stack</kbd> is empty instead, all the elements in the <kbd>inbound­_stack</kbd> are moved to the <kbd>outbound_stack</kbd> before the front element in the queue is popped out:</p>
<pre>
while self.inbound_stack: <br/>    self.outbound_stack.append(self.inbound_stack.pop()) 
</pre>
<p>The <kbd>while</kbd> loop will continue to be executed as long as there are elements in the <kbd>inbound_stack</kbd>.</p>
<p>The statement <kbd>self.inbound_stack.pop()</kbd> will remove the latest element that was added to the <kbd>inbound_stack</kbd> and immediately pass the popped data to the <kbd>self.outbound_stack.append()</kbd> method call.</p>
<p>Initially, our <kbd>inbound_stack</kbd> was filled with the elements <strong>5</strong>, <strong>6</strong> and <strong>7</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="200" src="assets/image_05_013.jpg" width="130"/></div>
<p>After executing the body of the <kbd>while</kbd> loop, the <kbd>outbound_stack</kbd> looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="181" src="assets/image_05_014.jpg" width="118"/></div>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="155" src="assets/image_05_015.png" width="268"/></div>
<p>The last line in the <kbd>dequeue</kbd> method will return <kbd>5</kbd> as the result of the <kbd>pop</kbd> operation on the <kbd>outbound_stack</kbd>:</p>
<pre>
return self.outbound_stack.pop() 
</pre>
<p>This leaves the <kbd>outbound_stack</kbd> with only two elements:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="167" src="assets/image_05_016.jpg" width="123"/></div>
<p>The next time the <kbd>dequeue</kbd> operation is called, the <kbd>while</kbd> loop will not be executed because there are no elements in the <kbd>outbound_stack</kbd>, which makes the outer <kbd>if</kbd> statement fail.</p>
<p>The <kbd>pop</kbd> operation is called right away in that case so that only the element in the queue that has waited the longest is returned.</p>
<p>A typical run of code to use this queue implementation is as follows:</p>
<pre>
queue = Queue() <br/>queue.enqueue(5) <br/>queue.enqueue(6) <br/>queue.enqueue(7) <br/>print(queue.inbound_stack) <br/>queue.dequeue() <br/>print(queue.inbound_stack) <br/>print(queue.outbound_stack) <br/>queue.dequeue() <br/>print(queue.outbound_stack) 
</pre>
<p>The output for the preceding code is as follows:</p>
<pre>
<strong>    [5, 6, 7] </strong><br/><strong>    [] </strong><br/><strong>    [7, 6] </strong><br/><strong>    [7]</strong> 
</pre>
<p>The code sample adds elements to a queue and prints out the elements within the queue. The <kbd>dequeue</kbd> method is called, after which a change in the number of elements is observed when the queue is printed out again.</p>
<div class="packt_tip">Implementing a queue with two stacks is a popular question posed during interviews.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Node-based queue</h1>
            </header>

            <article>
                
<p>Using a Python list to implement a queue is a good starter to get the feel of how queues work. It is completely possible for us to implement our own queue data structure by utilizing our knowledge of pointer structures.</p>
<p>A queue can be implemented using a doubly linked list, and <kbd>insertion</kbd> and <kbd>deletion</kbd> operations on this data structure have a time complexity of <strong>O</strong>(<em>1</em>).</p>
<p>The definition for the <kbd>node</kbd> class remains the same as the <kbd>Node</kbd> we defined when we touched on doubly linked list, The doubly linked list can be treated as a queue if it enables a FIFO kind of data access, where the first element added to the list is the first to be removed.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Queue class</h1>
            </header>

            <article>
                
<p>The <kbd>queue</kbd> class is very similar to that of the doubly linked <kbd>list</kbd> class:</p>
<pre>
class Queue: <br/>def __init__(self): <br/>        self.head = None <br/>        self.tail = None <br/>        self.count = 0 
</pre>
<p><kbd>self.head</kbd> and <kbd>self.tail</kbd> pointers are set to <kbd>None</kbd> upon creation of an instance of the <kbd>queue</kbd> class. To keep a count of the number of nodes in <kbd>Queue</kbd>, the <kbd>count</kbd> instance variable is maintained here too and set to <kbd>0</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Enqueue operation</h1>
            </header>

            <article>
                
<p>Elements are added to a <kbd>Queue</kbd> object via the <kbd>enqueue</kbd> method. The elements in this case are the nodes:</p>
<pre>
    def enqueue(self, data): <br/>        new_node = Node(data, None, None) <br/>        if self.head is None: <br/>            self.head = new_node <br/>            self.tail = self.head <br/>        else: <br/>            new_node.prev = self.tail <br/>            self.tail.next = new_node <br/>            self.tail = new_node <br/><br/>        self.count += 1 
</pre>
<p>The <kbd>enqueue</kbd> method code is the same code already explained in the <kbd>append</kbd> operation of the doubly linked list. It creates a node from the data passed to it and appends it to the tail of the queue, or points both <kbd>self.head</kbd> and <kbd>self.tail</kbd> to the newly created node if the queue is empty. The total count of elements in the queue is increased by the line <kbd>self.count += 1.</kbd></p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Dequeue operation</h1>
            </header>

            <article>
                
<p>The other operation that makes our doubly linked list behave as a queue is the <kbd>dequeue</kbd> method. This method is what removes the node at the front of the queue.</p>
<p>To remove the first element pointed to by <kbd>self.head</kbd>, an <kbd>if</kbd> statement is used:</p>
<pre>
def dequeue(self): <br/>current = self.head <br/>        if self.count == 1: <br/>            self.count -= 1 <br/>            self.head = None <br/>            self.tail = None <br/>        elif self.count &gt; 1: <br/>            self.head = self.head.next <br/>            self.head.prev = None <br/>            self.count -= 1 
</pre>
<p><kbd>current</kbd> is initialized by pointing it to <kbd>self.head</kbd>. If <kbd>self.count</kbd> is 1, then it means only one node is in the list and invariably the queue. Thus, to remove the associated node (pointed to by <kbd>self.head</kbd>), the <kbd>self.head</kbd> and <kbd>self.tail</kbd> variables are set to <kbd>None</kbd>.</p>
<p>If, on the other hand, the queue has many nodes, then the head pointer is shifted to point to <kbd>self.head</kbd>'s next node.</p>
<p>After the <kbd>if</kbd> statement is run, the method returns the node that was pointed to by <kbd>head</kbd>. <kbd>self.count</kbd> is decremented by one in either way the <kbd>if</kbd> statement execution path flows.</p>
<p>Equipped with these methods, we have successfully implemented a queue, borrowing heavily from the idea of a doubly linked list.</p>
<p>Remember also that the only things transforming our doubly linked list into a queue are the two methods, namely <kbd>enqueue</kbd> and <kbd>dequeue</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Application of queues</h1>
            </header>

            <article>
                
<p>Queues are used to implement a variety of functionalities in computer land. For instance, instead of providing each computer on a network with its own printer, a network of computers can be made to share one printer by queuing what each printer wants to print. When the printer is ready to print, it will pick one of the items (usually called jobs) in the queue to print out.</p>
<p>Operating systems also queue processes to be executed by the CPU. Let's create an application that makes use of a queue to create a bare-bones media player.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Media player queue</h1>
            </header>

            <article>
                
<p>Most music player software allows users the chance to add songs to a playlist. Upon hitting the play button, all the songs in the main playlist are played one after the other. The sequential playing of the songs can be implemented with queues because the first song to be queued is the first song that is played. This aligns with the FIFO acronym. We shall implement our own playlist queue that plays songs in the FIFO manner.</p>
<p>Basically, our media player queue will only allow for the addition of tracks and a way to play all the tracks in the queue. In a full-blown music player, threads would be used to improve how the queue is interacted with, while the music player continues to be used to select the next song to be played, paused, or even stopped.</p>
<p>The <kbd>track</kbd> class will simulate a musical track:</p>
<pre>
from random import randint <br/>class Track: <br/><br/>    def __init__(self, title=None): <br/>        self.title = title <br/>        self.length = randint(5, 10) 
</pre>
<p>Each track holds a reference to the title of the song and also the length of the song. The length is a random number between 5 and 10. The random module provides the <kbd>randint</kbd> method to enable us generate the random numbers. The class represents any MP3 track or file that contains music. The random length of a track is used to simulate the number of seconds it takes to play a song or track.</p>
<p>To create a few tracks and print out their lengths, we do the following:</p>
<pre>
track1 = Track("white whistle") <br/>track2 = Track("butter butter") <br/>print(track1.length) <br/>print(track2.length) 
</pre>
<p>The output of the preceding code is as follows:</p>
<pre>
    <strong>6</strong><br/><strong>    7</strong>
</pre>
<p>Your output may be different depending on the random length generated for the two tracks.</p>
<p>Now, let's create our queue. Using inheritance, we simply inherit from the <kbd>queue</kbd> class:</p>
<pre>
import time <br/>class MediaPlayerQueue(Queue): <br/><br/>    def __init__(self): <br/>        super(MediaPlayerQueue, self).__init__() 
</pre>
<p>A call is made to properly initialize the queue by making a call to <kbd>super</kbd>. This class is essentially a queue that holds a number of track objects in a queue. To add tracks to the queue, an <kbd>add_track</kbd> method is created:</p>
<pre>
    def add_track(self, track): <br/>        self.enqueue(track) 
</pre>
<p>The method passes a <kbd>track</kbd> object to the <kbd>enqueue</kbd> method of the queue <kbd>super</kbd> class. This will, in effect, create a <kbd>Node</kbd> using the <kbd>track</kbd> object (as the node's data) and point either the tail, if the queue is not empty, or both head and tail, if the queue is empty, to this new node.</p>
<p>Assuming the tracks in the queue are played sequentially from the first track added to the last (FIFO), then the <kbd>play</kbd> function has to loop through the elements in the queue:</p>
<pre>
def play(self): <br/>        while self.count &gt; 0: <br/>            current_track_node = self.dequeue() <br/>            print("Now playing {}".format(current_track_node.data.title)) <br/>            time.sleep(current_track_node.data.length) 
</pre>
<p><kbd>self.count</kbd> keeps count of when a track is added to our queue and when tracks have been dequeued. If the queue is not empty, a call to the <kbd>dequeue</kbd> method will return the node (which houses the <kbd>track</kbd> object) at the front of the queue. The <kbd>print</kbd> statement then accesses the title of the track through the <kbd>data</kbd> attribute of the node. To further simulate the playing of a track, the <kbd>time.sleep()</kbd> method halts program execution till the number of seconds of the track has elapsed:</p>
<pre>
time.sleep(current_track_node.data.length) 
</pre>
<p>The media player queue is made up of nodes. When a track is added to the queue, the track is hidden in a newly created node and associated with the data attribute of the node. That explains why we access a node's <kbd>track</kbd> object through the data property of the node which is returned by the call to <kbd>dequeue</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="133" src="assets/B05630_05_16.jpg" width="275"/></div>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">You can see, instead of our <kbd>node</kbd> object just storing just any data, it stores tracks in this case.</p>
<p>Let's take our music player for a spin:</p>
<pre>
track1 = Track("white whistle") <br/>track2 = Track("butter butter") <br/>track3 = Track("Oh black star") <br/>track4 = Track("Watch that chicken") <br/>track5 = Track("Don't go") 
</pre>
<p>We create five track objects with random words as titles:</p>
<pre>
print(track1.length) <br/>print(track2.length) <br/><strong>&gt;&gt; 8<br/></strong><strong>&gt;&gt; 9</strong>
</pre>
<p>The output should be different from what you get on your machine due to the random length.</p>
<p>Next, an instance of the <kbd>MediaPlayerQueue</kbd> class is created:</p>
<pre>
media_player = MediaPlayerQueue() 
</pre>
<p>The tracks will be added and the output of the <kbd>play</kbd> function should print out the tracks being played in the same order in which we queued them:</p>
<pre>
media_player.add_track(track1) <br/>media_player.add_track(track2) <br/>media_player.add_track(track3) <br/>media_player.add_track(track4) <br/>media_player.add_track(track5) <br/>media_player.play() 
</pre>
<p><span>The output of the preceding code is as follows</span><span>:</span></p>
<pre>
    <strong>&gt;&gt;Now playing white whistle</strong><br/><strong>    &gt;&gt;Now playing butter butter</strong><br/><strong>    &gt;&gt;Now playing Oh black star</strong><br/><strong>    &gt;&gt;Now playing Watch that chicken</strong><br/><strong>    &gt;&gt;Now playing Don't go</strong>
</pre>
<p>Upon execution of the program, it can be seen that the tracks are played in the order in which they were queued. When playing the track, the system also pauses for the number of seconds equal to that of the length of the track.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we used our knowledge of linking nodes together to create other data structures, namely stacks and queues. We have seen how these data structures closely mimic stacks and queues in the real world. Concrete implementations, together with their varying types, have been shown. We later applied the concept of stacks and queues to write real-life programs.</p>
<p>We shall consider trees in the next chapter. The major operations on a tree will be discussed, likewise the different spheres in which to apply the data structure.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>