<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Audio Player"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Audio Player</h1></div></div></div><p>Let's now build an audio media player!</p><p>Our application should have features offered by typical media players, such as play, pause, fast forward, rewind, next, mute, volume updates, and more. Our player should let the listener easily access individual media files or media library from his or her local drive.</p><p>In addition to<a id="id405" class="indexterm"/> this, our player should be able to scan entire directories for a song and accordingly, auto update the playlist with all supported formats. All this and more.</p><p>Let us start our project!</p><div class="section" title="Mission Briefing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Mission Briefing</h1></div></div></div><p>On completion<a id="id406" class="indexterm"/> our player will look as follows:</p><div class="mediaobject"><img src="graphics/7941_05_01.jpg" alt="Mission Briefing"/></div><p>Our audio player will be capable of playing audio files in AU, MP2, MP3, OGG/Vorbis, WAV, and WMA formats. It will have all the controls that you would expect of a small media player.</p><p>We will use cross-platform modules to write our code. This will ensure that our player can play audio files on Windows, Mac OS X, and Linux platforms.</p><div class="section" title="Why Is It Awesome?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec98"/>Why Is It Awesome?</h2></div></div></div><p>In addition to <a id="id407" class="indexterm"/>getting to hear good music while testing our code, this project will introduce us to several new ideas related to GUI programming with Tkinter.</p><p>For one, we get to work with new sets of widgets, such as the Listbox, Progressbar, Scale, Radiobutton, and PMW Balloon widget.</p><p>We also take a look at the power of the Canvas widget in accommodating and precise positioning of other widgets within it.</p><p>Towards the end of the project, we take a look at a Tkinter extension named PMW. We also discuss some more Tkinter extensions that we do not use here, but are good to have in our GUI programming arsenal.</p><p>Though not a topic for this book, we also get a brief insight into the world of audio programming <a id="id408" class="indexterm"/>with Python, which necessarily looks at how to work with external libraries and API implementations.</p></div><div class="section" title="Your Hotshot Objectives"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec99"/>Your Hotshot Objectives</h2></div></div></div><p>Some of the key objectives outlined for this project include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reinforcing<a id="id409" class="indexterm"/> our experiences and learning from previous projects</li><li class="listitem" style="list-style-type: disc">Working with new set of widgets, such as Listbox, Scale, Progressbar, and Radiobutton</li><li class="listitem" style="list-style-type: disc">Getting to know more of the Canvas widget</li><li class="listitem" style="list-style-type: disc">Working with external APIs</li><li class="listitem" style="list-style-type: disc">Getting to know about some common Tkinter extensions, such as PMW, WCK, Tix, and others</li><li class="listitem" style="list-style-type: disc">Learning to refactor code at each stage of development</li></ul></div></div><div class="section" title="Mission Checklist"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec100"/>Mission Checklist</h2></div></div></div><p>We will use the following additional libraries for this project:</p><div class="section" title="Pyglet for audio manipulation"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec50"/>Pyglet for audio manipulation</h3></div></div></div><p>Window users can <a id="id410" class="indexterm"/>download and install binary packages for pyglet from:</p><p>
<a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet">http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet</a>
</p><p>Mac OS X and <a id="id411" class="indexterm"/>Linux users should download and compile pyglet from the source ZIP file available at:</p><p>
<a class="ulink" href="http://www.pyglet.org/download.html">http://www.pyglet.org/download.html</a>
</p><p>When installing from source, you will also need to add the <code class="literal">AVbin.dll</code> to your current program directory. The link to the DLL file is also available at the preceding download page.</p></div><div class="section" title="PMW Tkinter extension"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec51"/>PMW Tkinter extension</h3></div></div></div><p>We will be using <span class="strong"><strong>Python mega widgets </strong></span>(<span class="strong"><strong>PMW</strong></span>) Tkinter <a id="id412" class="indexterm"/>extension to code some widgets features not <a id="id413" class="indexterm"/>available in core Tkinter. PMW must be installed from the source package for all platforms. The package can be downloaded at:</p><p>
<a class="ulink" href="http://sourceforge.net/projects/pmw/files/Pmw/Pmw.1.3.3/">http://sourceforge.net/projects/pmw/files/Pmw/Pmw.1.3.3/</a>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>We use Version 1.3.3 in our application, and other versions of PMW may not be compatible with our code.</p></div></div></div><div class="section" title="Additional font"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec52"/>Additional font</h3></div></div></div><p>This is an optional component meant only to augment our styling. We install a font to mimic the font of a <a id="id414" class="indexterm"/>digital clock. We have used the following font for this project:</p><p>
<a class="ulink" href="http://www.dafont.com/ds-digital.font">http://www.dafont.com/ds-digital.font</a>
</p><p>After you have installed pyglet and PMW, execute the following command from your Python shell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import pyglet, Pmw</strong></span>
</pre></div><p>If the command executes without any error message, you are ready to code your media player.</p></div></div></div></div>
<div class="section" title="Getting the audio to play"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Getting the audio to play</h1></div></div></div><p>The first goal of our project is to add the ability to play the audio file. As usual, we will keep the audio related logic separate<a id="id415" class="indexterm"/> from our GUI section. Therefore, we create two separate files: <code class="literal">main-gui.py</code> and <code class="literal">player.py</code>. (See <span class="emphasis"><em>code 5.01</em></span>)</p><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec101"/>Prepare for Lift Off</h2></div></div></div><p>We first code a basic GUI, which includes a Play button (which toggles between play and stop functionality) and an Add File button. At the end of this iteration, we should be able to load a file, play it, and stop it. By the end of this section, our application will look like the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_05_02.jpg" alt="Prepare for Lift Off"/></div></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec102"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – creating the GUI class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec53"/>Step 1 – creating the GUI class</h3></div></div></div><p>Let's create<a id="id416" class="indexterm"/> the <code class="literal">GUI</code> class. The code for <code class="literal">main-gui.py</code> is as follows (see <span class="emphasis"><em>code 5.01 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">from Tkinter import *
import tkFileDialog
import player
class GUI:
   def __init__(self, player):
     self.player = player
     player.parent = self
     self.root = Tk()
     self.create_button_frame()
     self.create_bottom_frame()
     self.root.mainloop()</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We create a class named <code class="literal">GUI</code>, and run the Tkinter mainloop from within its <code class="literal">__init__ method</code>.</li><li class="listitem" style="list-style-type: disc">We will separate the actual audio manipulation logic such as play, pause, rewind, forward, and others in a separate class to be defined later. However, because we want those functionalities to be available in this <code class="literal">GUI</code> class, we pass an object instantiated out of that <code class="literal">player</code> class as an argument to our <code class="literal">__init__</code> method.</li><li class="listitem" style="list-style-type: disc">The line <code class="literal">self.player = player</code> within our <code class="literal">__init__</code> method ensures that the <code class="literal">player</code> class instance is available throughout the <code class="literal">GUI</code> class.</li><li class="listitem" style="list-style-type: disc">Just like we want to access the properties and methods of the <code class="literal">player</code> class from this <code class="literal">GUI</code> class, we also want the methods and attributes of the <code class="literal">GUI</code> class to be available within our <code class="literal">player</code> class. We, therefore, use the line <code class="literal">player.parent = self </code>in the <code class="literal">__init__ </code>method. This creates a reference to self so that all its methods can be assessed inside the <code class="literal">player</code> class using the syntax <code class="literal">parent.attribute</code> and <code class="literal">parent.method()</code>.</li><li class="listitem" style="list-style-type: disc">With these two lines of code, we have ensured that all properties of the <code class="literal">GUI</code> class will be available in the <code class="literal">player</code> class and vice versa; all properties of the <code class="literal">player</code> class will be available in the <code class="literal">GUI</code> class.</li></ul></div></div><div class="section" title="Step 2 – creating the Play button and Add File button"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec54"/>Step 2 – creating the Play button and Add File button</h3></div></div></div><p>For this, we add two methods: <code class="literal">create_button_frame</code> and <code class="literal">create_bottom_frame</code>. The <code class="literal">create_button_frame </code>method holds the Play button, and the <code class="literal">create_bottom_frame </code>method holds the Add File button, as follows:</p><div class="informalexample"><pre class="programlisting">def create_button_frame(self):
    buttonframe= Frame(self.root)
    self.playicon = PhotoImage(file='../icons/play.gif')
    self.stopicon = PhotoImage(file='../icons/stop.gif')
    self.playbtn=Button(buttonframe, text ='play', image=self.playicon, borderwidth=0, command=self.toggle_play_pause)
   self.playbtn.image = self.playicon
   self.playbtn.grid(row=3, column=3)
   buttonframe.grid(row=1, pady=4, padx=5)

def create_bottom_frame(self):
    bottomframe = Frame(self.root)
    add_fileicon = PhotoImage(file='../icons/add_file.gif')
   add_filebtn=Button(bottomframe, image=add_fileicon, borderwidth=0, text='Add File', command=self.add_file)
   add_filebtn.image = add_fileicon
   add_filebtn.grid(row=2, column=1)
   bottomframe.grid(row=2, sticky='w', padx=5)</pre></div><p>The <a id="id417" class="indexterm"/>description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each of the two buttons is associated with a <code class="literal">TkinterPhotoImage </code>class icon. We have provided a set of icons in a separate folder named <code class="literal">icons</code>.</li></ul></div></div><div class="section" title="Step 3 – toggling between play and pause"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec55"/>Step 3 – toggling between play and pause</h3></div></div></div><p>The Play button has a command callback that toggles the button between play and stop functionality. The <code class="literal">toggle</code> method is defined as follows:</p><div class="informalexample"><pre class="programlisting">def toggle_play_pause(self):
    if self.playbtn['text'] =='play':
     self.playbtn.config(text='stop', image=self.stopicon)
     self.player.start_play_thread()
   elif self.playbtn['text'] =='stop':
     self.playbtn.config(text ='play', image=self.playicon)
     self.player.pause()</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The method, <code class="literal">toggle_play_pause</code>, changes the icon alternatively between a play and pause icon. It also calls the <code class="literal">play</code> and <code class="literal">pause</code> methods of the <code class="literal">player</code> class to play and pause the songs.</li></ul></div></div><div class="section" title="Step 4 – add file dialog"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec56"/>Step 4 – add file dialog</h3></div></div></div><p>The Add File button opens <code class="literal">tkFileDialog</code>, which associates the file opened with a class attribute named <code class="literal">currentTrack</code>, as follows:</p><div class="informalexample"><pre class="programlisting">def add_file(self):
    tfile = tkFileDialog.askopenfilename(filetypes=[('All supported', '.mp3 .wav .ogg'), ('All files', '*.*')])
   self.currentTrack = tfile</pre></div></div><div class="section" title="Step 5 – creating the Player class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec57"/>Step 5 – creating the Player class</h3></div></div></div><p>Now, let's code the basic <code class="literal">player </code>class. For now, we will only add play and pause functionality to the class. The code for our <code class="literal">player</code> class is built upon the pyglet library.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>Pygle<a id="id418" class="indexterm"/>t provides an object-oriented interface for developing rich media applications, such as games, audio and video tools, and others. It is a popular choice with Python programmers for media manipulation, because it has no external dependencies, supports a large number of formats, and is available on all major operating systems.</p></div></div><p>Before we proceed further, you might want to look at the API documentation of the pyglet player available at:</p><p>
<a class="ulink" href="http://www.pyglet.org/doc/api/pyglet.media.Player-class.html">http://www.pyglet.org/doc/api/pyglet.media.Player-class.html</a>
</p><p>The documentation tells us that we can play an audio file using the following code:</p><div class="informalexample"><pre class="programlisting">myplayer= pyglet.media.Player()
source = pyglet.media.load(&lt;&lt;audio file to be played&gt;&gt;)
myplayer.queue(source)
myplayer.play()
pyglet.app.run()</pre></div><p>We will use this code snippet to play the audio file. Accordingly, the code for our <code class="literal">Player</code> class is as follows(see <span class="emphasis"><em>code 5.01 player.py</em></span>):</p><div class="informalexample"><pre class="programlisting">import pyglet
from threading import Thread
class Player():
   parent = None
   def play_media(self):
     try:
        self.myplayer= pyglet.media.Player()
        self.source = pyglet.media.load(self.parent.currentTrack)
        self.myplayer.queue(self.source)
        self.myplayer.play()
        pyglet.app.run()
     except:
        pass

   def start_play_thread(self):
     player_thread = Thread(target=self.play_media)
     player_thread.start()

   def pause(self):
     try:
        self.myplayer.pause()
        self.paused = True
     except: pass</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We<a id="id419" class="indexterm"/> create a class named <code class="literal">Player</code> and initialize its parent class as <code class="literal">None</code>. Recall that in our <code class="literal">GUI</code> class, we have defined a reference <code class="literal">player.parent = self</code>, so as to be able to assess our <code class="literal">GUI</code> class properties from within our <code class="literal">player</code> class.</li><li class="listitem" style="list-style-type: disc">We then define our <code class="literal">play_media</code> method, which is responsible for actually playing the sound. The method accesses the <code class="literal">currentTrack</code> attribute of the <code class="literal">GUI</code> class and tries to play it.</li><li class="listitem" style="list-style-type: disc">Although this code can play audio files, pyglet requires running its own event loop to play the audio. This means it will return control to our GUI mainloop only after it has completed playing the entire sound, while freezing the Tkinter mainloop if run directly.</li><li class="listitem" style="list-style-type: disc">We, therefore, need to call the play method in a separate thread. We use the threading module to define a new method named <code class="literal">start_play_thread</code>, which simply calls our <code class="literal">play_media</code> method in a separate thread, thus preventing freezing out of GUI.</li><li class="listitem" style="list-style-type: disc">Lastly, we define the pause method, which pauses or stops the audio file being currently played. Pyglet does not differentiate between <a id="id420" class="indexterm"/>pause and stop functions. Therefore, we are typically stopping the audio using the pause command.</li></ul></div></div><div class="section" title="Step 6 – running the application"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec58"/>Step 6 – running the application</h3></div></div></div><p>We finally run the application by creating an object out of our <code class="literal">GUI</code> class. Because this <code class="literal">GUI</code> class requires an object from the <code class="literal">player</code> class, we also instantiate a player object and pass it as an argument to our <code class="literal">GUI</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">if __name__ == '__main__':
   playerobj = player.Player()
   app = GUI(playerobj)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The last section of code creates an object from the <code class="literal">player</code> class that we are yet to define. The <code class="literal">player</code> class will take care of all audio manipulation using pyglet.</li><li class="listitem" style="list-style-type: disc">We first create an object out of the <code class="literal">player</code> class and pass it as an argument to the <code class="literal">__init__</code> method of our <code class="literal">GUI</code> class. This ensures that all attributes and methods of the <code class="literal">player</code> class are available within the <code class="literal">GUI</code> class using the syntax <code class="literal">player.attribute</code> and <code class="literal">player.method()</code>.</li></ul></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec103"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes our first iteration.</p><p>In this section, we created a <code class="literal">GUI</code> class, added a button that toggles between play and pause. We added another button to add a file using <code class="literal">tkFileDialog</code>.</p><p>We also created a <code class="literal">Player</code> class, which uses pyglet for playing audio files. The files are played in a separate thread to avoid freezing of the Tkinter mainloop while the audio is playing.</p><p>Finally, we ran our application by first creating a player object and passing it as an argument to another object created by our <code class="literal">GUI</code> class.</p><p>We now<a id="id421" class="indexterm"/> have a functional audio player, where you can load a single file using <code class="literal">tkFileDialog</code>. After loading, you can press the Play button and the audio file starts playing. You can stop the audio by clicking the Play button, which toggles alternatively between play and pause functions.</p></div></div>
<div class="section" title="Adding a playlist"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Adding a playlist</h1></div></div></div><p>We now have the capability to play a single audio file, but what is an audio player if it does not allow for a playlist?</p><p>Let's add a<a id="id422" class="indexterm"/> playlist feature to our player. Once a playlist is added, we accordingly need to provide buttons to add files to the playlist, delete files from <a id="id423" class="indexterm"/>it, and add all supported files from a chosen directory and the ability to delete all items in the list at once.</p><p>At the end of this iteration, we will have a player that looks like the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_05_03.jpg" alt="Adding a playlist"/></div><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec104"/>Prepare for Lift Off </h2></div></div></div><p>We will use Tkinter Listbox widget to provide a playlist. Let's look at some of the key features of the Listbox widget:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You create a Listbox like you create any other widget as follows:<div class="informalexample"><pre class="programlisting">mylist = ListBox(parent, **configurable options)</pre></div></li><li class="listitem" style="list-style-type: disc">When you initially create the Listbox widget, it is empty. To insert one or more lines of text into the Listbox, you use the <code class="literal">insert()</code> method, which takes two arguments: an index of the position where the text is to be inserted and the actual string to be inserted as follows:<div class="informalexample"><pre class="programlisting">mylist.insert(0, "First Item")
mylist.insert(END, "Last Item")</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">curselection()</code> method returns the index of all items selected in the list, and the <code class="literal">get()</code> method returns the list item for a given index as follows:<div class="informalexample"><pre class="programlisting">mylist.curselection() # returns a tuple of all selected items
mylist.curselection()[0] # returns first selected item
mylist.get(1) # returns second item from the list
mylist.get(0, END) # returns all items from the list</pre></div></li><li class="listitem" style="list-style-type: disc">In addition, <a id="id424" class="indexterm"/>the Listbox widget has several other configurable options. For a complete Listbox widget reference,<a id="id425" class="indexterm"/> type the following into your Python interactive shell:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import Tkinter</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; help(Tkinter.Listbox)</strong></span>
</pre></div></li></ul></div></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec105"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – adding an empty Listbox widget"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec59"/>Step 1 – adding an empty Listbox widget</h3></div></div></div><p>Let's first add an empty Listbox widget, as follows (see <span class="emphasis"><em>code 5.02 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def create_list_frame(self):
    list_frame = Frame(self.root)
    self.Listbox = Listbox(list_frame, activestyle='none', cursor='hand2', bg='#1C3D7D', fg='#A0B9E9', selectmode=EXTENDED, width=60, height =10)
   self.Listbox.pack(side=LEFT, fill=BOTH, expand=1)
   self.Listbox.bind("&lt;Double-Button-1&gt;", self.identify_track_to_play)
   scrollbar = Scrollbar(list_frame)
   scrollbar.pack(side=RIGHT, fill=BOTH)
   self.Listbox.config(yscrollcommand=scrollbar.set)
   scrollbar.config(command=self.Listbox.yview)
   list_frame.grid(row=4, padx=5)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We create a new frame, <code class="literal">list_frame</code>, to hold our List widget.</li><li class="listitem" style="list-style-type: disc">We create a Listbox widget within this frame and set some styling options, such as background color, foreground color, and mouse cursor. The styling of active line is set using the Listbox option, <code class="literal">activestyle</code>, which means that we do not want to underline the selected item.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">selectmode </code>option is configured as extended. See the following information box for a list of choices available and their meaning.<a id="id426" class="indexterm"/> We will use the <code class="literal">EXTENDED </code>select mode, because even though a single file can be played at once, we want to allow the user to select more than one file together at once for deletion.</li><li class="listitem" style="list-style-type: disc">We add a scrollbar to the Listbox, similar to the way we did in our text editor project.</li><li class="listitem" style="list-style-type: disc">We <a id="id427" class="indexterm"/>bind the double-click of mouse to another method named <code class="literal">identify_track_to_play</code>.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>The Listbox widget offers four selection modes using the <code class="literal">selectmode</code> option as follows:</p><p>
<code class="literal">SINGLE</code>: It allows only a single row to be selected at one time.</p><p>
<code class="literal">BROWSE</code> (Default mode): It is similar to <code class="literal">SINGLE</code> but allows for moving the selection by dragging the mouse.</p><p>
<code class="literal">MULTIPLE</code>: It allows for multiple selections by clicking on items one at a time.</p><p>
<code class="literal">EXTENDED</code>: It allows for selection of multiple range of items using <span class="emphasis"><em>Shift</em></span> and <span class="emphasis"><em>Control</em></span> keys.</p></div></div></div><div class="section" title="Step 2 – identify track to play"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec60"/>Step 2 – identify track to play</h3></div></div></div><p>Our program was simpler in the first iteration, where we had only song to play. However, given a playlist, now we have to identify which song needs to be played from the given list.</p><p>The rule is simple. If a user clicks on a given song, it becomes our selected track. If the user has made no selection and hits the Play button, the first song in the playlist should be played. Put in code this would look like as follows (see <span class="emphasis"><em>code 5.02 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def identify_track_to_play(self, event=None):
   try:
     indx = int(self.Listbox.curselection()[0])
     if self.Listbox.get(indx) == "":
        self.del_selected()
     except:
        indx = 0
        self.currentTrack =self.Listbox.get(indx)
<code class="literal">     self.player.start_play_thread()</code>
</pre></div></div><div class="section" title="Step 3 – adding items to the list"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec61"/>Step 3 – adding items to the list</h3></div></div></div><p>Now that we have a Listbox and we can play any item by double-clicking on it, let's add methods to populate and remove items from the list.</p><p>However,<a id="id428" class="indexterm"/> even before we do any modifications to our list, let's first define an empty list named <code class="literal">alltracks </code>to keep track of all items in the playlist. We will need to update this list after any changes are done to the list, as follows(see <span class="emphasis"><em>code 5.02 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">alltracks = []</pre></div><p>We had already <a id="id429" class="indexterm"/>created an <code class="literal">add file</code> method in the last section. Let's modify it slightly so that the file selected does not become the selected track, instead it gets added to the playlist, as follows (see <span class="emphasis"><em>code 5.02 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def add_file(self):
    filename = tkFileDialog.askopenfilename(filetypes=[('All supported', '.mp3 .wav'), ('.mp3 files', '.mp3'), ('.wav files', '.wav')])
    if filename:
      self.Listbox.insert(END, filename)
    self.alltracks = list(self.Listbox.get(0, END))</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The file selected through <code class="literal">tkFileDialog </code>is inserted at the end of the list box, and our attribute, <code class="literal">alltracks</code>, is updated with all elements in the Listbox widget.</li><li class="listitem" style="list-style-type: disc">Notice that the <code class="literal">get()</code> method returns a tuple of all items. Because tuples are immutable, we explicitly convert the tuple into a list by using the <code class="literal">list</code> type declaration.</li></ul></div></div><div class="section" title="Step 4 – deleting items from the list"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec62"/>Step 4 – deleting items from the list</h3></div></div></div><p>Let's add a new button to delete selected files. This is added to our existing <code class="literal">create_bottom_frame</code> method, as follows (see <span class="emphasis"><em>code 5.02 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">del_selectedicon = PhotoImage(file='../icons/del_selected.gif')
del_selectedbtn=Button(bottomframe, image=del_selectedicon, padx=0, borderwidth=0, text='Delete', command=self.del_selected)
del_selectedbtn.image = del_selectedicon
del_selectedbtn.grid(row=5, column=2)</pre></div><p>This<a id="id430" class="indexterm"/> button has a command callback to a method named <code class="literal">del_selected</code>. The code for <code class="literal">del_selected</code> is as follows:</p><div class="informalexample"><pre class="programlisting">def del_selected(self):
    whilelen(self.Listbox.curselection())&gt;0:
      self.Listbox.delete(self.Listbox.curselection()[0])
    self.alltracks = list(self.Listbox.get(0, END))</pre></div><p>As usual, we <a id="id431" class="indexterm"/>update our <code class="literal">alltracks</code> list after deletion of items from the Listbox widget.</p><p>Now, you can make a selection from your list box and click on the Delete button to remove all selected items from the list box.</p></div><div class="section" title="Step 5 – adding multiple items to the list"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec63"/>Step 5 – adding multiple items to the list </h3></div></div></div><p>Adding individual audio files to a playlist can become tedious. We want to allow the users to select a directory, and our list should get populated with all supported media formats from that directory.</p><p>We, therefore, add a new button to allow for adding all media files from a given directory. This is also added to our existing <code class="literal">create_bottom_frame</code> method, as follows (see <span class="emphasis"><em>code 5.02 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">add_diricon = PhotoImage(file='../icons/add_dir.gif')
add_dirbtn=Button(bottomframe, image=add_diricon, borderwidth=0, padx=0, text='Add Dir', command=self.add_dir)
add_dirbtn.image = add_diricon
add_dirbtn.grid(row=5, column=3)</pre></div><p>We need to use the <code class="literal">os</code> module to grab all supported types. Let's first import the <code class="literal">os</code> module into the current namespace, as follows:</p><div class="informalexample"><pre class="programlisting">import os</pre></div><p>Now<a id="id432" class="indexterm"/> the associated command callback<a id="id433" class="indexterm"/> is as follows:</p><div class="informalexample"><pre class="programlisting">  def add_dir(self):
     path = tkFileDialog.askdirectory()
     if path:
        tfileList = []
        for (dirpath, dirnames, filenames) in os.walk(path):
           for tfile in filenames:
              if tfile.endswith(".mp3") or tfile.endswith(".wav") or tfile.endswith(".ogg"):
                 tfileList.append(dirpath+"/"+tfile)
        for item in tfileList:
           self.listbox.insert(END, item)
        self.alltracks = list(self.listbox.get(0, END))</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">add_dir</code> method first creates a temporary list, <code class="literal">tfilelist</code>.</li><li class="listitem" style="list-style-type: disc">It then iterates through all filenames fetched through the <code class="literal">tkFileDialog.askdirectory()</code> method. If it encounters a supported file format, it appends the file to the temporary list.</li><li class="listitem" style="list-style-type: disc">It then iterates through all items in the <code class="literal">tfilelist</code>, inserting them into our Listbox.</li><li class="listitem" style="list-style-type: disc">It finally updates our <code class="literal">alltracks</code> attribute with all items in the newly modified list.</li></ul></div></div><div class="section" title="Step 6 – deleting all items"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec64"/>Step 6 – deleting all items</h3></div></div></div><p>Finally, we add a button to delete all items from the playlist. The associated button is added to the <code class="literal">create_bottom_frame</code> method,<a id="id434" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">delallicon = PhotoImage(file='../icons/delall.gif')
delallbtn = Button(bottomframe, image=delallicon, borderwidth=0, padx=0, text='Clear All', command=self.clear_list)
delallbtn.image = delallicon
delallbtn.grid(row=5, column=4)</pre></div><p>Now its associated command callback is as follows:</p><div class="informalexample"><pre class="programlisting">def clear_list(self):
    self.Listbox.delete(0, END)
    self.alltracks =list(self.Listbox.get(0, END))</pre></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec106"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes<a id="id435" class="indexterm"/> our second iteration.</p><p>In this iteration, we saw how to work with the Listbox widget. In particular, we learned to add  Listbox, add items to he Listbox widget, select a particular item from the Listbox widget, and<a id="id436" class="indexterm"/> delete one or more items from it.</p><p>You now have a playlist where you can add and delete items.</p><p>The  Listbox widget has an event binding for double-click of the mouse button on an item. This associated event callback selects the clicked item, and sends it across to be played on a separate thread.</p><p>In the process, we saw a list of common operations done on the Listbox widget.</p></div></div>
<div class="section" title="Adding more controls to the player"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Adding more controls to the player</h1></div></div></div><p>Now that we have a playlist, we need to ensure that songs play in a queue. We also need to add a <a id="id437" class="indexterm"/>few more controls typically found in audio players, such as Next, Previous, Fast Forward, Rewind, and Mute buttons. We also need to provide a method to change the volume of playback.</p><p>At the end of this iteration, our player would have the following additional controls in the top-button frame:</p><div class="mediaobject"><img src="graphics/7941_05_04.jpg" alt="Adding more controls to the player"/></div><p>The pyglet API documentation provides simple interfaces for all these controls. For your reference, the documentation is available at:</p><p>
<a class="ulink" href="http://www.pyglet.org/doc/api/pyglet.media.Player-class.html">http://www.pyglet.org/doc/api/pyglet.media.Player-class.html</a>
</p><p>Let's begin by <a id="id438" class="indexterm"/>adding methods to handle these in our <code class="literal">Player</code> class.</p><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec107"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – fast forwarding a track"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec65"/>Step 1 – fast forwarding a track</h3></div></div></div><p>We can fast forward a track as follows (see <span class="emphasis"><em>code 5.03 player.py</em></span>):</p><div class="informalexample"><pre class="programlisting">FWDREWNDTIME = 20
#time to seek ahead or backwards in seconds
def fast_fwd(self):
   try:
     current_time = self.myplayer.time
     self.myplayer.seek(current_time+FWDREWNDTIME)
   except:pass</pre></div></div><div class="section" title="Step 2 – rewinding a track"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec66"/>Step 2 – rewinding a track</h3></div></div></div><p>We can rewind a track as follows:</p><div class="informalexample"><pre class="programlisting">def rewind(self):
   try:
     current_time = self.myplayer.time
     self.myplayer.seek(current_time-FWDREWNDTIME)
   except:pass</pre></div></div><div class="section" title="Step 3 – pausing a track"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec67"/>Step 3 – pausing a track</h3></div></div></div><p>We can pause a track as follows:</p><div class="informalexample"><pre class="programlisting">def pause(self):
   try:
     self.myplayer.pause()
     self.paused = True
   except: pass</pre></div></div><div class="section" title="Step 4 – setting the volume of playback"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec68"/>Step 4 – setting the volume of playback</h3></div></div></div><p>We can set the volume of playback as follows:</p><div class="informalexample"><pre class="programlisting">def set_vol(self, vol):
   try:
     self.myplayer.volume = vol
   except:pass</pre></div></div><div class="section" title="Step 5 – muting and unmuting a track"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec69"/>Step 5 – muting and unmuting a track</h3></div></div></div><p>We can mute and unmute a track as follows:</p><div class="informalexample"><pre class="programlisting">def mute(self):
   try:
     self.myplayer.volume = 0.0
     self.parent.volscale.set(0.0)
   except:pass

def unmute(self):
   self.set_vol(self.vol)
   self.parent.volscale.set(0.3)</pre></div><p>We will not discuss the code here in detail. For coding these functionalities, we have used the API documentation for pyglet available at:</p><p>
<a class="ulink" href="http://www.pyglet.org/doc/api/pyglet.media.Player-class.html">http://www.pyglet.org/doc/api/pyglet.media.Player-class.html</a>
</p><p>You can also access this documentation for the pyglet media player class by<a id="id439" class="indexterm"/> typing these two lines in your Python interactive shell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import pyglet</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; help (pyglet.media.Player)</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>We have been indiscriminately using try/except blocks in this program to hide all errors emanating from the <code class="literal">player</code> class.</p><p>This might not be the best programming practice, but we ignore all <code class="literal">player</code> class errors so as not to deviate from our discussion on Tkinter.</p><p>In a normal case, you would handle all different kind of errors using different except blocks.</p></div></div></div><div class="section" title="Step 6 – adding the control buttons"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec70"/>Step 6 – adding the control buttons</h3></div></div></div><p>Now that we have the backend code to handle events, such as fast forward, rewind, volume change, mute, and others, it is simply time to add buttons for each of these controls to our <code class="literal">GUI</code> class. We link each of the buttons to its respective command callback.</p><p>So, we modify our <code class="literal">create_button_frame</code> widget to add buttons for these new controls.</p><p>We have added hundreds of buttons so far in our previous project. So, we do not reproduce the entire code here for sake of brevity. Rather, we simply show the implementation of the Previous Track button as one of its sample, and how it calls the associated command callback to the <code class="literal">previous()</code> method of the <code class="literal">player</code> class as follows (see <span class="emphasis"><em>code 5.03 GUI.py</em></span>):</p><div class="informalexample"><pre class="programlisting">previcon = PhotoImage(file='../icons/previous.gif')
prevbtn=Button(buttonframe, image=previcon, borderwidth=0, padx=0, command=self.prev_track)
prevbtn.image = previcon
prevbtn.grid(row=3, column=1, sticky='w')</pre></div></div><div class="section" title="Step 7 – changing volume with the ttk Scale widget"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec71"/>Step 7 – changing volume with the ttk Scale widget</h3></div></div></div><p>In addition<a id="id440" class="indexterm"/> to these buttons, we also use the ttk Scale widget to allow the users to change the volume. The native Scale widget implementation in core Tkinter looks rather old fashioned and we instead settle for the ttk Scale widget, which has same set of configurable options as the core Tkinter Scale widget, as follows:</p><div class="informalexample"><pre class="programlisting">self.volscale = ttk.Scale(buttonframe, from_=0.0, to =1.0 , command=self.vol_update)
self.volscale.set(0.6)
self.volscale.grid(row=3, column=7, padx=5)</pre></div><p>As per the pyglet documentation, the volume of playback must be specified as a float ranging from <code class="literal">0.0</code> (no sound) to <code class="literal">1.0</code> (maximum sound), and our <code class="literal">updateVolume</code>  method <a id="id441" class="indexterm"/>uses this as the basis.</p><p>This has an attached callback to another method, <code class="literal">vol_update</code>, in the <code class="literal">GUI</code> class, which simply delegates the task to the <code class="literal">player</code> method to handle volume changes.</p><div class="informalexample"><pre class="programlisting">def vol_update(self, e):
    vol = float(e)
    self.player.set_vol(vol)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The pyglet <code class="literal">Player</code> class expects volume to be specified as a float, but the command here receives the new value of scale as a string. We, therefore, first convert it to float, and then pass it to the <code class="literal">set_vol</code> method of the <code class="literal">player</code> class.</li></ul></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec108"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes the second iteration where we added playback control features to our program.</p><p>This section was more about sticking to the API documentation of pyglet and trusting it as a blackbox to <a id="id442" class="indexterm"/>deliver what it says: namely, to be able to play and control audio.</p><p>We also saw how to use the ttk Scale widget in a practical demonstration of building our volume control.</p></div><div class="section" title="Classified Intel"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec109"/>Classified Intel</h2></div></div></div><p>When it came to choosing an external implementation (as we did for audio API here), we first searched through the Python Standard Library at:</p><p>
<a class="ulink" href="http://docs.python.org/library/">http://docs.python.org/library/</a>
</p><p>Because the Standard Library does not have a suitable package for us, we turned our attention to Python Package Index to see if there exists another high-level audio interface implementation. The Python package index lives at:</p><p>
<a class="ulink" href="http://pypi.python.org/">http://pypi.python.org/</a>
</p><p>Fortunately, we came across several audio packages. After comparing the packages against our needs and seeing how active its community was, we settled for pyglet. The same program could have been implemented with several other packages, though with varying levels of complexity.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>In general, the lower you go down the protocol stack, the more complex your programs would get.</p><p>However, at lower layers of the protocol, you get a finer control over the implementation at the cost of increasing learning curves.</p><p>For instance, because the pyglet <code class="literal">player</code> class does not differentiate between pause and stop functionality, we had to altogether do away with the pause functionality and settle for a simpler implementation where pause and stop mean the same.</p><p>For a finer control of audio source, we will have to go deeper into the protocol stacks, which we will avoid for now, so as not to digress from our topic.</p></div></div></div></div>
<div class="section" title="Adding the top display console"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Adding the top display console</h1></div></div></div><p>In this iteration, we will add a<a id="id443" class="indexterm"/> display console at<a id="id444" class="indexterm"/> the top of our player. This console will display the time counter for our music player. It will also display the currently played track.</p><p>We will also code a progress bar, which will show the progress of the current track being played.</p><p>At the end of<a id="id445" class="indexterm"/> this iteration, the top frame of our player will look like the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_05_05.jpg" alt="Adding the top display console"/></div><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec110"/>Prepare for Lift Off</h2></div></div></div><p>We need to <a id="id446" class="indexterm"/>precisely place our timer clock text and the currently playing track text on the top of an image.</p><p>Recall that the Canvas widget allows for a deep nested placement of other widgets inside it with precise coordinate-based control. This is all that we want to display the console. We will, therefore, use the Canvas widget as the container for our console.</p></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec111"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – creating the top console and progress bar"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec72"/>Step 1 – creating the top console and progress bar</h3></div></div></div><p>We accordingly define a new method named <code class="literal">create_console_frame </code>in our <code class="literal">GUI</code> class, which holds our image, clock text, and currently playing text for creating the top console and progress bar as follows(see <span class="emphasis"><em>code 5.04 GUI.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def create_console_frame(self):
   consoleframe = Frame(self.root)
   self.canvas = Canvas(consoleframe, width=370, height=90)
   self.canvas.grid(row=1)
   photo = PhotoImage(file='../icons/glassframe.gif')
   self.canvas.image = photo
   self.console = self.canvas.create_image(0, 10, anchor=NW, image=photo)
   self.clock = self.canvas.create_text(32, 34, anchor=W, fill='#CBE4F6', font="DS-Digital 20", text="00:00")
   self.songname = self.canvas.create_text(115, 37, anchor=W, fill='#9CEDAC', font="Verdana 10", text='\"Currently playing: none [00.00] \"')
   self.progressBar = ttk.Progressbar(consoleframe, length =1, mode="determinate")
   self.progressBar.grid(row=2, columnspan=10, sticky='ew', padx=5)
   consoleframe.grid(row=1, pady=1, padx=0)</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id447" class="indexterm"/> code defines a new frame, <code class="literal">consoleframe</code>, and adds a Canvas widget of desired height and width to the frame.</li><li class="listitem" style="list-style-type: disc">We use <code class="literal">canvas.create_image </code>to add the background image. The background image is provided in the <code class="literal">icons</code> folder.</li><li class="listitem" style="list-style-type: disc">We use <code class="literal">canvas.create_text </code>to add one text for displaying the clock and another text to display the currently playing track. The desired location of each of these texts is specified using x, y coordinates.</li><li class="listitem" style="list-style-type: disc">We <a id="id448" class="indexterm"/>also specify a special font for displaying our clock. If this font is installed on a computer, the text is displayed in the specified font. If the font is not installed, display occurs in the default font.</li><li class="listitem" style="list-style-type: disc">Finally, we display a ttkProgressbar widget, which shall be used to display the progress of track as it plays. We use the determinate mode of the progress bar, because we want to display the completion of track relative to its overall length. For now, the overall length of track is initialized to <code class="literal">1</code>. It will be updated as the song starts to play.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>A ttkProgressbar widget displays the status of progress of an operation. The progress bar can run in two modes:</p><p>
<code class="literal">Determinate</code>: This mode shows the amount of work completed relative to the total amount of work.</p><p>
<code class="literal">Indeterminate</code>: This provides an animated show of the progress, but does not show the relative amount of work completed.</p></div></div></div><div class="section" title="Step 2 – getting the total duration of a track"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec73"/>Step 2 – getting the total duration of a track </h3></div></div></div><p>The contents of the display panel and the progress on the progress bar need to be updated <a id="id449" class="indexterm"/>every time a new song starts playing. In our current code, a new song starts playing when a user clicks on the Play button or double-clicks on a particular track, or when the Next or Previous button is clicked.</p><p>Before we<a id="id450" class="indexterm"/> update the clock or the progress bar, we need to know two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Total length of current track</li><li class="listitem" style="list-style-type: disc">Duration for which a current track has been played</li></ul></div><p>Fortunately, pyglet provides API calls to determine both these things. As per its documentation, the total length of a song currently playing can be obtained from the code: <code class="literal">source.duration</code>.</p><p>Similarly, the current duration of play can be obtained using <code class="literal">myplayer.time</code>.</p><p>Let's, therefore, define two new methods in our <code class="literal">Player</code> class to get the value of these two variables, as follows (<span class="emphasis"><em>code 5.04player.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def song_len(self):
   try:
     self.song_length = self.source.duration
   except:
     self.song_length = 0
   return self.song_length
def current_time(self):
   try:
     current_time = self.myplayer.time
   except:
     current_time = 0
   return current_time</pre></div><p>Now, we slightly modify our <code class="literal">start_play_thread </code>method<a id="id451" class="indexterm"/> to call our <code class="literal">song_len </code>method<a id="id452" class="indexterm"/> so that our <code class="literal">song_length </code>attribute is updated with the value of the song length.</p><div class="informalexample"><pre class="programlisting">def start_play_thread(self):
   player_thread = Thread(target=self.play_media)
   player_thread.start()
<span class="strong"><strong>   time.sleep(1)</strong></span>
<span class="strong"><strong>   self.song_len()</strong></span>
</pre></div><p>Notice that we made the method to sleep for one second, so as to enable<a id="id453" class="indexterm"/> to length metadata to populate. If we do not make it sleep for a second, the code would execute so fast that it would end even before the <code class="literal">song_length</code> variable is updated by pyglet. </p><p>Now, we have access to the total length and current duration of play. We now <a id="id454" class="indexterm"/>want to update the current track every time a new track is played.</p></div><div class="section" title="Step 3 – updating console at launch of play"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec74"/>Step 3 – updating console at launch of play</h3></div></div></div><p>A new track is played when a user hits the Play button, or when he or she double-clicks a particular song, or when he or she clicks the Next or Previous button.</p><p>If you look at the code from previous iteration (<span class="emphasis"><em>code 5.03 GUI.py</em></span>), all these methods call the <code class="literal">self.player.start_play_thread()</code>functionality to start the playback. However, now we need to update the console display every time a new player thread is started.</p><p>We, therefore, need to refactor our code. For one, we will route all calls to <code class="literal">player.start_play_thread()</code>through a single method, which will update the display as the player thread starts.</p></div><div class="section" title="Step 4 – updating timer clock and progress bar at regular intervals"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec75"/>Step 4 – updating timer clock and progress bar at regular intervals</h3></div></div></div><p>We, therefore, define a new method named <code class="literal">launch_play</code>,<code class="literal"> </code>and replace all instances of <code class="literal">player.start_play_thread()</code>from previous code to now call our <code class="literal">launch_play </code>method, as follows (see <span class="emphasis"><em>Code 5.04.py main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def launch_play(self):
   try:
     self.player.pause()
   except:
     pass
   self.player.start_play_thread()
   song_lenminute = str(int(self.player.song_length/60))
   song_lenseconds = str (int(self.player.song_length%60))
   filename = self.currentTrack.split('/')[-1] + '\n ['+ song_lenminute+':'+song_lenseconds+']'
<span class="strong"><strong>   self.canvas.itemconfig(self.songname, text=filename)</strong></span>
<span class="strong"><strong>   self.progressBar["maximum"]=self.player.song_length</strong></span>
<span class="strong"><strong>   self.update_clock_and_progressbar()</strong></span>
</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code <a id="id455" class="indexterm"/>first tries to stop any other track that might be playing at that time, because we don't want multiple tracks playing at a given time.</li><li class="listitem" style="list-style-type: disc">It then starts to play the next track in a separate thread. The thread method automatically updates the song length, and now we have access to the song length in the variable <code class="literal">self.player.song_len</code>.</li><li class="listitem" style="list-style-type: disc">The next two lines break the song length into equivalent minutes and seconds.</li><li class="listitem" style="list-style-type: disc">The next<a id="id456" class="indexterm"/> line breaks the file name and gets hold of the song name from the complete path. It then appends the time calculated in minutes and seconds to the file name.</li><li class="listitem" style="list-style-type: disc">We set the <code class="literal">maximum</code> value for our progress bar, which is a floating point number specifying the maximum value of the progress bar. For viewing all configurable options for ttk Progressbar, enter the following into your Python interactive console:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import ttk</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; help(ttk.Progressbar)</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">The next line uses <code class="literal">canvas.itemconfig </code>to update the song name and song length in the display console.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>Just like we use <code class="literal">config</code> to change value of widget related options, the Canvas widget uses <code class="literal">itemconfig</code> to change the options for individual items within the canvas.</p><p>The format for <code class="literal">itemconfig</code> is as follows: <code class="literal">itemconfig(itemid, **options)</code>.</p></div></div></li></ul></div><p>In this step, we will learn to update timer clock and progress bar at regular intervals. Although song name and song length are to be updated just once for a given song, the play duration and progress bar need to be updated<a id="id457" class="indexterm"/> at small intervals. We, therefore, handle it in a separate method named <code class="literal">update_clock_and_progressbar()</code>.</p><p>We want to display time in the format you normally find in a digital clock. <a id="id458" class="indexterm"/>We accordingly define a string format named <code class="literal">timepattern</code>, as follows: </p><p>
<code class="literal">timepattern = '{0:02d}:{1:02d}'</code>.</p><p>Now, let us turn our attention to updating the display clock and the progress bar. We have already made a call to <code class="literal">update_clock_and_progressbar()</code>which is supposed to take care of this work. Let's now code this method, as follows(see <span class="emphasis"><em>Code 5.04.py main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def update_clock_and_progressbar(self):
   current_time = self.player.current_time()
   song_len = (self.player.song_len())
   currtimeminutes = int(current_time/60)
   currtimeseconds = int(current_time%60)
   currtimestrng = self.timepattern.format(currtimeminutes, currtimeseconds)
   self.canvas.itemconfig(self.clock, text= currtimestrng)
   self.progressBar["value"] = current_time
<span class="strong"><strong>   self.root.update()</strong></span>
   if current_time == song_len: #track is over
     self.canvas.itemconfig(self.clock, text= '00:00')
     self.timer=[0,0]
     self.progressBar["value"] = 0
   else:
     <span class="strong"><strong>self.canvas.after(1000, self.update_clock_and_progressbar)</strong></span>
</pre></div><p>This code runs itself every 1000 ms, forces a root update, and changes the time and progress bar value. To keep running regularly, it calls back itself after every 1000 ms.</p><p>When a track is over, it resets the values of clock and progress bar to zero, and<a id="id459" class="indexterm"/> exits out of the update loop.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>We used the <code class="literal">canvas.after</code> method to call the same method at intervals of one second. Thus, this method would get to be called at one second interval throughout playing of the current track. We also kept a condition to break out of the loop when the current track ended playing.</p></div></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec112"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes<a id="id460" class="indexterm"/> this iteration. In this iteration, we built a functional display console and a progress bar to display time and information about the current track.</p><p>We started by creating a blank canvas in the top area of our root window. We then added an image that resembles a display console. We then used <code class="literal">canvas.create_text</code> to precisely position the timer clock, name of currently playing track, and the total track length in the console.</p><p>We also created a ttk progress bar.</p><p>We then calculated the track length using the pyglet API. Next, we made all calls to play the track to be routed through an intermediate method which updated the console with information about the currently playing track.</p><p>We also added a method to update the clock and progress bar at regular intervals.</p></div></div>
<div class="section" title="Looping over tracks"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Looping over tracks</h1></div></div></div><p>So now we have a functional player. It though lacks a vital feature. There is no tracking over loop. That means every time a user listens to a track, the player stops after playing that track. It does not<a id="id461" class="indexterm"/> jump to the next track in our playlist.</p><p>Let's provide some<a id="id462" class="indexterm"/> radio buttons to let the user choose the looping structure. By the end of this iteration, we will add the following to our player:</p><div class="mediaobject"><img src="graphics/7941_05_06.jpg" alt="Looping over tracks"/></div><p>In essence, our player<a id="id463" class="indexterm"/> should provide choice amongst:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>No loop</strong></span>: Playing a track and ending there</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Loop Current</strong></span>: Playing a single track repeatedly</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Loop All</strong></span>: Playing through the entire playlist, one after another</li></ul></div><p>Let's code this<a id="id464" class="indexterm"/> feature.</p><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec113"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – creating the radio buttons"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec76"/>Step 1 – creating the radio buttons</h3></div></div></div><p>The corresponding code for creating radio buttons in the <code class="literal">GUI</code> class is as follows (see <span class="emphasis"><em>Code 5.05 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">#radio buttons added to create_bottom_frame
self.loopv = IntVar()
self.loopv.set(3)
for txt, val in self.loopchoices:
   Radiobutton(bottomframe, text=txt, variable=self.loopv, value=val).grid(row=5, column=4+val, pady=3)</pre></div></div><div class="section" title="Step 2 – on end of song callback"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec77"/>Step 2 – on end of song callback</h3></div></div></div><p>Let's look at the player end logic first when a song ends. We need a way to call a method once a song has completed playing. Luckily, the pyglet player allows for an <code class="literal">on_eos</code> (on end of song) callback.</p><p>We first modify our existing <code class="literal">play_media </code> method in the <code class="literal">player</code> class to include this callback.(See <span class="emphasis"><em>Code 5.05  player.py</em></span>)</p><div class="informalexample"><pre class="programlisting">self.myplayer.push_handlers(on_eos=self.what_next)</pre></div><p>This callback is executed on end of a given song. We add the callback to a method named <code class="literal">what_next</code>.</p></div><div class="section" title="Step 3 – what next?"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec78"/>Step 3 – what next?</h3></div></div></div><p>This <code class="literal">what_next </code>method<a id="id465" class="indexterm"/> essentially looks for the selected choice on looping and accordingly takes some action. The code for <code class="literal">what_next</code> is as follows:</p><div class="informalexample"><pre class="programlisting">def what_next(self):
   if self.stopped:
     self.stopped = False
     return None
   if self.parent.loopv.get() == 1:
     # No Loop
     return None
   if self.parent.loopv.get() == 2:
     # Loop current
     self.parent.launch_play()
   if self.parent.loopv.get() == 3:
     # Loop All
     self.fetch_next_track()</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">on_eos </code>callback is also called just in case a track is stopped in the middle. That means that if a stop action occurs, we don't want to do anything next. We, therefore, break out of the method by calling<a id="id466" class="indexterm"/> a blank return.</li><li class="listitem" style="list-style-type: disc">The code then checks the value of <code class="literal">self.parent.selectedloopchoice</code>.</li><li class="listitem" style="list-style-type: disc">If the selected loop value is <code class="literal">1</code>(<span class="strong"><strong>No Loop</strong></span>), it does not play the next song, but breaks out of the method with a return statement.</li><li class="listitem" style="list-style-type: disc">If the<a id="id467" class="indexterm"/> loop value is <code class="literal">2</code> (loop over the current song), it again calls the <code class="literal">launch_play </code>method without changing the current track.</li><li class="listitem" style="list-style-type: disc">If the loop value is <code class="literal">3</code> (<span class="strong"><strong>Loop All</strong></span>), it calls another method named <code class="literal">fetch_next_track</code>.</li></ul></div></div><div class="section" title="Step 4 – fetching the next track"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec79"/>Step 4 – fetching the next track</h3></div></div></div><p>The code of <code class="literal">fetch_next_track </code>to fetch the next track is as follows:</p><div class="informalexample"><pre class="programlisting">def fetch_next_track(self):
   try:      next_trackindx = self.parent.alltracks.index(self.parent.currentTrack) +1
     self.parent.currentTrack = self.parent.alltracks[next_trackindx]
     self.parent.launch_play()
   except:pass
     # end of list – do nothing</pre></div><p>The description of the code is listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This code simply increments index by one, sets the current track variable to the next item in the list of all songs, and calls <code class="literal">launch_play()</code> to play the next track.</li></ul></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec114"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes<a id="id468" class="indexterm"/> the coding of looping in our player.</p><p>This iteration relied <a id="id469" class="indexterm"/>on the fact that pyglet allows an <code class="literal">on_oes</code> (on end of song) callback. At the end of a track, we use this callback to check the looping choice specified by the user.</p><p>If the user does not want to loop through the playlist, we pass a blank return statement. If the user wants to loop over the current song, we call the<a id="id470" class="indexterm"/> <code class="literal">launch_play </code>method without incrementing the current track. If the user wants to loop through the entire list, we call a method named <code class="literal">fetch_next_track</code>, which increments the index of song by one, and then calls the <code class="literal">launch_play</code> method to play the next song.</p><p>In this iteration, we also saw a sample usage of radio buttons.</p><p>Our player is now equipped to loop over a playlist based on preferences provided by the user.</p></div></div>
<div class="section" title="Adding the contextual menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Adding the contextual menu</h1></div></div></div><p>In this quick iteration, we add a contextual pop-up menu or the right-click menu with shortcuts to <a id="id471" class="indexterm"/>some common operations on the player.</p><p>For now, we will <a id="id472" class="indexterm"/>add just two functions to the right-click menu: <span class="strong"><strong>Play </strong></span>and <span class="strong"><strong>Delete</strong></span>.</p><p>After completion, the right-click menu will open, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_05_07.jpg" alt="Adding the contextual menu"/></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec115"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – creating the contextual menu"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec80"/>Step 1 – creating the contextual menu</h3></div></div></div><p>We have done similar contextual menus<a id="id473" class="indexterm"/> in our text editor, so we do a quick round up.</p><p>We add a new method, <code class="literal">context_menu</code>, and call it from the <code class="literal">GUI __init__</code> method, as follows (see <span class="emphasis"><em>Code 5.06 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">def create_context_menu(self):
   self.context_menu = Menu(self.root, tearoff=0)
   self.context_menu.add_command(label="Play", command=self.identify_track_to_play)
   self.context_menu.add_command(label="Delete", command=self.del_selected)</pre></div><p>We also define a <code class="literal">show_context_menu </code>method and bind it to right-click of mouse<code class="literal">&lt;&lt;Button-3&gt;&gt;</code> from within our <code class="literal">create_list_frame</code>, immediately next to where the Listbox widget is defined, as follows:</p><div class="informalexample"><pre class="programlisting">def show_context_menuContext_menu(self,event):
   self.context_menu.tk_popup(event.x_root+45, event.y_root+10,0)</pre></div></div><div class="section" title="Step 2: overriding the close button"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec81"/>Step 2: overriding the close button</h3></div></div></div><p>While <a id="id474" class="indexterm"/>we are at it, let us code a little overlooked function. Now that we have the capability to loop over entire playlists, we do not want the player to close without stopping the songs being played. Let us, therefore, override the <code class="literal">root.destroy()</code> method<a id="id475" class="indexterm"/> to stop tracks before exiting.</p><p>To override the destroy method, we first add a protocol override method to our <code class="literal">GUI __init__</code> method, as follows (see <span class="emphasis"><em>Code 5.06 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">self.root.protocol('WM_DELETE_WINDOW', self.close_player)</pre></div><p>Finally let's define our <code class="literal">close_player</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">def close_player(self):
   if tkMessageBox.askokcancel("Quit", "Really want to quit?"):
     try:
        self.player.pause()
     except:
        pass
     self.root.destroy()</pre></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec116"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>The contextual menu is now added to our program. A user can now right-click on an item and select to play or delete<a id="id476" class="indexterm"/> it.</p><p>We have also<a id="id477" class="indexterm"/> overridden our close button to ensure that any playing track is stopped before we exit the player.</p></div></div>
<div class="section" title="Adding a tooltip and finalizing our player"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Adding a tooltip and finalizing our player</h1></div></div></div><p>In this iteration,<a id="id478" class="indexterm"/> we add tooltip also named the Balloon<a id="id479" class="indexterm"/> widget to all the buttons in our player.</p><p>A tooltip<a id="id480" class="indexterm"/> is a small popup, which shows up when you hover your mouse over the Bound widget (buttons in our case). A typical tooltip on our application would look as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/7941_05_08.jpg" alt="Adding a tooltip and finalizing our player"/></div><div class="section" title="Prepare for Lift Off"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec117"/>Prepare for Lift Off</h2></div></div></div><p>Although core Tkinter has many useful widgets, it is far from complete. For us, the tooltip or Balloon widget is not provided as a core Tkinter widget. We, therefore, look for these widgets in what are named <a id="id481" class="indexterm"/>
<span class="strong"><strong>Tkinter extensions</strong></span>.</p><p>These<a id="id482" class="indexterm"/> extensions are nothing but modified Tkinter widgets to act and behave with new functionalities not offered by Tkinter.</p><p>There are literally hundreds of Tkinter extensions. In fact, we could write our own Tkinter extensions. However, some of the popular Tkinter extensions are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Python Mega Widgets</strong></span> (<span class="strong"><strong>PMW</strong></span>) <a id="id483" class="indexterm"/>available at <a class="ulink" href="http://pmw.sourceforge.net">http://pmw.sourceforge.net</a><a id="id484" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Tix</strong></span><a id="id485" class="indexterm"/><a id="id486" class="indexterm"/> available at <a class="ulink" href="http://wiki.Python.org/moin/Tix">http://wiki.Python.org/moin/Tix</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>TkZinc</strong></span> available<a id="id487" class="indexterm"/><a id="id488" class="indexterm"/> at <a class="ulink" href="http://wiki.Python.org/moin/TkZinc">http://wiki.Python.org/moin/TkZinc</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Widget Construction Kit</strong></span>(<span class="strong"><strong>WCK</strong></span><a id="id489" class="indexterm"/><a id="id490" class="indexterm"/>) available at <a class="ulink" href="http://effbot.org/zone/wck.htm">http://effbot.org/zone/wck.htm</a></li></ul></div><div class="section" title="PMW list of extensions"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec82"/>PMW list of extensions</h3></div></div></div><p>Talking about PMW, here is a<a id="id491" class="indexterm"/> quick list of widget extensions from the package:</p><div class="section" title="Widgets"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec01"/>Widgets</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ButtonBox<a id="id492" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">ComboBox</li><li class="listitem" style="list-style-type: disc">Counter</li><li class="listitem" style="list-style-type: disc">EntryField</li><li class="listitem" style="list-style-type: disc">Group</li><li class="listitem" style="list-style-type: disc">HistoryText</li><li class="listitem" style="list-style-type: disc">LabeledWidget</li><li class="listitem" style="list-style-type: disc">MainMenuBar</li><li class="listitem" style="list-style-type: disc">MenuBar</li><li class="listitem" style="list-style-type: disc">MessageBar</li><li class="listitem" style="list-style-type: disc">NoteBook</li><li class="listitem" style="list-style-type: disc">OptionMenu</li><li class="listitem" style="list-style-type: disc">PanedWidget</li><li class="listitem" style="list-style-type: disc">RadioSelect</li><li class="listitem" style="list-style-type: disc">ScrolledCanvas</li><li class="listitem" style="list-style-type: disc">ScrolledField</li><li class="listitem" style="list-style-type: disc">ScrolledFrame</li><li class="listitem" style="list-style-type: disc">ScrolledListBox</li><li class="listitem" style="list-style-type: disc">ScrolledText</li><li class="listitem" style="list-style-type: disc">TimeCounter</li></ul></div></div><div class="section" title="Dialogs"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec02"/>Dialogs</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">AboutDialog<a id="id493" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">ComboBoxDialog</li><li class="listitem" style="list-style-type: disc">CounterDialog</li><li class="listitem" style="list-style-type: disc">Dialog</li><li class="listitem" style="list-style-type: disc">MessageDialog<a id="id494" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">PromptDialog</li><li class="listitem" style="list-style-type: disc">SelectionDialog</li><li class="listitem" style="list-style-type: disc">TextDialog</li></ul></div></div><div class="section" title="Miscellaneous"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec03"/>Miscellaneous</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Balloon</li><li class="listitem" style="list-style-type: disc">Blt(used for graph generation)<a id="id495" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Color Module functions</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>PMW offers a large list of extended widgets. For a demonstration of all these widgets, browse into the PMW package that you installed earlier, and look for a directory named <code class="literal">demo</code>. Within <code class="literal">demo</code>, look for a file, <code class="literal">all.py</code>, which demonstrates<a id="id496" class="indexterm"/> all PMW extensions with sample<a id="id497" class="indexterm"/> working code.</p></div></div></div></div></div><div class="section" title="Engage Thrusters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec118"/>Engage Thrusters</h2></div></div></div><div class="section" title="Step 1 – importing PMW"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec83"/>Step 1 – importing PMW</h3></div></div></div><p>PMW provides the Balloon widget implementation, but it is not part of standard Tkinter library. We need to add it. To add PMW, refer to our discussion under the <span class="emphasis"><em>Mission Checklist</em></span> section. Once added, you need to import PMW into your namespace, as follows (see <span class="emphasis"><em>Code 5.07 main-gui.py</em></span>):</p><div class="informalexample"><pre class="programlisting">import Pmw</pre></div></div><div class="section" title="Step 2 – instantiating the Balloon widget"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec84"/>Step 2 – instantiating the Balloon widget</h3></div></div></div><p>We then instantiate the Balloon widget within the mainloop from our <code class="literal">__init__</code> method as follows:</p><div class="informalexample"><pre class="programlisting">   self.balloon = Pmw.Balloon(self.root)</pre></div></div><div class="section" title="Step 3 – adding Balloon tooltips to all buttons in our player"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec85"/>Step 3 – adding Balloon tooltips to all buttons in our player</h3></div></div></div><p>Finally, we bind the Balloon widget to each of the button widgets in our player. We will not reproduce the code for each button. However, the format is as follows:</p><div class="informalexample"><pre class="programlisting">balloon.bind(name of widget, 'Description for the balloon')</pre></div><p>So our Add File button would have a balloon binding as follows:</p><div class="informalexample"><pre class="programlisting">self.balloon.bind(add_filebtn, 'Add New File')</pre></div><p>We add similar code for each button in <span class="emphasis"><em>5.07 main-gui.py</em></span>.</p><p>Before we end this iteration, let us add a title to our player and add a title bar icon as well, as follows:</p><div class="informalexample"><pre class="programlisting">self.root.title('Media Player')
self.root.iconbitmap('../icons/mp.ico')</pre></div></div></div><div class="section" title="Objective Complete – Mini Debriefing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec119"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes<a id="id498" class="indexterm"/> the iteration. We added Balloon tooltips to our player buttons using PMW Tkinter extension.</p><p>Most importantly, <a id="id499" class="indexterm"/>we got to know about Tkinter extensions and when to use them.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>When you come across a widget implementation need that is not available as a core widget, try looking for implementations of it in PMW or Tix. If you don't find one that suits your need, search the Internet for some other Tkinter extension.</p><p>If you still don't find your desired implementation, try out WCK, which lets you implement all types of custom widgets. However, note that WCK is not under active development for long.</p></div></div></div></div>
<div class="section" title="Mission Accomplished"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Mission Accomplished</h1></div></div></div><p>This brings us to the end of this project. Our audio media player is ready!</p><p>Let us recap the things that we touched upon in this project.</p><p>Some of the topics we covered in this project could be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We reinforced a lot of GUI programming techniques that we discussed during previous projects</li><li class="listitem" style="list-style-type: disc">We learned how to work with more widgets, such as Listbox, ttk Scale, Progressbar, and Radiobutton</li><li class="listitem" style="list-style-type: disc">We got further insight into the power of the Canvas widget</li><li class="listitem" style="list-style-type: disc">We saw how to work with external APIs to ease program development</li><li class="listitem" style="list-style-type: disc">We got to know about some common Tkinter extensions, such as PMW, WCK, Tix, and others</li><li class="listitem" style="list-style-type: disc">We also saw how to refactor code at each stage of development</li></ul></div></div>
<div class="section" title="A Hotshot Challenge"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>A Hotshot Challenge</h1></div></div></div><p>Here are some hotshot challenges on which you can work:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Currently, our <a id="id500" class="indexterm"/>code adds each button separately. This makes the program long and adds unnecessary boilerplates. Refactor this code to add all buttons using loops. This should considerably shorten the length of our <code class="literal">GUI</code> class, while streamlining the buttons to be handled from a small loop.</li><li class="listitem" style="list-style-type: disc">Currently, the program keeps record of songs only during a single program run. The songs need to be loaded in subsequent runs. Try to incorporate auto-playlist load based on last run playlist history using object persistence.</li><li class="listitem" style="list-style-type: disc">Find a Python package that lets you extract useful metadata from your audio files: things such as its author, genre or frequencies, and number of channels. Use these metadata to display more information about the current track in the display console.</li><li class="listitem" style="list-style-type: disc">Add skinning ability to the player, letting the user select a different skin for the player.</li><li class="listitem" style="list-style-type: disc">Look out for some network related packages to support streaming of online audio. Incorporate the feature of being able to tune in to online radio stations.</li></ul></div></div></body></html>