<html><head></head><body>
		<div>
			<div id="_idContainer012" class="Content">
			</div>
		</div>
		<div id="_idContainer013" class="Content">
			<h1 id="_idParaDest-12"><a id="_idTextAnchor013"/>1. Your First Step</h1>
		</div>
		<div id="_idContainer014" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Replicate the concepts of RESTful API </li>
				<li class="bullets">Describe the meaning of different HTTP methods and statuses</li>
				<li class="bullets">Get hands-on experience on PyCharm IDE</li>
				<li class="bullets">Build a RESTful API and execute CRUD using Flask</li>
				<li class="bullets">Use JSON messages to communicate with the APIs</li>
				<li class="bullets">Test API endpoints using Postman and httpie/curl command-line tools</li>
			</ul>
			<p>This chapter introduces API and explains the concepts of web services, API and REST.</p>
		</div>
		<div id="_idContainer028" class="Content">
			<h2 id="_idParaDest-13"><a id="_idTextAnchor014"/>Introduction</h2>
			<p>We are in the internet era, a world where everything is connected. Data flows seamlessly from one place to another. We can get all the information in the world with a few clicks on a website. Take Skyscanner as an example, we just need to put in the date and location of our trips, and it can find us the cheapest flight in a split second; the hero behind the scenes that provides this data is API.</p>
			<p>In this chapter, you will learn what a web service, an API, and REST are. We will start by teaching the fundamental concepts of APIs. Then we will look at real-life examples of how different web services (Google, Facebook, and so on) use the REST API.</p>
			<p>Finally, we will develop our first simple Python RESTful API using Python. Python is a popular and powerful programming language. Apart from its extensive use in the realm of artificial intelligence, it is also widely used in web application development, big data analysis, web scraping, and process automation. What makes Python excel in so many areas is the extensive number of frameworks available. The frameworks do all the heavy lifting jobs and that allows the developers to focus on the actual application design and development. </p>
			<p>In this chapter, you will see how data is encoded and communicated between the frontend and the backend. You will learn technical details about the JSON format, the HTTP protocol, HTTP status codes, and so on. All the development work will be verified and tested using Postman and httpie/curl. We will take you through the whole process of web application development. Not only will you learn the essential aspects of developing a RESTful API, but you will also learn about the thinking process, design, development, testing, and even deployment. This is a journey of learning the complete software development life cycle. Let's embark on our exciting journey now!</p>
			<h2 id="_idParaDest-14"><a id="_idTextAnchor015"/>Understanding API</h2>
			<p>API stands for application programming interface; it is an interface for the website (or mobile application) to communicate with the backend logic. Simply put, it is like a messenger that takes a request from the users and sends the request to the backend system. Once the backend system responds, it will then pass that response to the users. A metaphor for this is a waiter/waitress, who can understand different customers' orders. They will then act as a middleman between the customers and the chefs in the kitchen. </p>
			<p>If you were the boss of the restaurant, the key benefit of having a waiter/waitress here between your customer and the kitchen is that the customers will be shielded from seeing your business secrets. They don't need to know how the meal is prepared. They just need to send an order through the waiter/waitress, and they will get the meal they ordered. In this scenario, the waiter acts like the API. The following figure helps illustrate the analogy.</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/C15309_01_01.jpg" alt="Figure 1.1: The waiter acting as the API for the customer&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 1.1: The waiter acting as the API for the customer</h6>
			<p>Similarly, in computer science, one of the key benefits of having API is encapsulation. We encapsulate the logic so that people outside won't be able to see it. With this arrangement, big companies with sensitive information are willing to provide services to the world through APIs, confident that their internal information won't be revealed. Take Skyscanner again as an example. The company is comfortable with using an API to allow customers to book their flights, but at the same time, personal data from other customers that are stored in their internal database won't leak. </p>
			<p>An API is also a standard interface that can communicate with different types of frontend Terminals, they can be mobile applications or websites. As long as the frontend is sending the same request to the API, it will get the same result back. If we go back to our metaphor, the waiter/waitress will serve all kinds of customers, regardless of their gender, age, language, and so on.</p>
			<p>Now, imagine you are a software engineer at Skyscanner who is responsible for developing an API. What will your job be? Let me tell you. Your job will be to write a program that can take booking requests (date and location) from customers through the website, and then look up matching flights in the Skyscanner database and return the flight details to the customers. Throughout this book, you will be our API engineering intern. We will guide you, step by step, through the process of developing a RESTful API project that can serve the users of your system.</p>
			<h2 id="_idParaDest-15">R<a id="_idTextAnchor016"/>ESTful API</h2>
			<p>REST stands for Representational State Transfer. It was first defined in Dr. Roy Fielding's dissertation (Architectural Styles and the Design of Network-Based Software Architectures) back in 2000. This dissertation is considered to be the bible in the web domain. REST is not a standard or protocol; it is more like a software architectural style. Many engineers follow this architectural style to build their applications, such as eBay, Facebook, and Google Maps. These web applications serve huge amounts of traffic every second, so you can see that REST really is a scalable architecture style. And when we say RESTful API, we are referring to an API that conforms to the REST constraints/principles.</p>
			<h3 id="_idParaDest-16">R<a id="_idTextAnchor017"/>EST Constraints/Principles</h3>
			<p>There are five important constraints/principles for the REST architecture style:</p>
			<ul>
				<li>Client-server: There is an interface between the client and the server. The client and server communicate through this interface and are independent of each other. Either side can be replaced as long as the interface stays the same. Requests always come from the client-side.</li>
				<li>Stateless: There is no concept of state for a request. Every request is considered to be independent and complete. There is no dependence on the previous request nor dependence on a session to maintain the connection status.</li>
				<li>Cacheable: Things are cacheable on the server or client-side to improve performance. </li>
				<li>Layered system: There can be multiple layers in the system, and the goal here is to hide the actual logic/resources. These layers can perform different functions, such as caching and encryption. </li>
				<li>Uniform interface: The interface stays the same. This helps to decouple the client and server logic.</li>
			</ul>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor018"/>HTTP Protocol</h2>
			<p>To better understand what REST is and make sure we are implementing the REST style, we can simply talk about the HTTP protocol. HTTP is an implementation of the REST architecture style. It is short for HyperText Transfer Protocol and is the standard protocol used on the worldwide web. We use it every day to browse different websites. That's why all the websites we visit are prefixed with http.</p>
			<p>In the HTTP protocol, there are different types of  service request methods. Each service request method has a special definition that is specific to it. When the frontend interface interacts with the backend API through a URL, they need to, at the same time, define the HTTP method for this request. Different HTTP methods are like different service counters. For example, reading and creating data are completely different services, so they should be handled by different service counters, meaning different HTTP methods.</p>
			<ul>
				<li><strong class="inline">GET</strong>: For reading data</li>
				<li><strong class="inline">POST</strong>: For creating data</li>
				<li><strong class="inline">PUT</strong>: For updating data by completely replacing data with new content</li>
				<li><strong class="inline">PATCH</strong>: For updating data, but by partially modifying a few attributes</li>
				<li><strong class="inline">DELETE</strong>: For deleting data</li>
			</ul>
			<p>Simply put, different HTTP methods are like the verbs for REST API. They are used for performing different actions on the same set of data.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor019"/>HTTP Methods and CRUD</h2>
			<p>We can easily build a RESTful API by leveraging what has already been provided by the HTTP protocol. Let's take a look at the HTTP methods that we can use to communicate with the server.</p>
			<p>In this book, we will build a recipe sharing platform with a RESTful API as the backend. This platform will allow users to create and share their own recipes. At the same time, users will also be able to read recipes shared by other users. Using this recipe sharing platform as an example, to achieve these functionalities, we will need our API to be able to perform different actions on the recipes. We can leverage different HTTP methods here. For example, we can use the <strong class="inline">GET</strong> method to request <strong class="inline">http://localhost:5000/recipes</strong> for all the recipes. We can use the <strong class="inline">POST</strong> method to request <strong class="inline">http://localhost:5000/recipes</strong> to create a new recipe. We can also use the <strong class="inline">DELETE</strong> method to request <strong class="inline">http://localhost:5000/recipes/20</strong> to delete a recipe with <strong class="inline">ID = 20</strong>. Please refer to the following table for details.</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/C15309_01_02.jpg" alt="Figure 1.2: HTTP methods&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 1.2: HTTP methods</h6>
			<p>We can see that asking the backend API to work for us is simple. We can simply use the HTTP protocol to communicate our request.</p>
			<p>In fact, with this recipe sharing platform, you can see the majority of the actions we require will revolve around CREATE, READ, UPDATE, and DELETE. This is generally true for all other web applications as well. In the developer community, we call this CRUD in short. In a nutshell, CRUD models the life cycle of database record management.</p>
			<p>Modeling our web applications this way can help us easily construct a functioning web system, as these actions are related to the HTTP methods. Constructing our application with this architecture is simple, powerful, and highly readable.</p>
			<p>As you can probably imagine, we will need to send information to the backend server. For example, you may want to store a recipe in the backend database. You send the recipe over HTTP with a pre-agreed format with the backend. A pre-agreed format can be understood as a language used to communicate with the waiter/waitress in our previous metaphor. In real life, we have different languages, such as English, German, Chinese, and so on. We need to speak the right language for the other side to understand. In the web API domain, there are two prevalent standards, JSON and XML. We will mainly talk about JSON here because it is more readable and widely adopted.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/>The JSON Format</h2>
			<p><strong class="keyword">JavaScript Object Notation</strong> (<strong class="keyword">JSON</strong>) is a simple plaintext format that is capable of representing complex data structures. We can use this format to represent strings, numbers, arrays, and even objects. Once we have the information "JSONified," we can use this widely adopted format to communicate with the API.</p>
			<p>We are going to show you what a JSON format file looks like. In the following example, you will see that we are representing two recipes in JSON format. A JSON document is a plaintext document; there is no encryption here. It is so readable that I am sure you can already tell (without further explanation) that there are two recipes here, each with an ID, name, and description.</p>
			<p>Here are a few notes on JSON syntax:</p>
			<ul>
				<li>Arrays are enclosed by <strong class="inline">[]</strong></li>
				<li>Objects can be represented by <strong class="inline">{}</strong></li>
				<li>Names/values always exist in pairs, and are delimited by "<strong class="inline">:</strong>"</li>
				<li>Strings are enclosed by ""</li>
			</ul>
			<p>Following is a sample code file with JSON syntax:</p>
			<p class="snippet">{</p>
			<p class="snippet">  "recipes":[</p>
			<p class="snippet">    {</p>
			<p class="snippet">      "id":1,</p>
			<p class="snippet">      "name":"Egg Salad",</p>
			<p class="snippet">      "description":"Place an egg in a saucepan and..."</p>
			<p class="snippet">    },</p>
			<p class="snippet">    {</p>
			<p class="snippet">      "id":2,</p>
			<p class="snippet">      "name":"Tomato Pasta",</p>
			<p class="snippet">      "description":"Bring a large pot of lightly salted water to a boil..."</p>
			<p class="snippet">    }</p>
			<p class="snippet">  ]</p>
			<p class="snippet">}</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>HTTP Status Codes</h2>
			<p>An HTTP status code is a code that is returned in the HTTP protocol. It is usually hidden from users, so you probably didn't realize it exists. In fact, every HTTP response from the server contains a status code. And as we construct our RESTful API, we need to comply with the HTTP protocol. The status code helps the frontend client understand the status of their request, that is, whether it is a success or failure. For example, there could be a client request about creating a record in the backend database. In that case, once the database record has been successfully created, the server should return an HTTP status code 201 (Created). If there is an error (such as a syntax error in the JSON document), the server should return an HTTP status code 400 (Bad Request) instead.</p>
			<h3 id="_idParaDest-21"><a id="_idTextAnchor022"/>Commonly used HTTP Status Codes</h3>
			<p>Let's discuss some commonly used status codes. They are as follows:</p>
			<ul>
				<li>200 OK means the request has been successful. The request could be a GET, PUT, or PATCH.</li>
				<li>201 Created means the POST request has been successful and a record has been created.</li>
				<li>204 No Content means the DELETE request has been successful.</li>
				<li>400 Bad Request means there is something wrong with the client request. For example, there is a syntax error in the JSON format.</li>
				<li>401 Unauthorized means the client request is missing authentication details.</li>
				<li>403 Forbidden means the requested resource is forbidden.</li>
				<li>404 Not Found means the requested resource doesn't exist.</li>
			</ul>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>Open API</h2>
			<p>Open API is a third-party API that is open to use. There are plenty of them available out there. Companies are eager to open their APIs to expand their user base but at the same time keep their source code proprietary. These APIs can be accessible by us as well. Let's take a look at some of the APIs from Facebook. </p>
			<p>For example, we can use the HTTP GET method to access <strong class="inline">https://graph.facebook.com/{page_id}/feed</strong>, which will give us the feeds on the Facebook page with <strong class="inline">ID = {page_id}</strong>. We can send an HTTP request using the <strong class="inline">POST</strong> method to <strong class="inline">https://graph.facebook.com/{page_id}/feed</strong>, and then we can create a post on the Facebook page with <strong class="inline">ID = {page_id}</strong>.</p>
			<h4>Note</h4>
			<p class="callout">The Facebook fans page API details can be found at <a href="https://developers.facebook.com/docs/pages/publishing">https://developers.facebook.com/docs/pages/publishing</a>.</p>
			<p>Now, let's look at another internet giant, Google. Google also provides some Gmail APIs that we can use to manage the email labels in our mailbox. Here is a screenshot from the Gmail API documentation:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/C15309_01_03.jpg" alt="Figure 1.3: Gmail API documentation&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 1.3: Gmail API documentation</h6>
			<h4>Note</h4>
			<p class="callout">The Gmail Label API is available at <a href="https://developers.google.com/gmail/api/v1/reference/">https://developers.google.com/gmail/api/v1/reference/</a>.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor024"/>The Flask Web Framework</h2>
			<p>Flask is a web framework that we can use to easily build a web application. Web applications usually need some core functionalities, such as interacting with client requests, routing URLs to resources, rendering web pages, and interacting with backend databases. A web application framework such as Flask provides the necessary packages, modules that do the heavy lifting. So, as a developer, we only need to focus on the actual application logic.</p>
			<p>There are, of course, other available web frameworks available on the market. One strong competitor of Flask is Django. It is also a Python web framework. The reason why we choose Flask in this book is that Flask is minimalistic. It is regarded as a micro-web-framework that only provides the absolutely essential packages for developers to start with. Because of that, it is easy to learn and is great for beginners.</p>
			<p>And later, if we want to build further functions, there is a vast number of Flask extensions. You will see the power of Flask as we progress in this book.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor025"/>Building a Simple Recipe Management Application</h2>
			<p>Let's do some simple exercises to test your knowledge. We are going to build a recipe-sharing platform throughout this book, and the API is the interface we expose to the public. We will first define what functions we want to provide and the corresponding URLs. These are the basic functions that we will probably  need:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/C15309_01_04.jpg" alt="Figure 1.4: HTTP methods and functions&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 1.4: HTTP methods and functions</h6>
			<p>A typical recipe should have the following attributes</p>
			<ul>
				<li><strong class="inline">ID</strong>: The unique identifier for the recipe</li>
				<li><strong class="inline">Name</strong>: The name of the recipe</li>
				<li><strong class="inline">Description</strong>: The description of the recipe</li>
			</ul>
			<p>We are going to build an API that lists all the recipes stored in our system. The API will be designed to return different results with different URLs. For example, <strong class="inline">http://localhost:5000/recipes</strong> is going to give us all the recipes stored in our system, while <strong class="inline">http://localhost:5000/recipes/20</strong> will give us the recipe with <strong class="inline">ID = 20</strong>. Upon successful recipe retrieval, we will also see the HTTP status is set to 200 (OK). This indicates that our request has been successful.</p>
			<p>When we create a new recipe, we use the HTTP POST method to query <strong class="inline">http://localhost:5000/recipes</strong> with all the necessary parameters to describe our recipe in JSON format. The JSON format is simply a key/value pair. If our request is successful, the recipe will be created in the backend and will return HTTP status 201 (Created). Together with the HTTP status, it will also send the recipe that has just been created in JSON format. </p>
			<p>When we update a recipe, we use the HTTP PUT method to send the data to <strong class="inline">http://localhost:5000/recipes/20</strong> with all the necessary parameters for the updated recipe in JSON format. If our request is successful, the recipe will be updated in the backend and it will return HTTP status 200 (OK). Together with the HTTP status, it will also send the updated recipe in JSON format. </p>
			<p>When we delete a recipe, we can use the HTTP Delete method to send the data to <strong class="inline">http://localhost:5000/recipes/20</strong>. This will remove the recipe with <strong class="inline">ID = 20</strong>.</p>
			<p>Now you know where we are heading to, let's roll up our sleeves and get our hands dirty!</p>
			<h3 id="_idParaDest-25"><a id="_idTextAnchor026"/>Virtual Environment</h3>
			<p>It is always recommended for developers to develop their application inside a virtual environment instead of directly on their local environment. </p>
			<p>The reason is that virtual environments are independent application development environments. We can create multiple virtual environments on a local machine, and these virtual environments can have their own version of Python, their own packages, their own environment variables, and so on. These virtual environments won't interfere with each other even though they are built on the same local machine. </p>
			<p>In the following exercise, we will create a development project in the PyCharm IDE. We will show you how to set up a virtual environment for this project in PyCharm.</p>
			<h3 id="_idParaDest-26"><a id="_idTextAnchor027"/>Exercise 1: Building Our First Flask Application</h3>
			<p>We are going to build our first Flask application in this exercise. You will realize how simple it is to build an application along the way. PyCharm is a great <strong class="keyword">integrated development environment</strong> (<strong class="keyword">IDE</strong>) with a nice GUI that will make our development process easier. We will learn about the workflow of application development, including the creation of the application project and installing the necessary Python packages:</p>
			<ol>
				<li><a id="_idTextAnchor028"/>Create a new project in PyCharm with <strong class="bold">File &gt; New Project</strong>. Name our project <strong class="inline">basic-api</strong>. PyCharm will automatically help us to create a virtual environment for this new project.<div id="_idContainer019" class="IMG---Figure"><img src="image/C15309_01_05.jpg" alt="Figure 1.5: Creating a new project&#13;&#10;"/></div><h6>Figure 1.5: Creating a new project</h6><p>It's a good practice for projects to run on their own assigned independent virtual environments, so these projects can run on different packages and they won't affect each other.</p></li>
				<li>Install the necessary packages in our virtual environment. To do that, we can create a file named <strong class="inline">requirements.txt</strong> in our project and type in the following text. We want to install <strong class="inline">Flask</strong> (version <strong class="inline">1.0.3</strong>) and <strong class="inline">httpie</strong> (version <strong class="inline">1.0.2):</strong><p class="snippet">Flask==1.0.3</p><p class="snippet">httpie==1.0.2</p><p>Following screenshot shows the installation of Flask and httpie in <strong class="inline">requirements.txt</strong>:</p><div id="_idContainer020" class="IMG---Figure"><img src="image/C15309_01_06.jpg" alt="Figure 1.6: Installing Flask and httpie in requirements.txt&#13;&#10;"/></div><h6>Figure 1.6: Installing Flask and httpie in requirements.txt</h6><p>PyCharm is going to prompt us on the missing package, as shown in the screenshot. Clicking on <strong class="bold">Install requirement</strong> will let PyCharm take care of the installation for us in the virtual environment. Once the installation is done, we can create our first Python file, called <strong class="inline">app.py</strong>.</p><h4>Note</h4><p class="callout">To install the Python packages, we can also run the <strong class="inline">pip install -r requirements.txt</strong> command in Terminal. It will yield the same result.</p><p class="callout">The Flask package that we are installing is a web micro-framework. It is extremely lightweight and allows us to build a web service with just a few lines of code. </p></li>
				<li>Let's type in the following code in <strong class="inline">app.py</strong>, then <em class="italics">right-click</em> on the filename of <strong class="inline">app.py</strong> in the left panel,  and select <strong class="bold">run</strong> <strong class="inline">app</strong> to execute our first web service in Flask:<p class="snippet">from flask import Flask</p><p class="snippet">app = Flask(__name__)</p><p class="snippet">@app.route("/")</p><p class="snippet">def hello():</p><p class="snippet">    return "Hello World!"</p><p class="snippet">if __name__ == "__main__":</p><p class="snippet">    app.run()</p><p>What this does is it first imports the Flask package in <strong class="inline">app.py</strong>, then it instantiates a <strong class="inline">Flask</strong> object, and finally, it assigns it to the <strong class="inline">app</strong> variable. We have created the main function as the entry point for our startup script. This subsequently brings up the Flask web server. After that, we have defined our first API function, <strong class="inline">hello</strong>, which returns a "<strong class="inline">Hello World</strong>" response. Using the Flask decorator, we can route the GET request URL to this function.</p></li>
				<li>Now open the browser and type <strong class="inline">http://localhost:5000</strong>, You will see the string <strong class="bold">Hello World!</strong>. No special format, just plaintext. This means your first web service passed the test, it works!<div id="_idContainer021" class="IMG---Figure"><img src="image/C15309_01_07.jpg" alt="Figure 1.7: Browser showing Hello World in plaintext&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 1.7: Browser showing Hello World in plaintext</h6>
			<p>This is a very good start! Though this web service merely returns the plain text string, we can build a lot of stuff on top of that. </p>
			<p>I hope you can see how simple it is to build a web service using Flask; it is literally just a few lines of code. In fact, there are more Flask extensions out there that can help us build fancy functions. And be patient, we will talk about that in the subsequent chapters. For now, let's stay simple and get ourselves familiar with Flask first. </p>
			<p>For production-grade applications, data is usually stored in a database. We haven't looked at how to interact with the database yet, so for now, we are going to simply store them in memory. Since we are building a recipe sharing platform, we will be creating two recipes in our next exercise, and we'll let them live in the memory.</p>
			<h3 id="_idParaDest-27"><a id="_idTextAnchor029"/>Exercise 2: Managing Recipes with Flask</h3>
			<p>In this exercise, we are going to work on our recipe management application with Flask. We will implement functionality to get recipes, to create recipes, and to update recipes. Without further ado, let's get started:</p>
			<h4>Note</h4>
			<p class="callout">For the complete code, please refer to <a href="https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson01/Exercise02">https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson01/Exercise02</a>.</p>
			<ol>
				<li value="1">First, clean up <strong class="inline">app.py</strong> and start everything all over again, import the packages that we need for this web service from the preceding code:<p class="snippet">from flask import Flask, jsonify, request</p><p>The jsonify package here is to convert our Python objects (such as a list) to JSON format. It will also change the content type in our HTTP response to application/json. Simply put, it takes care of the heavy lifting of converting to JSON format for us.</p></li>
				<li>Then we import the <strong class="inline">HTTPStatus</strong> enum, which includes different HTTP statuses:<p class="snippet">from http import HTTPStatus</p><p>For instance, we will have <strong class="inline">HTTPStatus.CREATED (201)</strong> and <strong class="inline">HTTPStatus.NOT_FOUND (404)</strong>.</p></li>
				<li>Create an instance of the <strong class="inline">Flask</strong> class<p class="snippet">app = Flask(__name__)</p></li>
				<li>Define the recipes list. We store two recipes in the list. They are stored in the memory<p class="snippet">recipes = [</p><p class="snippet">    {</p><p class="snippet">        'id': 1,</p><p class="snippet">        'name': 'Egg Salad',</p><p class="snippet">        'description': 'This is a lovely egg salad recipe.'</p><p class="snippet">    },</p><p class="snippet">    {</p><p class="snippet">        'id': 2, 'name': 'Tomato Pasta',</p><p class="snippet">        'description': 'This is a lovely tomato pasta recipe.'</p><p class="snippet">    }</p><p class="snippet">]</p></li>
				<li>Use the route decorator to tell Flask that the <strong class="inline">/recipes</strong> route will route to the <strong class="inline">get_recipes</strong> function, and the <strong class="inline">methods = ['GET']</strong> argument to specify that the route decorator will only respond to GET requests:<p class="snippet">@app.route('/recipes', methods=['GET'])</p><p class="snippet">def get_recipes():</p><h4>Note</h4><p class="callout">Please note that if we don't specify methods argument, the default will still be only responding to GET requests.</p></li>
				<li>After that, use the <strong class="inline">jsonify</strong> function to convert the list of recipes to JSON format and respond to the client:<p class="snippet">    return jsonify({'data': recipes})</p></li>
				<li>After getting a specific recipe, if you only want to retrieve one specific recipe, then use the <strong class="inline">/recipes/&lt;int:recipe_id&gt;</strong> route to trigger the <strong class="inline">get_recipe(recipe_id)</strong> function.<p class="snippet">@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['GET'])</p><p>The syntax <strong class="inline">&lt;int:recipe_id&gt;</strong> syntax means the value in the route will be assigned to the integer variable id integer variable and can be used in the function. Our function <strong class="inline">get_recipe(recipe_id)</strong> function will then loop through the whole "<strong class="inline">recipes</strong>" list and locate the recipe that has the id that we are looking for. If that recipe exists, then we will return it. </p></li>
				<li>Take a closer look at our <strong class="inline">get_recipe</strong> function. Get the next recipe in the loop by using <strong class="inline">recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)</strong>. Here, the line <strong class="inline">for recipe in recipes</strong> iterates through all the recipes in our recipe collection and finds out the recipe with <strong class="inline">id = recipe_id</strong>. Once we have found it, we store it in the iterator and retrieve it using the next function. If there is no such recipe with that ID, <strong class="inline">None</strong> will be returned:<p class="snippet">def get_recipe(recipe_id):</p><p class="snippet">    recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)</p><p class="snippet">    if recipe:</p><p class="snippet">        return jsonify(recipe)</p><p class="snippet">    return jsonify({'message': 'recipe not found'}), HTTPStatus.NOT_FOUND</p></li>
				<li>Next, we will work on the <strong class="inline">create_recipe</strong> function, which creates a recipe in memory. Use the <strong class="inline">/recipes</strong> route to the <strong class="inline">create_recipe</strong> function and the "<strong class="inline">methods = [POST]</strong>" argument to specify that the route decorator will only respond to POST requests:<p class="snippet">@app.route('/recipes', methods=['POST'])</p></li>
				<li>After that, use the <strong class="inline">request.get_json</strong> method to get the name and description from the client POST request. These two values together with a self-incremented id that we generate will be stored in the recipe (dictionary object) and then appended to our recipes list. At this point in time, the recipe is created and stored:<p class="snippet">def create_recipe():</p><p class="snippet">    data = request.get_json()</p><p class="snippet">    name = data.get('name')</p><p class="snippet">    description = data.get('description')</p><p class="snippet">    recipe = {</p><p class="snippet">        'id': len(recipes) + 1,</p><p class="snippet">        'name': name,</p><p class="snippet">        'description': description</p><p class="snippet">    }</p><p class="snippet">    recipes.append(recipe)</p></li>
				<li>Finally, return the recipe that has just been created in JSON format, together with an <strong class="bold">HTTP 201 (CREATED)</strong> status. The following code highlights this:<p class="snippet">    return jsonify(recipe), HTTPStatus.CREATED </p></li>
				<li>The next part of code is about updating recipes. Again, use the same line of code here, <strong class="inline">recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)</strong> to get the recipe with a specific ID:<p class="snippet">@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['PUT'])</p><p class="snippet">def update_recipe(recipe_id):</p><p class="snippet">    recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)</p></li>
				<li>The next few lines of code say that if we can't find the recipe, we will return a <strong class="inline">recipe not found</strong> message in JSON format, together with a <strong class="inline">HTTP NOT_FOUND</strong> status: <p class="snippet">    if not recipe:</p><p class="snippet">        return jsonify({'message': 'recipe not found'}), HTTPStatus.NOT_FOUND</p></li>
				<li>If we found the recipe, then perform the <strong class="inline">recipe.update</strong> function, and put in the new name and description you get from the client request: <p class="snippet">    data = request.get_json()</p><p class="snippet">    recipe.update(</p><p class="snippet">        {</p><p class="snippet">            'name': data.get('name'),</p><p class="snippet">            'description': data.get('description')</p><p class="snippet">        }</p><p class="snippet">    )</p></li>
				<li>Finally, we convert the updated recipe to JSON format using the <strong class="inline">jsonify</strong> function and return together with a default HTTP status <strong class="bold">200 (OK)</strong>. The following code highlights this:<p class="snippet">    return jsonify(recipe)</p></li>
				<li>The last few lines of code in our program is for starting up the Flask server:<p class="snippet">if __name__ == '__main__':</p><p class="snippet">    app.run()</p></li>
				<li>Once the code is done, <em class="italics">right-click</em> on the <strong class="inline">app.py</strong> file and click <strong class="bold">run</strong> to start the application. The Flask server will be started up and our application is ready to be tested. Th<a id="_idTextAnchor030"/>e full code looks like this:<p class="snippet">from flask import Flask, jsonify, request</p><p class="snippet">from http import HTTPStatus</p><p class="snippet">app = Flask(__name__)</p><p class="snippet">recipes = [</p><p class="snippet">    {</p><p class="snippet">        'id': 1,</p><p class="snippet">        'name': 'Egg Salad',</p><p class="snippet">        'description': 'This is a lovely egg salad recipe.'</p><p class="snippet">    },</p><p class="snippet">    {</p><p class="snippet">        'id': 2, 'name': 'Tomato Pasta',</p><p class="snippet">        'description': 'This is a lovely tomato pasta recipe.'</p><p class="snippet">    }</p><p class="snippet">]</p><p class="snippet">@app.route('/recipes/', methods=['GET'])</p><p class="snippet">def get_recipes():</p><p class="snippet">    return jsonify({'data': recipes})</p><p class="snippet">@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['GET'])</p><p class="snippet">def get_recipe(recipe_id):</p><p class="snippet">    recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)</p><p class="snippet">    if recipe:</p><p class="snippet">        return jsonify(recipe)</p><p class="snippet">    return jsonify({'message': 'recipe not found'}), HTTPStatus.NOT_FOUND</p><p class="snippet">@app.route('/recipes', methods=['POST'])</p><p class="snippet">def create_recipe():</p><p class="snippet">    data = request.get_json()</p><p class="snippet">    name = data.get('name')</p><p class="snippet">    description = data.get('description')</p><p class="snippet">    recipe = {</p><p class="snippet">        'id': len(recipes) + 1,</p><p class="snippet">        'name': name,</p><p class="snippet">        'description': description</p><p class="snippet">    }</p><p class="snippet">    recipes.append(recipe)</p><p class="snippet">    return jsonify(recipe), HTTPStatus.CREATED</p><p class="snippet">@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['PUT'])</p><p class="snippet">def update_recipe(recipe_id):</p><p class="snippet">    recipe = next((recipe for recipe in recipes if recipe['id'] == recipe_id), None)</p><p class="snippet">    if not recipe:</p><p class="snippet">        return jsonify({'message': 'recipe not found'}), HTTPStatus.NOT_FOUND </p><p class="snippet">    data = request.get_json()</p><p class="snippet">    recipe.update(</p><p class="snippet">        {</p><p class="snippet">            'name': data.get('name'),</p><p class="snippet">            'description': data.get('description')</p><p class="snippet">        }</p><p class="snippet">    )</p><p class="snippet">    return jsonify(recipe)</p><p class="snippet">if __name__ == '__main__':</p><p class="snippet">    app.run()</p></li>
			</ol>
			<p>The output is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/C15309_01_08.jpg" alt="Figure 1.8: The final Flask server&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 1.8: The final Flask server</h6>
			<p>In the following sections, we will show you how to test your web service using curl/httpie or Postman.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor031"/>Using curl or httpie to Test All the Endpoints</h2>
			<p>In this section, we will go through ways to test the API service endpoints in our recipe management application using Command Prompt. Testing is a very important step in application development. This is to ensure the functions we developed are working as expected. We can use curl or httpie, depending on your personal preference. In the subsequent exercise, we will show you both tools. </p>
			<p>Curl (or cURL) is a command-line tool that can transfer data using URLs. We can use this tool to send requests to our API endpoints and examine the response. If you are running on macOS, you don't need to install curl. It is pre-installed in the system and you can find it in Terminal. You can also run it in the Terminal in PyCharm. However, if you are running on Windows, you need to download and install it for free from <a href="http://curl.haxx.se/download.html">http://curl.haxx.se/download.html</a>.</p>
			<p>Httpie (aych-tee-tee-pie) is another command-line client that does a similar thing. It was built with the goal to improve the communication between the CLI (command-line interface) and the web. It is pretty user-friendly. For more details about httpie, please refer to <a href="https://httpie.org/">https://httpie.org/</a>.</p>
			<p>We added <strong class="inline">httpie==1.0.2</strong> in our requirements.txt previously, so PyCharm should have already installed it for us. The main benefit of having httpie is it will beautifully format the JSON document, making it more readable. And believe me, that will save us a lot of time when we move on to verifying the HTTP response from the server.</p>
			<h3 id="_idParaDest-29"><a id="_idTextAnchor032"/>Exercise 3: Testing Our API Endpoints with httpie and curl</h3>
			<p>In this exercise, we are going to use httpie and curl to test our API endpoints. We will test the functions of getting all the recipes back from the server, and also creating/updating the recipes:</p>
			<ol>
				<li value="1">We will first open the Terminal in PyCharm. It is located at the bottom of the application. It will look as shown in the following screenshot:<div id="_idContainer023" class="IMG---Figure"><img src="image/C15309_01_09.jpg" alt="Figure 1.9: PyCharm Terminal&#13;&#10;"/></div><h6>Figure 1.9: PyCharm Terminal</h6></li>
				<li>Type in the following httpie command to get the recipes from our API endpoint, <a href="http://localhost:5000/recipes"><strong class="inline">http://localhost:5000/recipes</strong></a>; we will be using the HTTP GET method here:<p class="snippet">http GET localhost:5000/recipes</p></li>
				<li>If you prefer to do it the curl way, use the following command instead. Note that we have different parameters here: <strong class="inline">-i</strong> is for showing the header in the response and <strong class="inline">-X</strong> is for specifying the HTTP method. We will be using <strong class="inline">GET</strong> here:<p class="snippet">curl -i -X GET localhost:5000/recipes </p><h4>Note</h4><p class="callout">The http GET and curl-i -X GET commands basically do the same thing, which is using the HTTP <strong class="inline">GET</strong> method to send a request to <strong class="inline">http://localhost:5000/recipes</strong>. If the code that we put in on the server-side is working properly, the request will go through the <strong class="inline">/recipes</strong> route and the <strong class="inline">get_recipes</strong> function will be invoked. This will then get us all the recipes in JSON format. </p><p>Take a look at the response we get. The first few lines in the response are the header. It has the HTTP status <strong class="inline">200 OK</strong> and a <strong class="inline">Content-Length</strong> of <strong class="inline">175</strong> bytes. The <strong class="inline">Content-Type</strong> is <strong class="inline">application/json </strong>and, in the end, we have the response body in JSON format:</p><p class="snippet">HTTP/1.0 200 OK</p><p class="snippet">Content-Length: 175</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Date: Mon, 15 Jul 2019 12:40:44 GMT</p><p class="snippet">Server: Werkzeug/0.15.4 Python/3.7.0</p><p class="snippet">{</p><p class="snippet">    "data": [</p><p class="snippet">        {</p><p class="snippet">            "description": "This is a lovely egg salad recipe.",</p><p class="snippet">            "id": 1,</p><p class="snippet">            "name": "Egg Salad"</p><p class="snippet">        },</p><p class="snippet">        {</p><p class="snippet">            "description": "This is a lovely tomato pasta recipe.",</p><p class="snippet">            "id": 2,</p><p class="snippet">            "name": "Tomato Pasta"</p><p class="snippet">        }</p><p class="snippet">    ]</p><p class="snippet">}</p></li>
				<li>After that, let's create a recipe. This time, use the HTTP <strong class="inline">POST</strong> method, as we have lots of information that cannot be encoded in the URL. Please take a look at the following httpie command:<p class="snippet">http POST localhost:5000/recipes name="Cheese Pizza" description="This is a lovely cheese pizza"</p></li>
				<li>And then following is the curl command. The -H here is to specify the header in the request. Put in <strong class="inline">Content-Type: application/json</strong>, as we are going to send over the details of the new recipe in JSON format. The <strong class="inline">-d</strong> here is to specify the HTTP <strong class="inline">POST</strong> data, which is our new recipe:<p class="snippet">curl -i -X POST localhost:5000/recipes -H "Content-Type: application/json" -d '{"name":"Cheese Pizza", "description":"This is a lovely cheese pizza"}'</p></li>
				<li>The <strong class="inline">@app.route('/recipes', methods=['POST'])</strong> in the backend to catch this client request and invoke the <strong class="inline">create_recipe</strong> function. It will get the recipe details from the client request and save it to a list in the application memory. Once the recipe is successfully stored in the memory, it will return an HTTP status of <strong class="inline">201 CREATED</strong>, and the new recipe will also be returned in the HTTP response for us to verify:<p class="snippet">HTTP/1.0 201 CREATED</p><p class="snippet">Content-Length: 77</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Date: Mon, 15 Jul 2019 14:26:11 GMT</p><p class="snippet">Server: Werkzeug/0.15.4 Python/3.7.0</p><p class="snippet">{</p><p class="snippet">    "description": "This is a lovely cheese pizza",</p><p class="snippet">    "id": 3,</p><p class="snippet">    "name": "Cheese Pizza"</p><p class="snippet">}</p></li>
				<li>Now, get all the recipes again to verify if our previous recipe was really created successfully. We expect to receive three recipes in the response now:<p class="snippet">http GET localhost:5000/recipes </p><p class="snippet">curl -i -X GET localhost:5000/recipes </p></li>
				<li>Use either one of the preceding commands. They do the same thing, which is to trigger the <strong class="inline">get_recipes</strong> function and get us all the recipes currently stored in the application memory in JSON format. <p>In the following response, we can see that the HTTP header is saying OK, and the Content-Length is now slightly longer than our previous response, that is, <strong class="inline">252</strong> bytes. This makes sense because we are expecting to see one more recipe in the response. The Content-Type is again <strong class="inline">application/json</strong>, with the body storing the recipes in JSON format. Now we can see our new recipe with ID <strong class="inline">3</strong>:</p><p class="snippet">HTTP/1.0 200 OK</p><p class="snippet">Content-Length: 252</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Date: Tue, 16 Jul 2019 01:55:30 GMT</p><p class="snippet">Server: Werkzeug/0.15.4 Python/3.7.0</p><p class="snippet">{</p><p class="snippet">    "data": [</p><p class="snippet">        {</p><p class="snippet">            "description": "This is a lovely egg salad recipe.",</p><p class="snippet">            "id": 1,</p><p class="snippet">            "name": "Egg Salad"</p><p class="snippet">        },</p><p class="snippet">        {</p><p class="snippet">            "description": "This is a lovely tomato pasta recipe.",</p><p class="snippet">            "id": 2,</p><p class="snippet">            "name": "Tomato Pasta"</p><p class="snippet">        },</p><p class="snippet">        {</p><p class="snippet">            "description": "This is a lovely cheese pizza",</p><p class="snippet">            "id": 3,</p><p class="snippet">            "name": "Cheese Pizza"</p><p class="snippet">        }</p><p class="snippet">    ]</p><p class="snippet">}</p></li>
				<li>Cool! So far, we are in pretty good shape. Now, test our application by trying to modify the recipe with ID 3. Use the HTTP <strong class="inline">PUT</strong> method and send over the modified name and description of the recipe to <strong class="inline">localhost:5000/recipes/3</strong>:<p class="snippet">http PUT localhost:5000/recipes/3 name="Lovely Cheese Pizza" description="This is a lovely cheese pizza recipe."</p><p>The following is the curl command. Again, <strong class="inline">-H</strong> is to specify the header in the HTTP request, and we are setting that to <strong class="inline">"Content-Type: application/json"</strong>; <strong class="inline">-d</strong> is to specify that our data should be in JSON format:</p><p class="snippet">curl -i -X PUT localhost:5000/recipes/3 -H "Content-Type: application/json" -d '{"name":"Lovely Cheese Pizza", "description":"This is a lovely cheese pizza recipe."}'</p></li>
				<li>If things are working properly, then the client request will be caught by the <strong class="inline">@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['PUT'])</strong> route. It will then invoke the <strong class="inline">update_recipe(recipe_id)</strong> function to look for the recipe with the passed-in <strong class="inline">recipe_id</strong>, update it, and return it. Together with the updated recipe in JSON format, we will also receive the HTTP status of <strong class="inline">OK</strong> (<strong class="inline">200</strong>):<p class="snippet">HTTP/1.0 200 OK</p><p class="snippet">Content-Length: 92</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Date: Tue, 16 Jul 2019 02:04:57 GMT</p><p class="snippet">Server: Werkzeug/0.15.4 Python/3.7.0</p><p class="snippet">{</p><p class="snippet">    "description": "This is a lovely cheese pizza recipe.",</p><p class="snippet">    "id": 3,</p><p class="snippet">    "name": "Lovely Cheese Pizza"</p><p class="snippet">}</p></li>
				<li>Alright, all good so far. Now, go on and see if we can get a particular recipe. To do this, send a request to <strong class="inline">localhost:5000/recipes/3</strong> to get the recipe with ID <strong class="inline">3</strong>, and confirm whether our previous update was successful:<p class="snippet">http GET localhost:5000/recipes/3</p><p>We can also use a <strong class="inline">curl</strong> command:</p><p class="snippet">curl -i -X GET localhost:5000/recipes/3 </p></li>
				<li>The application will look for the recipe with the <strong class="inline">recipe_id</strong> and return it in JSON format, together with an HTTP status of <strong class="inline">200 OK</strong>:<p class="snippet">HTTP/1.0 200 OK</p><p class="snippet">Content-Length: 92</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Date: Tue, 16 Jul 2019 06:10:49 GMT</p><p class="snippet">Server: Werkzeug/0.15.4 Python/3.7.0</p><p class="snippet">{</p><p class="snippet">    "description": "This is a lovely cheese pizza recipe.",</p><p class="snippet">    "id": 3,</p><p class="snippet">    "name": "Lovely Cheese Pizza"</p><p class="snippet">}</p></li>
				<li>Now, what if we try a recipe ID that we know doesn't exist? How will the application behave? Test it out with the httpie command as follows:<p class="snippet">http GET localhost:5000/recipes/101</p><p>Alternatively, use the following <strong class="inline">curl</strong> command, which will do the same thing as in the preceding code:</p><p class="snippet">curl -i -X GET localhost:5000/recipes/101 </p></li>
				<li>Similarly, <strong class="inline">@app.route('/recipes/&lt;int:recipe_id&gt;', methods=['GET'])</strong> in the application will catch this client request and try to look for the recipe with ID = 101. The application will return with an HTTP status of <strong class="bold">404</strong> and a <strong class="inline">message: "recipe not found"</strong> in JSON format:<p class="snippet">HTTP/1.0 404 NOT FOUND</p><p class="snippet">Content-Length: 31</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Date: Tue, 16 Jul 2019 06:15:31 GMT</p><p class="snippet">Server: Werkzeug/0.15.4 Python/3.7.0</p><p class="snippet">{</p><p class="snippet">    "message": "recipe not found"</p><p class="snippet">}</p></li>
			</ol>
			<p>If your application passed the test, congratulations! It is a pretty solid implementation. You can choose to perform more tests by yourself if you want to.</p>
			<h2 id="_idParaDest-30">Post<a id="_idTextAnchor033"/>man</h2>
			<p>A Postman is a handy tool for API testing. It has a user-friendly GUI that we can send HTTP requests through. It allows us to send requests with different HTTP methods (that is, GET, POST, PUT, and DELETE) and we can check the response from the server. With this tool, we can easily test our API by sending a client request and checking the HTTP response. We can also save our test cases and group them into different collections.</p>
			<h3 id="_idParaDest-31"><a id="_idTextAnchor034"/>The Postman GUI</h3>
			<p>We assume you should have already installed Postman by following the steps in the preface. When you open Postman, you should see the screen shown in the following screenshot. The left-hand side is a navigation panel for you to navigate through your historical or saved requests. In Postman, your requests are going to be organized into collections, which is like a folder in the filesystem. You can put relevant saved requests in the same collection.</p>
			<p>The top panel is for you to compose your request. As you have learned from the command-line testing tool, we can have different HTTP verbs (such as GET and PUT). We also need to put in an API endpoint to send the request to. For some requests, you may also need to pass in additional parameters. These can all be done in Postman.</p>
			<p>The bottom panel shows the server response:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/C15309_01_10.jpg" alt="Figure 1.10: Postman interface&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 1.10: Postman interface</h6>
			<h3 id="_idParaDest-32"><a id="_idTextAnchor035"/>Sending a GET Request</h3>
			<p>Sending a GET request is simple; we just need to fill in the target URL:</p>
			<ol>
				<li value="1">Select <strong class="inline">GET</strong> as our HTTP method in the drop-down list.</li>
				<li>Enter the request URL (such as <strong class="inline">http://localhost:5000/API1</strong>).</li>
				<li>Click the <strong class="bold">Send</strong> button.</li>
			</ol>
			<h3 id="_idParaDest-33"><a id="_idTextAnchor036"/>Sending a POST Request</h3>
			<p>Sending a POST request, however, will take a bit more work, because very often, we will put extra data in the request. For example, if you want to send some JSON data to an API endpoint, you can do the following:</p>
			<ol>
				<li value="1">Select <strong class="bold">POST</strong> as our HTTP method in the drop-down list.</li>
				<li>Enter the request URL (such as <strong class="inline">http://localhost:5000/API2</strong>).</li>
				<li>Select the <strong class="bold">Body</strong> Tab. Also, select the "<strong class="bold">raw</strong>" radio button.</li>
				<li>Choose "<strong class="bold">JSON (application/json)</strong>" from the right drop-down menu. Put in the JSON data to the Body content area:<p class="snippet">{</p><p class="snippet">     "key1": "value1",</p><p class="snippet">     "key2": "value2"</p><p class="snippet">}</p></li>
				<li>Click the <strong class="bold">Send</strong> button.</li>
			</ol>
			<h3 id="_idParaDest-34"><a id="_idTextAnchor037"/>Saving a Request</h3>
			<p>Very often, you will want to save your request for later use. This saving feature in Postman is particularly useful during regression testing. To save your request, you just need to click the save button, follow the on-screen instructions, and save it in a collection. Then you will see your saved request in the left navigation panel. </p>
			<h4>Note</h4>
			<p class="callout">You may need to open an account in Postman before you can save the request. Please follow the on-screen instructions accordingly.</p>
			<p class="callout">If yo<a id="_idTextAnchor038"/>u want to learn more about Postman, click on the "Bootcamp" button at the bottom of Postman. You will see interactive tutorials showing you how to use Postman step-by-step on the screen. </p>
			<h3 id="_idParaDest-35"><a id="_idTextAnchor039"/>Activity 1: Sending Requests to Our APIs Using Postman</h3>
			<p>Now that we have learned how to use Postman, we are going to test our application using Postman instead of the curl/httpie command-line testing tools. In this activity, we will be using this tool to test the CRUD functions in our web service:</p>
			<ol>
				<li value="1">Create a request in Postman and get all the recipes.</li>
				<li>Use a <strong class="inline">POST</strong> request to create a recipe.</li>
				<li>Create a request to get all the recipes.</li>
				<li>Send an update request to modify the recipe that we have just created.</li>
				<li>Send a request to get a specific recipe.</li>
				<li>Send a request to search for a recipe that doesn't exist.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 286.</p></li>
			</ol>
			<p>If your application passed the test, congratulations! It is a pretty solid implementation.</p>
			<h3 id="_idParaDest-36"><a id="_idTextAnchor040"/>Exercise 4: Automated Testing Using Postman</h3>
			<p>In this exercise, we would like to show you how we can use Postman as a powerful automatic testing tool. An automatic testing tool allows us to repeatedly send requests to the APIs, thus achieve testing automation. Postman allows us to do this. We can save historical requests in a collection so that you can reuse the same test cases next time:</p>
			<ol>
				<li value="1">Hover the cursor over the request; the <strong class="bold">Save Request</strong> button will appear:<div id="_idContainer025" class="IMG---Figure"><img src="image/C15309_01_11.jpg" alt="Figure 1.11: Saving the request&#13;&#10;"/></div><h6>Figure 1.11: Saving the request</h6></li>
				<li>Click on the Save Request button, and you will see a dialog box popping up, asking for more information. Type in <strong class="bold">Get all recipes</strong> for the request name and click on <strong class="bold">Create Collection</strong> at the bottom. Then, type in <strong class="bold">Basic API</strong> as the collection name and tick to confirm. Click <strong class="bold">Save to Basic API</strong>:<div id="_idContainer026" class="IMG---Figure"><img src="image/C15309_01_12.jpg" alt="Figure 1.12: Putting in information for saving the request&#13;&#10;"/></div><h6>Figure 1.12: Putting in information for saving the request</h6></li>
				<li>The collection will then be created. Now, save our request to this collection for future use. We can also click on the <strong class="bold">Collections</strong> tab to see all the requests in that collection:<div id="_idContainer027" class="IMG---Figure"><img src="image/C15309_01_13.jpg" alt="Figure 1.13: Creating the new collection&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 1.13: Creating the new collection</h6>
			<p>Now we have a bunch of saved requests in our collection. Next time, if we make any changes in our application, we can rerun these tests to make sure the previously developed APIs are still working fine. This is called regression testing in the developer community. And Postman is a simple yet powerful tool for us to perform such testing.</p>
			<h3 id="_idParaDest-37"><a id="_idTextAnchor041"/>Activity 2: Implement and Test the delete_recipe Function</h3>
			<p>Now we have a basic understanding of how to implement the API. We have coded the create and update recipe functions. In this activity, you will implement the <strong class="inline">delete_recipe</strong> function yourself. </p>
			<p>You have learned about both the command-line and GUI testing tools. You will test the application using these tools after the implementation. This is what you need to do:</p>
			<ol>
				<li value="1">Implement a <strong class="inline">delete_recipe</strong> function in <strong class="inline">app.py</strong> that can delete a specific recipe. Create the API endpoint accordingly.</li>
				<li>Start the application, make it ready for testing.</li>
				<li>Use httpie or curl to delete the recipe with <strong class="inline">ID = 1</strong>.</li>
				<li>Use Postman to delete the recipe with <strong class="inline">ID = 2</strong>.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 291.</p></li>
			</ol>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor042"/>Summary</h2>
			<p>In this chapter, we have built a basic RESTful API using Flask. We did CRUD (Create, Read, Update, Delete) operations on our recipes, and through this, you should have grasped the concepts and fundamentals of APIs. We have also talked about relevant concepts, such as HTTP methods, HTTP status codes, JSON, and routing. We wrapped up the chapter by showing you different ways (command prompt, GUI) to test the web services that we have built.</p>
			<p>After laying a good foundation, in the next chapter, we will continue to develop our recipe sharing platform step by step. You will learn the whole process of RESTful API development. Just stay with us, the best is yet to come!</p>
		</div>
	</body></html>