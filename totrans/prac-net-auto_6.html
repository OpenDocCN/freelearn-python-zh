<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Continuous Integration for Network Engineers</h1>
                </header>
            
            <article>
                
<p>As we saw in previous chapters, now armed with knowledge or a fair understanding on creating automation using various techniques, working with Ansible, and understanding best practices, we continue our journey to understand how to work on the basics of planning an automation project.</p>
<p>In this chapter, we will see some of the tools that help us in working on planning our automation projects, and some examples to interact with some increasingly complex scenarios related to various devices or network technologies.</p>
<p>Some of the aspects that we will be working on are:</p>
<ul>
<li>Interaction with Splunk</li>
<li>BGP and routing table</li>
<li>Wireless client to AP to switchport</li>
<li>Phone to switchport</li>
<li>WLAN and IPAM</li>
<li>Useful best practices and use cases</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interaction with Splunk</h1>
                </header>
            
            <article>
                
<p><strong>Splunk</strong> is one of the most widely used data mining tools. With its data mining and digging capabilities, engineers can take actions based upon decisions. While it is useful in various aspects, here we will see an example of Splunk being used as a Syslog server, with our test router sending a message (as syslog) to this server, and how from automation we can query results from Splunk for these syslogs and take actions.</p>
<p>This is an important part of automation, since based upon certain events (alerts and syslogs), engineers need to perform automated tasks, like self healing, or even triggering emails or using third-party tools to create tickets for various teams to work on.</p>
<p>Here we will see the basic implementation and configuration of Splunk as a Syslog server:</p>
<ol>
<li><strong> </strong>After downloading and installing Splunk , it can be accessed from the URL <kbd>http://localhost:8000/en-US/account/login?return_to=%2Fen-US%2F</kbd> as we can see in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6189c067-0a4c-4106-975c-4c5bd66d2d42.jpg" style="width:65.92em;height:35.08em;"/></div>
<ol start="2">
<li>Once we login, we create a listener listed to syslogs (in our case we use the <kbd>TCP</kbd> protocol and keep the default port <kbd>514</kbd> open):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/48cc657b-392a-4a50-b50b-72a47dab1d87.jpg" style="width:79.67em;height:32.42em;"/></div>
<p> </p>
<p style="padding-left: 60px">Once the configuration is done for TCP port <kbd>514</kbd> on Splunk (listening for syslog messages), ensure any local firewall on the server is allowing inbound packets to TCP port <kbd>514</kbd>, and our machine is ready to access syslogs from network devices on TCP port <kbd>514</kbd>).</p>
<ol start="3">
<li>Configure the router to send syslogs. We apply the following commands on the router to enable logging (In our case the IP for the Syslog server is <kbd>192.168.255.250</kbd><span>):</span></li>
</ol>
<pre style="padding-left: 90px"><strong>config t</strong><br/><strong>logging host 192.168.255.250 transport tcp port 514</strong><br/><strong>logging buffered informational</strong><br/><strong>exit</strong></pre>
<p style="padding-left: 60px">This configures the router to send syslogs to the given IP address on TCP protocol over port <kbd>514</kbd>. Additionally, we are also stating to log only information syslog messages on the router.</p>
<ol start="4">
<li>Once done, for confirmation we can try to perform a shutdown and no shutdown of any interface (<kbd>Loopback0</kbd> in our case), and see the log using the <kbd>show logging</kbd> command on the router:</li>
</ol>
<pre style="padding-left: 90px"><strong>R2#show logging</strong><br/><strong>Syslog logging: enabled (11 messages dropped, 0 messages rate-limited,</strong><br/><strong>                0 flushes, 0 overruns, xml disabled, filtering disabled)</strong><br/><strong>    Console logging: level debugging, 26 messages logged, xml disabled,</strong><br/><strong>                     filtering disabled</strong><br/><strong>    Monitor logging: level debugging, 0 messages logged, xml disabled,</strong><br/><strong>                     filtering disabled</strong><br/><strong>    Buffer logging: level informational, 7 messages logged, xml disabled,</strong><br/><strong>                    filtering disabled</strong><br/><strong>    Logging Exception size (4096 bytes)</strong><br/><strong>    Count and timestamp logging messages: disabled</strong><br/><strong>No active filter modules.</strong><br/><strong>    Trap logging: level informational, 30 message lines logged</strong><br/><strong>        Logging to 192.168.255.250(global) (tcp port 514,audit disabled, link up), 30 message lines logged, xml disabled,</strong><br/><strong>               filtering disabled</strong><br/><strong>Log Buffer (4096 bytes):</strong><br/><strong>*Mar  1 01:02:04.223: %SYS-5-CONFIG_I: Configured from console by console</strong><br/><strong>*Mar  1 01:02:10.275: %SYS-6-LOGGINGHOST_STARTSTOP: Logging to host 192.168.255.250 started - reconnection</strong><br/><strong>*Mar  1 01:02:32.179: %LINK-5-CHANGED: Interface Loopback0, changed state to administratively down</strong><br/><strong>*Mar  1 01:02:33.179: %LINEPROTO-5-UPDOWN: Line protocol on Interface Loopback0, changed state to down</strong><br/><strong>*Mar  1 01:02:39.303: %SYS-5-CONFIG_I: Configured from console by console</strong><br/><strong>*Mar  1 01:02:39.647: %LINK-3-UPDOWN: Interface Loopback0, changed state to up</strong><br/><strong>*Mar  1 01:02:40.647: %LINEPROTO-5-UPDOWN: Line protocol on Interface Loopback0, changed state to up</strong><br/><br/></pre>
<p style="padding-left: 60px">An important aspect to confirm if the router is sending syslogs is the line <kbd>tcp port 514, audit disabled, link up</kbd>, which confirms that the router is sending syslog traffic to the Syslog server.</p>
<ol start="5">
<li>Here is the raw output on Splunk for the syslog that is generated:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f9db7f5d-5a30-444b-a201-d60a95547b3f.jpg" style="width:63.08em;height:29.50em;"/></div>
<p style="padding-left: 60px">As we see in the <span class="packt_screen">New Search</span> section we can write queries to fetch the exact data that we want. In our case we wanted to see only the log from our router with the <kbd>Interface Loopback0</kbd> down messages, hence we wrote the query:</p>
<pre style="padding-left: 90px">host="192.168.255.248" "Interface Loopback0, changed state to down"</pre>
<ol start="6">
<li>Now let us see the code from Python that we can write to fetch the same information using a script:</li>
</ol>
<pre style="padding-left: 90px">import requests<br/>import json<br/>from xml.dom import minidom<br/><br/>username="admin"<br/>password="admin"<br/><br/>### For generating the session key ####<br/>url = 'https://localhost:8089/services/auth/login'<br/>headers = {'Content-Type': 'application/json'}<br/>data={"username":username,"password":password}<br/>requests.packages.urllib3.disable_warnings()<br/>r = requests.get(url, auth=(username, password), data=data, headers=headers,verify=False)<br/>sessionkey = minidom.parseString(r.text).getElementsByTagName('sessionKey')[0].childNodes[0].nodeValue<br/><br/>#### For executing the query using the generated sessionkey<br/>headers={"Authorization":"Splunk "+sessionkey}<br/>data={"search":'search host="192.168.255.248" "Interface Loopback0, changed state to down"',"output_mode":"json"}<br/>r=requests.post('https://localhost:8089/servicesNS/admin/search/search/jobs/export',data=data , headers=headers,verify=False);<br/>print (r.text)</pre>
<p style="padding-left: 60px">In the first section, we query the API of Splunk to fetch the authentication session key (or token) to run our queries and get results. Once we have the session key (extracted from the XML output), we create a header and using <kbd>requests.post</kbd> we execute our query. The data variable contains our query in the following format:</p>
<pre style="padding-left: 90px">{"search":'search host="192.168.255.248" "Interface Loopback0, changed state to down"'}</pre>
<p style="padding-left: 60px">In other words, if we take this in a variable (named <kbd>Search</kbd>) , and provide the result as a value to that variable, it would look like below:</p>
<pre style="padding-left: 90px">Search='search host="192.168.255.248" "Interface Loopback0, changed state to down"'</pre>
<p style="padding-left: 60px">Additionally we also send another option of <kbd>output_mode</kbd> as JSON , since we want the output in JSON (some other values can be CSV or XML).</p>
<p style="padding-left: 60px">Executing the same will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/283d1561-ade0-447d-a192-5d72952d8d63.jpg" style="width:121.33em;height:31.33em;"/></div>
<p style="padding-left: 60px">As we see in the preceding output, we are now retrieving and displaying the value in JSON format.</p>
<p>We will stop our example here, but to enhance this script, this result can now become a trigger on which we can add additional methods or logic to decide on the trigger for further actions. By this logic, we can have self-healing scripts that find out the data (as a trigger), evaluate the trigger (identify it actionable), and take actions based upon further logic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automation examples on various technology domains</h1>
                </header>
            
            <article>
                
<p>With the familiarity and understanding of automation with the interaction of devices, APIs, controllers, let's see some examples of how to interact with other network domain devices and tackle some complex scenarios using automation frameworks.</p>
<div class="packt_infobox">Some of these examples will be a small project in themselves, but will help you understand additional ways of performing automation tasks <span>in depth</span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BGP and routing table</h1>
                </header>
            
            <article>
                
<p>Let's take an example in which we need to configure BGP, validate if a session is up, and report the details for the same. In our example, we would take two routers (as a prerequisite, both routers are able to ping each other) as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ebb2b169-6f26-4d3d-bbd7-e562af417b5d.jpg" style="width:78.92em;height:25.58em;"/></div>
<p>As we see <kbd>R2</kbd> and <kbd>testrouter</kbd> are able to ping each other using an IP address of the <kbd>FastEthernet0/0</kbd> <span>interface </span>of each other.</p>
<p>The next step is a very basic configuration of BGP (in our case, we use the <span><strong>Autonomous System</strong> (</span><strong>AS</strong>) number <kbd>200</kbd>). The code is as follows:</p>
<pre>from netmiko import ConnectHandler<br/>import time<br/><br/>def pushbgpconfig(routerip,remoteip,localas,remoteas,newconfig="false"):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds=""<br/>    cmds="router bgp "+localas<br/>    cmds=cmds+"\n neighbor "+remoteip+" remote-as "+remoteas<br/>    xcheck=device.send_config_set(cmds)<br/>    print (xcheck)<br/>    outputx=device.send_command("wr mem")<br/>    print (outputx)<br/>    device.disconnect()<br/><br/><br/>def validatebgp(routerip,remoteip):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="show ip bgp neighbors "+remoteip+" | include BGP state"<br/>    outputx=device.send_command(cmds)<br/>    if ("Established" in outputx):<br/>        print ("Remote IP "+remoteip+" on local router "+routerip+" is in ESTABLISHED state")<br/>    else:<br/>        print ("Remote IP "+remoteip+" on local router "+routerip+" is NOT IN ESTABLISHED state")<br/>    device.disconnect()<br/>    <br/>pushbgpconfig("192.168.255.249","192.168.255.248","200","200")<br/>### we give some time for bgp to establish<br/>print ("Now sleeping for 5 seconds....")<br/>time.sleep(5) # 5 seconds<br/>validatebgp("192.168.255.249","192.168.255.248")</pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2b09e0f2-6f5d-40c9-83b2-2cf218026f39.jpg" style="width:39.83em;height:16.58em;"/></div>
<p>As we see, we push the neighbor config (BGP config) to the router. Once the config is pushed, the script waits for 5 seconds and validates the state of BGP if it is in the <kbd>ESTABLISHED state</kbd>. This validation <span>confirms that the config that we pushed has all the sessions that are newly configured as established.</span></p>
<p><span>Let's push an incorrect config as follows:</span></p>
<pre>from netmiko import ConnectHandler<br/>import time<br/>def pushbgpconfig(routerip,remoteip,localas,remoteas,newconfig="false"):<br/> uname="cisco"<br/> passwd="cisco"<br/> device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/> cmds=""<br/> cmds="router bgp "+localas<br/> cmds=cmds+"\n neighbor "+remoteip+" remote-as "+remoteas<br/> xcheck=device.send_config_set(cmds)<br/> print (xcheck)<br/> outputx=device.send_command("wr mem")<br/> print (outputx)<br/> device.disconnect()<br/>def validatebgp(routerip,remoteip):<br/> uname="cisco"<br/> passwd="cisco"<br/> device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/> cmds="show ip bgp neighbors "+remoteip+" | include BGP state"<br/> outputx=device.send_command(cmds)<br/> if ("Established" in outputx):<br/> print ("Remote IP "+remoteip+" on local router "+routerip+" is in ESTABLISHED state")<br/> else:<br/> print ("Remote IP "+remoteip+" on local router "+routerip+" is NOT IN ESTABLISHED state")<br/> device.disconnect()<br/> <br/>pushbgpconfig("192.168.255.249","192.168.255.248","200","400")<br/>### we give some time for bgp to establish<br/>print ("Now sleeping for 5 seconds....")<br/>time.sleep(5) # 5 seconds<br/>validatebgp("192.168.255.249","192.168.255.248")</pre>
<p>The output of the preceding code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/05566bbc-1697-444a-a402-d9d243fe5fb1.jpg" style="width:44.67em;height:18.50em;"/></div>
<p>As we see in the preceding output, now we are pushing the config with an incorrect remote (<kbd>400</kbd> in this case). Of course, since the config is not correct, we get a non-established message, which confirms that the config that we pushed was not correct. In a similar way, we can push the bulk of the configs by calling the methods as many times as we want for each of the remote neighbors to be configured. Additionally, sometimes we need to get specific information under certain config sections from a running config.</p>
<p>As an example, the following code will give out a list for each section of the running config:</p>
<pre>from netmiko import ConnectHandler<br/>import itertools<br/><br/>class linecheck:<br/>    def __init__(self):<br/>        self.state = 0<br/>    def __call__(self, line):<br/>        if line and not line[0].isspace():<br/>            self.state += 1<br/>        return self.state<br/><br/>def getbgpipaddress(routerip):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="show running-config"<br/>    outputx=device.send_command(cmds)<br/>    device.disconnect()<br/>    for _, group in itertools.groupby(outputx.splitlines(), key=linecheck()):<br/>        templist=list(group)<br/>        if (len(templist) == 1):<br/>            if "!" in str(templist):<br/>                continue <br/>        print(templist)<br/><br/><br/>getbgpipaddress("192.168.255.249")</pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1e49b5a2-ae3e-4771-9e99-8e62aa110650.jpg" style="width:57.75em;height:37.67em;"/></div>
<p>As we see in the preceding output, we got all the sections of the running config, except the exclamation mark <kbd>!</kbd> that we see in a running config (executing the router command <kbd>show running-config</kbd> on router). The focus of this output is that we have a config that is now parsed for each section in running config grouped in a single list, or in other words, a specific set of configs meant for a specific section (such as an interface or BGP) is grouped in a single list.</p>
<p>Lets enhance this code. As an example, we only want to see what BGP remote IPs are configured in our router:</p>
<pre>from netmiko import ConnectHandler<br/>import itertools<br/>import re<br/><br/>class linecheck:<br/>    def __init__(self):<br/>        self.state = 0<br/>    def __call__(self, line):<br/>        if line and not line[0].isspace():<br/>            self.state += 1<br/>        return self.state<br/><br/>def getbgpipaddress(routerip):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="show running-config"<br/>    outputx=device.send_command(cmds)<br/>    device.disconnect()<br/>    for _, group in itertools.groupby(outputx.splitlines(), key=linecheck()):<br/>        templist=list(group)<br/>        if (len(templist) == 1):<br/>            if "!" in str(templist):<br/>                continue <br/>        if "router bgp" in str(templist):<br/>            for line in templist:<br/>                if ("neighbor " in line):<br/>                    remoteip=re.search("\d+.\d+.\d+.\d+",line)<br/>                    print ("Remote ip: "+remoteip.group(0))<br/><br/><br/>getbgpipaddress("192.168.255.249")</pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b1e683e7-edb6-4137-a417-79e60ff63dfb.jpg" style="width:52.25em;height:12.83em;"/></div>
<p>In this case, first we parse the running config and focus on the section which has the <kbd>router bgp</kbd> config. Once we get to that particular list, we parse the list and fetch the remote IP using the regex on the specific command that contains the string <kbd>neighbor</kbd><strong>. </strong>The result values would be the remote IPs under the BGP section.</p>
<p>As we are working with BGP, the AS numbers, being an integral part of BGP, need to be parsed or validated. Using the preceding strategies, we can get the AS numbers for BGP routes/prefixes, but in addition to that, there is a Python library <kbd>pyasn</kbd> that can easily find out AS number information for a given public IP address.</p>
<p>Again, as mentioned earlier, we need to install the following library <span>before we can call it in the code, by</span> using: </p>
<pre><strong>pip install cymruwhois</strong></pre>
<p>The code is as follows:</p>
<pre>import socket<br/><br/>def getfromhostname(hostname):<br/>    print ("AS info for hostname :"+hostname)<br/>    ip = socket.gethostbyname(hostname)<br/>    from cymruwhois import Client<br/>    c=Client()<br/>    r=c.lookup(ip)<br/>    print (r.asn)<br/>    print (r.owner)<br/><br/>def getfromip(ip):<br/>    print ("AS info for IP : "+ip)<br/>    from cymruwhois import Client<br/>    c=Client()<br/>    r=c.lookup(ip)<br/>    print (r.asn)<br/>    print (r.owner)<br/><br/><br/>getfromhostname("google.com")<br/>getfromip("107.155.8.0")</pre>
<p class="mce-root">The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b63d2c78-e58e-4b92-8a4b-f26ab91884a4.jpg" style="width:43.17em;height:14.42em;"/></div>
<p>As we see, the first method <kbd>getfromhostname</kbd><strong> </strong> is used to fetch information for a given hostname. The other method <kbd>getfromip</kbd><strong> </strong>is used to fetch the same information by using an IP address instead of any hostname.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Cisco switchport for access point</h1>
                </header>
            
            <article>
                
<p>When working with a multi-device environment, along with routers and switches we need to interact with other network gear(s) like wireless devices. This example will show how to configure a switch with specific ports to be connected to <strong>Access Point</strong> (<strong>AP</strong>) as trunk. </p>
<p>In our test case, assuming the VLANs configured on AP are <kbd>vlan 100</kbd> and <kbd>vlan 200</kbd> for users, and the native VLAN is <kbd>vlan 10</kbd>, and the code is as follows:</p>
<pre>from netmiko import ConnectHandler<br/>import time<br/><br/>def apvlanpush(routerip,switchport):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="interface "+switchport<br/>    cmds=cmds+"\nswitchport mode trunk\nswitchport trunk encapsulation dot1q\n"<br/>    cmds=cmds+ "switchport trunk native vlan 10\nswitchport trunk allowed vlan add 10,100,200\nno shut\n"<br/>    xcheck=device.send_config_set(cmds)<br/>    print (xcheck)<br/>    device.disconnect()<br/><br/>def validateswitchport(routerip,switchport):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="show interface "+switchport+" switchport "<br/>    outputx=device.send_command(cmds)<br/>    print (outputx)<br/>    device.disconnect()<br/>     <br/>apvlanpush("192.168.255.245","FastEthernet2/0")<br/>time.sleep(5) # 5 seconds<br/>validateswitchport("192.168.255.245","FastEthernet2/0")<br/><br/></pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4cc9a1e3-acd6-4da8-b324-7bab8f33e431.jpg" style="width:45.42em;height:30.58em;"/></div>
<p>As we see, the AP needs to be connected to our switchport, which needs to be a trunk, with certain access VLANs to be allowed; hence we create two methods, the first of which passes router/switch name and the interfaces that needs to be configured. </p>
<p>Once the configuration is successfully pushed on the switch, we execute the <kbd>validateswitchport</kbd> method to validate if the same port is now in trunk mode. The output of the <kbd>validateswitchport</kbd><strong> </strong>method spills out the output of the command, on which we can further introduce the regex and splits to get any specific information we want from that output (such as the <kbd>Administrative Mode</kbd> or <kbd>Operational Mode</kbd>).</p>
<p>As an enhancement, we can also use the outputs from the validation method to call other methods that would perform some additional configs (if required), based on the result that we got earlier. (For example, changing the <kbd>Trunking Native Mode VLAN</kbd> to <kbd>20</kbd>).</p>
<p>Let's see the new code with the additional enhancement of changing the native VLAN to <kbd>20</kbd>. The code is as follows<strong>:</strong></p>
<pre>from netmiko import ConnectHandler<br/>import time<br/><br/>def apvlanpush(routerip,switchport):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="interface "+switchport<br/>    cmds=cmds+"\nswitchport mode trunk\nswitchport trunk encapsulation dot1q\n"<br/>    cmds=cmds+ "switchport trunk native vlan 10\nswitchport trunk allowed vlan add 10,100,200\nno shut\n"<br/>    xcheck=device.send_config_set(cmds)<br/>    print (xcheck)<br/>    device.disconnect()<br/><br/>def validateswitchport(routerip,switchport):<br/>    print ("\nValidating switchport...."+switchport)<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="show interface "+switchport+" switchport "<br/>    outputx=device.send_command(cmds)<br/>    print (outputx)<br/>    outputx=outputx.split("\n")<br/>    for line in outputx:<br/>        if ("Trunking Native Mode VLAN: 10" in line):<br/>            changenativevlan(routerip,switchport,"20")<br/>    device.disconnect()<br/><br/>def changenativevlan(routerip,switchport,nativevlan):<br/>    print ("\nNow changing native VLAN on switchport",switchport)<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="interface "+switchport<br/>    cmds=cmds+"\nswitchport trunk native vlan "+nativevlan+"\n"<br/>    xcheck=device.send_config_set(cmds)<br/>    print (xcheck)<br/>    validateswitchport(routerip,switchport)<br/>    device.disconnect()<br/>     <br/>apvlanpush("192.168.255.245","FastEthernet2/0")<br/>time.sleep(5) # 5 seconds<br/>validateswitchport("192.168.255.245","FastEthernet2/0")</pre>
<p>The output is explained in two sections as follows:</p>
<ul>
<li>Validating and changing the native VLAN to <kbd>20</kbd>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d58b4964-2880-4582-bbc9-a508d4beecf7.jpg" style="width:34.83em;height:31.83em;"/></div>
<ul>
<li>Revalidating with the new native VLAN number:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6d76c4ee-47da-4b36-8e6e-95e316fd34c0.jpg" style="width:35.50em;height:21.17em;"/></div>
<p>As we see in the final validation, now we have a native VLAN 20, instead of the earlier <kbd>10</kbd>. This is also a good troubleshooting technique as in multiple scenarios there are requirements of a <strong>what if analysis</strong> (to take decisions based upon the evaluation of a certain condition)<strong> </strong>in which we need to take some actions based on the dynamic results received. Since, here in our code we validated that the native VLAN needs to be <kbd>20</kbd>, hence we performed another action to correct that earlier config.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Cisco switchport for IP Phone</h1>
                </header>
            
            <article>
                
<p>Similar to the earlier scenario, where we want a switchport as a trunk port for AP, we can configure the switchport to work with IP Phones. An additional task for configuring a port to be used as IP Phone is that another end machine or data machine can be connected to the IP Phone for data transfer. In other words, a single switchport of a Cisco router can act as both a voice and data port when used with IP Phone.</p>
<p>Let's see an example of configuring a switchport to act as an IP Phone port:</p>
<pre>from netmiko import ConnectHandler<br/>import time<br/><br/>def ipphoneconfig(routerip,switchport):<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="interface "+switchport<br/>    cmds=cmds+"\nswitchport mode access\nswitchport access vlan 100\n"<br/>    cmds=cmds+ "switchport voice vlan 200\nspanning-tree portfast\nno shut\n"<br/>    xcheck=device.send_config_set(cmds)<br/>    print (xcheck)<br/>    device.disconnect()<br/><br/>def validateswitchport(routerip,switchport):<br/>    print ("\nValidating switchport...."+switchport)<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=routerip, username=uname, password=passwd)<br/>    cmds="show interface "+switchport+" switchport "<br/>    outputx=device.send_command(cmds)<br/>    print (outputx)<br/>    outputx=outputx.split("\n")<br/>    for line in outputx:<br/>        if ("Trunking Native Mode VLAN: 10" in line):<br/>            changenativevlan(routerip,switchport,"20")<br/>    device.disconnect()<br/>     <br/>ipphoneconfig("192.168.255.245","FastEthernet2/5")<br/>time.sleep(5) # 5 seconds<br/>validateswitchport("192.168.255.245","FastEthernet2/5")<br/><br/></pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1bae28c5-6d1f-49f4-a7f5-a14a71f984c4.jpg" style="width:43.92em;height:36.58em;"/></div>
<p>As we see now, the port configured (<kbd>FastEthernet 2/5</kbd>) has been assigned a <kbd>Voice VLAN</kbd> of <kbd>200</kbd> and a data/access VLAN of <kbd>100</kbd> (from the preceding output, notice the line <kbd>Access Mode VLAN: 100 (VLAN0100)</kbd>. Any IP Phone connecting to this port will have access to both the VLANs for its voice and data usage. Again, going by previous examples, we can perform additional validations and checks on the ports and trigger some actions in case of any incorrect or missing configs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wireless LAN (WLAN)</h1>
                </header>
            
            <article>
                
<p>There are many vendors that have backend APIs that can be controlled or called using Python to perform certain wireless tasks. A commonly used vendor in wireless is <kbd>Netgear</kbd>. Python has a library <kbd>pynetgear</kbd> that helps us achieve some of the automation to control our locally connected devices. </p>
<p>Let's see an example of fetching the current network devices connected to the local wireless Netgear router in our network:</p>
<pre>&gt;&gt;&gt; from pynetgear import Netgear, Device<br/>&gt;&gt;&gt; netgear = Netgear("myrouterpassword", "192.168.100.1","admin","80")<br/>&gt;&gt;&gt; for i in netgear.get_attached_devices():<br/>  print (i)</pre>
<p class="mce-root">The <kbd>Netgear</kbd> method accepts four arguments in the following order (<kbd>routerpassword</kbd>, <kbd>routerip</kbd>, <kbd>routerusername</kbd>, and <kbd>routerport</kbd>). As we see in the current example, the router is reachable using <kbd>http://192.168.100.1</kbd> with the username <kbd>admin</kbd> and password as <kbd>myrouterpassword</kbd>. Hence, we call the method with these parameters.</p>
<p>The output is shown as follows:</p>
<pre class="mce-root"><strong>&gt;&gt;&gt; netgear.get_attached_devices()</strong><br/><strong>[Device(signal=3, ip='192.168.100.4', name='ANDROID-12345', mac='xx:xx:xx:xx:xx:xx', type='wireless', link_rate=72), Device(signal=None, ip='192.168.100.55', name='ANDROID-678910', mac='yy:yy:yy:yy:yy:yy', type='wireless', link_rate=72), Device(signal=None, ip='192.168.100.10', name='mylaptop', mac='zz:zz:zz:zz:zz:zz', type='wireless', link_rate=520)]</strong></pre>
<p class="mce-root">As we see, the method <kbd>get_attached_devices()</kbd> returned a list of all the IPs, their MAC addresses (hidden in this example), signal (or wireless band being used), and the link rate for the connection in Mbps.</p>
<p>We can use similar type of methods to manipulate bandwidth, block any user, or perform other tasks that are exposed by the APIs of the specific hardware manufacturer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Access of IP Address Management (IPAM)</h1>
                </header>
            
            <article>
                
<p>Another requirement in networking is to use the IPAM database for IPAM. It is provided by different vendors, and as an example here, we would refer to SolarWind's IPAM. SolarWinds is again an industry standard tool for monitoring and performing various functionalities on a network, and it has a good set of APIs to interact with using its ORION SDK toolkit.</p>
<p>In Python, we can install the library <kbd>orionsdk</kbd> to achieve interaction with SolarWinds. Let's see an example in which we fetch the next available IP address from the IPAM module in SolarWinds:</p>
<pre>from orionsdk import SwisClient<br/><br/>npm_server = 'mysolarwindsserver'<br/>username = "test"<br/>password = "test"<br/><br/>verify = False<br/>if not verify:<br/>    from requests.packages.urllib3.exceptions import InsecureRequestWarning<br/>    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)<br/><br/>swis = SwisClient(npm_server, username, password)<br/><br/>print("My IPAM test:")<br/>results=swis.query("SELECT TOP 1 Status, DisplayName FROM IPAM.IPNode WHERE Status=2")<br/>print (results)<br/><br/>### for a formatted printing<br/>for row in results['results']:<br/> print("Avaliable: {DisplayName}".format(**row))<br/><br/></pre>
<p class="mce-root CDPAlignLeft CDPAlign">The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img style="text-align: center;color: #333333;font-size: 1em;width:37.83em;height:11.58em;" src="assets/30c86818-98c1-4e5a-9894-a43b9f844821.jpg"/></div>
<p>As we see in the preceding code, we use the <kbd>orionsdk</kbd> library to call the API for SolarWinds from the <kbd>mysolarwindsserver</kbd><strong> </strong><span>server.</span><strong> </strong>The username and password needed for the SolarWinds are passed in script, and we use a simple SQL query (which is understandable by SolarWinds) which is as follows:</p>
<pre> SELECT TOP 1 Status, DisplayName FROM IPAM.IPNode  WHERE Status=2 </pre>
<p>This query fetches the next available IP address (denoted by <kbd>Status=2</kbd> in SolarWinds) and prints it. The first print is the raw print and the one in <kbd>for</kbd> loop; it prints out the value in a better understandable format as shown in the preceding output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example and use case</h1>
                </header>
            
            <article>
                
<p>Here, we will see a detailed example that is common to most network engineers, and how to automate it using Python. Also, we will create it as a web based tool, enabling it to run from any environment or machine, using only a browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create a web-based pre and post check tool for validations</h1>
                </header>
            
            <article>
                
<p>In the following example, we will see how we can perform a pre and post check on any network maintenance that we do. This is generally required by every network engineer while performing activities on production devices to ensure that once the maintenance activity is complete, an engineer has not missed out anything that could cause an issue later on. It is also required to validate if our changes and maintenance have been completed successfully, or if we need to perform additional fixes and rollbacks in case of validations that have failed.</p>
<p>The following are the steps to create and execute the tool:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 1 – Create the main HTML file</h1>
                </header>
            
            <article>
                
<p>We will design a web-based form to select certain show commands that we will call for performing checks. These commands, when executed, will act as a precheck; once our maintenance activity is complete, we will act again as a postcheck.</p>
<p>Any difference between the same command outputs in precheck or postcheck scenarios will be highlighted and the engineer will be in a good position to make decisions on calling the maintenance a success or failure, based on the outputs.</p>
<p>The HTML code (<kbd>prepostcheck.html</kbd>) is as follows:</p>
<pre style="padding-left: 60px">&lt;!DOCTYPE html&gt;<br/><br/>&lt;html &gt;<br/>&lt;head&gt;<br/>         &lt;script&gt;<br/>             function checkme() {<br/>        var a=document.forms["search"]["cmds"].value;<br/>        var b=document.forms["search"]["searchbox"].value;<br/>        var c=document.forms["search"]["prepost"].value;<br/>        var d=document.forms["search"]["changeid"].value;<br/>        if (a==null || a=="")<br/>        {<br/>          alert("Please Fill All Fields");<br/>          return false;<br/>        }<br/>        if (b==null || b=="")<br/>        {<br/>          alert("Please Fill All Fields");<br/>          return false;<br/>        }<br/>        if (c==null || c=="")<br/>        {<br/>          alert("Please Fill All Fields");<br/>          return false;<br/>        }<br/>        if (d==null || d=="")<br/>        {<br/>          alert("Please Fill All Fields");<br/>          return false;<br/>        }<br/>                 document.getElementById("mypoint").style.display = "inline";<br/>             }<br/>&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h2&gt; Pre/Post check selection &lt;/h2&gt;<br/>&lt;form name="search" action="checks.py" method="post" onsubmit="return checkme()"&gt;<br/>Host IP: (Multiple IPs seperated by comma)&lt;br&gt;&lt;input type="text" name="searchbox" size='80' required&gt;<br/>&lt;p&gt;&lt;/p&gt;<br/>Commands (Select):<br/>&lt;br&gt;<br/>&lt;select name="cmds" multiple style="width:200px;height:200px;" required&gt;<br/>  &lt;option value="show version"&gt;show version&lt;/option&gt;<br/>  &lt;option value="show ip int brief"&gt;show ip int brief&lt;/option&gt;<br/>  &lt;option value="show interface description"&gt;show interface description&lt;/option&gt;<br/>  &lt;option value="show clock"&gt;show clock&lt;/option&gt;<br/>  &lt;option value="show log"&gt;show log (last 100)&lt;/option&gt;<br/>  &lt;option value="show run"&gt;show run&lt;/option&gt;<br/>  &lt;option value="show ip bgp summary"&gt;show ip bgp summary&lt;/option&gt;<br/>  &lt;option value="show ip route"&gt;show ip route&lt;/option&gt;<br/>  &lt;option value="show ip route summary"&gt;show ip route summary&lt;/option&gt;<br/>  &lt;option value="show ip ospf"&gt;show ip ospf&lt;/option&gt;<br/>  &lt;option value="show interfaces status"&gt;show interfaces status&lt;/option&gt;<br/>  <br/>&lt;/select&gt;<br/>&lt;p&gt;&lt;/p&gt;<br/>Mantainence ID: &lt;input type="text" name="changeid" required&gt;<br/>&lt;p&gt;&lt;/p&gt;<br/>Pre/Post: &lt;br&gt;<br/>&lt;input type="radio" name="prepost" value="pre" checked&gt; Precheck&lt;br&gt;<br/>&lt;input type="radio" name="prepost" value="post"&gt; Postcheck&lt;br&gt;<br/>&lt;p&gt;&lt;/p&gt;<br/>&lt;input type="submit" value="Submit"&gt;<br/>&lt;br&gt;&lt;br&gt;&lt;br&gt;<br/>&lt;/form&gt; <br/>&lt;p&gt;&lt;label id="mypoint" style="display: none;background-color: yellow;"&gt;&lt;b&gt;Please be Patient.... Gathering results!!!&lt;/b&gt;&lt;/label&gt;&lt;/p&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>This will create the main page on which we select our initial options (set of commands and if we need to perform a precheck or a postcheck). The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/863b56f6-127a-4ea6-8b8a-abf74b0c3f57.jpg" style="width:34.83em;height:30.17em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span>Main page</span></div>
<p>An additional JavaScript code in HTML ensures that the <kbd>Submit</kbd> button will not send any data until all the selections are made. There is no point sending data which is not completed; for example, if we do not fill out entire fields the <kbd>Submit</kbd> option will not proceed, giving out the message that we see in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e02900d3-19d7-47d4-9b71-97a111443d7a.jpg" style="width:34.75em;height:28.92em;"/></div>
<p>Unless all the fields are not filled, hitting the <kbd>Submit</kbd> button will spill out this message and the code will not continue. Additionally, as we see in the code, the <kbd>Submit</kbd> button is tied to the Python script, with <kbd>checks.py</kbd><strong> </strong>as a POST method. In other words, the selections we will make will be sent to <kbd>checks.py</kbd> as a POST method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 2 – Create the backend Python code</h1>
                </header>
            
            <article>
                
<p>Now, let's see the back end Python code (<kbd>checks.py</kbd>)<strong> </strong>that will accept these inputs from HTML form and perform its task. The code is as follows:</p>
<pre>#!/usr/bin/env python<br/>import cgi<br/>import paramiko<br/>import time<br/>import re<br/>import sys<br/>import os<br/>import requests<br/>import urllib<br/>import datetime<br/>from datetime import datetime<br/>from threading import Thread<br/>from random import randrange<br/><br/>form = cgi.FieldStorage()<br/>searchterm = form.getvalue('searchbox')<br/>cmds = form.getvalue('cmds')<br/>changeid = form.getvalue('changeid')<br/>prepost=form.getvalue('prepost')<br/>searchterm=searchterm.split(",")<br/>xval=""<br/>xval=datetime.now().strftime("%Y-%m-%d_%H_%M_%S")<br/><br/>returns = {}<br/>def getoutput(devip,cmd):<br/>    try:<br/>        output=""<br/>        mpath="C:/iistest/logs/"<br/>        fname=changeid+"_"+devip+"_"+prepost+"_"+xval+".txt"<br/>        fopen=open(mpath+fname,"w")<br/>        remote_conn_pre = paramiko.SSHClient()<br/>        remote_conn_pre.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br/>        remote_conn_pre.connect(devip, username='cisco', password='cisco', look_for_keys=False, allow_agent=False)<br/>        remote_conn = remote_conn_pre.invoke_shell()<br/>        remote_conn.settimeout(60)<br/>        command=cmd<br/>        remote_conn.send(command+"\n")<br/>        time.sleep(15)<br/>        output=(remote_conn.recv(250000)).decode()<br/>        fopen.write(output)<br/>        remote_conn.close()<br/>        fopen.close()<br/>        returns[devip]=("Success: &lt;a href='http://localhost/test/logs/"+fname+"' target='_blank'&gt;"+fname +"&lt;/a&gt; Created")<br/>    except:<br/>        returns[devip]="Error. Unable to fetch details"<br/><br/>try:<br/>    xtmp=""<br/>    cmdval="terminal length 0\n"<br/>    if (str(cmds).count("show") &gt; 1):<br/>        for cmdvalue in cmds:<br/>            if ("show" in cmdvalue):<br/>                if ("show log" in cmdvalue):<br/>                    cmdvalue="terminal shell\nshow log | tail 100"<br/>                cmdval=cmdval+cmdvalue+"\n\n"<br/>    else:<br/>        if ("show" in cmds):<br/>            if ("show log" in cmds):<br/>                cmds="terminal shell\nshow log | tail 100"<br/>            cmdval=cmdval+cmds+"\n\n"<br/>    threads_imagex= []<br/>    for devip in searchterm:<br/>        devip=devip.strip()<br/>        t = Thread(target=getoutput, args=(devip,cmdval,))<br/>        t.start()<br/>        time.sleep(randrange(1,2,1)/20)<br/>        threads_imagex.append(t)<br/>    <br/>    for t in threads_imagex:<br/>        t.join()<br/>        <br/>    print("Content-type: text/html")<br/>    print()<br/>    xval=""<br/>    for key in returns:<br/>        print ("&lt;b&gt;"+key+"&lt;/b&gt;:"+returns[key]+"&lt;br&gt;")<br/>        <br/>    print ("&lt;br&gt;Next step: &lt;a href='http://localhost/test/selectfiles.aspx'&gt; Click here to compare files &lt;/a&gt;")<br/>    print ("&lt;br&gt;Next step: &lt;a href='http://localhost/test/prepostcheck.html'&gt; Click here to perform pre/post check &lt;/a&gt;")<br/><br/>except:<br/>    print("Content-type: text/html")<br/>    print()<br/>    print("Error fetching details. Need manual validation")<br/>    print ("&lt;br&gt;Next step: &lt;a href='http://localhost/test/selectfiles.aspx'&gt; Click here to compare files &lt;/a&gt;")<br/>    print ("&lt;br&gt;Next step: &lt;a href='http://localhost/test/prepostcheck.html'&gt; Click here to perform pre/post check &lt;/a&gt;")</pre>
<p>This code accepts input from a web page using the CGI parameter. Various values from the web page are parsed into the variables using the following code snippet:</p>
<pre>form = cgi.FieldStorage()<br/>searchterm = form.getvalue('searchbox')<br/>cmds = form.getvalue('cmds')<br/>changeid = form.getvalue('changeid')<br/>prepost=form.getvalue('prepost')</pre>
<p>Once we have these values, the additional logic is to log in into the given device(s) using the <kbd>paramiko</kbd><strong> </strong>library, fetch the output of the show commands, and save it in a file under the <kbd>logs</kbd> folder with the output. An important aspect to note here is the way we are constructing the filename:</p>
<pre>#xval=datetime.now().strftime("%Y-%m-%d_%H_%M_%S")<br/>#and<br/>#fname=changeid+"_"+devip+"_"+prepost+"_"+xval+".txt"</pre>
<p>The <kbd>fname</kbd> is the filename into which we would write the output, but the filename is built dynamically with the inputs provided by the maintenance ID, device IP, pre/post status, and the time the file was created. This is to ensure that we know the device for which we are performing a pre or a post check, and at what time the file was created, to ensure we have a correct pre and post check combination.</p>
<p>The function <kbd>getoutput()</kbd><strong> </strong>is invoked from a thread (in a multi-threaded function call) to fetch the output and store it in the newly created file. A multi-threading process is called, because if we want to perform pre or post checks in multiple devices, we can provide a comma separated IP address list in web, and Python script will in parallel invoke the show commands on all devices and create multiple pre or post check files, based on hostnames.</p>
<p>Let's create a <kbd>precheck</kbd> file for some commands in our example, where we fill in some values and click on the <kbd>Submit</kbd> button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/efa052c4-e7e6-4de3-98a0-3b9f6fe93c91.jpg" style="width:37.25em;height:37.50em;"/></div>
<div class="packt_infobox"><span>While the gathering of data is in progress, the yellow message will be displayed to confirm that the back end work is going on.</span></div>
<p>Once the task is completed, this is what we see (as returned from the Python code):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2af3ce42-fa61-4e0f-8058-70e97e9aaf3e.jpg" style="width:34.00em;height:11.42em;"/></div>
<p>As we see, the code returns a success, which means that it was able to fetch the output of the commands that we want to validate. The filename is dynamically created, based on our selection on the main page.</p>
<p>A click on the <kbd>.txt</kbd> filename that is generated as a clickable URL (which can be used to reconfirm if we got the correct output of commands we selected earlier), shows the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/18397e3a-6a6f-468f-9aef-f3107f155925.jpg" style="width:39.58em;height:28.67em;"/></div>
<p>Now, let's perform the same steps and create a <kbd>postcheck</kbd> file. </p>
<p>We go back to the main page, and keeping the other values the same, we just select the radio button to <kbd>Postcheck</kbd> instead of <kbd>Precheck</kbd>. Do ensure that we select the same set of commands, since a pre and post check only make sense if we have the same data to work with:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f4a73e82-3c55-40ad-97e0-9ab73b353a15.jpg" style="width:35.25em;height:38.92em;"/></div>
<p>In a similar way, once the backend execution completes, we have a <kbd>postcheck</kbd> file created as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9322e246-d639-4e98-a754-37296920ef84.jpg" style="width:41.25em;height:9.50em;"/></div>
<p>Notice the filename, the timestamp, and the <kbd>post</kbd><strong> </strong>word changes based on our selection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 3 – Create web server based files for the tool</h1>
                </header>
            
            <article>
                
<p>Now with the both pre and post check files created, let's create a web framework to perform web-based pre/post check for the files. We need to create a web page in which our current log files are visible as pre and post files, and we can select the <kbd>precheck</kbd> file and its relevant <kbd>postcheck</kbd> file for comparison. As we know that we cannot use HTML or browser languages to fetch information about any files from the server,  we need to use some backed web language to perform this function for us. We take advantage of ASP and VB.NET to create the web page to display the already created log files for selection and comparison.</p>
<p>The backend code for <kbd>selectfiles.aspx</kbd> is as follows (this is to display the files from the log directory on a browser):</p>
<pre>&lt;%@ Page Language="VB" AutoEventWireup="false" CodeFile="selectfiles.aspx.vb" Inherits="selectfiles" %&gt;<br/><br/>&lt;!DOCTYPE html&gt;<br/><br/>&lt;html &gt;<br/>&lt;head runat="server"&gt;<br/>    &lt;title&gt;&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;form id="form1" method="post" action="comparefiles.aspx" &gt;<br/>    &lt;div&gt;<br/>    &lt;%response.write(xmystring.tostring())%&gt;<br/>    &lt;/div&gt;<br/>         &lt;input type="submit" value="Submit"&gt;<br/>    &lt;/form&gt;<br/>  &lt;br&gt;&lt;br&gt;&lt;br&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>The VB.NET backend code, to fill in the values on the preceding <kbd>.aspx</kbd> page <kbd>selectfiles.aspx.vb</kbd>, is as follows:</p>
<pre>Imports System.IO<br/>Partial Class selectfiles<br/>    Inherits System.Web.UI.Page<br/>    Public xmystring As New StringBuilder()<br/>  Public tableval As New Hashtable<br/>    Protected Sub Page_Load(sender As Object, e As EventArgs) Handles Me.Load<br/>        Dim precheck As New List(Of String)<br/>        Dim postcheck As New List(Of String)<br/>        Dim prename = New SortedList<br/>        Dim postname = New SortedList<br/>        Dim infoReader As System.IO.FileInfo<br/>    Dim rval as Integer<br/>    rval=0<br/>    <br/>        xmystring.Clear()<br/>        Dim xval As String<br/>    Dim di As New DirectoryInfo("C:\iistest\logs\")<br/>    Dim lFiles As FileInfo() = di.GetFiles("*.txt")<br/>    Dim fi As System.IO.FileSystemInfo<br/>    Dim files() As String = IO.Directory.GetFiles("C:\iistest\logs\", "*.txt", SearchOption.TopDirectoryOnly)<br/>    xmystring.Append("&lt;head&gt;&lt;style type='text/css'&gt;a:hover{background:blue;color:yellow;}&lt;/style&gt;&lt;/head&gt;")<br/>        xmystring.Append("&lt;fieldset style='float: left;width: 49%;display: inline-block;box-sizing: border-box;'&gt;")<br/>        xmystring.Append("&lt;legend&gt;Pre check files (Sorted by Last Modified Date)&lt;/legend&gt;")<br/><br/>         For Each fi In lFiles<br/>      rval=rval+1<br/>      tableval.add(fi.LastWriteTime.ToString()+rval.tostring(),fi.Name)<br/>            'infoReader = My.Computer.FileSystem.GetFileInfo(file)<br/>            If (fi.Name.Contains("pre")) Then<br/>                precheck.Add(fi.LastWriteTime.ToString()+rval.tostring()) <br/>            Else<br/>                postcheck.Add(fi.LastWriteTime.ToString()+rval.tostring())<br/>            End If<br/>        Next<br/>        precheck.Sort()<br/>        postcheck.Sort()<br/><br/>        xval = ""<br/>        Dim prekey As ICollection = prename.Keys<br/>        Dim postkey As ICollection = postname.Keys<br/>        Dim dev As String<br/>    Dim fnameval as String<br/>        For Each dev In precheck<br/>            infoReader = My.Computer.FileSystem.GetFileInfo(tableval(dev))<br/>      fnameval="http://localhost/test/logs/"+Path.GetFileName(tableval(dev))<br/>            xval = "&lt;input type = 'radio' name='prechecklist' value='C:\iistest\logs\" + tableval(dev) + "' required&gt;&lt;a href='" &amp; fnameval &amp; "' target='blank'&gt;" &amp; tableval(dev) &amp; "&lt;/a&gt; ( &lt;b&gt;" &amp; dev.Substring(0,dev.LastIndexOf("M")).Trim() + "M&lt;/b&gt;)&lt;br&gt;"<br/>            <br/>      xmystring.Append(xval)<br/>        Next<br/>    xmystring.Append("&lt;/fieldset&gt;")<br/>           xmystring.Append("&lt;fieldset style='float: right;width: 49%;display: inline-block;box-sizing: border-box;'&gt;")<br/>        xmystring.Append("&lt;legend&gt;Post check files (Sorted by Last Modified Date)&lt;/legend&gt;")<br/>              For Each dev In postcheck<br/>      fnameval="http://localhost/test/logs/"+tableval(dev)<br/>            xval = "&lt;input type = 'radio' name='postchecklist' value='C:\iistest\logs\" + tableval(dev) + "' required&gt;&lt;a href='" &amp; fnameval &amp; "' target='blank'&gt;" &amp; tableval(dev) &amp; "&lt;/a&gt; ( &lt;b&gt;" &amp; dev.Substring(0,dev.LastIndexOf("M")).Trim() + "M&lt;/b&gt;)&lt;br&gt;"<br/>            xmystring.Append(xval)<br/>        Next<br/>        xmystring.Append("&lt;/fieldset&gt;")<br/><br/>    End Sub<br/>End Class</pre>
<p>This code is used to fetch the files from the log directory, and based on their filenames, they are divided into either <kbd>precheck</kbd> files or <kbd>postcheck</kbd> files. Also, the files are ordered in chronological order for easy selection during the comparison process.</p>
<p>Let's see the output of this page now:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1eab88dc-950f-41b1-b457-49a01d201889.jpg" style="width:108.75em;height:11.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 4 – Create server based files for pre and post files comparison</h1>
                </header>
            
            <article>
                
<p>The final step is to create a web page that retrieves the text from these files and also provides frontend (or a web-based tool) for easy comparison. For our purpose, we use a JScript library called <kbd>diffview</kbd> <strong>. </strong>To call this dependency, we need to download <kbd><strong> </strong>diffview.js</kbd>, <kbd>difflib.js</kbd>, and <kbd>diffview.css</kbd> which available here: <a href="https://github.com/cemerick/jsdifflib" target="_blank">https://github.com/cemerick/jsdifflib, </a>and copy the files into our web server folder. Once done, in the similar way as accessing the files, we would again create a <kbd>.aspx</kbd> page to get the content of the selected files and display it for comparison.</p>
<p>The following is the code of the main page <kbd>comparefiles.aspx</kbd>:</p>
<pre>&lt;%@ Page Language="VB" AutoEventWireup="false" CodeFile="comparefiles.aspx.vb" Inherits="comparefiles" %&gt;<br/><br/>&lt;!DOCTYPE html&gt;<br/><br/>&lt;html &gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="utf-8"/&gt;<br/>  &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/&gt;<br/>  &lt;link rel="stylesheet" type="text/css" href="diffview.css"/&gt;<br/>  &lt;script type="text/javascript" src="diffview.js"&gt;&lt;/script&gt;<br/>  &lt;script type="text/javascript" src="difflib.js"&gt;&lt;/script&gt;<br/>&lt;style type="text/css"&gt;<br/>body {<br/>  font-size: 12px;<br/>  font-family: Sans-Serif;<br/>}<br/>h2 {<br/>  margin: 0.5em 0 0.1em;<br/>  text-align: center;<br/>}<br/>.top {<br/>  text-align: center;<br/>}<br/>.textInput {<br/>  display: block;<br/>  width: 49%;<br/>  float: left;<br/>}<br/>textarea {<br/>  width:100%;<br/>  height:300px;<br/>}<br/>label:hover {<br/>  text-decoration: underline;<br/>  cursor: pointer;<br/>}<br/>.spacer {<br/>  margin-left: 10px;<br/>}<br/>.viewType {<br/>  font-size: 16px;<br/>  clear: both;<br/>  text-align: center;<br/>  padding: 1em;<br/>}<br/>#diffoutput {<br/>  width: 100%;<br/>}<br/>&lt;/style&gt;<br/><br/>&lt;script type="text/javascript"&gt;<br/><br/>function diffUsingJS(viewType) {<br/>  "use strict";<br/>  var byId = function (id) { return document.getElementById(id); },<br/>    base = difflib.stringAsLines(byId("baseText").value),<br/>    newtxt = difflib.stringAsLines(byId("newText").value),<br/>    sm = new difflib.SequenceMatcher(base, newtxt),<br/>    opcodes = sm.get_opcodes(),<br/>    diffoutputdiv = byId("diffoutput"),<br/>    contextSize = byId("contextSize").value;<br/><br/>  diffoutputdiv.innerHTML = "";<br/>  contextSize = contextSize || null;<br/><br/>  diffoutputdiv.appendChild(diffview.buildView({<br/>    baseTextLines: base,<br/>    newTextLines: newtxt,<br/>    opcodes: opcodes,<br/>    baseTextName: "Base Text",<br/>    newTextName: "New Text",<br/>    contextSize: contextSize,<br/>    viewType: viewType<br/>  }));<br/>}<br/><br/>&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;div class="top"&gt;<br/>    &lt;strong&gt;Context size (optional):&lt;/strong&gt; &lt;input type="text" id="contextSize" value="" /&gt;<br/>  &lt;/div&gt;<br/>  &lt;div class="textInput"&gt;<br/>    &lt;h2&gt;Pre check&lt;/h2&gt;<br/>    &lt;textarea id="baseText" runat="server" readonly&gt;&lt;/textarea&gt;<br/>  &lt;/div&gt;<br/>  &lt;div class="textInput spacer"&gt;<br/>    &lt;h2&gt;Post check&lt;/h2&gt;<br/>    &lt;textarea id="newText" runat="server" readonly&gt;&lt;/textarea&gt;<br/>  &lt;/div&gt;<br/>    &lt;% Response.Write(xmystring.ToString()) %&gt;<br/>  &lt;div class="viewType"&gt;<br/>    &lt;input type="radio" name="_viewtype" id="sidebyside" onclick="diffUsingJS(0);" /&gt; &lt;label for="sidebyside"&gt;Side by Side Diff&lt;/label&gt;<br/>    &amp;nbsp; &amp;amp;amp;amp;nbsp;<br/>    &lt;input type="radio" name="_viewtype" id="inline" onclick="diffUsingJS(1);" /&gt; &lt;label for="inline"&gt;Inline Diff&lt;/label&gt;<br/>  &lt;/div&gt;<br/>  &lt;div id="diffoutput"&gt; &lt;/div&gt;<br/><br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>The backend code for the main page, to get the contents of the file (<kbd>comparefiles.aspx.vb</kbd>), is as follows:</p>
<pre>Imports System.IO<br/><br/>Partial Class comparefiles<br/>    Inherits System.Web.UI.Page<br/>    Public xmystring As New StringBuilder()<br/><br/>    Protected Sub Page_Load(sender As Object, e As EventArgs) Handles Me.Load<br/>        Dim fp As StreamReader<br/>        Dim precheck As New List(Of String)<br/>        Dim postcheck As New List(Of String)<br/>        xmystring.Clear()<br/>        Dim prefile As String<br/>        Dim postfile As String<br/>        prefile = Request.Form("prechecklist")<br/>        postfile = Request.Form("postchecklist")<br/>        fp = File.OpenText(prefile)<br/>        baseText.InnerText = fp.ReadToEnd()<br/>        fp = File.OpenText(postfile)<br/>        newText.InnerText = fp.ReadToEnd()<br/>        fp.Close()<br/><br/>    End Sub<br/><br/>End Class</pre>
<p>With this ready, let's compare the files and see the results. We select the pre and post check files and click on <kbd>Submit</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6402dbab-3ae6-41f6-b6c9-c1666534b465.jpg"/></div>
<p>The next page takes us to the content and comparison:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/493e101c-9380-4c06-a801-8a1c2788cbbf.jpg" style="width:108.75em;height:53.83em;"/></div>
<p>As we see in the preceding screenshot, on the left, we have the <kbd>precheck</kbd> file, and on the right, we have the <kbd>postcheck</kbd> file. Both can be read on the page itself through slides on both windows. The bottom window appears when we select either <kbd>Side by Side Diff</kbd> or <kbd>Inline Diff</kbd>.</p>
<p>On a <kbd>Side by Side Diff</kbd>, anything that is different will be highlighted. In our case it was uptime that was different. For everything else in common, no color highlighting will be in place and an engineer can safely assume the same states for non highlighted colors. </p>
<p>Let's see the same example with a <kbd>Inline Diff</kbd> comparison selection:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4cf4ec76-401b-438b-bbda-03bd7796af1b.jpg"/></div>
<p>It is the same result; different lines are highlighted in different colors to confirm the pre and post check differences. With this tool now, an engineer can quickly parse through the entire log files, and based on the highlighted differences (a mismatch between <kbd>precheck</kbd> file content and <kbd>postcheck</kbd> file content), can make the decision to call the task a success or a failure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we saw various concepts related to the usage of automation in daily network scenarios. We got familiar with examples of performing various tasks related to additional devices such as wireless AP and IP Phones. Additionally, we also got introduced to IPAM of SolarWinds and how to work on the API using Python.</p>
<p>We also saw a real-world example of creating a pre and post validation tool to help engineers make quick maintenance validation decisions, and also ported to the web so that the tool can be used from anywhere, instead of running from individual machines with Python installed as a prerequisite.</p>
<p>Finally, in our concluding chapter, we will look at some additional aspects of SDN to understand better usage and how and where to automate, with respect to SDN scenarios.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>