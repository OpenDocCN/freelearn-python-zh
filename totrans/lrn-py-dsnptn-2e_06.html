<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. The Observer Pattern – Keeping Objects in the Know</h1></div></div></div><p class="calibre6">In the previous chapter, we started with a brief introduction to Proxy and went ahead to discuss the Proxy design pattern. We understood the concept of the Proxy pattern with a UML diagram and also learned how it's applied in the real world with the help of Python implementations. You learned about the ups and downs of the Proxy pattern with the FAQ section.</p><p class="calibre6">In this chapter, we will talk about the third type of design pattern—the behavioral design pattern. We will be introduced to the Observer design pattern, which falls under the hood of Behavioral patterns. We will discuss how the Observer design pattern is used in software application development. We will work with a sample use case and implement it in Python v3.5.</p><p class="calibre6">In this chapter, we will cover the following topics in brief:</p><div><ul class="itemizedlist"><li class="listitem">An introduction to behavioral design patterns</li><li class="listitem">The Observer pattern and its UML diagram</li><li class="listitem">A real-world use case with the Python v3.5 code implementation</li><li class="listitem">The power of loose coupling</li><li class="listitem">Frequently asked questions</li></ul></div><p class="calibre6">At the end of the chapter, we will summarize the entire discussion—consider this a takeaway.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec45" class="calibre1"/>Introducing Behavioral patterns</h1></div></div></div><p class="calibre6">In the previous chapters of the book, you learned about creational patterns (Singleton) and structural patterns (Façade). In this section, we will get a brief idea of Behavioral patterns.</p><p class="calibre6">Creational patterns work on the basis of how objects can be created. They isolate the details of object creation. Code is independent of the type of object to be created. Structural patterns design the structure of objects and classes so that they can work together to achieve larger results. Their main focus is on simplifying the structure and identifying relationships between classes and objects.</p><p class="calibre6">Behavioral patterns, as the name suggests, focus on the responsibilities that an object has. They deal with the interaction among objects to achieve larger functionality. Behavioral patterns suggest that while the objects should be able to interact with each other, they should still be loosely coupled. We will learn about the principle of loose coupling later in this chapter.</p><p class="calibre6">The Observer design pattern is one of the simplest Behavioral patterns. So, let's gear up and understand more about them.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec46" class="calibre1"/>Understanding the Observer design pattern</h1></div></div></div><p class="calibre6">In the Observer design pattern, an object (Subject) maintains a list of dependents (Observers) so that the Subject can notify all the Observers about the changes that it undergoes using any of the methods defined by the Observer.</p><p class="calibre6">In the world of distributed applications, multiple services interact with each other to perform a larger operation that a user wants to achieve. Services can perform multiple operations, but the operation they perform is directly or heavily dependent on the state of the objects of the service that it interacts with.</p><p class="calibre6">Consider a use case for user registration where the user service is responsible for user operations on the website. Let's say that we have another service called e-mail service that observes the state of the user and sends e-mails to the user. For example, if the user has just signed up, the user service will call a method of the e-mail service that will send an e-mail to the user for account verification. If the account is verified but has fewer credits, the e-mail service will monitor the user service and send an e-mail alert for low credits to the user.</p><p class="calibre6">Thus, if there's a core service in the application on which many other services are dependent, the core service becomes the Subject that has to be observed/monitored by the Observer for changes. The Observer should, in turn, make changes to the state of its own objects or take certain actions based on the changes that happen in the Subject. The above scenario, where the dependent service monitor's state changes in the core service, presents a classical case for the Observer design pattern.</p><p class="calibre6">In the case of a broadcast or publish/subscribe system, you'll find the usage of the Observer design pattern. Consider the example of a blog. Let's suppose that you're a tech enthusiast who loves to read about the latest articles on Python on this blog. What will you do? You subscribe to the blog. Like you, there would be multiple subscribers that are also registered with the blog. So, whenever there is a new blog, you get notified, or if there is a change on the published blog, you are also made aware of the edits. The way in which you're notified of the change can be an e-mail. Now if you apply this scenario to the Observer pattern, the blog is the Subject that maintains the list of subscribers or Observers. So when a new entry is added to the blog, all Observers are notified via e-mail or any other notification mechanism as defined by the Observer.</p><p class="calibre6">The main intentions of the Observer pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem">It defines a one-to-many dependency between objects so that any change in one object will be notified to the other dependent objects automatically</li><li class="listitem">It encapsulates the core component of the Subject</li></ul></div><p class="calibre6">The Observer pattern is used in the following multiple scenarios:</p><div><ul class="itemizedlist"><li class="listitem">Implementation of the Event service in distributed systems</li><li class="listitem">A framework for a news agency</li><li class="listitem">The stock market also represents a great case for the Observer pattern</li></ul></div><p class="calibre6">The following Python code implements the Observer design pattern:</p><div><pre class="programlisting">class Subject:
    def __init__(self):
        self.__observers = []
    
    def register(self, observer):
        self.__observers.append(observer)
    
    def notifyAll(self, *args, **kwargs):
        for observer in self.__observers:
            observer.notify(self, *args, **kwargs)


class Observer1:
    def __init__(self, subject):
        subject.register(self)
    
    def notify(self, subject, *args):
        print(type(self).__name__,':: Got', args, 'From', subject)


class Observer2:
    def __init__(self, subject):
        subject.register(self)
    
    def notify(self, subject, *args):
        print(type(self).__name__, ':: Got', args, 'From', subject)


subject = Subject()
observer1 = Observer1(subject)
observer2 = Observer2(subject)
subject.notifyAll('notification')</pre></div><p class="calibre6">The output of the preceding code is as follows:</p><div><img src="img/00020.jpeg" alt="Understanding the Observer design pattern" class="calibre14"/></div><p class="calibre15"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec37" class="calibre1"/>A UML class diagram for the Observer pattern</h2></div></div></div><p class="calibre6">Let's now understand more about the Observer pattern with the help of the following UML diagram.</p><p class="calibre6">As we discussed in the previous paragraph, the Observer pattern has two main actors: the <code class="email">Subject</code> and <code class="email">Observer</code>. Let's put these in a UML diagram and see how the classes look:</p><div><img src="img/00021.jpeg" alt="A UML class diagram for the Observer pattern" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">As we look at the UML diagram, you'll realize that there are three main participants in this pattern:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">Subject</code>: The <code class="email">Subject</code> class is aware of the <code class="email">Observer</code>. The <code class="email">Subject</code> class has methods such as <code class="email">register()</code> and <code class="email">deregister()</code> that are used by <code class="email">Observers</code> to register themselves with the <code class="email">Subject</code> class. A <code class="email">Subject</code>, thus can handle multiple <code class="email">Observers</code>.</li><li class="listitem"><code class="email">Observer</code>: It defines an interface for objects that are observing the Subject. It defines methods that need to be implemented by the <code class="email">Observer</code> to get notified of changes in the Subject.</li><li class="listitem"><code class="email">ConcreteObserver</code>: It stores the state that should be consistent with that of the <code class="email">Subject's</code> state. It implements the <code class="email">Observer</code> interface to keep the state consistent with changes in the Subject.</li></ul></div><p class="calibre6">The flow is straightforward. <code class="email">ConcreteObservers</code> register themselves with the Subject by implementing the interface provided by the <code class="email">Observer</code>. Whenever there is a change in state, the Subject notifies all <code class="email">ConcreteObservers</code> with the notify method provided by the <code class="email">Observers</code>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec47" class="calibre1"/>The Observer pattern in the real world</h1></div></div></div><p class="calibre6">We will take up a news agency case to demonstrate the real-world scenario for the Observer pattern. News agencies typically gather news from various locations and publish them to the subscribers. Let's look at the design considerations for this use case.</p><p class="calibre6">With information being sent/received in real time, a news agency should be able to publish the news as soon as possible to its subscribers. Additionally, because of the advancements in the technology industry, it's not just the newspapers, but also the subscribers that can be of different types such as an e-mail, mobile, SMS, or voice call. We should also be able to add any other type of subscriber in the future and budgeting for any new technology.</p><p class="calibre6">Let's develop an application in Python v3.5 and implement the preceding use case. We will start with the Subject, which is the news publisher:</p><div><ul class="itemizedlist"><li class="listitem">Subject behavior is represented by the <code class="email">NewsPublisher</code> class</li><li class="listitem"><code class="email">NewsPublisher</code> provides you with an interface so that subscribers can work with it</li><li class="listitem">The <code class="email">attach()</code> method is used by the <code class="email">Observer</code> to register with <code class="email">NewsPublisher</code> and the <code class="email">detach()</code> method helps in deregistering the <code class="email">Observer</code></li><li class="listitem">The <code class="email">subscriber()</code> method returns the list of all the subscribers that have already registered with the <code class="email">Subject</code></li><li class="listitem">The <code class="email">notifySubscriber()</code> method iterates over all the subscribers that have registered with <code class="email">NewsPublisher</code></li><li class="listitem">The <code class="email">addNews()</code> method is used by the publisher to create new news and <code class="email">getNews()</code> is used to return the latest news, which is then notified to the <code class="email">Observer</code></li></ul></div><p class="calibre6">Let's first look at the <code class="email">NewsPublisher</code> class:</p><div><pre class="programlisting">class NewsPublisher:
    def __init__(self):
        self.__subscribers = []
        self.__latestNews = None

    def attach(self, subscriber):
        self.__subscribers.append(subscriber)

    def detach(self):
        return self.__subscribers.pop()

    def subscribers(self):
        return [type(x).__name__ for x in self.__subscribers]

    def notifySubscribers(self):
        for sub in self.__subscribers:
            sub.update()

    def addNews(self, news):
        self.__latestNews = news

    def getNews(self):
        return "Got News:", self.__latestNews</pre></div><p class="calibre6">Let's talk about the <code class="email">Observer</code> interface now:</p><div><ul class="itemizedlist"><li class="listitem">In this example, <code class="email">Subscriber</code> represents the <code class="email">Observer</code>. It is an abstract base class and represents any other <code class="email">ConcreteObserver</code>.</li><li class="listitem"><code class="email">Subscriber</code> has the <code class="email">update()</code> method that needs to be implemented by <code class="email">ConcreteObservers</code>.</li><li class="listitem">The <code class="email">update()</code> method is implemented by <code class="email">ConcreteObserver</code> so that they get notified by the <code class="email">Subject</code> (<code class="email">NewsPublishers</code>) about any news getting published.</li></ul></div><p class="calibre6">Lets us now look at the code for the <code class="email">Subscriber</code> abstract class:</p><div><pre class="programlisting">from abc import ABCMeta, abstractmethod

class Subscriber(metaclass=ABCMeta):
    
    @abstractmethod
    def update(self):
        pass</pre></div><p class="calibre6">We also developed certain classes that represent <code class="email">ConcreteObserver</code>:</p><div><ul class="itemizedlist"><li class="listitem">In this case, we have two main observers: <code class="email">EmailSubscriber</code> and <code class="email">SMSSubscriber</code> that implement the subscriber interface</li><li class="listitem">In addition to these two, we have another Observer, <code class="email">AnyOtherObserver</code>, that demonstrates the loose coupling of <code class="email">Observers</code> with the <code class="email">Subject</code></li><li class="listitem">The <code class="email">__init__()</code> method of each of these <code class="email">ConcreteObservers</code> registers them with <code class="email">NewsPublisher</code> with the <code class="email">attach()</code> method</li><li class="listitem">The <code class="email">update()</code> method of <code class="email">ConcreteObserver</code> is used internally by <code class="email">NewsPublisher</code> to notify about the news additions</li></ul></div><p class="calibre6">Here's how the <code class="email">SMSSubscriber</code> class is implemented:</p><div><pre class="programlisting">class SMSSubscriber:
    def __init__(self, publisher):
        self.publisher = publisher
        self.publisher.attach(self)
    
    def update(self):
        print(type(self).__name__, self.publisher.getNews())
    
class EmailSubscriber:
    def __init__(self, publisher):
        self.publisher = publisher
        self.publisher.attach(self)
    
    def update(self):
        print(type(self).__name__, self.publisher.getNews())
    
class AnyOtherSubscriber:
    def __init__(self, publisher):
        self.publisher = publisher
        self.publisher.attach(self)
    
    def update(self):
        print(type(self).__name__, self.publisher.getNews())</pre></div><p class="calibre6">Now that all the required subscribers have been implemented, lets look at the <code class="email">NewsPublisher</code> and <code class="email">SMSSubscribers</code> class in action:</p><div><ul class="itemizedlist"><li class="listitem">The client creates an object for <code class="email">NewsPublisher</code> that is used by <code class="email">ConcreteObservers</code> for various operations.</li><li class="listitem"><code class="email">SMSSubscriber</code>, <code class="email">EmailSubscriber</code>, and <code class="email">AnyOtherSubscriber</code> classes are initialized with publisher objects.</li><li class="listitem">In Python, when we create objects, the <code class="email">__init__()</code> method gets called. In the <code class="email">ConcreteObserver</code> class, the <code class="email">__init__()</code> method internally uses the <code class="email">attach()</code> method of <code class="email">NewsPublisher</code> to register itself for news updates.</li><li class="listitem">We then print the list of all the subscribers (<code class="email">ConcreteObservers</code>) that got registered with the <code class="email">Subject</code>.</li><li class="listitem">The object of <code class="email">NewsPublisher (news_publisher)</code> is then used to create new news with the <code class="email">addNews()</code> method.</li><li class="listitem">The <code class="email">notifySubscribers()</code> method of <code class="email">NewsPublisher</code> is used to notify all subscribers of the news addition. The <code class="email">notifySubscribers()</code> method internally calls the <code class="email">update()</code> method implemented by <code class="email">ConcreteObservers</code> so that they get the latest news.</li><li class="listitem"><code class="email">NewsPublisher</code> also has the <code class="email">detach()</code> method that removes the subscriber from the list of registered subscribers.</li></ul></div><p class="calibre6">The following code implementation represents the interactions between the <code class="email">Subject</code> and <code class="email">Observers</code>:</p><div><pre class="programlisting">if __name__ == '__main__':
    news_publisher = NewsPublisher()

    for Subscribers in [SMSSubscriber, EmailSubscriber, AnyOtherSubscriber]:
        Subscribers(news_publisher)
    print("\nSubscribers:", news_publisher.subscribers())

    news_publisher.addNews('Hello World!')
    news_publisher.notifySubscribers()

    print("\nDetached:", type(news_publisher.detach()).__name__)
    print("\nSubscribers:", news_publisher.subscribers())

    news_publisher.addNews('My second news!')
    news_publisher.notifySubscribers()</pre></div><p class="calibre6">The output of the preceding code is as follows:</p><div><img src="img/00022.jpeg" alt="The Observer pattern in the real world" class="calibre14"/></div><p class="calibre15"> </p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec48" class="calibre1"/>The Observer pattern methods</h1></div></div></div><p class="calibre6">There are two different ways of notifying the <code class="email">Observer</code> of the changes that happen in the <code class="email">Subject</code>. They can be classified as push or pull models.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec38" class="calibre1"/>The pull model</h2></div></div></div><p class="calibre6">In the <a id="id168" class="calibre1"/>pull model, <code class="email">Observers</code> play an active role as follows:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">Subject</code> broadcasts<a id="id169" class="calibre1"/> to all the registered <code class="email">Observers</code> when there is any change</li><li class="listitem">The <code class="email">Observer</code> is responsible for getting the changes or pulling data from the subscriber when there is an amendment</li><li class="listitem">The pull model is ineffective as it involves two steps—the first step where the <code class="email">Subject</code> notifies the <code class="email">Observer</code> and the second step where the <code class="email">Observer</code> pulls the required data from the Subject</li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec39" class="calibre1"/>The push model</h2></div></div></div><p class="calibre6">In the <a id="id170" class="calibre1"/>push model, the <code class="email">Subject</code> is the one that plays a<a id="id171" class="calibre1"/> dominant role as follows:</p><div><ul class="itemizedlist"><li class="listitem">Unlike the pull model, the changes are pushed by the <code class="email">Subject</code> to the <code class="email">Observer</code>.</li><li class="listitem">In this model, the Subject can send detailed information to the <code class="email">Observer</code> (even though it may not be needed). This can result in sluggish response times when a large amount of data is sent by the <code class="email">Subject</code> but is never actually used by the <code class="email">Observer</code>.</li><li class="listitem">Only <a id="id172" class="calibre1"/>the required data is sent from the <code class="email">Subject</code> so<a id="id173" class="calibre1"/> that the performance is better.</li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec49" class="calibre1"/>Loose coupling and the Observer pattern</h1></div></div></div><p class="calibre6">Loose<a id="id174" class="calibre1"/> coupling is an important design principle that should be<a id="id175" class="calibre1"/> used in software applications. The main purpose of loose coupling is to strive for loosely-coupled designs between objects that interact with each other. Coupling refers to the degree of knowledge that one object has about the other object that it interacts with.</p><p class="calibre6">Loosely-coupled designs allow us to build flexible object-oriented systems that can handle changes because they reduce the dependency between multiple objects.</p><p class="calibre6">The<a id="id176" class="calibre1"/> loose coupling architecture ensures following features:</p><div><ul class="itemizedlist"><li class="listitem">It reduces the risk that a change made within one element might create an unanticipated impact on the other elements</li><li class="listitem">It simplifies testing, maintenance, and troubleshooting problems</li><li class="listitem">The system can be easily broken down into definable elements</li></ul></div><p class="calibre6">The Observer pattern provides you with an object design where the <code class="email">Subject</code> and <code class="email">Observer</code> are loosely coupled. The following points will explain this better:</p><div><ul class="itemizedlist"><li class="listitem">The only thing that the <code class="email">Subject</code> knows about an <code class="email">Observer</code> is that it implements a certain interface. It need not know the <code class="email">ConcreteObserver</code> class.</li><li class="listitem">Any new <code class="email">Observer</code> can be added at any point in time (as we saw in the sample example earlier in this chapter).</li><li class="listitem">The <code class="email">Subject</code> need not be modified at all to add any new <code class="email">Observer</code>. In the example, we saw that <code class="email">AnyOtherObserver</code> can be added/removed without any changes in the <code class="email">Subject</code>.</li><li class="listitem">Subjects or <code class="email">Observers</code> are not tied up and can be used independently of each other. So the <code class="email">Observer</code> can be reused anywhere else, if needed.</li><li class="listitem">Changes in the <code class="email">Subject</code> or <code class="email">Observer</code> will not affect each other. As both are independent or loosely coupled, they are free to make their own changes.</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec50" class="calibre1"/>The Observer pattern – advantages and disadvantages</h1></div></div></div><p class="calibre6">The<a id="id177" class="calibre1"/> Observer pattern provides you with the following advantages:</p><div><ul class="itemizedlist"><li class="listitem">It supports the principle of loose coupling between objects that interact with each other</li><li class="listitem">It allows sending data to other objects effectively without any change in the <code class="email">Subject</code> or <code class="email">Observer</code> classes</li><li class="listitem"><code class="email">Observers</code> can be added/removed at any point in time</li></ul></div><p class="calibre6">The following <a id="id178" class="calibre1"/>are the disadvantages of the Observer pattern:</p><div><ul class="itemizedlist"><li class="listitem">The Observer interface has to be implemented by <code class="email">ConcreteObserver</code>, which involves inheritance. There is no option for composition, as the Observer interface can be instantiated.</li><li class="listitem">If not correctly implemented, the <code class="email">Observer</code> can add complexity and lead to inadvertent performance issues.</li><li class="listitem">In software application, notifications can, at times, be undependable and result in race conditions or inconsistency.</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec51" class="calibre1"/>Frequently asked questions</h1></div></div></div><p class="calibre6">Q1. Can<a id="id179" class="calibre1"/> there be many <code class="email">Subjects</code> and <code class="email">Observers</code>?</p><p class="calibre6">A: There can be a case for a software application to have multiple <code class="email">Subjects</code> and Observers. For this to work, <code class="email">Observers</code> need to be notified of changes in the <code class="email">Subjects</code> and which <code class="email">Subject</code> underwent a change.</p><p class="calibre6">Q2. Who is responsible for triggering the update?</p><p class="calibre6">A: As you learned earlier, the Observer pattern can work in both push and pull models. Typically, the Subject triggers the update method when there are changes, but sometimes based on the application need, the <strong class="calibre7">Observer</strong> can also trigger notifications. However, care needs to be taken that the frequency should not be too high, otherwise it can lead to performance degradation, especially when the updates to the Subject are less frequent.</p><p class="calibre6">Q3. Can the <code class="email">Subject</code> or <code class="email">Observer</code> be used for access for any other use case?</p><p class="calibre6">A: Yes, that's the power of loose coupling that is manifested in the Observer pattern. The <code class="email">Subject</code>/<code class="email">Observer</code> can both be independently used.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec52" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">We began the chapter by understanding the behavioral design patterns. We understood the basis of the Observer pattern and how it is effectively used in software architecture. We looked at how Observer design patterns are used to notify the <code class="email">Observer</code> of the changes happening in the <code class="email">Subject</code>. They manage the interaction between objects and manage one-to-many dependencies on the objects.</p><p class="calibre6">You also learned the pattern with a UML diagram and sample code implementation in Python v3.5.</p><p class="calibre6">Observer patterns are implemented in two different ways: push and pull models. You learned about each of these and discussed their implementation and performance impact.</p><p class="calibre6">We understood the principle of loose coupling in software design and how the Observer pattern leverages this principle in application development.</p><p class="calibre6">We also covered a section on FAQs that would help you get more ideas about the pattern and its possible advantages/disadvantages.</p><p class="calibre6">At the end of this chapter, we're now geared up to learn more Behavioral patterns in the chapters to come.</p></div></body></html>