<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Threads and Networking</h1></div></div></div><p>In this chapter, we will create threads, queues, and TCP/IP sockets using Python 3.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to create multiple threads</li><li class="listitem" style="list-style-type: disc">Starting a thread</li><li class="listitem" style="list-style-type: disc">Stopping a thread</li><li class="listitem" style="list-style-type: disc">How to use queues</li><li class="listitem" style="list-style-type: disc">Passing queues among different modules</li><li class="listitem" style="list-style-type: disc">Using dialog widgets to copy files to your network</li><li class="listitem" style="list-style-type: disc">Using TCP/IP to communicate via networks</li><li class="listitem" style="list-style-type: disc">Using URLOpen to read data from websites</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Introduction</h1></div></div></div><p>In this chapter, we will extend the functionality of our Python GUI using threads, queues, and network connections.</p><div><div><h3 class="title"><a id="note54"/>Note</h3><p>A tkinter GUI is single-threaded. Every function that involves sleep or wait time has to be called in a separate thread, otherwise the tkinter GUI freezes.</p></div></div><p>When we run our Python GUI in Windows Task Manager, we can see that a new <code class="literal">python.exe</code> process has been launched.</p><p>When we give our Python GUI a <code class="literal">.pyw</code> extension, then the process created will be <code class="literal">python.pyw</code>, as can be seen in Task Manager.</p><p>When a process is created, the process automatically creates a main thread to run our application. This is <a id="id189" class="indexterm"/>called a single-threaded application.</p><p>For our Python GUI, a single-threaded application will lead to our GUI becoming frozen as soon as we call a longer-running task such as clicking a button that has a sleep of a few seconds.</p><p>In order to keep our GUI responsive we have to use multi-threading, and this is what we will study in this chapter.</p><p>We can also create multiple processes by creating multiple instances of our Python GUI, as can be seen in Task Manager.</p><p>Processes are isolated by design from each other and do not share common data. In order to <a id="id190" class="indexterm"/>communicate between separate processes we would have to use <strong>Inter-Process-Communication</strong> (<strong>IPC</strong>), which is an advanced technique.</p><p>Threads, on the other hand, do share common data, code, and files, which makes communication between threads within the same process much easier than when using IPC.</p><div><div><h3 class="title"><a id="note55"/>Note</h3><p>A <a id="id191" class="indexterm"/>great explanation of threads can be found at: <a class="ulink" href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html">https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html</a>
</p></div></div><p>In this chapter, we will learn how to keep our Python GUI responsive and not to freeze.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>How to create multiple threads</h1></div></div></div><p>We will<a id="id192" class="indexterm"/> create multiple threads using Python. This is necessary in order to keep our GUI responsive.</p><div><div><h3 class="title"><a id="note56"/>Note</h3><p>A thread is like weaving a fabric made out of yarn and is nothing to be afraid of.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec137"/>Getting ready</h2></div></div></div><p>Multiple threads run within the same computer process memory space. There is no need for Inter-Process-Communication (aka IPC), which would complicate our code. In this recipe, we will avoid IPC by using threads.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec138"/>How to do it...</h2></div></div></div><p>First we will increase the size of our <code class="literal">ScrolledText</code> widget, making it larger. Let's increase <code class="literal">scrolW</code> to 40 and <code class="literal">scrolH</code> to 10.</p><div><pre class="programlisting"># Using a scrolled Text control
scrolW  = 40; scrolH  =  10
self.scr = scrolledtext.ScrolledText(self.monty, width=scrolW, height=scrolH, wrap=tk.WORD)
self.scr.grid(column=0, row=3, sticky='WE', columnspan=3)</pre></div><p>When we<a id="id193" class="indexterm"/> now run the resulting GUI, the <code class="literal">Spinbox</code> widget is center-aligned in relation to the <code class="literal">Entry</code> widget above it, which does not look good. We'll change this by left-aligning the widget.</p><p>Add <code class="literal">sticky='W'</code> to the <code class="literal">grid</code> control to left-align the <code class="literal">Spinbox</code> widget.</p><div><pre class="programlisting"># Adding a Spinbox widget using a set of values
self.spin = Spinbox(self.monty, values=(1, 2, 4, 42, 100), width=5, bd=8, command=self._spin) 
self.spin.grid(column=0, row=2, sticky='W')</pre></div><p>The GUI could still look better, so next, we will increase the size of the <code class="literal">Entry</code> widget to get a more balanced GUI layout.</p><p>Increase the width to 24, as shown in the following:</p><div><pre class="programlisting"># Adding a Textbox Entry widget
self.name = tk.StringVar()
nameEntered = ttk.Entry(self.monty, width=24, textvariable=self.name)
nameEntered.grid(column=0, row=1, sticky='W')</pre></div><p>Let us also slightly increase the width of the <code class="literal">Combobox</code> to 14.</p><div><pre class="programlisting">ttk.Label(self.monty, text="Choose a number:").grid(column=1, row=0)
number = tk.StringVar()
numberChosen = ttk.Combobox(self.monty, width=14, textvariable=number)
numberChosen['values'] = (1, 2, 4, 42, 100)
numberChosen.grid(column=1, row=1)
numberChosen.current(0)</pre></div><p>Running the modified and improved code results in a larger GUI, which we will use for this and the following recipes.</p><div><img src="img/B04829_06_01.jpg" alt="How to do it..."/></div><p>In order to<a id="id194" class="indexterm"/> create and use threads in Python, we have to import the <code class="literal">Thread</code> class from the threading module.</p><div><pre class="programlisting">#======================
# imports
#======================
import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext
from tkinter import Menu  
from tkinter import Spinbox
import B04829_Ch06_ToolTip as tt

from threading import Thread

GLOBAL_CONST = 42</pre></div><p>Let's add a method to be created in a thread to our <code class="literal">OOP</code> class.</p><div><pre class="programlisting">class OOP():
    def methodInAThread(self):
        print('Hi, how are you?')</pre></div><p>We can now call our threaded method in the code, saving the instance in a variable.</p><div><pre class="programlisting">#======================
# Start GUI
#======================
oop = OOP()

# Running methods in Threads
runT = Thread(target=oop.methodInAThread)
oop.win.mainloop())</pre></div><p>Now we<a id="id195" class="indexterm"/> have a method that is threaded, but when we run the code, nothing gets printed to the console!</p><p>We have to start the <code class="literal">Thread</code> first before it can run and the next recipe will show us how to do this.</p><p>However, setting a breakpoint after the GUI main event loop proves that we did indeed create a <code class="literal">Thread</code> object, as can been seen in the Eclipse IDE Debugger.</p><div><img src="img/B04829_06_02.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec139"/>How it works...</h2></div></div></div><p>In this recipe, we prepared our GUI to use threads by first increasing the GUI size, so we could better see the results printed to the <code class="literal">ScrolledText</code> widget.</p><p>We then imported the <code class="literal">Thread</code> class from the Python <code class="literal">threading</code> module.</p><p>After that, we created a method that we call in a thread from within our GUI.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Starting a thread</h1></div></div></div><p>This<a id="id196" class="indexterm"/> recipe will show us how to start a thread. It will also demonstrate why threads are necessary to keep our GUI responsive during long-running tasks.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec140"/>Getting ready</h2></div></div></div><p>Let's first see what happens when we call a function or method of our GUI that has some sleep associated with it without using threads.</p><div><div><h3 class="title"><a id="note57"/>Note</h3><p>We are using a sleep here to simulate a real-world application that might have to wait for a web server or database to respond or a large file transfer or complex computation to complete its task.</p><p>The sleep is a very realistic place-holder and shows the principle involved.</p></div></div><p>Adding a loop<a id="id197" class="indexterm"/> into our button callback method with some sleep time results in our GUI becoming unresponsive and, when we try to close the GUI, things get even worse.</p><div><pre class="programlisting"># Button callback
def clickMe(self):
  self.action.configure(text='Hello ' + self.name.get())
  # Non-threaded code with sleep freezes the GUI
  for idx in range(10):
    sleep(5)
    self.scr.insert(tk.INSERT, str(idx) + '\n')</pre></div><div><img src="img/B04829_06_03.jpg" alt="Getting ready"/></div><p>If we wait long enough, the method will eventually complete but during this time none of our GUI widgets respond to click events. We solve this problem by using threads.</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>In the previous recipe, we created a method to be run in a thread, but so far, the thread has not run!</p></div></div><p>Unlike regular Python functions and methods, we have to <code class="literal">start</code> a method that is going to be run in its own thread!</p><p>This is what we will do next.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec141"/>How to do it...</h2></div></div></div><p>First, let's move <a id="id198" class="indexterm"/>the creation of the thread into its own method and then call this method from the button callback method.</p><div><pre class="programlisting"># Running methods in Threads
def createThread(self):
  runT = Thread(target=self.methodInAThread)
  runT.start()
# Button callback
def clickMe(self):
  self.action.configure(text='Hello ' + self.name.get())
  self.createThread()</pre></div><p>Clicking the button now results in the <code class="literal">createThread</code> method being called which, in turn, calls the <code class="literal">methodInAThread</code> method.</p><p>First, we create a thread and target it at a method. Next, we start the thread that will run the targeted method in a new thread.</p><div><div><h3 class="title"><a id="note59"/>Note</h3><p>The GUI itself runs in its own thread, which is the main thread of the application.</p></div></div><div><img src="img/B04829_06_04.jpg" alt="How to do it..."/></div><p>We can<a id="id199" class="indexterm"/> print out the instance of the thread.</p><div><pre class="programlisting"># Running methods in Threads
def createThread(self):
  runT = Thread(target=self.methodInAThread)
  runT.start()
  print(runT)</pre></div><p>Clicking the button now creates the following printout:</p><div><img src="img/B04829_06_05.jpg" alt="How to do it..."/></div><p>When we<a id="id200" class="indexterm"/> click the button several times, we can see that each thread gets assigned a unique name and ID.</p><div><img src="img/B04829_06_06.jpg" alt="How to do it..."/></div><p>Let's now move our code with the <code class="literal">sleep</code> in a loop into the <code class="literal">methodInAThread</code> method to verify that threads really do solve our problem.</p><div><pre class="programlisting">def methodInAThread(self):
  print('Hi, how are you?')
  for idx in range(10):
    sleep(5)
    self.scr.insert(tk.INSERT, str(idx) + '\n')</pre></div><p>When clicking the button, while the numbers are being printed into the <code class="literal">ScrolledText</code> widget with a five second delay, we can click around anywhere in our GUI, switch tabs, and so on. Our GUI has become responsive again because we are using threads!</p><div><img src="img/B04829_06_07.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec142"/>How it works...</h2></div></div></div><p>In this<a id="id201" class="indexterm"/> recipe, we called methods of our GUI class in their own threads and learned that we have to start the threads. Otherwise, the thread gets created but just sits there waiting for us to run its target method.</p><p>We noticed that each thread gets assigned a unique name and ID.</p><p>We simulated long-running tasks by inserting a <code class="literal">sleep</code> statement into our code, which showed us that threads can indeed solve our problem.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Stopping a thread</h1></div></div></div><p>We have <a id="id202" class="indexterm"/>to start a thread to actually make it do something by calling the <code class="literal">start()</code> method, so, intuitively, we would expect there to be a matching <code class="literal">stop()</code> method, but there is no such thing. In this recipe, we will learn how to run a thread as a background task, which is called a daemon. When closing the main thread, which is our GUI, all daemons will automatically be stopped as well.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec143"/>Getting ready</h2></div></div></div><p>When we call methods in a thread, we can also pass arguments and keyword arguments to the method. We start this recipe by doing exactly that.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec144"/>How to do it...</h2></div></div></div><p>By adding <code class="literal">args=[8]</code> to the thread constructor and modifying the targeted method to expect<a id="id203" class="indexterm"/> arguments, we can pass arguments to threaded methods. The parameter to <code class="literal">args</code> has to be a sequence, so we will wrap our number in a Python list.</p><div><pre class="programlisting">def methodInAThread(self, numOfLoops=10):
  for idx in range(numOfLoops):
    sleep(1)
    self.scr.insert(tk.INSERT, str(idx) + '\n')</pre></div><p>In the following code, <code class="literal">runT</code> is a local variable which we only access within the scope of the method inside of which we created <code class="literal">runT</code>.</p><div><pre class="programlisting">    
# Running methods in Threads
def createThread(self):
  runT = Thread(target=self.methodInAThread, args=[8])
  runT.start()</pre></div><p>By turning the local variable into a member, we can then check if the thread is still running by calling <code class="literal">isAlive</code> on it from another method.</p><div><pre class="programlisting"># Running methods in Threads
def createThread(self):
  self.runT = Thread(target=self.methodInAThread, args=[8])
  self.runT.start()
  print(self.runT)
  print('createThread():', self.runT.isAlive())</pre></div><p>In the preceding code, we have elevated our local <code class="literal">runT</code> variable to a member of our class. What this does is enable us to assess the <code class="literal">self.runT</code> variable from any method in our class.</p><p>This is achieved like this:</p><div><pre class="programlisting">    def methodInAThread(self, numOfLoops=10):
        for idx in range(numOfLoops):
            sleep(1)
            self.scr.insert(tk.INSERT, str(idx) + '\n')
        sleep(1)
        print('methodInAThread():', self.runT.isAlive())</pre></div><p>When we click the button and then exit the GUI, we can see that the print statement in the <code class="literal">createThread</code> method was printed, but we do not see the second print statement from <code class="literal">methodInAThread</code>.</p><p>Instead, we<a id="id204" class="indexterm"/> get a RuntimeError.</p><div><img src="img/B04829_06_08.jpg" alt="How to do it..."/></div><p>Threads are expected to finish their assigned task so when we close the GUI while the thread has not completed, Python tells us that the thread we started is not in the main event loop.</p><p>We can solve this by turning the thread into a daemon, which will then execute as a background task.</p><p>What this gives us is that, as soon as we close our GUI, which is our main thread starting other threads, the daemon threads will cleanly exit.</p><p>We can do this by calling the <code class="literal">setDaemon(True)</code> method on the thread before we start the thread.</p><div><pre class="programlisting"># Running methods in Threads
def createThread(self):
  runT = Thread(target=self.methodInAThread)
  runT.setDaemon(True)
  runT.start()
  print(runT)</pre></div><p>When we<a id="id205" class="indexterm"/> now click the button and exit our GUI while the thread has not yet completed its assigned task, we no longer get any errors.</p><div><img src="img/B04829_06_09.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec145"/>How it works...</h2></div></div></div><p>While there is a start method to make threads run, surprisingly there is not really an equivalent stop method.</p><p>In this recipe, we are running a method in a thread, which prints numbers to our <code class="literal">ScrolledText</code> widget.</p><p>When we exit our GUI, we are no longer interested in the thread that used to print to our widget, so, by turning the thread into a background daemon, we can exit our GUI cleanly.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>How to use queues</h1></div></div></div><p>A Python <a id="id206" class="indexterm"/>queue is a data structure that implements the first-in-first-out paradigm, basically working like a pipe. You shovel something into the pipe on one side and it falls out on the other side of the pipe.</p><p>The main difference between this queue shoveling, and shoveling mud into physical pipes is that, in Python queues, things do not get mixed up. You put one unit in, and that unit comes back out on the other side. Next, you place another unit in (say, for example, an instance of a class), and this entire unit will come back out on the other end as one integral piece.</p><p>It comes back out at the other end in the exact order we inserted code into the queue.</p><div><div><h3 class="title"><a id="note60"/>Note</h3><p>A queue is not a stack where we push and pop data. A stack is a last-in-first-out (LIFO) data structure.</p></div></div><p>Queues are <a id="id207" class="indexterm"/>containers that hold data being fed into the queue from potentially different data sources. We can have different clients providing data to the queue whenever those clients have data available. Whichever client is ready to send data to our queue sends it, and we can then display this data in a widget or send it forward to other modules.</p><p>Using multiple threads to complete assigned tasks in a queue is very useful when receiving the final results of the processing and displaying them. The data is inserted at one end of the queue and then comes out of the other end in an ordered fashion, First-In-First-Out (FIFO).</p><p>Our GUI might have five different button widgets that each kick off different tasks that we want to display in our GUI in a widget (for example, a ScrolledText widget).</p><p>These five different tasks take a different amount of time to complete.</p><p>Whenever a task has completed, we immediately need to know this and display this information in our GUI.</p><p>By creating a shared Python queue and having the five tasks write their results to this queue, we can display the result of whatever task has been completed immediately using a FIFO approach.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec146"/>Getting ready</h2></div></div></div><p>As our GUI is ever increasing in its functionality and usefulness, it starts to talk to networks, processes, and websites, and will eventually have to wait for data to be made available for the GUI to represent.</p><p>Creating queues in Python solves the problem of waiting for data to be displayed inside our GUI.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec147"/>How to do it...</h2></div></div></div><p>In order to create queues in Python, we have to import the <code class="literal">Queue</code> class from the <code class="literal">queue</code> module. Add the following statement towards the top of our GUI module:</p><div><pre class="programlisting">from threading import Thread
from time import sleep
from queue import Queue</pre></div><p>That gets us started.</p><p>Next, we create a queue instance.</p><div><pre class="programlisting">def useQueues(self):
    guiQueue = Queue()     # create queue instance</pre></div><div><div><h3 class="title"><a id="note61"/>Note</h3><p>In the preceding code we create a local <code class="literal">Queue</code> instance that is only accessible within this method. If we wish to access this queue from other places, we have to turn it into a member of our class by using the <code class="literal">self</code> keyword which binds the local variable to the entire class, making it available from any other method within our class. In Python, we often create class instance variables in the <code class="literal">__init__(self)</code> method but Python is very pragmatic and enables us to create those member variables anywhere in the code.</p></div></div><p>Now we<a id="id208" class="indexterm"/> have an instance of a queue. We can prove that this works by printing it out.</p><div><img src="img/B04829_06_10.jpg" alt="How to do it..."/></div><p>In order to put data into the queue, we use the <code class="literal">put</code> command. In order to get data out of the queue, we use the <code class="literal">get</code> command.</p><div><pre class="programlisting"># Create Queue instance  
def useQueues(self):
    guiQueue = Queue()
    print(guiQueue)
    guiQueue.put('Message from a queue')
    print(guiQueue.get())</pre></div><p>Running the modified code results in the message first being placed in the <code class="literal">Queue</code>, and then being taken out of the <code class="literal">Queue</code>, and then printed to the console.</p><div><img src="img/B04829_06_11.jpg" alt="How to do it..."/></div><p>We can <a id="id209" class="indexterm"/>place many messages into the queue.</p><div><pre class="programlisting"># Create Queue instance  
def useQueues(self):
    guiQueue = Queue()
    print(guiQueue)
    for idx in range(10):
        guiQueue.put('Message from a queue: ' + str(idx))
    print(guiQueue.get())</pre></div><p>We have placed 10 messages into the <code class="literal">Queue</code>, but we are only getting the first one out. The other messages are still inside of the <code class="literal">Queue</code>, waiting to be taken out in a FIFO fashion.</p><div><img src="img/B04829_06_12.jpg" alt="How to do it..."/></div><p>In order to get all messages that have been placed into a <code class="literal">Queue</code> out, we can create an endless loop.</p><div><pre class="programlisting"># Create Queue instance
def useQueues(self):
    guiQueue = Queue()
    print(guiQueue)
    for idx in range(10):
        guiQueue.put('Message from a queue: ' + str(idx))
    
    while True: 
        print(guiQueue.get())</pre></div><div><img src="img/B04829_06_13.jpg" alt="How to do it..."/></div><p>While this <a id="id210" class="indexterm"/>code works, unfortunately it freezes our GUI. In order to fix this, we have to call the method in its own thread, as we did in previous recipes.</p><p>Let's run our method in a thread and tie it to the button event:</p><div><pre class="programlisting"># Running methods in Threads
def createThread(self, num):
    self.runT = Thread(target=self.methodInAThread, args=[num])
    self.runT.setDaemon(True)
    self.runT.start()
    print(self.runT)
    print('createThread():', self.runT.isAlive())

    # textBoxes are the Consumers of Queue data
    writeT = Thread(target=self.useQueues, daemon=True)
    writeT.start()

# Create Queue instance  
def useQueues(self):
    guiQueue = Queue()
    print(guiQueue)
    for idx in range(10):
        guiQueue.put('Message from a queue: ' + str(idx))
    while True: 
        print(guiQueue.get())</pre></div><p>When we now<a id="id211" class="indexterm"/> click the action <code class="literal">Button</code>, we no longer get an extraneous pop-up window and the code works.</p><div><img src="img/B04829_06_14.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec148"/>How it works...</h2></div></div></div><p>We have created a <code class="literal">Queue</code>, placed messages into one side of the <code class="literal">Queue</code> in a first-in-first-out (aka FIFO) fashion. We got the messages out of the <code class="literal">Queue</code> and then printed them to the console (stdout).</p><p>We realized that we have to call the method in its own <code class="literal">Thread</code>.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Passing queues among different modules</h1></div></div></div><p>In this <a id="id212" class="indexterm"/>recipe, we will pass <code class="literal">Queues</code> around<a id="id213" class="indexterm"/> different modules. As our GUI code increases in complexity, we want to separate the GUI components from the business logic, separating them out into different modules.</p><p>Modularization gives us code reuse and also makes the code more readable.</p><p>Once the data to be displayed in our GUI comes from different data sources, we will face latency issues, which is what <code class="literal">Queues</code> solve. By passing instances of <code class="literal">Queues</code> among different Python modules, we are separating the different concerns of the modules' functionalities.</p><div><div><h3 class="title"><a id="note62"/>Note</h3><p>The GUI code ideally would only be concerned with creating and displaying widgets.</p><p>The business logic modules' job is to only do the business logic.</p></div></div><p>We<a id="id214" class="indexterm"/> have to combine the two elements, ideally<a id="id215" class="indexterm"/> using as few relations among the different modules, reducing code interdependence.</p><div><div><h3 class="title"><a id="note63"/>Note</h3><p>The coding principle of avoiding unnecessary dependencies is usually called "loose coupling".</p></div></div><p>In order to understand the significance of loose coupling, we can draw some boxes on a whiteboard or a piece of paper. One box represents our GUI class and code, while the other boxes represent business logic, databases, and so on.</p><p>Next, we draw lines between the boxes, graphing out the interdependencies between those boxes which are our Python modules.</p><div><div><h3 class="title"><a id="note64"/>Note</h3><p>The fewer lines we have between our Python boxes, the more loosely-coupled our design is.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec149"/>Getting ready</h2></div></div></div><p>In the previous recipe, we have started to use <code class="literal">Queues</code>. In this recipe we will pass instances of a <code class="literal">Queue</code> from our main GUI thread to other Python modules, which will enable us to write to the <code class="literal">ScrolledText</code> widget from another module while keeping our GUI responsive.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec150"/>How to do it...</h2></div></div></div><p>First, we create a new Python module in our project. Let's call it <code class="literal">Queues.py</code>. We'll place a function into it (no OOP necessary yet) and pass it an instance of the queue.</p><p>We also pass a self-reference of the class that creates the GUI form and widgets, which enables us to use all of the GUI methods from another Python module.</p><p>We do this in the button callback.</p><div><div><h3 class="title"><a id="note65"/>Note</h3><p>This is the magic of OOP. In the middle of a class, we pass ourselves into a function we are calling from within the class, using the <code class="literal">self</code> keyword.</p></div></div><p>The code<a id="id216" class="indexterm"/> now looks like this.</p><div><pre class="programlisting">import B04829_Queues as bq

class OOP():
    # Button callback
    def clickMe(self):
      # Passing in the current class instance (self)
        print(self)
        bq.writeToScrol(self)</pre></div><p>The<a id="id217" class="indexterm"/> imported module contains the function we are calling,</p><div><pre class="programlisting">def writeToScrol(inst):
    print('hi from Queue', inst)
    inst.createThread(6)
</pre></div><p>We have commented out the call to <code class="literal">createThread</code> in the button callback because we are now calling it from our new module.</p><div><pre class="programlisting">
# Threaded method does not freeze our GUI
# self.createThread()</pre></div><p>By passing in a self-reference from the class instance to the function the class is calling in another module, we now have access to all of our GUI elements from other Python modules.</p><p>Running the code creates the following result.</p><div><img src="img/B04829_06_15.jpg" alt="How to do it..."/></div><p>Next, we <a id="id218" class="indexterm"/>will create the <code class="literal">Queue</code> as a member <a id="id219" class="indexterm"/>of our class, placing a reference to it in the <code class="literal">__init__</code> method of the class.</p><div><pre class="programlisting">class OOP():
    def __init__(self):
        # Create a Queue
        self.guiQueue = Queue()</pre></div><p>Now we can put messages into the queue from our new module by simply using the passed-in class reference to our GUI.</p><div><pre class="programlisting">def writeToScrol(inst):
    print('hi from Queue', inst)
    for idx in range(10):
        inst.guiQueue.put('Message from a queue: ' + str(idx))
    inst.createThread(6)</pre></div><p>The <code class="literal">createThread</code> method in our GUI code now only reads from the queue, which got filled in by the business logic residing in our new module, which has separated the logic from our GUI module.</p><div><pre class="programlisting">def useQueues(self):
    # Now using a class member Queue
    while True:
        print(self.guiQueue.get())</pre></div><p>Running our modified code creates the same results. We have not broken anything (yet)!</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec151"/>How it works...</h2></div></div></div><p>In<a id="id220" class="indexterm"/> order to separate the GUI widgets from <a id="id221" class="indexterm"/>the functionality that expresses the business logic, we created a class, made a queue a member of this class and, by passing an instance of the class into a function residing in a different Python module, we now have access to all of the GUI widgets as well as the <code class="literal">Queue</code>.</p><p>This recipe is an example of when it makes sense to program in OOP.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Using dialog widgets to copy files to your network</h1></div></div></div><p>This <a id="id222" class="indexterm"/>recipe shows us how to copy<a id="id223" class="indexterm"/> files from your local hard drive to a network location.</p><p>We will do this by using one of Python's tkinter built-in dialogs, which enables us to browse our hard drive. We can then select a file to be copied.</p><p>This recipe also shows us how to make <code class="literal">Entry</code> widgets read-only and to default our <code class="literal">Entry</code> to a specified location, which speeds up the browsing of our hard drive.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec152"/>Getting ready</h2></div></div></div><p>We will extend <strong>Tab 2</strong> of the GUI we have been building in previous recipes.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec153"/>How to do it...</h2></div></div></div><p>Add the following code to our GUI in the <code class="literal">def createWidgets(self)</code> method towards the bottom where we created Tab Control 2.</p><p>The parent of the new widget frame is <code class="literal">tab2</code>, which we have created at the very beginning of the <code class="literal">createWidgets()</code> method. As long as you place the code shown as follows physically below the creation of <code class="literal">tab2</code>, it will work.</p><div><pre class="programlisting">###########################################################
    def createWidgets(self):
        tabControl = ttk.Notebook(self.win)  # Create Tab  
        tab2 = ttk.Frame(tabControl)         # Add a second tab
        tabControl.add(tab2, text='Tab 2')

# Create Manage Files Frame 
mngFilesFrame = ttk.LabelFrame(tab2, text=' Manage Files: ')
mngFilesFrame.grid(column=0, row=1, sticky='WE', padx=10, pady=5)

# Button Callback
def getFileName():
    print('hello from getFileName')

# Add Widgets to Manage Files Frame
lb = ttk.Button(mngFilesFrame, text="Browse to File...", command=getFileName)
lb.grid(column=0, row=0, sticky=tk.W) 
     
file = tk.StringVar()
self.entryLen = scrolW
self.fileEntry = ttk.Entry(mngFilesFrame, width=self.entryLen, textvariable=file)
self.fileEntry.grid(column=1, row=0, sticky=tk.W)
    
logDir = tk.StringVar()
self.netwEntry = ttk.Entry(mngFilesFrame, width=self.entryLen, textvariable=logDir)
self.netwEntry.grid(column=1, row=1, sticky=tk.W) 
        def copyFile():
        import shutil   
        src  = self.fileEntry.get()
        file = src.split('/')[-1]  
        dst  = self.netwEntry.get() + '\\'+ file
        try:
            shutil.copy(src, dst)   
            mBox.showinfo('Copy File to Network', 'Success: File copied.')
        except FileNotFoundError as err:
            mBox.showerror('Copy File to Network', '*** Failed to copy file! ***\n\n' + str(err))
        except Exception as ex:
            mBox.showerror('Copy File to Network', '*** Failed to copy file! ***\n\n' + str(ex))
        
        cb = ttk.Button(mngFilesFrame, text="Copy File To :   ", command=copyFile)
        cb.grid(column=0, row=1, sticky=tk.E)
                
        # Add some space around each label
        for child in mngFilesFrame.winfo_children(): 
            child.grid_configure(padx=6, pady=6)</pre></div><p>This<a id="id224" class="indexterm"/> will add two buttons and two <a id="id225" class="indexterm"/>entries to <strong>Tab 2</strong> of our GUI.</p><p>We are not yet implementing the functionality of our button callback function.</p><p>Running the code creates the following GUI:</p><div><img src="img/B04829_06_16.jpg" alt="How to do it..."/></div><p>Clicking the <strong>Browse to File…</strong> button currently prints to the console.</p><div><img src="img/B04829_06_17.jpg" alt="How to do it..."/></div><p>We can<a id="id226" class="indexterm"/> use tkinter's built-in file <a id="id227" class="indexterm"/>dialogs so let's add the following <code class="literal">import</code> statements to the top of our Python GUI module.</p><div><pre class="programlisting">from tkinter import filedialog as fd
from os import path</pre></div><p>We can now use the dialogs in our code. Instead of hard-coding a path, we can use Python's os module to find the full path to where our GUI module resides.</p><div><pre class="programlisting">def getFileName():
    print('hello from getFileName')
    fDir  = path.dirname(__file__)
    fName = fd.askopenfilename(parent=self.win, initialdir=fDir)</pre></div><p>Clicking the browse button now opens up the <code class="literal">askopenfilename</code> dialog.</p><div><img src="img/B04829_06_18.jpg" alt="How to do it..."/></div><p>We can <a id="id228" class="indexterm"/>now open a file in this directory<a id="id229" class="indexterm"/> or browse to a different directory. After selecting a file and clicking the <strong>Open</strong> button in the dialog, we will save the full path to the file in the <code class="literal">fName</code> local variable.</p><p>It would be nice if, when we opened our Python <code class="literal">askopenfilename</code> dialog widget, we would automatically default to a directory so that we would not have to browse all the way to where we were looking for a particular file to be opened.</p><p>It is best to demonstrate how to do this by going back to our GUI <strong>Tab 1</strong>, which is what we will do next.</p><p>We can default values into Entry widgets. Back on our <strong>Tab 1</strong>, this is very easy. All we have to do is add the following two lines of code to the creation of the <code class="literal">Entry</code> widget.</p><div><pre class="programlisting"># Adding a Textbox Entry widget
self.name = tk.StringVar()
nameEntered = ttk.Entry(self.monty, width=24, textvariable=self.name)
nameEntered.grid(column=0, row=1, sticky='W')
nameEntered.delete(0, tk.END)
nameEntered.insert(0, '&lt; default name &gt;')</pre></div><p>When we now run the GUI, the <code class="literal">nameEntered</code> Entry has a default value.</p><div><img src="img/B04829_06_19.jpg" alt="How to do it..."/></div><p>We can<a id="id230" class="indexterm"/> get the full path to the module <a id="id231" class="indexterm"/>we are using with the following Python syntax and then we can create a new subfolder just below it. We can do this as a module level global, or we can create the subfolder within a method.</p><div><pre class="programlisting"># Module level GLOBALS
GLOBAL_CONST = 42
fDir   = path.dirname(__file__)
netDir = fDir + '\\Backup'

def __init__(self):
    self.createWidgets()       
    self.defaultFileEntries()

def defaultFileEntries(self):
    self.fileEntry.delete(0, tk.END)
    self.fileEntry.insert(0, fDir) 
    if len(fDir) &gt; self.entryLen:
        self.fileEntry.config(width=len(fDir) + 3)
        self.fileEntry.config(state='readonly')

    self.netwEntry.delete(0, tk.END)
    self.netwEntry.insert(0, netDir) 
    if len(netDir) &gt; self.entryLen:
        self.netwEntry.config(width=len(netDir) + 3)</pre></div><p>We are setting defaults for both entry widgets and, after setting them, we make the local file entry widget read-only.</p><div><div><h3 class="title"><a id="note66"/>Note</h3><p>This order is important. We have to first populate the entry before we make it read-only.</p></div></div><p>We are <a id="id232" class="indexterm"/>also selecting <strong>Tab 2</strong> before<a id="id233" class="indexterm"/> calling the main event loop and no longer set the focus into the <code class="literal">Entry</code> of <strong>Tab 1</strong>. Calling <code class="literal">select</code> on our tkinter <code class="literal">notebook</code> is zero-based so by passing in the value of 1 we select <strong>Tab 2</strong>…</p><div><pre class="programlisting"># Place cursor into name Entry
# nameEntered.focus()             
tabControl.select(1)</pre></div><div><img src="img/B04829_06_20.jpg" alt="How to do it..."/></div><p>As we are not all on the same network, this recipe will use the local hard drive as an example for a network.</p><p>A UNC path is a Universal Naming Convention and what this means is that we can access a server on our network by using double backslashes to access a network server instead of the typical <code class="literal">C:\</code> when we access our local hard drive on a Windows PC.</p><div><div><h3 class="title"><a id="note67"/>Note</h3><p>You just have to use the UNC and replace <code class="literal">C:\</code> with <code class="literal">\\&lt;server name&gt; \&lt;folder&gt;\</code>.</p></div></div><p>This example can be used to back up our code to a backup directory, which we can create if it does not exist by using <code class="literal">os.makedirs</code>.</p><div><pre class="programlisting"># Module level GLOBALS
GLOBAL_CONST = 42

from os import makedirs
fDir   = path.dirname(__file__)
netDir = fDir + '\\Backup' 
if not path.exists(netDir):
    makedirs(netDir, exist_ok = True)</pre></div><p>After<a id="id234" class="indexterm"/> selecting a file to copy to somewhere else, we<a id="id235" class="indexterm"/> import the Python <code class="literal">shutil</code> module. We need the full path to the source of the file to be copied, a network or local directory path, and then we append the file name to the path where we are going to copy it, using <code class="literal">shutil.copy</code>.</p><div><div><h3 class="title"><a id="note68"/>Note</h3><p>Shutil is short-hand notation for shell utility.</p></div></div><p>We also give feedback to the user via a message box to indicate whether the copying succeeded or failed. In order to do this, import <code class="literal">messagebox</code> and rename it <code class="literal">mBox</code>.</p><p>In the following code, we will mix two different approaches of where to place our import statements. In Python, we have some flexibility that other languages do not provide.</p><p>We typically place all of the import statements towards the very top of each of our Python modules so that it is clear which modules we are importing.</p><p>At the same time, a modern coding approach is to place the creation of variables close to the function or method where they are first being used.</p><p>In the following code, we import the message box at the top of our Python module, but then we also import the shutil Python module in a function.</p><p>Why would we wish to do this?</p><p>Does this even work?</p><p>The answer is, yes, it does work, and we are placing this import statement into a function because this is the only place in our code where we actually do need this module.</p><p>If we never call this method, then we will never import the module this method requires.</p><p>In a sense, you can view this technique as the lazy initialization design pattern.</p><p>If we don't need it, we don't import it until we really do require it in our Python code.</p><p>The idea here is that our entire code might require, let's say, twenty different modules. At runtime, which modules are really needed depends upon the user interaction. If we never call the <code class="literal">copyFile()</code> function then there is no need to import <code class="literal">shutil</code>.</p><p>Once<a id="id236" class="indexterm"/> we click the button that invokes<a id="id237" class="indexterm"/> the <code class="literal">copyFile()</code> function in this function, we import the required module.</p><div><pre class="programlisting">from tkinter import messagebox as mBox

def copyFile():
    import shutil   
    src = self.fileEntry.get()
    file = src.split('/')[-1]  
    dst = self.netwEntry.get() + '\\'+ file
    try:
      shutil.copy(src, dst)   
      mBox.showinfo('Copy File to Network', 'Success: File copied.')
    except FileNotFoundError as err:
      mBox.showerror('Copy File to Network', '*** Failed to copy file! ***\n\n' + str(err))
    except Exception as ex:
      mBox.showerror('Copy File to Network', '*** Failed to copy file! ***\n\n' + str(ex))</pre></div><p>When we now run our GUI and browse to a file and click copy, the file is copied to the location we specified in our <code class="literal">Entry</code> widget.</p><div><img src="img/B04829_06_21.jpg" alt="How to do it..."/></div><p>If the file does not exist or we forgot to browse to a file and are trying to copy the entire parent folder, the code will let us know this as well because we are using Python's built-in exception handling capabilities.</p><div><img src="img/B04829_06_22.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec154"/>How it works...</h2></div></div></div><p>We are <a id="id238" class="indexterm"/>copying files from our local hard <a id="id239" class="indexterm"/>drive to a network by using the Python shell utility. As most of us are not connected to the same local area network, we simulate the copying by backing up our code to a different local folder.</p><p>We are using one of tkinter's dialog controls and, by defaulting directory paths, we can increase our efficiency in copying files.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Using TCP/IP to communicate via networks</h1></div></div></div><p>This <a id="id240" class="indexterm"/>recipe shows you how to use sockets<a id="id241" class="indexterm"/> to communicate via TCP/IP. In order to achieve this, we need both an IP address and a port number.</p><p>In order to keep things simple and independent of the ever-changing internet IP addresses, we will create our own local TCP/IP server and, as a client, learn how to connect to it and read data from a TCP/IP connection.</p><p>We will integrate this networking capability into our GUI by using the queues we created in previous recipes.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec155"/>Getting ready</h2></div></div></div><p>We will create a new Python module, which will be the TCP server.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec156"/>How to do it...</h2></div></div></div><p>One way to implement a TCP server in Python is to inherit from the <code class="literal">socketserver</code> module. We subclass <code class="literal">BaseRequestHandler</code> and then override the inherited <code class="literal">handle</code> method. In <a id="id242" class="indexterm"/>very few lines of Python <a id="id243" class="indexterm"/>code, we can implement a TCP server module.</p><div><pre class="programlisting">from socketserver import BaseRequestHandler, TCPServer

class RequestHandler(BaseRequestHandler):
    # override base class handle method
    def handle(self):
        print('Server connected to: ', self.client_address)
        while True:
            rsp = self.request.recv(512)
            if not rsp: break
            self.request.send(b'Server received: ' + rsp)

def startServer():
    serv = TCPServer(('', 24000), RequestHandler)
    serv.serve_forever()</pre></div><p>We are passing in our <code class="literal">RequestHandler</code> class into a <code class="literal">TCPServer</code> initializer. The empty single quotes are a short cut for passing in localhost, which is our own PC. This is the IP address of 127.0.0.1. The second item in the tuple is the port number. We can choose any port number that is not in use on our local PC.</p><p>We just have to make sure that we are using the same port on the client side of the TCP connection, otherwise we would not be able to connect to the server. Of course, we have to start the server first before clients can connect to it.</p><p>We will modify our <code class="literal">Queues.py</code> module to become the TCP client.</p><div><pre class="programlisting">from socket import socket, AF_INET, SOCK_STREAM

def writeToScrol(inst):
    print('hi from Queue', inst)
    sock = socket(AF_INET, SOCK_STREAM)
    sock.connect(('localhost', 24000))
    for idx in range(10):
        sock.send(b'Message from a queue: ' + bytes(str(idx).encode()) )
        recv = sock.recv(8192).decode()
        inst.guiQueue.put(recv)      
    inst.createThread(6)</pre></div><p>This is all the code we need to talk to the TCP server. In this example, we are simply sending some bytes to the server and the server sends them back, prepending some strings before returning the response.</p><div><div><h3 class="title"><a id="note69"/>Note</h3><p>This shows the principle of how TCP communications via networks work.</p></div></div><p>Once <a id="id244" class="indexterm"/>we know how to connect to a remote<a id="id245" class="indexterm"/> server via TCP/IP, we will use whatever commands are designed by the protocol of the program we are interested in communicating with. The first step is to connect before we can send commands to specific applications residing on a server.</p><p>In the <code class="literal">writeToScrol</code> function, we will use the same loop as before but now we will send the messages to the TCP server. The server modifies the received message and then sends it back to us. Next, we place it into the GUI member queue which, as in previous recipes, runs in its own <code class="literal">Thread</code>.</p><div><div><h3 class="title"><a id="note70"/>Note</h3><p>In Python 3, we have to send strings over sockets in binary format. Adding the integer index now becomes a little bit convoluted as we have to cast it to a string, encode it, and then cast the encoded string into bytes!</p></div></div><div><pre class="programlisting">sock.send(b'Message from a queue: ' + bytes(str(idx).encode()) )</pre></div><p>Note the <code class="literal">b</code> before the string and then, well, all the rest of the required casting…</p><p>We are starting the TCP server in its own thread in the initializer of the OOP class.</p><div><pre class="programlisting">class OOP():
    def __init__(self):
    # Start TCP/IP server in its own thread
        svrT = Thread(target=startServer, daemon=True)
        svrT.start()</pre></div><p>Clicking the <strong>Click Me!</strong> button on <strong>Tab 1</strong> now creates the following output in our <code class="literal">ScrolledText</code> widget, as well as on the console, and the response, due to using <code class="literal">Threads</code>, is very fast.</p><div><img src="img/B04829_06_23.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec157"/>How it works...</h2></div></div></div><p>We<a id="id246" class="indexterm"/> created a TCP server to simulate<a id="id247" class="indexterm"/> connecting to a server in our local area network or on the Internet. We turned our queues module into a TCP client. We are running both the queue and the server in their own background thread, which keeps our GUI very responsive.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Using URLOpen to read data from websites</h1></div></div></div><p>This <a id="id248" class="indexterm"/>recipe shows how we can easily <a id="id249" class="indexterm"/>read entire webpages by using Python's built-in modules. We will display the webpage data first in its raw format and then decode it, and then we will display it in our GUI.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec158"/>Getting ready</h2></div></div></div><p>We will read the data from a webpage and then display it in the <code class="literal">ScrolledText</code> widget of our GUI.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec159"/>How to do it...</h2></div></div></div><p>First, we create a new Python module and name it <code class="literal">URL.py</code>.</p><p>We then import the required functionality to read webpages using Python.</p><p>We can do this in very few lines of code.</p><p>We are wrapping our code in a <code class="literal">try…except</code> block similar to Java and C#. This is a modern approach to coding which Python supports.</p><p>Whenever we have code that might not complete we can experiment with this code and, if it works, all is fine.</p><p>If the block of code in the <code class="literal">try…except</code> block does not work, the Python interpreter will throw one of several possible exceptions, which we then can catch. Once we have caught the <a id="id250" class="indexterm"/>exception we can decide what<a id="id251" class="indexterm"/> to do next.</p><p>There is a hierarchy of exceptions in Python and we can also create our own classes that inherit from and extend the Python exception classes.</p><p>In the code shown as follows, we are mainly concerned that the URL we are trying to open might not be available and so we wrap our code within a <code class="literal">try…except</code> code block.</p><p>If the code succeeds in opening the requested URL, all is fine.</p><p>If it fails, maybe because our internet connection is down, we fall into the exception part of the code and print out that an exception has occurred.</p><div><div><h3 class="title"><a id="note71"/>Note</h3><p>You <a id="id252" class="indexterm"/>can read more about Python exception handling at <a class="ulink" href="https://docs.python.org/3.4/library/exceptions.html">https://docs.python.org/3.4/library/exceptions.html</a>.</p></div></div><div><pre class="programlisting">from urllib.request import urlopen
link = 'http://python.org/' 
try:
    f = urlopen(link)
    print(f)
    html = f.read()
    print(html)
    htmldecoded = html.decode()
    print(htmldecoded)
 
except Exception as ex:
    print('*** Failed to get Html! ***\n\n' + str(ex))</pre></div><p>By calling <code class="literal">urlopen</code> on the official Python website, we get the entire data as one long string.</p><p>The first print statement prints this long string out to the console.</p><p>We then call <code class="literal">decode</code> on the result and this time we get a little over 1,000 lines of web data, including some whitespace.</p><p>We are also printing out the type of calling <code class="literal">urlopen</code>, which is an <code class="literal">http.client.HTTPResponse</code> object. Actually, we are printing it out first.</p><div><img src="img/B04829_06_24.jpg" alt="How to do it..."/></div><p>Here is <a id="id253" class="indexterm"/>the official Python webpage <a id="id254" class="indexterm"/>we just read. If you are a web developer, you probably have some good ideas what to do with the parsed data.</p><div><img src="img/B04829_06_25.jpg" alt="How to do it..."/></div><p>We next display this data in our GUI inside the <code class="literal">ScrolledText</code> widget. In order to do so, we have to connect our new module to read the data from the webpage to our GUI.</p><p>In order to do this, we need a reference to our GUI, and one way to do this is by tying our new module to the <strong>Tab 1</strong> button callback.</p><p>We can return the decoded HTML data from the Python webpage to the <code class="literal">Button</code> widget, which we can then place in the <code class="literal">ScrolledText</code> control.</p><p>So, let's turn our code into a function and return the data to the calling code.</p><div><pre class="programlisting">from urllib.request import urlopen
link = 'http://python.org/'
def getHtml():
    try:
        f = urlopen(link)
        #print(f)
        html = f.read()
        #print(html)
        htmldecoded = html.decode()
        #print(htmldecoded)     
    except Exception as ex:
        print('*** Failed to get Html! ***\n\n' + str(ex))
    else:
        return htmldecoded  </pre></div><p>We can <a id="id255" class="indexterm"/>now write the data in our <code class="literal">button</code> callback <a id="id256" class="indexterm"/>method to the <code class="literal">ScrolledText</code> control by first importing the new module and then inserting the data into the widget. We also give it some sleep after the call to <code class="literal">writeToScrol</code>.</p><div><pre class="programlisting">import B04829_Ch06_URL as url

# Button callback
def clickMe(self):
  bq.writeToScrol(self)       
  sleep(2)
  htmlData = url.getHtml()
  print(htmlData)
  self.scr.insert(tk.INSERT, htmlData)</pre></div><p>The HTML data is now displayed in our GUI widget.</p><div><img src="img/B04829_06_26.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec160"/>How it works...</h2></div></div></div><p>We create<a id="id257" class="indexterm"/> a new module to separate the <a id="id258" class="indexterm"/>code that gets the data from a webpage from our GUI code. This is always a good thing to do. We read in the webpage data and then return it to the calling code after decoding it. We then use the button callback function to place the returned data in the <code class="literal">ScrolledText</code> control.</p><p>This chapter introduced us to some advanced Python programming concepts, which we combined to produce a functional GUI program.</p></div></div></div>
</body></html>