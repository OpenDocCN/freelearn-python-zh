- en: Working with Class-Based Views and Hyperlinked APIs in Django 2.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will expand the capabilities of the RESTful API that we
    started in the previous chapter. We will change the ORM settings to work with
    a more powerful PostgreSQL 10.5 database and we will take advantage of advanced
    features included in **Django REST Framework** (**DRF**) that allow us to reduce
    boilerplate code for complex APIs, such as class-based views. We will look at
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use model serializers to eliminate duplicate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with wrappers to write API views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the default parsing and rendering options and move beyond JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browse the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design a RESTful API to interact with a complex PostgreSQL 10.5 database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the tasks performed by each HTTP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare relationships with the models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install packages with the requirements file to work with PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify the contents of the PostgreSQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage serialization and deserialization with relationships and hyperlinks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create class-based views and use generic classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take advantage of generic class-based views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with endpoints for the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browse an API with relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and retrieve related resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using model serializers to eliminate duplicate code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GameSerializer` class we coded in [Chapter 5](e8d188a7-452a-4ce2-8e00-37eeeaabb879.xhtml),
    *Developing RESTful APIs with Django 2.1*, declares many attributes with the same
    names that we used in the `Game` model and repeats information such as the field
    types and the `max_length` values. The `GameSerializer` class is a subclass of
    the `rest_framework.serializers.Serializer` superclass and it declares attributes
    that we manually mapped to the appropriate types, and overrides the `create` and
    `update` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will create a new version of the `GameSerializer` class that will inherit
    from the `rest_framework.serializers.ModelSerializer` superclass. The `ModelSerializer`
    class automatically populates both a set of default fields and a set of default
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Working with wrappers to write API views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our code in the `games_service/games/views.py` file declared a `JSONResponse`
    class and two function-based views. These functions returned `JSONResponse` when
    it was necessary to return JSON data and a `django.Http.Response.HttpResponse`
    instance when the response was just an HTTP status code. Hence, no matter what
    the accepted content type that's specified in the HTTP request header, the view
    functions always provide the same content in the response body—JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following two commands to retrieve all the games with different values
    for the `Accept` request header: `text/html` and `application/json`. The code
    file for the sample is included in the `restful_python_2_06_01` folder, in the
    `Django01/cmd/cmd601.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent `curl` commands. The code file for the sample
    is included in the `restful_python_2_06_01` folder, in the `Django01/cmd/cmd602.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/`. We have requested both `http` and `curl` to enable
    the verbose mode with the `-v` option in which they specify more details about
    the operation and display the whole request, including the request header.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command defines the `text/html` value for the `Accept` request header.
    The second command defines the `application/json` value for the `Accept` request
    header. You will notice that both commands produce the same results, and therefore,
    the view functions don''t take into account the value specified for the `Accept`
    request header in the HTTP requests. The header response for both commands will
    include the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The second request specified that it will only accept `text/html`, but the response
    included a JSON body, that is, `application/json` content. Thus, our first version
    of the RESTful API is not prepared to render content other from JSON. We will
    make some changes to enable the API to render other contents.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we have doubts about the methods supported by a resource or resource
    collection in a RESTful API, we can compose and send an HTTP request with the
    `OPTIONS` HTTP verb and the URL for the resource or resource collection. If the
    RESTful API implements the `OPTIONS` HTTP verb for a resource or resource collection,
    it provides a comma-separated list of HTTP verbs or methods that it supports as
    a value for the `Allow` header in the response. In addition, the response header
    will include additional information about other supported options, such as the
    content type it is capable of parsing from the request and the content type it
    is capable of rendering on the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to know which HTTP verbs the games collection supports,
    we can run the following command. The code file for the sample is included in
    the `restful_python_2_06_01` folder, in the `Django01/cmd/cmd603.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_06_01` folder, in the `Django01/cmd/cmd604.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/games/`. The request will match and run the `views.game_collection`
    function, that is, the `game_collection` function declared within the `game_service/games/views.py`
    file. This function only runs code when the `request.method` is equal to `''GET''`
    or `''POST''`. In this case, `request.method` is equal to `''OPTIONS''`, and therefore,
    the function won''t run any code and won''t return any response, specifically,
    it won''t return an `HttpResponse` instance. As a result, we will see the `Internal
    Server Error` shown in the next screenshot listed in Django''s development server
    console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdfed8ed-cf45-47a3-b169-94087e6098d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following lines show the header for the output that also includes a huge
    HTML document with detailed information about the error because the debug mode
    is activated for Django. We receive a `500 Internal Server Error` status code.
    Notice that you will have to scroll up in the Terminal or Command Prompt to find
    these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we want to provide a more consistent API and we want to provide an
    accurate response when we receive a request with the `OPTIONS` verbs for either
    a game resource or the games collection.
  prefs: []
  type: TYPE_NORMAL
- en: If we compose and send an HTTP request with the `OPTIONS` verb for a game resource,
    we will see the same error and we will have a similar response because the `views.game_detail`
    function only runs code when `request.method` is equal to `'GET'`, `'PUT'`, or
    `'DELETE'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will produce the explained error when we try to see
    the options offered for the game resource whose ID is equal to `2`. Don''t forget
    to replace `2` with a primary key value of an existing game in your configuration.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/cmd/cmd605.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_06_01` folder, in the `Django01/cmd/cmd606.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We just need to make a few small changes in the `games_service/games/views.py`
    file to solve the issues we have been analyzing for our RESTful API. We will use
    the useful `@api_view` decorator, declared in the `rest_framework.decorators`
    module, for our function-based views. This decorator allows us to specify which
    are the HTTP verbs that our function can process. If the request that has to be
    processed by the view function has an HTTP verb that isn't included in the string
    list specified as the `http_method_names` argument for the `@api_view` decorator,
    the default behavior returns a `405 Method Not Allowed` status code. This way,
    we make sure that whenever we receive an HTTP verb that isn't considered within
    our function view, we won't generate an unexpected error as the decorator handles
    the response for the unsupported HTTP verbs or methods.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the `@api_view` decorator is a wrapper that converts a function-based
    view into a subclass of the `rest_framework.views.APIView` class. This class is
    the base class for all view in Django REST Framework. As we might guess, if we
    want to work with class-based views, we can create classes that inherit from this
    class and we will have the same benefits we have analyzed for the function-based
    views that use the decorator. We will start working with class-based views in
    the forthcoming examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, as we specify a string list with the supported HTTP verbs, the
    decorator automatically builds the response for the `OPTIONS` HTTP verb with the
    supported methods, parser, and rendering capabilities. Our actual version of the
    API is just capable of rendering JSON as its output. The usage of the decorator
    makes sure that we always receive an instance of the `rest_framework.request.Request`
    class in the `request` argument when Django calls our view function. The decorator
    also handles the `ParserError` exceptions when our function views access the `request.data`
    attribute that might cause parsing problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using the default parsing and rendering options and moving beyond JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `APIView` class specifies default settings for each view that we can override
    by specifying appropriate values in the `games_service/settings.py` file or by
    overriding the class attributes in subclasses of the `APIView` superclass. As
    we learned, the usage of the `APIView` class under the hoods makes the decorator
    apply these default settings. Thus, whenever we use the decorator, the default
    parser classes and the default renderer classes will be associated with the function
    views.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the value for the `DEFAULT_PARSER_CLASSES` configuration variable
    is the following tuple of strings with three parser class names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Browsing the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the recent edits, we made it possible for our API to use the default content
    renderers configured in Django REST Framework, and therefore, our API is capable
    of rendering `text/html` content. We can take advantage of the browsable API,
    a feature included in Django REST Framework that generates human-friendly HTML
    output for each resource whenever the request specifies `text/html` as the value
    for the `Content-type` key in the request header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we enter a URL for an API resource in a web browser, the browser will
    require an HTML response, and therefore, Django REST Framework will provide an
    HTML response built with the Bootstrap popular frontend component library. You
    can read more about Bootstrap here: [http://getbootstrap.com](http://getbootstrap.com).
    This response will include a section that displays the resource content in JSON,
    buttons to perform different requests, and forms to submit data to the resources.
    As with everything in Django REST Framework, we can customize the templates and
    themes used to generate the browsable API.'
  prefs: []
  type: TYPE_NORMAL
- en: Open a web browser and enter `http://localhost:8000/games/`. The browsable API
    will compose and send an HTTP `GET` request to `/games/` and will display the
    results of its execution, that is, the headers and the JSON games list. The following
    screenshot shows the rendered web page after entering the URL in a web browser
    with the resource description of Game List
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94318302-64a2-40ae-9313-6d009f2fde7b.png)'
  prefs: []
  type: TYPE_IMG
- en: If you decide to browse the API in a web browser running on another computer
    or device connected to the LAN, remember that you have to use the development
    computer's assigned IP address, instead of localhost. For example, if the computer's
    assigned IPv4 IP address is `192.168.1.103`, instead of `http://localhost:8000/games/`,
    you should use `http://192.168.1.103:8000/games/`. Of course, you can also use
    the hostname instead of the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: The browsable API uses information about the allowed methods for a resource
    to provide us with buttons to run these methods. At the right-hand side of the
    resource description, the browsable API shows an OPTIONS button and a GET drop-down
    button. The OPTIONS button allows us to make an `OPTIONS` request to `/games/`,
    that is, to the current resource. The GET drop-down button allows us to make a
    `GET` request to `/games/` again. If we click or tap the down arrow, we can select
    the json option and the browsable API will display the raw JSON results of a `GET`
    request to `/games/` without the headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the rendered web page, the browsable API provides us some
    controls to generate a `POST` request to `/games/`. The Media type drop-down allows
    us to select between the configured supported parsers for our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/x-www-form-urlencoded`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multipart/form-data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Content textbox allows us to specify the data to be sent to the `POST`
    request formatted as specified in the Media type drop-down. Select application/json
    in the Media type drop-down and enter the following JSON content in the Content
    textbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Click or tap POST. The browsable API will compose and send a `POST` request
    to `/games/` with the previously specified data as JSON and we will see the results
    of the call in the web browser. The following screenshot shows a web browser displaying
    the HTTP status code `201 Created` in the response and the previously explained
    drop-down and textbox with the POST button to allow us to continue composing and
    sending `POST` requests to `/games/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d865074b-cbfb-4b1a-9c29-f5aeb3f8a59f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now enter the URL for an existing game resource, such as `http://localhost:8000/games/7/`.
    Make sure you replace `7` with the ID of an existing game in the previously rendered
    Games List. The browsable API will compose and send an HTTP `GET` request to `/games/7/`
    and will display the results of its execution, that is, the headers and the JSON
    data for the game. The following screenshot shows the rendered web page after
    entering the URL in a web browser with the resource description of Game Detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/927c7515-dc6b-4c7e-82af-4ed4ac9ee68e.png)'
  prefs: []
  type: TYPE_IMG
- en: The browsable API feature allows us to easily check how the API works and to
    compose and send HTTP requests with different methods in any web browser that
    has access to our LAN. We will take advantage of additional features included
    in the browsable API, such as HTML forms that allow us to easily create new resources
    later after we build a new more complex RESTful API with Python and Django REST
    Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with a complex PostgreSQL 10.5 database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our Django-based RESTful API performed CRUD operations on a single database
    table in an SQLite database. Now, we want to create a more complex RESTful API
    with Django REST Framework to interact with a complex database model that has
    to allow us to register player scores for playing games that are grouped into
    ESRB ratings. In our previous RESTful API, we used a string field to specify the
    ESRB rating for a game. In this case, we want to be able to easily retrieve all
    the games that have a specific ESRB rating, and therefore, we will have a relationship
    between a game and an ESRB rating.
  prefs: []
  type: TYPE_NORMAL
- en: We must be able to perform CRUD operations on different related resources ...
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the tasks performed by each HTTP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our API must support. Each method is composed by an HTTP verb
    and a scope and all the methods have well-defined meanings for all the resources
    and collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb | Scope | Semantics |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of ESRB ratings | Retrieve all the stored ESRB ratings
    in the collection, sorted by their description in ascending order. Each ESRB rating
    must include a list of URLs for each game resource that belongs to the rating.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | ESRB rating | Retrieve a single ESRB rating. The ESRB rating must
    include a list of URLs for each game resource that belongs to the rating. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of ESRB ratings | Create a new ESRB rating in the collection.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | ESRB rating | Update an existing ESRB rating. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | ESRB rating | Update one or more fields of an existing ESRB rating.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | ESRB rating | Delete an existing ESRB rating. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of games | Retrieve all the stored games in the collection,
    sorted by their name in ascending order. Each game must include its ESRB rating
    description. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Game | Retrieve a single game. The game must include its ESRB rating
    description. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of games | Create a new game in the collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | ESRB rating | Update an existing game. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | ESRB rating | Update one or more fields of an existing game. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | ESRB rating | Delete an existing game. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of players | Retrieve all the stored players in the collection,
    sorted by their name in ascending order. Each player must include a list of the
    registered scores, sorted by score in descending order. The list must include
    all the details for the score achieved by the player and its related game. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Player | Retrieve a single player. The player must include a list
    of the registered scores, sorted by score in descending order. The list must include
    all the details for the score achieved by the player and its related game. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of players | Create a new player in the collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Player | Update an existing player. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Player | Update one or more fields of an existing player. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Player | Delete an existing player. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of scores | Retrieve all the stored scores in the collection,
    sorted by score in descending order. Each score must include the player''s name
    that achieved the score and the game''s name. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Score | Retrieve a single score. The score must include the player''s
    name that achieved the score and the game''s name. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of scores | Create a new score in the collection. The
    score must be related to an existing player and an existing game. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Score | Update an existing score. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Score | Update one or more fields of an existing score. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Score | Delete an existing score. |'
  prefs: []
  type: TYPE_TB
- en: We want our API to be able to update a single field for an existing resource,
    and therefore, we will provide an implementation for the `PATCH` method. In addition,
    our RESTful API must support the `OPTIONS` method for all the resources and collection
    of resources.
  prefs: []
  type: TYPE_NORMAL
- en: We will use all the features and reusable elements included in Django REST Framework
    to make it easy to build our API. We will work with a PostgreSQL 10.5 database.
    In case you don't want to spend time installing PostgreSQL, you can skip the changes
    we make in the Django REST Framework ORM configuration and continue working with
    the default SQLite database. However, it is highly recommended to work with PostgreSQL
    as the database engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous table, we have a huge number of methods and scopes. The following
    list enumerates the URIs for each scope mentioned in the previous table, where
    `{id}` has to be replaced with the numeric id of the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collection of ESRB ratings**: `/esrb-ratings/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ESRB rating**: `/esrb-rating/{id}/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection of games**: `/games/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game**: `/game/{id}/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection of players**: `/players/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player**: `/player/{id}/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection of scores**: `/player-scores/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Score**: `/player-score/{id}/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider that `http://localhost:8000/` is the URL for the API running
    on the Django development server. We have to compose and send an HTTP request
    with the following HTTP verb (`GET`) and request URL (`http://localhost:8000/esrb-ratings/`)
    to retrieve all the stored ESRB ratings in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Declaring relationships with the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you quit the Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the Terminal or Command Prompt window in which it is
    running. Now we will create the models that we will use to represent and persist
    the ESRB ratings, games, players and scores, and their relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `models.py` file in the `games_service/games` folder. Replace the
    code in this file with the following lines. The lines that declare fields related
    to other models are highlighted in the code listing. The code file for the sample
    is included in the `restful_python_2_06_01` folder, in the `Django01/games-service/games/models.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Installing packages with the requirements.txt file to work with PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you quit Django development server. You just need to press *Ctrl*
    + *C* in the Terminal or Command Prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will install an additional package. Make sure you have activated the
    virtual environment we have created in the previous chapter and we named `Django01`.
    After you activate the virtual environment, it is time to run many commands, which
    will be the same for either macOS, Linux, or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will edit the existing `requirements.txt` file to specify the additional
    package that our application requires to be installed on any supported platform.
    This way, it will be extremely easy to repeat the installation of the specified
    packages with their versions in any new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite editor to edit the existing text file named `requirements.txt`
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional package and the version that our new version
    of the API requires: `psycopg2` version 2.7.5\. The code file for the sample is
    included in the `restful_python_2_06_01` folder, in the `Django01/requirements.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Psycopg 2 (`psycopg2`) is a Python-PostgreSQL database adapter and Django's
    integrated ORM will use it to interact with our recently created PostgreSQL database.
    Again, it is very important to make sure that the PostgreSQL `bin` folder is included
    in the `PATH` environmental variable before we run the installation for this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions explained in the previous table with
    `pip` by using the recently edited `requirements.txt` file. Make sure you are
    in the folder that has the `requirements.txt` file (`Django01`) before running
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate the new package has been successfully
    installed. If you downloaded the source code for the example and you didn''t work
    with the previous version of the API, `pip` will also install the other packages
    included in the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default SQLite database engine and the database file name are specified
    in the `games_service/games_service/settings.py` Python file. In order to work
    with PostgreSQL 10.5 instead of SQLite for this example, replace the declaration
    of the `DATABASES` dictionary in this file with the following lines. The nested
    dictionary maps the database named `default` with the `django.db.backends.postgresql`
    database engine, the desired database name, and its settings. In this case, we
    will create a database named games.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you specify the desired database name in the value for the `'NAME'`
    key and that you configure the user, password, host, and port based on the user
    you recently created and your PostgreSQL 10.5 configuration. ...
  prefs: []
  type: TYPE_NORMAL
- en: Running migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now run the following Python script to generate the migrations that will allow
    us to synchronize the database for the first time. Make sure you are in the `games_service`
    folder within the root folder for the virtual environment (`Django01`). Notice
    that we use the Django app name, `games`, and not the PostgreSQL database name,
    `django_games` in the next script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that the `games_service/games/migrations/0001_initial.py`
    file includes the code to create the `EsrbRating`, `Game`, `Player`, and `PlayerScore`
    models. The following lines show the code for this file that was automatically
    generated by Django and its integrated ORM. The code file for the sample is included
    in the `restful_python_2_06_01` folder, in the `Django01/games-service/games/migrations/0001_initial.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a subclass of the `django.db.migrations.Migration` class named
    `Migration` that defines an `operations` list with many `migrations.CreateModel`.
    Each `migrations.CreateModel` method will create the table for each of the related
    models. Notice that Django has automatically added an `id` field for each of the
    models.
  prefs: []
  type: TYPE_NORMAL
- en: The `operations` are executed in the same order in which they appear in the
    list. The code creates `EsrbRating`, `Game`, `Player`, and `PlayerScore`. The
    code creates the foreign keys for `Game` and `PlayerScore` when it creates these
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the following Python script to apply all the generated migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the contents of the PostgreSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we run the previous command, we can use the PostgreSQL command line or
    any other application that allows us to easily check the contents of the PostgreSQL
    10.5 database to check the tables that Django generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to list the generated tables. If the database name
    you are using is not named `django_games`, make sure you use the appropriate database
    name. The code file for the sample is included in the `restful_python_2_06_01`
    folder, in the `Django01/cmd/list_database_tables.sql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output with all the generated table names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Managing serialization and deserialization with relationships and hyperlinks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our new RESTful Web API has to be able to serialize and deserialize the `EsrbRating`,
    `Game`, `Player`, and `PlayerScore` instances into JSON representations. In this
    case, we also have to pay special attention to the relationships between the different
    models when we create the serializer classes to manage serialization to JSON and
    deserialization from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In our last version of the previous API, we created a subclass of the `rest_framework.serializers.ModelSerializer`
    class to make it easier to generate a serializer and reduce boilerplate code.
    In this case, we will also declare a class that inherits from `ModelSerializer`
    but three classes will inherit from the `rest_framework.serializers.HyperlinkedModelSerializer`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '`HyperlinkedModelSerializer` is a type of `ModelSerializer` that uses hyperlinked
    relationships instead of primary key relationships, and therefore, it represents
    the relationships to other model instances with hyperlinks instead of primary
    key values. In addition, `HyperlinkedModelSerializer` generates a field named
    `url` with the URL for the resource as its value. As happens with `ModelSerializer`,
    the `HyperlinkedModelSerializer` class provides default implementations for the
    `create` and `update` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `serializers.py` file in the `games_service/games` folder. Replace
    the code in this file with the following lines. The new code declares the required
    imports and the `EsrbRatingSerializer` class. We will add more classes to this
    file later. The code file for the sample is included in the `restful_python_2_06_01`
    folder, in the `Django01/games-service/games/serializers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `EsrbRatingSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. The `EsrbRatingSerializer` class declares a `games` attribute as an
    instance of `serializers.HyperlinkedRelatedField` with `many` and `read_only`
    equal to `True` because it is a one-to-many relationship and it is read-only.
    We use the `games` name that we specified as the `related_name` string value when
    we created the `esrb_rating` field as a `models.ForeignKey` instance in the `Game`
    model. This way, the `games` field will provide us with an array of hyperlinks
    to each game that belongs to the ESRB rating. The `view_name` value is `'game-detail'`
    because we want the browsable API feature to use the game detail view to render
    the hyperlink when the user clicks or taps on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EsrbRatingSerializer` class declares a `Meta` inner class that declares
    the following two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `EsrbRating` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields`: This attribute specifies a tuple of the string whose values indicate
    the field names that we want to include in the serialization from the related
    model. We want to include both the primary key and the URL, and therefore, the
    code specifies both `''id''` and `''url''` as members of the tuple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no need to override either the `create` or `update` methods because
    the generic behavior will be enough in this case. The `HyperlinkedModelSerializer`
    superclass provides implementations for both methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `serializers.py` file in the `games_service/games` folder and add
    the following lines after the last line to declare the `GameSerializer` class.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/games-service/games/serializers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `GameSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. The `GameSerializer` class declares an `esrb_rating` attribute as
    an instance of the `serializers.SlugRelatedField` class with its `queryset` argument
    set to `EsrbRating.objects.all()` and its `slug_field` argument set to `'description'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`SlugRelatedField` is a read-write field that represents the target of the
    relationship by a unique slug attribute, that is, the description.'
  prefs: []
  type: TYPE_NORMAL
- en: We created the `esrb_rating` field as a `models.ForeignKey` instance in the
    `Game` model and we want to display the ESRB rating's `description` value as the
    description (slug field) for the related `EsrbRating`. Hence, we specified `'description'`
    as the `slug_field`. If it is necessary to display the possible options for the
    related ESRB rating in a form in the browsable API, Django will use the expression
    specified in the `queryset` argument to retrieve all the possible instances and
    display their specified slug field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EsrbRatingSerializer` class declares a `Meta` inner class that declares
    the following two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `Game` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields`: This attribute specifies a tuple of the string whose values indicate
    the field names that we want to include in the serialization from the related
    model. We just want to include the URL, and therefore, the code specifies `''url''`
    as a member of the tuple but doesn''t specify `''id''`. The `esrb_rating` field
    will specify the `description` field for the related `EsrbRating`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the `serializers.py` file in the `games_service/games` folder and add
    the following lines after the last line to declare the `ScoreSerializer` class.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/games-service/games/serializers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `ScoreSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. We will use the `ScoreSerializer` class to serialize `PlayerScore`
    instances related to a `Player`, that is, to display all the scores for a specific
    player when we serialize a `Player`. We want to display all the details for the
    related `Game` but we don't include the related `Player` because `Player` will
    use this `ScoreSerializer` serializer.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScoreSerializer` class declares a `game` attribute as an instance of the
    previously coded `GameSerializer` class. We created the `game` field as a `models.ForeignKey`
    instance in the `PlayerScore` model and we want to serialize the same data for
    the game that we coded in the `GameSerializer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ScoreSerializer` class declares a `Meta` inner class that declares the
    following two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `PlayerScore` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields`: This attribute specifies a tuple of the string whose values indicate
    the field names that we want to include in the serialization from the related
    model. In this case, we include both the `''url''` and the `''id''`. As previously
    explained, we don''t include the `''player''` field name in this tuple of string
    to avoid serializing the player again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use `PlayerSerializer` as a master and `ScoreSerializer` as the detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `serializers.py` file in the `games_service/games` folder and add
    the following lines after the last line to declare the `PlayerSerializer` class.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/games-service/games/serializers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayerSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. We will use the `PlayerSerializer` class to serialize `Player` instances
    and we will use the previously declared `ScoreSerializer` class to serialize all
    the `PlayerScore` instances related to `Player`.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerSerializer` class declares a `scores` attribute as an instance of
    the previously coded `ScoreSerializer` class. The `many` argument is set to `True`
    because it is a one-to-many relationship. We use the `scores` name that we specified
    as the `related_name` string value when we created the `player` field as a `models.ForeignKey`
    instance in the `PlayerScore` model. This way, the `scores` field will render
    each `PlayerScore` that belongs to the `Player` by using the previously declared
    `ScoreSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Player` model declared `gender` as an instance of `models.CharField` with
    the `choices` attribute set to the `Player.GENDER_CHOICES` string tuple. The `ScoreSerializer`
    class declares a `gender` attribute as an instance of `serializers.ChoiceField`
    with the `choices` argument set to the `Player.GENDER_CHOICES` string tuple. In
    addition, the class declares a `gender_description` attribute with `read_only`
    set to `True` and the `source` argument set to `'get_gender_display'`. The `source`
    string is built with `get_` followed by the field name, `gender`, and `_display`.
    This way, the read-only `gender_description` attribute will render the description
    for the gender choices instead of the single char stored values. The `ScoreSerializer`
    class declares a `Meta` inner class that declares the `model` and `fields` attributes.
    The `model` attribute specifies the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `serializers.py` file in the `games_service/games` folder and add
    the following lines after the last line to declare the `PlayerScoreSerializer`
    class. The code file for the sample is included in the `restful_python_2_06_01`
    folder, in the `Django01/games-service/games/serializers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayerScoreSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. We will use the `PlayerScoreSerializer` class to serialize `PlayerScore`
    instances. Previously, we created the `ScoreSerializer` class to serialize `PlayerScore`
    instances as the detail of a player. We will use the new `PlayerScoreSerializer`
    class when we want to display the related player's name and the related game's
    name. In the other serializer class, we didn't include any information related
    to the player and we included all the details for the game.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerScoreSerializer` class declares a `player` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `Player.objects.all()`
    and its `slug_field` argument set to `'name'`. We created the `player` field as
    a `models.ForeignKey` instance in the `PlayerScore` model, and we want to display
    the player's name as the description (slug field) for the related `Player`. Thus,
    we specified `'name'` as the `slug_field` argument. If it is necessary to display
    the possible options for the related player in a form in the browsable API, Django
    will use the expression specified in the `queryset` argument to retrieve all the
    possible players and display their specified slug field.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerScoreSerializer` class declares a `game` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `Game.objects.all()`
    and its `slug_field` argument set to `'name'`. We created the `game` field as
    a `models.ForeignKey` instance in the `PlayerScore` model and we want to display
    the game's name as the description (slug field) for the related `Game`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating class-based views and using generic classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, we will write our API views by declaring class-based views, instead
    of function-based views. We might code classes that inherit from the `rest_framework.views.APIView`
    class and declare methods with the same names than the HTTP verbs we want to process:
    `get`, `post`, `put`, `patch`, `delete`, and so on. These methods receive a `request`
    argument as happened with the functions that we created for the views. However,
    this approach would require us to write a lot of code. Instead, we can take advantage
    of a set of generic views that we can use as our base classes for our class-based
    views to reduce the required code to the minimum and take advantage of the behavior
    that has been generalized ...'
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of generic class-based views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `views.py` file in the `games_service/games` folder. Replace the code
    in this file with the following lines. The new code declares the required imports
    and the class-based views. We will add more classes to this file later. The code
    file for the sample is included in the `restful_python_2_06_01` folder, in the
    `Django01/games-service/games/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table summarizes the methods that each class-based view is going
    to process:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Scope | Class-based view name | HTTP verbs that it will process |'
  prefs: []
  type: TYPE_TB
- en: '| Collection of ESRB ratings: `/esrb-ratings/` | `EsrbRatingList` | `GET`,
    `POST`, and `OPTIONS` |'
  prefs: []
  type: TYPE_TB
- en: '| ESRB rating: `/esrb-rating/{id}/` | `EsrbRatingDetail` | `GET`, `PUT`, `PATCH`,
    `DELETE`, and `OPTIONS` |'
  prefs: []
  type: TYPE_TB
- en: '| Collection of games: `/games/` | `GameList` | `GET`, `POST`, and `OPTIONS`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Game: `/game/{id}/` | `GameDetail` | `GET`, `PUT`, `PATCH`, `DELETE`, and
    `OPTIONS` |'
  prefs: []
  type: TYPE_TB
- en: '| Collection of players: `/players/` | `PlayerList` | `GET`, `POST`, and `OPTIONS`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Player: `/player/{id}/` | `PlayerDetail` | `GET`, `PUT`, `PATCH`, `DELETE`,
    and `OPTIONS` |'
  prefs: []
  type: TYPE_TB
- en: '| Collection of scores: `/player-scores/` | `PlayerScoreList` | `GET`, `POST`,
    and `OPTIONS` |'
  prefs: []
  type: TYPE_TB
- en: '| Score: `/player-score/{id}/` | `PlayerScoreDetail` | `GET`, `PUT`, `PATCH`,
    `DELETE`, and `OPTIONS` |'
  prefs: []
  type: TYPE_TB
- en: Working with endpoints for the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create an endpoint for the root of our API to make it easier to browse
    the API with the browsable API feature and understand how everything works. Open
    the `views.py` file in the `games_service/games` folder and add the following
    code after the last line to declare the `ApiRoot` class. The code file for the
    sample is included in the `restful_python_2_06_01` folder, in the `Django01/games-service/games/serializers.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Browsing an API with relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can launch Django''s development server to compose and send HTTP requests
    to our still unsecured, yet much more complex, web API (we will definitely add
    security later). Execute any of the following two commands based on your needs
    to access the API in other devices or computers connected to your LAN. Remember
    that we analyzed the difference between them in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a web browser and enter `http://localhost:8000/` or the appropriate URL
    if you are using another computer or device to access the browsable API. The browsable
    API will compose and send a `GET` request to `/` and will display the results
    of its execution, that is, the headers and the JSON response from the execution
    of the `get` method defined in the `ApiRoot` class within the `views.py` file.
    The following screenshot shows the rendered web page after entering the URL in
    a web browser with the resource description of api-root:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f42ccb1-8ca3-4c9a-946d-a578083f8015.png)'
  prefs: []
  type: TYPE_IMG
- en: The api-root provides us with hyperlinks to see the list of ESRB ratings, games,
    players, and scores. This way, it becomes extremely easy to access the lists and
    perform operations on the different resources through the browsable API. In addition,
    when we visit the other URLs, the breadcrumb will allow us to go back to the api-root.
  prefs: []
  type: TYPE_NORMAL
- en: In this new version of the API, we worked with the generic views that provide
    many functions under the hood, and therefore, the browsable API will provide us
    additional features compared with the previous version. Click or tap on the URL
    at the right-hand side of "esrb-ratings". If you are browsing in localhost, the
    URL will be `http://localhost:8000/esrb-ratings/`. The browsable API will render
    the web page for the ESRB rating List.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the rendered web page, the browsable API provides us some
    controls to generate a `POST` request to `/esrb-ratings/`. In this case, by default,
    the browsable API displays the HTML form tab with an automatically generated form
    that we can use to generate a POST request without having to deal with the raw
    data as we did in our previous version. The HTML forms make it easy to generate
    requests to test our API. The following screenshot shows the HTML form to create
    a new ESRB rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a35bb0da-012c-493d-b11f-2dfc95798263.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We just need to enter the desired name, `AO (Adults Only)`, in the Name textbox
    and click or tap POST to create a new ESRB rating. The browsable API will compose
    and send a `POST` request to `/esrb-ratings/` with the previously specified data
    and we will see the results of the call in the web browser. The following screenshot
    shows a web browser displaying the HTTP status code `201 Created` in the response
    and the previously explained HTML form with the POST button to allow us to continue
    composing and sending `POST` requests to `/esrb-ratings/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e63e1938-6e43-44be-b23b-51834dc775d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now click on the URL displayed as a value for the `"url"` key in the JSON data
    displayed for the ESRB rating, such as `http://localhost:8000/esrb-ratings/1/`.
    Make sure you replace `1` with the ID of an existing ESRB rating in the previously
    rendered esrbrating-list. The browsable API will compose and send a `GET` request
    to `/esrb-ratings/1/` and will display the results of its execution, that is,
    the headers and the JSON data for the ESRB rating. The web page will display a
    DELETE button because we are working with the ESRB rating Detail view.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the breadcrumb to go back to the API root and start creating games
    related to an ESRB rating, players, and finally, scores related to a game and
    a player. We can do all this with easy-to-use HTML forms and the browsable API
    feature. This feature is extremely useful for testing CRUD operations with a RESTful
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and retrieving related resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will use the HTTP command or its `curl` equivalents to compose and send
    HTTP requests to the API. We will use JSON for the requests that require additional
    data. Remember that you can perform the same tasks as your favorite GUI-based
    tool or with the browsable API.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will run the following command to compose and send an HTTP `POST`
    request to create a new ESRB rating. Remember that we used the browsable API to
    create an ESRB rating with the following description: `''AO (Adults Only)''`.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/cmd/cmd615.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following is the equivalent
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, the `@api_view` decorator is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A wrapper that converts a function-based view into a subclass of the `rest_framework.views.APIView`
    class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A wrapper that converts a function-based view into a serializer
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A wrapper that converts a function-based view into a subclass of the `rest_framework.views.api_view`
    class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Serializer` and `ModelSerializer` classes in Django REST Framework are
    similar to which of the following two classes in Django Web framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Form` and `ModelForm`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`View` and `ModelView`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Controller` and `ModelController`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following classes is a read-write field that represents the target
    of the relationship by a unique slug attribute, that is, the description?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SlugLinkedField`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HyperlinkedRelatedField`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SlugRelatedField`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following classes renders the URL for a related object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SlugLinkedField`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HyperlinkedRelatedField`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SlugRelatedField`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The browsable API is a feature included in Django REST Framework that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates human-friendly JSON output for each resource whenever the request
    specifies `application/json` as the value for the `Content-type` key in the request
    header
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates human-friendly HTML output for each resource whenever the request
    specifies `text/html` as the value for the `Content-type` key in the request header
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: . Generates human-friendly HTML output for each resource whenever the request
    specifies `application/json` as the value for the `Content-type` key in the request
    header
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took advantage of many features included in Django REST
    Framework that allow us to eliminate duplicate code and build our API reusing
    generalized behaviors. We used model serializers, wrappers, default parsing and
    rendering options, class-based views, and generic classes.
  prefs: []
  type: TYPE_NORMAL
- en: We used the browsable API feature and we designed a RESTful API that interacted
    with a complex PostgreSQL 10.5 database. We declared relationships with the models,
    and we configured serialization and deserialization with hyperlinks. Finally,
    we created and retrieved related resources and understood how things work under
    the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we built a complex API with Django REST Framework that we can encapsulate
    in a microservice, we will use additional ...
  prefs: []
  type: TYPE_NORMAL
