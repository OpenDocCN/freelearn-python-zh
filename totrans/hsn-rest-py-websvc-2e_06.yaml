- en: Working with Class-Based Views and Hyperlinked APIs in Django 2.1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Django 2.1中使用基于类的视图和超链接API
- en: 'In this chapter, we will expand the capabilities of the RESTful API that we
    started in the previous chapter. We will change the ORM settings to work with
    a more powerful PostgreSQL 10.5 database and we will take advantage of advanced
    features included in **Django REST Framework** (**DRF**) that allow us to reduce
    boilerplate code for complex APIs, such as class-based views. We will look at
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展我们在上一章中开始构建的RESTful API的功能。我们将更改ORM设置以与更强大的PostgreSQL 10.5数据库一起工作，并利用**Django
    REST Framework**（**DRF**）中包含的先进功能，这些功能允许我们减少复杂API（如基于类的视图）的样板代码。我们将查看以下内容：
- en: Use model serializers to eliminate duplicate code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型序列化器来消除重复代码
- en: Work with wrappers to write API views
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包装器编写API视图
- en: Use the default parsing and rendering options and move beyond JSON
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认解析和渲染选项并超越JSON
- en: Browse the API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览API
- en: Design a RESTful API to interact with a complex PostgreSQL 10.5 database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个与复杂的PostgreSQL 10.5数据库交互的RESTful API
- en: Understand the tasks performed by each HTTP method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每种HTTP方法执行的任务
- en: Declare relationships with the models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型声明关系
- en: Install packages with the requirements file to work with PostgreSQL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用要求文件安装与PostgreSQL一起工作的包
- en: Configure the database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据库
- en: Run migrations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行迁移
- en: Verify the contents of the PostgreSQL database
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证PostgreSQL数据库的内容
- en: Manage serialization and deserialization with relationships and hyperlinks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关系和超链接管理序列化和反序列化
- en: Create class-based views and use generic classes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于类的视图并使用通用类
- en: Take advantage of generic class-based views
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用基于类的通用视图
- en: Work with endpoints for the API
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与API端点一起工作
- en: Browse an API with relationships
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览具有关系的API
- en: Create and retrieve related resources
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和检索相关资源
- en: Using model serializers to eliminate duplicate code
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型序列化器来消除重复代码
- en: The `GameSerializer` class we coded in [Chapter 5](e8d188a7-452a-4ce2-8e00-37eeeaabb879.xhtml),
    *Developing RESTful APIs with Django 2.1*, declares many attributes with the same
    names that we used in the `Game` model and repeats information such as the field
    types and the `max_length` values. The `GameSerializer` class is a subclass of
    the `rest_framework.serializers.Serializer` superclass and it declares attributes
    that we manually mapped to the appropriate types, and overrides the `create` and
    `update` methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](e8d188a7-452a-4ce2-8e00-37eeeaabb879.xhtml)“使用Django 2.1开发RESTful API”中编写的`GameSerializer`类声明了许多与我们在`Game`模型中使用的相同名称的属性，并重复了诸如字段类型和`max_length`值等信息。`GameSerializer`类是`rest_framework.serializers.Serializer`超类的子类，并声明了我们将手动映射到适当类型的属性，并重写了`create`和`update`方法。
- en: Now we will create a new version of the `GameSerializer` class that will inherit
    from the `rest_framework.serializers.ModelSerializer` superclass. The `ModelSerializer`
    class automatically populates both a set of default fields and a set of default
    ...
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个新的`GameSerializer`类版本，它将继承自`rest_framework.serializers.ModelSerializer`超类。`ModelSerializer`类自动填充一组默认字段和一组默认...
- en: Working with wrappers to write API views
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包装器编写API视图
- en: Our code in the `games_service/games/views.py` file declared a `JSONResponse`
    class and two function-based views. These functions returned `JSONResponse` when
    it was necessary to return JSON data and a `django.Http.Response.HttpResponse`
    instance when the response was just an HTTP status code. Hence, no matter what
    the accepted content type that's specified in the HTTP request header, the view
    functions always provide the same content in the response body—JSON.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`games_service/games/views.py`文件中编写的代码声明了一个`JSONResponse`类和两个基于函数的视图。这些函数在需要返回JSON数据时返回`JSONResponse`，而在响应只是一个HTTP状态码时返回`django.Http.Response.HttpResponse`实例。因此，无论HTTP请求头中指定的接受内容类型是什么，视图函数始终在响应体中提供相同的内容——JSON。
- en: 'Run the following two commands to retrieve all the games with different values
    for the `Accept` request header: `text/html` and `application/json`. The code
    file for the sample is included in the `restful_python_2_06_01` folder, in the
    `Django01/cmd/cmd601.txt` file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下两个命令以检索具有不同`Accept`请求头值的所有游戏：`text/html`和`application/json`。示例代码文件包含在`restful_python_2_06_01`文件夹中的`Django01/cmd/cmd601.txt`文件中：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are the equivalent `curl` commands. The code file for the sample
    is included in the `restful_python_2_06_01` folder, in the `Django01/cmd/cmd602.txt`
    file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例代码文件包含在`restful_python_2_06_01`文件夹中的`Django01/cmd/cmd602.txt`文件中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/`. We have requested both `http` and `curl` to enable
    the verbose mode with the `-v` option in which they specify more details about
    the operation and display the whole request, including the request header.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8000/games/`。我们已经请求了 `http` 和 `curl`
    使用 `-v` 选项启用详细模式，它们指定了更多关于操作的信息，并显示了整个请求，包括请求头。
- en: 'The first command defines the `text/html` value for the `Accept` request header.
    The second command defines the `application/json` value for the `Accept` request
    header. You will notice that both commands produce the same results, and therefore,
    the view functions don''t take into account the value specified for the `Accept`
    request header in the HTTP requests. The header response for both commands will
    include the following line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令为 `Accept` 请求头定义了 `text/html` 值。第二个命令为 `Accept` 请求头定义了 `application/json`
    值。您将注意到这两个命令产生了相同的结果，因此，视图函数不会考虑 HTTP 请求中指定的 `Accept` 请求头值。这两个命令的响应头将包括以下行：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The second request specified that it will only accept `text/html`, but the response
    included a JSON body, that is, `application/json` content. Thus, our first version
    of the RESTful API is not prepared to render content other from JSON. We will
    make some changes to enable the API to render other contents.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次请求指定它只接受 `text/html`，但响应中包含 JSON 主体，即 `application/json` 内容。因此，我们第一个版本的 RESTful
    API 没有准备好渲染除 JSON 之外的内容。我们将进行一些更改，以使 API 能够渲染其他内容。
- en: Whenever we have doubts about the methods supported by a resource or resource
    collection in a RESTful API, we can compose and send an HTTP request with the
    `OPTIONS` HTTP verb and the URL for the resource or resource collection. If the
    RESTful API implements the `OPTIONS` HTTP verb for a resource or resource collection,
    it provides a comma-separated list of HTTP verbs or methods that it supports as
    a value for the `Allow` header in the response. In addition, the response header
    will include additional information about other supported options, such as the
    content type it is capable of parsing from the request and the content type it
    is capable of rendering on the response.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对 RESTful API 中资源或资源集合支持的方法有疑问时，我们可以使用 `OPTIONS` HTTP 动词和资源或资源集合的 URL 组合并发送
    HTTP 请求。如果 RESTful API 为资源或资源集合实现了 `OPTIONS` HTTP 动词，它会在响应的 `Allow` 头部提供一个以逗号分隔的
    HTTP 动词或方法列表，表示它支持的操作。此外，响应头还将包括有关其他支持选项的附加信息，例如它能够从请求中解析的内容类型以及它能够在响应中呈现的内容类型。
- en: 'For example, if we want to know which HTTP verbs the games collection supports,
    we can run the following command. The code file for the sample is included in
    the `restful_python_2_06_01` folder, in the `Django01/cmd/cmd603.txt` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想知道游戏集合支持哪些 HTTP 动词，我们可以运行以下命令。示例代码文件包含在 `restful_python_2_06_01` 文件夹中，在
    `Django01/cmd/cmd603.txt` 文件中：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_06_01` folder, in the `Django01/cmd/cmd604.txt`
    file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的命令是等效的 `curl` 命令。示例代码文件包含在 `restful_python_2_06_01` 文件夹中，在 `Django01/cmd/cmd604.txt`
    文件中：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/games/`. The request will match and run the `views.game_collection`
    function, that is, the `game_collection` function declared within the `game_service/games/views.py`
    file. This function only runs code when the `request.method` is equal to `''GET''`
    or `''POST''`. In this case, `request.method` is equal to `''OPTIONS''`, and therefore,
    the function won''t run any code and won''t return any response, specifically,
    it won''t return an `HttpResponse` instance. As a result, we will see the `Internal
    Server Error` shown in the next screenshot listed in Django''s development server
    console output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`OPTIONS http://localhost:8000/games/`。该请求将匹配并运行 `views.game_collection`
    函数，即位于 `game_service/games/views.py` 文件中声明的 `game_collection` 函数。此函数仅在 `request.method`
    等于 `'GET'` 或 `'POST'` 时运行代码。在这种情况下，`request.method` 等于 `'OPTIONS'`，因此，该函数不会运行任何代码，也不会返回任何响应，特别是，它不会返回
    `HttpResponse` 实例。因此，我们将看到下一张截图在 Django 开发服务器控制台输出中显示的 `Internal Server Error`：
- en: '![](img/fdfed8ed-cf45-47a3-b169-94087e6098d3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdfed8ed-cf45-47a3-b169-94087e6098d3.png)'
- en: 'The following lines show the header for the output that also includes a huge
    HTML document with detailed information about the error because the debug mode
    is activated for Django. We receive a `500 Internal Server Error` status code.
    Notice that you will have to scroll up in the Terminal or Command Prompt to find
    these lines:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了输出头，其中还包括一个包含关于错误详细信息的巨大HTML文档，因为Django的调试模式已被激活。我们收到`500 内部服务器错误`状态码。请注意，您需要在终端或命令提示符中向上滚动以找到这些行：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Obviously, we want to provide a more consistent API and we want to provide an
    accurate response when we receive a request with the `OPTIONS` verbs for either
    a game resource or the games collection.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们希望提供一个更一致的API，并且当我们收到对游戏资源或游戏集合的`OPTIONS`动词的请求时，我们希望提供一个准确的响应。
- en: If we compose and send an HTTP request with the `OPTIONS` verb for a game resource,
    we will see the same error and we will have a similar response because the `views.game_detail`
    function only runs code when `request.method` is equal to `'GET'`, `'PUT'`, or
    `'DELETE'`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`OPTIONS`动词对游戏资源发送组合和发送HTTP请求，我们将看到相同的错误，并且我们将得到类似的响应，因为`views.game_detail`函数仅在`request.method`等于`'GET'`、`'PUT'`或`'DELETE'`时运行代码。
- en: 'The following commands will produce the explained error when we try to see
    the options offered for the game resource whose ID is equal to `2`. Don''t forget
    to replace `2` with a primary key value of an existing game in your configuration.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/cmd/cmd605.txt` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在我们尝试查看ID等于`2`的游戏资源提供的选项时产生所解释的错误。别忘了将`2`替换为您配置中现有游戏的键值。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_06_01` folder, in the `Django01/cmd/cmd606.txt`
    file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令。示例的代码文件包含在`restful_python_2_06_01`文件夹中，在`Django01/cmd/cmd606.txt`文件中：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We just need to make a few small changes in the `games_service/games/views.py`
    file to solve the issues we have been analyzing for our RESTful API. We will use
    the useful `@api_view` decorator, declared in the `rest_framework.decorators`
    module, for our function-based views. This decorator allows us to specify which
    are the HTTP verbs that our function can process. If the request that has to be
    processed by the view function has an HTTP verb that isn't included in the string
    list specified as the `http_method_names` argument for the `@api_view` decorator,
    the default behavior returns a `405 Method Not Allowed` status code. This way,
    we make sure that whenever we receive an HTTP verb that isn't considered within
    our function view, we won't generate an unexpected error as the decorator handles
    the response for the unsupported HTTP verbs or methods.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在`games_service/games/views.py`文件中做一些小的修改，以解决我们一直在分析我们RESTful API的问题。我们将使用在`rest_framework.decorators`模块中声明的有用的`@api_view`装饰器来处理基于函数的视图。这个装饰器允许我们指定我们的函数可以处理哪些HTTP动词。如果必须由视图函数处理的请求的HTTP动词不包括在作为`@api_view`装饰器的`http_method_names`参数指定的字符串列表中，则默认行为返回`405
    方法不允许`状态码。这样，我们确保每当收到不在我们函数视图中考虑的HTTP动词时，我们不会生成意外的错误，因为装饰器处理了不受支持的HTTP动词或方法。
- en: Under the hood, the `@api_view` decorator is a wrapper that converts a function-based
    view into a subclass of the `rest_framework.views.APIView` class. This class is
    the base class for all view in Django REST Framework. As we might guess, if we
    want to work with class-based views, we can create classes that inherit from this
    class and we will have the same benefits we have analyzed for the function-based
    views that use the decorator. We will start working with class-based views in
    the forthcoming examples in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`@api_view`装饰器是一个包装器，它将基于函数的视图转换为`rest_framework.views.APIView`类的子类。这个类是Django
    REST框架中所有视图的基类。正如我们可能猜测的那样，如果我们想使用基于类的视图，我们可以创建继承自这个类的类，我们将获得与使用装饰器的基于函数的视图相同的优势。我们将在本章接下来的示例中开始使用基于类的视图。
- en: In addition, as we specify a string list with the supported HTTP verbs, the
    decorator automatically builds the response for the `OPTIONS` HTTP verb with the
    supported methods, parser, and rendering capabilities. Our actual version of the
    API is just capable of rendering JSON as its output. The usage of the decorator
    makes sure that we always receive an instance of the `rest_framework.request.Request`
    class in the `request` argument when Django calls our view function. The decorator
    also handles the `ParserError` exceptions when our function views access the `request.data`
    attribute that might cause parsing problems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们指定了一个支持HTTP动词的字符串列表，装饰器会自动为支持的`OPTIONS` HTTP动词构建响应，包括支持的方法、解析器和渲染能力。我们实际的API版本仅能渲染JSON作为其输出。装饰器的使用确保了当Django调用我们的视图函数时，我们总是接收到`rest_framework.request.Request`类的实例作为`request`参数。装饰器还处理当我们的函数视图访问可能引起解析问题的`request.data`属性时产生的`ParserError`异常。
- en: Using the default parsing and rendering options and moving beyond JSON
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用默认解析和渲染选项，并超越JSON
- en: The `APIView` class specifies default settings for each view that we can override
    by specifying appropriate values in the `games_service/settings.py` file or by
    overriding the class attributes in subclasses of the `APIView` superclass. As
    we learned, the usage of the `APIView` class under the hoods makes the decorator
    apply these default settings. Thus, whenever we use the decorator, the default
    parser classes and the default renderer classes will be associated with the function
    views.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIView`类为每个视图指定了默认设置，我们可以通过在`games_service/settings.py`文件中指定适当的值或在`APIView`超类子类中覆盖类属性来覆盖这些设置。正如我们所学的，`APIView`类在底层使用装饰器应用这些默认设置。因此，每次我们使用装饰器时，默认解析器类和默认渲染器类都将与函数视图相关联。'
- en: 'By default, the value for the `DEFAULT_PARSER_CLASSES` configuration variable
    is the following tuple of strings with three parser class names:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`DEFAULT_PARSER_CLASSES`配置变量的值为以下包含三个解析器类名的字符串元组：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Browsing the API
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览API
- en: With the recent edits, we made it possible for our API to use the default content
    renderers configured in Django REST Framework, and therefore, our API is capable
    of rendering `text/html` content. We can take advantage of the browsable API,
    a feature included in Django REST Framework that generates human-friendly HTML
    output for each resource whenever the request specifies `text/html` as the value
    for the `Content-type` key in the request header.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最近的编辑，我们使我们的API能够使用Django REST Framework中配置的默认内容渲染器，因此我们的API能够渲染`text/html`内容。我们可以利用Django
    REST Framework中包含的可浏览API功能，该功能在请求指定请求头中的`Content-type`键值为`text/html`时，为每个资源生成友好的HTML输出。
- en: 'Whenever we enter a URL for an API resource in a web browser, the browser will
    require an HTML response, and therefore, Django REST Framework will provide an
    HTML response built with the Bootstrap popular frontend component library. You
    can read more about Bootstrap here: [http://getbootstrap.com](http://getbootstrap.com).
    This response will include a section that displays the resource content in JSON,
    buttons to perform different requests, and forms to submit data to the resources.
    As with everything in Django REST Framework, we can customize the templates and
    themes used to generate the browsable API.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在一个网页浏览器中输入API资源的URL时，浏览器将需要HTML响应，因此Django REST Framework将提供由Bootstrap流行的前端组件库构建的HTML响应。您可以在[http://getbootstrap.com](http://getbootstrap.com)了解更多关于Bootstrap的信息。此响应将包括一个显示资源内容的JSON部分、执行不同请求的按钮以及提交数据到资源的表单。与Django
    REST Framework中的所有内容一样，我们可以自定义用于生成可浏览API的模板和主题。
- en: Open a web browser and enter `http://localhost:8000/games/`. The browsable API
    will compose and send an HTTP `GET` request to `/games/` and will display the
    results of its execution, that is, the headers and the JSON games list. The following
    screenshot shows the rendered web page after entering the URL in a web browser
    with the resource description of Game List
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并输入`http://localhost:8000/games/`。可浏览API将组合并发送一个HTTP `GET`请求到`/games/`，并将显示其执行结果，即头部和JSON游戏列表。以下截图显示了在网页浏览器中输入URL后渲染的网页，其中包含游戏列表的资源描述。
- en: '![](img/94318302-64a2-40ae-9313-6d009f2fde7b.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94318302-64a2-40ae-9313-6d009f2fde7b.png)'
- en: If you decide to browse the API in a web browser running on another computer
    or device connected to the LAN, remember that you have to use the development
    computer's assigned IP address, instead of localhost. For example, if the computer's
    assigned IPv4 IP address is `192.168.1.103`, instead of `http://localhost:8000/games/`,
    you should use `http://192.168.1.103:8000/games/`. Of course, you can also use
    the hostname instead of the IP address.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定在另一台运行在LAN上的计算机或设备上的网页浏览器中浏览API，请记住你必须使用开发计算机分配的IP地址，而不是localhost。例如，如果计算机分配的IPv4
    IP地址是`192.168.1.103`，那么你应该使用`http://192.168.1.103:8000/games/`而不是`http://localhost:8000/games/`。当然，你也可以使用主机名而不是IP地址。
- en: The browsable API uses information about the allowed methods for a resource
    to provide us with buttons to run these methods. At the right-hand side of the
    resource description, the browsable API shows an OPTIONS button and a GET drop-down
    button. The OPTIONS button allows us to make an `OPTIONS` request to `/games/`,
    that is, to the current resource. The GET drop-down button allows us to make a
    `GET` request to `/games/` again. If we click or tap the down arrow, we can select
    the json option and the browsable API will display the raw JSON results of a `GET`
    request to `/games/` without the headers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可浏览的API使用关于资源允许的方法的信息，为我们提供运行这些方法的按钮。在资源描述的右侧，可浏览的API显示了一个OPTIONS按钮和一个GET下拉按钮。OPTIONS按钮允许我们向`/games/`发送`OPTIONS`请求，即当前资源。GET下拉按钮允许我们再次向`/games/`发送`GET`请求。如果我们点击或轻触向下箭头，我们可以选择json选项，可浏览的API将显示对`/games/`的`GET`请求的原始JSON结果，而不显示头部信息。
- en: 'At the bottom of the rendered web page, the browsable API provides us some
    controls to generate a `POST` request to `/games/`. The Media type drop-down allows
    us to select between the configured supported parsers for our API:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染网页的底部，可浏览的API为我们提供了一些控件来生成一个向`/games/`发送的`POST`请求。媒体类型下拉菜单允许我们在API配置的支持的解析器之间进行选择：
- en: '`application/json`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json`'
- en: '`application/x-www-form-urlencoded`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/x-www-form-urlencoded`'
- en: '`multipart/form-data`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multipart/form-data`'
- en: 'The Content textbox allows us to specify the data to be sent to the `POST`
    request formatted as specified in the Media type drop-down. Select application/json
    in the Media type drop-down and enter the following JSON content in the Content
    textbox:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 内容文本框允许我们指定要发送到`POST`请求的数据，格式与媒体类型下拉菜单中指定的一致。在媒体类型下拉菜单中选择application/json，并在内容文本框中输入以下JSON内容：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Click or tap POST. The browsable API will compose and send a `POST` request
    to `/games/` with the previously specified data as JSON and we will see the results
    of the call in the web browser. The following screenshot shows a web browser displaying
    the HTTP status code `201 Created` in the response and the previously explained
    drop-down and textbox with the POST button to allow us to continue composing and
    sending `POST` requests to `/games/`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触POST。可浏览的API将组合并发送一个包含之前指定数据的`POST`请求到`/games/`，我们将在网页浏览器中看到调用结果。以下截图显示了一个网页浏览器在响应中显示了HTTP状态码`201
    Created`，以及之前解释过的下拉菜单和文本框，其中包含POST按钮，允许我们继续编写并发送`POST`请求：
- en: '![](img/d865074b-cbfb-4b1a-9c29-f5aeb3f8a59f.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d865074b-cbfb-4b1a-9c29-f5aeb3f8a59f.png)'
- en: 'Now enter the URL for an existing game resource, such as `http://localhost:8000/games/7/`.
    Make sure you replace `7` with the ID of an existing game in the previously rendered
    Games List. The browsable API will compose and send an HTTP `GET` request to `/games/7/`
    and will display the results of its execution, that is, the headers and the JSON
    data for the game. The following screenshot shows the rendered web page after
    entering the URL in a web browser with the resource description of Game Detail:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入现有游戏资源的URL，例如`http://localhost:8000/games/7/`。确保将`7`替换为之前渲染的“游戏列表”中现有游戏的ID。可浏览的API将组合并发送一个HTTP
    `GET`请求到`/games/7/`，并将显示其执行结果，即游戏的头部信息和JSON数据。以下截图显示了在网页浏览器中输入URL后的渲染网页，其中包含“游戏详情”的资源描述：
- en: '![](img/927c7515-dc6b-4c7e-82af-4ed4ac9ee68e.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/927c7515-dc6b-4c7e-82af-4ed4ac9ee68e.png)'
- en: The browsable API feature allows us to easily check how the API works and to
    compose and send HTTP requests with different methods in any web browser that
    has access to our LAN. We will take advantage of additional features included
    in the browsable API, such as HTML forms that allow us to easily create new resources
    later after we build a new more complex RESTful API with Python and Django REST
    Framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可浏览的API功能使我们能够轻松检查API的工作方式，并在任何可以访问我们局域网的Web浏览器中组合和发送不同方法的HTTP请求。我们将利用可浏览API中包含的附加功能，例如HTML表单，它允许我们在使用Python和Django
    REST框架构建了一个新的更复杂的RESTful API之后轻松创建新的资源。
- en: Designing a RESTful API to interact with a complex PostgreSQL 10.5 database
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个RESTful API以与复杂的PostgreSQL 10.5数据库交互
- en: So far, our Django-based RESTful API performed CRUD operations on a single database
    table in an SQLite database. Now, we want to create a more complex RESTful API
    with Django REST Framework to interact with a complex database model that has
    to allow us to register player scores for playing games that are grouped into
    ESRB ratings. In our previous RESTful API, we used a string field to specify the
    ESRB rating for a game. In this case, we want to be able to easily retrieve all
    the games that have a specific ESRB rating, and therefore, we will have a relationship
    between a game and an ESRB rating.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的基于Django的RESTful API在SQLite数据库的单个数据库表上执行CRUD操作。现在，我们想要使用Django REST框架创建一个更复杂的RESTful
    API，以与一个复杂的数据库模型交互，该模型必须允许我们为属于ESRB评分的游戏注册玩家分数。在我们之前的RESTful API中，我们使用一个字符串字段来指定游戏的ESRB评分。在这种情况下，我们希望能够轻松检索具有特定ESRB评分的所有游戏，因此，我们将有一个游戏和ESRB评分之间的关系。
- en: We must be able to perform CRUD operations on different related resources ...
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够在不同的相关资源上执行CRUD操作...
- en: Understanding the tasks performed by each HTTP method
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每种HTTP方法执行的任务
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our API must support. Each method is composed by an HTTP verb
    and a scope and all the methods have well-defined meanings for all the resources
    and collections:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了我们的API必须支持的HTTP动词、范围和语义。每个方法由一个HTTP动词和一个范围组成，并且所有方法对所有资源和集合都有明确定义的意义：
- en: '| HTTP verb | Scope | Semantics |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| HTTP动词 | 范围 | 语义 |'
- en: '| `GET` | Collection of ESRB ratings | Retrieve all the stored ESRB ratings
    in the collection, sorted by their description in ascending order. Each ESRB rating
    must include a list of URLs for each game resource that belongs to the rating.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | ESRB评分集合 | 获取集合中存储的所有ESRB评分，按描述升序排序。每个ESRB评分必须包括属于该评分的每个游戏资源的URL列表。|'
- en: '| `GET` | ESRB rating | Retrieve a single ESRB rating. The ESRB rating must
    include a list of URLs for each game resource that belongs to the rating. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | ESRB评分 | 获取单个ESRB评分。ESRB评分必须包括属于该评分的每个游戏资源的URL列表。|'
- en: '| `POST` | Collection of ESRB ratings | Create a new ESRB rating in the collection.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | ESRB评分集合 | 在集合中创建一个新的ESRB评分。|'
- en: '| `PUT` | ESRB rating | Update an existing ESRB rating. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | ESRB评分 | 更新现有的ESRB评分。|'
- en: '| `PATCH` | ESRB rating | Update one or more fields of an existing ESRB rating.
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | ESRB评分 | 更新现有ESRB评分的一个或多个字段。|'
- en: '| `DELETE` | ESRB rating | Delete an existing ESRB rating. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | ESRB评分 | 删除现有的ESRB评分。|'
- en: '| `GET` | Collection of games | Retrieve all the stored games in the collection,
    sorted by their name in ascending order. Each game must include its ESRB rating
    description. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏集合 | 获取集合中存储的所有游戏，按名称升序排序。每个游戏必须包括其ESRB评分描述。|'
- en: '| `GET` | Game | Retrieve a single game. The game must include its ESRB rating
    description. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏 | 获取单个游戏。游戏必须包括其ESRB评分描述。|'
- en: '| `POST` | Collection of games | Create a new game in the collection. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 游戏集合 | 在集合中创建一个新的游戏。|'
- en: '| `PUT` | ESRB rating | Update an existing game. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | ESRB评分 | 更新现有的游戏。|'
- en: '| `PATCH` | ESRB rating | Update one or more fields of an existing game. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | ESRB评分 | 更新现有游戏的一个或多个字段。|'
- en: '| `DELETE` | ESRB rating | Delete an existing game. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | ESRB评分 | 删除现有的游戏。|'
- en: '| `GET` | Collection of players | Retrieve all the stored players in the collection,
    sorted by their name in ascending order. Each player must include a list of the
    registered scores, sorted by score in descending order. The list must include
    all the details for the score achieved by the player and its related game. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 玩家集合 | 获取集合中所有存储的玩家，按姓名升序排序。每个玩家必须包括按分数降序排序的已注册分数列表。列表必须包括玩家获得的分数及其相关游戏的详细信息。
    |'
- en: '| `GET` | Player | Retrieve a single player. The player must include a list
    of the registered scores, sorted by score in descending order. The list must include
    all the details for the score achieved by the player and its related game. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 玩家 | 获取单个玩家。玩家必须包括按分数降序排序的已注册分数列表。列表必须包括玩家获得的分数及其相关游戏的详细信息。 |'
- en: '| `POST` | Collection of players | Create a new player in the collection. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 玩家集合 | 在集合中创建一个新的玩家。 |'
- en: '| `PUT` | Player | Update an existing player. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 玩家 | 更新现有玩家。 |'
- en: '| `PATCH` | Player | Update one or more fields of an existing player. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 玩家 | 更新现有玩家的一个或多个字段。 |'
- en: '| `DELETE` | Player | Delete an existing player. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 玩家 | 删除现有玩家。 |'
- en: '| `GET` | Collection of scores | Retrieve all the stored scores in the collection,
    sorted by score in descending order. Each score must include the player''s name
    that achieved the score and the game''s name. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 分数集合 | 获取集合中所有存储的分数，按分数降序排序。每个分数必须包括获得分数的玩家的姓名和游戏的名称。 |'
- en: '| `GET` | Score | Retrieve a single score. The score must include the player''s
    name that achieved the score and the game''s name. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 分数 | 获取单个分数。分数必须包括获得分数的玩家的姓名和游戏的名称。 |'
- en: '| `POST` | Collection of scores | Create a new score in the collection. The
    score must be related to an existing player and an existing game. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 分数集合 | 在集合中创建一个新的分数。分数必须与现有玩家和现有游戏相关。 |'
- en: '| `PUT` | Score | Update an existing score. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 分数 | 更新现有分数。 |'
- en: '| `PATCH` | Score | Update one or more fields of an existing score. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 分数 | 更新现有分数的一个或多个字段。 |'
- en: '| `DELETE` | Score | Delete an existing score. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 分数 | 删除现有分数。 |'
- en: We want our API to be able to update a single field for an existing resource,
    and therefore, we will provide an implementation for the `PATCH` method. In addition,
    our RESTful API must support the `OPTIONS` method for all the resources and collection
    of resources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的 API 能够更新现有资源的单个字段，因此我们将提供 `PATCH` 方法的实现。此外，我们的 RESTful API 必须支持所有资源和资源集合的
    `OPTIONS` 方法。
- en: We will use all the features and reusable elements included in Django REST Framework
    to make it easy to build our API. We will work with a PostgreSQL 10.5 database.
    In case you don't want to spend time installing PostgreSQL, you can skip the changes
    we make in the Django REST Framework ORM configuration and continue working with
    the default SQLite database. However, it is highly recommended to work with PostgreSQL
    as the database engine.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Django REST 框架中包含的所有特性和可重用元素，以简化我们的 API 构建。我们将使用 PostgreSQL 10.5 数据库。如果你不想花时间安装
    PostgreSQL，你可以跳过我们在 Django REST 框架 ORM 配置中做的更改，并继续使用默认的 SQLite 数据库。然而，强烈建议使用 PostgreSQL
    作为数据库引擎。
- en: 'In the previous table, we have a huge number of methods and scopes. The following
    list enumerates the URIs for each scope mentioned in the previous table, where
    `{id}` has to be replaced with the numeric id of the resource:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个表中，我们有一个大量方法和范围。以下列表列举了前一个表中提到的每个范围的 URI，其中 `{id}` 必须替换为资源的数字 ID：
- en: '**Collection of ESRB ratings**: `/esrb-ratings/`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ESRB 评分集合**: `/esrb-ratings/`'
- en: '**ESRB rating**: `/esrb-rating/{id}/`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ESRB 评分**: `/esrb-rating/{id}/`'
- en: '**Collection of games**: `/games/`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏集合**: `/games/`'
- en: '**Game**: `/game/{id}/`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏**: `/game/{id}/`'
- en: '**Collection of players**: `/players/`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家集合**: `/players/`'
- en: '**Player**: `/player/{id}/`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家**: `/player/{id}/`'
- en: '**Collection of scores**: `/player-scores/`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分数集合**: `/player-scores/`'
- en: '**Score**: `/player-score/{id}/`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分数**: `/player-score/{id}/`'
- en: 'Let''s consider that `http://localhost:8000/` is the URL for the API running
    on the Django development server. We have to compose and send an HTTP request
    with the following HTTP verb (`GET`) and request URL (`http://localhost:8000/esrb-ratings/`)
    to retrieve all the stored ESRB ratings in the collection:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设 `http://localhost:8000/` 是 Django 开发服务器上运行的 API 的 URL。我们必须使用以下 HTTP 动词
    (`GET`) 和请求 URL (`http://localhost:8000/esrb-ratings/`) 编排并发送一个 HTTP 请求，以检索集合中所有存储的
    ESRB 评分：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Declaring relationships with the models
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明与模型的关系
- en: Make sure you quit the Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the Terminal or Command Prompt window in which it is
    running. Now we will create the models that we will use to represent and persist
    the ESRB ratings, games, players and scores, and their relationships.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已退出 Django 的开发服务器。记住，你只需要在运行该服务器的终端或命令提示符窗口中按 *Ctrl* + *C*。现在我们将创建我们将用来表示和持久化
    ESRB 评分、游戏、玩家和分数以及它们之间关系的模型。
- en: 'Open the `models.py` file in the `games_service/games` folder. Replace the
    code in this file with the following lines. The lines that declare fields related
    to other models are highlighted in the code listing. The code file for the sample
    is included in the `restful_python_2_06_01` folder, in the `Django01/games-service/games/models.py`
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `games_service/games` 文件夹中打开 `models.py` 文件。将此文件中的代码替换为以下行。与其它模型相关的字段声明在代码列表中被突出显示。示例的代码文件包含在
    `restful_python_2_06_01` 文件夹中，位于 `Django01/games-service/games/models.py` 文件：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Installing packages with the requirements.txt file to work with PostgreSQL
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `requirements.txt` 文件安装包以与 PostgreSQL 一起工作
- en: Make sure you quit Django development server. You just need to press *Ctrl*
    + *C* in the Terminal or Command Prompt window in which it is running.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已退出 Django 开发服务器。你只需要在运行该服务器的终端或命令提示符窗口中按 *Ctrl* + *C*。
- en: Now we will install an additional package. Make sure you have activated the
    virtual environment we have created in the previous chapter and we named `Django01`.
    After you activate the virtual environment, it is time to run many commands, which
    will be the same for either macOS, Linux, or Windows.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安装一个额外的包。确保你已经激活了上一章中创建的虚拟环境，我们将其命名为 `Django01`。激活虚拟环境后，就是运行许多命令的时候了，这些命令在
    macOS、Linux 或 Windows 上都是相同的。
- en: Now we will edit the existing `requirements.txt` file to specify the additional
    package that our application requires to be installed on any supported platform.
    This way, it will be extremely easy to repeat the installation of the specified
    packages with their versions in any new virtual environment.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编辑现有的 `requirements.txt` 文件，以指定我们的应用程序在任意支持平台上需要安装的额外包。这样，在任意新的虚拟环境中重复安装指定包及其版本将会变得极其容易。
- en: 'Use your favorite editor to edit the existing text file named `requirements.txt`
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional package and the version that our new version
    of the API requires: `psycopg2` version 2.7.5\. The code file for the sample is
    included in the `restful_python_2_06_01` folder, in the `Django01/requirements.txt`
    file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器编辑虚拟环境根目录下名为 `requirements.txt` 的现有文本文件。在最后一行之后添加以下行以声明新版本的 API 所需要的额外包及其版本：`psycopg2`
    版本 2.7.5。示例的代码文件包含在 `restful_python_2_06_01` 文件夹中，位于 `Django01/requirements.txt`
    文件：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Psycopg 2 (`psycopg2`) is a Python-PostgreSQL database adapter and Django's
    integrated ORM will use it to interact with our recently created PostgreSQL database.
    Again, it is very important to make sure that the PostgreSQL `bin` folder is included
    in the `PATH` environmental variable before we run the installation for this package.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Psycopg 2 (`psycopg2`) 是一个 Python-PostgreSQL 数据库适配器，Django 的集成 ORM 将会使用它来与我们的最近创建的
    PostgreSQL 数据库进行交互。再次强调，在运行此包的安装之前，确保 PostgreSQL 的 `bin` 文件夹已包含在 `PATH` 环境变量中是非常重要的。
- en: 'Now we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions explained in the previous table with
    `pip` by using the recently edited `requirements.txt` file. Make sure you are
    in the folder that has the `requirements.txt` file (`Django01`) before running
    the command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须在 macOS、Linux 或 Windows 上运行以下命令来安装额外的包以及之前表格中解释的版本，使用 `pip` 通过最近编辑的 `requirements.txt`
    文件进行安装。确保在运行命令之前你位于包含 `requirements.txt` 文件（`Django01`）的文件夹中：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last lines for the output will indicate the new package has been successfully
    installed. If you downloaded the source code for the example and you didn''t work
    with the previous version of the API, `pip` will also install the other packages
    included in the `requirements.txt` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示新包已成功安装。如果你下载了示例的源代码，并且你没有使用 API 的先前版本，`pip` 也会安装 `requirements.txt`
    文件中包含的其他包：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Configuring the database
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据库
- en: The default SQLite database engine and the database file name are specified
    in the `games_service/games_service/settings.py` Python file. In order to work
    with PostgreSQL 10.5 instead of SQLite for this example, replace the declaration
    of the `DATABASES` dictionary in this file with the following lines. The nested
    dictionary maps the database named `default` with the `django.db.backends.postgresql`
    database engine, the desired database name, and its settings. In this case, we
    will create a database named games.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的SQLite数据库引擎和数据库文件名在`games_service/games_service/settings.py`Python文件中指定。为了在这个示例中使用PostgreSQL
    10.5而不是SQLite，请将此文件中`DATABASES`字典的声明替换为以下行。嵌套字典将名为`default`的数据库映射到`django.db.backends.postgresql`数据库引擎、所需的数据库名称及其设置。在这种情况下，我们将创建一个名为games的数据库。
- en: Make sure you specify the desired database name in the value for the `'NAME'`
    key and that you configure the user, password, host, and port based on the user
    you recently created and your PostgreSQL 10.5 configuration. ...
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在`'NAME'`键的值中指定了所需的数据库名称，并根据您最近创建的用户和您的PostgreSQL 10.5配置配置用户、密码、主机和端口。...
- en: Running migrations
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行迁移
- en: 'Now run the following Python script to generate the migrations that will allow
    us to synchronize the database for the first time. Make sure you are in the `games_service`
    folder within the root folder for the virtual environment (`Django01`). Notice
    that we use the Django app name, `games`, and not the PostgreSQL database name,
    `django_games` in the next script:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下Python脚本以生成允许我们首次同步数据库的迁移。确保您位于虚拟环境根目录(`Django01`)下的`games_service`文件夹中。请注意，我们在下一个脚本中使用的是Django应用名称`games`，而不是PostgreSQL数据库名称`django_games`：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following lines show the output generated after running the previous command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一条命令后的输出结果：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output indicates that the `games_service/games/migrations/0001_initial.py`
    file includes the code to create the `EsrbRating`, `Game`, `Player`, and `PlayerScore`
    models. The following lines show the code for this file that was automatically
    generated by Django and its integrated ORM. The code file for the sample is included
    in the `restful_python_2_06_01` folder, in the `Django01/games-service/games/migrations/0001_initial.py`
    file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明`games_service/games/migrations/0001_initial.py`文件包含了创建`EsrbRating`、`Game`、`Player`和`PlayerScore`模型的代码。以下行显示了由Django及其集成ORM自动生成的此文件的代码。示例的代码文件包含在`restful_python_2_06_01`文件夹中，在`Django01/games-service/games/migrations/0001_initial.py`文件中：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code defines a subclass of the `django.db.migrations.Migration` class named
    `Migration` that defines an `operations` list with many `migrations.CreateModel`.
    Each `migrations.CreateModel` method will create the table for each of the related
    models. Notice that Django has automatically added an `id` field for each of the
    models.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个名为`Migration`的`django.db.migrations.Migration`类的子类，该类定义了一个包含许多`migrations.CreateModel`的`operations`列表。每个`migrations.CreateModel`方法将为每个相关模型创建一个表。请注意，Django已自动为每个模型添加了一个`id`字段。
- en: The `operations` are executed in the same order in which they appear in the
    list. The code creates `EsrbRating`, `Game`, `Player`, and `PlayerScore`. The
    code creates the foreign keys for `Game` and `PlayerScore` when it creates these
    models.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`operations`按它们在列表中出现的顺序执行。代码创建了`EsrbRating`、`Game`、`Player`和`PlayerScore`。当创建这些模型时，代码为`Game`和`PlayerScore`创建了外键。'
- en: 'Now run the following Python script to apply all the generated migrations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下Python脚本以应用所有生成的迁移：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following lines show the output generated after running the previous command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一条命令后的输出结果：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Verifying the contents of the PostgreSQL database
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证PostgreSQL数据库的内容
- en: After we run the previous command, we can use the PostgreSQL command line or
    any other application that allows us to easily check the contents of the PostgreSQL
    10.5 database to check the tables that Django generated.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行上一条命令后，我们可以使用PostgreSQL命令行或任何允许我们轻松检查PostgreSQL 10.5数据库内容的其他应用程序来检查Django生成的表。
- en: 'Run the following command to list the generated tables. If the database name
    you are using is not named `django_games`, make sure you use the appropriate database
    name. The code file for the sample is included in the `restful_python_2_06_01`
    folder, in the `Django01/cmd/list_database_tables.sql` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以列出生成的表。如果您使用的数据库名称不是`django_games`，请确保您使用适当的数据库名称。示例的代码文件包含在`restful_python_2_06_01`文件夹中，在`Django01/cmd/list_database_tables.sql`文件中：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following lines show the output with all the generated table names:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了所有生成的表名输出：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Managing serialization and deserialization with relationships and hyperlinks
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关系和超链接管理序列化和反序列化
- en: Our new RESTful Web API has to be able to serialize and deserialize the `EsrbRating`,
    `Game`, `Player`, and `PlayerScore` instances into JSON representations. In this
    case, we also have to pay special attention to the relationships between the different
    models when we create the serializer classes to manage serialization to JSON and
    deserialization from JSON.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新RESTful Web API必须能够将`EsrbRating`、`Game`、`Player`和`PlayerScore`实例序列化和反序列化为JSON表示。在这种情况下，我们创建序列化器类来管理对JSON的序列化和从JSON的反序列化时，还必须特别注意不同模型之间的关系。
- en: In our last version of the previous API, we created a subclass of the `rest_framework.serializers.ModelSerializer`
    class to make it easier to generate a serializer and reduce boilerplate code.
    In this case, we will also declare a class that inherits from `ModelSerializer`
    but three classes will inherit from the `rest_framework.serializers.HyperlinkedModelSerializer`
    class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前API的最后一个版本中，我们创建了一个`rest_framework.serializers.ModelSerializer`类的子类，以便更容易生成序列化器并减少样板代码。在这种情况下，我们还将声明一个继承自`ModelSerializer`的类，但三个类将继承自`rest_framework.serializers.HyperlinkedModelSerializer`类。
- en: '`HyperlinkedModelSerializer` is a type of `ModelSerializer` that uses hyperlinked
    relationships instead of primary key relationships, and therefore, it represents
    the relationships to other model instances with hyperlinks instead of primary
    key values. In addition, `HyperlinkedModelSerializer` generates a field named
    `url` with the URL for the resource as its value. As happens with `ModelSerializer`,
    the `HyperlinkedModelSerializer` class provides default implementations for the
    `create` and `update` methods.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`HyperlinkedModelSerializer`是`ModelSerializer`的一种类型，它使用超链接关系而不是主键关系，因此，它使用超链接而不是主键值来表示与其他模型实例的关系。此外，`HyperlinkedModelSerializer`生成一个名为`url`的字段，其值为资源的URL。与`ModelSerializer`一样，`HyperlinkedModelSerializer`类为`create`和`update`方法提供了默认实现。'
- en: 'Open the `serializers.py` file in the `games_service/games` folder. Replace
    the code in this file with the following lines. The new code declares the required
    imports and the `EsrbRatingSerializer` class. We will add more classes to this
    file later. The code file for the sample is included in the `restful_python_2_06_01`
    folder, in the `Django01/games-service/games/serializers.py` file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`games_service/games`文件夹中的`serializers.py`文件。用以下行替换此文件中的代码。新代码声明了所需的导入和`EsrbRatingSerializer`类。我们稍后会将更多类添加到该文件中。示例代码文件包含在`restful_python_2_06_01`文件夹中，位于`Django01/games-service/games/serializers.py`文件中：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `EsrbRatingSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. The `EsrbRatingSerializer` class declares a `games` attribute as an
    instance of `serializers.HyperlinkedRelatedField` with `many` and `read_only`
    equal to `True` because it is a one-to-many relationship and it is read-only.
    We use the `games` name that we specified as the `related_name` string value when
    we created the `esrb_rating` field as a `models.ForeignKey` instance in the `Game`
    model. This way, the `games` field will provide us with an array of hyperlinks
    to each game that belongs to the ESRB rating. The `view_name` value is `'game-detail'`
    because we want the browsable API feature to use the game detail view to render
    the hyperlink when the user clicks or taps on it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`EsrbRatingSerializer`类是`HyperlinkedModelSerializer`超类的子类。`EsrbRatingSerializer`类声明了一个`games`属性，它是一个`serializers.HyperlinkedRelatedField`实例，其中`many`和`read_only`都设置为`True`，因为它是一对多关系且只读。我们使用我们在创建`Game`模型中的`esrb_rating`字段时指定的`related_name`字符串值作为`games`名称。这样，`games`字段将为我们提供指向属于ESRB评分的每个游戏的超链接数组。`view_name`的值是`''game-detail''`，因为我们希望可浏览的API功能使用游戏详情视图来渲染超链接，当用户点击或轻触它时。'
- en: 'The `EsrbRatingSerializer` class declares a `Meta` inner class that declares
    the following two attributes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`EsrbRatingSerializer`类声明了一个`Meta`内部类，该类声明了以下两个属性：'
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `EsrbRating` class.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`: 此属性指定与序列化器相关的模型，即`EsrbRating`类。'
- en: '`fields`: This attribute specifies a tuple of the string whose values indicate
    the field names that we want to include in the serialization from the related
    model. We want to include both the primary key and the URL, and therefore, the
    code specifies both `''id''` and `''url''` as members of the tuple.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields`：此属性指定了一个字符串的元组，其值表示我们想要包含在从相关模型序列化中的字段名称。我们想要包含主键和 URL，因此，代码将 `''id''`
    和 `''url''` 都指定为元组的成员。'
- en: There is no need to override either the `create` or `update` methods because
    the generic behavior will be enough in this case. The `HyperlinkedModelSerializer`
    superclass provides implementations for both methods.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，无需重写 `create` 或 `update` 方法，因为通用行为将足够。`HyperlinkedModelSerializer` 超类为这两个方法提供了实现。
- en: 'Open the `serializers.py` file in the `games_service/games` folder and add
    the following lines after the last line to declare the `GameSerializer` class.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/games-service/games/serializers.py` file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `games_service/games` 文件夹中的 `serializers.py` 文件，并在最后一行之后添加以下行以声明 `GameSerializer`
    类。示例代码文件包含在 `restful_python_2_06_01` 文件夹中，位于 `Django01/games-service/games/serializers.py`
    文件中：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `GameSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. The `GameSerializer` class declares an `esrb_rating` attribute as
    an instance of the `serializers.SlugRelatedField` class with its `queryset` argument
    set to `EsrbRating.objects.all()` and its `slug_field` argument set to `'description'`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameSerializer` 类是 `HyperlinkedModelSerializer` 超类的子类。`GameSerializer` 类声明了一个
    `esrb_rating` 属性，它是一个 `serializers.SlugRelatedField` 类的实例，其 `queryset` 参数设置为 `EsrbRating.objects.all()`，其
    `slug_field` 参数设置为 `''description''`。'
- en: '`SlugRelatedField` is a read-write field that represents the target of the
    relationship by a unique slug attribute, that is, the description.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`SlugRelatedField` 是一个读写字段，它通过一个唯一的 slug 属性表示关系的目标，即描述。'
- en: We created the `esrb_rating` field as a `models.ForeignKey` instance in the
    `Game` model and we want to display the ESRB rating's `description` value as the
    description (slug field) for the related `EsrbRating`. Hence, we specified `'description'`
    as the `slug_field`. If it is necessary to display the possible options for the
    related ESRB rating in a form in the browsable API, Django will use the expression
    specified in the `queryset` argument to retrieve all the possible instances and
    display their specified slug field.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Game` 模型中将 `esrb_rating` 字段创建为一个 `models.ForeignKey` 实例，并且我们想要显示 ESRB 评分的
    `description` 值作为相关 `EsrbRating` 的描述（slug 字段）。因此，我们指定了 `'description'` 作为 `slug_field`。如果需要在可浏览的
    API 中的表单中显示相关 ESRB 评分的可能选项，Django 将使用在 `queryset` 参数中指定的表达式检索所有可能实例并显示它们指定的 slug
    字段。
- en: 'The `EsrbRatingSerializer` class declares a `Meta` inner class that declares
    the following two attributes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`EsrbRatingSerializer` 类声明了一个 `Meta` 内部类，该类声明了以下两个属性：'
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `Game` class.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`：此属性指定与序列器相关的模型，即 `Game` 类。'
- en: '`fields`: This attribute specifies a tuple of the string whose values indicate
    the field names that we want to include in the serialization from the related
    model. We just want to include the URL, and therefore, the code specifies `''url''`
    as a member of the tuple but doesn''t specify `''id''`. The `esrb_rating` field
    will specify the `description` field for the related `EsrbRating`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields`：此属性指定了一个字符串的元组，其值表示我们想要包含在从相关模型序列化中的字段名称。我们只想包含 URL，因此，代码将 `''url''`
    作为元组的成员，但没有指定 `''id''`。`esrb_rating` 字段将为相关的 `EsrbRating` 指定 `description` 字段。'
- en: 'Open the `serializers.py` file in the `games_service/games` folder and add
    the following lines after the last line to declare the `ScoreSerializer` class.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/games-service/games/serializers.py` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `games_service/games` 文件夹中的 `serializers.py` 文件，并在最后一行之后添加以下行以声明 `ScoreSerializer`
    类。示例代码文件包含在 `restful_python_2_06_01` 文件夹中，位于 `Django01/games-service/games/serializers.py`
    文件中：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `ScoreSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. We will use the `ScoreSerializer` class to serialize `PlayerScore`
    instances related to a `Player`, that is, to display all the scores for a specific
    player when we serialize a `Player`. We want to display all the details for the
    related `Game` but we don't include the related `Player` because `Player` will
    use this `ScoreSerializer` serializer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreSerializer` 类是 `HyperlinkedModelSerializer` 超类的子类。我们将使用 `ScoreSerializer`
    类来序列化与 `Player` 相关的 `PlayerScore` 实例，即在我们序列化 `Player` 时显示特定玩家的所有分数。我们希望显示相关 `Game`
    的所有细节，但我们不包括相关的 `Player`，因为 `Player` 将使用这个 `ScoreSerializer` 序列化器。'
- en: The `ScoreSerializer` class declares a `game` attribute as an instance of the
    previously coded `GameSerializer` class. We created the `game` field as a `models.ForeignKey`
    instance in the `PlayerScore` model and we want to serialize the same data for
    the game that we coded in the `GameSerializer` class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreSerializer` 类声明了一个 `game` 属性，其类型为之前编写的 `GameSerializer` 类的实例。我们在 `PlayerScore`
    模型中创建了一个 `game` 字段作为 `models.ForeignKey` 实例，并且我们想要序列化与 `GameSerializer` 类中编写的相同的数据。'
- en: 'The `ScoreSerializer` class declares a `Meta` inner class that declares the
    following two attributes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreSerializer` 类声明了一个 `Meta` 内部类，该类声明了以下两个属性：'
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `PlayerScore` class.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`: 此属性指定与序列化器相关的模型，即 `PlayerScore` 类。'
- en: '`fields`: This attribute specifies a tuple of the string whose values indicate
    the field names that we want to include in the serialization from the related
    model. In this case, we include both the `''url''` and the `''id''`. As previously
    explained, we don''t include the `''player''` field name in this tuple of string
    to avoid serializing the player again.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields`: 此属性指定一个字符串元组，其值表示我们想要在序列化中包含的相关模型的字段名称。在这种情况下，我们包括 `''url''` 和 `''id''`。如前所述，我们不将
    `''player''` 字段名称包含在这个字符串元组中，以避免再次序列化玩家。'
- en: We will use `PlayerSerializer` as a master and `ScoreSerializer` as the detail.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `PlayerSerializer` 作为主类，`ScoreSerializer` 作为细节类。
- en: 'Open the `serializers.py` file in the `games_service/games` folder and add
    the following lines after the last line to declare the `PlayerSerializer` class.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/games-service/games/serializers.py` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `games_service/games` 文件夹中的 `serializers.py` 文件，并在最后一行之后添加以下行以声明 `PlayerSerializer`
    类。示例代码文件包含在 `restful_python_2_06_01` 文件夹中，位于 `Django01/games-service/games/serializers.py`
    文件中：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `PlayerSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. We will use the `PlayerSerializer` class to serialize `Player` instances
    and we will use the previously declared `ScoreSerializer` class to serialize all
    the `PlayerScore` instances related to `Player`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerSerializer` 类是 `HyperlinkedModelSerializer` 超类的子类。我们将使用 `PlayerSerializer`
    类来序列化 `Player` 实例，并使用之前声明的 `ScoreSerializer` 类来序列化与 `Player` 相关的所有 `PlayerScore`
    实例。'
- en: The `PlayerSerializer` class declares a `scores` attribute as an instance of
    the previously coded `ScoreSerializer` class. The `many` argument is set to `True`
    because it is a one-to-many relationship. We use the `scores` name that we specified
    as the `related_name` string value when we created the `player` field as a `models.ForeignKey`
    instance in the `PlayerScore` model. This way, the `scores` field will render
    each `PlayerScore` that belongs to the `Player` by using the previously declared
    `ScoreSerializer`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerSerializer` 类声明了一个 `scores` 属性，其类型为之前编写的 `ScoreSerializer` 类的实例。`many`
    参数设置为 `True`，因为这是一个一对多关系。我们使用在创建 `PlayerScore` 模型中的 `player` 字段时指定的 `scores` 名称作为
    `related_name` 字符串值。这样，`scores` 字段将通过使用之前声明的 `ScoreSerializer` 来渲染属于 `Player`
    的每个 `PlayerScore`。'
- en: The `Player` model declared `gender` as an instance of `models.CharField` with
    the `choices` attribute set to the `Player.GENDER_CHOICES` string tuple. The `ScoreSerializer`
    class declares a `gender` attribute as an instance of `serializers.ChoiceField`
    with the `choices` argument set to the `Player.GENDER_CHOICES` string tuple. In
    addition, the class declares a `gender_description` attribute with `read_only`
    set to `True` and the `source` argument set to `'get_gender_display'`. The `source`
    string is built with `get_` followed by the field name, `gender`, and `_display`.
    This way, the read-only `gender_description` attribute will render the description
    for the gender choices instead of the single char stored values. The `ScoreSerializer`
    class declares a `Meta` inner class that declares the `model` and `fields` attributes.
    The `model` attribute specifies the `Player` class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 模型将 `gender` 声明为 `models.CharField` 的实例，其 `choices` 属性设置为 `Player.GENDER_CHOICES`
    字符串元组。`ScoreSerializer` 类声明了一个 `gender` 属性，它是一个 `serializers.ChoiceField` 的实例，其
    `choices` 参数设置为 `Player.GENDER_CHOICES` 字符串元组。此外，该类声明了一个 `gender_description`
    属性，其中 `read_only` 设置为 `True`，`source` 参数设置为 `''get_gender_display''`。`source`
    字符串是通过 `get_` 后跟字段名 `gender` 和 `_display` 构建的。这样，只读的 `gender_description` 属性将渲染性别选择的描述，而不是存储的单个字符值。`ScoreSerializer`
    类声明了一个 `Meta` 内部类，该类声明了 `model` 和 `fields` 属性。`model` 属性指定了 `Player` 类。'
- en: 'Open the `serializers.py` file in the `games_service/games` folder and add
    the following lines after the last line to declare the `PlayerScoreSerializer`
    class. The code file for the sample is included in the `restful_python_2_06_01`
    folder, in the `Django01/games-service/games/serializers.py` file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `games_service/games` 文件夹中的 `serializers.py` 文件，并在最后一行之后添加以下行以声明 `PlayerScoreSerializer`
    类。示例代码文件包含在 `restful_python_2_06_01` 文件夹中，位于 `Django01/games-service/games/serializers.py`
    文件中：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `PlayerScoreSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    superclass. We will use the `PlayerScoreSerializer` class to serialize `PlayerScore`
    instances. Previously, we created the `ScoreSerializer` class to serialize `PlayerScore`
    instances as the detail of a player. We will use the new `PlayerScoreSerializer`
    class when we want to display the related player's name and the related game's
    name. In the other serializer class, we didn't include any information related
    to the player and we included all the details for the game.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreSerializer` 类是 `HyperlinkedModelSerializer` 超类的子类。我们将使用 `PlayerScoreSerializer`
    类来序列化 `PlayerScore` 实例。之前，我们创建了 `ScoreSerializer` 类来序列化 `PlayerScore` 实例作为玩家的详细信息。当我们想要显示相关玩家的姓名和相关游戏的名称时，我们将使用新的
    `PlayerScoreSerializer` 类。在其他序列化类中，我们没有包含任何与玩家相关的信息，并且包含了游戏的所有详细信息。'
- en: The `PlayerScoreSerializer` class declares a `player` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `Player.objects.all()`
    and its `slug_field` argument set to `'name'`. We created the `player` field as
    a `models.ForeignKey` instance in the `PlayerScore` model, and we want to display
    the player's name as the description (slug field) for the related `Player`. Thus,
    we specified `'name'` as the `slug_field` argument. If it is necessary to display
    the possible options for the related player in a form in the browsable API, Django
    will use the expression specified in the `queryset` argument to retrieve all the
    possible players and display their specified slug field.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreSerializer` 类声明了一个 `player` 属性，它是一个 `serializers.SlugRelatedField`
    的实例，其 `queryset` 参数设置为 `Player.objects.all()`，其 `slug_field` 参数设置为 `''name''`。我们在
    `PlayerScore` 模型中创建了一个 `player` 字段作为 `models.ForeignKey` 实例，我们希望将玩家的名称作为相关 `Player`
    的描述（slug 字段）。因此，我们将 `''name''` 作为 `slug_field` 参数。如果需要在可浏览的 API 中的表单中显示相关玩家的可能选项，Django
    将使用 `queryset` 参数中指定的表达式检索所有可能的玩家并显示它们的指定 slug 字段。'
- en: The `PlayerScoreSerializer` class declares a `game` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `Game.objects.all()`
    and its `slug_field` argument set to `'name'`. We created the `game` field as
    a `models.ForeignKey` instance in the `PlayerScore` model and we want to display
    the game's name as the description (slug field) for the related `Game`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreSerializer` 类声明了一个 `game` 属性，它是一个 `serializers.SlugRelatedField`
    的实例，其 `queryset` 参数设置为 `Game.objects.all()`，其 `slug_field` 参数设置为 `''name''`。我们在
    `PlayerScore` 模型中创建了一个 `game` 字段作为 `models.ForeignKey` 实例，我们希望将游戏的名称作为相关 `Game`
    的描述（slug 字段）。'
- en: Creating class-based views and using generic classes
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于类的视图和使用通用类
- en: 'This time, we will write our API views by declaring class-based views, instead
    of function-based views. We might code classes that inherit from the `rest_framework.views.APIView`
    class and declare methods with the same names than the HTTP verbs we want to process:
    `get`, `post`, `put`, `patch`, `delete`, and so on. These methods receive a `request`
    argument as happened with the functions that we created for the views. However,
    this approach would require us to write a lot of code. Instead, we can take advantage
    of a set of generic views that we can use as our base classes for our class-based
    views to reduce the required code to the minimum and take advantage of the behavior
    that has been generalized ...'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将通过声明基于类的视图来编写我们的API视图，而不是基于函数的视图。我们可能会编写从`rest_framework.views.APIView`类继承的类，并声明与我们要处理的HTTP动词具有相同名称的方法：`get`、`post`、`put`、`patch`、`delete`等。这些方法接收一个`request`参数，就像我们为视图创建的函数一样。然而，这种方法将需要我们编写大量的代码。相反，我们可以利用一组通用视图，我们可以将它们用作基于类的视图的基础类，以将所需的代码量减少到最小，并利用已经泛化的行为
    ...
- en: Taking advantage of generic class-based views
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用通用类视图
- en: 'Open the `views.py` file in the `games_service/games` folder. Replace the code
    in this file with the following lines. The new code declares the required imports
    and the class-based views. We will add more classes to this file later. The code
    file for the sample is included in the `restful_python_2_06_01` folder, in the
    `Django01/games-service/games/views.py` file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`games_service/games`文件夹中的`views.py`文件。用以下行替换此文件中的代码。新代码声明了所需的导入和基于类的视图。我们稍后将在该文件中添加更多类。示例的代码文件包含在`restful_python_2_06_01`文件夹中，在`Django01/games-service/games/views.py`文件中：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following table summarizes the methods that each class-based view is going
    to process:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了每个基于类的视图将要处理的方法：
- en: '| Scope | Class-based view name | HTTP verbs that it will process |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | 基于类的视图名称 | 它将要处理的HTTP动词 |'
- en: '| Collection of ESRB ratings: `/esrb-ratings/` | `EsrbRatingList` | `GET`,
    `POST`, and `OPTIONS` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| ESRB评分集合: `/esrb-ratings/` | `EsrbRatingList` | `GET`、`POST` 和 `OPTIONS`
    |'
- en: '| ESRB rating: `/esrb-rating/{id}/` | `EsrbRatingDetail` | `GET`, `PUT`, `PATCH`,
    `DELETE`, and `OPTIONS` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| ESRB评分: `/esrb-rating/{id}/` | `EsrbRatingDetail` | `GET`、`PUT`、`PATCH`、`DELETE`
    和 `OPTIONS` |'
- en: '| Collection of games: `/games/` | `GameList` | `GET`, `POST`, and `OPTIONS`
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 游戏集合: `/games/` | `GameList` | `GET`, `POST`, 和 `OPTIONS` |'
- en: '| Game: `/game/{id}/` | `GameDetail` | `GET`, `PUT`, `PATCH`, `DELETE`, and
    `OPTIONS` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 游戏: `/game/{id}/` | `GameDetail` | `GET`、`PUT`、`PATCH`、`DELETE` 和 `OPTIONS`
    |'
- en: '| Collection of players: `/players/` | `PlayerList` | `GET`, `POST`, and `OPTIONS`
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 玩家集合: `/players/` | `PlayerList` | `GET`、`POST` 和 `OPTIONS` |'
- en: '| Player: `/player/{id}/` | `PlayerDetail` | `GET`, `PUT`, `PATCH`, `DELETE`,
    and `OPTIONS` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 玩家: `/player/{id}/` | `PlayerDetail` | `GET`、`PUT`、`PATCH`、`DELETE` 和 `OPTIONS`
    |'
- en: '| Collection of scores: `/player-scores/` | `PlayerScoreList` | `GET`, `POST`,
    and `OPTIONS` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 分数集合: `/player-scores/` | `PlayerScoreList` | `GET`、`POST` 和 `OPTIONS` |'
- en: '| Score: `/player-score/{id}/` | `PlayerScoreDetail` | `GET`, `PUT`, `PATCH`,
    `DELETE`, and `OPTIONS` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 分数: `/player-score/{id}/` | `PlayerScoreDetail` | `GET`、`PUT`、`PATCH`、`DELETE`
    和 `OPTIONS` |'
- en: Working with endpoints for the API
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与API端点一起工作
- en: 'We will create an endpoint for the root of our API to make it easier to browse
    the API with the browsable API feature and understand how everything works. Open
    the `views.py` file in the `games_service/games` folder and add the following
    code after the last line to declare the `ApiRoot` class. The code file for the
    sample is included in the `restful_python_2_06_01` folder, in the `Django01/games-service/games/serializers.py`
    file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为API的根创建一个端点，以便更容易地使用可浏览的API功能浏览API并了解一切是如何工作的。打开`games_service/games`文件夹中的`views.py`文件，在最后一行之后添加以下代码以声明`ApiRoot`类。示例的代码文件包含在`restful_python_2_06_01`文件夹中，在`Django01/games-service/games/serializers.py`文件中：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Browsing an API with relationships
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关系浏览API
- en: 'Now we can launch Django''s development server to compose and send HTTP requests
    to our still unsecured, yet much more complex, web API (we will definitely add
    security later). Execute any of the following two commands based on your needs
    to access the API in other devices or computers connected to your LAN. Remember
    that we analyzed the difference between them in the previous chapter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动Django的开发服务器，以组合和发送HTTP请求到我们仍然不安全的、但更加复杂的Web API（我们肯定会稍后添加安全性）。根据您的需求执行以下两个命令之一以访问连接到您的LAN的其他设备或计算机上的API。请记住，我们在上一章中分析了它们之间的区别：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何之前的命令后，开发服务器将开始监听端口`8000`。
- en: 'Open a web browser and enter `http://localhost:8000/` or the appropriate URL
    if you are using another computer or device to access the browsable API. The browsable
    API will compose and send a `GET` request to `/` and will display the results
    of its execution, that is, the headers and the JSON response from the execution
    of the `get` method defined in the `ApiRoot` class within the `views.py` file.
    The following screenshot shows the rendered web page after entering the URL in
    a web browser with the resource description of api-root:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 打开网页浏览器并输入`http://localhost:8000/`或如果你使用另一台计算机或设备，请输入适当的URL以访问可浏览的API。可浏览的API将组合并发送一个`GET`请求到`/`，并将显示其执行结果，即`views.py`文件中`ApiRoot`类定义的`get`方法执行的头部和JSON响应。以下截图显示了在网页浏览器中输入URL后的渲染网页，其中包含api-root的资源描述：
- en: '![](img/4f42ccb1-8ca3-4c9a-946d-a578083f8015.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f42ccb1-8ca3-4c9a-946d-a578083f8015.png)'
- en: The api-root provides us with hyperlinks to see the list of ESRB ratings, games,
    players, and scores. This way, it becomes extremely easy to access the lists and
    perform operations on the different resources through the browsable API. In addition,
    when we visit the other URLs, the breadcrumb will allow us to go back to the api-root.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`api-root`为我们提供了超链接，以便查看ESRB评级、游戏、玩家和分数的列表。这样，通过可浏览的API访问列表并执行不同资源上的操作变得极其容易。此外，当我们访问其他URL时，面包屑导航将允许我们返回到`api-root`。'
- en: In this new version of the API, we worked with the generic views that provide
    many functions under the hood, and therefore, the browsable API will provide us
    additional features compared with the previous version. Click or tap on the URL
    at the right-hand side of "esrb-ratings". If you are browsing in localhost, the
    URL will be `http://localhost:8000/esrb-ratings/`. The browsable API will render
    the web page for the ESRB rating List.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个API的新版本中，我们使用了提供许多底层功能的通用视图，因此，与之前的版本相比，可浏览的API将为我们提供额外的功能。点击或轻触“esrb-ratings”右侧的URL。如果你正在本地主机上浏览，URL将是`http://localhost:8000/esrb-ratings/`。可浏览的API将渲染ESRB评级列表的网页。
- en: 'At the bottom of the rendered web page, the browsable API provides us some
    controls to generate a `POST` request to `/esrb-ratings/`. In this case, by default,
    the browsable API displays the HTML form tab with an automatically generated form
    that we can use to generate a POST request without having to deal with the raw
    data as we did in our previous version. The HTML forms make it easy to generate
    requests to test our API. The following screenshot shows the HTML form to create
    a new ESRB rating:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染的网页底部，可浏览的API为我们提供了一些控件来生成一个`POST`请求到`/esrb-ratings/`。在这种情况下，默认情况下，可浏览的API显示HTML表单标签，其中包含一个自动生成的表单，我们可以使用它来生成POST请求，而无需像我们之前的版本那样处理原始数据。HTML表单使得生成测试API的请求变得容易。以下截图显示了创建新ESRB评级的HTML表单：
- en: '![](img/a35bb0da-012c-493d-b11f-2dfc95798263.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a35bb0da-012c-493d-b11f-2dfc95798263.png)'
- en: 'We just need to enter the desired name, `AO (Adults Only)`, in the Name textbox
    and click or tap POST to create a new ESRB rating. The browsable API will compose
    and send a `POST` request to `/esrb-ratings/` with the previously specified data
    and we will see the results of the call in the web browser. The following screenshot
    shows a web browser displaying the HTTP status code `201 Created` in the response
    and the previously explained HTML form with the POST button to allow us to continue
    composing and sending `POST` requests to `/esrb-ratings/`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在“名称”文本框中输入所需的名称，`AO (Adults Only)`，然后点击或轻触“POST”来创建一个新的ESRB评级。可浏览的API将组合并发送一个`POST`请求到`/esrb-ratings/`，使用之前指定的数据，我们将在网页浏览器中看到调用结果。以下截图显示了网页浏览器显示的HTTP状态码`201
    Created`的响应和之前解释的带有POST按钮的HTML表单，允许我们继续编写并发送`POST`请求到`/esrb-ratings/`：
- en: '![](img/e63e1938-6e43-44be-b23b-51834dc775d9.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e63e1938-6e43-44be-b23b-51834dc775d9.png)'
- en: Now click on the URL displayed as a value for the `"url"` key in the JSON data
    displayed for the ESRB rating, such as `http://localhost:8000/esrb-ratings/1/`.
    Make sure you replace `1` with the ID of an existing ESRB rating in the previously
    rendered esrbrating-list. The browsable API will compose and send a `GET` request
    to `/esrb-ratings/1/` and will display the results of its execution, that is,
    the headers and the JSON data for the ESRB rating. The web page will display a
    DELETE button because we are working with the ESRB rating Detail view.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击显示在JSON数据中`"url"`键值处的URL，例如`http://localhost:8000/esrb-ratings/1/`。确保将`1`替换为之前渲染的`esrbrating-list`中存在的ESRB评分的ID。可浏览的API将组合并发送一个到`/esrb-ratings/1/`的`GET`请求，并将显示其执行结果，即ESRB评分的头信息和JSON数据。网页将显示一个删除按钮，因为我们正在处理ESRB评分详情视图。
- en: We can use the breadcrumb to go back to the API root and start creating games
    related to an ESRB rating, players, and finally, scores related to a game and
    a player. We can do all this with easy-to-use HTML forms and the browsable API
    feature. This feature is extremely useful for testing CRUD operations with a RESTful
    API.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用面包屑导航回到API根目录，并开始创建与ESRB评分、玩家和最终与游戏和玩家相关的分数相关的游戏。我们可以通过易于使用的HTML表单和可浏览的API功能来完成所有这些。这个功能对于测试RESTful
    API的CRUD操作非常有用。
- en: Creating and retrieving related resources
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和检索相关资源
- en: Now we will use the HTTP command or its `curl` equivalents to compose and send
    HTTP requests to the API. We will use JSON for the requests that require additional
    data. Remember that you can perform the same tasks as your favorite GUI-based
    tool or with the browsable API.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用HTTP命令或其`curl`等效命令来组合并发送HTTP请求到API。我们将使用JSON进行需要额外数据的请求。记住，你可以使用你喜欢的基于GUI的工具或通过可浏览的API执行相同的任务。
- en: 'First, we will run the following command to compose and send an HTTP `POST`
    request to create a new ESRB rating. Remember that we used the browsable API to
    create an ESRB rating with the following description: `''AO (Adults Only)''`.
    The code file for the sample is included in the `restful_python_2_06_01` folder,
    in the `Django01/cmd/cmd615.txt` file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将运行以下命令来组合并发送一个HTTP `POST`请求以创建一个新的ESRB评分。记住，我们使用可浏览的API创建了一个具有以下描述的ESRB评分：`'AO
    (Adults Only)'`。示例代码文件包含在`restful_python_2_06_01`文件夹中的`Django01/cmd/cmd615.txt`文件中：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following is the equivalent
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的
- en: Test your knowledge
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'Under the hood, the `@api_view` decorator is:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在底层，`@api_view`装饰器是：
- en: A wrapper that converts a function-based view into a subclass of the `rest_framework.views.APIView`
    class
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个将基于函数的视图转换为`rest_framework.views.APIView`类子类的包装器
- en: A wrapper that converts a function-based view into a serializer
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个将基于函数的视图转换为序列化器的包装器
- en: A wrapper that converts a function-based view into a subclass of the `rest_framework.views.api_view`
    class
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个将基于函数的视图转换为`rest_framework.views.api_view`类子类的包装器
- en: The `Serializer` and `ModelSerializer` classes in Django REST Framework are
    similar to which of the following two classes in Django Web framework?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django REST Framework中的`Serializer`和`ModelSerializer`类类似于Django Web框架中的哪两个类？
- en: '`Form` and `ModelForm`'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Form`和`ModelForm`'
- en: '`View` and `ModelView`'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`View`和`ModelView`'
- en: '`Controller` and `ModelController`'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Controller`和`ModelController`'
- en: Which of the following classes is a read-write field that represents the target
    of the relationship by a unique slug attribute, that is, the description?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个类是一个读写字段，通过唯一的slug属性（即描述）表示关系的目标？
- en: '`SlugLinkedField`'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SlugLinkedField`'
- en: '`HyperlinkedRelatedField`'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HyperlinkedRelatedField`'
- en: '`SlugRelatedField`'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SlugRelatedField`'
- en: Which of the following classes renders the URL for a related object?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个类用于生成相关对象的URL？
- en: '`SlugLinkedField`'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SlugLinkedField`'
- en: '`HyperlinkedRelatedField`'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HyperlinkedRelatedField`'
- en: '`SlugRelatedField`'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SlugRelatedField`'
- en: 'The browsable API is a feature included in Django REST Framework that:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可浏览的API是Django REST Framework中包含的一个功能：
- en: Generates human-friendly JSON output for each resource whenever the request
    specifies `application/json` as the value for the `Content-type` key in the request
    header
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当请求头中的`Content-type`键指定为`application/json`值时，为每个资源生成人类友好的JSON输出
- en: Generates human-friendly HTML output for each resource whenever the request
    specifies `text/html` as the value for the `Content-type` key in the request header
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当请求头中的`Content-type`键指定为`text/html`值时，为每个资源生成人类友好的HTML输出
- en: . Generates human-friendly HTML output for each resource whenever the request
    specifies `application/json` as the value for the `Content-type` key in the request
    header
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: . 当请求指定请求头中的 `Content-type` 键的值为 `application/json` 时，为每个资源生成人类友好的 HTML 输出
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took advantage of many features included in Django REST
    Framework that allow us to eliminate duplicate code and build our API reusing
    generalized behaviors. We used model serializers, wrappers, default parsing and
    rendering options, class-based views, and generic classes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们利用了 Django REST Framework 中包含的许多功能，这些功能使我们能够消除重复代码，并重用通用行为来构建我们的 API。我们使用了模型序列化器、包装器、默认解析和渲染选项、基于类的视图和通用类。
- en: We used the browsable API feature and we designed a RESTful API that interacted
    with a complex PostgreSQL 10.5 database. We declared relationships with the models,
    and we configured serialization and deserialization with hyperlinks. Finally,
    we created and retrieved related resources and understood how things work under
    the hood.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了可浏览的 API 功能，并设计了一个与复杂的 PostgreSQL 10.5 数据库交互的 RESTful API。我们声明了与模型的关系，并使用超链接配置了序列化和反序列化。最后，我们创建了相关资源并检索了它们，并理解了内部的工作原理。
- en: Now that we built a complex API with Django REST Framework that we can encapsulate
    in a microservice, we will use additional ...
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 Django REST Framework 构建了一个复杂的 API，可以封装成微服务，我们将使用额外的 ...
