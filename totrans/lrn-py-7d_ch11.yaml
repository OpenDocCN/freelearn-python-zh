- en: Class and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve deeper into classes and objects, let's first try to understand
    what they are and why they form part of Python programming. Python language also
    supports object-oriented programming. For beginners, this might be a little confusing
    topic but be assured it is not that difficult to understand the concept of object-oriented
    programming (OOP). Let's try to understand what object-oriented programming is.
    Before this concept was introduced, we were primarily slave to writing procedural
    programming, that is, going line by line. At this level, you need not understand
    what is procedural programming but certainly there is one example to illustrate
    it, that is, C language. In procedural programming, there were a lot of complexities
    and above all procedural programming had negligible code reuse concept.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of object-oriented programming was seen to solve many problems,
    which procedural programming did not solve. In object-oriented programming, everything
    mimics just like a real-world object. In the real world, everything is an object.
    An object can have state and behavior. An object in the real world can communicate
    with another object. For example, a dog object in the real world has state and
    behavior. OOPs is based on four pillars. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOPs is a vast topic that needs to be covered at the intermediate level. In
    case of Python programming, however, we will cover some key concepts in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class**: Class is considered as a blueprint for object creation. It can be
    understood as a factory to produce objects. It provides a template for creating
    an object and specifying its behavior through means of methods and state through
    means of variable instance name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects**: They can be considered as an instance of a class. An object can
    have state and behavior or attributes. The objects basically bundles a set of
    related states and behaviors, for example, a dog has state (*name*) and behavior
    (*barking*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance**: Inheritance is a feature supported by many programming languages,
    it can be correlated in real life as properties passed on by parents to their
    children. In object-oriented programming, the child class can inherit many properties
    from the parent class. Here, we mean that the child class can use an existing
    method or behavior, which the parent class has defined and use them accordingly
    in their class. Inheritance can be a single inheritance or multiple inheritance.
    Single inheritance, as the name suggests, refers to only one parent, while multiple
    inheritance refers to inheriting the property from multiple parents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism**: Well, this literally means something, which has many forms.
    In OOPs, an object can have many forms through means of different attributes.
    To simplify, in our case, we can understand it by methods with the same name but
    having different outputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction**: Here, we hide the necessary details and are only interested
    in showing the relevant details to the other intended user. Here, by other intended
    user we mean another software application, or another class, or other client who
    will be the end users of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: This refers to hiding the necessary methods and their relevant
    details from the outside world. A class can be treated as a best example, which
    provides encapsulation to the methods and relevant instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, after understanding some basic concepts of OOPs, let's understand them
    with some programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a class in Python is quite easy. Refer to the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `class1.py` program. In this program, we are creating an empty
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just created a `Leapx_org` class. This class is empty, the class body
    just contains the pass statement. Basically, the class is a blueprint to create
    instances. Let''s create the instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the `class1.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program class1.py
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see both the instances of the `Leapx_org`
    class at different locations in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Instance variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instance variables refer to the data that are unique to instances (objects).
    Let''s create an instance variable. We will write a new `class2.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `L_obj1.f_name`, `L_obj1.L_name`, and `L_obj1.pamount`
    are the instance variables, which are unique to the `L_obj1` instance. Similarly, `L_obj2.f_name`,
    `L_obj2.L_name`, and `L_obj2.pamount` are the instance variables of the `L_obj2` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code class2.py
  prefs: []
  type: TYPE_NORMAL
- en: If we create an instance variable, as shown in the code, then we would not get
    benefit of making a class. You can see repeatable code for both the instances.
    So we would not have to set the variable all the time. In order to make it automatically,
    we will use the special `method __init__()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__ method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `__init__()` method must begin and end with two consecutive underscores.
    Here `__init__` works as the class''s constructor. When a user instantiates the
    class, it runs automatically. Let''s see and understand this concept with the
    help of code. Here we will write the full code for `classinit.py` and then we
    will understand it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, from preceding code, it seems difficult; let''s understand it by line by
    line. The first line defines a class as we already know. When we create the `__init__(self,first,last,
    pay)` method inside the class then first argument, self, `of __init__()` method
    receives the instance of the class automatically. By convention we call it `self`,
    you can use another name, but it is a good idea to stick to the convention. After
    declaring the `self` variable, we can specify other arguments that we want to
    accept. So we will accept three values `first`, `last`, and `pay`. Inside the
    `__init__()` method we will declare the instance variable. So the `self.f_name`,
    `self.l_name`, `self.pay_amt`, and `self.full_name` are instance variables. The
    `self` variable receives the instance. The `self.f_name = first` statement is
    the same thing as we saw `L_obj1.f_name = "Mohit"` in the previous code `class2.py`.
    The `L_obj` is the instance of the class and the variable is self referred to
    instance of the class, which is more or less similar. When we create an instance
    like `L_obj1 = Leapx_org(''mohit'', ''RAJ'', 60000)` the values `(''mohit'', ''RAJ'',
    60000)` are automatically passed to the `__init__(self, first, last, pay)` method.
    We don’t need to pass the value of the `self` variable, because the `L_obj1` instance
    is passed automatically. Similar things happens for the `L_obj2` instance. If
     your doubt still persists for the self and instance variables, you can refer
    to the following figure for clarification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Self linking with object
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you got an idea of the instance variable: the `self.f_name`, `self.l_name`,
    `self_pay_amt`, and `self.full_name` are the instance variables, unique to instance
    `L_obj1` and `L_obj2`. The `self.f_name`, `self.l_name`,  `self_pay_amt`, and
    `self.full_name` contain values `mohit`, `RAJ`, and `60000`, for instance, `L_obj1`
    and `Ravender`, `Dahiya` and `70000`, for instance, `L_obj2`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of classinit.py
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the preceding result and the result from `class2.py` are the
    same. But we reduce few lines from the code `classinit.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the method inside the class. We want a functionality to generate
    the e-mail address for users. We will write the full code for `classmethod1.py` and
    discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code is very much similar to the previous code. We added the `make_email()`
    method here, which used the instance variables `self.f_name` and `self.l_name`.
    By using the `L_obj1.make_email()` syntax the `L_obj1` instance calls the `method
    make_email()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `make_email()` is the regular method. What is the regular method? The regular
    methods in the class automatically take the instances as the first argument. That's
    why, by convention, we use self as the first argument which expects an instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, in string, list we did the same thing as we did in `list1.append()`.
    If you relate list with the preceding class, then `list1` is the instance and
    `append()` is the method of the class list. You can also define the list as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go deeper to explore the `self` variable. If you are still in doubt,
    the next example will clear it. Refer to the code in `classmethod2.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is very much similar to `classmethod2.py`. In order to experiment,
    we used just one instance `L_obj1`. In the `make_email()` method, the argument
    self has been removed. Let''s run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classmethod2.py
  prefs: []
  type: TYPE_NORMAL
- en: You can see that error `make_email() takes no arguments (1 given)`. This can
    be confusing as we have not passed any argument in the syntax `L_obj1.make_email()`.
    What is the `make_email()` method expecting? In this case, the `L_obj1` instance
    is passed automatically. That’s why we use the `self` argument to the methods
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see following code `classmethod3.py` in order to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `self` variable has been put in the `make_email(self)` method.
    In the last line, `Leapx_org.make_email(L_obj1)` signifies what is running in
    the background. The syntax `L_obj1.make_email()` and `Leapx_org.make_email(L_obj1)`
    both are one and the same.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax `Leapx_org.make_email(L_obj1)` states `class.method(instance)`. In
    this syntax, we pass the instance to the `make_email()` method and the `self`
    argument accepts that instance. So, `L_obj1.make_email()` is transformed into
    `Leapx_org.make_email(L_obj1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Class variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class variables are the ones, which are sharable among all the instances of
    the class. The class variable must be the same for all the instances. To understand
    with example, let''s assume that `leapx_org` gives 5 percent increment based upon
    `pay_amt`. Let''s use another method to calculate the increment. Refer to the `classinstance1.py` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things that are new in the preceding program. We added
    `incrementpay()` which returns the raised `pay_amt amount`. The last line `print
    L_obj1.incrementpay()` states that the `L_obj1` instance calls the `incrementpay()` method.
    Let''s run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of classinstance1.py
  prefs: []
  type: TYPE_NORMAL
- en: The preceding program runs successfully but most of its content is logically
    wrong. In the `incrementpay()` method, we used the multiplication number `1.20`,
    which would be same for all the instances. So we can make the multiplication number
    `1.20` as the class variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the new code `classinstance2.py` with amendments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, we made a `mul_num` class variable that contains
    the value `1.20`. In the `incrementpay()` method, we access the `mul_num` class
    variable with the help of `self` means instance. You can use either `self` or
    class name with the `mul_num`. If you use the class name with `mul_num`, then
    it would be `Leapx_org. mul_num`. If you don''t use any of them, then the interpreter
    throws an error. You might be confused, if it is a class variable, then how can
    we access the class variable with the instance. Let''s add some lines to understand
    it better. Add the following lines at the end of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program classinstance2 with added lines
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are accessing the `mul_num` class variable with the help
    of instances `L_obj1`, `L_obj2`, and the `Leapx_org` class. All are showing the
    same value `1.2`. So what happens when we try to access an attribute by an instance?
    The instance first checks whether the instance contains the attribute. If the
    instance does not contain the attribute, then it checks the class or its parent
    class contains that attribute. So the instances `L_obj1` and `L_obj2` access the
    `mul_num` from the class. For more clarification, you can view the attribute of
    the class and instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the full code of `classinstance3.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Except for the last two lines, the rest of the code is similar to the previous
    one. The `L_obj1.__dict__` syntax prints all the attributes of the `L_obj1` instance
    and `Leapx_org.__dict__` prints all the attributes of the `Leapx_org` class. Run
    the program to see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classinstance3.py
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the instance name space does not contain the `mul_num` class
    variable, but the class name space contains `mul_num`. Let''s add `mul_num` to
    the name space of the `L_obj1` instance.  To avoid confusion, we will write `classinstance4.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, line `L_obj1.mul_num = 1.3` adds the `mul_num` variable
    in the name space of the `L_obj1` instance. The last three lines of code print
    the name of space of the instance `L_obj1`, `L_obj2` and the `Leapx_org` class.
    Let''s run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classinstance4.py
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows that the `L_obj1` instance finds the `mul_num` first
    with its own namespace before searching in the class namespace. That's why `L_obj1`
    shows `1.3`. We did not set `mul_num`, for instance, `L_obj2`, so `L_obj2` is
    still getting the value from the class namespace. In the `incrementpay()` method,
    we use `self.mul_num` instead of `Leapx_org.mul_num` because `self.mul_num` gives
    the ability to change `mul_num` value for single instance, if we want to. Let's
    create one more class variable to count the number of employees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the next code `classinstance5.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier we created new class variables count initializing with `0`. The syntax
    `Leapx_org.count = Leapx_org.count+1` increases the class variable by one. We
    have created three instances. Whenever we create a new instance, the `count` variable
    is incremented by one. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classinstance5.py
  prefs: []
  type: TYPE_NORMAL
- en: Now you got the idea of the class variable. If you set `self.count = self.count+1`
    instead of `Leapx_org.count = Leapx_org.count+1`, then you would get `0` employees.
  prefs: []
  type: TYPE_NORMAL
- en: Class inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about inheritance. Inheritance allows us to
    inherit methods and attributes of the parent class. By inheritance, a new child
    class automatically gets all of the methods and attributes of the existing parent
    class. The syntax is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember, in [Chapter 10](lrn-py-7d_ch09.html), *File Handling and Exceptions*,
    we had inherited the built-in class exception. Starting with the existing code,
    let''s make the `instructor` class, which would inherit the method of the `Leapx_org`
    class. Refer to the code in `classinheri1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In preceding code, we create a new class instructor which inherits the method
    and attributes from the `Leapx_org` class. The `Leapx_org` class is the base class
    and the instructor class is the child class. We left the body of the instructor
    class blank. We created two instances of the instructor class, then we printed
    the e-mails. Let''s run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classinheri1.py
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding result shows that the child class is successfully accessing the
    attributes of the parent class. When we instantiate the instructor class, it first
    looks up the `__init__` method of the instructor class. As the instructor class
    is empty, the interpreter checks the chain of inheritance. If you want to check
    the chain of inheritance, you need to use the `help()` function. Add the following
    lines in the `classinheri1.py` code and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the help function
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can easily see which methods, data, and attributes
    inherit from the base class. You can say that the base class is generic class
    and the child class is a specific class. Let''s proceed to more complicated examples.
    In the instructor class, we will add one more thing, which instructor teaches
    which subject. In order to do that, we need to add the `__init__` method to the
    instructor class. Let''s see the code `classinheri2.py` and discuss the additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the class instructor, we have created a `new __init__` method, which accepts
    the data `first`, `last`, `pay`, and `subject`. Now, there is no need to copy
    and paste the code of the `__init__` method from the `Leapx_org` base class. In
    order to get the data of the first, last, and pay arguments, we have used the `Leapx_org.__init__(self,first,last,pay)` syntax.
    This syntax passes the `first`, `last`, and `pay` arguments to the `Leapx_org` base
    class. The arguments `first`, `last`, and `pay` are handled by the `Leapx_org`
    class and the subject argument is handled by the class instructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created two instances `I_obj1` and `l_obj2`, which pass the data to the
    instructor class. Let''s run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classinheri2.py
  prefs: []
  type: TYPE_NORMAL
- en: Now you can understand that by using this class we can avoid repeating a lot
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In multiple inheritance, a class inherits the attributes and methods from more
    than one parent class. Let''s take a simple example `classmultiple.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created three classes. Class `A` contains a `sum1()`
    method, which performs the sum of two numbers. Class `B` contains a `sub1()` method,
    which performs the subtraction of two numbers. Class `C` is the class that inherits
    classes `A` and `B`. The `c_obj` instance is an instance of class `C`. The statement
    `c_obj.sum1(12,4)` calls the `sum1()` method of class `A`. The `c_obj.sub1(45,5)`
    statement calls the `sub1()` method of class `B`. Let''s run the code `classmultiple.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program classmultiple.py
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows that the program is running successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Multilevel inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this type of inheritance, a class can inherit from a child class or derived
    class. Let''s take a simple example code `classmultilevel.py` to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, you can see that class `B` inherited from class `A`
    and class `C` inherited from class `B`. The instance of class `C` can call the
    method of class `A`. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classmultilevel.py
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows that the code is running successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overriding the methods allows a user to override the parent class method. Sometimes
    the class provides a generic method, but in the child class, the user wants a
    specific implementation of the method. The name of the method must be the same
    in the parent class and the child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the program `classover1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, classes `A` and `B` both have the same method `sum1()`
    with different implementations. We also have printed the class name space using
    `B.__dict__`. Let''s see the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class16a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classover1.py
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding output, you can see the `sum1` function. The Interpreter first
    checks the instance’s class name space: if the method is found, the interpreter
    uses it.'
  prefs: []
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about operator overloading with special methods.
    Generally, people call them magic methods. We will use these methods in operator
    overloading. First, let''s understand what operator overloading is. Using a special
    method, we''ll able to change the built-in behavior of the operator. The special
    method is surrounded by double underscores (`__`). Some people called it the dunder
    method. Let''s take an example of the `+` operator, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see a different behavior of the `+` operator. The integer number is added
    and the strings are concatenated. Depending upon the object you are working with,
    the `+` operator has different behavior. However, the `+` calling is a special
    method that runs in the background. In order to do addition of two integers, the `+`
    operator calls `int.__add__(1,2)` and for string addition `+` calls `str.__add__(“a”,
    “b”)`. Refer to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So we can customize the addition using the `__add__()` method. Let''s take
    an example of the following code `classoperator1.py`, which is very much similar
    to the earlier code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add two instances `L_obj1` and `L_obj2`. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classoperator1.py
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding output shows an error in the code. Error for the `+` operator
    `L_obj1` and `L_obj2` are unsupported. We don''t know what we want to get from
    the addition. Consider we want to add the pay amount of both the instances. When
    I use `obj1+L_obj2`, the `+` operator should add the pay amount, which means *60000+70000*.
    Let''s refer to the program and see how to overload the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program is the same as the previous one except for the `magic
    __add__()` method. When we use `L_obj1+L_obj2`, then the `+` operator calls the
    `__add__()` method. The `__add__()` method accepts two instances as arguments.
    The syntax `result = self.pay_amt+ other.pay_amt` signifies the addition of `pay_amt`
    of two instances, which are `L_obj1` and `L_obj2`, in our case. Let''s see the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of classoperator2.py
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do one more program, which compares `pay_amt` for both the instances.
    Here is the code for `classoperator3.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, the last statement `L_obj1>L_obj2` would call the
    `__gt__()` method which accepts two instances; in this method, we perform a comparison
    based on their `pay_amt`. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program classoperator3.py
  prefs: []
  type: TYPE_NORMAL
- en: Do your experiment with different `pay_amt` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same program and print the instance length and instance. Refer
    to the code for `classoperator4.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have printed the instance and length of the instance.
    Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classoperator4.py
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to use two magic methods: to customize the instance print, we will
    use `__str__()` and to find out the length, we will use `__len__()`. For the `__len__()`
    method, we will use the length of the full name. See the code `classoperator5.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed earlier, we need to use two methods: one is `__str__()` and the
    second one is `__len__()`. We used the customize output `instance is belong to`.
    The `__len__()` function returns the combined length of the first name and the
    second name. Refer to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code classoperator5.py
  prefs: []
  type: TYPE_NORMAL
- en: Bingo! So both our purposes are served, the customized output and the length
    of the instance are being printed. I hope you got an idea how to use operator
    overloading and magic methods.
  prefs: []
  type: TYPE_NORMAL
- en: The class method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have seen the regular class methods of the class. The regular method automatically
    takes an instance as the first argument, and, by convention, we called it `self.`
    How can we pass the class as an argument so that we can change the class variable
    in the method? To do that, we use the class method. The class method takes the
    class as first argument. To turn the regular method into the class method, we
    will use decorator (`@classmethod`) at the top of the method. Let''s see the `methodclass1.py` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, a couple of things are new. The regular method `mul_num_set()`
    has been converted into the class method using the decorator `@classmethod` at
    the top. In the `mul_num_set(cls,amt)` method, the first argument `cls` represents
    the class. By convention, we are using `cls`. Don''t use `class` as the argument
    because `class` is the keyword, use it to define a class. The syntax `cls.mul_num=amt`
    sets the `mul_num` class variable to the `amt` value, which is passed by the line
    `Leapx_org.mul_num_set(1.40)`. The line `Leapx_org.mul_num_set(1.40)` calls the
    class method `mul_num_set()` using the class. You can also use an instance to
    call the class method as shown in `L_obj1.mul_num_set(1.40)`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program methodclass1.py
  prefs: []
  type: TYPE_NORMAL
- en: The same thing can be achieved using the `Leapx_org.mul_num= 1.40` line. But
    here we used the class method.
  prefs: []
  type: TYPE_NORMAL
- en: The static method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The static method doesn't take an instance or class as the first argument. They
    are just simple functions. But we include them in class because they have some
    logical connection with the class. Consider a situation in the `methodclass1.py`
    program, when the pay of a person is less than `50000`, then the incremented pay
    amount would be  `1.30`of pay amount , otherwise `1.20`. To turn a regular method
    into a class method, we will use decorator (`@staticmethod`) at the top of the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, the `check_amt()` method is a static method as specified
    by the decorator `@staticmethod`. The `check_amt()` method checks whether `amt`
    is greater than `50000` or not. The `incrementpay()` method uses the `check_amt()` static
    method. The `check_amt()` method does not change the class and instance variable.
    But it has some logical connection with regular method `incrementpay()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program staticmethod1.py
  prefs: []
  type: TYPE_NORMAL
- en: Hope you understood the static method.
  prefs: []
  type: TYPE_NORMAL
- en: The private variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python doesn''t have real private methods, so two underlines at the beginning
    make a variable and a method private. Let''s see a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, `__info()` is the private method and `__amount` is
    the private variable. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program private1.py
  prefs: []
  type: TYPE_NORMAL
- en: You can see the benefit of the private variable. Outside the class, you cannot
    access the private method as well as the private variable, but inside the class,
    you can access the private variables. In the `hello()` method, the `__amount` variable
    can be accessed as shown in the output (`Amount is printed`).
  prefs: []
  type: TYPE_NORMAL
- en: However, you can access private variables and the private method from outside
    the class. Use the syntax like instance `_class-name__private-attribute`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s rewrite the program with the correct syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/class24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program private1.py
  prefs: []
  type: TYPE_NORMAL
- en: So what is the benefit of accessing private variable outside the class. The
    benefit is to prevent the class method and variable being changed by others accidentally.
    Hope you get the idea of private methods.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned what is class and the benefits of creating
    a class. We learned how to create an instance or an object. Instance and object
    are the same thing. We learned the difference between class variable and instance
    variable. Class variables are shareable among all the regular methods. Static
    methods are unique to instances. In class inheritance, we learned the benefit
    of inheritance and code reuse. By using method overriding, we can override the
    method of the parent class. In operator overloading, we learned how to change
    the behavior of the built-in operator. We learned why to create static and class
    methods. The class methods are created to change class attributes. In the end, we
    learned the benefits of private methods and private variables.
  prefs: []
  type: TYPE_NORMAL
