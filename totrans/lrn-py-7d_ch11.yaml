- en: Class and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: Before we delve deeper into classes and objects, let's first try to understand
    what they are and why they form part of Python programming. Python language also
    supports object-oriented programming. For beginners, this might be a little confusing
    topic but be assured it is not that difficult to understand the concept of object-oriented
    programming (OOP). Let's try to understand what object-oriented programming is.
    Before this concept was introduced, we were primarily slave to writing procedural
    programming, that is, going line by line. At this level, you need not understand
    what is procedural programming but certainly there is one example to illustrate
    it, that is, C language. In procedural programming, there were a lot of complexities
    and above all procedural programming had negligible code reuse concept.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨类和对象之前，让我们首先尝试理解它们是什么以及为什么它们是Python编程的一部分。Python语言也支持面向对象编程。对于初学者来说，这可能是一个有点令人困惑的话题，但请放心，理解面向对象编程（OOP）的概念并不那么困难。让我们尝试理解什么是面向对象编程。在引入这个概念之前，我们主要是过程式编程的奴隶，也就是说，逐行编写。在这个层面上，你不需要理解什么是过程式编程，但肯定有一个例子可以说明它，那就是C语言。在过程式编程中，有很多复杂性，最重要的是过程式编程几乎没有代码重用概念。
- en: Object-oriented programming overview
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程概述
- en: 'The concept of object-oriented programming was seen to solve many problems,
    which procedural programming did not solve. In object-oriented programming, everything
    mimics just like a real-world object. In the real world, everything is an object.
    An object can have state and behavior. An object in the real world can communicate
    with another object. For example, a dog object in the real world has state and
    behavior. OOPs is based on four pillars. They are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的概念被认为解决了许多过程式编程无法解决的问题。在面向对象编程中，一切就像现实世界中的对象一样。在现实世界中，一切都是对象。一个对象可以具有状态和行为。现实世界中的对象可以与另一个对象进行通信。例如，现实世界中的狗对象具有状态和行为。OOPs基于四个支柱。它们是：
- en: Polymorphism
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Abstraction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Encapsulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Key concepts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键概念
- en: OOPs is a vast topic that needs to be covered at the intermediate level. In
    case of Python programming, however, we will cover some key concepts in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一个广泛的话题，需要在中级水平上涵盖。然而，在Python编程中，我们将在本章中介绍一些关键概念。
- en: '**Class**: Class is considered as a blueprint for object creation. It can be
    understood as a factory to produce objects. It provides a template for creating
    an object and specifying its behavior through means of methods and state through
    means of variable instance name.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：类被认为是对象创建的蓝图。它可以被理解为生产对象的工厂。它提供了一个模板来创建对象，并通过方法指定其行为，通过变量实例名称指定其状态。'
- en: '**Objects**: They can be considered as an instance of a class. An object can
    have state and behavior or attributes. The objects basically bundles a set of
    related states and behaviors, for example, a dog has state (*name*) and behavior
    (*barking*).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：它们可以被视为类的一个实例。一个对象可以具有状态和行为或属性。对象基本上捆绑了一组相关的状态和行为，例如，狗有状态（*名字*）和行为（*吠叫*）。'
- en: '**Inheritance**: Inheritance is a feature supported by many programming languages,
    it can be correlated in real life as properties passed on by parents to their
    children. In object-oriented programming, the child class can inherit many properties
    from the parent class. Here, we mean that the child class can use an existing
    method or behavior, which the parent class has defined and use them accordingly
    in their class. Inheritance can be a single inheritance or multiple inheritance.
    Single inheritance, as the name suggests, refers to only one parent, while multiple
    inheritance refers to inheriting the property from multiple parents.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：继承是许多编程语言支持的一个特性，在现实生活中可以关联为父母传给子女的属性。在面向对象编程中，子类可以从父类继承许多属性。在这里，我们的意思是子类可以使用父类定义的现有方法或行为，并在它们自己的类中相应地使用它们。继承可以是单一继承或多重继承。单一继承，正如其名所示，指的是只有一个父类，而多重继承指的是从多个父类继承属性。'
- en: '**Polymorphism**: Well, this literally means something, which has many forms.
    In OOPs, an object can have many forms through means of different attributes.
    To simplify, in our case, we can understand it by methods with the same name but
    having different outputs.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态**：好吧，这字面上意味着某种具有多种形式的东西。在OOPs中，一个对象可以通过不同的属性具有多种形式。为了简化，在我们的例子中，我们可以通过具有相同名称但输出不同的方法来理解它。'
- en: '**Abstraction**: Here, we hide the necessary details and are only interested
    in showing the relevant details to the other intended user. Here, by other intended
    user we mean another software application, or another class, or other client who
    will be the end users of the program.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：在这里，我们隐藏必要的细节，只对向其他预期用户展示的相关细节感兴趣。在这里，其他预期用户指的是另一个软件应用、另一个类或其他客户端，他们将是程序的最终用户。'
- en: '**Encapsulation**: This refers to hiding the necessary methods and their relevant
    details from the outside world. A class can be treated as a best example, which
    provides encapsulation to the methods and relevant instances.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：这指的是隐藏必要的方法和它们的相关细节，不让外界知道。一个类可以被视为提供封装的最佳例子，它为方法和相关实例提供了封装。'
- en: Creating a class
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个类
- en: Now, after understanding some basic concepts of OOPs, let's understand them
    with some programming.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在理解了一些面向对象编程（OOPs）的基本概念之后，让我们通过一些编程来理解它们。
- en: 'Creating a class in Python is quite easy. Refer to the following syntax:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中创建一个类相当简单。参考以下语法：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s create a `class1.py` program. In this program, we are creating an empty
    class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `class1.py` 程序。在这个程序中，我们创建了一个空类：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have just created a `Leapx_org` class. This class is empty, the class body
    just contains the pass statement. Basically, the class is a blueprint to create
    instances. Let''s create the instances:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个 `Leapx_org` 类。这个类是空的，类体中只包含一个 pass 语句。基本上，这个类是一个创建实例的蓝图。让我们创建实例：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s run the `class1.py` program:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `class1.py` 程序：
- en: '![](img/class1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![类1](img/class1.jpg)'
- en: Output of program class1.py
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 class1.py 的输出
- en: In the preceding screenshot, you can see both the instances of the `Leapx_org`
    class at different locations in memory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到 `Leapx_org` 类的两个实例在内存中的不同位置。
- en: Instance variables
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例变量
- en: 'Instance variables refer to the data that are unique to instances (objects).
    Let''s create an instance variable. We will write a new `class2.py` program:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量指的是对实例（对象）独有的数据。让我们创建一个实例变量。我们将编写一个新的 `class2.py` 程序：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, `L_obj1.f_name`, `L_obj1.L_name`, and `L_obj1.pamount`
    are the instance variables, which are unique to the `L_obj1` instance. Similarly, `L_obj2.f_name`,
    `L_obj2.L_name`, and `L_obj2.pamount` are the instance variables of the `L_obj2` instance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`L_obj1.f_name`、`L_obj1.L_name` 和 `L_obj1.pamount` 是实例变量，它们是 `L_obj1`
    实例独有的。同样地，`L_obj2.f_name`、`L_obj2.L_name` 和 `L_obj2.pamount` 是 `L_obj2` 实例的实例变量。
- en: 'Let''s run the code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码：
- en: '![](img/class2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![类2](img/class2.jpg)'
- en: Output of code class2.py
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 class2.py 的输出
- en: If we create an instance variable, as shown in the code, then we would not get
    benefit of making a class. You can see repeatable code for both the instances.
    So we would not have to set the variable all the time. In order to make it automatically,
    we will use the special `method __init__()` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个实例变量，如代码所示，那么我们就不会从创建类中获得好处。你可以看到两个实例都有可重复的代码。所以我们就不用每次都设置变量。为了使其自动，我们将使用特殊的
    `__init__()` 方法。
- en: The __init__ method
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`__init__` 方法'
- en: 'The `__init__()` method must begin and end with two consecutive underscores.
    Here `__init__` works as the class''s constructor. When a user instantiates the
    class, it runs automatically. Let''s see and understand this concept with the
    help of code. Here we will write the full code for `classinit.py` and then we
    will understand it line by line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法必须以两个连续的下划线开始和结束。在这里，`__init__` 作为类的构造函数工作。当用户实例化类时，它会自动运行。让我们通过代码来查看和理解这个概念。这里我们将编写
    `classinit.py` 的完整代码，然后我们将逐行理解它：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, from preceding code, it seems difficult; let''s understand it by line by
    line. The first line defines a class as we already know. When we create the `__init__(self,first,last,
    pay)` method inside the class then first argument, self, `of __init__()` method
    receives the instance of the class automatically. By convention we call it `self`,
    you can use another name, but it is a good idea to stick to the convention. After
    declaring the `self` variable, we can specify other arguments that we want to
    accept. So we will accept three values `first`, `last`, and `pay`. Inside the
    `__init__()` method we will declare the instance variable. So the `self.f_name`,
    `self.l_name`, `self.pay_amt`, and `self.full_name` are instance variables. The
    `self` variable receives the instance. The `self.f_name = first` statement is
    the same thing as we saw `L_obj1.f_name = "Mohit"` in the previous code `class2.py`.
    The `L_obj` is the instance of the class and the variable is self referred to
    instance of the class, which is more or less similar. When we create an instance
    like `L_obj1 = Leapx_org(''mohit'', ''RAJ'', 60000)` the values `(''mohit'', ''RAJ'',
    60000)` are automatically passed to the `__init__(self, first, last, pay)` method.
    We don’t need to pass the value of the `self` variable, because the `L_obj1` instance
    is passed automatically. Similar things happens for the `L_obj2` instance. If
     your doubt still persists for the self and instance variables, you can refer
    to the following figure for clarification:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，从前面的代码来看，似乎很难理解；让我们逐行理解它。第一行定义了一个类，正如我们之前所知道的。当我们类内部创建 `__init__(self,first,last,pay)`
    方法时，`__init__()` 方法的第一个参数 `self` 自动接收类的实例。按照惯例，我们称之为 `self`，你可以使用另一个名字，但坚持惯例是一个好主意。在声明
    `self` 变量之后，我们可以指定我们想要接受的其它参数。所以我们将接受三个值 `first`、`last` 和 `pay`。在 `__init__()`
    方法内部，我们将声明实例变量。所以 `self.f_name`、`self.l_name`、`self.pay_amt` 和 `self.full_name`
    是实例变量。`self` 变量接收实例。`self.f_name = first` 语句与我们在之前的代码 `class2.py` 中看到的 `L_obj1.f_name
    = "Mohit"` 是同一个东西。`L_obj` 是类的实例，变量是 `self` 指向类的实例，这在某种程度上是相似的。当我们创建一个实例，如 `L_obj1
    = Leapx_org('mohit','RAJ',60000)` 时，值 `('mohit','RAJ',60000)` 会自动传递到 `__init__(self,first,last,pay)`
    方法。我们不需要传递 `self` 变量的值，因为 `L_obj1` 实例会自动传递。类似的事情也发生在 `L_obj2` 实例上。如果你对 `self`
    和实例变量还有疑问，你可以参考以下图表以获得澄清：
- en: '![](img/class3.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class3.jpg)'
- en: Self linking with object
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象的自关联
- en: 'Now you got an idea of the instance variable: the `self.f_name`, `self.l_name`,
    `self_pay_amt`, and `self.full_name` are the instance variables, unique to instance
    `L_obj1` and `L_obj2`. The `self.f_name`, `self.l_name`,  `self_pay_amt`, and
    `self.full_name` contain values `mohit`, `RAJ`, and `60000`, for instance, `L_obj1`
    and `Ravender`, `Dahiya` and `70000`, for instance, `L_obj2`, respectively.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了实例变量：`self.f_name`、`self.l_name`、`self_pay_amt` 和 `self.full_name` 是实例变量，对于实例
    `L_obj1` 和 `L_obj2` 是唯一的。例如，`self.f_name`、`self.l_name`、`self_pay_amt` 和 `self.full_name`
    包含值 `mohit`、`RAJ` 和 `60000`，例如，`L_obj1` 的 `Ravender`、`Dahiya` 和 `70000`，例如，`L_obj2`
    分别。
- en: 'Let''s run the code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码：
- en: '![](img/class4.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class4.jpg)'
- en: Output of classinit.py
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`classinit.py` 类的输出'
- en: You can see that the preceding result and the result from `class2.py` are the
    same. But we reduce few lines from the code `classinit.py`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，前面的结果和 `class2.py` 的结果相同。但我们从 `classinit.py` 的代码中减少了几个行。
- en: 'Let''s create the method inside the class. We want a functionality to generate
    the e-mail address for users. We will write the full code for `classmethod1.py` and
    discuss it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在类内部创建方法。我们想要一个生成用户电子邮件地址的功能。我们将编写 `classmethod1.py` 的完整代码并讨论它：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code is very much similar to the previous code. We added the `make_email()`
    method here, which used the instance variables `self.f_name` and `self.l_name`.
    By using the `L_obj1.make_email()` syntax the `L_obj1` instance calls the `method
    make_email()` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与之前的代码非常相似。我们在这里添加了 `make_email()` 方法，它使用了实例变量 `self.f_name` 和 `self.l_name`。通过使用
    `L_obj1.make_email()` 语法，`L_obj1` 实例调用了 `make_email()` 方法。
- en: The `make_email()` is the regular method. What is the regular method? The regular
    methods in the class automatically take the instances as the first argument. That's
    why, by convention, we use self as the first argument which expects an instance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_email()` 是常规方法。什么是常规方法？类中的常规方法自动将实例作为第一个参数。这就是为什么按照惯例，我们使用 `self` 作为第一个参数，它期望一个实例。'
- en: 'If you remember, in string, list we did the same thing as we did in `list1.append()`.
    If you relate list with the preceding class, then `list1` is the instance and
    `append()` is the method of the class list. You can also define the list as shown
    here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在字符串和列表中，我们做了与在 `list1.append()` 中相同的事情。如果你将列表与前面的类联系起来，那么 `list1` 是实例，`append()`
    是类列表的方法。你也可以像下面这样定义列表：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s go deeper to explore the `self` variable. If you are still in doubt,
    the next example will clear it. Refer to the code in `classmethod2.py` as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探索 `self` 变量。如果你还有疑问，下一个示例将澄清它。参考 `classmethod2.py` 中的代码如下：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code is very much similar to `classmethod2.py`. In order to experiment,
    we used just one instance `L_obj1`. In the `make_email()` method, the argument
    self has been removed. Let''s run the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与 `classmethod2.py` 非常相似。为了进行实验，我们只使用了一个实例 `L_obj1`。在 `make_email()` 方法中，已经移除了参数
    `self`。让我们运行代码：
- en: '![](img/class5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/class5.jpg)'
- en: Output of code classmethod2.py
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`classmethod2.py` 代码的输出'
- en: You can see that error `make_email() takes no arguments (1 given)`. This can
    be confusing as we have not passed any argument in the syntax `L_obj1.make_email()`.
    What is the `make_email()` method expecting? In this case, the `L_obj1` instance
    is passed automatically. That’s why we use the `self` argument to the methods
    of the class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到错误 `make_email() takes no arguments (1 given)`。这可能会令人困惑，因为我们没有在语法 `L_obj1.make_email()`
    中传递任何参数。`make_email()` 方法期望什么？在这种情况下，`L_obj1` 实例是自动传递的。这就是为什么我们使用 `self` 参数到类的方法中。
- en: 'Let''s see following code `classmethod3.py` in order to understand this better:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码 `classmethod3.py` 以更好地理解这一点：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, the `self` variable has been put in the `make_email(self)` method.
    In the last line, `Leapx_org.make_email(L_obj1)` signifies what is running in
    the background. The syntax `L_obj1.make_email()` and `Leapx_org.make_email(L_obj1)`
    both are one and the same.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`self` 变量已经被放入了 `make_email(self)` 方法中。在最后一行，`Leapx_org.make_email(L_obj1)`
    表示后台正在运行的内容。语法 `L_obj1.make_email()` 和 `Leapx_org.make_email(L_obj1)` 都是一样的。
- en: The syntax `Leapx_org.make_email(L_obj1)` states `class.method(instance)`. In
    this syntax, we pass the instance to the `make_email()` method and the `self`
    argument accepts that instance. So, `L_obj1.make_email()` is transformed into
    `Leapx_org.make_email(L_obj1)`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 语法 `Leapx_org.make_email(L_obj1)` 表示 `class.method(instance)`。在这个语法中，我们传递实例到
    `make_email()` 方法，而 `self` 参数接受这个实例。因此，`L_obj1.make_email()` 转换为 `Leapx_org.make_email(L_obj1)`。
- en: Class variables
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类变量
- en: 'Class variables are the ones, which are sharable among all the instances of
    the class. The class variable must be the same for all the instances. To understand
    with example, let''s assume that `leapx_org` gives 5 percent increment based upon
    `pay_amt`. Let''s use another method to calculate the increment. Refer to the `classinstance1.py` program:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量是那些在类的所有实例之间可以共享的变量。类变量对于所有实例都必须是相同的。为了通过示例来理解，让我们假设 `leapx_org` 根据 `pay_amt`
    提供了 5% 的增量。让我们使用另一种方法来计算增量。参考 `classinstance1.py` 程序：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are a couple of things that are new in the preceding program. We added
    `incrementpay()` which returns the raised `pay_amt amount`. The last line `print
    L_obj1.incrementpay()` states that the `L_obj1` instance calls the `incrementpay()` method.
    Let''s run the program:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，有一些新内容。我们添加了 `incrementpay()`，它返回增加的 `pay_amt` 金额。最后一行 `print L_obj1.incrementpay()`
    表示 `L_obj1` 实例调用了 `incrementpay()` 方法。让我们运行程序：
- en: '![](img/class6.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/class6.jpg)'
- en: Output of classinstance1.py
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`classinstance1.py` 代码的输出'
- en: The preceding program runs successfully but most of its content is logically
    wrong. In the `incrementpay()` method, we used the multiplication number `1.20`,
    which would be same for all the instances. So we can make the multiplication number
    `1.20` as the class variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序运行成功，但其中大部分内容在逻辑上是错误的。在 `incrementpay()` 方法中，我们使用了乘数 `1.20`，这对于所有实例都是相同的。因此，我们可以将乘数
    `1.20` 作为类变量。
- en: 'Let''s write the new code `classinstance2.py` with amendments:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写新的代码 `classinstance2.py` 并进行修改：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding program, we made a `mul_num` class variable that contains
    the value `1.20`. In the `incrementpay()` method, we access the `mul_num` class
    variable with the help of `self` means instance. You can use either `self` or
    class name with the `mul_num`. If you use the class name with `mul_num`, then
    it would be `Leapx_org. mul_num`. If you don''t use any of them, then the interpreter
    throws an error. You might be confused, if it is a class variable, then how can
    we access the class variable with the instance. Let''s add some lines to understand
    it better. Add the following lines at the end of the code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们创建了一个包含值`1.20`的`mul_num`类变量。在`incrementpay()`方法中，我们通过`self`（即实例）来访问`mul_num`类变量。你可以使用`self`或类名与`mul_num`一起使用。如果你使用类名与`mul_num`一起使用，那么它将是`Leapx_org.mul_num`。如果你不使用它们中的任何一个，那么解释器会抛出一个错误。如果你觉得这是一个类变量，那么我们如何通过实例来访问类变量呢？让我们添加一些代码来更好地理解它。在代码的末尾添加以下行：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the program and see the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并查看输出：
- en: '![](img/class7.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![班级7](img/class7.jpg)'
- en: Output of program classinstance2 with added lines
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了新行的程序`classinstance2`的输出
- en: As you can see, we are accessing the `mul_num` class variable with the help
    of instances `L_obj1`, `L_obj2`, and the `Leapx_org` class. All are showing the
    same value `1.2`. So what happens when we try to access an attribute by an instance?
    The instance first checks whether the instance contains the attribute. If the
    instance does not contain the attribute, then it checks the class or its parent
    class contains that attribute. So the instances `L_obj1` and `L_obj2` access the
    `mul_num` from the class. For more clarification, you can view the attribute of
    the class and instances.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在通过实例`L_obj1`、`L_obj2`和`Leapx_org`类来访问`mul_num`类变量。它们都显示了相同的值`1.2`。那么当我们尝试通过实例访问属性时会发生什么？实例首先检查实例是否包含该属性。如果实例不包含该属性，那么它会检查类或其父类是否包含该属性。因此，实例`L_obj1`和`L_obj2`从类中访问`mul_num`。为了更清晰地说明，你可以查看类和实例的属性。
- en: 'The following is the full code of `classinstance3.py`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`classinstance3.py`的完整代码：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Except for the last two lines, the rest of the code is similar to the previous
    one. The `L_obj1.__dict__` syntax prints all the attributes of the `L_obj1` instance
    and `Leapx_org.__dict__` prints all the attributes of the `Leapx_org` class. Run
    the program to see the output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后两行之外，其余代码与上一个类似。`L_obj1.__dict__`语法打印了`L_obj1`实例的所有属性，而`Leapx_org.__dict__`打印了`Leapx_org`类的所有属性。运行程序查看输出：
- en: '![](img/class8.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![班级8](img/class8.jpg)'
- en: Output of code classinstance3.py
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`classinstance3.py`的输出
- en: 'You can see that the instance name space does not contain the `mul_num` class
    variable, but the class name space contains `mul_num`. Let''s add `mul_num` to
    the name space of the `L_obj1` instance.  To avoid confusion, we will write `classinstance4.py`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，实例命名空间不包含`mul_num`类变量，但类命名空间包含`mul_num`。让我们将`mul_num`添加到`L_obj1`实例的命名空间中。为了避免混淆，我们将编写`classinstance4.py`：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, line `L_obj1.mul_num = 1.3` adds the `mul_num` variable
    in the name space of the `L_obj1` instance. The last three lines of code print
    the name of space of the instance `L_obj1`, `L_obj2` and the `Leapx_org` class.
    Let''s run the code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第`L_obj1.mul_num = 1.3`行在`L_obj1`实例的命名空间中添加了`mul_num`变量。代码的最后三行打印了实例`L_obj1`、`L_obj2`和`Leapx_org`类的命名空间。让我们运行代码：
- en: '![](img/class9.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![班级9](img/class9.jpg)'
- en: Output of code classinstance4.py
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`classinstance4.py`的输出
- en: The preceding output shows that the `L_obj1` instance finds the `mul_num` first
    with its own namespace before searching in the class namespace. That's why `L_obj1`
    shows `1.3`. We did not set `mul_num`, for instance, `L_obj2`, so `L_obj2` is
    still getting the value from the class namespace. In the `incrementpay()` method,
    we use `self.mul_num` instead of `Leapx_org.mul_num` because `self.mul_num` gives
    the ability to change `mul_num` value for single instance, if we want to. Let's
    create one more class variable to count the number of employees.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示，`L_obj1`实例首先在其自己的命名空间中找到`mul_num`，然后再在类命名空间中搜索。这就是为什么`L_obj1`显示`1.3`的原因。我们没有设置`mul_num`，例如`L_obj2`，所以`L_obj2`仍然从类命名空间中获取值。在`incrementpay()`方法中，我们使用`self.mul_num`而不是`Leapx_org.mul_num`，因为`self.mul_num`赋予我们改变`mul_num`值的单例能力，如果需要的话。让我们再创建一个类变量来计算员工数量。
- en: 'Let us see the next code `classinstance5.py`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一份代码`classinstance5.py`：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Earlier we created new class variables count initializing with `0`. The syntax
    `Leapx_org.count = Leapx_org.count+1` increases the class variable by one. We
    have created three instances. Whenever we create a new instance, the `count` variable
    is incremented by one. Let''s see the output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们创建了新的类变量 count，并初始化为 `0`。语法 `Leapx_org.count = Leapx_org.count+1` 会将类变量增加一。我们创建了三个实例。每次我们创建一个新的实例时，`count`
    变量都会增加一。让我们看看输出结果：
- en: '![](img/class10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class10.jpg)'
- en: Output of code classinstance5.py
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 classinstance5.py 的输出
- en: Now you got the idea of the class variable. If you set `self.count = self.count+1`
    instead of `Leapx_org.count = Leapx_org.count+1`, then you would get `0` employees.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了类变量的概念。如果你将 `self.count = self.count+1` 而不是 `Leapx_org.count = Leapx_org.count+1`，那么你会得到
    `0` 名员工。
- en: Class inheritance
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类继承
- en: 'In this section, we will learn about inheritance. Inheritance allows us to
    inherit methods and attributes of the parent class. By inheritance, a new child
    class automatically gets all of the methods and attributes of the existing parent
    class. The syntax is given as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习继承。继承允许我们继承父类的方法和属性。通过继承，新的子类会自动获得现有父类的所有方法和属性。语法如下：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you remember, in [Chapter 10](lrn-py-7d_ch09.html), *File Handling and Exceptions*,
    we had inherited the built-in class exception. Starting with the existing code,
    let''s make the `instructor` class, which would inherit the method of the `Leapx_org`
    class. Refer to the code in `classinheri1.py`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在 [第 10 章](lrn-py-7d_ch09.html) *文件处理和异常* 中，我们继承了内置的类异常。从现有代码开始，让我们创建一个
    `instructor` 类，它将继承 `Leapx_org` 类的方法。参考 `classinheri1.py` 中的代码：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In preceding code, we create a new class instructor which inherits the method
    and attributes from the `Leapx_org` class. The `Leapx_org` class is the base class
    and the instructor class is the child class. We left the body of the instructor
    class blank. We created two instances of the instructor class, then we printed
    the e-mails. Let''s run the code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个新的类 instructor，它从 `Leapx_org` 类继承方法和属性。`Leapx_org` 类是基类，而 instructor
    类是子类。我们留空了 instructor 类的主体。我们创建了 instructor 类的两个实例，然后打印了电子邮件。让我们运行代码：
- en: '![](img/class11.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class11.jpg)'
- en: Output of code classinheri1.py
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 classinheri1.py 的输出
- en: 'The preceding result shows that the child class is successfully accessing the
    attributes of the parent class. When we instantiate the instructor class, it first
    looks up the `__init__` method of the instructor class. As the instructor class
    is empty, the interpreter checks the chain of inheritance. If you want to check
    the chain of inheritance, you need to use the `help()` function. Add the following
    lines in the `classinheri1.py` code and run it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结果表明子类成功访问了父类的属性。当我们实例化 instructor 类时，它首先查找 instructor 类的 `__init__` 方法。由于
    instructor 类为空，解释器会检查继承链。如果你想检查继承链，你需要使用 `help()` 函数。在 `classinheri1.py` 代码中添加以下行并运行它：
- en: '![](img/class12.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class12.jpg)'
- en: Output of the help function
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助函数的输出
- en: 'In the preceding screenshot, you can easily see which methods, data, and attributes
    inherit from the base class. You can say that the base class is generic class
    and the child class is a specific class. Let''s proceed to more complicated examples.
    In the instructor class, we will add one more thing, which instructor teaches
    which subject. In order to do that, we need to add the `__init__` method to the
    instructor class. Let''s see the code `classinheri2.py` and discuss the additions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以轻松地看到哪些方法、数据和属性是从基类继承的。你可以认为基类是通用类，而子类是特定类。让我们继续更复杂的例子。在 instructor
    类中，我们将添加一个额外的功能，即讲师教授哪门课程。为了做到这一点，我们需要在 instructor 类中添加 `__init__` 方法。让我们看看 `classinheri2.py`
    代码并讨论添加的内容：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the class instructor, we have created a `new __init__` method, which accepts
    the data `first`, `last`, `pay`, and `subject`. Now, there is no need to copy
    and paste the code of the `__init__` method from the `Leapx_org` base class. In
    order to get the data of the first, last, and pay arguments, we have used the `Leapx_org.__init__(self,first,last,pay)` syntax.
    This syntax passes the `first`, `last`, and `pay` arguments to the `Leapx_org` base
    class. The arguments `first`, `last`, and `pay` are handled by the `Leapx_org`
    class and the subject argument is handled by the class instructor.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在类父类中，我们创建了一个 `new __init__` 方法，它接受数据 `first`、`last`、`pay` 和 `subject`。现在，没有必要从
    `Leapx_org` 基类复制和粘贴 `__init__` 方法的代码。为了获取 `first`、`last` 和 `pay` 参数的数据，我们使用了 `Leapx_org.__init__(self,first,last,pay)`
    语法。这个语法将 `first`、`last` 和 `pay` 参数传递给 `Leapx_org` 基类。参数 `first`、`last` 和 `pay`
    由 `Leapx_org` 类处理，而 `subject` 参数由类父类处理。
- en: 'We created two instances `I_obj1` and `l_obj2`, which pass the data to the
    instructor class. Let''s run the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个实例 `I_obj1` 和 `l_obj2`，并将数据传递给父类。让我们运行代码：
- en: '![](img/class13.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![类13](img/class13.jpg)'
- en: Output of code classinheri2.py
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`classinheri2.py` 代码的输出'
- en: Now you can understand that by using this class we can avoid repeating a lot
    of code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能理解，通过使用这个类，我们可以避免重复大量代码。
- en: Multiple inheritance
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'In multiple inheritance, a class inherits the attributes and methods from more
    than one parent class. Let''s take a simple example `classmultiple.py`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重继承中，一个类可以从多个父类继承属性和方法。让我们通过一个简单的例子 `classmultiple.py` 来看看：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, we have created three classes. Class `A` contains a `sum1()`
    method, which performs the sum of two numbers. Class `B` contains a `sub1()` method,
    which performs the subtraction of two numbers. Class `C` is the class that inherits
    classes `A` and `B`. The `c_obj` instance is an instance of class `C`. The statement
    `c_obj.sum1(12,4)` calls the `sum1()` method of class `A`. The `c_obj.sub1(45,5)`
    statement calls the `sub1()` method of class `B`. Let''s run the code `classmultiple.py`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了三个类。类 `A` 包含一个 `sum1()` 方法，用于计算两个数字的和。类 `B` 包含一个 `sub1()` 方法，用于计算两个数字的差。类
    `C` 是继承自类 `A` 和 `B` 的类。`c_obj` 实例是类 `C` 的实例。语句 `c_obj.sum1(12,4)` 调用类 `A` 的 `sum1()`
    方法。`c_obj.sub1(45,5)` 语句调用类 `B` 的 `sub1()` 方法。让我们运行代码 `classmultiple.py`：
- en: '![](img/class14.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![类14](img/class14.jpg)'
- en: Output of program classmultiple.py
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`classmultiple.py` 程序的输出'
- en: The preceding output shows that the program is running successfully.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示程序正在成功运行。
- en: Multilevel inheritance
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多级继承
- en: 'In this type of inheritance, a class can inherit from a child class or derived
    class. Let''s take a simple example code `classmultilevel.py` to understand:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种继承类型中，一个类可以继承自子类或派生类。让我们通过一个简单的例子代码 `classmultilevel.py` 来理解：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding example, you can see that class `B` inherited from class `A`
    and class `C` inherited from class `B`. The instance of class `C` can call the
    method of class `A`. Let''s see the output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你可以看到类 `B` 从类 `A` 继承，类 `C` 从类 `B` 继承。类 `C` 的实例可以调用类 `A` 的方法。让我们看看输出：
- en: '![](img/class15.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![类15](img/class15.jpg)'
- en: Output of code classmultilevel.py
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`classmultilevel.py` 代码的输出'
- en: The preceding output shows that the code is running successfully.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示代码正在成功运行。
- en: Overriding methods
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重写
- en: Overriding the methods allows a user to override the parent class method. Sometimes
    the class provides a generic method, but in the child class, the user wants a
    specific implementation of the method. The name of the method must be the same
    in the parent class and the child class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重写方法允许用户重写父类方法。有时类提供了一个通用方法，但在子类中，用户希望有一个特定实现的方法。方法名必须在父类和子类中相同。
- en: 'Let''s see the program `classover1.py`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序 `classover1.py`：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding example, classes `A` and `B` both have the same method `sum1()`
    with different implementations. We also have printed the class name space using
    `B.__dict__`. Let''s see the output of the code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，类 `A` 和 `B` 都有一个相同的方法 `sum1()`，但实现不同。我们还使用 `B.__dict__` 打印了类名空间。让我们看看代码的输出：
- en: '![](img/class16a.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![类16a](img/class16a.jpg)'
- en: Output of code classover1.py
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`classover1.py` 代码的输出'
- en: 'In the preceding output, you can see the `sum1` function. The Interpreter first
    checks the instance’s class name space: if the method is found, the interpreter
    uses it.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，你可以看到 `sum1` 函数。解释器首先检查实例的类名空间：如果找到了方法，解释器就使用它。
- en: Operator overloading
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: 'In this section, we will learn about operator overloading with special methods.
    Generally, people call them magic methods. We will use these methods in operator
    overloading. First, let''s understand what operator overloading is. Using a special
    method, we''ll able to change the built-in behavior of the operator. The special
    method is surrounded by double underscores (`__`). Some people called it the dunder
    method. Let''s take an example of the `+` operator, as shown in the following
    example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习使用特殊方法进行操作符重载。通常，人们称它们为魔法方法。我们将使用这些方法进行操作符重载。首先，让我们了解什么是操作符重载。使用特殊方法，我们可以改变运算符的内置行为。特殊方法由双下划线（`__`）包围。有些人称之为dunder方法。以下是一个`+`运算符的例子，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can see a different behavior of the `+` operator. The integer number is added
    and the strings are concatenated. Depending upon the object you are working with,
    the `+` operator has different behavior. However, the `+` calling is a special
    method that runs in the background. In order to do addition of two integers, the `+`
    operator calls `int.__add__(1,2)` and for string addition `+` calls `str.__add__(“a”,
    “b”)`. Refer to the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`+`运算符的不同行为。整数相加，字符串连接。根据你正在处理的对象，`+`运算符有不同的行为。然而，`+`调用是一个在后台运行的特殊方法。为了进行两个整数的加法，`+`运算符会调用`int.__add__(1,2)`，对于字符串加法`+`会调用`str.__add__(“a”,
    “b”)`。参考以下示例：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So we can customize the addition using the `__add__()` method. Let''s take
    an example of the following code `classoperator1.py`, which is very much similar
    to the earlier code snippets:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用`__add__()`方法来自定义加法。以下是一个类似之前代码片段的例子`classoperator1.py`：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will add two instances `L_obj1` and `L_obj2`. Let''s see the output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加两个实例`L_obj1`和`L_obj2`。让我们看看输出结果：
- en: '![](img/class16.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class16.jpg)'
- en: Output of code classoperator1.py
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`classoperator1.py`代码的输出'
- en: 'The preceding output shows an error in the code. Error for the `+` operator
    `L_obj1` and `L_obj2` are unsupported. We don''t know what we want to get from
    the addition. Consider we want to add the pay amount of both the instances. When
    I use `obj1+L_obj2`, the `+` operator should add the pay amount, which means *60000+70000*.
    Let''s refer to the program and see how to overload the `+` operator:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了代码中的错误。对于`+`运算符`L_obj1`和`L_obj2`是不支持的。我们不知道我们想要从加法中得到什么。假设我们想要将两个实例的工资总额相加。当我使用`obj1+L_obj2`时，`+`运算符应该加上工资总额，即*60000+70000*。让我们参考程序并看看如何重载`+`运算符：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding program is the same as the previous one except for the `magic
    __add__()` method. When we use `L_obj1+L_obj2`, then the `+` operator calls the
    `__add__()` method. The `__add__()` method accepts two instances as arguments.
    The syntax `result = self.pay_amt+ other.pay_amt` signifies the addition of `pay_amt`
    of two instances, which are `L_obj1` and `L_obj2`, in our case. Let''s see the
    output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序与上一个程序相同，只是多了`magic __add__()`方法。当我们使用`L_obj1+L_obj2`时，`+`运算符会调用`__add__()`方法。`__add__()`方法接受两个实例作为参数。语法`result
    = self.pay_amt+ other.pay_amt`表示将两个实例的`pay_amt`相加，在我们的例子中是`L_obj1`和`L_obj2`。让我们看看输出结果：
- en: '![](img/class17.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class17.jpg)'
- en: Output of classoperator2.py
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`classoperator2.py`的输出'
- en: 'Let''s do one more program, which compares `pay_amt` for both the instances.
    Here is the code for `classoperator3.py`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个程序，这个程序比较两个实例的`pay_amt`。以下是`classoperator3.py`的代码：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding program, the last statement `L_obj1>L_obj2` would call the
    `__gt__()` method which accepts two instances; in this method, we perform a comparison
    based on their `pay_amt`. Let''s see the output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，最后的语句`L_obj1>L_obj2`会调用接受两个实例的`__gt__()`方法；在这个方法中，我们根据它们的`pay_amt`进行比较。让我们看看输出结果：
- en: '![](img/class18.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class18.jpg)'
- en: Output of program classoperator3.py
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`classoperator3.py`程序的输出'
- en: Do your experiment with different `pay_amt` values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的`pay_amt`值进行实验。
- en: 'Let''s use the same program and print the instance length and instance. Refer
    to the code for `classoperator4.py`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用相同的程序并打印实例长度和实例。请参考`classoperator4.py`的代码：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, we have printed the instance and length of the instance.
    Let''s see the output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们打印了实例及其长度。让我们看看输出结果：
- en: '![](img/class19.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class19.jpg)'
- en: Output of code classoperator4.py
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`classoperator4.py`代码的输出'
- en: 'We need to use two magic methods: to customize the instance print, we will
    use `__str__()` and to find out the length, we will use `__len__()`. For the `__len__()`
    method, we will use the length of the full name. See the code `classoperator5.py`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用两个魔术方法：为了自定义实例打印，我们将使用`__str__()`，为了找出长度，我们将使用`__len__()`。对于`__len__()`方法，我们将使用全名的长度。参见代码`classoperator5.py`：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As discussed earlier, we need to use two methods: one is `__str__()` and the
    second one is `__len__()`. We used the customize output `instance is belong to`.
    The `__len__()` function returns the combined length of the first name and the
    second name. Refer to the output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要使用两种方法：一个是`__str__()`，另一个是`__len__()`。我们使用了自定义输出`instance is belong
    to`。`__len__()`函数返回第一个名字和第二个名字的组合长度。参考输出：
- en: '![](img/class20.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class20.jpg)'
- en: Output of code classoperator5.py
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代码classoperator5.py的输出
- en: Bingo! So both our purposes are served, the customized output and the length
    of the instance are being printed. I hope you got an idea how to use operator
    overloading and magic methods.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！所以我们的两个目的都达到了，即自定义输出和打印实例的长度。我希望您已经了解了如何使用运算符重载和魔术方法。
- en: The class method
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类方法
- en: 'You have seen the regular class methods of the class. The regular method automatically
    takes an instance as the first argument, and, by convention, we called it `self.`
    How can we pass the class as an argument so that we can change the class variable
    in the method? To do that, we use the class method. The class method takes the
    class as first argument. To turn the regular method into the class method, we
    will use decorator (`@classmethod`) at the top of the method. Let''s see the `methodclass1.py` example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了类的常规方法。常规方法自动接受一个实例作为第一个参数，并且按照惯例，我们将其称为`self`。我们如何将类作为参数传递，以便我们可以在方法中更改类变量？为了做到这一点，我们使用类方法。类方法接受类作为第一个参数。要将常规方法转换为类方法，我们将在方法的顶部使用装饰器（`@classmethod`）。让我们看看`methodclass1.py`的示例：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding program, a couple of things are new. The regular method `mul_num_set()`
    has been converted into the class method using the decorator `@classmethod` at
    the top. In the `mul_num_set(cls,amt)` method, the first argument `cls` represents
    the class. By convention, we are using `cls`. Don''t use `class` as the argument
    because `class` is the keyword, use it to define a class. The syntax `cls.mul_num=amt`
    sets the `mul_num` class variable to the `amt` value, which is passed by the line
    `Leapx_org.mul_num_set(1.40)`. The line `Leapx_org.mul_num_set(1.40)` calls the
    class method `mul_num_set()` using the class. You can also use an instance to
    call the class method as shown in `L_obj1.mul_num_set(1.40)`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，有几个新事物。常规方法`mul_num_set()`已经被装饰器`@classmethod`在顶部转换为类方法。在`mul_num_set(cls,amt)`方法中，第一个参数`cls`代表类。按照惯例，我们使用`cls`。不要使用`class`作为参数，因为`class`是关键字，使用它来定义一个类。语法`cls.mul_num=amt`将`mul_num`类变量设置为`amt`值，该值通过`Leapx_org.mul_num_set(1.40)`这一行传递。`Leapx_org.mul_num_set(1.40)`这一行使用类调用类方法`mul_num_set()`。您也可以使用实例来调用类方法，如`L_obj1.mul_num_set(1.40)`所示：
- en: 'Let''s run the program:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行程序：
- en: '![](img/class21.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class21.jpg)'
- en: Output of program methodclass1.py
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 程序方法class1.py的输出
- en: The same thing can be achieved using the `Leapx_org.mul_num= 1.40` line. But
    here we used the class method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以使用`Leapx_org.mul_num= 1.40`这一行实现相同的效果。但在这里我们使用了类方法。
- en: The static method
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: The static method doesn't take an instance or class as the first argument. They
    are just simple functions. But we include them in class because they have some
    logical connection with the class. Consider a situation in the `methodclass1.py`
    program, when the pay of a person is less than `50000`, then the incremented pay
    amount would be  `1.30`of pay amount , otherwise `1.20`. To turn a regular method
    into a class method, we will use decorator (`@staticmethod`) at the top of the
    method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法不接收实例或类作为第一个参数。它们只是简单的函数。但我们将它们包含在类中，因为它们与类有一定的逻辑联系。考虑`methodclass1.py`程序中的情况，当一个人的工资少于`50000`时，增加的工资金额将是工资金额的`1.30`倍，否则是`1.20`倍。要将常规方法转换为类方法，我们将在方法的顶部使用装饰器（`@staticmethod`）。
- en: 'Let''s make the program:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写程序：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding program, the `check_amt()` method is a static method as specified
    by the decorator `@staticmethod`. The `check_amt()` method checks whether `amt`
    is greater than `50000` or not. The `incrementpay()` method uses the `check_amt()` static
    method. The `check_amt()` method does not change the class and instance variable.
    But it has some logical connection with regular method `incrementpay()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`check_amt()`方法是一个静态方法，这是通过装饰器`@staticmethod`指定的。`check_amt()`方法检查`amt`是否大于`50000`。`incrementpay()`方法使用了`check_amt()`静态方法。`check_amt()`方法不会改变类和实例变量。但它与常规方法`incrementpay()`有一些逻辑联系。
- en: 'Refer to the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下输出：
- en: '![](img/class22.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class22.jpg)'
- en: Output of program staticmethod1.py
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 程序staticmethod1.py的输出
- en: Hope you understood the static method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你理解了静态方法。
- en: The private variable
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有变量
- en: 'Python doesn''t have real private methods, so two underlines at the beginning
    make a variable and a method private. Let''s see a very simple example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有真正的私有方法，所以两个下划线在开头使变量和方法变为私有。让我们看一个非常简单的例子：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding program, `__info()` is the private method and `__amount` is
    the private variable. Let''s see the output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`__info()`是私有方法，`__amount`是私有变量。让我们看看输出：
- en: '![](img/class23.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class23.jpg)'
- en: Output of program private1.py
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 程序private1.py的输出
- en: You can see the benefit of the private variable. Outside the class, you cannot
    access the private method as well as the private variable, but inside the class,
    you can access the private variables. In the `hello()` method, the `__amount` variable
    can be accessed as shown in the output (`Amount is printed`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到私有变量的好处。在类外部，你不能访问私有方法以及私有变量，但在类内部，你可以访问私有变量。在`hello()`方法中，`__amount`变量可以像输出中所示那样访问（`Amount
    is printed`）。
- en: However, you can access private variables and the private method from outside
    the class. Use the syntax like instance `_class-name__private-attribute`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以从类外部访问私有变量和私有方法。使用类似`instance `_class-name__private-attribute`的语法。
- en: 'Now, let''s rewrite the program with the correct syntax:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用正确的语法重写程序：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s see the output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出：
- en: '![](img/class24.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/class24.jpg)'
- en: Output of program private1.py
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 程序private1.py的输出
- en: So what is the benefit of accessing private variable outside the class. The
    benefit is to prevent the class method and variable being changed by others accidentally.
    Hope you get the idea of private methods.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在类外部访问私有变量的好处是什么？好处是防止类方法和变量被他人意外更改。希望你能理解私有方法的概念。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have learned what is class and the benefits of creating
    a class. We learned how to create an instance or an object. Instance and object
    are the same thing. We learned the difference between class variable and instance
    variable. Class variables are shareable among all the regular methods. Static
    methods are unique to instances. In class inheritance, we learned the benefit
    of inheritance and code reuse. By using method overriding, we can override the
    method of the parent class. In operator overloading, we learned how to change
    the behavior of the built-in operator. We learned why to create static and class
    methods. The class methods are created to change class attributes. In the end, we
    learned the benefits of private methods and private variables.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了什么是类以及创建类的益处。我们学习了如何创建一个实例或对象。实例和对象是同一件事物。我们学习了类变量和实例变量之间的区别。类变量可以在所有常规方法之间共享。静态方法仅对实例是唯一的。在类继承中，我们学习了继承和代码重用的好处。通过使用方法重写，我们可以覆盖父类的方法。在运算符重载中，我们学习了如何改变内置运算符的行为。我们学习了为什么要创建静态方法和类方法。类方法是为了改变类属性而创建的。最后，我们学习了私有方法和私有变量的好处。
