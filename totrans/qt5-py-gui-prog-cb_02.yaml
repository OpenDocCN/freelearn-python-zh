- en: Chapter 2. Layout Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 布局管理
- en: 'In this chapter we will lay out our GUI using Python 3:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 3 来搭建我们的图形用户界面：
- en: Arranging several labels within a label frame widget
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签框架小部件中排列多个标签
- en: Using padding to add space around widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用填充来为小部件周围添加空间
- en: How widgets dynamically expand the GUI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件如何动态扩展GUI
- en: Aligning the GUI widgets by embedding frames within frames
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在框架内嵌套框架来对齐GUI小部件
- en: Creating menu bars
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菜单栏
- en: Creating tabbed widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建标签式小部件
- en: Using the grid layout manager
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格布局管理器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will explore how to arrange widgets within widgets to create
    our Python GUI. Learning the fundamentals of GUI layout design will enable us
    to create great looking GUIs. There are certain techniques that will help us to
    achieve this layout design.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在窗口小部件内部排列小部件以创建我们的Python图形用户界面。掌握GUI布局设计的根本原理将使我们能够创建外观出色的GUI。有一些技术将帮助我们实现这种布局设计。
- en: The grid layout manager is one of the most important layout tools built into
    tkinter that we will be using.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器是tkinter内置的最重要的布局工具之一，我们将要使用它。
- en: We can very easily create menu bars, tabbed controls (aka Notebooks), and many
    more widgets using tk.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常容易地使用 tk 创建菜单栏、标签控制（即笔记本）以及许多其他小部件。
- en: One widget that is missing out of the box from tk is a status bar.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: tk中缺少一个开箱即用的状态栏组件。
- en: In this chapter, we will not bother to hand-craft this widget, but it can be
    done.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不必费心手工制作这个小部件，但它是可以完成的。
- en: Arranging several labels within a label frame widget
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在标签框架小部件中排列多个标签
- en: The `LabelFrame` widget allows us to design our GUI in an organized fashion.
    We are still using the grid layout manager as our main layout design tool, yet
    by using `LabelFrame` widgets we get much more control over our GUI design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`LabelFrame`小部件允许我们以有组织的方式设计我们的GUI。我们仍然使用网格布局管理器作为我们的主要布局设计工具，但通过使用`LabelFrame`小部件，我们对GUI设计有了更多的控制。'
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We are starting to add more and more widgets to our GUI, and we will make the
    GUI fully functional in the coming recipes. Here, we are starting to use the `LabelFrame`
    widget. We will reuse the GUI from the last recipe of the previous chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始在我们的GUI中添加越来越多的控件，并在接下来的菜谱中使GUI完全功能化。在这里，我们开始使用`LabelFrame`控件。我们将重用上一章最后一个菜谱中的GUI。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add the following code just above the main event loop towards the bottom of
    the Python module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python模块的底部主事件循环上方添加以下代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![How to do it...](img/B04829_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_01.jpg)'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can easily align the labels vertically by changing our code, as shown next.
    Note that the only change we had to make was in the column and row numberings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改代码轻松地垂直对齐标签，如下所示。请注意，我们唯一需要做的更改是在列和行编号上。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![How to do it...](img/B04829_02_01_1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_01_1.jpg)'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Comment # 1: Here, we will create our first ttk LabelFrame widget and give
    the frame a name. The parent container is `win`, our main window.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '评论 # 1：在这里，我们将创建我们的第一个 ttk LabelFrame 小部件，并为框架命名。父容器是 `win`，即我们的主窗口。'
- en: 'The three lines following comment # 2 create label names and place them in
    the LabelFrame. We are using the important grid layout tool to arrange the labels
    within the LabelFrame. The column and row properties of this layout manager give
    us the power to control our GUI layout.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释# 2之后的三个行创建标签名称并将它们放置在LabelFrame中。我们正在使用重要的网格布局工具来排列LabelFrame内的标签。这个布局管理器的列和行属性赋予我们控制GUI布局的能力。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The parent of our labels is the LabelFrame, not the `win` instance variable
    of the main window. We can see the beginning of a layout hierarchy here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标签的父容器是LabelFrame，而不是主窗口的`win`实例变量。在这里我们可以看到布局层次结构的开始。
- en: 'The highlighted comment # 3 shows how easy it is to change our layout via the
    column and row properties. Note how we change the column to 0, and how we layer
    our labels vertically by numbering the row values sequentially.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '突出的注释 # 3 展示了如何通过列和行属性轻松更改我们的布局。注意我们如何将列更改为 0，以及我们如何通过按顺序编号行值来垂直堆叠我们的标签。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The name ttk stands for "themed tk". The tk-themed widget set was introduced
    in Tk 8.5.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ttk 的名字代表 "主题化的 tk"。Tk 8.5 中引入了 tk 主题化的控件集。
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In a recipe later in this chapter, we will embed LabelFrame(s) within LabelFrame(s),
    nesting them to control our GUI layout.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面的食谱中，我们将嵌入LabelFrame(s)到LabelFrame(s)中，通过嵌套它们来控制我们的GUI布局。
- en: Using padding to add space around widgets
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用填充来为小部件周围添加空间
- en: Our GUI is being created nicely. Next, we will improve the visual aspects of
    our widgets by adding a little space around them, so they can breathe...
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图形用户界面正在顺利创建。接下来，我们将通过在它们周围添加一些空间来改善我们小部件的视觉外观，这样它们就可以呼吸了...
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: While tkinter might have had a reputation for creating ugly GUIs, this has dramatically
    changed since version 8.5, which ships with Python 3.4.x. You just have to know
    how to use the tools and techniques that are available. That's what we will do
    next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 tkinter 可能曾因创建丑陋的 GUI 而声名狼藉，但自从 8.5 版本（随 Python 3.4.x 一起发布）以来，这一情况已经发生了显著变化。你只需知道如何使用可用的工具和技术。这正是我们接下来要做的。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The procedural way of adding spacing around widgets is shown first, and then
    we will use a loop to achieve the same thing in a much better way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先展示的是围绕小部件添加间距的流程方式，然后我们将使用循环以更优的方式实现相同的效果。
- en: Our LabelFrame looks a bit tight as it blends into the main window towards the
    bottom. Let's fix this now.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的LabelFrame在底部与主窗口融合时看起来有点紧凑。现在我们来修复这个问题。
- en: 'Modify the following line of code by adding `padx` and `pady`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 修改以下代码行，通过添加`padx`和`pady`：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And now our LabelFrame got some breathing space:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 我们的 LabelFrame 获得了一些呼吸空间：
- en: '![How to do it...](img/B04829_02_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_02.jpg)'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In tkinter, adding space horizontally and vertically is done by using the built-in
    properties named `padx` and `pady`. These can be used to add space around many
    widgets, improving horizontal and vertical alignments, respectively. We hard-coded
    20 pixels of space to the left and right of the LabelFrame, and we added 40 pixels
    to the top and bottom of the frame. Now our LabelFrame stands out more than it
    did before.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The screenshot above only shows the relevant change.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图仅显示了相关更改。
- en: 'We can use a loop to add space around the labels contained within the LabelFrame:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用循环来在包含在LabelFrame中的标签周围添加空格：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the labels within the LabelFrame widget have some space around them too:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在LabelFrame小部件内的标签周围也有一些空间：
- en: '![How it works...](img/B04829_02_02_1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_02_02_1.jpg)'
- en: The `grid_configure()` function enables us to modify the UI elements before
    the main loop displays them. So, instead of hard-coding values when we first create
    a widget, we can work on our layout and then arrange spacing towards the end of
    our file, just before the GUI is being created. This is a neat technique to know.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The `winfo_children()` function returns a list of all the children belonging
    to the `labelsFrame` variable. This enables us to loop through them and assign
    the padding to each label.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`winfo_children()` 函数返回属于 `labelsFrame` 变量的所有子元素的列表。这使得我们可以遍历它们，并为每个标签分配填充。'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: One thing to notice is that the spacing to the right of the labels is not really
    visible. This is because the title of the LabelFrame is longer than the names
    of the labels. We can experiment with this by making the names of the labels longer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now our GUI looks like the following. Note how there is now some space added
    to the right of the long label next to the dots. The last dot does not touch the
    LabelFrame, which it would without the added space.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_02_02_2.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: We can also remove the name of the LabelFrame to see the effect `padx` has on
    positioning our labels.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_02_02_3.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: How widgets dynamically expand the GUI
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably noticed in previous screenshots and by running the code that widgets
    have a capability to extend themselves to the space they need to visually display
    their text.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java introduced the concept of dynamic GUI layout management. In comparison,
    visual development IDEs like VS.NET lay out the GUI in a visual manner, and are
    basically hard-coding the x and y coordinates of UI elements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Using `tkinter`, this dynamic capability creates both an advantage and a little
    bit of a challenge, because sometimes our GUI dynamically expands when we would
    prefer it rather not to be so dynamic! Well, we are dynamic Python programmers,
    so we can figure out how to make the best use of this fantastic behavior!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of the previous recipe we added a label frame widget. This
    moved some of our controls to the center of column 0\. We might not wish this
    modification to our GUI layout. Next, we will explore some ways to fix this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us first become aware of the subtle details that are going on in our GUI
    layout, in order to understand it better.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: We are using the grid layout manager widget and it lays out our widgets in a
    zero-based grid.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '| Row 0; Col 0 | Row 0; Col 1 | Row 0; Col 2 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| Row 1; Col 0 | Row 1; Col 1 | Row 1; Col 2 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: Using the grid layout manager, what is happening is that the width of any given
    column is determined by the longest name or widget in that column. This affects
    all rows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: By adding our LabelFrame widget and giving it a title that is longer than some
    hard-coded size widget like the top-left label and the text entry below it, we
    dynamically move those widgets to the center of column 0, adding space to the
    left and right sides of those widgets.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, because we used the sticky property for the Checkbutton and ScrolledText
    widgets, those remain attached to the left side of the frame.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look in more detail at the screenshot from the first recipe of this
    chapter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_02_4.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'We added the following code to create the LabelFrame and then placed labels
    into this frame:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the text property of the LabelFrame, which is displayed as the title of
    the LabelFrame, is longer than both our **Enter a name:** label and the textbox
    entry below it, those two widgets are dynamically centered with the new width
    of column 0.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The Checkbutton and Radiobutton widgets in column 0 did not get centered because
    we used the `sticky=tk.W` property when we created those widgets.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: For the ScrolledText widget we used `sticky=tk.WE,` which binds the widget to
    both the west (aka left) and east (aka right) side of the frame.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Let's remove the sticky property from the ScrolledText widget and observe the
    effect this change has.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now our GUI has new space around the ScrolledText widget both on the left and
    right sides. Because we used the `columnspan=3` property, our ScrolledText widget
    still spans all three columns.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_02_5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: If we remove `columnspan=3`, we get the following GUI, which is not what we
    want. Now our ScrolledText only occupies column 0, and, because of its size, it
    stretches the layout.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_02_6.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: One way to get our layout back to where we were before adding the LabelFrame
    is to adjust the grid column position. Change the column value from 0 to 1.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now our GUI looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we are still using individual widgets, our layout can get messed up.
    By moving the column value of the LabelFrame from 0 to 1, we were able to get
    the controls back to where they used to be and where we prefer them to be. At
    least the left-most label, text, checkbox, scrolledtext, and radio button widgets
    are now located where we intended them to be. The second label and text `Entry`
    located in column 1 have aligned themselves to the center of the length of the
    **Labels in a Frame** widget, so we basically moved our alignment challenge one
    column to the right. It is not so visible because the size of the **Choose a number:**
    label is almost the same as the size of the **Labels in a Frame** title, and so
    the column width was already close to the new width generated by the LabelFrame.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next recipe, we will embed frames within frames to avoid the accidental
    misalignment of widgets we just experienced in this recipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Aligning the GUI widgets by embedding frames within frames
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have much better control of our GUI layout if we embed frames within frames.
    This is what we will do in this recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dynamic behavior of Python and its GUI modules can create a little bit of
    a challenge to really get our GUI looking the way we want. Here we will embed
    frames within frames to get more control of our layout. This will establish a
    stronger hierarchy among the different UI elements, making the visual appearance
    easier to achieve.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to use the GUI we created in the previous recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will create a top-level frame that will contain other frames and widgets.
    This will help us to get our GUI layout just the way we want.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, we will have to embed our current controls within a central
    ttk.LabelFrame. This ttk.LabelFrame is a child of the main parent window and all
    controls will be children of this ttk.LabelFrame.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point in our recipes, we have assigned all widgets to our main GUI
    frame directly. Now we will only assign our LabelFrame to our main window, and
    after that, we will make this LabelFrame the parent container for all the widgets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates the following hierarchy in our GUI layout:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_30.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: In this diagram, **win** is the variable that references our main GUI tkinter
    window frame; **monty** is the variable that references our LabelFrame and is
    a child of the main window frame (**win**); and **aLabel** and all other widgets
    are now placed into the LabelFrame container (**monty**).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code towards the top of our Python module (see comment #
    1):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will modify all the following controls to use `monty` as the parent,
    replacing `win`. Here is an example of how to do this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![How to do it...](img/B04829_02_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Note how all the widgets are now contained in the **Monty Python** LabelFrame,
    which surrounds all of them with a barely visible thin line. Next, we can reset
    the **Labels in a Frame** widget to the left without messing up our GUI layout:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_04_1.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Oops - maybe not. While our frame within another frame aligned nicely to the
    left, it again pushed our top widgets into the center (a default).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In order to align them to the left, we have to force our GUI layout by using
    the `sticky` property. By assigning it "W" (West), we can control the widget to
    be left-aligned.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![How to do it...](img/B04829_02_04_2.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note how we aligned the label, but not the text box below it. We have to use
    the `sticky` property for all the controls we want to left-align. We can do that
    in a loop, using the `winfo_children()` and `grid_configure(sticky='W')` properties,
    as we did before in recipe 2 of this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The `winfo_children()` function returns a list of all the children belonging
    to the parent. This enables us to loop through all of the widgets and change their
    properties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using tkinter to force left, right, top, bottom the naming is very similar
    to Java: west, east, north and south, abbreviated to: "W" and so on. We can also
    use the following syntax: tk.W instead of "W".'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'In a previous recipe, we combined both "W" and "E" to make our ScrolledText
    widget attach itself both to the left and right sides of its container using "WE".
    We can add more combinations: "NSE" will stretch our widget to the top, bottom
    and right side. If we have only one widget in our form, for example a button,
    we can make it fill in the entire frame by using all options: "NSWE". We can also
    use tuple syntax: `sticky=(tk.N, tk.S, tk.W, tk.E)`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Let's change the very long label back and align the entry in column 0 to the
    left.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![How it works...](img/B04829_02_04_3.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to separate the influence that the length of our **Labels in a Frame**
    LabelFrame has on the rest of our GUI layout, we must not place this LabelFrame
    into the same LabelFrame as the other widgets. Instead we assign it directly to
    the main GUI form (`win`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: We will do this in later chapters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Creating menu bars
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will add a menu bar to our main window, add menus to the
    menu bar, and then add menu items to the menus.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by learning the techniques of how to add a menu bar, several menus
    and a few menu items to show the principle of how to do it. Clicking on a menu
    item will have no effect. Next, we will add functionality to the menu items, for
    example, closing the main window when clicking the **Exit** menu item and displaying
    a **Help** | **About** dialog.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We are continuing to extend the GUI we created in the current and previous chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we have to import the `Menu` class from `tkinter`. Add the following
    line of code to the top of the Python module, where the import statements live:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will create the menu bar. Add the following code towards the bottom
    of the module, just above where we create the main event loop:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we add a menu to the bar and also assign a menu item to the menu.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running this code adds a menu bar, with a menu, which has a menu item.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: Next, we add a second menu item to the first menu we added to the menu bar.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![How to do it...](img/B04829_02_05_1.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: We can add a separator line between the MenuItems by adding the following line
    of code (# 4) in between the existing MenuItems.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![How to do it...](img/B04829_02_05_2.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: By passing in the property `tearoff` to the constructor of the menu, we can
    remove the first dashed line that, by default, appears above the first MenuItem
    in a menu.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![How to do it...](img/B04829_02_05_3.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: We will add a second menu, which will be horizontally placed to the right of
    the first menu. We will give it one MenuItem, which we name `About`, and, in order
    for this to work, we have to add this second menu to the MenuBar.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**File** and **Help** | **About** are very common Windows GUI layouts that
    we are all familiar with, and we can create those same menus using Python and
    tkinter.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The order of creation and the naming of menu, menu item, and menu bar might
    at first be a little bit confusing, but, once we get used to how tkinter requires
    us to code it, this actually becomes fun.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![How to do it...](img/B04829_02_05_4.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'At this point, our GUI has a MenuBar and two menus that contain some MenuItems.
    Clicking on them does not do much, until we add some commands. That''s what we
    will do next. Add the following code above the creation of the MenuBar:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we bind the **File** | **Exit** MenuItem to this function by adding the
    following command to the MenuItem:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, when we click the `Exit` MenuItem, our application will indeed exit.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In comment # 1, we are calling the `tkinter` constructor of the menu and assigning
    the menu to our main GUI window. We save a reference in the instance variable
    named `menuBar` and, in the following line of code, we use this instance to configure
    our GUI to use `menuBar` as our menu.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment # 2 shows how we first add a MenuItem and then create a menu. This
    seems to be unintuitive, but this is how tkinter works. The `add_cascade()` method
    aligns the MenuItems one below the other, in a vertical layout.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment # 3 shows how to add a second MenuItem to the menu.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'In comment # 4, we are adding a separator line between the two MenuItems. This
    is usually used to group related MenuItems and separate them from less related
    items (hence the name).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment # 5 disables the tearoff dashed line to make our menu look much better.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without disabling this default feature, the user can "tear off" the menu from
    the main window. I find this capability to be of little value. Feel free to play
    around with it by double-clicking the dashed line (before disabling this feature).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Mac, this feature might not be enabled, so you do not have
    to worry about it at all.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_02_05_5.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: 'Comment # 6 shows you how to add a second menu to the MenuBar. We can keep
    on adding menus by using this technique.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment # 7 creates a function to quit our GUI application cleanly. This is
    the recommended Pythonic way to end the main event loop.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'In # 8 we bind the function we created in # 7 to the MenuItem, using the `tkinter`
    command property. Whenever we want our MenuItems to actually do something, we
    have to bind each of them to a function.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using a recommended Python naming convention by preceding our quit function
    with one single underscore, to indicate that this is a private function not to
    be called by clients of our code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will add the **Help** | **About** functionality in the next chapter, which
    introduces message boxes and much more.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Creating tabbed widgets
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create tabbed widgets to further organize our expanding
    GUI written in tkinter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to improve our Python GUI using tabs, we will start at the beginning,
    using the minimum amount of code necessary. In the following recipes, we will
    add widgets from previous recipes and place them into this new tabbed layout.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new Python module and place the following code into this module:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This creates the following GUI:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: While not amazingly impressive as of yet, this widget adds another very powerful
    tool to our GUI design toolkit. It comes with its own limitations in the minimalist
    example above (for example, we cannot reposition the GUI nor does it show the
    entire GUI title).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: While in previous recipes, we used the grid layout manager for simpler GUIs,
    we can use a simpler layout manager and "pack" is one of them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we "pack" tabControl ttk.Notebook into the main GUI form
    expanding the notebook tabbed control to fill in all sides.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_0.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: We can add a second tab to our control and click between them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have two tabs. Click on **Tab 2** to give it the focus.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_1.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: We would really like to see our windows title. So, to do this, we have to add
    a widget to one of our tabs. The widget has to be wide enough to expand our GUI
    dynamically to display our window title. We are adding Ole Monty back, together
    with his children.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we got our **Monty Python** inside **Tab1**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_2.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: We can keep placing all the widgets we have created so far into our newly created
    tab controls.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_3.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'Now all the widgets reside inside **Tab1**. Let''s move some to **Tab2**. First,
    we create a second LabelFrame to be the container of our widgets relocating to
    **Tab2**:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we move the check and radio buttons to **Tab2**, by specifying the new
    parent container, which is a new variable we name `monty2`. Here is an example
    which we apply to all controls that relocate to **Tab2**:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we run the code, our GUI now looks different. **Tab1** has less widgets
    than it had before when it contained all of our previously created widgets.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_4.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: We can now click **Tab 2** and see our relocated widgets.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_5.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Clicking the relocated Radiobutton(s) no longer has any effect, so we will change
    their actions to rename the text property, which is the title of the LabelFrame
    widget, to the name the Radiobuttons display. When we click the **Gold** Radiobutton,
    we no longer set the background of the frame to the color gold but here replace
    the LabelFrame text title instead. Python "The Snake" now becomes "Gold".
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, selecting any of the RadioButton widgets results in changing the name of
    the LabelFrame.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_6.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating a second tab, we moved some of the widgets that originally resided
    in **Tab1** to **Tab2**. Adding tabs is another excellent way to organize our
    ever-increasing GUI. This is one very nice way to handle complexity in our GUI
    design. We can arrange widgets in groups where they naturally belong, and free
    our users from clutter by using tabs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `tkinter`, creating tabs is done via the `Notebook` widget, which is the
    tool that allows us to add tabbed controls. The tkinter notebook widget, like
    so many other widgets, comes with additional properties that we can use and configure.
    An excellent place to start exploring additional capabilities of the tkinter widgets
    at our disposal is the official website: [https://docs.python.org/3.1/library/tkinter.ttk.html#notebook](https://docs.python.org/3.1/library/tkinter.ttk.html#notebook)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Using the grid layout manager
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The grid layout manager is one of the most useful layout tools at our disposal.
    We have already used it in many recipes because it is just so powerful.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will review some of the techniques of the grid layout manager.
    We have used them already and here we will explore them further.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have created rows and columns, which truly is a database
    approach to GUI design (MS Excel does the same). We hard-coded the first four
    rows but then we forgot to give the next row a specification of where we wish
    it to reside.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter did fill this in for us without us even noticing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we did in our code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Tkinter automatically adds the missing row (emphasized in comment # 1) where
    we did not specify any particular row. We might not realize this.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We laid out the checkbuttons on row 4 then we "forgot" to specify the row for
    our ScrolledText widget, which we reference via the scr variable and then we added
    the Radiobutton widgets to be laid out in row 6.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: This works nicely because tkinter automatically incremented the row position
    for our ScrolledText widget to use the next highest row number, which was row
    5.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Looking at our code and not realizing that we "forgot" to explicitly position
    our ScrolledText widget to row 5, we might think nothing resides there.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: So, we might try the following.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set the variable `curRad` to use row 5, we might get an unpleasant surprise:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_07.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note how our row of RadioButton(s) suddenly ended up in the middle of our ScrolledText
    widget! This is definitely not what we intended our GUI to look like!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we forget to explicitly specify the row number, by default, `tkinter` will
    use the next available row.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'We also used the `columnspan` property to make sure our widgets did not get
    limited to just one column. Here is how we made sure that our ScrolledText widget
    spans all the columns of our GUI:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
