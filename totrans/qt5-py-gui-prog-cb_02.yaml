- en: Chapter 2. Layout Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will lay out our GUI using Python 3:'
  prefs: []
  type: TYPE_NORMAL
- en: Arranging several labels within a label frame widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using padding to add space around widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How widgets dynamically expand the GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning the GUI widgets by embedding frames within frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating menu bars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tabbed widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the grid layout manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore how to arrange widgets within widgets to create
    our Python GUI. Learning the fundamentals of GUI layout design will enable us
    to create great looking GUIs. There are certain techniques that will help us to
    achieve this layout design.
  prefs: []
  type: TYPE_NORMAL
- en: The grid layout manager is one of the most important layout tools built into
    tkinter that we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: We can very easily create menu bars, tabbed controls (aka Notebooks), and many
    more widgets using tk.
  prefs: []
  type: TYPE_NORMAL
- en: One widget that is missing out of the box from tk is a status bar.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will not bother to hand-craft this widget, but it can be
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Arranging several labels within a label frame widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `LabelFrame` widget allows us to design our GUI in an organized fashion.
    We are still using the grid layout manager as our main layout design tool, yet
    by using `LabelFrame` widgets we get much more control over our GUI design.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are starting to add more and more widgets to our GUI, and we will make the
    GUI fully functional in the coming recipes. Here, we are starting to use the `LabelFrame`
    widget. We will reuse the GUI from the last recipe of the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following code just above the main event loop towards the bottom of
    the Python module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/B04829_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can easily align the labels vertically by changing our code, as shown next.
    Note that the only change we had to make was in the column and row numberings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/B04829_02_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comment # 1: Here, we will create our first ttk LabelFrame widget and give
    the frame a name. The parent container is `win`, our main window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The three lines following comment # 2 create label names and place them in
    the LabelFrame. We are using the important grid layout tool to arrange the labels
    within the LabelFrame. The column and row properties of this layout manager give
    us the power to control our GUI layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parent of our labels is the LabelFrame, not the `win` instance variable
    of the main window. We can see the beginning of a layout hierarchy here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The highlighted comment # 3 shows how easy it is to change our layout via the
    column and row properties. Note how we change the column to 0, and how we layer
    our labels vertically by numbering the row values sequentially.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name ttk stands for "themed tk". The tk-themed widget set was introduced
    in Tk 8.5.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a recipe later in this chapter, we will embed LabelFrame(s) within LabelFrame(s),
    nesting them to control our GUI layout.
  prefs: []
  type: TYPE_NORMAL
- en: Using padding to add space around widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our GUI is being created nicely. Next, we will improve the visual aspects of
    our widgets by adding a little space around them, so they can breathe...
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While tkinter might have had a reputation for creating ugly GUIs, this has dramatically
    changed since version 8.5, which ships with Python 3.4.x. You just have to know
    how to use the tools and techniques that are available. That's what we will do
    next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The procedural way of adding spacing around widgets is shown first, and then
    we will use a loop to achieve the same thing in a much better way.
  prefs: []
  type: TYPE_NORMAL
- en: Our LabelFrame looks a bit tight as it blends into the main window towards the
    bottom. Let's fix this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the following line of code by adding `padx` and `pady`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And now our LabelFrame got some breathing space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In tkinter, adding space horizontally and vertically is done by using the built-in
    properties named `padx` and `pady`. These can be used to add space around many
    widgets, improving horizontal and vertical alignments, respectively. We hard-coded
    20 pixels of space to the left and right of the LabelFrame, and we added 40 pixels
    to the top and bottom of the frame. Now our LabelFrame stands out more than it
    did before.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The screenshot above only shows the relevant change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a loop to add space around the labels contained within the LabelFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the labels within the LabelFrame widget have some space around them too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_02_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `grid_configure()` function enables us to modify the UI elements before
    the main loop displays them. So, instead of hard-coding values when we first create
    a widget, we can work on our layout and then arrange spacing towards the end of
    our file, just before the GUI is being created. This is a neat technique to know.
  prefs: []
  type: TYPE_NORMAL
- en: The `winfo_children()` function returns a list of all the children belonging
    to the `labelsFrame` variable. This enables us to loop through them and assign
    the padding to each label.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to notice is that the spacing to the right of the labels is not really
    visible. This is because the title of the LabelFrame is longer than the names
    of the labels. We can experiment with this by making the names of the labels longer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now our GUI looks like the following. Note how there is now some space added
    to the right of the long label next to the dots. The last dot does not touch the
    LabelFrame, which it would without the added space.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_02_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can also remove the name of the LabelFrame to see the effect `padx` has on
    positioning our labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_02_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How widgets dynamically expand the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably noticed in previous screenshots and by running the code that widgets
    have a capability to extend themselves to the space they need to visually display
    their text.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java introduced the concept of dynamic GUI layout management. In comparison,
    visual development IDEs like VS.NET lay out the GUI in a visual manner, and are
    basically hard-coding the x and y coordinates of UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: Using `tkinter`, this dynamic capability creates both an advantage and a little
    bit of a challenge, because sometimes our GUI dynamically expands when we would
    prefer it rather not to be so dynamic! Well, we are dynamic Python programmers,
    so we can figure out how to make the best use of this fantastic behavior!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of the previous recipe we added a label frame widget. This
    moved some of our controls to the center of column 0\. We might not wish this
    modification to our GUI layout. Next, we will explore some ways to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us first become aware of the subtle details that are going on in our GUI
    layout, in order to understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the grid layout manager widget and it lays out our widgets in a
    zero-based grid.
  prefs: []
  type: TYPE_NORMAL
- en: '| Row 0; Col 0 | Row 0; Col 1 | Row 0; Col 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Row 1; Col 0 | Row 1; Col 1 | Row 1; Col 2 |'
  prefs: []
  type: TYPE_TB
- en: Using the grid layout manager, what is happening is that the width of any given
    column is determined by the longest name or widget in that column. This affects
    all rows.
  prefs: []
  type: TYPE_NORMAL
- en: By adding our LabelFrame widget and giving it a title that is longer than some
    hard-coded size widget like the top-left label and the text entry below it, we
    dynamically move those widgets to the center of column 0, adding space to the
    left and right sides of those widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, because we used the sticky property for the Checkbutton and ScrolledText
    widgets, those remain attached to the left side of the frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look in more detail at the screenshot from the first recipe of this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We added the following code to create the LabelFrame and then placed labels
    into this frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since the text property of the LabelFrame, which is displayed as the title of
    the LabelFrame, is longer than both our **Enter a name:** label and the textbox
    entry below it, those two widgets are dynamically centered with the new width
    of column 0.
  prefs: []
  type: TYPE_NORMAL
- en: The Checkbutton and Radiobutton widgets in column 0 did not get centered because
    we used the `sticky=tk.W` property when we created those widgets.
  prefs: []
  type: TYPE_NORMAL
- en: For the ScrolledText widget we used `sticky=tk.WE,` which binds the widget to
    both the west (aka left) and east (aka right) side of the frame.
  prefs: []
  type: TYPE_NORMAL
- en: Let's remove the sticky property from the ScrolledText widget and observe the
    effect this change has.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now our GUI has new space around the ScrolledText widget both on the left and
    right sides. Because we used the `columnspan=3` property, our ScrolledText widget
    still spans all three columns.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we remove `columnspan=3`, we get the following GUI, which is not what we
    want. Now our ScrolledText only occupies column 0, and, because of its size, it
    stretches the layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One way to get our layout back to where we were before adding the LabelFrame
    is to adjust the grid column position. Change the column value from 0 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our GUI looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we are still using individual widgets, our layout can get messed up.
    By moving the column value of the LabelFrame from 0 to 1, we were able to get
    the controls back to where they used to be and where we prefer them to be. At
    least the left-most label, text, checkbox, scrolledtext, and radio button widgets
    are now located where we intended them to be. The second label and text `Entry`
    located in column 1 have aligned themselves to the center of the length of the
    **Labels in a Frame** widget, so we basically moved our alignment challenge one
    column to the right. It is not so visible because the size of the **Choose a number:**
    label is almost the same as the size of the **Labels in a Frame** title, and so
    the column width was already close to the new width generated by the LabelFrame.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next recipe, we will embed frames within frames to avoid the accidental
    misalignment of widgets we just experienced in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning the GUI widgets by embedding frames within frames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have much better control of our GUI layout if we embed frames within frames.
    This is what we will do in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dynamic behavior of Python and its GUI modules can create a little bit of
    a challenge to really get our GUI looking the way we want. Here we will embed
    frames within frames to get more control of our layout. This will establish a
    stronger hierarchy among the different UI elements, making the visual appearance
    easier to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to use the GUI we created in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will create a top-level frame that will contain other frames and widgets.
    This will help us to get our GUI layout just the way we want.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do so, we will have to embed our current controls within a central
    ttk.LabelFrame. This ttk.LabelFrame is a child of the main parent window and all
    controls will be children of this ttk.LabelFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point in our recipes, we have assigned all widgets to our main GUI
    frame directly. Now we will only assign our LabelFrame to our main window, and
    after that, we will make this LabelFrame the parent container for all the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates the following hierarchy in our GUI layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, **win** is the variable that references our main GUI tkinter
    window frame; **monty** is the variable that references our LabelFrame and is
    a child of the main window frame (**win**); and **aLabel** and all other widgets
    are now placed into the LabelFrame container (**monty**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code towards the top of our Python module (see comment #
    1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will modify all the following controls to use `monty` as the parent,
    replacing `win`. Here is an example of how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/B04829_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note how all the widgets are now contained in the **Monty Python** LabelFrame,
    which surrounds all of them with a barely visible thin line. Next, we can reset
    the **Labels in a Frame** widget to the left without messing up our GUI layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Oops - maybe not. While our frame within another frame aligned nicely to the
    left, it again pushed our top widgets into the center (a default).
  prefs: []
  type: TYPE_NORMAL
- en: In order to align them to the left, we have to force our GUI layout by using
    the `sticky` property. By assigning it "W" (West), we can control the widget to
    be left-aligned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/B04829_02_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note how we aligned the label, but not the text box below it. We have to use
    the `sticky` property for all the controls we want to left-align. We can do that
    in a loop, using the `winfo_children()` and `grid_configure(sticky='W')` properties,
    as we did before in recipe 2 of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `winfo_children()` function returns a list of all the children belonging
    to the parent. This enables us to loop through all of the widgets and change their
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using tkinter to force left, right, top, bottom the naming is very similar
    to Java: west, east, north and south, abbreviated to: "W" and so on. We can also
    use the following syntax: tk.W instead of "W".'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a previous recipe, we combined both "W" and "E" to make our ScrolledText
    widget attach itself both to the left and right sides of its container using "WE".
    We can add more combinations: "NSE" will stretch our widget to the top, bottom
    and right side. If we have only one widget in our form, for example a button,
    we can make it fill in the entire frame by using all options: "NSWE". We can also
    use tuple syntax: `sticky=(tk.N, tk.S, tk.W, tk.E)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's change the very long label back and align the entry in column 0 to the
    left.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/B04829_02_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to separate the influence that the length of our **Labels in a Frame**
    LabelFrame has on the rest of our GUI layout, we must not place this LabelFrame
    into the same LabelFrame as the other widgets. Instead we assign it directly to
    the main GUI form (`win`).
  prefs: []
  type: TYPE_NORMAL
- en: We will do this in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating menu bars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will add a menu bar to our main window, add menus to the
    menu bar, and then add menu items to the menus.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by learning the techniques of how to add a menu bar, several menus
    and a few menu items to show the principle of how to do it. Clicking on a menu
    item will have no effect. Next, we will add functionality to the menu items, for
    example, closing the main window when clicking the **Exit** menu item and displaying
    a **Help** | **About** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: We are continuing to extend the GUI we created in the current and previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we have to import the `Menu` class from `tkinter`. Add the following
    line of code to the top of the Python module, where the import statements live:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create the menu bar. Add the following code towards the bottom
    of the module, just above where we create the main event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we add a menu to the bar and also assign a menu item to the menu.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Running this code adds a menu bar, with a menu, which has a menu item.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we add a second menu item to the first menu we added to the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/B04829_02_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can add a separator line between the MenuItems by adding the following line
    of code (# 4) in between the existing MenuItems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/B04829_02_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By passing in the property `tearoff` to the constructor of the menu, we can
    remove the first dashed line that, by default, appears above the first MenuItem
    in a menu.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/B04829_02_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will add a second menu, which will be horizontally placed to the right of
    the first menu. We will give it one MenuItem, which we name `About`, and, in order
    for this to work, we have to add this second menu to the MenuBar.
  prefs: []
  type: TYPE_NORMAL
- en: '**File** and **Help** | **About** are very common Windows GUI layouts that
    we are all familiar with, and we can create those same menus using Python and
    tkinter.'
  prefs: []
  type: TYPE_NORMAL
- en: The order of creation and the naming of menu, menu item, and menu bar might
    at first be a little bit confusing, but, once we get used to how tkinter requires
    us to code it, this actually becomes fun.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/B04829_02_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, our GUI has a MenuBar and two menus that contain some MenuItems.
    Clicking on them does not do much, until we add some commands. That''s what we
    will do next. Add the following code above the creation of the MenuBar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we bind the **File** | **Exit** MenuItem to this function by adding the
    following command to the MenuItem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we click the `Exit` MenuItem, our application will indeed exit.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In comment # 1, we are calling the `tkinter` constructor of the menu and assigning
    the menu to our main GUI window. We save a reference in the instance variable
    named `menuBar` and, in the following line of code, we use this instance to configure
    our GUI to use `menuBar` as our menu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment # 2 shows how we first add a MenuItem and then create a menu. This
    seems to be unintuitive, but this is how tkinter works. The `add_cascade()` method
    aligns the MenuItems one below the other, in a vertical layout.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment # 3 shows how to add a second MenuItem to the menu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In comment # 4, we are adding a separator line between the two MenuItems. This
    is usually used to group related MenuItems and separate them from less related
    items (hence the name).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment # 5 disables the tearoff dashed line to make our menu look much better.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without disabling this default feature, the user can "tear off" the menu from
    the main window. I find this capability to be of little value. Feel free to play
    around with it by double-clicking the dashed line (before disabling this feature).
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Mac, this feature might not be enabled, so you do not have
    to worry about it at all.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B04829_02_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Comment # 6 shows you how to add a second menu to the MenuBar. We can keep
    on adding menus by using this technique.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment # 7 creates a function to quit our GUI application cleanly. This is
    the recommended Pythonic way to end the main event loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In # 8 we bind the function we created in # 7 to the MenuItem, using the `tkinter`
    command property. Whenever we want our MenuItems to actually do something, we
    have to bind each of them to a function.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using a recommended Python naming convention by preceding our quit function
    with one single underscore, to indicate that this is a private function not to
    be called by clients of our code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will add the **Help** | **About** functionality in the next chapter, which
    introduces message boxes and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tabbed widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create tabbed widgets to further organize our expanding
    GUI written in tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to improve our Python GUI using tabs, we will start at the beginning,
    using the minimum amount of code necessary. In the following recipes, we will
    add widgets from previous recipes and place them into this new tabbed layout.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new Python module and place the following code into this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the following GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While not amazingly impressive as of yet, this widget adds another very powerful
    tool to our GUI design toolkit. It comes with its own limitations in the minimalist
    example above (for example, we cannot reposition the GUI nor does it show the
    entire GUI title).
  prefs: []
  type: TYPE_NORMAL
- en: While in previous recipes, we used the grid layout manager for simpler GUIs,
    we can use a simpler layout manager and "pack" is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we "pack" tabControl ttk.Notebook into the main GUI form
    expanding the notebook tabbed control to fill in all sides.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can add a second tab to our control and click between them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we have two tabs. Click on **Tab 2** to give it the focus.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We would really like to see our windows title. So, to do this, we have to add
    a widget to one of our tabs. The widget has to be wide enough to expand our GUI
    dynamically to display our window title. We are adding Ole Monty back, together
    with his children.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now we got our **Monty Python** inside **Tab1**.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can keep placing all the widgets we have created so far into our newly created
    tab controls.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now all the widgets reside inside **Tab1**. Let''s move some to **Tab2**. First,
    we create a second LabelFrame to be the container of our widgets relocating to
    **Tab2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we move the check and radio buttons to **Tab2**, by specifying the new
    parent container, which is a new variable we name `monty2`. Here is an example
    which we apply to all controls that relocate to **Tab2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When we run the code, our GUI now looks different. **Tab1** has less widgets
    than it had before when it contained all of our previously created widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can now click **Tab 2** and see our relocated widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking the relocated Radiobutton(s) no longer has any effect, so we will change
    their actions to rename the text property, which is the title of the LabelFrame
    widget, to the name the Radiobuttons display. When we click the **Gold** Radiobutton,
    we no longer set the background of the frame to the color gold but here replace
    the LabelFrame text title instead. Python "The Snake" now becomes "Gold".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, selecting any of the RadioButton widgets results in changing the name of
    the LabelFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating a second tab, we moved some of the widgets that originally resided
    in **Tab1** to **Tab2**. Adding tabs is another excellent way to organize our
    ever-increasing GUI. This is one very nice way to handle complexity in our GUI
    design. We can arrange widgets in groups where they naturally belong, and free
    our users from clutter by using tabs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `tkinter`, creating tabs is done via the `Notebook` widget, which is the
    tool that allows us to add tabbed controls. The tkinter notebook widget, like
    so many other widgets, comes with additional properties that we can use and configure.
    An excellent place to start exploring additional capabilities of the tkinter widgets
    at our disposal is the official website: [https://docs.python.org/3.1/library/tkinter.ttk.html#notebook](https://docs.python.org/3.1/library/tkinter.ttk.html#notebook)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the grid layout manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The grid layout manager is one of the most useful layout tools at our disposal.
    We have already used it in many recipes because it is just so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will review some of the techniques of the grid layout manager.
    We have used them already and here we will explore them further.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have created rows and columns, which truly is a database
    approach to GUI design (MS Excel does the same). We hard-coded the first four
    rows but then we forgot to give the next row a specification of where we wish
    it to reside.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter did fill this in for us without us even noticing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we did in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Tkinter automatically adds the missing row (emphasized in comment # 1) where
    we did not specify any particular row. We might not realize this.'
  prefs: []
  type: TYPE_NORMAL
- en: We laid out the checkbuttons on row 4 then we "forgot" to specify the row for
    our ScrolledText widget, which we reference via the scr variable and then we added
    the Radiobutton widgets to be laid out in row 6.
  prefs: []
  type: TYPE_NORMAL
- en: This works nicely because tkinter automatically incremented the row position
    for our ScrolledText widget to use the next highest row number, which was row
    5.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at our code and not realizing that we "forgot" to explicitly position
    our ScrolledText widget to row 5, we might think nothing resides there.
  prefs: []
  type: TYPE_NORMAL
- en: So, we might try the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set the variable `curRad` to use row 5, we might get an unpleasant surprise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/B04829_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note how our row of RadioButton(s) suddenly ended up in the middle of our ScrolledText
    widget! This is definitely not what we intended our GUI to look like!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we forget to explicitly specify the row number, by default, `tkinter` will
    use the next available row.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also used the `columnspan` property to make sure our widgets did not get
    limited to just one column. Here is how we made sure that our ScrolledText widget
    spans all the columns of our GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
