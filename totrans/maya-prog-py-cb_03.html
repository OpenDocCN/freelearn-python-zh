<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Working with Geometry"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with Geometry</h1></div></div></div><p>In this chapter, we'll be looking at ways to create and manipulate geometry with scripting. The following topics will be covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with selected objects and checking node type</li><li class="listitem" style="list-style-type: disc">Accessing geometric data in polygonal models</li><li class="listitem" style="list-style-type: disc">Accessing geometric data in NURBS objects</li><li class="listitem" style="list-style-type: disc">Creating curves</li><li class="listitem" style="list-style-type: disc">Creating new polygonal faces</li><li class="listitem" style="list-style-type: disc">Creating new modifiers (noise)</li><li class="listitem" style="list-style-type: disc">Creating novel primitives (tetrahedron)</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Introduction</h1></div></div></div><p>In this chapter, we'll be looking at how to manipulate geometry within Maya via scripting. First off, we'll look at how to make sure that we have the right kind of object selected. From there, we'll look at how to retrieve information about particular kinds of geometry (both polygonal and NURBS).</p><p>We'll also be looking at how to create new geometry (both single faces and entire objects) and how to create per-vertex modifications to existing objects.</p></div></div>
<div class="section" title="Working with selected objects and checking node type"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Working with selected objects and checking node type</h1></div></div></div><p>Very often, you <a id="id110" class="indexterm"/>will want to make a script that only works on certain kinds of objects and the objects that already exist before the user invokes your script. In <a id="id111" class="indexterm"/>this case, you'll want to be able to not only determine what object(s) are currently selected but also to verify that the selected object(s) are of the appropriate type. In this example, we'll be creating a script that will verify that the currently selected object is, in fact, an instance of polygonal geometry and altering the user if it isn't.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec61"/>How to do it...</h2></div></div></div><p>Create a new script and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def currentSelectionPolygonal(obj):

    shapeNode = cmds.listRelatives(obj, shapes=True)
    nodeType = cmds.nodeType(shapeNode)

    if nodeType == "mesh":
        return True

    return False

def checkSelection():
    selectedObjs = cmds.ls(selection=True)

    if (len(selectedObjs) &lt; 1):
        cmds.error('Please select an object')

    lastSelected = selectedObjs[-1]

    isPolygon = currentSelectionPolygonal(lastSelected)

    if (isPolygon):
        print('FOUND POLYGON')
    else:
        cmds.error('Please select a polygonal object')

checkSelection()</pre></div><p>If you run the <a id="id112" class="indexterm"/>preceding script with nothing selected, you should get <a id="id113" class="indexterm"/>an error indicating that you should select something. If you run it with something other than a polygon object selected, you'll also get an error, but indicating this you should select a polygonal object.</p><p>If you run it with a polygonal object, however, the script will print <span class="strong"><strong>FOUND POLYGON</strong></span>.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec62"/>How it works...</h2></div></div></div><p>The script consists of two functions—one (<code class="literal">currentSelectionPolygonal</code>) to test if a given object is polygonal geometry and another (<code class="literal">checkSelection</code>) to invoke that on the currently selected object. Because <code class="literal">checkSelection</code> is the entry point for the script, that's where we'll start.</p><p>The first <a id="id114" class="indexterm"/>thing that we have to do is to get a list of what object or <a id="id115" class="indexterm"/>objects are currently selected. To do this, we'll use the <code class="literal">ls</code> command. The <code class="literal">ls</code> command is short for <span class="emphasis"><em>list</em></span> and another example of the bash scripting heritage of <a id="id116" class="indexterm"/>
<span class="strong"><strong>Maya Embedded Language</strong></span> (<span class="strong"><strong>MEL</strong></span>) that carries over to the Python command list. The <code class="literal">ls</code> command can do a variety of things, but the most common way that you're likely to use it is with the <code class="literal">selection</code> flag to return a list of the currently selected nodes, as in:</p><div class="informalexample"><pre class="programlisting">selectedObjs = cmds.ls(selection=True)</pre></div><p>Note that even though we're essentially asking Maya a question, it is not necessary to use the <code class="literal">query</code> flag. In fact, using the query mode for the <code class="literal">ls</code> command will generate an error. Note that we store the result of the <code class="literal">ls</code> command into a variable named <code class="literal">selectedObjects</code>. This will give us a collection of objects as a Python list, with objects appearing in the order in which they were selected. First, we want to make sure that at least one object is selected by checking the length of <code class="literal">selectedObjs</code>:</p><div class="informalexample"><pre class="programlisting">    if (len(selectedObjs) &lt; 1):
        cmds.error('Please select an object')</pre></div><p>If the user hasn't selected anything, we use the <code class="literal">error</code> command to both notify the user and stop the execution of the script. Adding meaningful error messages is a great way to give your users quality feedback. You can also use the <code class="literal">warning()</code> command to present the user with feedback without stopping the script. In both cases, the error (or warning) will show to the user in the same way as built-in errors (or warnings), appearing in the bottom of Maya's interface and with a red (or yellow) background.</p><p>Once we know that we have at least one object selected, we want to make sure that the given object is a polygonal one. Using <code class="literal">-1</code> as the index into the list allows us to count backwards from the end. In this case, that will give us the most recently selected object.</p><div class="informalexample"><pre class="programlisting">lastSelected = selectedObjs[-1]</pre></div><p>We then pass that object to our <code class="literal">currentSelectionPolygonal</code> function, which will determine if it is, in fact, a polygonal object. This function will handle the check and return either <code class="literal">True</code> or <code class="literal">False</code>, depending on whether or not the object in question is polygonal geometry.</p><div class="informalexample"><pre class="programlisting">isPolygon = currentSelectionPolygonal(lastSelected)</pre></div><p>It's generally a good idea to break up your scripts into distinct parts, with each one responsible for one distinct task. This makes your scripts much easier to write and maintain. However, it also requires that the different parts be able to communicate with each other. The <code class="literal">return</code> statement is one of the most common ways to do this. It causes the current function to stop and <span class="emphasis"><em>return</em></span> to the previous scope. If you give it a value, that value is brought back along, allowing information to be passed from one function to another.</p><p>We can check <a id="id117" class="indexterm"/>the type of given node by using the <code class="literal">nodeType()</code> command, but there's a bit more to it than that. If we check the type of the selected object itself, we'll almost always get <span class="emphasis"><em>transform</em></span>. This is due to the fact that most things you interact <a id="id118" class="indexterm"/>with in Maya are composed of two nodes, not one. There is generally a shape node, which holds all of the specific data associated with a given object (faces, vertices, and so on), and a transform object that holds the position, rotation, and scale (along with a few other things) common to all objects that appear on screen and can be moved. The shape node is always a child of its corresponding transform node.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>When you click on something in the interface, such as a polygonal object, you're actually clicking on the shape node, but Maya will automatically jump one step up the hierarchy to the transform node so that you can move it. That is often used to create controls for rigging by having the shape node for a curve be a child of some other transform, providing an easy way to grab bones inside a model by clicking on non-renderable curves (for example).</p></div></div><p>So, what we actually need in order to test the geometry type is the shape node associated with the transform. There are a couple of ways to go about this, but the best is to use the <code class="literal">listRelatives()</code> command with <code class="literal">shapes=True</code>. This will give us the shape node associated with the input node (if any):</p><div class="informalexample"><pre class="programlisting">def currentSelectionPolygonal(obj):
    shapeNode = cmds.listRelatives(obj, shapes=True)</pre></div><p>Once we've done this, we can test its type with <code class="literal">nodeType</code> to see what kind of geometry we have. If we have a polygonal object, it will result in <code class="literal">mesh</code>. If the node type is, in fact <code class="literal">mesh</code>, we return a value of <code class="literal">True</code>. If it's anything other than <code class="literal">mesh</code>, we return <code class="literal">False</code> instead:</p><div class="informalexample"><pre class="programlisting">    if nodeType == "mesh":
        return True

    return False</pre></div><p>Note that <code class="literal">return False</code> appears outside of an <code class="literal">else</code> block. This is mainly a stylistic choice. If you have a <code class="literal">return</code> statement inside a conditional (as we do here), it's a good idea to have a <code class="literal">return</code> statement that is outside the conditional that is guaranteed to be called, to ensure that there is no possible way that the function can fail to provide a return value.</p><p>Some people don't like to have multiple return values in a single function though, and if you're one of them, you could just as well create a variable and return that instead, as in:</p><div class="informalexample"><pre class="programlisting">    isMesh = False
    if (nodeType == "mesh"):
        isMesh = True

    return isMesh</pre></div><p>Or, for a <a id="id119" class="indexterm"/>more compact (but perhaps slightly less readable) approach, you could just return the result of the comparison itself:</p><div class="informalexample"><pre class="programlisting">    return (nodeType == "mesh")</pre></div><p>All of this would have the same result, in that the function would return <code class="literal">True</code> if and only if the object tested possessed a shape node of type <code class="literal">mesh</code>. At this point, we're done with the <code class="literal">currentSelectionPolygonal</code> function and can turn our attention back to <code class="literal">checkSelection</code>.</p><p>All that's left is <a id="id120" class="indexterm"/>to check the return value and notify the user of the result:</p><div class="informalexample"><pre class="programlisting">    if (isPolygon):
        print('FOUND POLYGON')
    else:
        cmds.error('Please select a polygonal object')</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec63"/>There's more...</h2></div></div></div><p>We can use the same technique of grabbing the shape node with <code class="literal">listRelatives</code> and testing its type to identify other kinds of objects. Some of the more useful ones to be aware of are <code class="literal">nurbsCurve</code> for NURBS curves and <code class="literal">nurbsSurface</code> for NURBS objects.</p></div></div>
<div class="section" title="Accessing geometric data in polygonal models"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Accessing geometric data in polygonal models</h1></div></div></div><p>In this<a id="id121" class="indexterm"/> example, we'll be looking at how to <a id="id122" class="indexterm"/>get information about polygonal geometry, which will form the basis for more complex scripts.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec64"/>Getting ready</h2></div></div></div><p>Create a new scene and make sure that it contains one or more polygonal objects.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec65"/>How to do it...</h2></div></div></div><p>Create a new script, name it <code class="literal">polyStats.py</code>, and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

# examine data for a currently-selected polygonal object
def getPolyData():
    selectedObjects = cmds.ls(selection=True)
    obj = selectedObjects[-1]

    vertNum = cmds.polyEvaluate(obj, vertex=True)
    print('Vertex Number: ',vertNum)

    edgeNum = cmds.polyEvaluate(obj, edge=True)
    print('Edge Number: ', edgeNum)

    faceNum = cmds.polyEvaluate(obj, face=True)
    print('Face Number: ',faceNum)

getPolyData()</pre></div><p>Running <a id="id123" class="indexterm"/>the <a id="id124" class="indexterm"/>preceding code will result in information about the currently selected polygonal object being printed.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec66"/>How it works...</h2></div></div></div><p>The <code class="literal">polyEvaluate</code> command is pretty straightforward and can be used to determine various information about a polygonal object. In this case, we're just grabbing the number of vertices, edges, and faces that the object contains.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec67"/>There's more...</h2></div></div></div><p>Grabbing the number of components that an object contains isn't really all that useful, in and of itself. To perform the useful work, you'll likely want to access the components directly.</p><p>In order to do this, you'll want to be understand that each object has a collection of components stored as a Python list, which are named as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Component</p>
</th><th style="text-align: left" valign="bottom">
<p>List name</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Vertices</p>
</td><td style="text-align: left" valign="top">
<p>vtx</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Edges</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Faces</p>
</td><td style="text-align: left" valign="top">
<p>f</p>
</td></tr></tbody></table></div><p>So, to select the first vertex for a given object (whose name is stored in a variable <code class="literal">obj</code>), you could do the following:</p><div class="informalexample"><pre class="programlisting">cmds.select(obj+'.vtx[0]', replace=True)</pre></div><p>You could similarly grab the first edge with:</p><div class="informalexample"><pre class="programlisting">cmds.select(obj+'.e[0]', replace=True)</pre></div><p>Or the first face with:</p><div class="informalexample"><pre class="programlisting">cmds.select(obj+'.f[0]', replace=True)</pre></div><p>Since the<a id="id125" class="indexterm"/> lists of components are just ordinary Python lists, you can also refer to collections of components by using a colon along with a start or a stop index (or both). For example, if we wanted to select vertices from <code class="literal">5</code> to <code class="literal">12</code>, we could do the following:</p><div class="informalexample"><pre class="programlisting">cmds.select(obj+'.vtx[5:12]', replace=True)</pre></div><p>This would work, but could quickly get awkward if you wanted to have the starting and ending indices as variables as well, which would result in something like the following:</p><div class="informalexample"><pre class="programlisting">cmds.select(obj+'.vtx[' + str(startIndex) + ':' + str(endIndex) + ']', replace=True)</pre></div><p>This would <a id="id126" class="indexterm"/>build up the proper value to pass to <code class="literal">cmds.select</code> (something like <code class="literal">polySurface5.vtx[5:12]</code>), but is a bit awkward to type. An easier way is to use Python's built-in string formatting capability, which can be used to fit variables into a specific string.</p><p>To do this, start with an example of the string you want to end up with, as in:</p><div class="informalexample"><pre class="programlisting">myObject.vtx[5:12]</pre></div><p>Then, identify each portion of the string that will change. In this case, we want to pass in three things—the name of the object, the start index, and the end index. For each one, replace the specific value with a number wrapped in curly braces, as in:</p><div class="informalexample"><pre class="programlisting">{0}.vtx[{1}:{2}]</pre></div><p>Once you've done this, you can call <code class="literal">format()</code> on the string, passing in values to replace the curly-bracketed numbers, as follows:</p><div class="informalexample"><pre class="programlisting">"{0}.vtx[{1}:{2}]".format("myObject", 5, 12)</pre></div><p>The numbers inside the brackets serve as indices and tell Python which of the arguments passed into format should go where. In this case, we're saying that the first argument (the object name) should go at the start and that the next two should be placed inside the square brackets.</p><p>Here's an example of it all put together:</p><div class="informalexample"><pre class="programlisting">objectName = "myObject"
startIndex = 5
endIndex = 12
cmds.select("{0}.vtx[{1}:{2}]".format(objectName, startIndex, endIndex), replace=True)</pre></div></div></div>
<div class="section" title="Accessing geometric data in NURBS objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Accessing geometric data in NURBS objects</h1></div></div></div><p>In this<a id="id127" class="indexterm"/> example, we'll be looking at how to retrieve information about NURBS surfaces, starting with the number of <span class="strong"><strong>control vertices</strong></span> (<span class="strong"><strong>CVs</strong></span>) they <a id="id128" class="indexterm"/>contain.</p><p>However, the <a id="id129" class="indexterm"/>number of CVs in a NURBS object isn't quite as straightforward as the number of vertices in a polygonal object. Although polygonal objects are relatively simple, with their shape determined directly by the position of the vertices, the curvature at any given point of a NURBS object is influenced by multiple points. The exact number of points that influence a given area depends on the degree of the surface.</p><p>To see how this works, we'll create a script that will determine the total number of CVs in each direction (<code class="literal">U</code> and <code class="literal">V</code>) of a NURBS surface, and we'll look at how to select a particular CV.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec68"/>Getting ready</h2></div></div></div><p>Make sure that you have a scene containing at least one NURBS surface.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec69"/>How to do it...</h2></div></div></div><p>Create a new file, name it <code class="literal">getNURBSinfo.py</code> (or similar), and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def getNURBSInfo():
    selectedObjects = cmds.ls(selection=True)
    obj = selectedObjects[-1]
    degU = cmds.getAttr(obj + '.degreeU')
    spansU = cmds.getAttr(obj + '.spansU')
    cvsU = degU + spansU
    print('CVs (U): ', cvsU)

    degV = cmds.getAttr(obj + '.degreeV')
    spansV = cmds.getAttr(obj + '.spansV')
    cvsV = degV + spansV
    print('CVs (V): ', cvsV)

getNURBSInfo()</pre></div><p>Select a <a id="id130" class="indexterm"/>NURBS surface and run the script. You'll see the number of CVs in each of the parametric directions (<code class="literal">U</code> and <code class="literal">V</code>) output to the script editor.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec70"/>How it works...</h2></div></div></div><p>In this<a id="id131" class="indexterm"/> example, we use the <code class="literal">getAttr</code> command to retrieve information about the selected object. The <code class="literal">getAttr</code> command is short for <span class="emphasis"><em>get attribute</em></span> and can be used to retrieve the value of any attribute on a given node, making it useful in a wide range of circumstances.</p><p>In this particular situation, we're using it to get two things per direction along the surface—the number of spans and the degree, as follows:</p><div class="informalexample"><pre class="programlisting">degU = cmds.getAttr(obj + '.degreeU')
spansU = cmds.getAttr(obj + '.spansU')</pre></div><p>The "degree" of a NURBS surface (or curve) is the number of points that influence each point along the geometry and ranges from 1 (linear) to 3. Curves and surfaces with degree of 1 are linear and resemble polygonal geometry. Curves and surfaces with degrees of greater than 1 interpolate multiple points to generate curvature. The total number of CVs in a curve or surface is always equal to the number of spans plus the degree.</p><p>One easy way to understand that is to think of the simplest possible curve—a straight line. That curve would have a single span (one segment) and would be of degree 1 (linear), and it would still require two points (the start and the end) in order to be defined. In that case, we would have:</p><p>
<span class="emphasis"><em>(1 span) + (degree of 1) = 2 points</em></span>
</p><p>For more complex curves, more points would be needed, but it's the same principle—the minimum number will always be (degree of curve) plus one (since it's impossible to have a curve or a surface with zero spans).</p><p>So, to get the total number of CVs, we use <code class="literal">getAttr</code> twice, once to get the spans and again to get the degree, then we add the totals, as in the following:</p><div class="informalexample"><pre class="programlisting">degU = cmds.getAttr(obj + '.degreeU')
spansU = cmds.getAttr(obj + '.spansU')
cvsU = degU + spansU
print('CVs (U): ', cvsU)</pre></div><p>Finally, to we'll finish off the script by selecting the first and last CVs. Selecting a CV on a NURBS surface is quite similar to selecting a vertex of a polygon, with the two following key differences:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We use <code class="literal">.cv</code> instead of <code class="literal">.vtx</code></li><li class="listitem" style="list-style-type: disc">We need to specify two indices (one for <code class="literal">U</code> and one for <code class="literal">V</code>) instead of one</li></ul></div><p>Selecting the first CV is pretty easy; we just use zero for both indices:</p><div class="informalexample"><pre class="programlisting">cmds.select(obj+'.cv[0][0]')</pre></div><p>Selecting <a id="id132" class="indexterm"/>the last CV is a bit more involved and requires that we string together a few different parts to make sure that we end up with something like <code class="literal">myObj.cv[8][8]</code> in the case that the surface has nine CVs in each direction. We<a id="id133" class="indexterm"/> need to subtract one from the total CV number and wrap that in <code class="literal">str()</code> so that Python will allow us to combine it with the text. Putting this all together gives us:</p><div class="informalexample"><pre class="programlisting">cmds.select(obj+'.cv[' + str(cvsU-1) + '][' + str(cvsV-1) + ']', add=True)</pre></div><p>Alternatively, we could use string formatting to build up the input, as follows:</p><div class="informalexample"><pre class="programlisting">cmds.select("{0}.cv[{1}][{2}]".format(obj, (cvsU-1), (cvsV-1), add=True)</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec71"/>There's more...</h2></div></div></div><p>The previously mentioned discussion is based on having working with a NURBS surface. If we were working with a curve instead, things would be much the same, but we would use a single index to specify the CV rather than two, as in:</p><div class="informalexample"><pre class="programlisting">    degree = cmds.getAttr(obj + '.degree')
    spans = cmds.getAttr(obj + '.spans')
    cvs = degree + spans
    print('CVs: ', cvs)

    cmds.select(obj+'.cv[0]')
    cmds.select(obj+'.cv[' + str(cvs-1) + ']', add=True)</pre></div><p>Also note that when we retrieve the values for degree and span, we do not specify <code class="literal">U</code> or <code class="literal">V</code> because curves have only one dimension rather than two.</p></div></div>
<div class="section" title="Creating curves"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Creating curves</h1></div></div></div><p>In this example, we'll be<a id="id134" class="indexterm"/> looking at how to create curves with code. This can be used for a number of different purposes, such as forming the basis for further modeling operation or creating custom controls for complex rigs.</p><p>We'll actually be making two curves in this example—a simple one that we create directly and a more complex one that we create one point at a time.</p><p>Here's what we'll end up with as our output and moving both curves away from the origin.</p><div class="mediaobject"><img src="graphics/4657_03_01.jpg" alt="Creating curves"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec72"/>How to do it...</h2></div></div></div><p>Create a new file <a id="id135" class="indexterm"/>and name it <code class="literal">makeCurves.py</code> or similar. Add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import math

def makeCurve():
    theCurve = cmds.curve(degree=1, p=[(-0.5,-0.5,0),(0.5,- 0.5,0),(0.5,0.5,0), (-0.5,0.5,0), (-0.5, -0.5, 0)])

def curveFunction(i):
    x = math.sin(i)
    y = math.cos(i)
    x = math.pow(x, 3)
    y = math.pow(y, 3)
    return (x,y)

def complexCurve():
    theCurve = cmds.curve(degree=3, p=[(0,0,0)])

    for i in range(0, 32):
        val = (math.pi * 2)/32 * i
        newPoint = curveFunction(val)
        cmds.curve(theCurve, append=True, p=[(newPoint[0], newPoint[1], 0)])


makeCurve()
complexCurve()</pre></div><p>If you run the <a id="id136" class="indexterm"/>preceding code, you'll end up with two curves being created—a square and an astroid curve.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec73"/>How it works...</h2></div></div></div><p>To make a new curve, we'll want to first understand what we're trying to make. In the case of the square, it's easy enough. We just need to have four points—each half of the width away from the origin in each combination of positive and negative ( (-,-), (-,+), (+,+), and (+,-)).</p><p>To actually make the curve, we'll use the <code class="literal">curve</code> command and specify a list of points. We'll also set the degree of our curve to <code class="literal">1</code>, that is, make it linear, which makes sense for a square. Putting that together gives us the following:</p><div class="informalexample"><pre class="programlisting">theCurve = cmds.curve(degree=1, p=[(-0.5,-0.5,0),(0.5,- 0.5,0),(0.5,0.5,0), (-0.5,0.5,0), (-0.5, -0.5, 0)])</pre></div><p>Note that we specify five points rather than four. If we leave it at only four points, we would end up with three spans rather than four, leaving one of the sides of our square missing. One way to address this is to simply repeat the first point at the end of the point list to close the curve.</p><p>For a more complex example, we'll create an <a id="id137" class="indexterm"/>
<span class="strong"><strong>astroid curve</strong></span> using some fun math. To make this easier, we'll create a function that will accept a parameterized input and output a two-element tuple with the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> coordinates of the curve for that input. We'll also append points to the curve as we go, as it is sometimes an easier way to approach things for more complex curves.</p><p>The parameterized equations for the curve can be written as:</p><p>Here, theta ranges from 0 to 2pi. Putting the value in terms of Python gives us the following:</p><div class="informalexample"><pre class="programlisting">def curveFunction(i):
    x = math.sin(i)
    y = math.cos(i)
    x = math.pow(x, 3)
    y = math.pow(y, 3)
    return (x,y)</pre></div><p>Now that we have a function that will give us the curve we want, we'll create a new curve and add points to it one at a time. First, we make the curve and set it to have a degree of three (cubic) so <a id="id138" class="indexterm"/>that it's nice and smooth, as follows:</p><div class="informalexample"><pre class="programlisting">theCurve = cmds.curve(degree=3, p=[(0,0,0)])</pre></div><p>Now, we'll step through our range of zero to (2 * pi) and add a new point to the existing curve:</p><div class="informalexample"><pre class="programlisting">for i in range(0, 32):
    val = (math.pi * 2)/32 * i
    newPoint = curveFunction(val)
    cmds.curve(theCurve, append=True, p=[(newPoint[0], newPoint[1], 0)])</pre></div><p>We start by calculating our input as 1/32nd of (2 * pi) times our index and passing it into our curve function. We then use the <code class="literal">curve</code> command again, but with a couple of changes, namely:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We specify the curve we're working on by passing it as the first argument</li><li class="listitem" style="list-style-type: disc">We use the <code class="literal">append=True</code> flag to let Maya know that the points should be added to the existing curve instead of creating a new one</li><li class="listitem" style="list-style-type: disc">We specify a single point using the output of our <code class="literal">curveFunction</code> for the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Y</em></span> coordinates and 0 for the <span class="emphasis"><em>Z</em></span> coordinate</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec74"/>There's more...</h2></div></div></div><p>Although you likely won't have a need for astroid curves in your own projects, there are plenty of situations where you may want to create curves in a step-by-step fashion. For example, you might want to create a curve based on an animation sequence, by adding a point for the position of a given object each frame. We'll see how to grab positions on a frame-by-frame basis when we look at scripting for animation.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec75"/>See also</h2></div></div></div><p>For more information on the astroid curve, have a look at its entry on the Wolfram MathWorld<a id="id139" class="indexterm"/> website, <a class="ulink" href="http://mathworld.wolfram.com/Astroid.html">http://mathworld.wolfram.com/Astroid.html</a>. That's just one of the fun curves that the site explains, along with all sorts of other mathematical resources that you might find useful.</p></div></div>
<div class="section" title="Creating new polygonal faces"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Creating new polygonal faces</h1></div></div></div><p>In this example, we'll be <a id="id140" class="indexterm"/>looking at how to create new polygonal faces with code, both a simple quad and a more complex example that incorporates an internal hole.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec76"/>How to do it...</h2></div></div></div><p>Create a new file, name it <code class="literal">polyCreate.py</code> (or similar), and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import math

def makeFace():

    newFace = cmds.polyCreateFacet(p=[(-1,-1,0),(1,- 1,0),(1,1,0),(-1,1,0)])

def makeFaceWithHole():
    points = []

    # create the inital square
    points.append((-5, -5, 0))
    points.append(( 5, -5, 0))
    points.append(( 5, 5, 0))
    points.append((-5, 5, 0))

    # add empty point to start a hole
    points.append(())

    for i in range(32):
        theta = (math.pi * 2) / 32 * i
        x = math.cos(theta) * 2
        y = math.sin(theta) * 2
        points.append((x, y, 0))

    newFace = cmds.polyCreateFacet(p=points)

makeFace()
makeFaceWithHole()</pre></div><p>If you run the preceding script, you'll see two new objects created, both in the <span class="emphasis"><em>XY</em></span> plane—one is a simple square and the other is a square with a hole in the center.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec77"/>How it works...</h2></div></div></div><p>The <code class="literal">polyCreateFacet</code> command is fairly straightforward and expects to receive an array of point positions. Each point should be stored in a tuple of three values, each one for the <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>, and <span class="emphasis"><em>Z</em></span> position of the vertex.</p><p>In the first <a id="id141" class="indexterm"/>example, we merely call the <code class="literal">polyCreateFacet</code> command directly and provide the four points that make up the corners of a 2-unit square centered at the origin and aligned in the <span class="emphasis"><em>XY</em></span> plane. We have the following code:</p><div class="informalexample"><pre class="programlisting">newFace = cmds.polyCreateFacet(p=[(-1,-1,0),(1,-1,0),(1,1,0),(- 1,1,0)])</pre></div><p>You can also create polygons with internal holes, but in order to do that, you'll need to signal to Maya that you're starting a hole. To do this, you'll need to feed the <code class="literal">polyCreateFacet</code> command a blank point as an empty tuple.</p><p>When creating more complex faces, it can be easier to create an array to hold the various points and push them onto it one at a time, rather than trying to have a single long argument to the <code class="literal">polyCreateFacet</code> command.</p><p>We start, once again, with four points to define a square in the <span class="emphasis"><em>XY</em></span> plane, as follows:</p><div class="informalexample"><pre class="programlisting">points = []

# create the inital square
points.append((-5, -5, 0))
points.append(( 5, -5, 0))
points.append(( 5, 5, 0))
points.append((-5, 5, 0))</pre></div><p>In order to get Maya to start creating a hole in the face we're making, we next add an empty tuple:</p><div class="informalexample"><pre class="programlisting">    points.append(())</pre></div><p>Now we can start adding the points for the hole. In this case, we'll add points to make a circular hole with 32 points. This's done easily enough with a little bit of trigonometry. Because we're making a hole with 32 segments, we divide one full rotation (in radians, so <code class="literal">math.pi * 2</code>) by <code class="literal">32</code> and multiply by our index to get the value we feed to the trigonometric functions.</p><p>Putting that all together give us the following:</p><div class="informalexample"><pre class="programlisting">for i in range(32):
        theta = (math.pi * 2) / 32 * i
        x = math.cos(theta) * 2
        y = math.sin(theta) * 2
        points.append((x, y, 0))</pre></div><p>Then, we'll have an array of 37 tuples representing 36 points plus one blank entry to indicate the start of a cutout region. Passing that into the <code class="literal">polyCreateFacet</code> command gives us the final result. We use the following code:</p><div class="informalexample"><pre class="programlisting">newFace = cmds.polyCreateFacet(p=points)</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec78"/>There's more...</h2></div></div></div><p>When<a id="id142" class="indexterm"/> creating polygonal faces, the order in which the vertices are specified is important. It's likely obvious that adding vertices out of order would cause the resulting faces to be bent in unintended ways, but the order also affects the direction that the face or faces <span class="strong"><strong>normals</strong></span> will point. Always be sure to specify your points around the outer edge of the face that you're creating, and in the counter-clockwise direction, which will cause the normals to point out of the screen.</p><p>If you want the normals to point in the other direction, either specify them in the opposite order or explicitly reverse the normals on the created faces using the <code class="literal">polyNormal</code> command as follows:</p><div class="informalexample"><pre class="programlisting"># with a polygonal object selected
cmds.polyNormal(normalMode=4)</pre></div><p>The <code class="literal">4</code> variable likely seems cryptic, but the <code class="literal">polyNormal</code> command can perform a few different specific functions (including a few deprecated options), and the <code class="literal">normalMode</code> flag is how to tell Maya which one you want. For details, be sure to consult the Python command documentation.</p><p>If you find yourself creating complex faces, such as our second example with the hole, you might want to ensure that you are left with faces of no more than four sides. You can certainly do it by creating the faces one at a time and joining them (which we will do in the custom primitive example, mentioned later), or you can create the shape as a single face, then triangulate it.</p><p>To triangulate the resulting face, run the <code class="literal">polyTriangulate</code> command after creating it, as in the following:</p><div class="informalexample"><pre class="programlisting">cmds.polyCreateFacet(p=myPoints)
cmds.polyTriangulate()</pre></div><p>You can also have Maya attempt to combine the resulting triangles into quads by running the <code class="literal">polyQuad</code> command as follows:</p><div class="informalexample"><pre class="programlisting"># attempt to form quads from a recently-triangulated poly mesh
cmds.polyQuad()</pre></div><p>Quadrangulation doesn't always work, but it also generally doesn't hurt anything. Leaving <span class="strong"><strong>ngons</strong></span> in <a id="id143" class="indexterm"/>your meshes, on the other hand, can lead to all sorts of problems down the road and is best avoided.</p></div></div>
<div class="section" title="Creating new modifiers (noise)"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Creating new modifiers (noise)</h1></div></div></div><p>Many 3D <a id="id144" class="indexterm"/>modeling and animation packages provide a way to add a bit of random noise to the vertices of an object, but Maya does not. This may seem like an oversight, but it also provides us with a great example project.</p><p>In this example, we'll write a script to step through all of the vertices of a polygonal object and move each of them slightly. Here's an example of what a simple polygonal sphere looks like both before and after applying the script that we'll be developing:</p><div class="mediaobject"><img src="graphics/4657_03_02.jpg" alt="Creating new modifiers (noise)"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec79"/>How to do it...</h2></div></div></div><p>Create a new script, name it <code class="literal">addNoise.py</code>, and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import random

def addNoise(amt):

    selectedObjs = cmds.ls(selection=True)
    obj = selectedObjs[-1]

    shapeNode = cmds.listRelatives(obj, shapes=True)

    if (cmds.nodeType(shapeNode) != 'mesh'):
        cmds.error('Select a mesh')
        return

    numVerts = cmds.polyEvaluate(obj, vertex=True)

    randAmt = [0, 0, 0]
    for i in range(0, numVerts):

        for j in range(0, 3):
            randAmt[j] = random.random() * (amt*2) - amt

        vertexStr = "{0}.vtx[{1}]".format(obj, i)
        cmds.select(vertexStr, replace=True)
        cmds.move(randAmt[0], randAmt[1], randAmt[2], relative=True)

    cmds.select(obj, replace=True)

addNoise(0.2)</pre></div><p>If you run this <a id="id145" class="indexterm"/>code with a polygonal object selected, you'll see that each of the vertices is moved by a small random amount (<code class="literal">0.2</code> units).</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec80"/>How it works...</h2></div></div></div><p>First off, we'll want to make sure that we have a polygonal object selected by:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Grabbing the currently selected objects</li><li class="listitem" style="list-style-type: disc">Determining the shape node (if any) attached to the most recently selected object</li><li class="listitem" style="list-style-type: disc">Testing the shape node to make sure that it's a polygonal object</li></ul></div><p>Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">    selectedObjs = cmds.ls(selection=True)
    obj = selectedObjs[-1]

    shapeNode = cmds.listRelatives(obj, shapes=True)</pre></div><p>Once we've done that, we'll want to loop through each of the vertices of the object, but first we'll need to know how many vertices it contains. So, we use the <code class="literal">polyEvaluate</code> command as follows:</p><div class="informalexample"><pre class="programlisting">numVerts = cmds.polyEvaluate(obj, vertex=True)</pre></div><p>Now we're ready to loop through the vertices and move each one. Because we'll want each axis to be independent, we'll start by creating a variable to hold the offsets for each:</p><div class="informalexample"><pre class="programlisting">randAmt = [0, 0, 0]</pre></div><p>Now we're <a id="id146" class="indexterm"/>ready to loop through the object. For each pass, we'll want to set the <code class="literal">randAmt</code> array to random variables, then apply those to the position of the vertex:</p><div class="informalexample"><pre class="programlisting">        for j in range(0, 3):
            randAmt[j] = random.random() * (amt*2) - amt</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>A note on how we're setting the random amount—we want to make sure that the values produced range between the input value (as the maximum) and its negative equivalent (as the minimum).</p></div></div><p>The <code class="literal">random.random()</code> function will produce a random number between 0 and 1. Multiplying it by doubling the input will give us a value between 0 and (amt * 2), and subtracting the input value will give us the proper range.</p><p>Now we'll actually move the vertices by first selecting the individual vertex and moving it using the <code class="literal">move</code> command:</p><div class="informalexample"><pre class="programlisting">        vertexStr = "{0}.vtx[{1}]".format(obj, i)
        cmds.select(vertexStr, replace=True)
        cmds.move(randAmt[0], randAmt[1], randAmt[2], relative=True)</pre></div><p>Note that Maya does also offer a <code class="literal">polyMoveVertex</code> command, which might seem like a better way to go about tweaking the position of each vertex. While that will absolutely work, it will run much slower due to the additional overhead of creating another <span class="strong"><strong>database availability group</strong></span> (<span class="strong"><strong>DAG</strong></span>) node <a id="id147" class="indexterm"/>for each moved vertex. If you would like to see for yourself, try commenting out the lines that select and move the vertices and adding the following:</p><div class="informalexample"><pre class="programlisting">cmds.polyMoveVertex(vertexStr, t=randAmt)</pre></div><p>Try running this and see how long it takes, then comment out this, re-enable the select and move lines and rerun the script. You'll likely see that the <code class="literal">polyMoveVertex</code> version takes a significantly longer time.</p><p>Once we've run through all of the vertices and moved each one slightly, we'll want to make sure that we finish up by selecting the original object, thereby setting the user up to take further actions on the object. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">cmds.select(obj, replace=True)</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec81"/>There's more...</h2></div></div></div><p>This example would only work on polygonal objects, but it would be easy to extend it to work with NURBS surface or even curves as well. To do this, we would need to do the following two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Test for the type of geometry (<code class="literal">nurbsSurface</code> or <code class="literal">nurbsCurve</code>)</li><li class="listitem" style="list-style-type: disc">Alter the point selection code to reference the appropriate type of point</li></ul></div><p>One further<a id="id148" class="indexterm"/> complication is that CVs of a NURBS surface have to be accessed in a two-dimensional array, rather than the flat array of the polygonal surfaces <code class="literal">vtx</code> list.</p></div></div>
<div class="section" title="Creating novel primitives (tetrahedron)"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Creating novel primitives (tetrahedron)</h1></div></div></div><p>In this example, we'll <a id="id149" class="indexterm"/>be creating a brand new (to Maya) geometric primitive—a tetrahedron. Tetrahedrons are simple in principle, but would require numerous steps to create using Maya's interface. As such, they make a great candidate for scripting.</p><p>We'll be creating a script that will create a tetrahedron of a given edge width as a polygonal mesh.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec82"/>Getting ready</h2></div></div></div><p>Before we start writing code, we'll want to make sure that we have a good grasp on the math behind tetrahedrons. A tetrahedron is the simplest regular polyhedron that consists of four faces, each of which is an equilateral triangle.</p><p>Each tetrahedron consists of only four points. For convenience, we'll name the three around the base <span class="strong"><strong>A</strong></span>, <span class="strong"><strong>B</strong></span>, and <span class="strong"><strong>C</strong></span>, and the point at the tip <span class="strong"><strong>D</strong></span>, as in the following illustration:</p><div class="mediaobject"><img src="graphics/4657_03_03.jpg" alt="Getting ready"/></div><p>To make <a id="id150" class="indexterm"/>the math easier, we'll set point <span class="strong"><strong>A</strong></span> to the origin ([0,0,0]). Because every side of the base is of the same length, we can find point <span class="strong"><strong>B</strong></span> by simply moving along the <span class="emphasis"><em>x</em></span> axis by the desired edge length, giving us [length, 0, 0] for <span class="strong"><strong>B</strong></span>.</p><p>Point <span class="strong"><strong>C</strong></span> is only slightly more involved. First, we note that every equilateral triangle can be split into two similar right triangles as follows:</p><p>Finding the <span class="emphasis"><em>X</em></span> coordinate of point <span class="strong"><strong>C</strong></span> is easy; all we have to do is halve the edge length. The <span class="emphasis"><em>Z</em></span> coordinate is in turn equal to the height of each of the half triangles in the previously mentioned illustration, which we don't yet know. However, we <span class="emphasis"><em>do</em></span> know the length of the other two sides, that is, the shorter side is half of our edge length, and the hypotenuse is just the full edge length itself.</p><p>Therefore, by the Pythagorean theorem, we know that:</p><div class="mediaobject"><img src="graphics/4657_03_07.jpg" alt="Getting ready"/></div><p>Or, rewriting it a bit, we have the following:</p><div class="mediaobject"><img src="graphics/4657_03_08.jpg" alt="Getting ready"/></div><p>Finally, we'll <a id="id151" class="indexterm"/>need the coordinates of the tip of the tetrahedron. We'll get those in a way similar to how we arrived at the coordinates for <span class="strong"><strong>C</strong></span>, in that we'll use another right triangle, but this one will be slightly different; it will be the triangle formed by point <span class="strong"><strong>A</strong></span>, point <span class="strong"><strong>D</strong></span>, and the point in the center of the base (which we'll call point <span class="strong"><strong>E</strong></span>).</p><div class="mediaobject"><img src="graphics/4657_03_04.jpg" alt="Getting ready"/></div><p>First, let's find point <span class="strong"><strong>E</strong></span>. Because it's the center of the base, we can just average the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> coordinates of <span class="strong"><strong>A</strong></span>, <span class="strong"><strong>B</strong></span>, and <span class="strong"><strong>C</strong></span>, and we'll have <span class="strong"><strong>E</strong></span>'s location. Then, we can construct a triangle that will allow us to determine the vertical position of point <span class="strong"><strong>D</strong></span>.</p><div class="mediaobject"><img src="graphics/4657_03_05.jpg" alt="Getting ready"/></div><p>Point <span class="strong"><strong>D</strong></span> will <a id="id152" class="indexterm"/>have the same <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> coordinates as <span class="strong"><strong>E</strong></span>, but needs to be raised by the proper amount along the <span class="emphasis"><em>y</em></span> axis to create a proper tetrahedron. To find that distance, we'll use the triangle formed by <span class="strong"><strong>A</strong></span>, <span class="strong"><strong>E</strong></span>, and <span class="strong"><strong>D</strong></span>. The hypotenuse is, once again, a full side of the tetrahedron, so that's easy. The shorter base (<span class="strong"><strong>A</strong></span>-<span class="strong"><strong>E</strong></span>) is the distance from <span class="strong"><strong>A</strong></span> to the center of the base. To find that, we can use the distance formula, making the calculation simpler by choosing point <span class="strong"><strong>A</strong></span> as the origin.</p><div class="mediaobject"><img src="graphics/4657_03_09.jpg" alt="Getting ready"/></div><p>Because both the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> coordinates of point <span class="strong"><strong>A</strong></span> are zero, we get the following:</p><div class="mediaobject"><img src="graphics/4657_03_10.jpg" alt="Getting ready"/></div><p>Once we've done that, we know the lengths of two of the sides of the triangle, and we can calculate the third by using the Pythagorean theorem once again, as follows:</p><div class="mediaobject"><img src="graphics/4657_03_11.jpg" alt="Getting ready"/></div><p>Now that we <a id="id153" class="indexterm"/>have a good handle on how to create a tetrahedron, we're ready to actually write the script.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec83"/>How to do it...</h2></div></div></div><p>Create a new script and name it <code class="literal">makeTetrahedron.py</code>. Add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import math

def makeTetra(size):

    pointA = [0, 0, 0]
    pointB = [size, 0, 0]

    pointC = [size/2.0, 0, 0]
    # set the Z position for C
    pointC[2] = math.sqrt((size*size) - (size/2.0 * size/2.0))

    pointE = [0,0,0]
    # average the A, B, and C to get E
    # first add all the values
    for i in range(0,3):
        pointE[i] += pointA[i]
        pointE[i] += pointB[i]
        pointE[i] += pointC[i]
    # now divide by 3
    for i in range(0,3):
        pointE[i] = pointE[i] / 3.0

    # start point D with the X and Z coordinates of point E
    pointD = [0,0,0]
    pointD[0] = pointE[0]
    pointD[2] = pointE[2]

    distanceAE = math.sqrt((pointE[0] * pointE[0]) + (pointE[2] * pointE[2]))

    # set the Y coordinate of point D
    pointD[1] = math.sqrt((size * size) - (distanceAE * distanceAE))

    faces = []
    faces.append(cmds.polyCreateFacet(p=[pointA, pointB, pointC], texture=1))
    faces.append(cmds.polyCreateFacet(p=[pointA, pointD, pointB], texture=1))
    faces.append(cmds.polyCreateFacet(p=[pointB, pointD, pointC], texture=1))
    faces.append(cmds.polyCreateFacet(p=[pointC, pointD, pointA], texture=1))

    cmds.select(faces[0], replace=True)
    for i in range(1, len(faces)):
        cmds.select(faces[i], add=True)

    obj = cmds.polyUnite()

    cmds.select(obj[0] + ".vtx[:]")
    cmds.polyMergeVertex(distance=0.0001)

    cmds.select(obj[0])

    cmds.move(-pointE[0], 0, -pointE[2])
    cmds.xform(pivots=(pointE[0], 0, pointE[2]))
    cmds.makeIdentity(apply=True)
    cmds.delete(ch=True)

makeTetra(5)</pre></div><p>Run this code, and<a id="id154" class="indexterm"/> you should end up with a tetrahedron with a side length of 5 units, with the base centered at the origin.</p><div class="mediaobject"><img src="graphics/4657_03_06.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec84"/>How it works...</h2></div></div></div><p>First off, we <a id="id155" class="indexterm"/>calculate all the points that we'll need, as outlined in the preceding <span class="emphasis"><em>Getting ready</em></span> section. Each point is a three-element array of <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>, and <span class="emphasis"><em>Z</em></span> coordinates.</p><p>The first two points are easy:</p><div class="informalexample"><pre class="programlisting">pointA = [0, 0, 0]
pointB = [size, 0, 0]</pre></div><p>
<code class="literal">pointC</code> is a bit more complex and requires us to use the Pythagorean theorem:</p><div class="informalexample"><pre class="programlisting">pointC = [size/2.0, 0, 0]
# set the Z position for C
pointC[2] = math.sqrt((size*size) - (size/2.0 * size/2.0))</pre></div><p>In order to calculate the position for <code class="literal">pointD</code>, we first determine the center of the base, which we'll call <code class="literal">pointE</code>. Use the following code:</p><div class="informalexample"><pre class="programlisting">pointE = [0,0,0]
# average the A, B, and C to get E
# first add all the values
for i in range(0,3):
    pointE[i] += pointA[i]
    pointE[i] += pointB[i]
    pointE[i] += pointC[i]
# now divide by 3
for i in range(0,3):
    pointE[i] = pointE[i] / 3.0</pre></div><p>Finally, we can determine <code class="literal">pointD</code> by setting the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> coordinates to those of <code class="literal">pointE</code> and using the Pythagorean theorem to determine the <span class="emphasis"><em>Y</em></span> coordinate as follows:</p><div class="informalexample"><pre class="programlisting"># start point D with the X and Z coordinates of point E
pointD = [0,0,0]
pointD[0] = pointE[0]
pointD[2] = pointE[2]
distanceAE = math.sqrt((pointE[0] * pointE[0]) + (pointE[2] * pointE[2]))</pre></div><p>Once we've <a id="id156" class="indexterm"/>done that, we can create individual faces with the <code class="literal">polyCreateFacet</code> command. We'll use the <code class="literal">polyCreateFacet</code> command four times, once for each of the tetrahedron's faces. We'll also store the result into an array so that we can select all of the faces for final processing later. We have the following code:</p><div class="informalexample"><pre class="programlisting">faces = []
faces.append(cmds.polyCreateFacet(p=[pointA, pointB, pointC], texture=1))
faces.append(cmds.polyCreateFacet(p=[pointA, pointD, pointB], texture=1))
faces.append(cmds.polyCreateFacet(p=[pointB, pointD, pointC], texture=1))
faces.append(cmds.polyCreateFacet(p=[pointC, pointD, pointA], texture=1))</pre></div><p>At this point, we have all of our geometry created, but we'll want to do a few things to finish off the object, namely:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Combine all the faces into a single object.</li><li class="listitem">Move the object so that the base is centered at the origin.</li><li class="listitem">Set the object's pivot point so that it is also centered at the base.</li><li class="listitem">Freeze the transformations.</li></ol></div><p>First off, let's combine the faces into a single object by selecting them. We start by replacing the current selection by the first face, then adding each of the additional three faces to the selection by using <code class="literal">add=True</code> in our call to <code class="literal">cmds.select()</code>.We have the following code:</p><div class="informalexample"><pre class="programlisting">cmds.select(faces[0], replace=True)
for i in range(1, len(faces)):
    cmds.select(faces[i], add=True)</pre></div><p>Once we have all the faces selected, we can combine them with <code class="literal">polyUnite</code>:</p><div class="informalexample"><pre class="programlisting">obj = cmds.polyUnite()</pre></div><p>It will cause all of the faces to be combined into a single polygonal object, but it's only the start. If we leave things at that, we'll end up with disconnected faces and multiple vertices at each of the tetrahedron's four points. To finish off, we'll want to make sure that vertices that are on top of each other are merged.</p><p>To do this, we'll start by selecting all of the vertices in our model:</p><div class="informalexample"><pre class="programlisting">cmds.select(obj[0] + ".vtx[:]")</pre></div><p>Note that we <a id="id157" class="indexterm"/>use the <code class="literal">vtx</code> list to select vertices, but we leave out both the start and end indices, having just a colon. That's an easy shorthand way to refer to the entire contents of a list and will cause all of the vertices in our model to be selected. Once we've done it, we tell Maya to merge nearby vertices with the <code class="literal">polyMergeVertex</code> command, passing in a small threshold distance.</p><div class="informalexample"><pre class="programlisting">cmds.polyMergeVertex(distance=0.0001)</pre></div><p>This tells Maya that any vertices that are less than 0.0001 units apart should be merged into a single vertex. At this point, we have a proper tetrahedron with four faces and four vertices. Because the rest of the operations we want to perform deal with the object as a whole (rather than its vertices), we switch back to the object mode by reselecting the object.</p><div class="informalexample"><pre class="programlisting">cmds.select(obj[0])</pre></div><p>Now we have a single object, but we want to center it. Luckily, we still have <code class="literal">pointE</code>, which contains the <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> coordinates of the base's center, relative to the origin. So, we'll start by moving the combined object in the negative direction on <span class="emphasis"><em>X</em></span> and <span class="emphasis"><em>Z</em></span> by the same amount:</p><div class="informalexample"><pre class="programlisting">cmds.move(-pointE[0], 0, -pointE[2])</pre></div><p>Now we have the object where we want it, but its pivot point is still located at what used to be the origin (<code class="literal">pointA</code>). To fix it, we'll use the <code class="literal">xform</code> command to move the pivot point, as follows:</p><div class="informalexample"><pre class="programlisting">cmds.xform(pivots=(pointE[0], 0, pointE[2]))</pre></div><p>The <code class="literal">pivots</code> flag will move the object's pivot to the specified location. In this case, we're moving it by the same amount (but in the opposite direction) that we moved the object, resulting in the pivot remaining at the origin, even though the object itself has been moved.</p><p>Finally, we'll finish off by freezing the transformations so that our object starts off with 0,0,0 for its position, and we will delete the construction history.</p><div class="informalexample"><pre class="programlisting">cmds.makeIdentity(apply=True)
cmds.delete(ch=True)</pre></div><p>Then, we're left with a fully-formed tetrahedron, centered at the origin and with a clean construction history and ready for further use.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec85"/>There's more...</h2></div></div></div><p>A tetrahedron is a fairly simple object, but all of the principles we used to create it can easily be extended <a id="id158" class="indexterm"/>to more complex shapes with more inputs.</p></div></div></body></html>