<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Arduino and the Internet of Things</h1></div></div></div><p>In the previous chapter, we learned how to access Arduino using Ethernet from a remote location. The main objective was to get you started with developing Arduino-based network applications using Python. We were able to accomplish this using various tools such as the <code class="literal">web.py</code> Python library, Mosquitto MQTT broker, and the Arduino Ethernet library. Remote access to sensor data via a Python-like extensible language can open up limitless possibilities for sensor-based web applications. In recent years, the rapid growth of these applications has enabled the development of a domain called the <strong>Internet of Things</strong> (<strong>IoT</strong>).</p><p>In the last chapter, we worked <a id="id866" class="indexterm"/>on Arduino networking. However, it was limited to LAN and the premise of the exercises was limited to your home or office. We didn't even involve the Internet to enable global access in our exercises. Traditional IoT applications require Arduino to be accessed remotely from any part of the world via the Internet. In this chapter, we will extend the Arduino networking concepts by interfacing Arduino with cloud-based platforms. We will also develop web applications to access the sensor data from these cloud platforms. Later in the chapter, we will go through the process of setting up your cloud-based messaging platform to serve sensor data. At the end of this chapter, you should be able to design and develop full-stack IoT applications, using Arduino, Python, and the cloud.</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Getting started with the IoT</h1></div></div></div><p>Long before the<a id="id867" class="indexterm"/> Internet, sensor- and actuator-based electronic control systems existed in high-tech automation systems. In those systems, sensors were interfaced to the microcontroller via hard-wired connections. Due to extensibility limitations, the coverage area of these systems was geographically restricted. Examples of these high-tech systems included factory automation, satellite systems, weapon systems, and so on. In most cases, the sensors used in these systems were huge and the microcontrollers were also limited by their low computational capabilities.</p><p>With recent advancements in technology, especially in the semiconductor industry, the physical size of sensors and microcontrollers has significantly reduced. It has also been made possible to manufacture low-cost and highly efficient electronic components, hence today it is relatively inexpensive to develop small and efficient sensor-based hardware products. Arduino and Raspberry Pi are great examples of these achievements. These sensor-and actuator-based hardware systems interface with the physical world that we live in. The sensors measure various elements from the physical environment, while the actuators manipulate the physical environment. These types of hardware-based electronic systems are also known as <a id="id868" class="indexterm"/>
<strong>physical systems</strong>.</p><p>On the other front, advancements in the semiconductor industry also enabled the development of highly efficient computation units, empowering personal computer and networking industries. This movement led to the worldwide network of connected computers called CyberWorld or the Internet. Every day, petabytes of data get generated and transferred across the Internet.</p><p>The domain of IoT stands at the crossroads of these progresses in physical and cyber systems, where ancient hardwired sensor-based systems are ready to get upgraded to more powerful and efficient systems that are also highly connected through the Internet. Due to the large number of sensors involved, these systems generate and send an avalanche of data. The data generated by these sensors has already eclipsed the data generated by humans.</p><p>The IoT has started to become a significant domain in recent years after a large number of consumer IoT products have started entering the market. These products include applications in home automation, health care, activity tracking, smart energy, and so on. One of the major reasons behind the rapid growth of the IoT domain is the introduction of these visible solutions. In a large number of cases, this was made possible due to fast and inexpensive prototyping that was enabled by Arduino and other open source hardware platforms.</p><p>Up to this point in the book, we have learned various methods of interfacing sensors and then <a id="id869" class="indexterm"/>developing applications using these connected sensors. In this chapter, we will learn the last step in the development of a full-stack IoT application—enabling access for your Python-Arduino application through the Internet. Now, let's try to first understand the architecture of the IoT.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec119"/>Architecture of IoT web applications</h2></div></div></div><p>In this book, we have <a id="id870" class="indexterm"/>covered<a id="id871" class="indexterm"/> three major concepts in the first eight chapters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Physical layer</strong>: We <a id="id872" class="indexterm"/>used various sensors and actuators with the Arduino board to deal with the physical environment. The sensors such as the temperature sensor, humidity sensor, and motion sensor were used measured the physical phenomenon, while the actuators such as LEDs were utilized to alter or produce physical elements.</li><li class="listitem" style="list-style-type: disc"><strong>Computation layer</strong>: We <a id="id873" class="indexterm"/>used Arduino sketches and Python programs to convert these physical elements into numerical data. We also utilized these high-level languages to perform various computations such as calculating relative humidity, developing user interfaces, plotting data, and providing web interfaces.</li><li class="listitem" style="list-style-type: disc"><strong>Interfacing layer</strong>: Throughout <a id="id874" class="indexterm"/>the material that we covered, we also utilized various interfacing methods to establish communication between Arduino and Python. For interfacing part of the interfacing layer between the physical and computation layers, we used serial port libraries, established network-based communication using the REST and MQTT protocol, and developed web applications.</li></ul></div><p>As you can see, we have developed applications with tightly-coupled physical, computation, and interfacing layers. In the research domain, these types of applications are also known as <a id="id875" class="indexterm"/>cyber-physical systems. One of the widely used and popular terms for the domain of cyber-physical system is the IoT. Although the cyber-physical domain is thoroughly defined compared to the IoT, the IoT has recently gained more popularity due to the large number of subdomains—industrial Internet, wearable devices, connected devices, smart grid, and so on—that are covered under this umbrella term. In simple terms, an application can qualify as an IoT application if it consists of hardware devices that deal with the physical world and have sufficient computational capabilities with Internet connectivity. Let's try to understand the architecture of the IoT from the material that we have already covered.</p><p>On the physical side, the following figure shows the hardware components that we utilized to deal with the physical environment. The sensors and actuators that interface with the actual physical world can be connected to Arduino using multiple low-level protocols. These <a id="id876" class="indexterm"/>components can be connected using GPIO pins and using the I2C or SPI protocols. The data acquired from these components gets processed on the Arduino board using the code <a id="id877" class="indexterm"/>that is uploaded by the user. Although the Arduino code can be made self-reliant to execute tasks without any external inputs, these inputs from users or other applications are required in advanced applications.</p><div><img src="img/5938OS_09_01.jpg" alt="Architecture of IoT web applications"/></div><p>As part of the communication layer, Arduino can be connected locally to other computers using USB. One can extend the coverage range by utilizing Ethernet, Wi-Fi, or any other radio communication method.</p><p>As illustrated in the following figure, the sensor data is collected using computation units for advance processing. These computation units are powerful enough to host operating systems and programming platforms. In this book, we utilized Python to develop various features at the computation layer. At this level, we performed high-level computation tasks such as developing graphical user interfaces using the <code class="literal">Tkinter</code> library, plotting charts using the <code class="literal">matplotlib</code> library, and developing web applications using the <code class="literal">web.py</code> library.</p><div><img src="img/5938OS_09_02.jpg" alt="Architecture of IoT web applications"/></div><p>In all the <a id="id878" class="indexterm"/>coding <a id="id879" class="indexterm"/>exercises that we performed previously, the physical coverage areas of the projects were limited because of hardwired serial interfaces or local Ethernet network, as displayed in the following figure:</p><div><img src="img/5938OS_09_03.jpg" alt="Architecture of IoT web applications"/></div><p>To develop full-stack IoT applications, we need to remotely access Arduino or host the computation layer on the Internet. In this chapter, we are going to work on this missing link and develop various applications to provide Internet connectivity to the exercises. To perform this operation, we are going to utilize a commercial cloud platform in the first section and develop our customized platform in the later section.</p><p>As the focus of this chapter is going to be on cloud connectivity, we are not going to develop a hardware circuit for each exercise. We will go through the hardware design <a id="id880" class="indexterm"/>exercise <a id="id881" class="indexterm"/>only once and keep using the same hardware for all the programming exercises. Similarly, we will also reuse the <code class="literal">web.py</code> programs that we developed in the previous chapter to focus on code snippets that are associated with Python libraries to develop cloud applications.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec120"/>Hardware design</h2></div></div></div><p>Let's begin by <a id="id882" class="indexterm"/>developing <a id="id883" class="indexterm"/>standard hardware for all the upcoming exercises. We will need the Arduino board that is attached to the Ethernet Shield to use the Ethernet protocol for network connectivity. In terms of components, you will be using simple sensors and actuators that you already used in the previous coding exercises. We will use the PIR motion sensor and the HIH-4030 humidity sensor to provide digital and analog outputs, respectively. We will also have an LED as part of the hardware design and this will be used in coding exercises as an actuator. For more information regarding the properties and detailed explanations of these sensors, you can refer to previous chapters.</p><p>To begin assembly of the hardware components, first attach the Ethernet Shield on top of the Arduino board. Connect the sensors and actuators to the appropriate pins, as displayed in the following figure. Once you have the hardware assembled, you can connect the Ethernet Shield to your home router using the Ethernet cable. You will need to power the board using the USB cable to upload the Arduino code from your computer. In case you want to deploy the Arduino board to a remote location, you will need an external 5V supply to power Arduino.</p><div><img src="img/5938OS_09_04.jpg" alt="Hardware design"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec61"/>The IoT cloud platforms</h1></div></div></div><p>The term <strong>IoT cloud platform</strong> is used for the cloud platforms that provide very specific services, protocol support, and web-based tools for IoT applications. In more informal terms, these cloud IoT platforms can be used to upload your sensor data and access them from anywhere using the Internet. With these basic features, they also provide tools to access, visualize, and process your sensor data on various platforms such as computers and smartphones. Examples of similar IoT cloud platforms include <a id="id884" class="indexterm"/>Xively (<a class="ulink" href="http://www.xively.com">http://www.xively.com</a>), 2lemetry<a id="id885" class="indexterm"/> (<a class="ulink" href="http://www.2lemetry.com">http://www.2lemetry.com</a>), Carriots<a id="id886" class="indexterm"/> (<a class="ulink" href="http://www.carriots.com">http://www.carriots.com</a>), ThingSpeak<a id="id887" class="indexterm"/> (<a class="ulink" href="http://thingspeak.com">http://thingspeak.com</a>), and so on.</p><p>The following <a id="id888" class="indexterm"/>figure <a id="id889" class="indexterm"/>shows the architecture of an IoT system with an Arduino-based sensor system that is sending data to a cloud platform, while a computation unit is accessing the data remotely from the cloud:</p><div><img src="img/5938OS_09_05.jpg" alt="The IoT cloud platforms"/></div><p>Xively, being the oldest and most popular IoT platform, has a large amount of community-based online help that is available for beginners. This is one of the major reasons why we have chosen Xively as our platform of choice for the upcoming exercises. Recently, Xively has changed their policy of creating free developer accounts and a user has to request access to this free account instead of obtaining one freely. In case you want to use another platform other than Xively, we have briefly covered a few similar platforms at the end of this section.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec121"/>Xively – a cloud platform for the IoT</h2></div></div></div><p>Xively is one of the <a id="id890" class="indexterm"/>very first<a id="id891" class="indexterm"/> IoT-specific cloud platforms that was founded in 2007 as Pachube. It went through multiple name changes, as it was called Cosm, but it is currently known as Xively. Xively provides an IoT cloud platform with tools and services to develop connected devices, products, and solutions. As mentioned on its website, Xively is the public cloud that is specifically built for the IoT.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec95"/>Setting up an account on Xively</h3></div></div></div><p>Now, we can go <a id="id892" class="indexterm"/>ahead and set up a new user account for the Xively platform. To set up an account, you need to execute following steps in the given order:</p><div><ol class="orderedlist arabic"><li class="listitem">To begin the sign up process on <a class="ulink" href="http://Xively.com">Xively.com</a>, open <a class="ulink" href="https://xively.com/signup">https://xively.com/signup</a> in a web browser.</li><li class="listitem">On the sign up page, you will be prompted to select the username and the password, as displayed in the following screenshot:<div><img src="img/5938OS_09_06.jpg" alt="Setting up an account on Xively"/></div></li><li class="listitem">On the next page, you will be asked to enter some additional information that includes your full name, organization's name, country, zip code, time zone, and so on. Fill out the form appropriately and click on the <strong>Sign Up</strong> button:<div><img src="img/5938OS_09_07.jpg" alt="Setting up an account on Xively"/></div></li><li class="listitem">Xively <a id="id893" class="indexterm"/>will send an activation e-mail to the e-mail account that you specified in the form. Open the e-mail and click on the activation link. Check your spam folder if you don't see the e-mail in your inbox.</li><li class="listitem">Once you click on the activation link, you will be redirected to the welcome page on Xively's website. We advise you to go through the tutorials provided on the welcome page, as it will help you to get familiar with the Xively platform.</li><li class="listitem">After completing the tutorials, you can come back to the main user screen from the page using the <a class="ulink" href="https://xively.com/login">https://xively.com/login</a> link.<p>If you are not already logged in, you will require your e-mail address as the username and an appropriate password to log into the Xively platform.</p></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec96"/>Working with Xively</h3></div></div></div><p>The Xively platform<a id="id894" class="indexterm"/> lets you create cloud device instances that can be connected to the actual hardware device, app, or service. Perform the following steps in order to work with Xively:</p><div><ol class="orderedlist arabic"><li class="listitem">To begin working with the Xively platform, add a device from the main page, as displayed in the following screenshot:<div><img src="img/5938OS_09_08.jpg" alt="Working with Xively"/></div></li><li class="listitem">Once you click on the <strong>Add Device</strong> button, it will prompt you to the following window where you will be asked to provide the device name, description, and privacy status of the device that you are going to assign. In the form, select a device name that you want your development device to be called, provide a brief description, and select <strong>Private Device</strong> as the privacy status:<div><img src="img/5938OS_09_09.jpg" alt="Working with Xively"/></div></li><li class="listitem">Once you <a id="id895" class="indexterm"/>click the <strong>Add Device</strong> button, Xively will create a device instance with automatically-generated parameters and prompt you to the development workbench environment. On the page of the device that you just added, you can see various identification and security parameters such as <strong>Product ID</strong>, <strong>Serial Number</strong>, <strong>Feed ID</strong>, <strong>Feed URL</strong>, and <strong>API Endpoint</strong>. From among these parameters, you will frequently need the <strong>Feed ID</strong> information for the upcoming exercises:<div><img src="img/5938OS_09_10.jpg" alt="Working with Xively"/></div></li><li class="listitem">A unique and secure API key of the newly created device is also located in the right-hand side bar of the page. This API key is very important and needs to be secured just like your password, as anyone with the API key can access the device.<div><img src="img/5938OS_09_11.jpg" alt="Working with Xively"/></div></li><li class="listitem">Now, to <a id="id896" class="indexterm"/>remotely access this device, open the terminal and use the cURL command to send data to it. In the following command, change the <code class="literal">&lt;Your_Feed_ID&gt;</code> and <code class="literal">&lt;Your_API_key&gt;</code> values with the ones available for your device:<div><pre class="programlisting">
<strong>$ curl --request PUT --data "0,10" --header "X-ApiKey: &lt;Your_API_key" https://api.xively.com/v2/feeds/&lt;Your_Feed_ID&gt;.csv</strong>
</pre></div></li><li class="listitem">As you can see, the previous command sent the value of 10 on channel 0 of your device on Xively. After executing the previous command, you will notice that the Xively workbench is updated with the information that you just sent using cURL:<div><img src="img/5938OS_09_12.jpg" alt="Working with Xively"/></div></li><li class="listitem">Try sending multiple values on channel 0 using the previous command. On the Xively workbench, you will be able to see a plot being generated by these values in real time. Access the plot by clicking on channel 0 in the workbench:<div><img src="img/5938OS_09_13.jpg" alt="Working with Xively"/></div></li></ol></div><p>Using the <a id="id897" class="indexterm"/>method that we used in this example, we can also configure Arduino to send sensor values automatically to the Xively platform. This will enable the storage and visualization of Arduino data on Xively.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec122"/>Alternative IoT platforms</h2></div></div></div><p>In this section, we have provided important links for the ThingSpeak and Carriots platforms. As we are not covering these platforms in detail, these links will help you to find similar examples to interface Arduino and Python with ThingSpeak and Carriots.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec97"/>ThingSpeak</h3></div></div></div><p>The tutorials in<a id="id898" class="indexterm"/> the following links will help you to get familiar with the <a id="id899" class="indexterm"/>ThingSpeak platform if you chose to use it instead of Xively:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>The official website</strong>: <a class="ulink" href="https://thingspeak.com/">https://thingspeak.com/</a></li><li class="listitem" style="list-style-type: disc"><strong>Using Arduino and Ethernet to update a ThingSpeak channel</strong>: <a class="ulink" href="http://community.thingspeak.com/tutorials/arduino/using-an-arduino-ethernet-shield-to-update-a-thingspeak-channel/">http://community.thingspeak.com/tutorials/arduino/using-an-arduino-ethernet-shield-to-update-a-thingspeak-channel/</a></li><li class="listitem" style="list-style-type: disc"><strong>Arduino examples for ThingSpeak</strong>: <a class="ulink" href="https://github.com/iobridge/ThingSpeak-Arduino-Examples">https://github.com/iobridge/ThingSpeak-Arduino-Examples</a></li><li class="listitem" style="list-style-type: disc"><strong>Communicating with ThingSpeak using Python</strong>:<a class="ulink" href="http://www.australianrobotics.com.au/news/how-to-talk-to-thingspeak-with-python-a-memory-cpu-monitor"> http://www.australianrobotics.com.au/news/how-to-talk-to-thingspeak-with-python-a-memory-cpu-monitor</a></li><li class="listitem" style="list-style-type: disc"><strong>Using Arduino and Python to talk to a ThingSpeak channel</strong>: <a class="ulink" href="http://vimeo.com/19064691">http://vimeo.com/19064691</a></li><li class="listitem" style="list-style-type: disc"><strong>Series of ThingSpeak tutorials</strong>: <a class="ulink" href="http://community.thingspeak.com/tutorials/">http://community.thingspeak.com/tutorials/</a></li></ul></div><p>ThingSpeak is an open source platform and you can create your own customized version of ThingSpeak using the files provided. You can obtain these files and the associated guideline from <a class="ulink" href="https://github.com/iobridge/ThingSpeak">https://github.com/iobridge/ThingSpeak</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec98"/>Carriots</h3></div></div></div><p>Carriots also<a id="id900" class="indexterm"/> provides a free, basic <a id="id901" class="indexterm"/>account for developers. If you want to use Carriots as an alternative to Xively, use the tutorials in the following links to get started:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>The official website</strong>: <a class="ulink" href="https://www.carriots.com/">https://www.carriots.com/</a></li><li class="listitem" style="list-style-type: disc"><strong>Setting up an account on Carriots</strong>: <a class="ulink" href="https://learn.adafruit.com/wireless-gardening-arduino-cc3000-wifi-modules/setting-up-your-carriots-account">https://learn.adafruit.com/wireless-gardening-arduino-cc3000-wifi-modules/setting-up-your-carriots-account</a></li><li class="listitem" style="list-style-type: disc"><strong>The Carriots library for Arduino</strong>:<a class="ulink" href="http://github.com/carriots/arduino_library"> https://github.com/carriots/arduino_library</a></li><li class="listitem" style="list-style-type: disc"><strong>A Carriots example for Arduino</strong>: <a class="ulink" href="https://github.com/carriots/arduino_examples">https://github.com/carriots/arduino_examples</a></li><li class="listitem" style="list-style-type: disc"><strong>Connect Carriots to the Python web application</strong>: <a class="ulink" href="http://www.instructables.com/id/Connect-your-Carriots-Device-to-Panics-Status-Boa/">http://www.instructables.com/id/Connect-your-Carriots-Device-to-Panics-Status-Boa/</a></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Developing cloud applications using Python and Xively</h1></div></div></div><p>Now, you have a <a id="id902" class="indexterm"/>basic idea about the available commercial IoT platforms and you can select one according to your comfort level and requirements. It will be very difficult to comprehensively explain every cloud platform with practical examples, as the objective of this chapter is to make you familiar with integrating the cloud platform with Python and Arduino. For this reason, we are going to use Xively as the de facto IoT cloud platform for the rest of the integration exercises.</p><p>Now that you know how to create an account on Xively and work with the Xively platform, it is time to start interfacing real hardware with the Xively platform. In this section, we will go through methods to upload and download data from Xively. We will combine the Arduino hardware that we built with the Python programs to show you basic methods of communicating with Xively.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec123"/>Interfacing Arduino with Xively</h2></div></div></div><p>The first stage to<a id="id903" class="indexterm"/> establish <a id="id904" class="indexterm"/>communication with Xively includes interfacing the Arduino board with the Xively platform via standalone Arduino code. We have already built the necessary hardware using the Arduino Uno, Ethernet Shield, and a few sensors. Let's connect it to your computer using the USB port. You also need to connect the Ethernet Shield to your home router using the Ethernet cable.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec99"/>Uploading Arduino data to Xively</h3></div></div></div><p>The <a id="id905" class="indexterm"/>Arduino IDE has a built-in example that can be used to communicate with the Xively service. This is known as <strong>PachubeClient</strong> (Pachube was Xively's previous name).</p><div><div><h3 class="title"><a id="note51"/>Note</h3><p>It is important to note that the reason behind using this default example is to give you a jump-start in the interfacing exercises. This particular sketch is rather old and may get dropped as a default exercise in the upcoming releases of the Arduino IDE. In that case, you can directly jump to the next exercise or develop your custom sketch to perform the same exercise.</p></div></div><p>Perform the following steps to upload Arduino data to Xively:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the Arduino IDE and then open the <strong>PachubeClient</strong> example by navigating to <strong>File</strong> | <strong>Examples</strong> | <strong>Ethernet</strong> | <strong>PachubeClient</strong>.</li><li class="listitem">To establish communication with Xively, you will need the feed ID and the API key of your Xively device, which you obtained in the last section.</li><li class="listitem">In the opened Arduino sketch, perform the following changes using the obtained feed ID and API key. You can specify any project name for the <code class="literal">USERAGENT</code> parameter:<div><pre class="programlisting">#define APIKEY        "&lt;Your-API-key&gt;"
#define FEEDID         &lt;Your-feed-ID&gt;
#define USERAGENT      "&lt;Your-project-name&gt;"</pre></div></li><li class="listitem">In the Arduino sketch, you will also have to change the MAC address and the IP address of your Ethernet Shield. You should be familiar with obtaining these addresses from the exercise that you performed in the previous chapter. Use these values and modify the following lines of code appropriately:<div><pre class="programlisting">byte mac[] = {0x90, 0xA2, 0xDA, 0x0D, 0x3F, 0x62};
IPAddress ip(10,0,0,75);</pre></div></li><li class="listitem">As the opened Arduino example was created for the Pachube, you need to update the server address to <code class="literal">api.xively.com</code> as specified in the following code snippet. Comment the IP address line as we will not need it anymore and add the <code class="literal">server[]</code> parameter:<div><pre class="programlisting">//IPAddress server(216,52,233,122);
char server[] = "api.xively.com";</pre></div></li><li class="listitem">In the <code class="literal">sendData()</code> function, change <a id="id906" class="indexterm"/>the channel name to <code class="literal">HumidityRaw</code> as we have our HIH-4030 humidity sensor connected to the analog port. We are not performing any relative humidity calculations at this stage and are going to upload just the raw data from the sensor:<div><pre class="programlisting">// here's the actual content of the PUT request:
client.print("HumidityRaw,");
client.println(thisData);</pre></div></li><li class="listitem">Once you have performed these changes, open the <code class="literal">XivelyClientBasic.ino</code> file from the folder containing codes for this chapter. Compare them with your current sketch and compile/upload the sketch to the Arduino board if everything seems satisfactory. Once you have uploaded the code, open the <strong>Serial Monitor</strong> window in the Arduino IDE to observe the following output:<div><img src="img/5938OS_09_14.jpg" alt="Uploading Arduino data to Xively"/></div></li><li class="listitem">If you see an output in the <strong>Serial Monitor</strong> window that is similar to the one displayed in the previous screenshot, your Arduino is successfully connected to Xively and is uploading data on the HumidityRaw channel.</li><li class="listitem">Open your device in Xively's website and you will be able to see an output that is similar to the following screenshot on the web page. This confirms that you <a id="id907" class="indexterm"/>have successfully uploaded data to an IoT cloud platform using your remotely-located Arduino:<div><img src="img/5938OS_09_15.jpg" alt="Uploading Arduino data to Xively"/></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec100"/>Downloading data to Arduino from Xively</h3></div></div></div><p>In the previous coding<a id="id908" class="indexterm"/> exercise, we used a default Arduino example to communicate with Xively. However, Xively also provides a very efficient Arduino library with built-in functions for rapid programming. In the next exercise, we will use an alternative method to communicate with the Xively platform using the <code class="literal">Xively-Arduino</code> library. Although you can use either of these methods, we recommend that you use the <code class="literal">Xively-Arduino</code> library as it is officially maintained by Xively.</p><p>In this exercise, we will download digital values from a channel called LED. Later, we will use these digital values, 0 and 1, to switch an LED that is connected to our Arduino board. As an input to this channel, we will alter the current value of the channel on the Xively platform's website while letting the Arduino download that value and perform the appropriate task.</p><p>Let's begin by importing the <code class="literal">Xively-Arduino</code> library and its dependencies. As you already know how to import libraries in the Arduino IDE, visit <a class="ulink" href="https://github.com/amcewen/HttpClient">https://github.com/amcewen/HttpClient</a> to download and import the <code class="literal">HttpClient</code> library. This is a dependency that is required by the <code class="literal">Xively-Arduino</code> library to function.</p><p>Once you have imported the <code class="literal">HttpClient</code> library, download the <code class="literal">Xively-Arduino</code> library from <a class="ulink" href="https://github.com/xively/xively_arduino">https://github.com/xively/xively_arduino</a> and repeat the import process.</p><p>The <code class="literal">Xively-Arduino</code> library ships with few examples so that you can get started. We will use their example as base code for downloading data for our exercise.</p><div><ol class="orderedlist arabic"><li class="listitem">In the Arduino IDE, navigate to <strong>File</strong> | <strong>Examples</strong> | <strong>Xively_arduino</strong> | <strong>DatastreamDownload</strong> and open the <strong>DatastreamDownload</strong> example. Change the default API key to your own API key that was obtained from the device that you created. As displayed in the following code snippet, you need to also identify your channel name, which is LED in this case:<div><pre class="programlisting">char xivelyKey[] = "&lt;Your-API-key&gt;";
char ledId[] = "LED";</pre></div></li><li class="listitem">The <code class="literal">Xively-Arduino</code> <a id="id909" class="indexterm"/>library requires you to define the <code class="literal">XivelyDatastream</code> variable as an array. You can also specify multiple data streams according to your application:<div><pre class="programlisting">XivelyDatastream datastreams[] = {
  XivelyDatastream(ledId, strlen(ledId), DATASTREAM_FLOAT),
};</pre></div></li><li class="listitem">You also need to declare a variable called <code class="literal">feed</code> using the <code class="literal">XivelyFeed</code> function. As displayed in the following line of code, replace the default feed ID with the appropriate one. In the initialization of the <code class="literal">feed</code> variable, the value <code class="literal">1</code> represents the number of <code class="literal">datastreams</code> in the <code class="literal">XivelyDatastream</code> array:<div><pre class="programlisting">XivelyFeed feed(&lt;Your-feed-ID&gt;, datastreams, 1);</pre></div></li><li class="listitem">In our exercise, we want to periodically retrieve the value of the LED channel and turn the actual LED on or off accordingly. In the following code snippet, we obtain the float value from <code class="literal">feed[0]</code>, where <code class="literal">0</code> specifies the data stream located at the <code class="literal">0</code> position in the <code class="literal">datastreams</code> array:<div><pre class="programlisting">Serial.print("LED value is: ");
Serial.println(feed[0].getFloat());

if (feed[0].getFloat() &gt;= 1){
   digitalWrite(ledPin, HIGH);
}
   else{
   digitalWrite(ledPin, LOW);
}</pre></div></li><li class="listitem">As you now know that the parameters need to be changed for this exercise, open the <code class="literal">XivelyLibBasicRetrieveData.ino</code> Arduino sketch from the code folder. This sketch contains the exact code that you need to use for the exercise. Although this sketch includes the necessary modifications, you will still have to <a id="id910" class="indexterm"/>change the values for account-specific parameters, that is, the API key, feed ID, and so on. Before you go ahead and upload this sketch, go to the Xively platform and create a channel called <code class="literal">LED</code> with <strong>Current Value</strong> as <code class="literal">1</code>, as displayed in the following screenshot:<div><img src="img/5938OS_09_16.jpg" alt="Downloading data to Arduino from Xively"/></div></li><li class="listitem">Now, compile and upload the code to your Arduino.</li><li class="listitem">Once you have uploaded the compiled code to your Arduino, open the <strong>Serial Monitor</strong> window and wait for an output that is similar to the one displayed in following screenshot. You will notice that the LED on the Arduino hardware is turned on:<div><img src="img/5938OS_09_17.jpg" alt="Downloading data to Arduino from Xively"/></div></li><li class="listitem">You can go back to the Xively LED channel and change the <strong>Current Value</strong> field to <code class="literal">0</code>. Within a few seconds, you will notice that the LED on the Arduino hardware is turned off. With this exercise, you have successfully established two-way communication between Arduino and the Xively platform.</li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec101"/>Advanced code to upload and download data using Arduino</h3></div></div></div><p>In the previous<a id="id911" class="indexterm"/> two Arduino exercises, we individually performed the uploading and downloading tasks. In this exercise, we want to create an Arduino program where we can upload data from the connected sensors (the PIR motion sensor and the HIH-4030 humidity sensor) while retrieving the value to control the LED. Open the Arduino sketch, <code class="literal">XivelyLibAdvance.ino</code>, which contains the code that demonstrates both the functionalities. As you can see in the following code snippet, we have defined three separate channels for each component while having independent <code class="literal">XivelyDatastream</code> objects for upload (<code class="literal">datastreaU[]</code>) and download (<code class="literal">datastreamD[]</code>). Similarly, we have also created two different feeds, <code class="literal">feedU</code> and <code class="literal">feedD</code>. The main reason behind delegating the upload and download tasks to different objects is to independently update the value of the LED channel while uploading the data stream for channels, <code class="literal">HumidityRaw</code> and <code class="literal">MotionRaw</code>:</p><div><pre class="programlisting">char ledId[] = "LED";
char humidityId[] = "HumidityRaw";
char pirId[] = "MotionRaw";

int ledPin = 2;
int pirPin = 3;

XivelyDatastream datastreamU[] = {
  XivelyDatastream(humidityId, strlen(humidityId), DATASTREAM_FLOAT),
  XivelyDatastream(pirId, strlen(pirId), DATASTREAM_FLOAT),
};

XivelyDatastream datastreamD[] = {
  XivelyDatastream(ledId, strlen(ledId), DATASTREAM_FLOAT),
};

XivelyFeed feedU(&lt;Your-feed-ID&gt;, datastreamU, 2);
XivelyFeed feedD(&lt;Your-feed-ID&gt;, datastreamD, 1);</pre></div><p>In the <code class="literal">loop()</code> function of the Arduino code, we periodically fetch the current value of the LED channel from <code class="literal">feedD</code> and then perform the LED action:</p><div><pre class="programlisting">int retD = xivelyclient.get(feedD, xivelyKey);
Serial.print("xivelyclient.get returned ");</pre></div><p>In the second stage of the periodic function, we obtain the raw sensor values from the analog and digital pins of the Arduino board and then upload those values using <code class="literal">feedU</code>:</p><div><pre class="programlisting">int humidityValue = analogRead(A0);
datastreamU[0].setFloat(humidityValue);
int pirValue = digitalRead(pirPin);
datastreamU[1].setFloat(pirValue);

int retU = xivelyclient.put(feedU, xivelyKey);
Serial.print("xivelyclient.put returned ");</pre></div><p>Make the <a id="id912" class="indexterm"/>appropriate changes in the code to accommodate feed ID and API key and then upload the sketch to the Arduino board. Once you upload this Arduino sketch to your platform, you should be able to see the following output on the <strong>Serial Monitor</strong> window. You can now disconnect your Arduino from the USB port and connect the external power supply. Now that you have connected your Arduino assembly to your local network using an Ethernet cable, you can place the Arduino assembly at any location in your workplace.</p><div><img src="img/5938OS_09_18.jpg" alt="Advanced code to upload and download data using Arduino"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec124"/>Python – uploading data to Xively</h2></div></div></div><p>Similar to how we<a id="id913" class="indexterm"/> interfaced Arduino to Xively, we will now explore methods to connect the Xively platform via Python and thus complete the loop. In this section, we will focus on different ways of uploading data to Xively using Python. We will start with a basic method of communicating with Xively and extend it further with <code class="literal">web.py</code> to implement the interface using a web application.</p><p>To begin with, let's first install Xively's Python library, <code class="literal">xively-python</code>, on your computer using the following command:</p><div><pre class="programlisting">
<strong>$ sudo pip install xively-python</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec102"/>The basic method for sending data</h3></div></div></div><p>Once again, you<a id="id914" class="indexterm"/> will need the API key and feed ID of your virtual device that you created on the Xively platform. Python, assisted by the <code class="literal">xively-python</code> library, provides very simple methods to establish a communication channel with the Xively platform. From your code folder, open the <code class="literal">uploadBasicXively.py</code> file. As specified in the code, replace the <code class="literal">FEED_ID</code> and <code class="literal">API_KEY</code> variables with the appropriate feed ID and API key:</p><div><pre class="programlisting">FEED_ID = "&lt;Your-feed-ID&gt;"
API_KEY = "&lt;Your-API-key&gt;"</pre></div><p>Using the <code class="literal">XivelyAPIClient</code> method, create an <code class="literal">api</code> instance and create the <code class="literal">feed</code> variable by using the <code class="literal">api.feeds.get()</code> method:</p><div><pre class="programlisting">api = xively.XivelyAPIClient(API_KEY)
feed = api.feeds.get(FEED_ID)</pre></div><p>Just as we did in the Arduino exercises, you will need to create data streams for each channel from the feeds. As specified in the following code snippet, try to get the specified channel from the feed or create one if it is not present on the Xively virtual device. You can also specify tags and other variables while creating a new channel:</p><div><pre class="programlisting">try:
  datastream = feed.datastreams.get("Random")
except HTTPError as e:
  print "HTTPError({0}): {1}".format(e.errno, e.strerror)
  datastream = feed.datastreams.create("Random", tags="python")
  print "Creating 'Random' datastream"</pre></div><p>Once you have opened the data stream for a channel, you can specify the current value using the <code class="literal">datastream.cuurent_value</code> method and update the value, which will upload this value to the specified channel:</p><div><pre class="programlisting">datastream.current_value = randomValue
datastream.at = datetime.datetime.utcnow()
datastream.update()</pre></div><p>Once you have performed the specified modifications to the <code class="literal">uploadBasicXively.py</code> file, execute it using the following command:</p><div><pre class="programlisting">
<strong>$ python uploadBasicXively.py</strong>
</pre></div><p>Open your virtual device on the Xively website to find the <code class="literal">Random</code> channel populated with the data<a id="id915" class="indexterm"/> that you uploaded. It will look similar to the following screenshot:</p><div><img src="img/5938OS_09_19.jpg" alt="The basic method for sending data"/></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec103"/>Uploading data using a web interface based on web.py</h3></div></div></div><p>In the previous<a id="id916" class="indexterm"/> chapter, we worked with the <code class="literal">web.py</code> library while developing templates and web applications. In this exercise, we will utilize one of the programs in which we created the <code class="literal">web.py</code> forms with the Xively code that we developed in the previous exercise. The goal of this exercise is to send data to the LED channel using a web application while observing the LED's behavior on the Arduino hardware.</p><p>You can find the Python program for this exercise in this chapter's folder with the name <code class="literal">uploadWebpyXively.py</code>. As you can see in the code, we are using the <code class="literal">web.py</code> forms to obtain two inputs, <code class="literal">Channel</code> and <code class="literal">Value</code>. We will use these inputs to modify the current value of the LED channel:</p><div><pre class="programlisting">submit_form = form.Form(
        form.Textbox('Channel', description = 'Channel'),
        form.Textbox('Value', description = 'Value'),
        form.Button('submit', type="submit", description='submit')
        )</pre></div><p>The template file, <code class="literal">base.html</code>, is also modified to accommodate minor changes that are required by this exercise. As you can see in the opened Python file, we are using the same <a id="id917" class="indexterm"/>code that we used to interface with Xively in the previous exercise. The only major modification is done to the <code class="literal">datastream.update()</code> method, which is now placed in the <code class="literal">POST()</code> function. This method will be executed when you submit the form. Once you change the API key and feed ID in this file, execute the Python code and open <code class="literal">http://localhost:8080</code> in your web browser. You can see the web application running, as displayed in the following screenshot. Enter the value as displayed in the figure to turn on the LED on the Arduino board. You can change the <strong>Value</strong> parameter to <code class="literal">0</code> to turn off the LED.</p><div><img src="img/5938OS_09_20.jpg" alt="Uploading data using a web interface based on web.py"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec125"/>Python – downloading data from Xively</h2></div></div></div><p>The process of <a id="id918" class="indexterm"/>downloading data from Xively includes requesting the <strong>Current Value</strong> parameter for the specified channel. In the next exercise, we will develop a reference code that will be used in the next downloading exercise. In that exercise, we will develop an advanced web application to retrieve data from a specific Xively channel.</p><p>As we are using functions based on the REST protocol to communicate with Xively, Xively will not simply notify you about any new, available update, instead you will have to request it. At this point, it is important to note that we will have to periodically request data from Xively. However, Xively provides an alternative method called <strong>triggers</strong> to overcome this problem, which is explained later in this section.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec104"/>The basic method for retrieving data from Xively</h3></div></div></div><p>Just like the <a id="id919" class="indexterm"/>uploading exercises, the downloading exercises also require a similar code to instantiate the <code class="literal">XivelyAPIClient()</code> and <code class="literal">api.feeds.get()</code> methods. As we are retrieving the data instead of sending it, we will only use the <code class="literal">feed.datastreams.get()</code> method and avoid the <code class="literal">feed.datastreams.create()</code> method. The download process requires the channel to be already present and this is the main reason why we only have to use the <code class="literal">get()</code> method:</p><div><pre class="programlisting">try:
  datastream = feed.datastreams.get("Random")
except HTTPError as e:
  print "HTTPError({0}): {1}".format(e.errno, e.strerror)
  print "Requested channel doesn't exist"</pre></div><p>Once the <code class="literal">datastream</code> object is initialized, the latest available value from the channel can be obtained using the <code class="literal">datastream.current_value</code> method:</p><div><pre class="programlisting">latestValue = datastream.current_value</pre></div><p>To enable the complete <a id="id920" class="indexterm"/>code to perform this exercise, open the <code class="literal">downloadXivelyBasic.py</code> code and change the values for the feed ID and API key to the appropriate ones. In this exercise, we are working with the <code class="literal">Random</code> channel that we created in the uploading exercise. Before you execute this Python code, you need to execute the <code class="literal">uploadXivelyBasic.py</code> file that will continuously provide random data to the <code class="literal">Random</code> channel. Now, you can execute the <code class="literal">downloadXivelyBasic.py</code> file that will fetch the current value of the <code class="literal">Random</code> channel periodically (with a delay specified by the <code class="literal">sleep()</code> function). As you can see in the following screenshot, we are getting a new value for the <code class="literal">Random</code> channel every 10 seconds:</p><div><img src="img/5938OS_09_21.jpg" alt="The basic method for retrieving data from Xively"/></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec105"/>Retrieving data from the web.py web interface</h3></div></div></div><p>This is an advanced <a id="id921" class="indexterm"/>exercise where we will upload data to one Xively channel after fetching data from another Xively channel, and process it by using the data entered via the web form. As you know, the analog pin on which the HIH-4030 sensor is connected provides you with raw sensor value, whereas the relative humidity depends upon the value of the current temperature. In this exercise, we will develop a web application so that the user can manually enter the temperature value and we will use this to calculate relative humidity from the raw sensor data.</p><p>Before we begin with the details of the code, let's first open the <code class="literal">uploadWebpyXively.py</code> file, change the appropriate parameters, and execute the file. Now, in a web browser, open the <code class="literal">http://localhost:8080</code> location. You will be able to see following web application, asking you to provide it with the current temperature value. Meanwhile, upload the <code class="literal">XivelyLibAdvance.ino</code> sketch to the Arduino board after making the appropriate changes. With this program, Arduino will start sending raw motion and humidity values <a id="id922" class="indexterm"/>to the <code class="literal">MotionRaw</code> and <code class="literal">HumidityRaw</code> channels. In the web application that is running, submit the form with the custom temperature value and you will be able to see the web application load the current relative humidity in percentage units. Internally, when you submitted the form, the web application retrieved the current raw humidity value from the <code class="literal">HumidityRaw</code> channel, executed the <code class="literal">relativeHumidity(data, temperature)</code> function, uploaded the calculated humidity value to a new channel called <code class="literal">Humidity</code>, and then displayed that value in the web application.</p><div><img src="img/5938OS_09_22.jpg" alt="Retrieving data from the web.py web interface"/></div><p>If you open your Xively platform page on a web browser, you will be able to see a newly created <code class="literal">Humidity</code> channel with the current value for relative humidity. You can submit multiple values for temperature in the web application to see the results reflected on the graph of the <code class="literal">Humidity</code> channel, as displayed in the following screenshot. Although this exercise demonstrates a single use case, this web application can be extended in multiple ways to create complex applications.</p><div><img src="img/5938OS_09_23.jpg" alt="Retrieving data from the web.py web interface"/></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec106"/>Triggers – custom notifications from Xively</h3></div></div></div><p>The Xively <a id="id923" class="indexterm"/>platform primarily deploys services based on the REST protocol, which doesn't have a provision<a id="id924" class="indexterm"/> to automatically publish data when it is updated with a new value. In order to overcome this limitation, Xively implements the concept of triggers, which provide additional functionality beyond just publishing data when it is changed. Through this, you can basically create a trigger for any channel to perform the <code class="literal">POST</code> operation on the specified location when conditions that are set for that trigger get satisfied by the incoming data. For example, you can set a trigger on the <code class="literal">Humidity</code> channel to send you a notification when the value of humidity changes, that is, increases above or decrease below a given threshold. You can create a trigger in your Xively platform account by just clicking on the <strong>Add Trigger</strong> button, as displayed in the following screenshot:</p><div><img src="img/5938OS_09_24.jpg" alt="Triggers – custom notifications from Xively"/></div><p>While creating a trigger, you can specify the channel you want to monitor and the condition to trigger a notification on the specified HTTP <code class="literal">POST</code> URL. As shown in the following screenshot, complete<a id="id925" class="indexterm"/> the information for <strong>Channel</strong>, <strong>Condition</strong>, and <strong>HTTP POST URL</strong> before saving the trigger. The major drawback with this approach is that Xively requires an actual URL to send the <code class="literal">POST</code> notification. If your current computer doesn't have a static IP address or a DNS address, the trigger won't be able to send you the notification:</p><div><img src="img/5938OS_09_25.jpg" alt="Triggers – custom notifications from Xively"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec63"/>Your own cloud platform for the IoT</h1></div></div></div><p>In the previous <a id="id926" class="indexterm"/>section, we worked with a commercial IoT platform that also provides restricted, free access to basic functionalities. We also learned various ways to communicate <a id="id927" class="indexterm"/>with Xively that is based on the REST protocol. For any small projects or prototypes, Xively and other similar IoT platforms provide a sufficient solution and are therefore recommended by us. However, the limited free service provided by Xively may not satisfy all of your requirements to develop a full-stack IoT product. The following are a few cases where you may want to configure or develop your own IoT platform:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Develop your own commercial IoT platform</li><li class="listitem" style="list-style-type: disc">Develop custom features that are exclusive to your product</li><li class="listitem" style="list-style-type: disc">Add more control features and communication protocols while also securing your data</li><li class="listitem" style="list-style-type: disc">Require an inexpensive solution for large-scale projects</li></ul></div><p>This section will guide you through the step-by-step process of creating an elementary small-level IoT cloud platform. The goal of the section is to make you familiar with the requirements and the process of creating an IoT platform. To develop a large-scale, diverse, and feature-rich platform such as Xively, you will need a significant amount of knowledge and experience in the domains of cloud and distributed computing. Unfortunately, cloud and distributed computing are out of scope of this book and we will stick with the implementation of the basic features.</p><p>To develop a <a id="id928" class="indexterm"/>cloud platform that is accessible through the Internet, you will at least require a computational unit with Internet connection and a static IP or DNS address. Today, the majority of consumer-oriented <strong>Internet Service Providers</strong> (<strong>ISPs</strong>) do not provide static IPs with their Internet service, making it difficult to host a server at home. However, various companies such as Amazon, Google, and Microsoft, provide free or cost-effective cloud computing services, which make it easier to host your cloud on their platforms. These services are highly scalable and they are equipped with a large amount of features to satisfy the majority of consumer requirements. In the following section, you will be creating your first cloud computing instance on <strong>Amazon Web Services</strong> (<strong>AWS</strong>). Later in this chapter, we will install and configure the appropriate software tools such as Python, Mosquitto broker, and so on, to utilize this Amazon instance as an IoT cloud platform.</p><div><div><h3 class="title"><a id="note52"/>Note</h3><p>The major reason behind developing or configuring a personal cloud platform is to have access to your IoT hardware through the Internet. Due to the lack of a static IP address for your home network, you may not be able to access you prototypes or projects from a remote location. A cloud platform can be used as the de facto computation unit for your network-based projects.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec126"/>Getting familiar with the Amazon AWS platform</h2></div></div></div><p>AWS is a<a id="id929" class="indexterm"/> collection<a id="id930" class="indexterm"/> of various cloud services offered by Amazon, which together make up a cloud computing platform. One of the original and most popular services offered by AWS is its <strong>Elastic Computer Cloud</strong> (<strong>EC2</strong>) service. The <a id="id931" class="indexterm"/>EC2 service lets a user create instances of a virtual machine with different combinations of computation power and operating systems from their large cloud infrastructure. It is also really easy to change the computational properties of these virtual instances at any time, making them highly scalable. When you are trying to create your own IoT platform using EC2, this scalability feature greatly helps you as you can expand or compress the size of your instances according to demand. If you are not familiar with the concept of cloud computing or AWS as a particular product, you can learn more about them<a id="id932" class="indexterm"/> from <a class="ulink" href="http://aws.amazon.com">http://aws.amazon.com</a>.</p><p>The EC2 cloud platform is different from Xively as it provides general-purpose cloud instances, virtual machines, with computation power and storage that can be converted to any feature-specific platform by installing and configuring platform-specific software. It is important to note that you really do not have to be an expert in cloud computing to further advance in this chapter. The upcoming sections provide an intuitive guide to perform basic tasks, such as setting up an account, creating and configuring your virtual machines, and installing software tools to create IoT platforms.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec107"/>Setting up an account on AWS</h3></div></div></div><p>Amazon provides <a id="id933" class="indexterm"/>one year of free access to the basic instance of the cloud-based virtual machine. This instance includes 750 hours of free usage time per month and this is greater than the number of hours in any month, thereby making it free for the entire month. The data storage capacity and bandwidth of the AWS account are sufficient for basic IoT or Arudino projects. To create a free account for a year on Amazon's AWS cloud platform, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <a class="ulink" href="http://aws.amazon.com">http://aws.amazon.com</a> and click on the button that asks you to try AWS for free or some other similar text.</li><li class="listitem">This action will lead you to a <strong>Sign In or Create an AWS Account</strong> page as displayed in the following screenshot. Enter the e-mail address that you want to use for this account when you select the <strong>I am a new user.</strong> option and click on the <strong>Sign in using our secure server</strong> button. If you already have an AWS account and you know how to create an account on Amazon AWS, you can use those credentials and skip to the next section:<div><img src="img/5938OS_09_26.jpg" alt="Setting up an account on AWS"/></div><div><div><h3 class="title"><a id="note53"/>Note</h3><p>Amazon only allows one free instance for each account. If you are an existing AWS user and your free instance is already occupied with another application, you can use the same instance to accommodate the MQTT broker or buy another instance.</p></div></div></li><li class="listitem">On the next <a id="id934" class="indexterm"/>page, you will be prompted to enter your name, e-mail address, and a password, as displayed in the following screenshot. Fill in the information to continue with the sign up process:<div><img src="img/5938OS_09_27.jpg" alt="Setting up an account on AWS"/></div></li><li class="listitem">You will be asked to enter your credit card information during the sign up process. However, you won't be charged for using the services included in the free account. Your credit card will be only used if you exceed any limitations or buy any additional services.</li><li class="listitem">The next stage includes the verification of your account using your phone number. Follow the instructions that are displayed in the following screenshot to complete the identity verification process:<div><img src="img/5938OS_09_28.jpg" alt="Setting up an account on AWS"/></div></li><li class="listitem">Once you have verified your identity, you will be redirected to the page that lists the available <a id="id935" class="indexterm"/>Amazon AWS plans. Select the appropriate plan that you want to subscribe to and continue. If you are not sure, you can select the <strong>Basic (Free)</strong> plan option, which we recommend for our purpose. The <strong>Amazon Management Console</strong> page will let you select other plans if you want to upgrade the current one.</li><li class="listitem">Launch the Amazon management console.</li></ol></div><p>As you have an Amazon AWS account now, let's create your virtual instance on it.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec108"/>Creating a virtual instance on the AWS EC2 service</h3></div></div></div><p>In order to create a<a id="id936" class="indexterm"/> virtual instance on Amazon's EC2 platform, first log in to AWS using your credentials and open the management console. Next, click on the <strong>EC2</strong> tab and execute the following instructions step by step:</p><div><ol class="orderedlist arabic"><li class="listitem">On the <strong>EC2 Console</strong> page, go to <strong>Create Instance</strong> and click on the <strong>Launch Instance</strong> button. This will open a wizard to create an instance that will guide you through the setup process:<div><img src="img/5938OS_09_29.jpg" alt="Creating a virtual instance on the AWS EC2 service"/></div></li><li class="listitem">On the first page of the wizard, you will be prompted to select an operating system for your virtual instance. Select <strong>Ubuntu Server 14.04 LTS</strong> as displayed in the next screenshot, which is eligible for the free tier. To avoid any charges for using an advanced instance, make sure that the option you select is eligible for the free tier:<div><img src="img/5938OS_09_30.jpg" alt="Creating a virtual instance on the AWS EC2 service"/></div></li><li class="listitem">In next window, you will be prompted with a list of options that have different configurations of computational capacity. From the <strong>General purpose</strong> family, select the <strong>t2.micro</strong> type, which is eligible for the free tier. The computational capabilities provided by the <strong>t2.micro</strong> tier are sufficient for the exercises that we are going to perform in the book and for most of the DIY projects. Make sure that you do not select any other tier unless you are confident of your selection.<div><img src="img/5938OS_09_31.jpg" alt="Creating a virtual instance on the AWS EC2 service"/></div></li><li class="listitem">Once <a id="id937" class="indexterm"/>you have selected the specified tier, click on the <strong>Review and Launch</strong> button to review the final configuration of the instance.</li><li class="listitem">Review the configuration and make sure that you have selected the appropriate options, as mentioned earlier. You can now click on the <strong>Launch</strong> button to proceed further.</li><li class="listitem">This will open a pop-up window that will prompt you to create a new key pair that will be used for authentication in the upcoming steps:<div><img src="img/5938OS_09_32.jpg" alt="Creating a virtual instance on the AWS EC2 service"/></div></li><li class="listitem">As shown in the previous screenshot, select <strong>Create a new key pair</strong> from the first drop-down menu while providing a name for the key pair. Click on the <strong>Download Key Pair</strong> button to download the key. The downloaded key will have the name that you provided in the previous option with the <code class="literal">.pem</code> extension. If you already have an existing key, you can select the appropriate options from the first drop-down menu. You will need this key every time you want to log in to this instance. Save this key in a safe place.</li><li class="listitem">Once again, click on the <strong>Launch Instances</strong> button to finally start the instance. Your virtual instance is launched on AWS now and it is running in the EC2.</li><li class="listitem">Now, click on the <strong>View Instance</strong> button that will take you back to the EC2 console window. You will be able to see your recently created <code class="literal">t2.micro</code> instance in the list.</li><li class="listitem">To find <a id="id938" class="indexterm"/>out more details about your virtual instance, select it from the list. As soon as you select your instance, you will be able to see additional information in the bottom tab. This information includes the public DNS, private DNS, public IP address, and so on.<div><img src="img/5938OS_09_33.jpg" alt="Creating a virtual instance on the AWS EC2 service"/></div></li><li class="listitem">Save this information, as you will need it to log in to your instance.</li></ol></div><p>Now, you have successfully created and turned on a virtual cloud instance using Amazon AWS. However, this instance is running in the Amazon EC2 and you will have to remotely authenticate into this instance to access its resources.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec109"/>Logging into your virtual instance</h3></div></div></div><p>In reality, your <a id="id939" class="indexterm"/>virtual instance is a virtual computer on a cloud with computation resources that are similar to your regular computer. You now need to log in to the running virtual instance to access files, run scripts, and install additional packages. To establish a secure authentication and access procedure, you need to use the <a id="id940" class="indexterm"/>
<strong>Secure Shell</strong> (<strong>SSH</strong>) protocol and there are multiple ways to use SSH from your computer. If you are using Mac OS X or Ubuntu, an SSH client program already exists within your operating system. For Windows, you can download the PuTTY SSH client from <a class="ulink" href="http://www.putty.org/">http://www.putty.org/</a>.</p><p>From the EC2 management window, retrieve the public IP address of your instance. To use the default SSH client in the Linux or Mac environment, open the terminal and navigate to the folder where you have saved your key file with the <code class="literal">.pem</code> extension. In the terminal window, execute the following command to make your key accessible:</p><div><pre class="programlisting">
<strong>$ chmod 400 test.pem</strong>
</pre></div><p>Once you have changed permission for your key file, run the following command to log in to the virtual instance. In the command, you will have to replace <code class="literal">&lt;key-name&gt;</code> with the file name of your key and <code class="literal">&lt;public-IP&gt;</code> with the public IP that you retrieved from the management console:</p><div><pre class="programlisting">
<strong>$ ssh –i &lt;key-name&gt;.pem ubuntu@&lt;public-IP&gt;</strong>
</pre></div><p>Once you <a id="id941" class="indexterm"/>execute this command, you will be asked to continue with the connection process if you are authenticating the instance for the very first time. At the prompt, write <code class="literal">yes</code> and press <em>Enter</em> to continue. On successful authentication, you will be able to see the command prompt of your virtual instance in the same terminal window.</p><p>In case you are using the Windows operating system and are not sure about the status of your SSH client, select your instance in the EC2 window and click on the <strong>Connect</strong> button in the top navigation bar, which is displayed in the following screenshot:</p><div><img src="img/5938OS_09_34.jpg" alt="Logging into your virtual instance"/></div><p>This action will open a pop-up window with a short tutorial that explains the connection process. This tutorial is also linked to the step-by-step authentication guide for PuTTY.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec127"/>Creating an IoT platform on the EC2 instance</h2></div></div></div><p>As you <a id="id942" class="indexterm"/>have successfully set up an Amazon EC2 instance, you have a virtual computer that is running in the cloud and has a static IP address to enable remote access. However, this instance cannot be categorized as an IoT platform, as it only contains a plain operating system (Ubuntu Linux in our case) and lacks the necessary software packages and configurations.</p><p>There are two distinct ways of setting up a custom IoT cloud platform on your virtual instance:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up an open source IoT platform such as ThingSpeak</li><li class="listitem" style="list-style-type: disc">Separately installing and configuring the required software tools</li></ul></div><p>Keep the following points in mind when setting up an open source IoT platform:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ThingSpeak is one of the open source IoT platforms that provides supporting files to create and host your own replica of the ThingSpeak platform.</li><li class="listitem" style="list-style-type: disc">Setting up this platform on your AWS instance is quite simple and you can obtain the necessary files and guidelines to install it via <a class="ulink" href="https://github.com/iobridge/ThingSpeak">https://github.com/iobridge/ThingSpeak</a>.</li><li class="listitem" style="list-style-type: disc">Although this personalized version of the ThingSpeak platform will provide sufficient tools to start developing IoT applications, the functionalities of the platform will be confined to the supplied feature set. To have complete control over customization, you may have to use the next option.</li></ul></div><p>If you want to <a id="id943" class="indexterm"/>separately install and configure the necessary software tools, here's what you need to remember:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This option includes furnishing project-specific software tools such as Python and the Mosquitto broker with the required Python libraries such as <code class="literal">web.py</code> and <code class="literal">paho_mqtt</code>.</li><li class="listitem" style="list-style-type: disc">We have already worked with exercises that implemented applications which were based on the Mosquitto broker and <code class="literal">web.py</code>. This version of the custom IoT cloud platform can reduce the complexity of installing additional open source platform tools and still provide the necessary support to host applications.</li><li class="listitem" style="list-style-type: disc">The Arduino program can directly communicate with this custom platform using REST or MQTT protocols. It can also behave as the remote computation unit to communicate with Xively or other third-party IoT cloud platforms.</li></ul></div><p>In the next section, we will begin the platform deployment process by installing the Mosquitto broker and the necessary packages on your virtual instance. This will be followed by the configuration of the virtual instance to support the MQTT protocol. Once your IoT cloud platform is up and running, you can just run the Python-based Mosquitto code from the last chapter from the instance with minor or no modifications. In future, this IoT platform that contains the Mosquitto broker and the Python project can be extended to accommodate additional features, protocols, and extra security.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec110"/>Installing the necessary packages on AWS</h3></div></div></div><p>Using the SSH protocol <a id="id944" class="indexterm"/>and the key pair, log into your virtual instance. Once you are at the Command Prompt, the first task that you need to perform is to update all the outdated packages in Ubuntu, the operating system of your virtual instance. Successively execute the following commands:</p><div><pre class="programlisting">
<strong>$ sudo apt-get update</strong>
<strong>$ sudo apt-get upgrade</strong>
</pre></div><p>Ubuntu already comes with the latest version of Python. However, you will still need to install Setuptools to install the additional Python packages:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install python-setuptools</strong>
</pre></div><p>Ubuntu's package <a id="id945" class="indexterm"/>repository also hosts Mosquitto and it can be directly installed using the following command. With this command, we will install the Mosquitto broker, Mosquitto client, and all other dependencies together. During the installation, you will be asked to confirm the installation of additional packages. Enter <code class="literal">Yes</code> at the terminal and proceed with the installation:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install mosquitto*</strong>
</pre></div><p>Now you have installed the Mosquitto broker on your virtual instance and you can run it by executing the Mosquitto command. To develop Python-based Mosquitto applications, we need the Python Mosquitto library on our instance. Let's install the library using Setuptools, through the following commands:</p><div><pre class="programlisting">
<strong>$ sudo easy_install pip</strong>
<strong>$ sudo pip install paho_mqtt</strong>
</pre></div><p>In the previous chapter, we developed a web application based on <code class="literal">web.py</code> that utilizes the <code class="literal">paho_mqtt</code> library to support the MQTT protocol. As with the first project, we are going to deploy the same web application on the EC2-based virtual instance to demonstrate your custom IoT cloud platform. As a dependency of this project, you first need the <code class="literal">web.py</code> Python library, which you can install using the following command:</p><div><pre class="programlisting">
<strong>$ sudo pip install web.py</strong>
</pre></div><p>Now you have all the necessary software packages to run the IoT application. To make your web application accessible via the Internet, you need to configure the security of you virtual instance.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec111"/>Configuring the security of the virtual instance</h3></div></div></div><p>First, we will <a id="id946" class="indexterm"/>configure the virtual instance to securely host the Mosquitto broker. Later, we will go through the methods to set up basic security to prevent the abuse of your Mosquitto server by automated bots or spamming attempts.</p><p>To change any parameters on your virtual instance, you will have to use the <strong>Security Groups</strong> tools from the <strong>Network &amp; Security</strong> section of your <strong>AWS Management Console</strong> page. Open the <strong>Security Groups</strong> section, as displayed in the following screenshot:</p><div><img src="img/5938OS_09_35.jpg" alt="Configuring the security of the virtual instance"/></div><p>Each virtual instance <a id="id947" class="indexterm"/>has a default security group that is generated automatically to allow access to your instance through the SSH port 22. This security configuration is responsible for letting you access your virtual instance through the SSH client from your computer. The Mosquitto broker uses the TCP port number <code class="literal">1883</code> to establish communication with publishers and subscriber clients. To allow incoming access from this Mosquitto port, you will have to edit the current inbound rules and add an entry for port <code class="literal">1883</code>:</p><div><img src="img/5938OS_09_36.jpg" alt="Configuring the security of the virtual instance"/></div><p>Once you click on the <strong>Edit</strong> button, the website will open a pop-up window to add new rules and edit the existing rules. Click on the <strong>Add Rule</strong> button to create an additional rule to accommodate the Mosquitto broker:</p><div><img src="img/5938OS_09_37.jpg" alt="Configuring the security of the virtual instance"/></div><p>As displayed <a id="id948" class="indexterm"/>in the following screenshot, enter the TCP port's number as <code class="literal">1883</code> and complete the other information in the form. Once you have completed the form with the given values, save the rules and exit the window:</p><div><img src="img/5938OS_09_38.jpg" alt="Configuring the security of the virtual instance"/></div><p>Now, with this configuration, port <code class="literal">1883</code> is accessible by other devices and enables remote communication with the Mosquitto broker. You can use the same method to add a rule for port <code class="literal">8080</code> to allow access to Python's web applications that were developed using <code class="literal">web.py</code>. In future, you can add any additional ports to allow access to various services. Although it is very easy to change the security rules on your virtual instance, make sure that you refrain from opening excessive ports to avoid any security risk.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec112"/>Testing your cloud platform</h3></div></div></div><p>In this testing section, we<a id="id949" class="indexterm"/> will first perform checks for the Mosquitto broker from your computer and then set up authentication parameters for the Mosquitto broker. Later, we will upload files and folders containing the Python code to our virtual instance using the SSH file transfer protocol.</p><div><div><div><div><h4 class="title"><a id="ch09lvl4sec07"/>Testing the Mosquitto service</h4></div></div></div><p>The first thing that <a id="id950" class="indexterm"/>we are going to check on our IoT platform is the accessibility of the Mosquitto broker. Open the terminal on your computer and execute the following command, after replacing <code class="literal">&lt;Public-IP&gt;</code> with the public IP or public DNS address of your virtual instance:</p><div><pre class="programlisting">
<strong>$ mosquitto_pub -h &lt;Public-IP&gt; -t test -m 3</strong>
</pre></div><p>This command will publish the message value <code class="literal">3</code> for the <code class="literal">test</code> topic for the Mosquitto broker that is specified at the given IP address; in our case, this is the virtual instance. Now, open a separate terminal window and execute the following command to subscribe to the <code class="literal">test</code> topic on our broker:</p><div><pre class="programlisting">
<strong>$ mosquitto_sub -h &lt;Public-IP&gt; -t test</strong>
</pre></div><p>On the execution of this command, you will be able to see the latest value that is published for this topic. Use the <code class="literal">mosquitto_pub</code> command to post multiple messages and you can see the output of these messages in the other terminal window that is running the <code class="literal">mosquitto_sub</code> command.</p></div><div><div><div><div><h4 class="title"><a id="ch09lvl4sec08"/>Configuring and testing basic security</h4></div></div></div><p>As you saw in the <a id="id951" class="indexterm"/>previous <a id="id952" class="indexterm"/>example, the publishing and subscribing commands just used the IP address to send and receive data without using any authentication parameters. This is a major security loophole, as anyone on the Internet can send data to your Mosquitto broker. To avoid unauthorized access to your broker, you have to establish authentication credentials. You can specify these parameters by following these steps in the given order:</p><div><ol class="orderedlist arabic"><li class="listitem">If you have not already logged into your instance through SSH, open a terminal window and log in using SSH. Once you are logged in, navigate to the Mosquitto directory and create a new file called <code class="literal">passwd</code> using the following set of commands. We will use this file to store the usernames and passwords:<div><pre class="programlisting">
<strong>$ cd /etc/mosquitto</strong>
<strong>$ sudo nano passwd</strong>
</pre></div></li><li class="listitem">In the file, enter the username and password information separated by using the colon operator (<code class="literal">:</code>). For testing purposes, we will use the following credentials, which can be changed any time once you are more familiar with the Mosquitto configuration:<div><pre class="programlisting">user:password</pre></div></li><li class="listitem">Press <em>Ctrl</em> + <em>X</em> to save and exit the file from the nano editor. When you are prompted to confirm the save operation, select <strong>Y</strong> and press <em>Enter</em>.</li><li class="listitem">In the same folder, open the Mosquitto configuration file using thenano editor:<div><pre class="programlisting">
<strong>$ sudo nano mosquitto.conf</strong>
</pre></div></li><li class="listitem">In the <a id="id953" class="indexterm"/>opened file, scroll down the text content until you reach the security section. In this section, find the <code class="literal">#allow_anonymous true</code> line of the code and replace it with <code class="literal">allow_anonymous false</code>. Make sure that you have removed the <code class="literal">#</code> symbol. With this operation, we have disabled the anonymous access to the Mosquitto broker and only those clients with proper credentials can access it.</li><li class="listitem">After performing the previous changes, scroll further down in the file, uncomment the line <code class="literal">#password_file</code>, and replace it with this:<div><pre class="programlisting">password_file /etc/mosquitto/passwd</pre></div></li><li class="listitem">Now that you have configured the basic security parameters for your broker, you must restart the Mosquitto service for the changes to take effect. In Ubuntu, Mosquitto is installed as part of the background service and you can restart it using the following command:<div><pre class="programlisting">
<strong>$ sudo service mosquitto restart</strong>
</pre></div></li><li class="listitem">To test these <a id="id954" class="indexterm"/>authentication configurations, open another terminal window in your computer and execute the following command with the public IP address of your instance. If you are able to successfully publish your message without any errors, your Mosquitto broker now has a security configuration:<div><pre class="programlisting">
<strong>$ mosquitto_pub -u user -P password -h &lt;Public-Ip&gt; -t test -m 3</strong>
</pre></div></li><li class="listitem">Also, check your Mosquitto subscriber using the following command:<div><pre class="programlisting">
<strong>$ mosquitto_sub -u user -P password -h &lt;Public-Ip&gt; -t test</strong>
</pre></div></li></ol></div></div><div><div><div><div><h4 class="title"><a id="ch09lvl4sec09"/>Uploading and testing a project on the instance</h4></div></div></div><p>As we discussed<a id="id955" class="indexterm"/> in the previous chapters, you <a id="id956" class="indexterm"/>can always use your computer for development purposes. Once you are ready for deployment, you can utilize this newly configured virtual instance as the deployment unit. You can copy your files from your local computer to the virtual instance using a utility called PuTTY (<a class="ulink" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/putty.html">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/putty.html</a>) or using the SCP (SSH copy) command.</p><p>Now it is time to upload the project files from the final coding exercise of the previous chapter, which implemented the MQTT protocol using Python and the Mosquitto library. As a reminder, the final exercise is located in the folder named <code class="literal">Exercise 4 - MQTT gateway</code> of the previous chapter's code repository. We will be using the SCP utility to upload these files to your virtual instance. Before we use this utility, let's first create a directory on your virtual instance. Log in to your virtual instance and go to the user directory of the virtual instance by using the following command:</p><div><pre class="programlisting">
<strong>$ ssh –i &lt;key-name&gt;.pem ubuntu@&lt;public-ip&gt;</strong>
<strong>$ cd ~</strong>
</pre></div><p>Using the <a id="id957" class="indexterm"/>character tilde (<code class="literal">~</code>) with the <code class="literal">cd</code> command will change the current directory to the home directory, unless you are planning to use any other location on your virtual instance. At this location, create a new empty directory named <code class="literal">project</code> by using following command:</p><div><pre class="programlisting">
<strong>$ mkdir project</strong>
</pre></div><p>Now, on the computer <a id="id958" class="indexterm"/>you are working on (Mac OS X or Linux), open another terminal window and use the following command to copy the entire directory to the remote instance:</p><div><pre class="programlisting">
<strong>$ scp -v -i test.pem -r &lt;project-folder-path&gt; ubuntu@&lt;your-ec2-static-ip&gt;:~/project</strong>
</pre></div><p>Once you have successfully copied the files to this location, you can go back to the terminal that is logged in to your virtual instance and change the directory to <code class="literal">project</code>:</p><div><pre class="programlisting">
<strong>$ cd project</strong>
</pre></div><p>Before running any commands, make sure that you have changed the appropriate IP addresses in the Arduino sketch and the Python programs. You will have to replace the previous IP address with the one of your virtual instance. Now that you have made these changes, you can execute the Python code containing the Mosquitto Gateway and web application to start the program. Open your web browser from the <code class="literal">http://&lt;Public-Ip&gt;:8080</code> location to see you web application running on the custom IoT platform. From now on, you should be able to access this application from any remote location through the Internet.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>Do not forget to change the IP address of the Mosquitto broker in the Arduino sketch and upload the sketch to the Arduino board again. You may not be able to obtain the sensor data if the appropriate IP address changes are not applied.</p></div></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Summary</h1></div></div></div><p>At the end of this chapter, and hence the end of the contextual part of the book, you should be able to develop your own Internet of Things projects. In this chapter, we used a commercial IoT cloud platform to handle your sensor data. We also deployed a cloud instance to host open source IoT tools and created our own version of the customized IoT cloud platform. Certainly, the content that you learned is not sufficient to develop scalable and fully-stacked commercial products, but it is really helpful to get you started with them. In a large number of cases, this material is sufficient to develop DIY projects and product prototypes that will ultimately lead you to the final product. In the next two chapters, we will put the material that we learned to the test and develop two complete IoT hardware projects. We are also going to learn a project development methodology that is specific to hardware-based IoT products, which can be applied to convert your prototypes into real products.</p></div></body></html>