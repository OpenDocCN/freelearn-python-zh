- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions – When Services Are Not Enough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the third communication type in ROS 2: actions.
    To understand actions, you need to have read the previous chapters on nodes, topics,
    and services.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, I want to alert you that this chapter covers more advanced
    material compared to what we encountered previously and what’s to come.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have some level of expertise, this chapter will satisfy you as
    it will give you a full overview of all three ROS 2 communication types. However,
    if you’re just getting started with ROS with zero experience, it might be a bit
    too much for you right now. This is OK, and topics/services are more than enough
    to get started with ROS 2\. You can skip this chapter (which is independent of
    future chapters) for now and continue with parameters and launch files. It might
    be a good idea to come back to it at a later stage after you’ve built more confidence
    by working on ROS 2 projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, you will understand why you need actions and how they
    work by going through an example that we will build step by step. Then, you will
    write the code to make two nodes communicate with each other. We will use the
    code in the **ch6** folder (in this book’s GitHub repository: [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))
    as a starting point. You can find the final code in the **ch7** folder.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to write an action server and client
    and take advantage of all action features, such as feedback and cancel mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Even though topics and services are more than enough to get started, ROS 2 actions
    are important as they help you take your code to the next level and implement
    more complex behaviors in your robotics applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a ROS 2 action?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom action interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an action server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an action client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking advantage of all the action mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional tools to handle actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a ROS 2 action?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand ROS 2 actions, we need to understand why we need them. That’s
    what we will focus on first. After that, I will explain how actions work through
    a real-life example.
  prefs: []
  type: TYPE_NORMAL
- en: You quickly discovered actions in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092)
    by running some existing nodes and command-line tools. The intuition you built
    there will help you better understand the concepts in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive in and see why and when actions could be needed in a ROS 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: Why actions?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve looked at two forms of communication in ROS 2: topics and services.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Topics* are used by nodes to send and receive messages. Publishers will publish
    data on a topic, and subscribers will subscribe to the topic to receive the data.
    Thus, topics are perfect for sending data streams in your application.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Services* are used for client/server interactions between nodes. The client
    sends a request to the server, after which the server executes or computes something
    and returns a response to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: So, that should be all, right? What else could we need?
  prefs: []
  type: TYPE_NORMAL
- en: In its early days, ROS started with only topics and services. However, ROS developers
    quickly realized that something was missing for some robotics applications. Let’s
    see that with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have a mobile robot with two wheels. First, you would create
    a node that’s responsible for controlling the wheels. This node would also be
    able to receive commands, such as **Move to (x, y) coordinates**. Those commands
    would be transformed into a velocity to apply to the wheels. However, you would
    also like to be able to get notified when the robot has finished moving.
  prefs: []
  type: TYPE_NORMAL
- en: With what we know so far, ROS 2 services seem to be a good option. In this server
    node, you could implement a **/move_robot** service that will receive coordinates
    from a client. Once the command is received, the controller starts to move the
    wheels. Then, when the robot has reached its destination, the server returns a
    response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the communication, we must add a service client to another node.
    The client will send a request to the server with the (x,y) coordinates to reach.
    When the server returns the response, we know that the robot has finished moving—either
    successfully by reaching the destination or something prevented it and we get
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Using a service to control a two-wheeled robot](img/B22403_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Using a service to control a two-wheeled robot
  prefs: []
  type: TYPE_NORMAL
- en: What’s wrong with that?
  prefs: []
  type: TYPE_NORMAL
- en: Well, moving a physical part of a robot in space can take some time. It could
    be a fraction of a second in some cases, but also maybe a few seconds, or even
    a few minutes. The point is that the service execution could take a significant
    amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, while the robot is moving, there are a few things you may want
    to do, and those things are missing when using services:'
  prefs: []
  type: TYPE_NORMAL
- en: Since the execution is taking some time, it would be nice to get some feedback
    from the server. With a service, the client has no idea of what’s happening on
    the server side. So, the client is completely blind and needs to wait for the
    response to get some information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you cancel the current execution? That would seem a reasonable feature
    to have. After you start the execution on the server side, the client may want
    to cancel it. For example, let’s say the client node is also monitoring the environment
    with a camera. If an obstacle is detected, the client could ask the server to
    stop the execution. With what we have for now, the client can’t do anything but
    wait for the server to finish the execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the last point for now, although we could find more: how could the server
    correctly handle multiple requests? Let’s say you have two or more clients, each
    one sending a different request. How can you possibly choose between those requests
    on the server? How can the server refuse to execute a request, or choose to replace
    a request with a new one, without finishing the first request? Or, in another
    scenario, how can the server handle multiple requests at the same time? As an
    analogy, when you download files on your computer, the computer isn’t stuck with
    just one file. It can download multiple files at the same time. You can even decide
    to cancel one download while the others are still running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming back to our example, you can see that a simple service is not enough.
    For this use case, we need more functionalities. What we could do is implement
    additional services, such as one to cancel a request. We could also add a new
    topic to publish some feedback about where the robot is during the execution.
  prefs: []
  type: TYPE_NORMAL
- en: There’s good news—you don’t have to do this. All these problems are solved by
    ROS 2 actions. The feedback mechanism, cancel mechanism, and other functionalities
    are also implemented directly in actions.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, services are perfect for client/server communication, but only
    if the action/computation is quick to execute. If the execution could take some
    time, and you want additional features such as feedback or cancellation, then
    actions are what you need.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know why we need actions, it’s time to understand how they work.
  prefs: []
  type: TYPE_NORMAL
- en: How do actions work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use the previous example, this time using a ROS 2 action instead of a
    service. I will show you how actions work at a high level, with the different
    interactions between the client and the server. Later in this chapter, we will
    dive into the code and see the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use two nodes: one containing an **Action** **client**, and the other
    containing an **Action** **server** (this is the one responsible for controlling
    the wheels).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how actions work, let’s follow the execution flow for one action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Execution flow for a ROS 2 action](img/B22403_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Execution flow for a ROS 2 action
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Action client** will start the communication by sending a request to the
    **Action server**. For actions, the *request* is named *goal*. Hence, we won’t
    talk about requests here, but about **goals**. Here, the goal can be a (x, y)
    coordinate to reach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Action server** receives the goal and decides to accept or reject it.
    The client immediately receives this response from the server. If the goal has
    been rejected, then the communication ends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the goal is accepted, the server can start to process it and execute the
    corresponding action. With this example, the **Server node** will make the robot
    move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as the client knows that the goal has been accepted, it will send a
    request to get the **Result** and wait for it (asynchronously, by registering
    a callback). For services, we talk about a *response*. For actions, this will
    be a *result*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the server is done executing the goal (either successfully or not), it
    will send the **Result** to the client. With this example, the result could be
    the final reached (x, y) coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client receives the **Result**, after which communication ends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how an action works, with a minimal set of functionalities. From the
    server side, a goal is received, accepted or rejected, then executed, and the
    result is returned. From the client side, a goal is sent, and if accepted, a request
    is sent and the result is received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, you can add extra functionalities, all of which are optional.
    Here are the additional mechanisms for actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Action with all communication mechanisms](img/B22403_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Action with all communication mechanisms
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Feedback**: The server, while executing the goal, can send some feedback
    to the client. With this example, the feedback could be the current coordinates
    for the robot or even a completion rate. Thus, the client can know what’s happening
    during the goal’s execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel**: After the goal has been accepted by the server and the goal is
    being executed on the server side, the client can decide to cancel that goal.
    To do so, it will send a cancel request that must be approved by the server. If
    the cancel request is accepted, then the server will try to finish the execution.
    So, in this example, it could make the robot stop. In the end, the server will
    still return a result to the client, whether the goal was successful, failed,
    or canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goal status**: This is not so important for you as it’s an internal mechanism
    for actions that you will not use directly in your code (I just added it here
    for completeness). Each goal will get a state machine, with states such as *accepted*,
    *executing*, and others. With each change of state for a goal, the server will
    notify the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, you have seen all possible communication mechanisms that can be implemented
    within actions.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the preceding figure, some communications are represented with
    a red line, while others are presented with a green line. Behind the scenes, actions
    just use topics and services. Even if an action is a ROS 2 communication on its
    own, the underlying code is using the two other communication types. Here, red
    lines represent services, and green lines represent topics.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, within an action, you have three services (send goal, cancel goal, and
    receive result) and two topics (feedback and goal status). The good news is that
    you don’t have to create those topics and services yourself—they are already implemented
    in the action mechanism. All you have to do is use the action client and server
    functionalities from the ROS 2 libraries.
  prefs: []
  type: TYPE_NORMAL
- en: To create an action, you will need to give it a **name** (for example, **move_robot**)
    so that the client knows where to send the goal. You will also need to use an
    **interface (goal,** **result, feedback)**.
  prefs: []
  type: TYPE_NORMAL
- en: One additional thing to note is that there can be only one action server. Just
    as for services, you can’t have two servers using the same name. On the other
    hand, you can have multiple action clients. Each client can also send multiple
    goals; that’s not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping things up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On top of topics and services, you can use actions to make your nodes communicate
    with each other. Now, when should you use topics, services, or actions?
  prefs: []
  type: TYPE_NORMAL
- en: You should use *topics* when you want to send data streams between nodes. With
    topics, there’s no response. For example, this can work for publishing sensor
    data or sending a stream of commands to another node if you don’t need any confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Services* are perfect when you want client/server communication, but also
    if the action to execute is very quick, such as a computation or a simple action,
    such as switching on an LED.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will use *actions* for anything that needs client/server communication
    and may take some time to execute, as well as when you also want to have mechanisms
    such as feedback and cancel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some important points about how actions work:'
  prefs: []
  type: TYPE_NORMAL
- en: An action is defined by a name and an interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of an action follows the same rules as for topics and services. It
    must start with a letter and can be followed by other letters, numbers, underscores,
    tildes, and slashes. Also, as the action is *doing* something, the best practice
    is to start the name with a verb.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interface contains three things: a goal, a result, and feedback. Both the
    client and server must use the same interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action server can only exist once, but you can send multiple goals from one
    or multiple action clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action clients aren’t aware of the node containing the server. They just know
    they have to use the action name and interface to reach the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement an action communication, you will need to do the following at
    the very least:'
  prefs: []
  type: TYPE_NORMAL
- en: Send a goal from the client to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept (or not) the goal and execute it on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the goal is finished, return a result from the server to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some optional features you can add:'
  prefs: []
  type: TYPE_NORMAL
- en: Send some execution feedback from the server to the client while the goal is
    being executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the client to send a cancel request to the server. If accepted, finish
    the goal execution on the server side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To write action servers and clients in your code, you must use the action functionality
    from the **rclpy.action** and **rclcpp_action** libraries.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can start writing some code. If you’re still a bit confused,
    don’t worry—actions are quite complex to grasp initially. They contain lots of
    different mechanisms. Everything will make more sense as we create an action and
    write the client and server code.
  prefs: []
  type: TYPE_NORMAL
- en: Since we can’t test a client without a server, we will, as we did for services,
    start with the server side. To create a server, we need an action interface, so
    that will be our starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom action interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create an action interface, we first need to clearly define what we need
    to achieve with the action. Then, we can add the interface to the **my_robot_interfaces**
    package (in this section, we will continue using the packages we created in the
    previous chapters).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the application and the interface we need
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the application that we will write in this chapter, the action server will
    be responsible for counting until a given number, with a delay between each count,
    so that we can simulate that the action takes some time and doesn’t return immediately.
    The client will have to send a number to the server so that the server can start
    to count. When the server finishes, it will send the result (last reached number)
    back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say the client sends the number 5 to the server, and there’s
    a delay of 0.5 seconds. The server will start to count from 0, up to 5, and wait
    0.5 seconds between each iteration. When finishing, the server will return 5 if
    it could count until the end, or the last reached number if the execution finished
    sooner (the goal was canceled, or any other reason that could make the server
    stop the goal). In addition to that, we will add some feedback about the current
    count while the server is executing the goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write any code, we need to know what interface to use for the action.
    From the previous paragraph, we can see that we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Goal**: An integer for the target number and a float number for the delay'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Result**: An integer for the last reached number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback**: An integer for the current count'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For topics and services, you must first check whether you can find an existing
    interface that matches your needs as there are already a lot of them you can use
    without having to create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: For actions, you could try to do the same, but there aren’t as many existing
    action interfaces. Actions are a bit more complex than the other communication
    types, so you would need to find an interface that matches the goal, result, and
    feedback for your application exactly. The probability of that is very low as
    each action will be quite different. Thus, for actions, we won’t try to find existing
    interfaces and create a custom one directly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new action interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of creating an action interface will be the same as for topic and
    service interfaces. We will follow a similar approach.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create and configure a package dedicated to interfaces. We
    did that in [*Chapter 5*](B22403_05.xhtml#_idTextAnchor211), in the *Creating
    a custom interface for a topic* section, with the **my_robot_interfaces** package.
    You can reuse this package to add your action interfaces. If you don’t have it,
    go back and configure it first, then continue with the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this package, we already have **msg** and **srv** folders for topic and
    service interfaces, respectively. We will add a third folder, named **action**,
    for—as you may have guessed—action interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this new folder, you will place all the action interfaces specific to your
    robot or application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new file for your action. Here are the rules you must follow
    regarding the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: Use UpperCamelCase—for example, `CountUntil`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t write `Action` or `Interface` in the name as this will add unnecessary
    redundancy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `.action` for the file extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a best practice, use a verb in the interface’s name—for example, `NavigateToPosition`,
    `OpenDoor`, `PickObjectFromTable`, or `FetchDrinkFromFridge`. Actions, just like
    services, are about performing an action or computation (which can take some time),
    so by using a verb, you make it very clear what the action is doing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we want to count until a given number, let’s call the interface **CountUntil**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can write the definition for the action in this file. Since we have three
    different parts (goal, result, and feedback), we need to separate them. You must
    add three dashes (**---**) between the goal and the result, and another three
    dashes between the result and the feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you don’t want to send any feedback, or if the result is empty, you
    still have to add the two separations with three dashes (**---**). A very simple
    action definition with nothing in the result and feedback would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the goal, result, and feedback, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in types (`bool`, `byte`, `int64`, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing message interfaces. For example, the goal of the action could contain
    `geometry_msgs/Twist`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can’t include an action or service definition inside an action definition.
    You can only include messages (topic definition) inside the goal, result, or feedback.
    Those three parts can be seen as three independent messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are creating a rather simple application, we will only use built-in
    types here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As for topic and service interfaces, all fields inside the definition must follow
    the **snake_case** convention (use underscores between words, all letters must
    be lowercase, and no spaces).
  prefs: []
  type: TYPE_NORMAL
- en: I’ve also added comments to specify which part is the goal, result, and feedback.
    You don’t need to do this—I only did it for your first action definition so that
    you don’t get confused. Often, people make mistakes regarding the order and put
    the feedback before the result, which can lead to hard-to-debug errors later.
    The order is goal, result, and then feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve written our interface, we need to build it so that we can use
    it in our code. Go back to the **CMakeLists.txt** file of the **my_robot_interfaces**
    package. Since the package has already been configured, we just need to do one
    thing: add the relative path to the interface on a new line inside the **rosidl_generate_interfaces()**
    function. Don’t use any commas between the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, save all files and build the **my_robot_interfaces** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once built, source the environment. You should be able to find your new interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you see the action definition, you know that your action interface has been
    successfully built, and you can now use it in your code. That’s what we will do,
    starting with the action server for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an action server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll write your first action server. In this server, we will
    be able to receive goals. When a goal is received, we will decide whether to accept
    or reject it. If it’s accepted, we will execute the goal. For this application,
    executing the goal means we will start to count from zero to the target number
    and wait for the provided delay between each iteration. Once the goal has been
    executed, we will return a result to the client.
  prefs: []
  type: TYPE_NORMAL
- en: That’s what we will implement in the code, starting with Python and then C++.
    In this section, we start only with the minimum functionalities for the action
    communication to work correctly. We will add the feedback and cancel mechanisms
    later. Since actions are a bit more complex than topics and services, let’s start
    simple and go step by step.
  prefs: []
  type: TYPE_NORMAL
- en: For a better learning experience, make sure you use the GitHub code while following
    along as I will not necessarily display all lines in this chapter, only the important
    ones. The code for this section is located in the **count_until_server_minimal**
    file (with **.py** or **.cpp** appended at the end). We won’t use the **number_publisher**
    and **number_counter** nodes here.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write any code for the server, we need to choose a name and interface
    for our action. Since we want to count until a given number, we will name the
    action **count_until**, and we will use the **CountUntil** interface we’ve just
    created.
  prefs: []
  type: TYPE_NORMAL
- en: We now have everything we need to start writing the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Python action server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to write your action server inside a node. Create a new file named
    **count_until_server_minimal.py** inside the **my_py_pkg** package (along with
    the other Python files). Make this file executable.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the interface and creating the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by setting up the action server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must import a bunch of libraries and classes that we will need in
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Unlike topics and services, the action server is not directly included in the
    **Node** class. So, we need to import the **ActionServer** class from **rclpy.action**.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, you must also import the interface for the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you import an interface from another package, make sure to add the dependency
    to **my_robot_interfaces** in the **package.xml** file of **my_py_pkg** (you should
    have already done this if you’ve been following along):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to the **count_until_server_minimal.py** file, let’s create the
    action server in the node’s constructor (as stated in the introduction to this
    section, I’ll only display the important and relevant snippets; the full constructor
    code is available on GitHub):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an action server with Python, you must use the **ActionServer** class
    we imported previously. Provide the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.create…()`. Here, it’s a bit different: the object (`self`) is provided
    as the first argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CountUntil` interface we’ve imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count_until`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goal callback**: When a goal is received, it will be processed inside this
    callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute callback**: If the goal has been accepted in the goal callback, then
    it will be processed in the execute callback. This is where you will execute the
    action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We specified two callback methods when creating the action server. When the
    node spins, the action server will be in *waiting mode*. As soon as a goal is
    received, the node will trigger the goal callback, and then the execute callback
    if needed. Let’s implement those callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting or rejecting a goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The action server can now receive goals. We need to decide whether to accept
    or reject them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start writing the goal callback, which is the first method to be called
    whenever a goal is received by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this callback, we receive the goal that was sent by the client (it’s of the
    **CountUntil.Goal** type).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'An action interface contains a goal, a result, and feedback. You get one class
    for each message: `CountUntil.Goal`, `CountUntil.Result`, and `CountUntil.Feedback`.
    We will use all three in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to validate the data you receive whenever you write the
    code for a server. For this application, let’s say we want to only accept positive
    target numbers. If the number is negative, we reject the goal.
  prefs: []
  type: TYPE_NORMAL
- en: After validating the data, you need to return either **GoalResponse.ACCEPT**
    or **GoalResponse.REJECT** to accept or reject the goal, respectively. The client
    will be notified immediately of that decision. Then, if the goal is rejected,
    nothing more happens on the server side. If the goal is accepted, the execute
    callback will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s implement the execute callback. Here’s the beginning of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this callback, you get what’s called a goal handle, which is of the **ServerGoalHandle**
    type. I’ve made the argument type explicit so that we can get auto-completion
    with VS Code. This goal handle contains the goal information, but you can also
    use it to set the goal’s final state, which we will see in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you must typically do is extract the data from the goal. Here,
    we get the target number and delay that we will use when executing the action.
    Then, we initialize a few things: the result from the **CountUntil.Result** class,
    and a counter starting at **0**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can start to execute the goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This part of the code will be different every time as it depends entirely on
    your application. Here, we’re incrementing the counter until the target number
    is reached, with a delay between each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The point of using a delay here is just to make this method take more time so
    that we can simulate the behavior of an action. If we wanted to count as fast
    as possible, without any delay, we could have used a service since the action
    would finish almost immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the execution is finished, we need to do two things—set a final state
    for the goal and return a result to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: During the execution of the action, the goal is in the *executing* state. When
    finishing the execution, you need to make it transition into a final state.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, since everything went smoothly and we didn’t expect any problems
    during the execution, we set the goal to *succeeded* by using the **succeed()**
    method on the goal handle. If, for example, your action was responsible for moving
    the wheels of a robot, and if the communication with the wheels is lost during
    the execution, you would stop the action and set the goal to *aborted* with the
    **abort()** method. The last possible state is *canceled*, which we will see a
    bit later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now written the minimal code for the action server to work properly. Before
    we write an action client, let’s switch to C++. If you only want to follow the
    Python explanations, then go ahead and skip the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a C++ action server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code logic for C++ actions is very similar to Python, but there are quite
    a few specificities about the syntax. We will focus mostly on those differences.
    Also, as the code starts to become quite large, I will not necessarily display
    the full code, only the important parts for comprehension. Make sure you take
    a look at this book’s GitHub repository to see the full code.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the interface and creating the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by setting up the action server. First, create a new file named
    **count_until_server_minimal.cpp** in the **src** directory of your **my_cpp_pkg**
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file and start by adding the necessary includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the action library is not a sub-library of **rclcpp**—it’s
    a completely independent one from a different package: **rclcpp_action**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each new package we use, we need to add the dependency to the **package.xml**
    file of the **my_cpp_pkg** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to specify those dependencies in the **CMakeLists.txt**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when you create your executable, don’t forget to add both dependencies
    to the **ament_target_dependencies()** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to the **count_until_server_minimal.cpp** file, we add a few **using**
    lines to simplify the code (you can find those lines at the top of the file, under
    the **#include** lines). After that, you can add an action server to your class
    as a private attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we’re going to use a shared pointer to keep the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the constructor, you can create the action server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For actions, the C++ syntax is stricter than Python. On top of the action interface,
    object to link to, and action name, you have to provide three callbacks (even
    if you don’t want to use them all):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Goal callback**: To accept or reject incoming goals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel callback**: To receive cancel requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute callback**: This is called the *handle accepted callback* in C++,
    but I named it *execute callback* to make the code similar to the Python one.
    In this callback, we execute goals that have been accepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I’ve designed this chapter so that we write minimal code first, and then add
    the extra optional features. However, the C++ `create_server()` method will not
    work if you don’t provide a cancel callback. Thus, what we will do for now is
    add this callback but not fully implement the cancel mechanism; we’ll do that
    later.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to implement the three callback methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The arguments inside the callbacks can be quite long to write. That’s why I
    suggest simplifying the code with **using** lines at the beginning, as well as
    double-checking everything as it’s easy to make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the beginning of the goal callback method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you get a unique identifier for the goal and the goal itself (to be precise,
    this is a **const** shared pointer to the goal). In the callback, we validate
    the goal and then accept or reject it. For example, to accept the goal, you would
    return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The next callback method is the cancel callback, in which you can decide whether
    to accept or reject an incoming cancel request. As I will explain the cancel mechanism
    later in this chapter, I will skip this part now—you just have to write the callback
    so that the code can compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important callback here is the execute callback. In this method, we
    receive a goal handle (**const std::shared_ptr<CountUntilGoalHandle> goal_handle**).
    The first thing we must do is extract the data from the goal and initialize a
    few things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You’ve probably started to get used to seeing shared pointers everywhere, and
    here is no exception. We don’t create a result object, but a shared pointer to
    a result object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to handle the waiting time between each count iteration, we use a **rclcpp::Rate**
    object. This is a bit different from what we did with Python. In this rate object,
    we have to pass the rate—that is, the frequency we want for the loop. For example,
    if the delay is 0.5 seconds, the frequency would be 2.0 Hz. We can now execute
    the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the **sleep()** function of the rate object to pause the execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, once the **for** loop ends, we can finish the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In Python, we would set the goal’s final state first, and then return the result.
    In C++, we don’t return anything (note the **void** return type). We send the
    result at the same time as setting the goal state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Writing C++ code with actions starts to be quite complex, especially if you
    don’t have much C++ experience. If you feel completely lost, maybe either continue
    with Python only or, as mentioned previously, skip this chapter for now and come
    back to it later.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the C++ action server. We can now write the client node and try
    the communication.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an action client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have the minimal code required for the server to receive a goal, accept
    it, execute it, and return a result. At this point, we can write the client side
    of the communication.
  prefs: []
  type: TYPE_NORMAL
- en: The action client will send a goal to the server. It will then register a callback
    to find out whether the goal was accepted or rejected. If the goal is accepted,
    the client will register yet another callback to get the final result. That’s
    what we’re going to implement now—first with Python, then with C++.
  prefs: []
  type: TYPE_NORMAL
- en: Where should you write the action client? In your own ROS 2 applications, you
    could add an action client to any node. As an example, let’s say you have a node
    that monitors the battery level of a mobile robot. This node could already have
    some publishers, subscribers, services, and so on. On top of all that, you can
    add an action client that will send a goal to another node (such as the server
    node, which controls the wheels of the robot) when the battery runs low.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, and to keep things simple, we will create a new node, just
    for the action client. You can then use this code as a template for adding an
    action client anywhere you want. You can find the code for this section in **count_until_client_minimal**
    (**.py** or **.cpp**).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the Python action client.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Python action client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Python file named **count_until_client_minimal.py** in the **my_py_pkg**
    package. Make this file executable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an action client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by setting up the action client. First, add the dependencies we
    will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As for the action server, we don’t get the action client directly from the **Node**
    class. Instead, we have to import **ActionClient** from **rclpy.action**.
  prefs: []
  type: TYPE_NORMAL
- en: We must also import the action interface, which should be the same as for the
    server. If we import this interface, we also need to add a dependency to the **package.xml**
    file. However, we have already done that, so there’s no need to add anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the node’s constructor, we create an action client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the **ActionClient** class directly, and we pass three arguments: the
    object to bind to (**self**), the action interface, and the action name. Double-check
    that the name is the same as on the server side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to send a goal to the server, we add a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the steps for sending a goal from the client to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: You can wait for the server with `wait_for_server()`. If you send a goal when
    the server isn’t up and running, you will get an error, so ensure it’s ready before
    you do anything. I didn’t provide a timeout here, so it will wait indefinitely.
    You could add a timeout and do something similar to what we did in [*Chapter 6*](B22403_06.xhtml#_idTextAnchor282),
    in the *Writing a service* *client* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a goal object from the interface: `Interface.Goal()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the goal fields. Any field you omit will get a default value (`0` for
    numbers, `""` for strings).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the goal with `send_goal_async()`. This will return a Python `Future` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register a callback for the goal’s response so that you know it’s been accepted
    or rejected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that just as for services, we make an asynchronous call with **send_goal_async()**.
    This way, the method will return and we won’t block the execution. If we were
    to block the execution, we would also block the spin, and thus we would never
    get any response.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve sent a goal with the action client and registered a callback,
    **goal_response_callback()**. Let’s implement this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this callback, we get a **ClientGoalHandle** object from the result of the
    Python **Future** object. From this goal handle, we can find out whether the goal
    was accepted or not.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you won’t get the final result in this goal response callback.
    Here, we only get to know whether the server accepted the goal or not. If the
    goal is accepted, we know that the server will start executing it and return a
    result at some point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the client, we can register another callback for the goal result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this callback, we get the goal’s final state and result after the server
    has finished executing the goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do anything you want with this result—here, we simply print it. As
    you can see, we will receive any of those three final states for the goal: **STATUS_SUCCEEDED**,
    **STATUS_ABORTED**, and **STATUS_CANCELED**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s not forget to call the **send_goal()** method. We will do this
    in the **main()** function, just after we initialize the node, and before we make
    the node spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will ask the server to count until **5** and wait **0.5** seconds between
    each count.
  prefs: []
  type: TYPE_NORMAL
- en: Trying the communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now try the communication between the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Create an executable (in **setup.py**) for both the client and server nodes.
    Build the package and source the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, start the server node and the client node in two different Terminals.
    You should see some logs in both Terminals as the communication progresses. In
    the end, you will get something like this for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can see the flow of execution with the timestamp in each log. Here, we tested
    the case when the target number was positive—and thus, the goal was accepted.
    If you want, you can also test the case when the target number is negative; you
    should see the goal being rejected and not executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to write an action client with C++.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a C++ action client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the C++ code, I will focus on the few important points to notice in the
    **count_until_client_minimal.cpp** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have all the includes and **using** lines. Those are almost the same
    as for the C++ action server. However, for the goal handle, we get **ClientGoalHandle**
    (this was **ServerGoalHandle** in the server code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an action client, we declare the client as a private attribute of
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we initialize the client in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see (but that shouldn’t be a surprise anymore), we store a shared
    pointer to the action client. When initializing it, we provide the action interface,
    the object to bind to (**this**), and the action name, which should be the same
    as the one defined in the server code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can create a **sendGoal()** method to send a goal to the
    server. This method follows the same steps as for the Python client. We wait for
    the server, then create a goal, fill in the goal fields, send the goal, and register
    a callback. However, there is a big difference in how we handle the callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In Python, we would chain the callbacks after sending the goal. In C++, you
    first need to create a **SendGoalOptions** object. In this object, you can register
    the different callback methods for your client. Here, we register the response
    and the result callback. Then, you must pass this object to the **async_send_goal()**
    method. This will register all the callbacks for when the node is spinning.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve registered two callbacks, we need to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the goal response callback, to check if the goal was accepted or rejected,
    we can simply write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If this returns **false**, we know the goal was rejected. If it returns **true**,
    there’s no need to do anything else in this callback as the result callback was
    already registered with the **SendGoalOptions** object.
  prefs: []
  type: TYPE_NORMAL
- en: In the result callback, we get the goal’s final state with **result.code**.
    We can then compare it with the different codes in **rclcpp_action::ResultCode**,
    which are **SUCCEEDED**, **ABORTED**, and **CANCELED**. To get access to the actual
    result, we write **result.result**. This will be a shared pointer to the result
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s not forget to call the **sendGoal()** method in the **main()**
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: That’s about it for the C++ action client. After writing both the client and
    server, create an executable for both (in **CMakeLists.txt**); then, build, source,
    and run the two nodes. You can even try running the Python client with the C++
    server, or any other combination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that both the client and server are running correctly, we can add the extra
    functionalities we get with actions: feedback and cancel.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of all the action mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason I’m talking about feedback and cancel mechanisms now and didn’t previously
    is to try not to overwhelm you with too much code at once. I know that actions
    are more complex than everything you’ve seen before with ROS 2\. The minimal code
    alone is already quite long and contains lots of small details you must pay attention
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as explained in the first part of this chapter, the feedback and cancel
    mechanisms are optional. You can create a fully working client/server communication
    without them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re now going to improve the minimal code and add a few more functionalities
    so that we can take full advantage of ROS 2 actions. Here’s what you can do to
    prepare the files for this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a copy of the files containing `_minimal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename those new files by removing the `_minimal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, you can make a copy of **count_until_client_minimal.py** (we won’t
    modify this file anymore) and rename the copy **count_until_client.py** (this
    is where we will add more code). You can find the same organization in this book’s
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s explore the feedback and cancel mechanisms, starting with feedback,
    which is the easiest one.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the feedback mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we wrote the action interface, we had to define three things: goal, result,
    and feedback. So far, we’ve only used the goal and result. The feedback is optional,
    and you could choose to leave it empty in the action definition. In this case,
    there’s nothing else to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve defined feedback in **CountUntil.action** (**int64 current_number**),
    let’s use it in our code so that we can make the server send feedback every time
    it increases the counter. The action client will be able to receive this feedback
    inside a callback.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with the action server. There are just a few lines to add so that
    we can publish the feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **count_until_server.py**. In the **execute_callback()** method, at the
    same time as creating a result object, create a feedback object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you execute the goal, you have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We must fill in the different fields of the feedback object and then send the
    feedback to the client with the **publish_feedback()** method from the goal handle.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to it for the server side. Now, let’s write the code to
    receive the feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **count_until_client.py** file and modify the line where you send
    the goal with **send_goal_async()**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the feedback with a Python action client, you must register a callback
    function when you send the goal. Here’s the implementation for this callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we get a feedback message and can access each field of that message.
    You can do anything you want with this feedback. For example, if your action client
    is asking for a robot to move to certain (x, y) coordinates, you might receive
    feedback on the current progress of the robot. From this, you could take any appropriate
    measure: cancel the goal (see the next section), send a new goal, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it regarding feedback. You can build your package again, source it,
    and run the two nodes. Here’s what you will see on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'It will continue as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With this feedback, the client isn’t in the dark anymore. It can get to know
    what’s happening between sending the goal and receiving the result.
  prefs: []
  type: TYPE_NORMAL
- en: Feedback with C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior for adding the feedback for the action server in **count_until_server.cpp**
    is the same as it is for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must create a feedback object in the execute callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that we use a shared pointer here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you must publish the feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client side, the way a callback is registered is a bit different. Open
    **count_until_client.cpp** and add the following line to the **sendGoal()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For a C++ action, we register all callbacks in the **SendGoalOptions** object
    that we pass to the **async_send_goal()** method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can implement the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we receive both the goal handle and the feedback (as **const** shared
    pointers).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, whenever there’s an argument we don’t use in a function, I write
    `(void)`, followed by the argument. This is a way to prevent getting *unused parameter*
    warnings when compiling with `colcon build`. As a best practice, you should address
    all errors and warnings in your code when developing a ROS 2 application. If you
    don’t do this, you will end up with lots of ignored warnings, and you could miss
    the important ones, leading to hard-to-debug issues in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the code is complete, you can compile the package and run the client
    and server nodes in two different Terminals. You should see a similar output to
    what we had for Python.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the feedback mechanism is relatively easy. Now, let’s learn how
    to cancel a goal. This will be more complex and require the use of more advanced
    ROS 2 concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the cancel mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After sending a goal, the client can decide to ask the server to cancel it.
    The server will receive this request and accept (or not) to cancel the goal. If
    the cancel request is accepted, the server will take any appropriate action to
    cancel the execution of the goal. In the end, the server will still send a result
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: What do we need to do in the code? In the server node, we will add another callback
    so that we can receive cancel requests and decide to accept or reject them. Then,
    in the execute callback, we will be able to check whether the goal should be canceled;
    if so, we will terminate the execution sooner.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we just do this, it’s not going to work and the cancel requests
    will never be received. Why is that? Let’s explore this question now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This section introduces a few concepts that are outside the scope of this (beginner)
    book. I will talk about them briefly without going into full detail. If you’d
    like to understand these in more depth, feel free to explore the advanced concepts
    by yourself (you will find additional resources in [*Chapter 14*](B22403_14.xhtml#_idTextAnchor665)*).*
    You can see this section as a going further with actions section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem with cancel and spin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will only focus on the server side here as this is where the issue will occur.
    I will explain what the issue is so that we can implement the solution later.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when you start the action server, three callbacks will be registered: a
    goal callback, a cancel callback, and an execute callback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our current code, when the server receives a goal, here’s what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The goal is received by the goal callback and is accepted or rejected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If accepted, we execute the goal in the execute callback. Something crucial
    to note is that while we execute the goal with the `for` loop, the thread is blocked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the goal is executed, we return the result and exit from the execute callback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The problem is with *Step 2*. Since we’re blocking the execution, we’re blocking
    the spin mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: When you make a node spin, what’s happening? As mentioned previously, the node
    will be kept alive and all callbacks can be processed. However, the spin is working
    in a single thread. This means that if you have one callback taking 5 seconds
    to execute, it will block the following callbacks for 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: We never had any issues before because all the callbacks we wrote were very
    quick to execute. However, with the execute callback for an action, we’re in a
    situation where the execution could take quite some time, and thus block all the
    other callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: That’s quite the problem. How can you ask to cancel a goal if the cancel request
    is only received after the goal’s execution has finished?
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we have two possible solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The classic programming way**: We could create a new thread in the execute
    callback. The callback can then exit while the goal is processed in the background.
    The spin continues, and thus, other callbacks can be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The ROS 2 way**: We can use a multi-threaded executor, which means that our
    spin mechanism will work not in a single thread, but in multiple threads. Thus,
    if one callback is blocking, you can still execute other callbacks—including the
    cancel callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we want to follow ROS 2 principles to stay consistent with other developers,
    we’re going to follow the ROS 2 way and solve that issue with a multi-threaded
    executor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I’m not going to go into more detail about single and multi-threaded executors
    here. I’m using them now so that we can implement the cancel mechanism correctly.
    Executors can be a great topic to explore after reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for the cancel mechanism in the server code will be the same for
    Python and C++:'
  prefs: []
  type: TYPE_NORMAL
- en: Register a callback to handle cancel requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cancel the goal in the execute callback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the node spin with a multi-threaded executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Canceling with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will start with the server code, which can be found in **count_until_server.py**.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s register a callback to receive cancel requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the callback’s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this callback, you receive a goal handle corresponding to the goal the client
    wants to cancel. You can then create any kind of condition to decide whether the
    goal should be canceled or not. To accept, you must return **CancelResponse.ACCEPT**;
    to reject, you must return **CancelResponse.REJECT**. With this example, I kept
    things simple and we just accepted the cancel request without implementing any
    other checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if the cancel request has been accepted, we need to do something about
    it. In the execute callback, while we’re executing the goal (inside the **for**
    loop), add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When we accept a cancel request, an **is_cancel_requested** flag in the goal
    handle will be set to **True**. Now, in the execute callback, we simply need to
    check this flag.
  prefs: []
  type: TYPE_NORMAL
- en: What we do in the code is stop the current execution. If, for example, your
    action server controls the wheels of a robot, you could interpret **cancel** as
    “decelerate and stop moving,” “step on the side so we don’t block the main way,”
    or even “go back to base.” The way you handle the behavior for the cancellation
    depends on each application. Here, we just stop counting.
  prefs: []
  type: TYPE_NORMAL
- en: In the execute callback, you need to set the goal’s final state and return a
    result, even if you cancel the goal. Thus, we use the **canceled()** method to
    set the state, and we return a result that contains the last reached number. If
    the client asks the server to count to 10 and then cancels the goal when the counter
    is at 7, the result will contain 7.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the cancel mechanism. However, to make things work, as we’ve seen
    previously, we need to use a multi-threaded executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll need to import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When using multi-threaded executors, we also need to use *callback groups*.
    Here, **ReentrantCallbackGroup** will allow all callbacks to be executed in parallel.
    This means that you can have several goal, cancel, and execute callbacks running
    at the same time for one action server.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create the action server, add a **callback_group** argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, modify the line to make the node spin in the **main()** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it. It’s just a few lines of code, but adding this requires
    a good understanding of ROS 2 and its underlying mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the code for the client so that we can send a cancel request for
    a goal that’s being executed. In **count_until_client.py**, add a method to cancel
    a goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’re using the goal handle that we saved in the goal response callback
    (**self.goal_handle_: ClientGoalHandle = future.result()**). From this goal handle
    object, we have access to a **cancel_goal_async()** method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, where do we cancel the goal? This can be done from anywhere: from the feedback
    callback, an independent subscriber callback, and so on. It will depend on your
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: To make a quick test, let’s arbitrarily decide that we want to cancel the goal
    if the **current_number** field from the feedback is greater than or equal to
    2\. It doesn’t make any sense (why would we ask to count until 5, only to cancel
    if the number reaches 2?), but it’s a quick way to test the cancel mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the goal feedback callback, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, build the package, source it, and run both the server and client. Here’s
    the log for the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For the server, you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: With this, we used all the mechanisms available for actions. Now, you can comment
    the lines to cancel the goal from the feedback callback—this was just for testing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling with C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the server code (**count_until_server.cpp**), we added a cancel callback
    when we created the action server. This was mandatory so that the code could compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this callback, we just accept the cancel request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to handle the cancellation of the goal in the execute callback, add the
    following code to the **for** loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In C++, we check the **is_canceling()** method inside the goal handle. If it
    returns **true**, this means that a cancel request for this goal has been accepted,
    and we need to do something about it.
  prefs: []
  type: TYPE_NORMAL
- en: We set the goal’s final state and result with **canceled()**, and we exit from
    the execute callback.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the cancel mechanism, but now we need to make the node spin with
    a multi-threaded executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **main()** function, we must replace the **rclcpp::spin(node);** line
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create an executor, add the node, and make the executor spin. Then,
    as we did for Python, inside the node, we need to add a callback group. We can
    declare one as a private attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we modify the code in the node’s constructor to give a reentrant callback
    group to the action server, so that all callbacks can be executed in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We also need to add **rcl_action_server_get_default_options()** after the callbacks
    and before the callback group; otherwise, the compiler will complain about not
    finding an overload for the **create_server()** function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve finished writing the server code, let’s send a cancel request
    from the client. In **count_until_client.cpp**, add a **cancelGoal()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In C++, we cancel goals from the action client, not from the goal handle. To
    make things simpler here, we’re canceling all goals that could have been sent
    by this client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the cancel mechanism, we add those lines to the feedback callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve completed the code, run your C++ action client and server nodes.
    You can also try any combination of Python and C++ nodes; they should behave the
    same way. Once you’ve tested your code, comment the lines to cancel the goal from
    the feedback callback.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish this chapter with a few more command-line tools that will help
    you when you’re developing applications with actions.
  prefs: []
  type: TYPE_NORMAL
- en: Additional tools to handle actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since actions are part of the core ROS 2 functionalities, they also get their
    own command-line tool: **ros2 action**.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to introspect actions, send a goal from the
    Terminal, and change an action name at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: To see all the possible commands, type **ros2** **action -h**.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and introspecting actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actions are based on topics and services. Since **rqt_graph** doesn’t support
    services (for now), we could see the topics for an action server and client, but
    that’s about it. Thus, **rqt_graph** won’t be very useful for introspecting actions.
    Because of this, we will use the **ros2** command-line tool here.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to find existing actions and how to get the interface for one
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop all nodes and start the **count_until_server** node (Python or C++ one).
    Then, list all available actions by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, we found the **/count_until** action. As we’ve seen with topics and services,
    if you don’t provide any namespace for the name (we wrote **count_until** in the
    server code), a leading slash will be added automatically.
  prefs: []
  type: TYPE_NORMAL
- en: From this action name, we can get more information, including the action interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run **ros2 action info <****action_name> -t**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see that the action server is hosted in the **count_until_server**
    node, and we also find the action interface. For **ros2 action info** to show
    the interface, don’t forget to add **-t**; otherwise, you’ll just see the node’s
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can get the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This process is the same as what we followed for services. Now that we know
    the action name and interface, we can try the service directly from the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a goal from the Terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you write a service server and want to try it before writing the action client,
    you can use the **ros2 action send_goal** command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete command is **ros2 action send_goal <action_name> <action_interface>
    "<goal_in_json>"**. You can also add **--feedback** after the command to receive
    the (optional) feedback from the server. Let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This command is very useful for developing action servers. However, it will
    only work well for actions for which the goal is simple. Here, we only have an
    integer number and a double number. If the goal contains an array of 20 3D points,
    you will spend more time trying to write the command correctly than implementing
    an action client. In this case, to go faster, use the action client we’ve written
    in this chapter as a template.
  prefs: []
  type: TYPE_NORMAL
- en: Topics and services inside actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, with **ros2 topic list** and **ros2 service list**, you won’t see
    the two topics and three services inside the action. However, they do exist—you
    just have to add **--include-hidden-topics** and **--****include-hidden-services**,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: With that, we’ve found all the topics and services that are being used. You
    can explore these a bit more by yourself by using the other **ros2 topic** and
    **ros2 service** command lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there’s one thing we’ve done for nodes, topics, and services: we’ve changed
    the name at runtime. For some reason, this feature isn’t available for actions
    yet. As a workaround, you can still do this by renaming the two topics and three
    services when you start the action server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: With this, the action will be renamed **/count_until1**. The command is a bit
    ugly and prone to errors, but when we start nodes using launch files in [*Chapter
    9*](B22403_09.xhtml#_idTextAnchor443), in the *Configuring nodes inside a launch
    file* section, this won’t be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve come to the end of this chapter. I haven’t added any challenges
    here as I think that this chapter itself is a big enough challenge. I would prefer
    you to spend your time continuing with the other concepts in this book instead
    of being stuck too long on actions, especially if you’re just getting started
    with ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you worked on ROS 2 actions. You created various actions to
    solve a problem that services don’t handle well: when the server may take some
    time to execute the request.'
  prefs: []
  type: TYPE_NORMAL
- en: With actions, you can properly handle this case. While the goal is being executed,
    you can get some feedback from the server, or even decide to cancel the goal.
    Also, you could handle several goals at the same time, queue them, replace one
    with another one, and so on (we haven’t seen this in this chapter as it’s something
    you can look into if you want to develop your skills further).
  prefs: []
  type: TYPE_NORMAL
- en: You can implement action servers and clients in your code using the **rclpy.action**
    library for Python and the **rclcpp_action** library for C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main steps for writing an action server:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re on the server side, we must choose the action name and interface.
    Usually, for an action, you will have to create a custom interface (in a dedicated
    package).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, you must import the interface into your code and create an action server
    in the constructor. Here, you will register three callback methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Goal callback**: When the server receives a goal, choose whether to accept
    or reject it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute callback**: After a goal has been accepted, you can execute it. During
    the execution of the goal, you can also publish optional feedback.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel callback (optional mechanism)**: If you receive a cancel request,
    you can accept or reject it. If accepted, you will have to cancel the current
    goal execution.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To write an action client, you must follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find which name and interface you need to use so that you can communicate with
    the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the interface into your code and create an action client in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a method to send a goal. After you send a goal, you will have to write
    several callbacks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Goal response callback**: You will know whether the goal has been accepted
    or rejected by the server.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goal result callback**: After the goal has been executed by the server, you
    will get the result and the goal’s final state here.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback callback (optional)**: If the server publishes any feedback, you
    can receive it here.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, from anywhere in the code, you can decide to cancel the execution of
    a currently active goal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On top of all that, with the **ros2 action** command line, you can introspect
    your actions and send goals directly from the Terminal. Also, since actions are
    based on topics and services, you can introspect each underlying communication
    with **ros2 topic** and **ros2** **service**, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you managed to get here while reading this book for the first time,
    congratulations—this chapter is probably one of the most difficult to follow.
    If you’re still wondering what I was talking about the whole time, don’t worry—you
    can come back to actions later once you’ve finished this book and become more
    experienced with ROS.
  prefs: []
  type: TYPE_NORMAL
- en: We’re now done with the three types of communication in ROS 2\. In the next
    chapter, we will go back to a more beginner level and continue to work on nodes.
    This time, we will learn how to customize nodes when we start them so that we
    can make our application more dynamic.
  prefs: []
  type: TYPE_NORMAL
