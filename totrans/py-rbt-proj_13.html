<html><head></head><body><div><h1 class="header-title">Making Jarvis IoT Enabled</h1>
                
            
            
                
<p class="mce-root">There was a time when we used to imagine controlling the world with our fingertips. Now, this imagination has become a reality. With the advent of smartphones, we have been doing stuff which one could have only imagined until a decade back. With mobile phones becoming smart, the industry and businesses have also tried their best to keep up with the disruptive change. However, there is one part that is still lagging behind. Which is that part? Your home!</p>
<p class="mce-root">Think about what you can control in your home using your smartphone? Not many things! There are some devices that can turn on or off a bunch of devices such as your AC. However, the list is exhaustive. So, with all the knowledge gained in the previous chapters and the powerful hardware in our hands, why don't we become the trendsetters and the disrupters and make something that is still just a part of our imagination.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Basics of <strong>Internet of Things</strong> (<strong>IoT</strong>)</li>
<li><strong>Message Queuing Telemetry Transport</strong> (<strong>MQTT</strong>) protocol</li>
<li>Setting up MQTT broker</li>
<li>Making an IoT-based intrusion detector</li>
<li>Controlling the home</li>
</ul>


            

            
        
    </div>
<div><h1 class="header-title">Basics of IoT</h1>
                
            
            
                
<p>In this chapter, we will be controlling devices in our home using our smartphones, but before doing this, we should understand the basics of this technology. The first topic of this chapter is IoT—the overused jargon in the modern world. It is something that everyone wants to know about but no one does. IoT can be related to a technology, where your refrigerator will tell you what items are low in supply and will order it automatically for you. Poor thing! This technology has some time to invade our houses. But IoT does not mean this alone. IoT is a very wide term, something which can be applied to almost all the places for optimization. So what is IoT then?</p>
<p>Let's break this acronym, <strong>Internet of Things</strong> sometimes also known as cyber physical systems. Now, what is <strong>Things</strong>? Any electronic object that has the ability to collect or receive data without human intervention can be called a thing here. So this thing can be your mobile, a pacemaker, a health monitoring device, and so on. The only <em>if</em> is that it should be connected to the internet and has the ability to collect and/or receive data. The second term is <strong>Internet</strong>; the internet refers to the internet, Duh! Now, all of these IoT devices send and receive data from a cloud or a central computer. The reason why it does that is because any IoT device, whether big or small, is considered a resource-constrained environment. That is, the resources such as computing power is much less. This is because the IoT devices have to be simple and cheap. Imagine you have to put IoT sensors on all of the street lights to monitor traffic. If the device costs $500, then it would be impractical to install this kind of device. However, if it could be made for $5-$10, then no one would bat an eye. That's the thing with IoT devices; they are extremely cheap. Now the flip side to this story is that they do not have a lot of computing power. Hence, to balance this equation, instead of computing the raw data on their own processors, they simply send this data to a cloud computing device or perhaps a server where this data is computed and the meaningful result is taken. So, this solves all our problems then. Well, no! The second problem with these devices are that they can be battery operated, use-and-throw devices as well. For example, where temperature sensors are installed all across the forests; in such situations, no one and absolutely no one will go and change the batteries every week. Hence, these devices are made in such a way that they consume little to almost no power, thereby making the programming very tricky.</p>
<p>Now that we have understood the IoT concepts, in this chapter, we'll be making our home IoT enabled. This means, we will be able to receive and collect data from the sensors from our home, see it on our mobile devices, and if needed, we can control the devices using your smartphones as well. There is one thing though, instead of computing it on cloud, we will simply be uploading all of our data onto the cloud and just accessing that data or sending our data to the cloud from where it can be accessed. We will be talking about the cloud computing aspect in a different book as this can be a whole new dimension and will be out of the scope of this book.</p>


            

            
        
    </div>
<div><h1 class="header-title">The MQTT protocol</h1>
                
            
            
                
<p>MQTT is an ISO-certified protocol and is in use very widely. The interesting thing about this protocol is that it was developed by Andy Stanford and Arlen Nipper in 1999 for monitoring of an oil pipeline through the desert. As you can imagine, in middle of a desert, the protocol they developed had to be energy efficient and bandwidth efficient as well.</p>
<p>How this protocol works is quite interesting. It has a publish-subscribe architecture. This means, it has a central server, which we also call a broker. Any device can register with this broker and publish any meaningful data onto it. Now, the data that is being published should have a topic, for example, air temperature.</p>
<p>These topics are particularly important. Why, you may ask? To the broker, there can be one or many devices that can be connected. With the connection, they also need to subscribe to a topic. Let's say they are subscribed to the topic <em>Air-</em>Temperature. Now, whenever any new data comes, it gets published to the subscribed devices.</p>
<p>One important thing to know is that there need not be any request to gain the data from the broker like what we have in HTTP. Rather, whenever the data is received, it will be pushed to the device which is subscribed to that topic. It is very obvious that the TCP protocol will also be up and working during the whole time and the port related to the broker will always be connected for seamless data transmission. However, should there be any break in the data, the broker will buffer all the data and send it to the subscriber whenever the connection is resumed.</p>
<div><img src="img/13bec90f-2720-4a6a-b32a-7160d779f889.png"/></div>
<p> </p>
<p>As you can see The motion sensor and the temperature sensors are giving the data to MQTT server by a specific topic namely <strong>Temperature</strong> and <strong>Motion</strong>. Those whose are subscribed to these topics would get the reading from this device. Hence there is no direct communication needed between the actual sensor and the mobile device. </p>
<p>The good thing about this whole architecture is that there can be limitless devices attached with this protocol and there need not be any scalability issues. Also, the protocol is relatively simple and easy to work with even a huge amount of data. Hence, this becomes the preferred protocol for IoT as it provides an easy, scalable, and seamless link between the data producer and the data receivers.</p>


            

            
        
    </div>
<div><h1 class="header-title">Setting up the MQTT broker</h1>
                
            
            
                
<p>Remember the old boring update process of vision processing? How can you forget? We have to do the same here as well. But lucky for us, this time it's not very long. So, let's see what we have to do to set up this server. Open up your command line and type in these following lines:</p>
<pre><strong>sudo apt-get update</strong><br/><strong>sudo apt-get upgrade</strong></pre>
<p>You know what this line does. If you don't have a clear memory of it, then refer to <a href="e8d477b8-8ece-4d9e-b62b-29dca9508f78.xhtml" target="_blank">Chapter 9</a>, <em>Vision Processing</em>. Once the update and upgrade processes are complete, go ahead and install the following packages:</p>
<pre><strong>sudo apt-get install mosquitto -y</strong></pre>
<p>This will install the Mosquitto broker onto your Raspberry Pi. This broker will take care of all the data transfer:</p>
<pre><strong>sudo apt-get install mosquitto-clients -y</strong></pre>
<p>Now, this line will install the client packages. As you can imagine, Raspberry Pi in itself will be a client to the broker. Hence, it will take care of the needful.</p>
<p>We have now installed the packages; yes exactly, it was that small. Now, all we need to do is configure the Mosquitto broker. To do this, you need to type in the following command:</p>
<pre><strong>sudo nano etc/mosquitto/mosquitto.conf</strong></pre>
<p>Now, this command will open the file where the Mosquitto file configuration is saved. To configure it, you need to get to the end of this file, where you will see the following:</p>
<pre><strong>include_dir/etc/mosquitto/conf.d</strong></pre>
<p>Now, you can comment out the the preceding line of code by simply adding <kbd>#</kbd> before the lines. Once done then go ahead and add the following lines:</p>
<pre><strong>allow_anonymous false</strong><br/><br/><strong>password_file /etc/mosquitto/pwfile</strong><br/><br/><strong>listener 1883</strong></pre>
<p>Let's see what we have done here. The <kbd>allow_anonymous false</kbd> line tells the broker that not everyone can access the data. The next line, <kbd>password_file /etc/mosquitto/pwfile</kbd> is telling the broker the location of password file, which is located at <kbd>/etc/mosquitto/pwfile</kbd>. Finally, we will define the port of this broker, which is <kbd>1883</kbd>, using the <kbd>listener 1883</kbd> command.</p>
<p>So finally, we have completed setting up the MQTT client in our Raspberry Pi. Now we are ready to go ahead and use it for the IoT-enabled home.</p>


            

            
        
    </div>
<div><h1 class="header-title">Making an IoT-based intrusion detector</h1>
                
            
            
                
<p>Now that Raspberry Pi is set up and we are ready to make it IoT enabled let's see how we are going to connect the system to the internet and make things work. Firstly, we need to connect Raspberry Pi to the devices, which we want to control using the IoT technology. So go ahead and use the following diagram to make the connection:</p>
<div><img src="img/850b503e-0226-46eb-b76b-dd84ee83b7e2.png" style="width:36.25em;height:55.75em;"/></div>
<p>Once you have set up all the components, let's go ahead and upload the following code:</p>
<pre>import time<br/>import paho.mqtt.client as mqtt<br/>import RPi.gpio as gpio<br/>pir = 23<br/>gpio.setmode(gpio.BCM)<br/>gpio.setup(pir, gpio.IN)<br/>client = mqtt.Client()<br/>broker="broker.hivemq.com"<br/>port = 1883<br/>pub_topic = "IntruderDetector_Home"<br/>def SendData():<br/>  client.publish(pub_topic,"WARNING : SOMEONE DETECTED AT YOUR PLACE")<br/><br/>def on_connect(client, userdata, flag,rc):<br/>  print("connection returned" + str(rc))<br/>  SendData()<br/>while True:<br/>  client.connect(broker,port)<br/>  client.on_connect = on_connect<br/>  if gpio.output(pir) == gpio.HIGH :<br/>    SendData()<br/>  client.loop_forever()<br/></pre>
<p>This code, unlike the other chunks of code that we have seen so far, will be quite new to you. So I will be explaining every part of it except for a few obvious parts. So, let's see what we have here:</p>
<pre>import paho.mqtt.client as mqtt</pre>
<p>In this part, we are importing the <kbd>pho.mqtt.client</kbd> library as <kbd>mqtt</kbd>. So whenever this library needs to be accessed, we simply need to use the line <kbd>mqtt</kbd> instead of the entire name of the library.</p>
<pre>client = mqtt.Client()</pre>
<p>We are defining a client using the client method of the <kbd>mqtt</kbd> library. This can be called using the <kbd>client</kbd> variable.</p>
<pre>broker="broker.hivemq.com"</pre>
<p>So we are defining the broker in our program. For this program, we are using the broker as <kbd>broker.hivemq.com</kbd>, which is providing us the broker services.</p>
<pre>port = 1883</pre>
<p>Now as we have done earlier, we will once again define the port at which the protocol will be working, which in our case is <kbd>1883</kbd>.</p>
<pre>pub_topic = "IntuderDetector_Home"</pre>
<p>Here, we are defining the value of the variable called <kbd>pub_topic</kbd>, which is <kbd>IntruderDetector_Home</kbd>. This will be the final topic to which one can subscribe once the code is running.</p>
<pre>def SendData():<br/>    client.publish(pub.topic, "WARNING : SOMEONE DETECTED AT YOUR PLACE")</pre>
<p>Here, we are defining a function called <kbd>SendData()</kbd>,  will publish the data <kbd>Warning : SOMEONE DETECTED AT YOUR PLACE</kbd> to the broker with the topic which we had declared previously.</p>
<pre>def on_message(client, userdata, message):<br/><br/>  print('message is : ')<br/>  print(str(message.payload))<br/></pre>
<p>In this line, we are defining a function named <kbd>on_message()</kbd>, which will print a value <kbd>message is :</kbd> followed by whatever the data is. This will be done using the line <kbd>print(str(message.payload))</kbd>. What this is doing is, it is printing whatever is being passed on in the arguments of the function.</p>
<pre> def on_connect(client, userdata, flag,rc):<br/><br/>     print("connection returned" + str(rc))  <br/>     SendData()</pre>
<p>In this line, we are defining the <kbd>on_connect()</kbd> function, which will print the line <kbd>connection returned</kbd> followed by the value of <kbd>rc</kbd>. <kbd>rc</kbd> stands for return code. So, whenever the message is delivered, a code is generated, even if it is not, then the specific code will be returned notifying the error. So, consider this as an acknowledgement. After this is done, the <kbd>SendData()</kbd> function that we defined earlier will be used to send the data to the broker.</p>
<pre>client.connect(broker,port)</pre>
<p><kbd>connect()</kbd> is a function of the MQTT library which connects the client to the broker. Doing this is very simple. All we need to do is pass on the arguments of the broker which we want to connect to and the port which would be used. In our case, <kbd>broker = broker.hivemq.com</kbd> and <kbd>port = 1883</kbd>. So when we call the function, Raspberry Pi gets connected to our broker.</p>
<pre>client.on_connect = on_connect </pre>
<p class="mce-root">This is the heart of the program. What the <kbd>client.on_connect</kbd> function is doing is that every time Raspberry Pi gets connected to the broker, it starts executing the <kbd>on_connect</kbd> function defined by us. This in-turn will send the data continuously to the broker after every 5 seconds, exactly the way in which we have defined in the function. This process is also called callback, which makes it event driven. That is, if it is not connected, it will not try to send the data to the broker.</p>
<pre>    if gpio.output(pir) == HIGH :<br/>        sendData()</pre>
<p>the sendData() function is called when the PIR sensor gets high or whenever the motion is detected the message is sent on the broker with the warning that someone is detected at your place. </p>
<pre>client.loop_forever()</pre>
<p>This is my favorite function, especially because of the lovely name it has. As you can expect, the <kbd>client.loop_forver()</kbd> function will keep looking for any event and whenever it is detected it will trigger the data to be sent to the broker. Now comes the part where we will see this data. For this, we'll have to download the <em>MyMQTT</em> app from App Store if you are running iOS or from Playstore if you are running android. </p>
<div><img src="img/0189638d-62f7-4eb5-b6b2-d12833d89293.jpeg" style="width:21.67em;height:26.25em;"/></div>
<p>Once you start the app, you will be presented with the preceding screen. You need to fill in the name of the broker URL, which in our case is <kbd>broker.hivemq.com</kbd>. Then, fill in the port, which in our case is <kbd>1883</kbd>.</p>
<p>Once this is done, you will see a screen similar to the following:</p>
<div><img src="img/3f1828e0-7304-4a5e-8756-e0a44eed0f84.jpeg" style="width:22.00em;height:36.75em;"/></div>
<p>Simply add the name of the subscription you need, which is <kbd>IntruderDetector_Home</kbd>. Once done, you'll see the magic!</p>
<p>You can also apply the same logic that we used in <a href="f5d8044d-e608-4ab6-adca-52ec2689f115.xhtml" target="_blank">Chapter 10</a>, <em>Making a Guard Robot</em>. So go ahead and play with it; I will leave you here.</p>
<p>In the next section, we will be controlling things based on IoT; see you then.</p>


            

            
        
    </div>
<div><h1 class="header-title">Controlling the home</h1>
                
            
            
                
<p>Finally, using the following diagram, make the connections and upload the following code:</p>
<div><img src="img/9be0f710-94d2-4854-bf2b-ff106efea2f7.png"/></div>
<div><pre>import time<br/>import paho.mqtt.client as paho<br/>import RPi.GPIO as GPIO<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(14,GPIO.OUT)<br/>broker="broker.hivemq.com"<br/>sub_topic = light/control<br/>client = paho.Client()<br/>def on_message(client, userdata, message):<br/>    print('message is : ')<br/>    print(str(message.payload))<br/>    data = str(message.payload)<br/>    if data == "on":<br/>        GPIO.output(3,GPIO.HIGH)<br/>    elif data == "off":<br/>        GPIO.output(3,GPIO.LOW)<br/><br/>def on_connect(client,userdata, flag, rc):<br/>    print("connection returned" + str(rc))<br/>    client.subscribe(sub_topic)<br/>client.connect(broker,port)<br/>client.on_connect = on_connect<br/>client.on_message=on_message<br/>client.loop_forever()</pre></div>
<p>Now, there is not much I need to tell you in this code; it's pretty straightforward. We are sending the data just like we did last time. However, this time we are using a new function. So, let's see what this code is all about:</p>
<pre>def on_message(client, userdata, message):<br/><br/>       print('message is : ')<br/>       print(str(message.payload))<br/>       data = str(message.payload)<br/><br/>       if data == "on":<br/>           GPIO.output(3,GPIO.HIGH)<br/><br/>       elif data == "off":<br/>           GPIO.output(3,GPIO.LOW)</pre>
<p>Here we are defining what the <kbd>on_message()</kbd> function is doing. There are three arguments to the function over which the message would be working on. This includes <kbd>client</kbd>, which we have already declared previously; <kbd>userdata</kbd>, which we are not using right now; and finally, <kbd>message</kbd>, which we will be sending through our smartphones over the internet.</p>
<p>Once you look inside the program, this function will print the message using the lines <kbd>print('message is : ')</kbd> and <kbd>print(str(message.payload))</kbd>. Once this is done, the value of <kbd>data</kbd> will be set as the message sent by the subscriber.</p>
<p>This data will be evaluated by our conditions. If the data is kept <kbd>on</kbd>, then the GPIO port number <kbd>3</kbd> will be set to <kbd>HIGH</kbd>, and if the string is <kbd>off</kbd>, then the GPIO port number <kbd>3</kbd> will be set to <kbd>LOW</kbd>—in simple words, switching your device on or off your device.</p>
<pre>def on_connect(client,userdata, flag, rc):<br/>    print("connection returned" + str(rc))<br/>    client.subscribe(sub_topic)</pre>
<p>We have defined the <kbd>on_connect()</kbd> function previously as well. However, this time it is slightly different. Rather than just printing the connection returned with the value of <kbd>rc</kbd>, we are also using another function called <kbd>client.subscribe(sub_topic)</kbd>, which will let us get connected to the broker on the specific topic that we have defined earlier in this program.</p>
<pre>client.on_message=on_message</pre>
<p>As we know that the entire algorithm is based on an event-driven system, this <kbd>client.on_message</kbd> function will keep waiting for a message to be received. Once received, it will then execute the <kbd>on_message</kbd> function. This will decide whether to turn the appliance on or off.</p>
<p>To use it, just go ahead and send the data based on the topic and it will be received by your Raspberry Pi.</p>
<div><img src="img/6cd0c92b-fd78-4962-a161-9f3f16ec79a9.jpeg" style="width:24.58em;height:22.67em;"/></div>
<p>Once received, the decision-making function, <kbd>on_message()</kbd>, will decide what data is being received by the MyMQTT app. If the data received is <kbd>on</kbd>, then the lights will be turned on. If the data received is <kbd>off</kbd>, then the lights will be turned off. It's as simple as that.</p>


            

            
        
    </div>
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have understood the basics of IoT and how the MQTT server works. We also made an intruder detection system that will alert you whenever someone is in your home, no matter where you are in the world. Finally, we also created a system to switch on a device in your home using a simple mobile command. In the next chapter, we will let Jarvis enable to let you interact with the system based on your voices.</p>


            

            
        
    </div></body></html>