<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Acquiring Intelligence Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Acquiring Intelligence Data</h1></div></div></div><p>We're going to acquire intelligence data from a variety of sources. We might interview people. We might steal files from a secret underground base. We might search the <a id="id156" class="indexterm"/>
<span class="strong"><strong>World Wide Web</strong></span> (<span class="strong"><strong>WWW</strong></span>), and this is what we'll focus on in this chapter. Using our own cameras or recording devices is the subject of the next chapter.</p><p>Important espionage targets include natural resources, popular opinion, and strategic economic strengths. This kind of background information is useful in a number of ways. A great deal of the world's data is already on the Web, and the rest will get there eventually. Any modern search for intelligence starts with the Web.</p><p>We can use Python libraries such as <code class="literal">http.client</code> and <code class="literal">urllib</code> to get data from remote servers and transfer files to other servers. Once we've found remote files of interest, we're going to need a number of Python libraries to parse and extract data from these libraries.</p><p>In <a class="link" href="ch01.html" title="Chapter 1. Our Espionage Toolkit">Chapter 1</a>, <span class="emphasis"><em>Our Espionage Toolkit</em></span>, we looked at how we can peek inside a ZIP archive. We'll look inside other kinds of files in this chapter. We'll focus on JSON files, because they're widely used for web services APIs. </p><p>Along the way, we'll cover a number of topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to access online data from Python.</li><li class="listitem" style="list-style-type: disc">The HTTP protocol and how to access websites from our applications.</li><li class="listitem" style="list-style-type: disc">The FTP protocol and how to upload and download large volumes of bulk data.</li><li class="listitem" style="list-style-type: disc">Many of the core Python data structures will include lists, tuples, dictionaries, and sets, and how we use these structures to organize and manage information. </li><li class="listitem" style="list-style-type: disc">At the end of this chapter, we'll be able to build applications that access live, current, up-to-the-minute data from the Web. Once we've got the data, we can filter and analyze it to create useful intelligence assets.</li></ul></div><div class="section" title="Accessing data from the Internet"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Accessing data from the Internet</h1></div></div></div><p>The WWW and Internet are based on a series of agreements called <span class="strong"><strong>Request for Comments</strong></span> (<span class="strong"><strong>RFC</strong></span>). The RFCs define the standards and protocols to interconnect different networks, that is, the rules for internetworking. The WWW is defined by a subset of these RFCs that specifies the protocols, behaviors of hosts and agents (servers and clients), and file formats, among other details.</p><p>In a way, the Internet is a <a id="id157" class="indexterm"/>controlled chaos. Most software developers agree to follow the RFCs. Some don't. If their idea is really good, it can catch on, even though it doesn't precisely follow<a id="id158" class="indexterm"/> the standards. We often see this in the way some browsers don't work with some websites. This can cause confusion and questions. We'll often have to perform both espionage and plain old debugging to figure out what's available on a given website.</p><p>Python provides a variety of <a id="id159" class="indexterm"/>modules that implement the software defined in the Internet RFCs. We'll look at some of the common protocols to gather data through the Internet and the Python library modules that implement these protocols.</p><div class="section" title="Background briefing – the TCP/IP protocols"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Background briefing – the TCP/IP protocols</h2></div></div></div><p>The essential idea behind the WWW is the Internet. The essential idea behind the Internet is the TCP/IP protocol stack. The IP part of this is the internetworking protocol. This defines how messages can be routed<a id="id160" class="indexterm"/> between networks. Layered on top of IP is the TCP protocol to connect two applications to each other. TCP connections are often made via a software abstraction called a <span class="strong"><strong>socket</strong></span>. In<a id="id161" class="indexterm"/> addition to TCP, there's also UDP; it's not used as much for the kind of WWW data we're interested in.</p><p>In Python, we can use the low-level <code class="literal">socket</code> library to work with the TCP protocol, but we won't. A socket is a file-like object that supports open, close, input, and output operations. Our software will be much simpler if we work at a higher level of abstraction. The Python libraries that we'll use will leverage the socket concept under the hood.</p><p>The Internet RFCs defines a number of protocols that build on TCP/IP sockets. These are more useful definitions of interactions between host computers (servers) and user agents (clients). We'll look at two of these: <span class="strong"><strong>Hypertext Transfer Protocol</strong></span> (<span class="strong"><strong>HTTP</strong></span>)<a id="id162" class="indexterm"/> and<a id="id163" class="indexterm"/> <span class="strong"><strong>File Transfer Protocol</strong></span> (<span class="strong"><strong>FTP</strong></span>).</p></div><div class="section" title="Using http.client for HTTP GET"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Using http.client for HTTP GET</h2></div></div></div><p>The essence<a id="id164" class="indexterm"/> of web traffic is HTTP. This is built on TCP/IP. HTTP defines two roles: host and user agent, also called <a id="id165" class="indexterm"/>server and client, respectively. We'll stick to server and client. HTTP defines a number of kinds of request types, including <code class="literal">GET</code> and <code class="literal">POST</code>.</p><p>A web browser is one kind of client software we can use. This software makes <code class="literal">GET</code> and <code class="literal">POST</code> requests, and displays the results from the web server. We can do this kind of client-side processing in Python using two library modules.</p><p>The <code class="literal">http.client</code> module <a id="id166" class="indexterm"/>allows us to make <code class="literal">GET</code> and <code class="literal">POST</code> requests as well as <code class="literal">PUT</code> and <code class="literal">DELETE</code>. We can read the response object. Sometimes, the response is an HTML page. Sometimes, it's a graphic image. There are other <a id="id167" class="indexterm"/>things too, but we're mostly interested in text and graphics.</p><p>Here's a picture of a mysterious device we've been trying to find. We need to download this image to our computer so that we can see it and send it to our informant from <a class="ulink" href="http://upload.wikimedia.org/wikipedia/commons/7/72/IPhone_Internals.jpg">http://upload.wikimedia.org/wikipedia/commons/7/72/IPhone_Internals.jpg</a>.</p><div class="mediaobject"><img src="graphics/Image_1.jpg" alt="Using http.client for HTTP GET"/></div><p>Here's a picture of the currency we're supposed to track down and pay with:</p><div class="mediaobject"><img src="graphics/0420OS_02_02.jpg" alt="Using http.client for HTTP GET"/></div><p>We need to download<a id="id168" class="indexterm"/> this image. Here is the link:</p><p>
<a class="ulink" href="http://upload.wikimedia.org/wikipedia/en/c/c1/1drachmi_1973.jpg">http://upload.wikimedia.org/wikipedia/en/c/c1/1drachmi_1973.jpg</a></p><p>Here's how we can use <code class="literal">http.client</code> to get these two image files:</p><div class="informalexample"><pre class="programlisting">import http.client
import contextlib

path_list = [
    "/wikipedia/commons/7/72/IPhone_Internals.jpg",
    "/wikipedia/en/c/c1/1drachmi_1973.jpg",
]
host = "upload.wikimedia.org"

with contextlib.closing(http.client.HTTPConnection( host )) as connection:
    for path in path_list:
        connection.request( "GET", path )
        response= connection.getresponse()
        print("Status:", response.status)
        print("Headers:", response.getheaders())
        _, _, filename = path.rpartition("/")
        print("Writing:", filename)
        with open(filename, "wb") as image:
            image.write( response.read() )</pre></div><p>We're using <code class="literal">http.client</code> to handle the client side of the HTTP protocol. We're also using the <code class="literal">contextlib</code> module<a id="id169" class="indexterm"/> to politely disentangle our application from network resources when we're done using them.</p><p>We've assigned a list of paths to the <code class="literal">path_list</code> variable. This example introduces list objects without providing any background. We'll return to lists in the <span class="emphasis"><em>Organizing collections of data</em></span> section later in the chapter. It's important that lists are surrounded by <code class="literal">[]</code> and the items are separated by <code class="literal">,</code>. Yes, there's an extra <code class="literal">,</code> at the end. This is legal in Python.</p><p>We created an <code class="literal">http.client.HTTPConnection</code> object using the host computer name. This connection object is a little like a file; it entangles Python with operating system resources on our local computer plus a remote server. Unlike a file, an <code class="literal">HTTPConnection</code> object isn't a proper context manager. As we really like context managers to release our resources, we made use of the <code class="literal">contextlib.closing()</code> function to handle the context management details. The<a id="id170" class="indexterm"/> connection needs to be closed; the <code class="literal">closing()</code> function <a id="id171" class="indexterm"/>assures that this will happen by calling the connection's <code class="literal">close()</code> method.</p><p>For all of the paths<a id="id172" class="indexterm"/> in our <code class="literal">path_list</code>, we make an HTTP <code class="literal">GET</code> request. This is what browsers do to get the image files mentioned in an HTML page. We print a few things from each response. The status, if everything worked, will be 200. If the status is not 200, then something went wrong and we'll need to read up on the HTTP status code to see what happened.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>If you use a coffee shop Wi-Fi connection, perhaps you're not logged in. You might need to open a browser to set up a connection.</p></div></div><p>An HTTP response includes headers that provide some additional details about the request and response. We've printed the headers because they can be helpful in debugging any problems we might have. One of the most useful headers is <code class="literal">('Content-Type', 'image/jpeg')</code>. This confirms that we really did get an image.</p><p>We used <code class="literal">_, _, filename = path.rpartition("/")</code> to locate the right-most <code class="literal">/</code> character in the path. Recall that the <code class="literal">partition()</code> method locates the left-most instance. We're using the right-most one here. We assigned the directory information and separator to the variable <code class="literal">_</code>. Yes, <code class="literal">_</code> is a legal variable name. It's easy to ignore, which makes it a handy shorthand for <span class="emphasis"><em>we don't care</em></span>. We kept the filename in the <code class="literal">filename</code> variable.</p><p>We create a nested context for the resulting image file. We can then read the body of the response—a collection of bytes—and write these bytes to the image file. In one quick motion, the file is ours.</p><p>The HTTP <code class="literal">GET</code> request is what underlies much of the WWW. Programs such as <code class="literal">curl</code> and <code class="literal">wget</code> are expansions of this example. They execute batches of <code class="literal">GET</code> requests to locate one or more pages of content. They can do quite a bit more, but this is the essence of extracting data from the WWW.</p></div><div class="section" title="Changing our client information"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Changing our client information</h2></div></div></div><p>An HTTP <code class="literal">GET</code> request<a id="id173" class="indexterm"/> includes several headers in addition to the URL. In the previous example, we simply relied on the Python <code class="literal">http.client</code> library to supply a suitable set of default headers. There are several reasons why <a id="id174" class="indexterm"/>we might want to supply different or additional headers.</p><p>First, we might want to tweak the <code class="literal">User-Agent</code> header to change the kind of browser that we're claiming to be. We might also need to provide cookies for some kinds of interactions. For information on the<a id="id175" class="indexterm"/> user agent string, see <a class="ulink" href="http://en.wikipedia.org/wiki/User_agent_string#User_agent_identification">http://en.wikipedia.org/wiki/User_agent_string#User_agent_identification</a>.</p><p>This information may be used by the web server to determine if a mobile device or desktop device is being used. We can use something like this:</p><div class="informalexample"><pre class="programlisting">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14</pre></div><p>This makes our Python request appear to come from the Safari browser instead of a Python application. We can use something like this to appear to be a different browser on a desktop computer:</p><div class="informalexample"><pre class="programlisting">Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:28.0) Gecko/20100101 Firefox/28.0</pre></div><p>We can use something like this to appear to be an iPhone instead of a Python application:</p><div class="informalexample"><pre class="programlisting">Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_1 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D201 Safari/9537.53</pre></div><p>We make this change by adding headers to the request we're making. The change looks like this:</p><div class="informalexample"><pre class="programlisting">connection.request( "GET", path, headers= {
    'User-Agent':
        'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_1 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D201 Safari/9537.53',
})</pre></div><p>This will make the web server treat our Python application like it's on an iPhone. This might lead to a more compact page of data than might be provided to a full desktop computer that makes the same request.</p><p>The header information is a structure with the <code class="literal">{ key: value, }</code> syntax. This is a dictionary. We'll return to dictionaries in the following <span class="emphasis"><em>Organizing collections of data</em></span> section. It's important that dictionaries are surrounded by <code class="literal">{}</code>, the keys and values are separated by <code class="literal">:</code>, and each key-value pair is separated by <code class="literal">,</code>. Yes, there's an extra <code class="literal">,</code> at the end. This is legal in Python.</p><p>There are many more<a id="id176" class="indexterm"/> HTTP headers we can provide. The <code class="literal">User-Agent</code> header is perhaps most important to gather different kinds of intelligence data from web servers.</p></div><div class="section" title="Using FTP in Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Using FTP in Python</h2></div></div></div><p>FTP specifies ways to transfer files<a id="id177" class="indexterm"/> between computers. There are two principle variants: the original FTP and the more secure version, FTPS. This more secure version uses SSL to assure that the <a id="id178" class="indexterm"/>lower-level sockets are fully encrypted. It's sometimes called <code class="literal">FTP_TLS</code>, FTP with transport layer security.</p><p>The SSH standard includes <a id="id179" class="indexterm"/>a file-transfer protocol, SFTP. This is a part of SSH and is separate from other FTP variants. This is supported by the <code class="literal">ftplib</code> module, even though it's really a different protocol.</p><p>In some cases, FTP access is anonymous. No security credentials (such as usernames or passwords) are used. This is<a id="id180" class="indexterm"/> usually reserved for download-only content. Sometimes, anonymous access expects a placeholder username and password—the username should be <span class="emphasis"><em>anonymous</em></span>, and typically, your e-mail address is used as a password. In other cases, we need to have proper credentials. We'll focus on publicly accessible FTP servers.</p><p>We're going to look for the CIA World Factbooks. We know that there are copies in Project Gutenberg. This leads us to use the <a class="ulink" href="http://ftp.ibiblio.org">ftp.ibiblio.org</a> server as the target of our investigation. The<a id="id181" class="indexterm"/> base URL is <a class="ulink" href="ftp://ftp.ibiblio.org/pub/docs/books/gutenberg/">ftp://ftp.ibiblio.org/pub/docs/books/gutenberg/</a>.</p><p>FTP has its own language of commands used to examine remote (and local) filesystems, create and remove directories, as well as get and put files. Some of this language is exposed through the Python FTP module. Some of it is kept hidden under the hood.</p><p>We can see some top-level documents available on the Project Gutenberg server with a script like the following. Here's our initial step in discovering the data:</p><div class="informalexample"><pre class="programlisting">import ftplib

host = "ftp.ibiblio.org"
root = "/pub/docs/books/gutenberg/"

def directory_list( path ):
    with ftplib.FTP(host, user="anonymous") as connection:
        print("Welcome", connection.getwelcome())
        for name, details in connection.mlsd(path):
            print(name, details['type'], details.get('size'))
directory_list(root)</pre></div><p>We imported the FTP library. We'll need this to do anything using the FTP protocol. We assigned the host, <code class="literal">host</code>, and root path, <code class="literal">root</code>, as strings. We'll use this in several functions that we need to define.</p><p>We defined a <code class="literal">directory_list()</code> function that <a id="id182" class="indexterm"/>will display names, types, and sizes from a directory. This lets us explore the files in our local directories. We'll use this function with different parameters after we've tracked <a id="id183" class="indexterm"/>down the directory with our candidate files.</p><p>The <code class="literal">directory_list()</code> function opens a context using a <code class="literal">ftplib.FTP</code> object. We don't need to use the <code class="literal">contextlib.closing()</code> function, because this context is well behaved. This object will manage the various sockets used to exchange data with the FTP server. One of the methods, <code class="literal">getwelcome()</code>, retrieves any welcome message. We'll see that this is pretty short. Sometimes, they're more elaborate.</p><p>We'll dump the top-level directory information that shows the various files, directories, and their sizes. The <code class="literal">details['type']</code> syntax is how we pick a particular name out of the name-value pairs in a dictionary. The <code class="literal">details.get('size')</code> syntax does a similar thing. Getting an item with <code class="literal">[]</code> will raise an exception if the name is not found. Getting an item with the <code class="literal">get()</code> method supplies a default value instead of an exception. Unless specified otherwise, the default value is <code class="literal">None</code>.</p><p>We're making the claim that<a id="id184" class="indexterm"/> the <code class="literal">details</code> dictionary must have a <code class="literal">type</code> item. If it doesn't, the program will crash, because something's very wrong. We're also making the claim that the <code class="literal">details</code> dictionary might or might not have the <code class="literal">size</code> item. If the size isn't present, the <code class="literal">None</code> value will do instead.</p><p>There are a number of files here. The <code class="literal">README</code> and <code class="literal">GUTINDEX.ALL</code> files look promising; let's examine them.</p><div class="section" title="Downloading a file via FTP"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Downloading a file via FTP</h3></div></div></div><p>The FTP library relies <a id="id185" class="indexterm"/>on a technique called a <span class="strong"><strong>callback function</strong></span> to support<a id="id186" class="indexterm"/> incremental processing. Downloading a 13 MB file takes some time. Having our computer just doze off while downloading is impolite. It's<a id="id187" class="indexterm"/> good to provide some ongoing status with respect to progress (or lack of it thereof).</p><p>We can define callback functions in a number of ways. If we're going to use class definitions, the callback function will simply be another method of the class. Class definitions get a bit beyond the scope of our book. They're quite simple, but we have to focus on espionage, not software design. Here's a general-purpose <code class="literal">get()</code> function:</p><div class="informalexample"><pre class="programlisting">import sys

def get( fullname, output=sys.stdout ):
    download= 0
    expected= 0
    dots= 0
    def line_save( aLine ):
        nonlocal download, expected, dots
        print( aLine, file=output )
        if output != sys.stdout:
            download += len(aLine)
            show= (20*download)//expected
            if show &gt; dots:
                print( "-", end="", file=sys.stdout )
                sys.stdout.flush()
                dots= show
    with ftplib.FTP( host, user="anonymous" ) as connection:
        print( "Welcome", connection.getwelcome() )
        expected= connection.size( fullname )
        print( "Getting", fullname, "to", output, "size", expected )
        connection.retrlines( "RETR {0}".format(fullname), line_save )
    if output != sys.stdout:
        print() # End the "dots"   </pre></div><p>The <code class="literal">get()</code> function contains a function definition buried inside it. The <code class="literal">line_save()</code> function is the callback function that's used by the <code class="literal">retrlines()</code> function of an FTP connection. Each line of <a id="id188" class="indexterm"/>data from the server will be passed to the <code class="literal">line_save()</code> function to process it.</p><p>Our <code class="literal">line_save()</code> function uses three <code class="literal">nonlocal</code> variables: <code class="literal">download</code>, <code class="literal">expected</code>, and <code class="literal">dots</code>. These variables are neither global nor are they local to the <code class="literal">line_save()</code> function. They're initialized before any<a id="id189" class="indexterm"/> lines are downloaded, and they are updated within the <code class="literal">line_save()</code> function on a line-by-line basis. As they are a saved state for the <code class="literal">line_save()</code> function, we need to notify Python not to create local variables when these are used in an assignment statement.</p><p>The function's primary job is to print the line to the file named in the <code class="literal">output</code> variable. Interestingly, the <code class="literal">output</code> variable is also nonlocal. As we never try to assign a new value to this variable, we don't need to notify Python about its use in an assignment statement. A function has read access to nonlocal variables; write access requires special arrangements via the <code class="literal">global</code> or <code class="literal">nonlocal</code> statements.</p><p>If the output file is <code class="literal">sys.stdout</code>, we're displaying the file on the console. Writing status information is just confusing. If the output file is not <code class="literal">sys.stdout</code>, we're saving the file. Showing some status is helpful.</p><p>We compute how many dots (from 0 to 19) to show. If the number of dots has increased, we'll print another dash. Yes, we called the variable <code class="literal">dots</code> but decided to print dashes. Obscurity is never a good thing. You might want to take an independent mission and write your own version, which is clearer than this.</p><p>The <code class="literal">get()</code> function creates a context using an <code class="literal">ftplib.FTP</code> object. This object will manage the various sockets used to exchange data with the FTP server. We use the <code class="literal">getwelcome()</code> method to<a id="id190" class="indexterm"/> get the welcome<a id="id191" class="indexterm"/> message. We use the <a id="id192" class="indexterm"/>
<code class="literal">size()</code> method to get the size of the file we're about to request. By setting the <code class="literal">expected</code> variable, we can assure that up to 20 dashes are displayed to show the <a id="id193" class="indexterm"/>state of the download.</p><p>The <code class="literal">retrlines()</code> method of the connection requires an FTP command and a callback function. It sends the command; each line of the response is sent to the callback function.</p></div><div class="section" title="Using our FTP get() function"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec11"/>Using our FTP get() function</h3></div></div></div><p>We can use this <code class="literal">get()</code> function<a id="id194" class="indexterm"/> to download files<a id="id195" class="indexterm"/> from the server. We'll start with two examples of extracting files from an FTP server:</p><div class="informalexample"><pre class="programlisting"># show the README on sys.stdout
get(root+"README") 

# get GUTINDEX.ALL
with open("GUTINDEX.ALL", "w", encoding="UTF-8") as output:
    get(root+"GUTINDEX.ALL", output)</pre></div><p>The first example is a small file. We'll display the <code class="literal">README</code> file, which might have useful information. It's usually small, and we can write it to <code class="literal">stdout</code> immediately. The second example will open a file processing context to save the large <code class="literal">GUTINDEX.ALL</code> file locally for further analysis. It's quite large, and we certainly don't want to display it immediately. We can search this index file for CIA World Factbooks. There are several Factbooks.</p><p>The introduction to the <code class="literal">GUTINDEX.ALL</code> file describes how document numbers turn into directory paths. One of the CIA World Factbooks, for example, is document number 35830. This becomes the directory path <code class="literal">3/5/3/35380/</code>. The document will be in this directory.</p><p>We can use our <code class="literal">directory_list()</code> function to see what else is there:</p><div class="informalexample"><pre class="programlisting">directory_list( root+"3/5/8/3/35830/" )</pre></div><p>This will show us that there are several subdirectories and a ZIP file that appears to have images. We'll start with the text document. We can use our <code class="literal">get()</code> function to download the CIA Factbook in a script like the following:</p><div class="informalexample"><pre class="programlisting">with open("35830.txt", "w", encoding="UTF-8") as output:
    get(root+"3/5/8/3/35830/"+"35830.txt", output)</pre></div><p>This gets us one of the CIA World Factbooks. We can easily track down the others. We can<a id="id196" class="indexterm"/> then analyze<a id="id197" class="indexterm"/> information from these downloaded documents.</p></div></div><div class="section" title="Using urllib for HTTP, FTP, or file access"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Using urllib for HTTP, FTP, or file access</h2></div></div></div><p>The <code class="literal">urllib</code> package <a id="id198" class="indexterm"/>wraps HTTP, FTP, and local file access in a single, tidy package. In the most common situations, this package allows us to elide some of the processing details we saw in the previous examples.</p><p>The advantage<a id="id199" class="indexterm"/> of the general approach in <code class="literal">urllib</code> is that we can write smallish programs that can work with data from<a id="id200" class="indexterm"/> a wide variety of locations. We can rely on <code class="literal">urllib</code> to work with HTTP, FTP, or local files seamlessly. The <a id="id201" class="indexterm"/>disadvantage is<a id="id202" class="indexterm"/> that we can't do<a id="id203" class="indexterm"/> some more complex HTTP or FTP interactions. Here's an example of downloading two images with the <code class="literal">urllib</code> version of the HTTP <code class="literal">get</code> function:</p><div class="informalexample"><pre class="programlisting">import urllib.request

url_list = [
"http://upload.wikimedia.org/wikipedia/commons/7/72/IPhone_Internals.jpg",
"http://upload.wikimedia.org/wikipedia/en/2/26/Common_face_of_one_euro_coin.jpg",
    ]

for url in url_list:
    with urllib.request.urlopen( url ) as response:
        print( "Status:", response.status )
        _, _, filename = response.geturl().rpartition("/")
        print( "Writing:", filename )
        with open( filename, "wb" ) as image:
            image.write( response.read() )</pre></div><p>We've defined two URLs. When<a id="id204" class="indexterm"/> using <code class="literal">urllib</code>, we can provide full URLs without having to distinguish between the host and the path we're tying to access.</p><p>We create a context using <code class="literal">urllib.request.urlopen()</code>. This context will contain all of the resources used for getting the file from the World Wide Web. The <code class="literal">response</code> object is called a <span class="strong"><strong>file-like object</strong></span> in<a id="id205" class="indexterm"/> Python parlance. We can use it the way we'd use a file: it supports <code class="literal">read()</code> and <code class="literal">readline()</code> methods. It can be used in a <code class="literal">for</code> statement to iterate over lines of a text file.</p></div><div class="section" title="Using urllib for FTP access"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Using urllib for FTP access</h2></div></div></div><p>We can use a<a id="id206" class="indexterm"/> simple <code class="literal">urllib.request</code> to get a file via FTP. We can simply change the URL to reflect the protocol<a id="id207" class="indexterm"/> we're using. Something like this works well:</p><div class="informalexample"><pre class="programlisting">import sys
import urllib.request
readme= "ftp://ftp.ibiblio.org/pub/docs/books/gutenberg/README"
with urllib.request.urlopen(readme) as response:
      
    sys.stdout.write( response.read().decode("ascii") )</pre></div><p>This will open the source file and print it on <code class="literal">sys.stdout</code>. Note that we had to decode the bytes from ASCII to create proper Unicode<a id="id208" class="indexterm"/> characters for use by Python. We can print the other status and header information if we find it necessary.</p><p>We can also use a local file URL. The schema is <code class="literal">file:</code> instead of <code class="literal">http:</code> or <code class="literal">ftp:</code>. Generally, the hostname is omitted, thus leading to file URLs like this:</p><div class="informalexample"><pre class="programlisting">local= "file:///Users/slott/Documents/Writing/Secret Agent's Python/currency.html"</pre></div><p>Using <code class="literal">urllib</code> leads to a few pleasant simplifications. We can treat resources located across the WWW with code that's similar to handling a local file. Remote resources are often slower than local files; we might want to give up waiting after a period of time. Also, there's the possibility of network disconnections. Our error handling needs to be more robust when working with remote data.</p></div></div></div>
<div class="section" title="Using a REST API in Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Using a REST API in Python</h1></div></div></div><p>A great deal of<a id="id209" class="indexterm"/> intelligence data is available through REST APIs. Much of the data is available in simple JSON, CSV, or XML documents. In order to make sense of this<a id="id210" class="indexterm"/> data, we need to be able to <a id="id211" class="indexterm"/>parse these various kinds of serialization formats. We'll focus on JSON because it's widely used. Sadly, it's not universal.</p><p>A REST protocol is essentially HTTP. It will leverage <code class="literal">POST</code>, <code class="literal">GET</code>, <code class="literal">PUT</code>, and <code class="literal">DELETE</code> requests to implement the essential four stages in the life of persistent data: <span class="strong"><strong>Create, Retrieve, Update, and Delete</strong></span> (<span class="strong"><strong>CRUD</strong></span><a id="id212" class="indexterm"/>) rules.</p><p>We'll look at currency conversion as a simple web API. This can both help us bribe our information sources as well as provide important information on the overall state of a nation's economy. We can measure national economies against each other as well as measure them against non-national crypto currencies such as bitcoins.</p><p>We'll get exchange and<a id="id213" class="indexterm"/> currency information from <a class="ulink" href="http://www.coinbase.com">http://www.coinbase.com</a>. There are a lot of similar services; this one seems reasonably complete. They seem to have up-to-date currency<a id="id214" class="indexterm"/> information that we can report to HQ as part of an overall intelligence assessment.</p><p>Their API documentation is available at <a class="ulink" href="https://coinbase.com/api/doc">https://coinbase.com/api/doc</a>. This tells us what URLs to use, what data to provide with the URL, and what kind of response to expect.</p><div class="section" title="Getting simple REST data"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Getting simple REST data</h2></div></div></div><p>We can get the currency exchange data either with the <code class="literal">http.client</code> or <code class="literal">urllib.request</code> module. This<a id="id215" class="indexterm"/> won't be new to us; we already grabbed data using both libraries. The responses from this website will be in the <a id="id216" class="indexterm"/>JSON notation. For more information, see <a class="ulink" href="http://www.json.org/">http://www.json.org/</a>.</p><p>To parse a JSON document, we'll need to import the <code class="literal">json</code> module from the standard library. The response that we get<a id="id217" class="indexterm"/> from <code class="literal">urllib</code> is a sequence of bytes. We'll need to decode these bytes to get a string. We can then use the <code class="literal">json.loads()</code> function to build Python objects from that string. Here's how it looks:</p><div class="informalexample"><pre class="programlisting">import urllib.request
import json
query_currencies= "http://www.coinbase.com/api/v1/currencies/"
with urllib.request.urlopen( query_currencies ) as document:
    print(document.info().items())
    currencies= json.loads( document.read().decode("utf-8") )
    print(currencies)</pre></div><p>We imported the two libraries that we need: <code class="literal">urllib.request</code> to get the data and <code class="literal">json</code> to parse the response.</p><p>The currency query (<code class="literal">/api/v1/currencies/</code>) is described in the API documentation on the Coinbase website. When we make this request, the resulting document will have all of the currencies they know about.</p><p>We printed <code class="literal">document.info().items()</code>; this is the collection of headers that came back with the response. Sometimes, these are interesting. In this case, they don't tell us too much that we don't already know. What's important is that the <code class="literal">Content-Type</code> header has a <code class="literal">application/json; charset=utf-8</code> value . This tells us how to decode the bytes.</p><p>We read the resulting document (<code class="literal">document.read()</code>) and then converted the bytes to characters. The <code class="literal">Content-Type</code> header says that the characters were encoded using <code class="literal">utf-8</code>, so we'll use <code class="literal">utf-8</code> to decode the bytes and recover the original sequence of characters. Once we have the characters, we can use <code class="literal">json.loads()</code> to create a Python object from the characters.</p><p>This will get us a list of currencies we can work with. The response object looks like this:</p><div class="informalexample"><pre class="programlisting">[['Afghan Afghani (AFN)', 'AFN'], ['Albanian Lek (ALL)', 'ALL'], 
['Algerian Dinar (DZD)', 'DZD'], … ]</pre></div><p>It is a list of lists that provides the names of 161 currencies.</p><p>In the next section, we'll look at ways to work with a list-of-tuple structure. Working with a list of list is going to be very similar to working with a list of tuple.</p><p>To make this more<a id="id218" class="indexterm"/> flexible, we need to turn the header <code class="literal">items()</code> list into a dictionary. From this, we can get the <code class="literal">Content-Type</code> value string from the dictionary. This string<a id="id219" class="indexterm"/> can be partitioned on <code class="literal">;</code> to locate the <code class="literal">charset=utf-8</code> substring. This string can subsequently be partitioned on the <code class="literal">=</code> character to locate the <code class="literal">utf-8</code> encoding information. This would be slightly better than assuming a <code class="literal">utf-8</code> encoding. The first step, creating a dictionary from the headers, has to wait until the <span class="emphasis"><em>Organizing collections of data</em></span> section. First, we'll look at getting other information using the REST protocol.</p></div><div class="section" title="Using more complex RESTful queries"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Using more complex RESTful queries</h2></div></div></div><p>Once we have a list of currencies, we can request<a id="id220" class="indexterm"/> spot conversion rates. This involves a somewhat more complex URL. We need to provide a currency code to get the current bitcoin exchange rate for that specific currency.</p><p>While it's not perfectly clear <a id="id221" class="indexterm"/>from the API documentation, the RFCs for the web state that we should encode the query string as part of our processing. In this specific situation, it doesn't seem possible for the query string to contain any characters that <span class="emphasis"><em>require</em></span> encoding.</p><p>We're going to be fussy though and encode the query string properly using the <code class="literal">urllib</code> module. Encoding will be essential for a number of examples in <a class="link" href="ch04.html" title="Chapter 4. Drops, Hideouts, Meetups, and Lairs">Chapter 4</a>, <span class="emphasis"><em>Drops, Hideouts, Meetups, and Lairs</em></span>.</p><p>Query string encoding is done using the <code class="literal">urllib.parse</code> module. It looks like this:</p><div class="informalexample"><pre class="programlisting">    scheme_netloc_path= "https://coinbase.com/api/v1/prices/spot_rate"
    form= {"currency": currency}
    query= urllib.parse.urlencode(form)</pre></div><p>The <code class="literal">scheme_netloc_path</code> variable has a portion of the URL. It has the scheme (<code class="literal">http</code>), network location (<code class="literal">coinbase.com</code>), and path (<code class="literal">api/v1/prices/spot_rate</code>). This fragment of the URL doesn't have the query string; we'll encode this separately because it had dynamic information that changes from request to request.</p><p>Technically, a query string is a bunch of parameters that have been encoded so that certain reserved characters such as <code class="literal">?</code> and <code class="literal">#</code> don't cause any confusion to the web server. Pragmatically, the query string used here is very simple with only a single parameter.</p><p>To handle query strings in a general-purpose way, we defined an HTML form using a dictionary and assigned it to the <code class="literal">form</code> variable. This dictionary is a model of a form on an HTML web page with a single input field. We modeled an input field with a name, <code class="literal">currency</code>, that has an <code class="literal">EUR</code> value.</p><p>The <code class="literal">urllib.parse.urlencode()</code> function <a id="id222" class="indexterm"/>encodes all the fields of the form into a tidy representation with any reserved characters handled properly. In this case, there's only one field, and no reserved characters are used by the field name or the field value.</p><p>We can play with this in interactive Python:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import urllib.parse
&gt;&gt;&gt; form= {"currency": "EUR"}
&gt;&gt;&gt; urllib.parse.urlencode(form)
'currency=EUR'</pre></div><p>The preceding code shows how <a id="id223" class="indexterm"/>we built a form<a id="id224" class="indexterm"/> object as a dictionary and then encoded it to create a valid URL-encoded query string. As the data was so simple, the encoding is quite simple.</p><p>Here's an example with a more complex piece of data in the form:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; form['currency']= "Something with # or ?"
&gt;&gt;&gt; urllib.parse.urlencode(form)
'currency=Something+with+%23+or+%3F'</pre></div><p>First, we updated the form with different input; we changed the currency value to <code class="literal">Something with # or ?</code>. We'll look at dictionary updates in the next section. The updated value has reserved characters in it. When we encoded this form, the result shows how reserved characters are handled by URL encoding.</p><p>As we start working with more complex structures, we'll find that the built-in <code class="literal">print()</code> function isn't going to do everything we need. In the <code class="literal">pprint</code> module, the <code class="literal">pprint()</code> function does a much nicer job working with complex data. We can use this to get the pretty-print function:</p><div class="informalexample"><pre class="programlisting">import pprint</pre></div><p>We can use our query template and the encoded data like this:</p><div class="informalexample"><pre class="programlisting">with urllib.request.urlopen( scheme_netloc_path+"?"+query ) as document:
    pprint.pprint( document.info().items() )
    spot_rate= json.loads( document.read().decode("utf-8") )</pre></div><p>The expression, <code class="literal">scheme_netloc_path+"?"+query</code>, assembled the complete URL from, the relatively static portions, and the dynamic query string. We've used a <code class="literal">with</code> statement to be sure that all of the network resources are properly released when we're done. We used the <code class="literal">pprint()</code> function to show the headers, which tell us the content type. The headers also include three cookies, which we're studiously ignoring for these examples.</p><p>When we print the <code class="literal">spot_rate</code> value, we see that the Python object looks like this:</p><div class="informalexample"><pre class="programlisting">{'currency': 'USD', 'amount': '496.02'}
Or this
{'currency': 'EUR', 'amount': '361.56'}</pre></div><p>These are Python<a id="id225" class="indexterm"/> dictionary objects. We'll need to<a id="id226" class="indexterm"/> learn more about dictionaries to be able to work with these responses. Stay tuned for the <span class="emphasis"><em>Using a Python dictionary mapping</em></span> section.</p></div><div class="section" title="Saving our data via JSON"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>Saving our data via JSON</h2></div></div></div><p>What if we want to save<a id="id227" class="indexterm"/> the data we downloaded? This is something in which JSON excels. We can use the JSON module to serialize objects into a string and write this string to a file.</p><p>Here's how we can save<a id="id228" class="indexterm"/> our two-spot currency rate pieces of data into a JSON document. First, we need to turn our <code class="literal">spot_rate</code> example from the <span class="emphasis"><em>Getting more RESTful data</em></span> section into a function. Here's how it might look:</p><div class="informalexample"><pre class="programlisting">def get_spot_rate( currency ):
    scheme_netloc_path= "https://coinbase.com/api/v1/prices/spot_rate"
    form= {"currency":currency}
    query= urllib.parse.urlencode(form)

    with urllib.request.urlopen( scheme_netloc_path+"?"+query ) as document:
        spot_rate= json.loads( document.read().decode("utf-8") )
    return spot_rate</pre></div><p>This function requires the currency code as an argument. Given the currency code, it creates a tiny input form and encodes this to create the query string. In this case, we saved that string in the <code class="literal">query</code> variable.</p><p>We created the URL from a template and the data. This URL was used as a request to get a currency spot rate. We read the entire response and decoded the string from bytes. Once we had the string, we loaded a Python dictionary object using this string. We returned this dictionary<a id="id229" class="indexterm"/> using the <code class="literal">get_spot_rate()</code> function. We can now use this function to get some spot-rate dictionary objects:</p><div class="informalexample"><pre class="programlisting">rates = [
    get_spot_rate("USD"), get_spot_rate("GBP"),
    get_spot_rate("EUR") ]</pre></div><p>This statement built a list-of-dictionary structure from our three spot-rate dictionaries. It assigned the collection to the <code class="literal">rates</code> variable. Once we have this, we can serialize it and create a file that has some useful exchange-rate information.</p><p>Here's how we use JSON to save a Python object to a file:</p><div class="informalexample"><pre class="programlisting">with open("rate.json","w") as save:
    json.dump( rates, save )</pre></div><p>We opened a file to write something and used this as a processing context to be assured that the file will be properly closed when we're done. We then used the <code class="literal">json.dump()</code> function to dump our <code class="literal">rates</code> object to this file.</p><p>What's important<a id="id230" class="indexterm"/> about this is that JSON works most simply when we encode one object to a file. In this case, we built a list of individual objects and<a id="id231" class="indexterm"/> encoded that list into the file. As we can't easily perform any sort of partial or incremental encoding of objects into a JSON file, we built a list with everything in it. Except in cases of huge mountains of data, this technique of building and dumping a list works very nicely.</p></div></div>
<div class="section" title="Organizing collections of data"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Organizing collections of data</h1></div></div></div><p>We introduced some data collections earlier in the chapter. It's time to come clean on what these collections are and how we can use<a id="id232" class="indexterm"/> them effectively. As we observed in <a class="link" href="ch01.html" title="Chapter 1. Our Espionage Toolkit">Chapter 1</a>, <span class="emphasis"><em>Our Espionage Toolkit</em></span>, Python offers a tower of different types of numbers. The commonly used numbers are built in; the more specialized numbers are imported from the standard library.</p><p>In a similar way, Python has a number of built-in collections. There is also a very large number of additional collection types available in the standard library. We'll look at the built-in lists, tuples, dictionaries, and sets. These cover the essential bases to work with groups of data items.</p><div class="section" title="Using a Python list"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Using a Python list</h2></div></div></div><p>The Python list class can be summarized as a mutable sequence. <span class="strong"><strong>Mutability</strong></span> <a id="id233" class="indexterm"/>means that we can add, change, and remove items (the list can be changed). Sequence means that<a id="id234" class="indexterm"/> the items are accessed based on their positions within the list.</p><p>The syntax is pleasantly simple; we put the data items in <code class="literal">[]</code> and separate the items with <code class="literal">,</code>. We can use any Python object in the sequence.</p><p>HQ wants information on per capita consumption of selected cheese varieties. While HQ doesn't reveal much to field agents, we know that they often want to know about natural resources and strategic economic strengths.</p><p>We can find cheese consumption data at <a class="ulink" href="http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls">http://www.ers.usda.gov/datafiles/Dairy_Data/chezcon_1_.xls</a>.</p><p>Sadly, the data is in a proprietary spreadsheet format and rather difficult to work with. To automate the data gathering, we would need something like Project Stingray to extract the data from this document. For manual<a id="id235" class="indexterm"/> data gathering, we can<a id="id236" class="indexterm"/> copy and paste the data.</p><p>Here's the data starting in 2000 and extending through 2010; we'll use it to show some simple list processing:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; cheese = [29.87, 30.12, 30.60, 30.66, 31.33, 32.62,
...     32.73, 33.50, 32.84, 33.02,]
&gt;&gt;&gt; len(cheese)
10
&gt;&gt;&gt; min(cheese)
29.87
&gt;&gt;&gt; cheese.index( max(cheese) )
7</pre></div><p>We created a list object and assigned it to the <code class="literal">cheese</code> variable. We used the <code class="literal">min()</code> function, which reveals the least value in the <code class="literal">29.87</code> sequence.</p><p>The <code class="literal">index()</code> method searches through the sequence for the matching value. We see that the maximum consumption found with the <code class="literal">max()</code> function has an index of <code class="literal">7</code> corresponding to 2007. After that, cheese consumption fell slightly.</p><p>Note that we have prefix function notations (<code class="literal">min()</code>, <code class="literal">max()</code>, <code class="literal">len()</code>, and several others). We also have method function notation, <code class="literal">cheese.index()</code>, and many others. Python offers a rich variety of notations. There's no fussy adherence to using only method functions.</p><p>As a list is mutable, we can append additional values to the list. We can use an <code class="literal">cheese.extend()</code> function to<a id="id237" class="indexterm"/> extend a given list with an additional list of values:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; cheese.extend( [32.92, 33.27, 33.51,] )
&gt;&gt;&gt; cheese
[29.87, 30.12, 30.6, 30.66, 31.33, 32.62, 32.73, 33.5, 32.84, 33.02, 32.92, 33.27, 33.51]</pre></div><p>We can also use the <code class="literal">+</code> operator to combine two lists.</p><p>We can reorder the data so that it's strictly ascending using the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; cheese.sort()
&gt;&gt;&gt; cheese
[29.87, 30.12, 30.6, 30.66, 31.33, 32.62, 32.73, 32.84, 32.92, 33.02, 33.27, 33.5, 33.51]</pre></div><p>Note that the <code class="literal">sort()</code> method doesn't return a value. It mutates the list object itself; it doesn't return a new list. If we try something like <code class="literal">sorted_cheese= cheese.sort()</code>, we see that <code class="literal">sorted_cheese</code> has a <code class="literal">None</code> value. This is a consequence of <code class="literal">sort()</code> not returning a value; it <a id="id238" class="indexterm"/>mutates the list.</p><p>When working with<a id="id239" class="indexterm"/> time-series data, this kind of transformation will be confusing because the relationship between year and cheese consumption is lost when we sort the list.</p><div class="section" title="Using list index operations"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Using list index operations</h3></div></div></div><p>We can access individual items<a id="id240" class="indexterm"/> using the <code class="literal">cheese[index]</code> notation:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; cheese[0]
29.87
&gt;&gt;&gt; cheese[1]
30.12</pre></div><p>This allows us to <a id="id241" class="indexterm"/>pick specific items from a list. As the list was sorted, the item <code class="literal">0</code> is the least, and the item <code class="literal">1</code> is the next larger value. We can index <span class="emphasis"><em>backwards</em></span> from the end of the list, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; cheese[-2]
33.5
&gt;&gt;&gt; cheese[-1]
33.51</pre></div><p>With the sorted data, the <code class="literal">-2</code> item is next to the largest one; the <code class="literal">-1</code> item is the last one, which is the largest value seen. In the original, unsorted <code class="literal">cheese[-2]</code> data would have been the 2009 data. </p><p>We can take a <span class="emphasis"><em>slice</em></span> from a list too. Some common slice manipulations look like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; cheese[:5]
[29.87, 30.12, 30.6, 30.66, 31.33]
&gt;&gt;&gt; cheese[5:]
[32.62, 32.73, 32.84, 32.92, 33.02, 33.27, 33.5, 33.51]</pre></div><p>The first slice picks the first five values—the values of least cheese consumption. As we sorted the time-series data, we don't readily know which years' these were. We might need a more sophisticated data collection.</p><p>When working with collections, we find that we have a new comparison operator, <code class="literal">in</code>. We can use a simple <code class="literal">in</code> test to see if a value occurs anywhere in the collection:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 30.5 in cheese
False
&gt;&gt;&gt; 33.5 in cheese
True</pre></div><p>The <code class="literal">in</code> operator works for tuples, dictionary keys, and sets.</p><p>The <a id="id242" class="indexterm"/>comparison operators<a id="id243" class="indexterm"/> compare the elements in order, looking for the first nonequal element between two sequences. Consider <a id="id244" class="indexterm"/>the following example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; [1, 2, 1] &lt; [1, 2, 2]
True</pre></div><p>As the first two elements were equal, it was the third element that determined the relationship between the two lists. This rule also works for tuples.</p></div></div><div class="section" title="Using a Python tuple"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Using a Python tuple</h2></div></div></div><p>The Python tuple class can<a id="id245" class="indexterm"/> be summarized as an immutable sequence. Immutability means that once created, the tuple cannot be changed. The value of the number 3 is immutable, also: it's always 3. Sequence means that the items are <a id="id246" class="indexterm"/>accessed based on their positions within the tuple.</p><p>The syntax is pleasantly simple; we might need to put the data items in <code class="literal">()</code> and must separate the items with <code class="literal">,</code>. We can use any Python objects in the sequence. The idea is to create an object that looks like a mathematical coordinate: <code class="literal">(3, 4)</code>.</p><p>Tuples are used under the hood at many places within Python. When we use multiple assignments, for example, the right-hand side of the following code creates a tuple and the left-hand side decomposes it:</p><div class="informalexample"><pre class="programlisting">power, value = 0, 1</pre></div><p>The right-hand side created a two-tuple <code class="literal">(0, 1)</code>. The syntax doesn't require <code class="literal">()</code> around the tuple. The left-hand side broke down a two-tuple, assigning the values to two distinct variables.</p><p>We generally use tuples for data objects where the number of elements is fixed by the problem domain. We often use tuples for coordinate pairs such as latitude and longitude. We don't need the flexible length that a list offers because the size of a tuple cannot change. What would a three-tuple mean when it's supposed to have just two values, latitude and longitude? A different kind of problem might involve longitude, latitude, and altitude; in this case, we're working with three-tuples. Using two-tuples or three-tuples in these examples is an essential feature of the problem: we won't be mutating objects to add or remove values.</p><p>When we looked at HTTP headers in requests and responses, we saw that these are represented as a list of two-tuples, such as <code class="literal">('Content-Type', 'text/html; charset=utf-8')</code>. Each tuple has a header name (<code class="literal">'Content-Type'</code>) and header value (<code class="literal">'text/html; charset=utf-8'</code>).</p><p>Here's an example of using a two-tuple to include year and cheese consumption:</p><div class="informalexample"><pre class="programlisting">year_cheese = [(2000, 29.87), (2001, 30.12), (2002, 30.6), (2003, 30.66),
    (2004, 31.33), (2005, 32.62), (2006, 32.73), (2007, 33.5),
    (2008, 32.84), (2009, 33.02), (2010, 32.92), (2011, 33.27),
    (2012, 33.51)]</pre></div><p>This list-of-tuple structure allows us to perform a slightly simpler analysis of the data. Here are two examples:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; max( year_cheese, key=lambda x:x[1] )
(2012, 33.51)
&gt;&gt;&gt; min( year_cheese, key=lambda x:x[1] )
(2000, 29.87)</pre></div><p>We applied the <code class="literal">max()</code> function to our<a id="id247" class="indexterm"/> list of tuples. The second argument to the <code class="literal">max()</code> function is another function—in this case, an anonymous <code class="literal">lambda</code> object—that evaluates just the second value in each tuple.</p><p>Here are two more<a id="id248" class="indexterm"/> examples that show what's happening with the <code class="literal">lambda</code> object:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; (2007, 33.5)[1]
33.5
&gt;&gt;&gt; (lambda x:x[1])( (2007, 33.5) )
33.5</pre></div><p>The <code class="literal">(2007, 33.5)</code> two-tuple has the <code class="literal">[1]</code> get item operation applied; this will pick the item at position <code class="literal">1</code>, that is, the <code class="literal">33.5</code> value. The item at position zero is the year 2007.</p><p>The <code class="literal">(lambda x:x[1])</code> expression creates an anonymous <code class="literal">lambda</code> function. We can then apply this function to the <code class="literal">(2007, 33.5)</code> two-tuple. As the <code class="literal">x[1]</code> expression picks the item at index position <code class="literal">1</code>, we get the <code class="literal">33.5</code> value.</p><p>We can, if we want, create a fully defined, named function instead of using <code class="literal">lambda</code>, as shown in the following code</p><div class="informalexample"><pre class="programlisting">def by_weight( yr_wt_tuple ):
    year, weight =  yr_wt_tuple
    return weight</pre></div><p>A named function has two advantages: it has a name, and it can have multiple lines of code. A <code class="literal">lambda</code> function has<a id="id249" class="indexterm"/> the advantage of being tiny when the entire function can be reduced to a single expression.</p><p>We can use this technique to sort these two-tuples with a function instead of <code class="literal">lambda</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; by_cheese = sorted( year_cheese, key=by_weight )
&gt;&gt;&gt; by_cheese
[(2000, 29.87), (2001, 30.12), (2002, 30.6), (2003, 30.66), (2004, 31.33), (2005, 32.62), (2006, 32.73), (2008, 32.84), (2010, 32.92), (2009, 33.02), (2011, 33.27), (2007, 33.5), (2012, 33.51)]</pre></div><p>We used a separate function to create a sorted copy of a sequence. The <code class="literal">sorted()</code> function requires an iterable item (the <code class="literal">year_cheese</code> list in this case) and a key function; it creates a new list<a id="id250" class="indexterm"/> from the old sequence that<a id="id251" class="indexterm"/> is sorted into order by the key function. In this case, our key function is the named function, <code class="literal">by_weight()</code>. Unlike the <code class="literal">list.sort()</code> method, the <code class="literal">sorted()</code> function does not modify the original sequence; the new list contains references to the original items.</p><div class="section" title="Using generator expressions with list of tuples"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Using generator expressions with list of tuples</h3></div></div></div><p>If we want to locate cheese production for a given year, we need to search this sequence of two-tuples for the matching year. We can't simply use the <code class="literal">list.index()</code> function to locate an item, as we're only<a id="id252" class="indexterm"/> using part of the item. One strategy is to extract the year from the list using a generator expression, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; years = [ item[0] for item in year_cheese ]
&gt;&gt;&gt; years
[2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012]</pre></div><p>The <code class="literal">item[0] for item in year_cheese</code> expression is a generator. It iterates through the <code class="literal">year_cheese</code> list, assigning each item to the variable named <code class="literal">item</code>. The <code class="literal">item[0]</code> subexpression is evaluated for each value of <code class="literal">item</code>. This will decompose the two-tuples, returning a single value from<a id="id253" class="indexterm"/> each tuple. The result is collected into a resulting list and assigned to the <code class="literal">years</code> variable. We'll return to this in the <span class="emphasis"><em>Transforming sequences with generator functions</em></span> section.</p><p>We can then use <code class="literal">years.index(2005)</code> to get the index for a given year, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; years.index(2005)
5
&gt;&gt;&gt; year_cheese[years.index(2005)]
(2005, 32.62)</pre></div><p>As <code class="literal">years.index(2005)</code> gives us the position of a given year, we can use <code class="literal">year_cheese[ years.index( 2005 ) ]</code> to get the <code class="literal">year-cheese</code> two-tuple for the year 2005.</p><p>This idea of mapping from year to cheese consumption is directly implemented by a Python dictionary.</p><p>The <code class="literal">in</code> operator<a id="id254" class="indexterm"/> and other comparison operators work for tuples in the same way they work for lists. They<a id="id255" class="indexterm"/> compare the target tuple to each tuple in the list using a simple item-by-item comparison between the items in the tuples.</p></div></div><div class="section" title="Using a Python dictionary mapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>Using a Python dictionary mapping</h2></div></div></div><p>A dictionary contains a mapping from keys to values. The Python dictionary class can be summarized as a mutable mapping. Mutability means that we can add, change, and remove items. Mapping<a id="id256" class="indexterm"/> means that the values are accessed based on their keys. Order is not preserved in a mapping.</p><p>The syntax is pleasantly simple: we put the key-value pairs in <code class="literal">{}</code>, separate the key from the value with <code class="literal">:</code>, and separate the <a id="id257" class="indexterm"/>pairs with <code class="literal">,</code>. The values can be any kind of Python object. The keys, however, suffer from a restriction—they must be immutable objects. As strings and numbers are immutable, they make perfect keys. A tuple is immutable and a good key. A list is mutable though, and can't be used as a key.</p><p>When we looked at creating an HTTP form data, in the <span class="emphasis"><em>Getting more RESTful data</em></span> section, we used a mapping from field name to field value. We got back a response, which was a mapping from keys to values. The response looked like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; spot_rate= {'currency': 'EUR', 'amount': '361.56'}
&gt;&gt;&gt; spot_rate['currency']
'EUR'
&gt;&gt;&gt; spot_rate['amount']
'361.56'
&gt;&gt;&gt; import decimal
&gt;&gt;&gt; decimal.Decimal(spot_rate['amount'])
Decimal('361.56')</pre></div><p>After creating the <code class="literal">spot_rate</code> dictionary, we used the <code class="literal">dict[key]</code> syntax to get values of two of the keys, <code class="literal">currency</code> and <code class="literal">amount</code>.</p><p>As a dictionary is mutable, we can easily change the values associated with the keys. Here's how we can create and modify a form:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; form= {"currency":"EUR"}
&gt;&gt;&gt; form['currency']= "USD"
&gt;&gt;&gt; form
{'currency': 'USD'}</pre></div><p>We created the <code class="literal">form</code> variable as a small dictionary. We can use this to make one spot-rate query. We then changed the value in the <code class="literal">form</code> dictionary. We can use this updated form to make a second spot-rate query.</p><p>When getting a value, the key must exist; otherwise, we'll get an exception. As noted earlier, we can also use <code class="literal">dict.get(key, default)</code> to get values when a key might not exist in the dictionary. Here are several examples:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; spot_rate['currency']
'EUR'
&gt;&gt;&gt; spot_rate['oops']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'oops'
&gt;&gt;&gt; spot_rate.get('amount')
'361.56'
&gt;&gt;&gt; spot_rate.get('oops')
&gt;&gt;&gt; spot_rate.get('oops', '#Missing')
'#Missing'</pre></div><p>First, we fetched the value mapped to the <code class="literal">currency</code> key. We tried to fetch a value mapped to the <code class="literal">oops</code> key. We got a <code class="literal">KeyError</code> exception because the <code class="literal">oops</code> key isn't in the <code class="literal">spot_rate</code> dictionary.</p><p>We did the same kinds of things<a id="id258" class="indexterm"/> using the <code class="literal">get()</code> method. When we executed <code class="literal">spot_rate.get('amount')</code>, the key-value pair existed, so the value was returned.</p><p>When we executed <code class="literal">spot_rate.get('oops')</code>, the key didn't exist; the default return value was <code class="literal">None</code>. Python doesn't print <code class="literal">None</code> values, so we don't see any obvious result from this. When we executed <code class="literal">spot_rate.get('oops', '#Missing')</code>, we provided a return value that is not <code class="literal">None</code>, which displayed something visible. The idea is that we can then do things like<a id="id259" class="indexterm"/> this to make a series of related queries:</p><div class="informalexample"><pre class="programlisting">for currency in 'USD', 'EUR', 'UAH':
    form['currency']=  currency
    data= urllib.parse.urlencode( form )
    ...etc...</pre></div><p>The <code class="literal">for</code> statement includes a tuple of values: <code class="literal">'USD', 'EUR', 'UAH'</code>. We aren't required to put <code class="literal">()</code> around the tuple in this particular case because the syntax is unambiguous.</p><p>Each value from the literal tuple is used to set the <code class="literal">currency</code> value in the form. We can then use the <code class="literal">urllib.parse.urlencode()</code> function to build a query string. We might be using this in a <code class="literal">urllib.urlopen()</code> function to get a current spot price for bitcoins in that currency.</p><div class="section" title="Using the dictionary access methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Using the dictionary access methods</h3></div></div></div><p>Other interesting methods<a id="id260" class="indexterm"/> of a dictionary mapping include the <code class="literal">keys()</code>, <code class="literal">values()</code>, and <code class="literal">items()</code> methods. Here are some examples:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; spot_rate.keys()
dict_keys(['amount', 'currency'])
&gt;&gt;&gt; spot_rate.items()
dict_items([('amount', '361.56'), ('currency', 'EUR')])
&gt;&gt;&gt; spot_rate.values()
dict_values(['361.56', 'EUR'])</pre></div><p>The <code class="literal">keys()</code> method gave us a <code class="literal">dict_keys</code> object, which contains just the keys in a simple list. We can sort this list or do other processing outside the dictionary. Similarly, the <code class="literal">values()</code> method gave us a <code class="literal">dict_values</code> object, which contains just the values in a simple list.</p><p>The <code class="literal">items()</code> method gave us a sequence of two-tuples, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; rate_as_list= spot_rate.items()
&gt;&gt;&gt; rate_as_list  
dict_items([('amount', '361.56'), ('currency', 'EUR')])</pre></div><p>We created the <code class="literal">rate_as_list</code> variable from the <code class="literal">spot_rate.items()</code> list of two-tuples. We can easily convert a list of two-tuple to a dictionary using the <code class="literal">dict()</code> function and vice versa, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; dict(rate_as_list)
{'amount': '361.56', 'currency': 'EUR'}</pre></div><p>This gives us a way to deal with the 161 currencies. We'll look at this in the next section, <span class="emphasis"><em>Transforming sequences with generator functions</em></span>.</p><p>Note that the <code class="literal">in</code> operator works against the dictionary keys, not the values:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 'currency' in spot_rate
True
&gt;&gt;&gt; 'USD' in spot_rate
False</pre></div><p>The <code class="literal">currency</code> key exists in the <code class="literal">spot_rate</code> dictionary. The <code class="literal">USD</code> value is not checked by the <code class="literal">in</code> operator. If we're looking for a specific value, we have to use the <code class="literal">values()</code> method explicitly:</p><div class="informalexample"><pre class="programlisting">'USD' in spot_rate.values()</pre></div><p>Other comparison operators<a id="id261" class="indexterm"/> don't really make sense for a dictionary. It's essential to explicitly compare a dictionary's keys, values, or items.</p></div></div><div class="section" title="Transforming sequences with generator functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>Transforming sequences with generator functions</h2></div></div></div><p>The<a id="id262" class="indexterm"/> data at <a class="ulink" href="http://www.coinbase.com/api/v1/currencies/">http://www.coinbase.com/api/v1/currencies/</a>, which was a RESTful request, was a giant list of lists. It started like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; currencies = [['Afghan Afghani (AFN)', 'AFN'], ['Albanian Lek (ALL)', 'ALL'],  
... ['Algerian Dinar (DZD)', 'DZD'], 
... ]</pre></div><p>If we apply the <code class="literal">dict()</code> function to<a id="id263" class="indexterm"/> this list of lists, we'll <a id="id264" class="indexterm"/>build a dictionary. However, this dictionary isn't what we want; the following code is how it looks:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; dict(currencies)
{'Afghan Afghani (AFN)': 'AFN', 'Albanian Lek (ALL)': 'ALL', 'Algerian Dinar (DZD)': 'DZD'}</pre></div><p>The keys in this dictionary are long <code class="literal">country currency (code)</code> strings. The values are the three-letter currency code.</p><p>We might want the keys of this as a handy lookup table for a person's reference to track down the proper currency for a given country. We might use something like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; dict(currencies).keys()
dict_keys(['Afghan Afghani (AFN)', 'Albanian Lek (ALL)', 'Algerian Dinar (DZD)'])</pre></div><p>This shows how we can create a dictionary from a list of lists and then extract just the <code class="literal">keys()</code> from this dictionary. This is, in a way, an excessive amount of processing for a simple result.</p><p>We showed an example of picking up some data using a generator function in the <span class="emphasis"><em>Using a Python tuple</em></span> section. Here's how we'd apply it to this problem. We'll create a list comprehension using a generator function. The generator, surrounded by <code class="literal">[]</code>, will lead to a new list object, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; [name for name, code in currencies]
['Afghan Afghani (AFN)', 'Albanian Lek (ALL)', 'Algerian Dinar (DZD)']</pre></div><p>The <code class="literal">currencies</code> object is the original list of lists. The real one has 161 items; we're working with a piece of it here to keep the output small.</p><p>The generator expression has three clauses. These are <span class="emphasis"><em>subexpressions</em></span> for <span class="emphasis"><em>targets</em></span> in <span class="emphasis"><em>source</em></span>. The <code class="literal">[]</code> characters are separate punctuations used to create a list objects from the generated values; they're not part of the generator expression itself. The <span class="emphasis"><em>subexpression</em></span> is evaluated for each target value. The <span class="emphasis"><em>target</em></span> variable is assigned to each element from the <span class="emphasis"><em>source</em></span> iterable object. Each two-tuple from the currencies list is assigned to the <code class="literal">name</code> and <code class="literal">code</code> target variables. The<a id="id265" class="indexterm"/> subexpression is just <code class="literal">name</code>. We can use this to build a dictionary from currency to full name:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; codes= dict( (code,name) for name,code in currencies )
&gt;&gt;&gt; codes
{'DZD': 'Algerian Dinar (DZD)', 'ALL': 'Albanian Lek (ALL)', 'AFN': 'Afghan Afghani (AFN)'}
&gt;&gt;&gt; codes['AFN']
'Afghan Afghani (AFN)'</pre></div><p>We used a generator function to swap the two elements of each item of the currency list. The targets were <code class="literal">name</code> and <code class="literal">code</code>; the resulting<a id="id266" class="indexterm"/> subexpression is the <code class="literal">(code,name)</code> two-tuple. We built a <a id="id267" class="indexterm"/>dictionary from this; this dictionary maps currency codes to country names.</p></div><div class="section" title="Using the defaultdict and counter mappings"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>Using the defaultdict and counter mappings</h2></div></div></div><p>There are a number of<a id="id268" class="indexterm"/> sophisticated mappings that are part of the standard library. Two of these are the <code class="literal">defaultdict</code> and <code class="literal">Counter</code> mappings. The <code class="literal">defaultdict</code> allows us to work more flexibly with keys that don't exist.</p><p>Let's look at the word corpus we<a id="id269" class="indexterm"/> used to<a id="id270" class="indexterm"/> recover a ZIP file password. We can use this word corpus for other purposes. One of the things that can help the crypto department decode messages is knowledge <a id="id271" class="indexterm"/>of two-letter sequences (<code class="literal">digram</code> or <code class="literal">bigram</code>) that occur commonly in the source documents.</p><p>What are the most common two-letter digrams in English? We can easily gather this from our dictionary, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">from collections import defaultdict
corpus_file = "/usr/share/dict/words"
digram_count = defaultdict( int )
with open( corpus_file ) as corpus:
    for line in corpus:
        word= line.lower().strip()
        for position in range(len(word)-1):
            digram= word[position:position+2]
            digram_count[digram] += 1</pre></div><p>We need to import the <code class="literal">defaultdict</code> class from the <code class="literal">collections</code> module because it's not built in. We created an empty <code class="literal">defaultdict</code> object, <code class="literal">digram_count</code>, using <code class="literal">int</code> as the initialization function. The initialization function handles missing keys; we'll look at the details in the following section.</p><p>We opened our word <code class="literal">corpus</code>. We iterated through each line in <code class="literal">corpus</code>. We transformed each line into a word by stripping the trailing spaces and mapping it to lowercase. We used the <code class="literal">range()</code> function to generate a<a id="id272" class="indexterm"/> sequence of positions from zero to one less than the length of the word (<code class="literal">len(word)-1</code>). We can pluck a two-character digram from each word using the <code class="literal">word[position:position+2]</code> slice notation.</p><p>When we evaluate <code class="literal">digram_count[digram]</code>, one of two things will happen:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the key exists in the mapping, the value is returned, just like any ordinary dictionary. We can then add one to the value that is returned, thus updating the dictionary.</li><li class="listitem" style="list-style-type: disc">If the key does not exist in<a id="id273" class="indexterm"/> this mapping, then the initialization function is evaluated to create a default value. The value of <code class="literal">int()</code> is <code class="literal">0</code>, which is ideal to count things. We can then add <code class="literal">1</code> to this value and update the dictionary.</li></ul></div><p>The cool feature of a <code class="literal">defaultdict</code> class is that no exception is raised for a missing key value. Instead of raising<a id="id274" class="indexterm"/> an exception, the initialization function is used.</p><p>This <code class="literal">defaultdict(int)</code> class is so common that we can use the <code class="literal">Counter</code> class definition for this. We can<a id="id275" class="indexterm"/> make two tiny changes to the previous example. The first change is as follows:</p><div class="informalexample"><pre class="programlisting">from collections import Counter</pre></div><p>The second change is as follows:</p><div class="informalexample"><pre class="programlisting">digram_count= Counter()</pre></div><p>The reason for making this change is that <code class="literal">Counter</code> classes do some additional things. In particular, we often want to know the most common counts, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; print( digram_count.most_common( 10 ) )
[('er', 42507), ('in', 33718), ('ti', 31684), ('on', 29811), ('te', 29443), ('an', 28275), ('al', 28178), ('at', 27276), ('ic', 26517), ('en', 25070)]</pre></div><p>The <code class="literal">most_common()</code> method of a <code class="literal">Counter</code> object returns the counts in the descending order. This <a id="id276" class="indexterm"/>shows us that <code class="literal">er</code> is the<a id="id277" class="indexterm"/> most common English-language digram. This information might help the decoders back at HQ.</p></div><div class="section" title="Using a Python set"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>Using a Python set</h2></div></div></div><p>The Python set class is mutable; we can add, change, and remove items. Items are either present or absent. We don't use positions or keys; we merely add, remove, or test the items. This means that sets have no inherent order.</p><p>The syntax is pleasantly<a id="id278" class="indexterm"/> simple; we put the data items in <code class="literal">{}</code> and separated the items with <code class="literal">,</code>. We can use any immutable Python objects in the set. It's important to note that the items must be immutable—we can include strings, numbers, and tuples. We can't include a list or dictionary in a set.</p><p>As the <code class="literal">{}</code> characters are used both by dictionaries and sets, it's unclear what the empty pair, <code class="literal">{}</code>, means. Is this an empty dictionary or an empty set? It's much more clear if we use <code class="literal">dict()</code> to mean an <a id="id279" class="indexterm"/>empty dictionary and <code class="literal">set()</code> to mean an empty set.</p><p>A set is a simple collection of things; it is perhaps the simplest possible collection of things.</p><p>In looking at the digrams, we noticed that there were some digrams, including a <code class="literal">-</code> character. How many <a id="id280" class="indexterm"/>hyphenated words are in the dictionary? This is a simple set processing example:</p><div class="informalexample"><pre class="programlisting">corpus_file = "/usr/share/dict/words"
hyphenated = set()
with open( corpus_file ) as corpus:
    for line in corpus:
        word= line.lower().strip()
        if '-' in word:
            hyphenated.add(word)</pre></div><p>We created an empty set and assigned it to the <code class="literal">hyphenated</code> variable. We checked each word in our collection of words to see if the <code class="literal">-</code> character is in the collection of characters. If we find the hyphen, we can add this word to our set of hyphenated words.</p><p>The word corpus on the author's computer had two hyphenated words. This raises more questions than it answers.</p><p>The <code class="literal">in</code> operator is essential for working with sets. The comparison operators implement subset and superset comparisons between two sets. The <code class="literal">a &lt;= b</code> operation asks if <code class="literal">a</code> is a subset of <code class="literal">b</code>, mathematically, <span class="inlinemediaobject"><img src="graphics/0420OS_02_03.jpg" alt="Using a Python set"/></span>.</p></div><div class="section" title="Using the for statement with a collection"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>Using the for statement with a collection</h2></div></div></div><p>The <code class="literal">for</code> statement is the<a id="id281" class="indexterm"/> primary tool to iterate through the items in a collection. When working with lists, tuples, or sets, the <code class="literal">for</code> statement will <a id="id282" class="indexterm"/>pleasantly assure that all values in the collection are assigned to the target variable, one at a time. Something like this works out nicely:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; for pounds in cheese:
...     print( pounds )
... 
29.87
etc.
33.51</pre></div><p>The <code class="literal">for</code> statement assigns each item in the cheese sequence to the target variable. We simply print each value from the collection.</p><p>When working with the list-of-tuples structures, we can do something a bit more interesting, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; for year, pounds in year_cheese:
...     print( year, pounds )
... 
2000 29.87
etc.
2012 33.51</pre></div><p>In this example, each two-tuple was decomposed, and the two values were assigned to the target variables, <code class="literal">year</code> and <code class="literal">pounds</code>.</p><p>We can leverage this when transforming a <code class="literal">Count</code> object into percentages. Let's look at our <code class="literal">digram_count</code> collection:</p><div class="informalexample"><pre class="programlisting">total= sum( digram_count.values() )
for digram, count in digram_count.items():
    print( "{:2s} {:7d} {:.3%}".format(digram, count, count/total) )</pre></div><p>First, we computed the sum of the values in the collection. This is the total number of digrams found in the original corpus. In this example, it was 2,021,337. Different corpora will have different numbers of digrams.</p><p>The <code class="literal">for</code> statement iterates through the sequence created by <code class="literal">digram_count.items()</code>. The <code class="literal">items()</code> method produces a sequence of two-tuples with the key and value. We assign these to two target variables: <code class="literal">digram</code> and <code class="literal">count</code>. We can then produce a nicely formatted table of all 620 digrams, their counts, and their relative frequency. </p><p>This is the kind of thing that the folks in the crypto department love.</p><p>When we apply the <code class="literal">for</code> statement to a dictionary directly, it iterates just over the keys. We could use<a id="id283" class="indexterm"/> something like this to iterate through the digram counts:</p><div class="informalexample"><pre class="programlisting">for digram in digram_count:
    print( digram, digram_count[digram], digram_count[digram]/total )</pre></div><p>The target variable, <code class="literal">digram</code>, is assigned<a id="id284" class="indexterm"/> to each key. We can then use a syntax such as <code class="literal">digram_count[digram]</code> to extract the value for this key.</p></div><div class="section" title="Using Python operators on collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>Using Python operators on collections</h2></div></div></div><p>Some of the mathematical operators work with collections. We<a id="id285" class="indexterm"/> can use the <code class="literal">+</code> and <code class="literal">*</code> operators with sequences such as lists and tuples, as shown<a id="id286" class="indexterm"/> in the following code:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; [2, 3, 5, 7] + [11, 13, 17]
[2, 3, 5, 7, 11, 13, 17]
&gt;&gt;&gt; [2, 3, 5, 7] * 2
[2, 3, 5, 7, 2, 3, 5, 7]
&gt;&gt;&gt; [0]*10
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</pre></div><p>These examples showed how we can concatenate two lists and multiply a list to create a longer list with multiple copies of the original list. The  <code class="literal">[0]*10</code> statement shows a more useful technique to initialize a list to a fixed number of values.</p><p>Sets have a number of <a id="id287" class="indexterm"/>operators for union (<code class="literal">|</code>), intersection (<code class="literal">&amp;</code>), difference (<code class="literal">-</code>), and <a id="id288" class="indexterm"/>symmetric difference (<code class="literal">^</code>). Also, the <a id="id289" class="indexterm"/>comparison operators<a id="id290" class="indexterm"/> are redefined to work as subset or superset comparisons. Here are some examples:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; {2, 3, 5, 7} | {5, 7, 11, 13, 17}
{2, 3, 5, 7, 11, 13, 17}
&gt;&gt;&gt; {2, 3, 5, 7} &amp; {5, 7, 11, 13, 17}
{5, 7}
&gt;&gt;&gt; {2, 3, 5, 7} - {5, 7, 11, 13, 17}
{2, 3}
&gt;&gt;&gt; {2, 3, 5, 7} ^ {5, 7, 11, 13, 17}
{2, 3, 11, 13, 17}
&gt;&gt;&gt; {2, 3} &lt;= {2, 5, 7, 3, 11}
True</pre></div><p>The union operator, <code class="literal">|</code>, combines the two sets. A set means an element only occurs once, so there are no duplicated elements in the union of the sets. The intersection of two sets, <code class="literal">&amp;</code>, is the set of common elements in the two sets. The subtraction operator, <code class="literal">-</code>, removes elements from the set on the left-hand side. The symmetric difference operator, <code class="literal">^</code>, creates a new set that has elements which are in one or the other set but not both; essentially, it is the same<a id="id291" class="indexterm"/> as an exclusive <code class="literal">OR</code>.</p><p>We showed just one <a id="id292" class="indexterm"/>comparison operator, the <code class="literal">&lt;=</code> subset operator, between two sets. The other comparison operators perform just as can be expected.</p></div></div>
<div class="section" title="Solving problems &#x2013; currency conversion rates"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Solving problems – currency conversion rates</h1></div></div></div><p>The problem we have is<a id="id293" class="indexterm"/> that our informants are always asking for odd or unusual currencies. This isn't really all that surprising; we're dealing with spies and criminals on the run. They always seem to need obscure foreign currencies for their own nefarious projects.</p><p>We can get a big pile of international exchange rates using a piece of code like the following:</p><div class="informalexample"><pre class="programlisting">    query_exchange_rates= "http://www.coinbase.com/api/v1/currencies/exchange_rates/"

    with urllib.request.urlopen( query_exchange_rates ) as document:
        pprint.pprint( document.info().items() )
        exchange_rates= json.loads( document.read().decode("utf-8") )</pre></div><p>The query string is a simple URL. When we make the request, we get back a long string of bytes. We decode this to make a proper string and use <code class="literal">json.loads()</code> to build a Python object.</p><p>The problem is that we get a giant dictionary object that's not really all that useful. It looks like this:</p><div class="informalexample"><pre class="programlisting">{'aed_to_btc': '0.000552',
 'aed_to_usd': '0.272246',
 'afn_to_btc': '3.6e-05',
 'afn_to_usd': '0.01763',</pre></div><p>Also, it goes on and on for 632 different combinations of currencies.</p><p>The keys to this mapping involve two currencies separated by <code class="literal">_to_</code> and written in lowercase letters. The currency code pieces that we got in the earlier example (see the <span class="emphasis"><em>Using a REST API in Python</em></span> section) are in uppercase. We got a bit of work on our hands to match this data up properly.</p><p>We need to break this long list of currencies down into sublists. The neat way to handle this is with a dictionary of lists. We can use the <code class="literal">defaultdict</code> class to build these lists. Here's a typical approach:</p><div class="informalexample"><pre class="programlisting">    from collections import defaultdict
    rates = defaultdict(list)
    for conversion, rate in exchange_rates.items():
        source, _, target = conversion.upper().partition("_TO_")
        rates[source].append( (target, float(rate)) )</pre></div><p>We set the <code class="literal">rates</code> variable to be a <code class="literal">defaultdict(list)</code> object. When a key is not found in this dictionary, an empty list will be built as the value for that missing key.</p><p>We can iterate through each conversion and rate in the <code class="literal">items()</code> method of the raw data. We'll convert the conversion<a id="id294" class="indexterm"/> string to uppercase and then partition the conversion on the <code class="literal">_TO_</code> string. This will separate the two currency codes, assigning them to <code class="literal">source</code> and <code class="literal">target</code>. As they're uppercase, we can also match them against our list of currency-to-country codes.</p><p>We also converted the rate from a string to a more useful <code class="literal">float</code> number. The string isn't useful for further calculations.</p><p>We can then accumulate a list for each currency within the <code class="literal">rates</code> dictionary. If the <code class="literal">source</code> currency exists, we'll append it to the list that's already present in the dictionary. If the <code class="literal">source</code> currency doesn't exist, we'll create an empty list and append it to that empty list. </p><p>We'll append a target currency and the conversion rate as a simple two-tuple.</p><p>When we're done, we'll have tidy, short lists. Here's how we can pick a few currencies and display the conversions:</p><div class="informalexample"><pre class="programlisting">    for c in 'USD', 'GBP', 'EUR':
        print( c, rates[c] )</pre></div><p>For a select few currencies, we printed the currency and the list of conversion rates available right now.</p><p>This shows us results like the following:</p><div class="informalexample"><pre class="programlisting">GBP [('BTC', 0.003396), ('USD', 1.682624)]
EUR [('BTC', 0.002768), ('USD', 1.371864)]</pre></div><p>The <code class="literal">USD</code> list is rather large, as it includes 159 other countries and currencies. </p><p>As we got the currency details from our earlier query, we can do this to make our output a little more useful:</p><div class="informalexample"><pre class="programlisting">    currency_details = dict( (code,name) for name,code in currencies )
    for c in 'USD', 'GBP', 'EUR':
        print( currency_details[c], rates[c] )  </pre></div><p>We built a dictionary that maps a currency code to the full name for the currency. When we look up the details for a currency, our output looks a little nicer, as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">British Pound (GBP) [('USD', 1.682624), ('BTC', 0.003407)]
Euro (EUR) [('USD', 1.371864), ('BTC', 0.002778)]</pre></div><p>This is the kind of thing that can help us convert the bribe amounts into budget numbers that the accountants at HQ will find useful. We can also use this information to send national assessments<a id="id295" class="indexterm"/> based on the value of the local currency.</p><p>Also, we can use this for our own purposes to buy and sell bitcoins. This might help keep us one step ahead of international chaos. Alternatively, it may help us leverage the advantages of crypto currency.</p><p>We can save our currency details to a file using <code class="literal">json.dump(currency_details, some_open_file)</code>. See the example in the <span class="emphasis"><em>Saving our data via JSON</em></span> section for a refresher on how this is done.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we saw the basics of using Python to access data available on the WWW. We used the HTTP protocol and the FTP protocol to transfer files around. We can use HTTPS and FTPS to assure that our data is kept secret.</p><p>We looked at using RESTful web services to gather data from information sources that have a defined API. RESTful web services are available for many kinds of data. They allow us to gather and analyze data from a variety of sources without a lot of tedious, error-prone pointing and clicking.</p><p>We also saw how to work with the various Python collections: lists, tuples, dictionaries, and sets. This gives us ways to capture and manage larger collections of information.</p><p>We looked at the JSON notation for Python objects. This is a handy way to transmit objects through the WWW. It's also handy for saving objects locally on our personal computer.</p><p>In the next chapter, we'll look at how we can work with image files. These are a bit more complex than JSON files, but the Python <code class="literal">pillow</code> package makes them easy to work with. We'll specifically use image files as a way to transmit hidden messages.</p><p>In <a class="link" href="ch04.html" title="Chapter 4. Drops, Hideouts, Meetups, and Lairs">Chapter 4</a>, <span class="emphasis"><em>Drops, Hideouts, Meetups, and Lairs</em></span>, we'll expand on the web services we saw in this chapter. We'll use geocoding web services and extract data from more complex online datasets.</p></div></body></html>