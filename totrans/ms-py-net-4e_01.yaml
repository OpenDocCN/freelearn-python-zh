- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Review of TCP/IP Protocol Suite and Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP协议集和Python的回顾
- en: Welcome to the new and exciting age of network engineering! When I started working
    as a network engineer at the turn of the millennium some 20 years ago, the role
    was distinctly different than the network engineering role of today. At the time,
    network engineers mainly possessed domain-specific knowledge to manage and operate
    local and wide area networks using the command-line interface. While they might
    occasionally cross over the discipline wall to handle tasks normally associated
    with systems administration and developers, there was no explicit expectation
    for a network engineer to write code or understand programming concepts. This
    is no longer the case today.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到网络工程的新兴和激动人心的时代！当我20年前在世纪之交开始作为网络工程师工作时，这个角色的性质与今天的网络工程师角色截然不同。当时，网络工程师主要拥有特定领域的知识，使用命令行界面来管理和操作本地和广域网络。虽然他们偶尔会跨越学科界限来处理通常与系统管理和发展相关联的任务，但并没有明确期望网络工程师编写代码或理解编程概念。这种情况现在已经不再存在。
- en: Over the years, the DevOps and **Software–Defined Networking** (**SDN**) movement,
    among other factors, have significantly blurred the lines between network engineers,
    systems engineers, and developers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，DevOps和**软件定义网络（SDN**）运动等因素，以及其他因素，已经极大地模糊了网络工程师、系统工程师和开发者之间的界限。
- en: The fact that you have picked up this book suggests that you might already be
    an adopter of network DevOps, or maybe you are considering going down that path
    of checking out network programmability. Maybe you have been working as a network
    engineer for many years, just as I had, and wanted to know what the buzz around
    the Python programming language is all about. You might even already have been
    fluent in the Python programming language but wonder what its applications are
    in the network engineering field.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择这本书的事实表明，你可能已经是一名网络DevOps的采用者，或者你可能在考虑探索网络可编程性的道路。也许你像我一样，已经作为网络工程师工作了多年，并想知道围绕Python编程语言的炒作是什么。你可能甚至已经精通Python编程语言，但想知道它在网络工程领域的应用。
- en: 'If you fall into any of these camps or are simply just curious about Python
    in the network engineering field, I believe this book is for you:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你属于以下任何一类，或者只是对网络工程领域的Python感兴趣，我相信这本书适合你：
- en: '![Diagram, venn diagram  Description automatically generated](img/B18403_01_01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图，维恩图，自动生成描述](img/B18403_01_01.png)'
- en: 'Figure 1.1: The intersection between Python and network engineering'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：Python和网络工程的交集
- en: There are already many great books written that dive into the topics of network
    engineering and Python separately. I do not intend to repeat their efforts with
    this book. Instead, this book assumes you have some hands-on experience in managing
    networks, as well as a basic understanding of network protocols. It’s helpful
    if you’re already familiar with Python as a programming language, but you do not
    need to be an expert. We will cover some Python basics later in the chapter as
    a baseline of Python knowledge. Again, you do not need to be an expert in Python
    or network engineering to read this book. This book intends to build on the basic
    foundations of network engineering and Python to help readers learn and practice
    various applications that can make their lives easier.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有许多优秀的书籍分别深入探讨了网络工程和Python这两个主题。我并不打算用这本书重复他们的努力。相反，这本书假设你已经有一些实际操作网络的经验，以及对于网络协议的基本理解。如果你已经熟悉Python作为编程语言，这将很有帮助，但你不需要成为专家。我们将在本章后面覆盖一些Python基础知识，作为Python知识的起点。再次强调，你不需要在Python或网络工程方面成为专家就能阅读这本书。这本书旨在建立在网络工程和Python的基本基础上，帮助读者学习和实践各种可以使他们的生活更轻松的应用。
- en: In this chapter, we will do a general review of some networking and Python concepts.
    The rest of the chapter should set the level of expectation of the prior knowledge
    required to get the most out of this book. If you want to brush up on the contents
    of this chapter, there are lots of free or low-cost resources to bring you up
    to speed. I would recommend the free Khan Academy ([https://www.khanacademy.org/](https://www.khanacademy.org/))
    and the official Python tutorials from the Python Software Foundation at [https://www.python.org/](https://www.python.org/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对一些网络和Python概念进行一般性回顾。本章的其余部分应该设定了为了充分利用本书所需的前置知识水平。如果您想复习本章的内容，有许多免费或低成本的资源可以帮助您跟上进度。我推荐免费的Khan
    Academy（[https://www.khanacademy.org/](https://www.khanacademy.org/)）和Python软件基金会提供的官方Python教程，网址为[https://www.python.org/](https://www.python.org/)。
- en: This chapter will pay a very quick visit to the relevant networking topics at
    a high level without going too much into the details. There is simply not enough
    space in one chapter to do a deep dive on any of the topics. To be honest, most
    of us do not get to a deep level when doing day-to-day jobs. What is the level
    of required networking knowledge? Judging from my experience of working in the
    field, a typical network engineer or developer might not remember the exact **Transmission
    Control Protocol** (**TCP**) state machine to accomplish their daily tasks (I
    know I don’t), but they would be familiar with the basics of the **Open Systems
    Interconnection** (**OSI**) model, the TCP and **User Datagram Protocol** (**UDP**)
    operations, different IP header fields, and other fundamental concepts. That is
    what we will cover in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将以非常快速的方式对相关网络主题进行高层次回顾，而不会过多涉及细节。在一章中深入探讨任何主题都实在没有足够的空间。说实话，我们在日常工作中很少能达到深入的水平。需要多少网络知识水平？根据我在该领域的经验，典型的网络工程师或开发者可能不会记住用于完成日常任务的精确的**传输控制协议**（**TCP**）状态机（我知道我不会），但他们会对**开放系统互联**（**OSI**）模型的基本知识、TCP和**用户数据报协议**（**UDP**）操作、不同的IP头部字段和其他基本概念熟悉。这正是我们将在本章中涵盖的内容。
- en: We will also look at a high-level review of the Python language first; just
    enough for those readers who do not code in Python daily to have ground to walk
    on for the rest of the book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将首先对Python语言进行高层次回顾；对于那些不每天使用Python编码的读者来说，这将为他们提供全书的基础。
- en: 'Specifically, we will cover the following topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: An overview of the Internet
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网概述
- en: The OSI and client-server model
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSI和客户端-服务器模型
- en: TCP, UDP, and IP protocol suites
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP、UDP和IP协议族
- en: Python syntax, types, operators, and loops
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python语法、类型、运算符和循环
- en: Extending Python with functions, classes, and packages
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数、类和包扩展Python
- en: Of course, the information presented in this chapter is not exhaustive; please
    check out the references for further information if required.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，本章中提供的信息并不全面；如果需要更多信息，请查阅参考文献。 '
- en: As network engineers, often we are challenged by the scale and complexity of
    the networks we need to manage. They range from small home-based networks, medium-size
    networks that make a small business go, to large multi-national enterprise networks
    spanning across the globe. The most extensive network of them all is, of course,
    the Internet. Without the Internet, there would be no email, websites, API, streaming
    media, or cloud computing as we know it. Therefore, before we dive deeper into
    the specifics of protocols and Python, let us begin with an overview of the Internet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网络工程师，我们常常面临着需要管理的网络的规模和复杂性的挑战。这些网络从小型的家庭网络，到支持小型企业运营的中型网络，再到覆盖全球的大型跨国企业网络，种类繁多。其中最广泛的网络当然是互联网。没有互联网，就没有我们现在所知道的电子邮件、网站、API、流媒体或云计算。因此，在我们深入探讨协议和Python的具体细节之前，让我们先对互联网有一个概述。
- en: An overview of the Internet
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网概述
- en: What is the Internet? This seemingly easy question might receive different answers
    depending on each of our backgrounds. The Internet means different things to different
    people; the young, the old, students, teachers, business people, and poets could
    all give different answers to the same question.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网是什么？这个看似简单的问题可能会因每个人的背景不同而得到不同的答案。互联网对不同的人意味着不同的事情；年轻人、老年人、学生、教师、商人和诗人可能都会对同一个问题给出不同的答案。
- en: To a network engineer, the Internet is a global computer network consisting
    of a web of inter-networks connecting large and small networks together. In other
    words, it is *a network of networks without a centralized owner*. Take your home
    network as an example. It might consist of a device that integrates the functions
    of routing, Ethernet switching, and wireless access points connecting your smartphones,
    tablets, computers, and internet-enabled TVs together for the devices to communicate
    with each other. This is your **Local Area Network** (**LAN**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络工程师来说，互联网是一个全球计算机网络，由一个连接大型和小型网络的互联网网络组成。换句话说，它是一个没有集中所有者的**网络网络**。以你的家庭网络为例。它可能由一个集成了路由、以太网交换和无线接入点功能的设备组成，将你的智能手机、平板电脑、电脑和互联网电视连接在一起，以便这些设备相互通信。这就是你的**局域网**（**LAN**）。
- en: When your home network needs to communicate with the outside world, it passes
    information from your LAN to a larger network, often appropriately named the **Internet
    Service Provider** (**ISP**). The ISP is typically thought of as a business that
    you pay to get online. They can do this by aggregating small networks into bigger
    networks that they maintain.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的家庭网络需要与外界通信时，它将信息从你的LAN传递到一个更大的网络，通常被称为**互联网服务提供商**（**ISP**）。ISP通常被认为是一家你付费上网的业务。他们可以通过将小型网络聚合到他们维护的更大网络中来做到这一点。
- en: Your ISP network often consists of many edge nodes that aggregate the traffic
    to their core network. The core network’s function is to interconnect these edge
    networks via a high-speed network.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你的ISP网络通常由许多边缘节点组成，这些节点将流量聚合到其核心网络。核心网络的功能是通过高速网络将这些边缘网络相互连接。
- en: At some of the more specialized edge nodes, called Internet exchange points,
    your ISP is connected to other ISPs to pass your traffic appropriately to your
    destination. The return path from your destination to your home computer, tablet,
    or smartphone may or may not follow the same path through all these in-between
    networks back to your original device, while the source and destination remain
    the same. This asymmetrical behavior is designed to be fault-tolerant so that
    no one node can take down the whole connection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些称为互联网交换点的更专业化的边缘节点中，你的ISP连接到其他ISP，以便将你的流量适当地传递到目的地。从你的目的地到你的家用电脑、平板电脑或智能手机的返回路径可能或可能不会通过所有这些中间网络返回到你的原始设备，而源和目的地保持不变。这种不对称行为旨在具有容错性，以便没有任何一个节点可以关闭整个连接。
- en: Let’s look at the components making up this web of networks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看构成这个网络网络的组件。
- en: Servers, hosts, and network components
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器、主机和网络组件
- en: '**Hosts** are end nodes on the network that communicate with other nodes. In
    today’s world, a host can be a traditional computer, or it can be your smartphone,
    tablet, or TV. With the rise of the **Internet of Things** (**IoT**), the broad
    definition of a host can be expanded to include an **Internet Protocol** (**IP**)
    camera, TV set-top boxes, and the ever-increasing types of sensors we use in agriculture,
    farming, automobiles, and more. With the explosion of the number of hosts connected
    to the Internet, they all need to be addressed, routed, and managed. The demand
    for proper networking has never been greater.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机**是网络上的终端节点，与其他节点进行通信。在当今世界，一个主机可以是一台传统计算机，也可以是你的智能手机、平板电脑或电视。随着**物联网**（**IoT**）的兴起，主机的广泛定义可以扩展到包括**互联网协议**（**IP**）摄像头、机顶盒以及我们在农业、农业、汽车等领域使用的不断增多的传感器。随着连接到互联网的主机数量的激增，它们都需要被寻址、路由和管理。对适当网络的需求从未如此之大。'
- en: Most of the time when we are on the Internet, we make requests for services.
    This could be viewing a web page, sending or receiving emails, transferring files,
    and other online activities. These services are provided by **servers**. As the
    name implies, servers provide services to multiple nodes and generally have higher
    levels of hardware specification. In a way, servers are particular “super nodes”
    on the network that offer additional capabilities to their peers. We will look
    at servers again later, in the *The client-server model* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们在互联网上都是进行服务请求。这可能包括浏览网页、发送或接收电子邮件、传输文件以及其他在线活动。这些服务都是由**服务器**提供的。正如其名所示，服务器为多个节点提供服务，通常具有更高的硬件规格。从某种意义上说，服务器是网络上的特定“超级节点”，为其他节点提供额外的功能。我们将在*客户端-服务器模型*部分再次探讨服务器。
- en: If you think of servers and hosts as cities and towns, the *network components*
    are the roads and highways that connect them together. In fact, the term information
    superhighway comes to mind when describing the network components that transmit
    the ever-increasing bits and bytes across the globe. In the Seven-Layer OSI model
    that we will look at in *The OSI model*, these network components are layer-one
    to layer-three devices that sometimes venture into layer four as well. They are
    layer-two and layer-three routers and switches that direct traffic, as well as
    layer-one transports such as fiber optic cables, coaxial cables, twisted copper
    pairs, and some **Dense Wavelength Division Multiplexing** (**DWDM**) equipment,
    to name a few.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把服务器和主机看作城市和城镇，那么网络组件就是连接它们的道路和高速公路。实际上，当我们描述传输全球不断增长的比特和字节的网络组件时，信息高速公路这个词就会浮现在脑海中。在我们将要探讨的*OSI模型*的七层OSI模型中，这些网络组件是一层到三层设备，有时甚至涉及到四层。它们是二层和三层的路由器和交换机，负责引导流量，以及一层传输设备，如光纤电缆、同轴电缆、绞合铜对，以及一些**密集波分复用**（**DWDM**）设备等。
- en: Collectively, hosts, servers, storage, and network components make up the internet
    as we know it today.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，主机、服务器、存储和网络组件共同构成了我们今天所知道的互联网。
- en: The rise of data centers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据中心的兴起
- en: 'In the last section, we looked at the different roles that servers, hosts,
    and network components play in the inter-network. Because of the higher hardware
    capacity that servers demand, they are often put together in a central location
    to be managed more efficiently. We often refer to these locations as data centers.
    They can generally be classified into three broad categories:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了服务器、主机和网络组件在网络中的作用。由于服务器对硬件容量的要求更高，它们通常被放置在中央位置以更有效地管理。我们通常将这些地点称为数据中心。它们通常可以分为三大类：
- en: Enterprise data centers
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业数据中心
- en: Cloud data centers
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云数据中心
- en: Edge data centers
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘数据中心
- en: Let us take a look at enterprise data centers first.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看企业数据中心。
- en: Enterprise data centers
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业数据中心
- en: In a typical enterprise, the company generally has business needs for internal
    tools such as emailing, document storage, sales tracking, ordering, HR tools,
    and a knowledge-sharing intranet. These services become file and mail servers,
    database servers, and web servers. Unlike user computers, these are generally
    high-end computers that require higher power, cooling, and high bandwidth network
    connections. A byproduct of the hardware is also the amount of noise it makes,
    which is not suitable for a normal workspace. The servers are generally placed
    in a central location, called the **Main Distribution Frame** (**MDF**), in the
    enterprise building to provide the necessary power feed, power redundancy, cooling,
    and network connectivity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的企业中，公司通常有对内部工具的需求，如电子邮件、文档存储、销售跟踪、订购、人力资源工具和知识共享内联网。这些服务成为文件和邮件服务器、数据库服务器和Web服务器。与用户计算机不同，这些通常是高端计算机，需要更高的电力、冷却和高带宽网络连接。硬件的副产品还包括它产生的噪音量，这在正常的工作空间中是不合适的。服务器通常放置在企业建筑中的中央位置，称为**主配线架**（**MDF**），以提供必要的电源供应、电源冗余、冷却和网络连接。
- en: To connect to the MDF, the user’s traffic is generally aggregated at locations
    closer to the user, which are sometimes called the **Intermediate Distribution
    Frame** (**IDF**), before they are bundled up and connected to the MDF. It is
    not unusual for the IDF-MDF spread to follow the physical layout of the enterprise
    building or campus. For example, each building floor can consist of an IDF that
    aggregates to the centralized MDF on another floor in the same building. If the
    enterprise consists of several buildings, further aggregation can be done by combining
    the buildings’ traffic before connecting them to the enterprise data center.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到MDF，用户的流量通常在更靠近用户的位置进行聚合，这些位置有时被称为**中间配线架**（**IDF**），然后它们被捆绑并连接到MDF。IDF-MDF的扩展通常遵循企业建筑或校园的物理布局，这是很常见的。例如，每层楼可以由一个IDF组成，它将流量聚合到同一建筑另一层的集中式MDF。如果企业由几座建筑组成，可以在将它们连接到企业数据中心之前，通过组合建筑流量进行进一步的聚合。
- en: Many enterprise data centers (sometimes referred to as campus networks) follow
    the three-layer network design. The layers are the access layer, the distribution
    layer, and the core layer. Of course, as with any design, there are no hard rules
    or one-size-fits-all model; the three-layer designs are just a general guide.
    As an example, to overlay the three-layer design to our User-IDF-MDF example earlier,
    the access layer is analogous to the ports each user connects to, the IDF can
    be thought of as the distribution layer, while the core layer consists of the
    connection to the MDF and the enterprise data centers. This is, of course, a generalization
    of enterprise networks, as some of them will not follow the same model.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业数据中心（有时被称为校园网络）遵循三层网络设计。这些层级包括接入层、分发层和核心层。当然，与任何设计一样，没有硬性规则或一刀切的模式；三层设计只是一个一般性的指导。以我们之前提到的User-IDF-MDF为例，接入层相当于每个用户连接的端口，IDF可以被视为分发层，而核心层则由连接到MDF和企业数据中心的连接组成。这当然是对企业网络的一种概括，因为其中一些不会遵循相同的模式。
- en: Cloud data centers
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云数据中心
- en: With the rise of cloud computing and software, or **Infrastructure as a Service**
    (**IaaS**), the data centers the cloud providers have built are big in scale,
    sometimes referred to as hyper-scale data centers. What we referred to as cloud
    computing is the on-demand availability of computing resources offered by the
    likes of Amazon AWS, Microsoft Azure, and Google Cloud without the user having
    to manage the resources directly. Many web-scale service providers, such as Facebook,
    can also be grouped into this category.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算和软件，或**基础设施即服务**（**IaaS**）的兴起，云服务提供商建立的数据中心规模庞大，有时被称为超大规模数据中心。我们所说的云计算是指由亚马逊AWS、微软Azure和谷歌云等提供的按需计算资源可用性，而用户无需直接管理这些资源。许多网络规模的服务提供商，如Facebook，也可以归入这一类别。
- en: Because of the number of servers they need to house, cloud data centers generally
    demand a much, much higher capacity of power, cooling, and network capacity than
    any enterprise data center. Even after working on cloud providers’ data centers
    for many years, every time I visit a cloud provider’s data center, I am still
    amazed at their scale. Just to give examples of their sheer scale, cloud data
    centers are so big and power-hungry that they are typically built close to power
    plants where they can get the cheapest power rate, without losing too much efficiency
    during the transportation of the power. Their cooling needs are so high that some
    are forced to be creative about where the data center is built. Facebook, for
    example, has built its Lulea data center in northern Sweden (just 70 miles south
    of the Arctic Circle) in part to leverage the cold temperature for cooling. Any
    search engine can give you some astounding numbers when it comes to the science
    of building and managing cloud data centers for the likes of Amazon, Microsoft,
    Google, and Facebook. The Microsoft data center in West Des Moines, Iowa, for
    example, consisted of 1.2 million square feet of the facility on 200 acres of
    land and required the city to spend an estimated $65 million in public infrastructure
    upgrades.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于他们需要容纳的服务器数量，云数据中心通常需要比任何企业数据中心都要高得多的电力、冷却和网络容量。即使在我为云服务提供商的数据中心工作了多年之后，每次我访问云服务提供商的数据中心，我仍然对其规模感到惊讶。仅举几个例子来说明其规模之大，云数据中心如此之大，能耗如此之高，通常建在靠近发电厂的地方，以便在电力运输过程中损失效率最小化。它们的冷却需求如此之高，以至于一些数据中心不得不在建设地点上发挥创意。例如，Facebook在瑞典北部的吕勒奥（北极圈以南70英里）建立了其数据中心，部分原因是为了利用低温进行冷却。任何搜索引擎都可以提供一些令人惊叹的数字，当涉及到像亚马逊、微软、谷歌和Facebook这样的公司建造和管理云数据中心时。例如，位于爱荷华州西得梅因的微软数据中心占地200英亩，设施面积为120万平方英尺，需要该市花费估计6500万美元的公共基础设施升级费用。
- en: At the cloud provider scale, the services they need to provide are generally
    not cost-effective or feasible to be housed in a single server. The services are
    spread between a fleet of servers, sometimes across many racks, to provide redundancy
    and flexibility for service owners.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在云服务提供商的规模下，他们需要提供的服务通常不划算，也不可能在单个服务器中实现。这些服务分布在多台服务器之间，有时跨越多个机架，为服务所有者提供冗余和灵活性。
- en: 'The latency and redundancy requirements, as well as the physical spread of
    servers, put a tremendous amount of pressure on the network. The interconnections
    required to connect the server fleets equate to an explosive growth of network
    equipment such as cables, switches, and routers. These requirements translate
    into the amount of equipment that needs to be racked, provisioned, and managed.
    A typical network design would be a multi-staged Clos network:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟和冗余需求，以及服务器的物理分布，给网络带来了巨大的压力。连接服务器编队的互连相当于网络设备（如电缆、交换机和路由器）的爆炸性增长。这些需求转化为需要上架、配置和管理设备的数量。典型的网络设计将是多阶段Clos网络：
- en: '![](img/B18403_01_02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Clos网络图](img/B18403_01_02.png)'
- en: 'Figure 1.2: Clos network'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：Clos网络
- en: In a way, cloud data centers and the increasing adaptions in other networks
    are where network automation becomes a necessity for the speed, flexibility, and
    reliability automation can provide. If we follow the traditional way of managing
    network devices via a Terminal and command-line interface, the number of engineering
    hours required will not allow the service to be available in a reasonable amount
    of time. Not to mention that human repetition is error-prone, inefficient, and
    a terrible waste of engineering talent. To add further complexity, there is often
    the need to quickly change some of the network configurations to accommodate rapidly
    changing business needs, such as redesigning a three-tier campus network into
    a CLOS-based topology.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，云数据中心和其他网络中不断增加的适应性使得网络自动化成为必要，因为自动化可以提供速度、灵活性和可靠性。如果我们遵循通过终端和命令行界面管理网络设备的传统方式，所需的工程小时数将不允许在合理的时间内提供服务。更不用说人为的重复是易出错的、低效的，并且是对工程人才的巨大浪费。再加上复杂性，通常需要快速更改一些网络配置以适应快速变化的业务需求，例如将三层校园网络重新设计为基于CLOS的拓扑结构。
- en: Personally, cloud data center networking is where I started my path of network
    automation with Python several years ago, and I’ve never looked back since.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，云计算数据中心网络是我几年前开始使用Python进行网络自动化的起点，从那时起我就再也没有回头了。
- en: Edge data centers
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边缘数据中心
- en: If we have sufficient computing power at the data center level, why keep anything
    else but at these data centers? All the connections from clients worldwide can
    be routed back to the data center servers, and we can call it a day, right? The
    answer, of course, depends on the use case. The most significant limitation in
    routing the request and session all the way back from the client to a large data
    center is the latency introduced in the transport. In other words, significant
    latency is where the network becomes a bottleneck.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在数据中心级别拥有足够的计算能力，为什么还要在其他地方保留任何东西呢？全球客户的所有连接都可以路由回数据中心服务器，然后我们可以结束一天的工作，对吧？当然，答案取决于用例。将请求和会话从客户端完全路由回大型数据中心的最大限制是传输中引入的延迟。换句话说，显著的延迟就是网络成为瓶颈的地方。
- en: 'Of course, any elementary physics textbook can tell you that the network latency
    number would never be zero: even as fast as light can travel in a vacuum, it still
    takes time for physical transportation. In the real world, latency would be much
    higher than light in a vacuum. Why? Because the network packet must traverse through
    multiple networks, sometimes through an undersea cable, slow satellite links,
    4G or 5G cellular links, or Wi-Fi connections.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何一本基础物理教科书都可以告诉你，网络延迟的数字永远不会是零：即使光在真空中传播得再快，物理传输也需要时间。在现实世界中，延迟会比真空中的光还要高。为什么？因为网络数据包必须穿越多个网络，有时是通过海底电缆、缓慢的卫星链路、4G或5G蜂窝链路，或者Wi-Fi连接。
- en: How can we reduce network latency? One solution would be to reduce the number
    of networks the end-user requests traverse through. We can try to be as closely
    connected to the end-user as possible, perhaps meeting the user at the edge where
    the requests enter our network. We can place enough resources at these edge locations
    to serve the request. This is especially common for servicing media content such
    as music and videos.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何减少网络延迟？一个解决方案是减少终端用户请求穿越的网络数量。我们可以尽量靠近终端用户，也许在请求进入我们网络的边缘与用户会合。我们可以在这些边缘位置放置足够的资源来处理请求。这在服务媒体内容，如音乐和视频时尤其常见。
- en: Let’s take a minute and imagine that you are building the next generation of
    video streaming services. To increase customer satisfaction with smooth streaming,
    you would want to place the video server as close to the customer as possible,
    either inside or very near to the customer’s ISP. Also, for redundancy and connection
    speed, the upstreaming of the video server farm would not just be connected to
    one or two ISPs, but all the ISPs that we can connect to reduce the hop count,
    thus reducing the number of devices we need to pass thru. All the connections
    would have as much bandwidth as needed to decrease peak-hour latency. This need
    gave rise to the peering exchange’s edge data centers of big ISP and content providers.
    Even when the number of network devices is not as high as cloud data centers,
    they too can benefit from network automation in terms of the increased reliability,
    flexibility, security, and visibility network automation brings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟时间想象一下，你正在构建下一代视频流媒体服务。为了提高流畅播放的客户满意度，你希望将视频服务器尽可能放置在客户附近，无论是内部还是客户互联网服务提供商（ISP）附近。此外，为了冗余和连接速度，视频服务器农场的上行链路不仅连接到一两个ISP，而是连接到我们可以连接的所有ISP，以减少跳数，从而减少我们需要通过设备的数量。所有连接都将拥有所需的带宽，以降低高峰时段的延迟。这种需求催生了大型ISP和内容提供商的互连交换边缘数据中心。即使网络设备的数量不如云数据中心高，它们也能从网络自动化中受益，包括提高可靠性、灵活性、安全性和可见性。
- en: If we extend the concept of edge nodes and get creative, we can see that some
    of the latest technologies, such as self-driving cars and **Software-Defined Wide-Area-Networks**
    (**SD-WANs**) are also applications of edge nodes. The self-driving car needs
    to make split-second decisions based on its sensors. SD-WAN routers need to route
    packets locally, without the need to consult a central “brain.” These are all
    concepts of intelligent edge nodes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展边缘节点的概念并发挥创意，我们可以看到一些最新的技术，如自动驾驶汽车和**软件定义广域网（SD-WANs**）也是边缘节点的应用。自动驾驶汽车需要根据其传感器做出瞬间决策。SD-WAN路由器需要本地路由数据包，而不需要咨询中央“大脑”。这些都是智能边缘节点的概念。
- en: As with many complex subjects, we can tackle the complexity by dividing the
    subject into smaller digestible pieces. Networking breaks the complexity by using
    layers to model the functions of its elements. Over the years, there have been
    different networking models. We will look at two of the most important models
    in this book, starting with the OSI model.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多复杂主题一样，我们可以通过将主题分解成更小的、易于消化的部分来应对复杂性。网络通过使用层来模拟其元素的功能来分解复杂性。多年来，已经出现了不同的网络模型。在本书中，我们将探讨两个最重要的模型，从OSI模型开始。
- en: The OSI model
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSI模型
- en: No network book is complete without first going over the OSI model. The model
    is a conceptual model that componentizes the telecommunication functions into
    different layers. The model defines seven layers, and each layer sits independently
    on top of another one with defined structures and characteristics.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一本网络书籍会不先介绍OSI模型就完整。该模型是一个概念模型，将电信功能分解为不同的层。该模型定义了七层，每一层都独立地位于另一层之上，具有定义的结构和特征。
- en: 'For example, in the network layer, IP is located on top of the different data
    link layers, such as Ethernet or frame relay. The OSI reference model is a good
    way to normalize different and diverse technologies into a set of common languages
    that people can agree on. This greatly reduces the scope for parties working on
    individual layers and allows them to look at specific tasks in depth without worrying
    too much about compatibility:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在网络层，IP位于不同的数据链路层之上，如以太网或帧中继。OSI参考模型是将不同的和多样化的技术规范化为一套人们可以达成共识的通用语言的好方法。这大大减少了在单个层上工作的各方的工作范围，并允许他们深入查看特定任务，而不必过多担心兼容性：
- en: '![Table  Description automatically generated with medium confidence](img/B18403_01_03.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成，置信度中等](img/B18403_01_03.png)'
- en: 'Figure 1.3: OSI model'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：OSI模型
- en: The OSI model was initially worked on in the late 1970s and was later published
    jointly by the **International Organization for Standardization** (**ISO**), what
    is now known as the **Telecommunication Standardization Sector of the International
    Telecommunication Union** (**ITU-T**). It is widely accepted and commonly referred
    to when introducing a new topic in telecommunication.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型最初在20世纪70年代末开始研究，后来由**国际标准化组织**（**ISO**），现在被称为**国际电信联盟电信标准化部门**（**ITU-T**）联合发布。它在介绍电信新主题时被广泛接受和引用。
- en: Around the same time as the OSI model development, the Internet was taking shape.
    The reference model the original designer used for the Internet is often referred
    to as the TCP/IP model. The TCP and the IP were the original protocol suites contained
    in the design. This is somewhat similar to the OSI model in the sense that they
    divide end-to-end data communication into abstraction layers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSI模型开发的同时，互联网也在形成。最初为互联网设计的参考模型通常被称为TCP/IP模型。TCP和IP是设计中所包含的原始协议套件。从某种程度上说，这与OSI模型相似，因为它们将端到端的数据通信划分为抽象层。
- en: 'What is different in the TCP/IP model is it combines layers 5 to 7 in the OSI
    model in the **Application** layer, while the **Physical** and **Data link** layers
    are combined in the **Link** layer:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP模型的不同之处在于，它将OSI模型中的第5层到第7层合并到**应用层**，而**物理层**和**数据链路层**则合并到**链路层**：
- en: '![](img/B18403_01_04.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_01_04.png)'
- en: 'Figure 1.4: Internet protocol suite'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：互联网协议套件
- en: Both the OSI and TCP/IP models are useful for providing standards for end-to-end
    data communication. We will refer to either the OSI or the TCP/IP model when needed,
    such as when we are discussing the web framework in the upcoming chapters. Just
    like models at the transport layer, there are also reference models that govern
    communication at the application level. In the modern network, the client-server
    model is what most applications are based on. We will look at the client-server
    model in the next section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: OSI和TCP/IP模型都适用于提供端到端数据通信的标准。在需要时，我们将参考OSI或TCP/IP模型，例如在接下来章节讨论网络框架时。就像传输层的模型一样，在应用层也有指导通信的参考模型。在现代网络中，客户端-服务器模型是大多数应用程序的基础。我们将在下一节中探讨客户端-服务器模型。
- en: The client-server model
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器模型
- en: The client-server reference models demonstrated a standard way for data to communicate
    between two nodes. Of course, by now, we all know that not all nodes are created
    equal. Even in the earliest **Advanced Research Projects Agency Network** (**ARPANET**)
    days, there were workstation nodes, and there were server nodes with the purpose
    of providing content to other workstation nodes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器参考模型演示了数据在两个节点之间通信的标准方式。当然，到现在我们都知道，并不是所有的节点都是平等的。即使在最早的**高级研究计划署网络**（**ARPANET**）时期，也存在工作站节点和提供内容给其他工作站节点的服务器节点。
- en: These server nodes typically have higher hardware specifications and are managed
    more closely by engineers. Since these nodes provide resources and services to
    others, they are appropriately referred to as servers. Servers typically sit idle,
    waiting for clients to initiate requests for their resources. This model of distributed
    resources that are requested by the client request is referred to as the client-server
    model.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务器节点通常具有更高的硬件规格，并由工程师更紧密地管理。由于这些节点为其他节点提供资源和服务，因此它们被适当地称为服务器。服务器通常处于空闲状态，等待客户端发起对其资源的请求。这种由客户端请求请求资源的分布式资源模型被称为客户端-服务器模型。
- en: Why is this important? If you think about it for a minute, the importance of
    networking is greatly highlighted by this client-server model. Without the need
    to transfer services between clients and servers, there is not a lot of need for
    network interconnections. It is the need to transfer bits and bytes from the client
    to the server that shines a light on the importance of network engineering. Of
    course, we are all aware of how the biggest network of them all, the Internet,
    has been transforming the lives of all of us and is continuing to do so.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么很重要？如果你稍微思考一下，这种客户端-服务器模型极大地突出了网络的重要性。如果没有在客户端和服务器之间传输服务的需要，那么对网络互连的需求就不大。正是从客户端向服务器传输比特和字节的需要，凸显了网络工程的重要性。当然，我们所有人都清楚，最大的网络——互联网——是如何改变我们所有人的生活的，并且仍在继续这样做。
- en: You might be asking, how can each node determine the time, speed, source, and
    destination every time they need to talk to each other? This brings us to network
    protocols.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，每个节点如何在每次需要互相交流时确定时间、速度、源和目的地？这引出了网络协议的概念。
- en: Network protocol suites
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络协议集
- en: In the early days of computer networking, protocols were proprietary and closely
    controlled by the company that designed the connection method. If you were using
    **Novell’s IPX/SPX** protocol in your hosts, the same hosts would not be able
    to communicate with Apple’s **AppleTalk** hosts, and vice versa. These proprietary
    protocol suites generally have analogous layers to the OSI reference model and
    follow the client-server communication method but are not compatible with each
    other. The proprietary protocols generally only work in LANs that are closed,
    without the need to communicate with the outside world. When traffic does need
    to move beyond the local LAN, typically a protocol translation device, such as
    a router, is used to translate from one protocol to another. For example, to connect
    an AppleTalk-based network to the Internet, a router would be used to connect
    and translate the AppleTalk protocol to an IP-based network. The additional translation
    is usually not perfect, but since most of the communication happened within the
    LAN in the early days, it was accepted by the network administrators.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机网络发展的早期，协议是专有的，并且由设计连接方法的公司严格控制。如果你在你的主机上使用 **Novell 的 IPX/SPX 协议**，那么相同的宿主机将无法与
    Apple 的 **AppleTalk** 宿主机通信，反之亦然。这些专有协议集通常具有与 OSI 参考模型类似的层，并遵循客户端-服务器通信方法，但它们之间不兼容。专有协议通常只在封闭的局域网中工作，无需与外界通信。当流量需要超出本地局域网时，通常使用协议转换设备，如路由器，将一个协议转换为另一个协议。例如，要将基于
    AppleTalk 的网络连接到互联网，就需要使用路由器将 AppleTalk 协议转换为基于 IP 的网络。这种额外的转换通常并不完美，但由于在早期，大部分通信都在局域网内进行，因此网络管理员接受了这一点。
- en: However, as the need for inter-network communication rises beyond the LAN, the
    need for standardizing the network protocol suites becomes greater. The proprietary
    protocols eventually gave way to the standardized protocol suites of TCP, UDP,
    and IP, which greatly enhanced the ability of one network to talk to another.
    The Internet, the greatest network of them all, relies on these protocols to function
    properly. In the next few sections, we will look at each of the protocol suites.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着网络间通信需求超出局域网，对标准化网络协议集的需求变得更加迫切。专有协议最终让位于 TCP、UDP 和 IP 的标准化协议集，这大大增强了网络之间通信的能力。互联网，最大的网络，依赖于这些协议的正常运行。在接下来的几节中，我们将查看每个协议集。
- en: The transmission control protocol
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输控制协议
- en: 'TCP is one of the main protocols used for the Internet today. If you have opened
    a web page or have sent an email, you have come across the TCP protocol. The protocol
    sits at layer 4 of the OSI model, and it is responsible for delivering the data
    segment between two nodes in a reliable and error-checked manner. The TCP consists
    of a 160-bit header that contains, among other fields, source and destination
    ports, a sequence number, an acknowledgment number, control flags, and a checksum:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是今天互联网上使用的主要协议之一。如果你打开了一个网页或者发送了一封电子邮件，你就已经遇到了 TCP 协议。该协议位于 OSI 模型的第 4 层，负责以可靠和错误检查的方式在两个节点之间传递数据段。TCP
    包含一个 160 位的头部，其中包含源和目的端口、序列号、确认号、控制标志和校验和：
- en: '![Table  Description automatically generated](img/B18403_01_05.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成](img/B18403_01_05.png)'
- en: 'Figure 1.5: TCP header'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：TCP 头部
- en: Functions and characteristics of TCP
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 的功能和特性
- en: TCP uses datagram sockets or ports to establish host-to-host communication.
    The standard body, called the **Internet Assigned Numbers Authority** (**IANA**),
    designates well-known ports to indicate certain services, such as `port 80` for
    HTTP (web) and `port 25` for SMTP (mail). The server in the client-server model
    typically listens on one of these well-known ports in order to receive communication
    requests from the client. The TCP connection is managed by the operating system
    with the socket representing the local endpoint for the connection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: TCP使用数据报套接字或端口来建立主机间的通信。被称为**互联网分配数字权威机构**（**IANA**）的标准机构指定了知名端口来指示某些服务，例如`端口80`用于HTTP（网页）和`端口25`用于SMTP（邮件）。在客户端-服务器模型中，服务器通常监听这些知名端口之一，以便接收来自客户端的通信请求。TCP连接由操作系统管理，套接字代表连接的本地端点。
- en: The protocol operation consists of a state machine, which the machine needs
    to keep track of when it is listening for an incoming connection during the communication
    session, as well as releasing resources once the connection is closed. Each TCP
    connection goes through a series of states such as `Listen`, `SYN-SENT`, `SYN-RECEIVED`,
    `ESTABLISHED`, `FIN-WAIT`, `CLOSE-WAIT`, `CLOSING`, `LAST-ACK`, `TIME-WAIT`, and
    `CLOSED`. The different states help in managing the TCP messages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 协议操作由一个状态机组成，该机器在通信会话期间监听传入连接时需要跟踪，以及在连接关闭后释放资源。每个TCP连接都会经过一系列状态，如`Listen`、`SYN-SENT`、`SYN-RECEIVED`、`ESTABLISHED`、`FIN-WAIT`、`CLOSE-WAIT`、`CLOSING`、`LAST-ACK`、`TIME-WAIT`和`CLOSED`。不同的状态有助于管理TCP消息。
- en: TCP messages and data transfer
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP消息和数据传输
- en: The biggest difference between TCP and UDP, which is its close cousin on the
    same layer, is that it transmits data in an ordered and reliable fashion. The
    fact that the TCP operation guarantees delivery is often referred to TCP as a
    connection-oriented protocol. It does this by first establishing a three-way handshake
    to synchronize the sequence number between the transmitter and the receiver, `SYN`,
    `SYN-ACK`, and `ACK`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP之间最大的区别，即它们在同一层上的近亲，是它以有序和可靠的方式传输数据。TCP操作保证交付的事实通常被称为TCP是一个面向连接的协议。它是通过首先建立一个三次握手来同步发送者和接收者之间的序列号，即`SYN`、`SYN-ACK`和`ACK`来实现的。
- en: The acknowledgment is used to keep track of subsequent segments in the conversation.
    Finally, at the end of the conversation, one side will send a `FIN` message, and
    the other side will `ACK` the `FIN` message as well as sending a `FIN` message
    of its own. The `FIN` initiator will then `ACK` the `FIN` message that it received.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 承认（acknowledgment）用于跟踪对话中的后续部分。最后，在对话结束时，一方将发送一个`FIN`消息，而另一方将确认接收到的`FIN`消息，并也发送一个自己的`FIN`消息。然后，`FIN`发起者将确认它接收到的`FIN`消息。
- en: As many of us who have troubleshot a TCP connection can tell you, the operation
    can get quite complex. One can certainly appreciate that, most of the time, the
    operation just happens silently in the background.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如许多调试过TCP连接的人可以告诉你的，操作可能会变得相当复杂。人们当然可以欣赏到，大多数时候，操作只是在后台默默地发生。
- en: A whole book could be written about the TCP protocol; in fact, many excellent
    books have been written on the protocol.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于TCP协议，可以写一本书；事实上，已经有许多关于该协议的优秀书籍被撰写。
- en: As this section is a quick overview, if interested, The *TCP/IP Guide* ([http://www.tcpipguide.com](http://www.tcpipguide.com))
    is an excellent free resource that you can use to dig deeper into the subject.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本节是一个快速概述，如果感兴趣，*TCP/IP指南* ([http://www.tcpipguide.com](http://www.tcpipguide.com))
    是一个优秀的免费资源，你可以用它来深入了解该主题。
- en: The user datagram protocol
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户数据报协议
- en: The UDP is also a core member of the protocol suites used. Like TCP, it operates
    on layer 4 of the OSI model that is responsible for delivering data segments between
    the application and the IP layer. Unlike TCP, the header is only 64 bits, which
    only consists of a source and destination port, length, and checksum. The lightweight
    header makes it ideal for applications that prefer faster data delivery without
    setting up the session between two hosts or needing reliable data delivery. Perhaps
    it’s hard to imagine with today’s fast internet connections, but the lightweight
    header made a big difference to the speed of transmission in the early days of
    `X.21` and frame relay links.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: UDP也是所使用的协议套件的核心成员之一。与TCP一样，它运行在OSI模型的第4层，负责在应用层和IP层之间传递数据段。与TCP不同，其头部只有64位，仅包含源端口、目的端口、长度和校验和。轻量级的头部使其非常适合那些偏好快速数据传输而不需要在两个主机之间建立会话或需要可靠数据传输的应用程序。或许在今天快速互联网连接的背景下难以想象，但轻量级的头部在`X.21`和帧中继链路的早期传输速度上起到了重要作用。
- en: 'Besides the speed difference, not having to maintain various states, such as
    TCP, also saves computer resources on the two endpoints:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了速度差异外，不需要维护各种状态，如TCP，这也节省了两个端点上的计算机资源：
- en: '![](img/B18403_01_06.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_01_06.png)'
- en: 'Figure 1.6: UDP header'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：UDP头部
- en: You might now wonder why UDP was ever used at all in the modern age; given the
    lack of reliable transmissions, wouldn’t we want all the connections to be reliable
    and error-free? If you think about multimedia video streaming or Skype calls,
    those applications benefit from a lighter header when the application just wants
    to deliver the datagram as quickly as possible. You can also consider the fast
    **Domain Name System** (**DNS**) lookup process based on the UDP protocol. The
    tradeoff between accuracy and latency usually tips to the side of low latency.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能想知道为什么在现代社会UDP还被使用；鉴于缺乏可靠传输，我们难道不希望所有连接都是可靠且无错误的吗？如果你考虑多媒体视频流或Skype通话，这些应用程序在应用程序只想尽可能快地传递数据报时，会从轻量级头部中受益。你也可以考虑基于UDP协议的快速**域名系统（DNS**）查找过程。在准确性和延迟之间的权衡通常倾向于低延迟。
- en: When the address you type in on the browser is translated into a computer-understandable
    address, the user will benefit from a lightweight process, since this has to happen
    before even the first bit of information is delivered to you from your favorite
    website.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中输入的地址被转换为计算机可理解的地址时，用户将受益于一个轻量级的过程，因为这在将信息的第一位传递给你之前必须发生。
- en: Again, this section does not do justice to the topic of UDP, and you are encouraged
    to explore the topic through various resources if you are interested in learning
    more about UDP.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，本节并没有公正地处理UDP的主题，如果你对学习更多关于UDP感兴趣，鼓励你通过各种资源来探索这个主题。
- en: The Wikipedia article on UDP, [https://en.wikipedia.org/wiki/User_Datagram_Protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol),
    is a good starting point to learn more about UDP.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关于UDP的维基百科文章[https://en.wikipedia.org/wiki/User_Datagram_Protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol)是了解UDP的一个好起点。
- en: The Internet protocol
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网协议
- en: 'As network engineers will tell you, we live at the IP layer, which is layer
    3 on the OSI model. IP has the job of addressing and routing between end nodes,
    among others. The addressing of an IP is probably its most important job. The
    address space is divided into two parts: the network and the host portion. The
    subnet mask is used to indicate which portion in the network address consists
    of the network and which portion is the host by matching the network portion with
    a 1 and the host portion with a 0\. IPv4 expresses the address in the dotted notation,
    for example, `192.168.0.1`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如网络工程师们会告诉你的，我们生活在IP层，这是OSI模型的第3层。IP负责在端节点之间进行寻址和路由，以及其他任务。IP的寻址可能是其最重要的任务。地址空间被分为两部分：网络部分和主机部分。子网掩码用于通过将网络部分与1匹配，将主机部分与0匹配，来指示网络地址中的哪一部分由网络组成，哪一部分由主机组成。IPv4使用点分表示法来表示地址，例如，`192.168.0.1`。
- en: 'The subnet mask can either be in a dotted notation (`255.255.255.0`) or use
    a forward slash to express the number of bits that should be considered in the
    network bit (`255.255.255.0` or `/24`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 子网掩码可以是点分表示法（`255.255.255.0`）或使用正斜杠来表示应考虑的网络位数（`255.255.255.0`或`/24`）：
- en: '![Graphical user interface, application, table  Description automatically generated](img/B18403_01_07.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、应用程序、表格  自动生成的描述](img/B18403_01_07.png)'
- en: 'Figure 1.7: IPv4 header'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：IPv4头部
- en: 'The IPv6 header, the next generation of the IP header of IPv4, has a fixed
    portion and various extension headers:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, table  Description automatically
    generated](img/B18403_01_08.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: IPv6 header'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The IPv6 **Next Header** field in the fixed header section can indicate an extension
    header to be followed that carries additional information. It can also identify
    the upper-layer protocol such as TCP and UDP. The extension headers can include
    routing and fragment information. For example, the extension header can include
    how the original packet is fragmented so the destination node can reassemble the
    packet accordingly. As much as the protocol designer would like to move from IPv4
    to IPv6, the Internet today is still mainly addressed with IPv4, with some of
    the service provider networks addressed with IPv6 natively.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: IP network address translation (NAT) and network security
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NAT is typically used for translating a range of private IPv4 addresses into
    publicly routable IPv4 addresses. But it can also mean a translation between IPv4
    and IPv6, such as at a carrier edge when they use IPv6 inside of the network that
    needs to be translated to IPv4 when the packet leaves the network. Sometimes,
    NAT6 to IPv6 is used as well for security reasons.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Security is a continuous process that integrates all the aspects of networking,
    including automation and Python. This book aims to use Python to help you manage
    the network; security will be addressed as part of the following chapters in the
    book, such as using Python to implement access lists, search for breaches in the
    log, and so on. We will also look at how we can use Python and other tools to
    gain visibility in the network, such as a graphic network topology dynamically
    based on the network device information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: IP routing concepts
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IP routing is about having the intermediate devices between the two endpoints
    transmit the packets between them based on the IP header. For all communication
    that happens on the Internet, the packet will traverse through various intermediate
    devices. As mentioned, the intermediate devices consist of routers, switches,
    optical gears, and various other gears that might not examine beyond the network
    and transport layer. In a road trip analogy, you might travel in the United States
    from the city of San Diego in California to the city of Seattle in Washington.
    The IP source address is analogous to San Diego and the destination IP address
    can be thought of as Seattle. On your road trip, you will stop by many different
    intermediate spots, such as Los Angeles, San Francisco, and Portland; these can
    be thought of as the intermediary routers and switches between the source and
    destination.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Why was this important? In a way, this book is about managing and optimizing
    these intermediate devices. In the age of mega data centers that span the size
    of multiple American football fields, the need for efficient, agile, reliable,
    and cost-effective ways to manage the network becomes a major point of competitive
    advantage for companies. In future chapters, we will dive into how we can use
    Python programming to effectively manage a network.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？从某种意义上说，这本书是关于管理和优化这些中间设备。在拥有多个美式足球场大小的超大型数据中心时代，需要高效、敏捷、可靠且成本效益高的网络管理方式，这对公司来说成为了一个主要的竞争优势。在未来的章节中，我们将深入探讨如何使用Python编程有效地管理网络。
- en: Now that we’ve looked at network reference models and protocol suites, we’re
    ready to dive into the Python language itself. In this chapter, we’ll begin with
    a broad overview of Python.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了网络参考模型和协议套件，我们准备深入探讨Python语言本身。在本章中，我们将从Python的广泛概述开始。
- en: Python language overview
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python语言概述
- en: 'In a nutshell, this book is about making our network engineering lives easier
    with Python. But what is Python and why is it the language of choice of many DevOps
    engineers? In the words of the Python Foundation Executive Summary ([https://www.python.org/doc/essays/blurb/](https://www.python.org/doc/essays/blurb/)):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这本书是关于如何使用Python使我们的网络工程生活变得更轻松。但Python是什么，为什么它是许多DevOps工程师的首选语言呢？用Python基金会执行摘要中的话来说（[https://www.python.org/doc/essays/blurb/](https://www.python.org/doc/essays/blurb/))：
- en: ”Python is an interpreted, object-oriented, high-level programming language
    with dynamic semantics. Its high-level, built-in data structure, combined with
    dynamic typing and dynamic binding, makes it very attractive for Rapid Application
    Development, as well as for use as a scripting or glue language to connect existing
    components together. Python’s simple, easy-to-learn syntax emphasizes readability
    and therefore reduces the cost of program maintenance.”
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Python是一种解释型、面向对象、高级编程语言，具有动态语义。它的高级内置数据结构，结合动态类型和动态绑定，使其非常适合快速应用开发，同时也适用于作为脚本或粘合语言将现有组件连接起来。Python简单、易于学习的语法强调可读性，因此降低了程序维护的成本。”
- en: If you are somewhat new to programming, the “object-oriented,” and “dynamic
    semantics” mentioned in the summary probably do not mean much to you. But I think
    we can all agree that “rapid application development” and “simple, easy-to-learn
    syntax” sound good. Python, as an interpreted language, means there is little
    to no compilation process required before execution, so the time needed to write,
    test, and edit Python programs is significantly reduced. For simple scripts, if
    your script fails, a print statement could be all you need to troubleshoot the
    issue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对编程有些陌生，总结中提到的“面向对象”和“动态语义”可能对你来说意义不大。但我想我们都可以同意“快速应用开发”和“简单、易于学习的语法”听起来不错。作为解释型语言，Python意味着在执行前几乎不需要编译过程，因此编写、测试和编辑Python程序所需的时间显著减少。对于简单的脚本，如果你的脚本失败，一个打印语句可能就是你需要来调试问题的所有。
- en: Using the interpreter also means that Python is easily ported to different operating
    systems, such as Windows and Linux. A Python program written on one operating
    system can be used on another with little to no change.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解释器还意味着Python可以轻松地移植到不同的操作系统，如Windows和Linux。在一个操作系统上编写的Python程序可以在另一个操作系统上使用，几乎不需要任何修改。
- en: The functions, modules, and packages encourage code reuse by breaking a large
    program into simple reusable pieces. The object-oriented nature of Python takes
    it one step further for grouping the components into objects. In fact, all Python
    files are modules that can be reused or imported into another Python program.
    This makes it easy to share programs between engineers and encourages code reuse.
    Python also has a *batteries-included* mantra, which means for everyday tasks,
    you need not download any additional packages outside of the Python language itself.
    To achieve this goal without the code being too bloated, a set of Python modules,
    a.k.a. standard libraries, are installed when you install the Python interpreter.
    For common tasks such as regular expressions, mathematical functions, and JSON
    decoding, all you need is the *import* statement, and the interpreter will move
    those functions into your program. This *batteries-included* mantra is what I
    would consider one of the killer features of the Python language.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、模块和包通过将大型程序分解成简单的可重用部分来鼓励代码重用。Python的面向对象特性使得将组件分组为对象更进一步。实际上，所有Python文件都是模块，可以被重用或导入到另一个Python程序中。这使得工程师之间共享程序变得容易，并鼓励代码重用。Python还有一个“内置电池”的口号，这意味着对于日常任务，你不需要在Python语言本身之外下载任何额外的包。为了在不使代码过于臃肿的情况下实现这一目标，当安装Python解释器时，会安装一组Python模块，即标准库。对于诸如正则表达式、数学函数和JSON解码等常见任务，你所需要的就是*导入*语句，解释器会将这些函数移动到你的程序中。这个“内置电池”的口号是我认为Python语言的一个杀手级特性。
- en: 'Lastly, the fact that Python code can start in a relatively small-sized script
    with a few lines of code and grow into a complete production system is convenient
    for network engineers. As many of us know, the network typically grows organically
    without a master plan. A language that can grow with your network is invaluable.
    You might be surprised to see that a language deemed a scripting language by many
    is being used for whole production systems of many cutting-edge companies (organizations
    using Python: [https://wiki.python.org/moin/OrganizationsUsingPython](https://wiki.python.org/moin/OrganizationsUsingPython)).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Python代码可以从一个相对较小的脚本开始，只有几行代码，并逐渐发展成为一个完整的生产系统，这对网络工程师来说非常方便。正如我们许多人所知，网络通常是自然生长的，没有明确的总体规划。一种能够随着你的网络一起发展的语言是无价的。你可能会惊讶地发现，许多被认为是脚本语言的编程语言，却被许多尖端公司的完整生产系统所使用（使用Python的组织：[https://wiki.python.org/moin/OrganizationsUsingPython](https://wiki.python.org/moin/OrganizationsUsingPython)）。
- en: If you have ever worked in an environment where you must switch between working
    on different vendor platforms, such as Cisco IOS and Juniper Junos, you know how
    painful it is to switch between syntaxes and usage when trying to achieve the
    same task. Since Python is flexible enough for both small and large programs,
    there is no such dramatic context switching. It is just the same Python code from
    small to large!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在一个必须在不同供应商平台之间切换的环境中工作过，比如在Cisco IOS和Juniper Junos之间切换，你就知道在尝试完成相同任务时，在语法和用法之间切换是多么痛苦。由于Python足够灵活，既可以用于小型程序也可以用于大型程序，因此不存在这样的剧烈上下文切换。它只是从小到大的相同Python代码！
- en: For the rest of the chapter, we will take a high-level tour of the Python language.
    If you are already familiar with the basics, feel free to quickly scan through
    it or skip ahead to *Chapter 2*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将对Python语言进行一次高级的巡礼。如果你已经熟悉基础知识，可以快速浏览或跳到*第二章*。
- en: Python versions
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python版本
- en: As many readers will already be aware, Python has been going through a transition
    from Python 2 to Python 3 for the last few years. Python 3 was released in 2008,
    over 10 years ago, **with active development**, with the most recent release of
    3.10\. Unfortunately, Python 3 is not backward compatible with Python 2.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如许多读者可能已经知道的那样，Python在过去几年中一直在经历从Python 2到Python 3的过渡。Python 3于2008年发布，距今已有10多年，**持续开发**，最新的版本是3.10。不幸的是，Python
    3与Python 2不向后兼容。
- en: At the time of writing the fourth edition of this book, in mid-2022, the Python
    community has all but moved over to Python 3\. In fact, Python 2 officially entered
    end-of-life as of January 1, 2020\. The latest Python 2.x release, 2.7, was released
    over six years ago in mid-2010\. Since Python 2 is end-of-life and is no longer
    maintained by the Python Software Foundation, we should all be using Python 3\.
    In this book, we will be using the latest stable Python 3 release, Python 3.10\.
    Python 3.10 has many exciting features, such as a stable asynchronous I/O that
    is very helpful in network automation. This book will use Python 3 for the code
    examples unless otherwise stated. When applicable, we will point out the Python
    2 and Python 3 differences.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书第四版的中期，即 2022 年中，Python 社区几乎全部转向了 Python 3。事实上，Python 2 正式于 2020 年 1 月
    1 日进入生命周期的终结。最新的 Python 2.x 版本，2.7，是在 2010 年中旬发布的，已有六年多。由于 Python 2 已进入生命周期的终结，并且不再由
    Python 软件基金会维护，因此我们都应该使用 Python 3。在本书中，我们将使用最新的稳定版 Python 3，Python 3.10。Python
    3.10 有许多令人兴奋的功能，例如稳定的异步 I/O，这对于网络自动化非常有帮助。除非另有说明，本书将使用 Python 3 进行代码示例。当适用时，我们将指出
    Python 2 和 Python 3 的差异。
- en: Operating system
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统
- en: As mentioned, Python is cross-platform. Python programs can be run on Windows,
    Mac, and Linux. In reality, certain care needs to be taken when you need to ensure
    cross-platform compatibilities, such as taking care of the subtle differences
    between backslashes in Windows filenames and the steps to activate Python virtual
    environments on different operating systems. Since this book is written for DevOps,
    systems, and network engineers, Linux is the preferred platform for the intended
    audience, especially in production.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python 是跨平台的。Python 程序可以在 Windows、Mac 和 Linux 上运行。实际上，当你需要确保跨平台兼容性时，需要特别注意，例如处理
    Windows 文件名中反斜杠的细微差别以及在不同操作系统上激活 Python 虚拟环境的步骤。由于本书是为 DevOps、系统和网络工程师编写的，Linux
    是目标受众的首选平台，尤其是在生产环境中。
- en: The code in this book will be tested on Linux Ubuntu 22.04 LTS machines. As
    of this writing, Python 3.10.4 is the default version that ships with 22.04, so
    we do not need to install Python 3 separately. I will also try my best to make
    sure the code runs the same on the Windows and the macOS platforms.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码将在 Linux Ubuntu 22.04 LTS 机器上测试。截至本书编写时，Python 3.10.4 是 22.04 默认版本，因此我们不需要单独安装
    Python 3。我还会尽力确保代码在 Windows 和 macOS 平台上运行一致。
- en: 'If you are interested in the OS details, they are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣操作系统细节，如下所示：
- en: '[PRE0]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running a Python program
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Python 程序
- en: Python programs are executed by an interpreter, which means the code is fed
    through this interpreter to be executed by the underlying operating system. There
    are several different implementations of the interpreter by the Python development
    community, such as IronPython and Jython. In this book, we will use the most common
    Python interpreter today, CPython. Whenever we mention Python in this book, we
    refer to CPython unless otherwise indicated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序由解释器执行，这意味着代码将通过这个解释器传递给底层操作系统执行。Python 开发社区实现了几种不同的解释器，例如 IronPython
    和 Jython。在本书中，我们将使用今天最常用的 Python 解释器，CPython。除非另有说明，否则本书中提到的 Python 都是指 CPython。
- en: One way you can use Python is by taking advantage of the interactive prompt.
    This is useful when you want to quickly test a piece of Python code or concept
    without writing a whole program.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Python 的一个方法是利用交互式提示符。当你想要快速测试一段 Python 代码或概念而不需要编写整个程序时，这非常有用。
- en: 'This is typically done by simply typing in the `Python3` keyword:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是通过简单地输入 `Python3` 关键字来完成的：
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The interactive mode is one of Python’s most useful features. In the interactive
    shell, you can type any valid statement or sequence of statements and immediately
    get a result back. I typically use the interactive shell to explore a feature
    or library that I am not familiar with.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式模式是 Python 最有用的功能之一。在交互式外壳中，你可以输入任何有效的语句或语句序列，并立即得到结果。我通常使用交互式外壳来探索我不熟悉的特性或库。
- en: The interactive mode can also be used for more complex tasks such as experimenting
    with data structure behaviors, for example, mutable versus immutable data types.
    Talk about instant gratification!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式模式也可以用于更复杂的任务，例如实验数据结构的行为，例如可变与不可变数据类型。谈谈即时的满足感！
- en: On Windows, if you do not get a Python shell prompt back, you might not have
    the program in your system search path. The latest Windows Python installation
    program provides a checkbox for adding Python to your system path; make sure that
    is checked during installation. Or, you can add the program to the path manually
    by going to **Environment settings**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'A more common way to run the Python program, however, is to save your Python
    file and run it via the interpreter after. This will save you from typing in the
    same statements repeatedly. Python files are just regular text files typically
    saved with the `.py` extension. In the *Nix world, you can also add the **shebang**
    (#!) line on top to specify the interpreter that will be used to run the file.
    The `#` character can be used to specify comments that will not be executed by
    the interpreter. The file `helloworld.py` has the following statements:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This can be executed as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let us take a look at the basic Python building structures, built-in data types.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Python built-in types
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In computer programming, data types typically refer to a way for the computer
    program to know the kind of value a variable can have, such as a word or a number.
    Python implements dynamic typing, or duck typing, and tries to determine the object’s
    type as you declare it automatically. Python has several standard types built
    into the interpreter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Numerics**: `int`, `float`, complex, and `bool` (the subclass of `int` with
    a `True` or `False` value)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequences**: `str`, `list`, `tuple`, and `range`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mappings**: `dict`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sets**: `set` and `frozenset`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None**: The `null` object'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will briefly examine the different types in Python. If they do not make sense
    to you at this moment, they might make more sense when we apply them in examples
    in the section that follows.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The None type
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `None` type denotes an object with no value. The `None` type is returned
    in functions that do not explicitly return anything such as a function but just
    do some math calculation and exit. The `None` type is also used in function arguments
    to error out if the caller does not pass in an actual value. For example, we can
    specify in a function ‘if a==None, raise an error’.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Numerics
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python numeric objects are basically numbers. With the exception of Booleans,
    the numeric types of `int`, `long`, `float`, and `complex` are all signed, meaning
    they can be positive or negative. A Boolean is a subclass of the integer, which
    can be one of two values: 1 for True, and 0 for False. In practice, we are almost
    always testing Booleans with True or False instead of the numerics 1 and 0\. The
    rest of the numeric types are differentiated by how precisely they can represent
    the number; in Python 3, `int` does not have a maximum size while in Python 2
    `int` indicates whole numbers with a limited range. Floats are numbers using the
    double-precision representation (64-bit) on the machine.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sequences are ordered sets of objects with an index of non-negative integers.
    Since there are many different sequence types in Python (str, lists, tuple, etc),
    let us use the interactive interpreter to illustrate the different sequence types.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Please feel free to type along on your own computer.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it surprises people that `string` (think of words) is a sequence
    type. But if you look closely, strings are a series of characters put together.
    Strings are enclosed by either single, double, or triple quotes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Note in the following examples, the quotes must match. A beginning double quote
    needs to be matched with an ending double quote. Triple quotes allow the string
    to span different lines:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The other two commonly used sequence types are lists and tuples. Lists are sequences
    of arbitrary objects. Lists can be created by enclosing objects in square brackets.
    Just like strings, lists are indexed by non-zero integers that start at zero.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of a list are retrieved by referencing the index number:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Tuples are like lists, created by enclosing values in parentheses. Like lists,
    the values in the tuple are retrieved by referencing its index number. Unlike
    lists, the values cannot be modified after creation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Some operations are common to all sequence types, such as returning an element
    by index. A sequence can also be sliced for a portion of its elements:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember that the index starts at 0\. Therefore, the index of 1 is the second
    element in the sequence.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also common functions that can be applied to sequence types, such
    as checking the number of elements and finding the minimum and maximum values
    amongst all the elements:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are various methods that are applicable only to strings. It is worth
    noting that these methods do not modify the underlying string data itself and
    always return a new string. In short, mutable objects such as lists and dictionaries
    can be changed after creation, and immutable objects, for example, strings, cannot.
    If you want to use the new returned value for other operations, you will need
    to catch the return value and assign it to a different variable:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here are some of the common methods for a list. The Python list data type is
    a very useful structure in terms of putting multiple items together and iterating
    through them one at a time. For example, we can make a list of data center spine
    switches and apply the same access list to all of them by iterating through them
    one by one. Since a list’s value can be modified after creation (unlike tuples),
    we can also expand and contract the existing list as we move along the program:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Python lists are great for storing data, but it is a bit tricky at times to
    keep track of data if we need to reference it by location. If that is an issue,
    we can use a different Python data type. Let’s look at Python mapping type next.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Mapping
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python provides one mapping type, called the **dictionary**. The dictionary
    data type is what I think of as a poor man’s database because it contains objects
    that can be indexed by keys. This is often referred to as an *associated array
    or hashing table* in other programming languages. If you have used any of the
    dictionary-like objects in other languages, you will know how powerful this type
    can be, because you can refer to the object with a human-readable key.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: This key, instead of just a number, will make much more sense to the poor guy
    who is trying to maintain and troubleshoot the code. That guy could be you only
    a few months after you wrote the code, trying to troubleshoot the code at 2 AM.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The object in the dictionary value can also be another data type, such as a
    list. As we have used square brackets for lists and round braces for tuples, we
    use curly braces to create a dictionary. Here is an example of how we can use
    a dictionary to represent our data center devices:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Python dictionary is one of my favorite data containers to use in network
    scripts and I use it all the time. However, there are other data containers that
    can come in handy in different use cases – a set is one of them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **set** is used to contain an unordered collection of objects. Unlike lists
    and tuples, sets are unordered and cannot be indexed by numbers. But there is
    one character that makes sets stand out as useful: the elements of a set are never
    duplicated. Imagine you have a list of IPs that you need to put in an access list.
    The only problem with this list of IPs is that they are full of duplicates.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, think about how many lines of code you would use to loop through the list
    of IPs to sort out unique items, one at a time. Now consider this: the built-in
    set type would allow you to eliminate duplicate entries with just one line of
    code. Personally, the Python set data type is not used that much in my code, but
    when I need it, I am always very thankful it exists. Once the set or sets are
    created, they can be compared with each other using the `union`, `intersection`,
    and `differences`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have looked at different data types, we will take a tour of Python
    operators next.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Python operators
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has some *numeric operators* that you would expect from any programming
    language, such as `+`, `-`, and so on; note that the truncating division (`//`,
    also known as **floor division**) truncates the result to an integer and a floating-point
    but only the integer value is returned. The modulo (`%`) operator returns the
    remainder value in the division:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are also *comparison operators*. Note the double equals sign is used
    for comparison and a single equals sign is used for variable assignment:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also use two of the common membership operators to test whether an object
    is in a sequence type:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Python operators allow us to perform simple operations efficiently. In the
    next section, we will look at how we can use control flows to repeat these operations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Python control flow tools
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `if`, `else`, and `elif` statements control conditional code execution.
    Unlike some other programming languages, Python uses indentation to structure
    blocks. There can be any number of indentation spaces as long as they align. Common
    practice is typically to use 2 or 4 spaces. The format of the conditional statement
    is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a simple example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `while` loop will continue to execute until the condition is `False`, so
    be careful with this one if you don’t want to continue to execute (and crash your
    process):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `for` loop works with any object that supports iteration; this means all
    the built-in sequence types, such as `lists`, `tuples`, and `strings`, can be
    used in a `for` loop. The letter `i` in the following for loop is an iterating
    variable, so you can typically pick something that makes sense within the context
    of your code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have looked at Python data types, operators, and control flows,
    we are ready to group them together into reusable code pieces called functions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Python functions
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often times when you find yourself copying and pasting some pieces of code,
    it is a good sign you should break it up into self-contained chunks of functions.
    This practice allows for better modularity, is easier to maintain, and allows
    for code reuse. Python functions are defined by using the `def` keyword with the
    function name, followed by the function parameters. The body of the function consists
    of the Python statements that are to be executed. At the end of the function,
    you can choose to return a value to the function caller. By default, it will return
    the `None` object if you do not specify a return value:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will see a lot more examples of functions in the following chapters, but
    here is a quick example. In the following example, we use positional parameters,
    so the first element is referred to by the first variable in the function. Another
    way of referring to parameters is keywords with default values, such as `def subtract(a=10,
    b=5)`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Python functions are great for grouping tasks together. Can we group different
    functions into a bigger piece of reusable code? Yes, we can do that via Python
    classes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Python classes
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is an **object-oriented programming** (**OOP**) language. The way Python
    creates objects is with the `class` keyword. A Python object is most commonly
    a collection of functions (methods), variables, and attributes (properties). Once
    a class is defined, you can create instances of the class. The class serves as
    a blueprint for subsequent instances.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The topic of OOP is outside the scope of this chapter, but here is a simple
    example of a `router` object definition to illustrate the point:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once defined, we can create as many instances of that class as we’d like:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Of course, there is a lot more to Python objects and OOP. We will look at more
    examples in future chapters.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Python modules and packages
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any Python source file can be used as a module and any functions and classes
    you define in that source file can be reused by other Python scripts. To load
    the code, the file referencing the module needs to use the `import` keyword. Three
    things happen when the file is imported:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The file creates a new namespace for the objects defined in the source file.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The caller executes all the code contained in the module.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file creates a name within the caller that refers to the module being imported.
    The name matches the name of the module.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember the `subtract()` function that we defined using the interactive shell?
    To reuse the function, we can put it into a file named `subtract.py`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In a file within the same directory of `subtract.py`, you can start the Python
    interpreter and import this function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This works because, by default, Python will first search for the current directory
    for the available modules. Remember the standard library that we mentioned a while
    back? You guessed it, those are just Python files being used as modules.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: If you are in a different directory, you can manually add a search path location
    using the `sys` module with `sys.path`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Can we group multiple modules together in Python? Yes, Python packages allow
    a collection of modules to be grouped together. This further organizes Python
    modules for more namespace protection and better reusability. A package is defined
    by creating a directory with a name you want to use as the namespace, then placing
    the module source file under that directory.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for Python to recognize the directory as a Python package, just create
    a `__init__.py` file in this directory. The `__init__.py` file can be an empty
    file. In the same example as the `subtract.py` file, let’s say if you were to
    create a directory called `math_stuff`, we can create a `__init__.py` file in
    the directory:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The way to refer to the module is to include the package name using dot notation,
    for example, `math_stuff.subtract`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, modules and packages are great ways to organize large code files
    and make sharing Python code a lot easier.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the OSI model and reviewed network protocol suites,
    such as TCP, UDP, and IP. They work as the layers that handle the addressing and
    communication negotiation between any two hosts. The protocols were designed with
    extensibility in mind and have largely been unchanged from their original design.
    Considering the explosive growth of the internet, that is quite an accomplishment.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: We also quickly reviewed the Python language, including built-in types, operators,
    control flows, functions, classes, modules, and packages. Python is a powerful,
    production-ready language that is also easy to read. This makes the language an
    ideal choice when it comes to network automation. Network engineers can leverage
    Python to start with simple scripts and gradually move on to other advanced features.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还快速回顾了Python语言，包括内置类型、运算符、控制流、函数、类、模块和包。Python是一种强大、生产就绪且易于阅读的语言，这使得它成为网络自动化的理想选择。网络工程师可以利用Python从简单的脚本开始，逐步过渡到其他高级功能。
- en: In *Chapter 2*, *Low-Level Network Device Interactions*, we will start to look
    at using Python to programmatically interact with network equipment.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二章*，*低级网络设备交互*中，我们将开始探讨如何使用Python编程方式与网络设备进行交互。
- en: Join our book community
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的社区——在这里您可以分享反馈、向作者提问，并了解新书发布——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2903617220506617062.png)'
