- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Review of TCP/IP Protocol Suite and Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the new and exciting age of network engineering! When I started working
    as a network engineer at the turn of the millennium some 20 years ago, the role
    was distinctly different than the network engineering role of today. At the time,
    network engineers mainly possessed domain-specific knowledge to manage and operate
    local and wide area networks using the command-line interface. While they might
    occasionally cross over the discipline wall to handle tasks normally associated
    with systems administration and developers, there was no explicit expectation
    for a network engineer to write code or understand programming concepts. This
    is no longer the case today.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, the DevOps and **Software–Defined Networking** (**SDN**) movement,
    among other factors, have significantly blurred the lines between network engineers,
    systems engineers, and developers.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that you have picked up this book suggests that you might already be
    an adopter of network DevOps, or maybe you are considering going down that path
    of checking out network programmability. Maybe you have been working as a network
    engineer for many years, just as I had, and wanted to know what the buzz around
    the Python programming language is all about. You might even already have been
    fluent in the Python programming language but wonder what its applications are
    in the network engineering field.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you fall into any of these camps or are simply just curious about Python
    in the network engineering field, I believe this book is for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, venn diagram  Description automatically generated](img/B18403_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The intersection between Python and network engineering'
  prefs: []
  type: TYPE_NORMAL
- en: There are already many great books written that dive into the topics of network
    engineering and Python separately. I do not intend to repeat their efforts with
    this book. Instead, this book assumes you have some hands-on experience in managing
    networks, as well as a basic understanding of network protocols. It’s helpful
    if you’re already familiar with Python as a programming language, but you do not
    need to be an expert. We will cover some Python basics later in the chapter as
    a baseline of Python knowledge. Again, you do not need to be an expert in Python
    or network engineering to read this book. This book intends to build on the basic
    foundations of network engineering and Python to help readers learn and practice
    various applications that can make their lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will do a general review of some networking and Python concepts.
    The rest of the chapter should set the level of expectation of the prior knowledge
    required to get the most out of this book. If you want to brush up on the contents
    of this chapter, there are lots of free or low-cost resources to bring you up
    to speed. I would recommend the free Khan Academy ([https://www.khanacademy.org/](https://www.khanacademy.org/))
    and the official Python tutorials from the Python Software Foundation at [https://www.python.org/](https://www.python.org/).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will pay a very quick visit to the relevant networking topics at
    a high level without going too much into the details. There is simply not enough
    space in one chapter to do a deep dive on any of the topics. To be honest, most
    of us do not get to a deep level when doing day-to-day jobs. What is the level
    of required networking knowledge? Judging from my experience of working in the
    field, a typical network engineer or developer might not remember the exact **Transmission
    Control Protocol** (**TCP**) state machine to accomplish their daily tasks (I
    know I don’t), but they would be familiar with the basics of the **Open Systems
    Interconnection** (**OSI**) model, the TCP and **User Datagram Protocol** (**UDP**)
    operations, different IP header fields, and other fundamental concepts. That is
    what we will cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at a high-level review of the Python language first; just
    enough for those readers who do not code in Python daily to have ground to walk
    on for the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OSI and client-server model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP, UDP, and IP protocol suites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python syntax, types, operators, and loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Python with functions, classes, and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the information presented in this chapter is not exhaustive; please
    check out the references for further information if required.
  prefs: []
  type: TYPE_NORMAL
- en: As network engineers, often we are challenged by the scale and complexity of
    the networks we need to manage. They range from small home-based networks, medium-size
    networks that make a small business go, to large multi-national enterprise networks
    spanning across the globe. The most extensive network of them all is, of course,
    the Internet. Without the Internet, there would be no email, websites, API, streaming
    media, or cloud computing as we know it. Therefore, before we dive deeper into
    the specifics of protocols and Python, let us begin with an overview of the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the Internet? This seemingly easy question might receive different answers
    depending on each of our backgrounds. The Internet means different things to different
    people; the young, the old, students, teachers, business people, and poets could
    all give different answers to the same question.
  prefs: []
  type: TYPE_NORMAL
- en: To a network engineer, the Internet is a global computer network consisting
    of a web of inter-networks connecting large and small networks together. In other
    words, it is *a network of networks without a centralized owner*. Take your home
    network as an example. It might consist of a device that integrates the functions
    of routing, Ethernet switching, and wireless access points connecting your smartphones,
    tablets, computers, and internet-enabled TVs together for the devices to communicate
    with each other. This is your **Local Area Network** (**LAN**).
  prefs: []
  type: TYPE_NORMAL
- en: When your home network needs to communicate with the outside world, it passes
    information from your LAN to a larger network, often appropriately named the **Internet
    Service Provider** (**ISP**). The ISP is typically thought of as a business that
    you pay to get online. They can do this by aggregating small networks into bigger
    networks that they maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Your ISP network often consists of many edge nodes that aggregate the traffic
    to their core network. The core network’s function is to interconnect these edge
    networks via a high-speed network.
  prefs: []
  type: TYPE_NORMAL
- en: At some of the more specialized edge nodes, called Internet exchange points,
    your ISP is connected to other ISPs to pass your traffic appropriately to your
    destination. The return path from your destination to your home computer, tablet,
    or smartphone may or may not follow the same path through all these in-between
    networks back to your original device, while the source and destination remain
    the same. This asymmetrical behavior is designed to be fault-tolerant so that
    no one node can take down the whole connection.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the components making up this web of networks.
  prefs: []
  type: TYPE_NORMAL
- en: Servers, hosts, and network components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hosts** are end nodes on the network that communicate with other nodes. In
    today’s world, a host can be a traditional computer, or it can be your smartphone,
    tablet, or TV. With the rise of the **Internet of Things** (**IoT**), the broad
    definition of a host can be expanded to include an **Internet Protocol** (**IP**)
    camera, TV set-top boxes, and the ever-increasing types of sensors we use in agriculture,
    farming, automobiles, and more. With the explosion of the number of hosts connected
    to the Internet, they all need to be addressed, routed, and managed. The demand
    for proper networking has never been greater.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time when we are on the Internet, we make requests for services.
    This could be viewing a web page, sending or receiving emails, transferring files,
    and other online activities. These services are provided by **servers**. As the
    name implies, servers provide services to multiple nodes and generally have higher
    levels of hardware specification. In a way, servers are particular “super nodes”
    on the network that offer additional capabilities to their peers. We will look
    at servers again later, in the *The client-server model* section.
  prefs: []
  type: TYPE_NORMAL
- en: If you think of servers and hosts as cities and towns, the *network components*
    are the roads and highways that connect them together. In fact, the term information
    superhighway comes to mind when describing the network components that transmit
    the ever-increasing bits and bytes across the globe. In the Seven-Layer OSI model
    that we will look at in *The OSI model*, these network components are layer-one
    to layer-three devices that sometimes venture into layer four as well. They are
    layer-two and layer-three routers and switches that direct traffic, as well as
    layer-one transports such as fiber optic cables, coaxial cables, twisted copper
    pairs, and some **Dense Wavelength Division Multiplexing** (**DWDM**) equipment,
    to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: Collectively, hosts, servers, storage, and network components make up the internet
    as we know it today.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of data centers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the last section, we looked at the different roles that servers, hosts,
    and network components play in the inter-network. Because of the higher hardware
    capacity that servers demand, they are often put together in a central location
    to be managed more efficiently. We often refer to these locations as data centers.
    They can generally be classified into three broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise data centers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud data centers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge data centers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us take a look at enterprise data centers first.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise data centers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a typical enterprise, the company generally has business needs for internal
    tools such as emailing, document storage, sales tracking, ordering, HR tools,
    and a knowledge-sharing intranet. These services become file and mail servers,
    database servers, and web servers. Unlike user computers, these are generally
    high-end computers that require higher power, cooling, and high bandwidth network
    connections. A byproduct of the hardware is also the amount of noise it makes,
    which is not suitable for a normal workspace. The servers are generally placed
    in a central location, called the **Main Distribution Frame** (**MDF**), in the
    enterprise building to provide the necessary power feed, power redundancy, cooling,
    and network connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: To connect to the MDF, the user’s traffic is generally aggregated at locations
    closer to the user, which are sometimes called the **Intermediate Distribution
    Frame** (**IDF**), before they are bundled up and connected to the MDF. It is
    not unusual for the IDF-MDF spread to follow the physical layout of the enterprise
    building or campus. For example, each building floor can consist of an IDF that
    aggregates to the centralized MDF on another floor in the same building. If the
    enterprise consists of several buildings, further aggregation can be done by combining
    the buildings’ traffic before connecting them to the enterprise data center.
  prefs: []
  type: TYPE_NORMAL
- en: Many enterprise data centers (sometimes referred to as campus networks) follow
    the three-layer network design. The layers are the access layer, the distribution
    layer, and the core layer. Of course, as with any design, there are no hard rules
    or one-size-fits-all model; the three-layer designs are just a general guide.
    As an example, to overlay the three-layer design to our User-IDF-MDF example earlier,
    the access layer is analogous to the ports each user connects to, the IDF can
    be thought of as the distribution layer, while the core layer consists of the
    connection to the MDF and the enterprise data centers. This is, of course, a generalization
    of enterprise networks, as some of them will not follow the same model.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud data centers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the rise of cloud computing and software, or **Infrastructure as a Service**
    (**IaaS**), the data centers the cloud providers have built are big in scale,
    sometimes referred to as hyper-scale data centers. What we referred to as cloud
    computing is the on-demand availability of computing resources offered by the
    likes of Amazon AWS, Microsoft Azure, and Google Cloud without the user having
    to manage the resources directly. Many web-scale service providers, such as Facebook,
    can also be grouped into this category.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the number of servers they need to house, cloud data centers generally
    demand a much, much higher capacity of power, cooling, and network capacity than
    any enterprise data center. Even after working on cloud providers’ data centers
    for many years, every time I visit a cloud provider’s data center, I am still
    amazed at their scale. Just to give examples of their sheer scale, cloud data
    centers are so big and power-hungry that they are typically built close to power
    plants where they can get the cheapest power rate, without losing too much efficiency
    during the transportation of the power. Their cooling needs are so high that some
    are forced to be creative about where the data center is built. Facebook, for
    example, has built its Lulea data center in northern Sweden (just 70 miles south
    of the Arctic Circle) in part to leverage the cold temperature for cooling. Any
    search engine can give you some astounding numbers when it comes to the science
    of building and managing cloud data centers for the likes of Amazon, Microsoft,
    Google, and Facebook. The Microsoft data center in West Des Moines, Iowa, for
    example, consisted of 1.2 million square feet of the facility on 200 acres of
    land and required the city to spend an estimated $65 million in public infrastructure
    upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: At the cloud provider scale, the services they need to provide are generally
    not cost-effective or feasible to be housed in a single server. The services are
    spread between a fleet of servers, sometimes across many racks, to provide redundancy
    and flexibility for service owners.
  prefs: []
  type: TYPE_NORMAL
- en: 'The latency and redundancy requirements, as well as the physical spread of
    servers, put a tremendous amount of pressure on the network. The interconnections
    required to connect the server fleets equate to an explosive growth of network
    equipment such as cables, switches, and routers. These requirements translate
    into the amount of equipment that needs to be racked, provisioned, and managed.
    A typical network design would be a multi-staged Clos network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Clos network'
  prefs: []
  type: TYPE_NORMAL
- en: In a way, cloud data centers and the increasing adaptions in other networks
    are where network automation becomes a necessity for the speed, flexibility, and
    reliability automation can provide. If we follow the traditional way of managing
    network devices via a Terminal and command-line interface, the number of engineering
    hours required will not allow the service to be available in a reasonable amount
    of time. Not to mention that human repetition is error-prone, inefficient, and
    a terrible waste of engineering talent. To add further complexity, there is often
    the need to quickly change some of the network configurations to accommodate rapidly
    changing business needs, such as redesigning a three-tier campus network into
    a CLOS-based topology.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, cloud data center networking is where I started my path of network
    automation with Python several years ago, and I’ve never looked back since.
  prefs: []
  type: TYPE_NORMAL
- en: Edge data centers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we have sufficient computing power at the data center level, why keep anything
    else but at these data centers? All the connections from clients worldwide can
    be routed back to the data center servers, and we can call it a day, right? The
    answer, of course, depends on the use case. The most significant limitation in
    routing the request and session all the way back from the client to a large data
    center is the latency introduced in the transport. In other words, significant
    latency is where the network becomes a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, any elementary physics textbook can tell you that the network latency
    number would never be zero: even as fast as light can travel in a vacuum, it still
    takes time for physical transportation. In the real world, latency would be much
    higher than light in a vacuum. Why? Because the network packet must traverse through
    multiple networks, sometimes through an undersea cable, slow satellite links,
    4G or 5G cellular links, or Wi-Fi connections.'
  prefs: []
  type: TYPE_NORMAL
- en: How can we reduce network latency? One solution would be to reduce the number
    of networks the end-user requests traverse through. We can try to be as closely
    connected to the end-user as possible, perhaps meeting the user at the edge where
    the requests enter our network. We can place enough resources at these edge locations
    to serve the request. This is especially common for servicing media content such
    as music and videos.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a minute and imagine that you are building the next generation of
    video streaming services. To increase customer satisfaction with smooth streaming,
    you would want to place the video server as close to the customer as possible,
    either inside or very near to the customer’s ISP. Also, for redundancy and connection
    speed, the upstreaming of the video server farm would not just be connected to
    one or two ISPs, but all the ISPs that we can connect to reduce the hop count,
    thus reducing the number of devices we need to pass thru. All the connections
    would have as much bandwidth as needed to decrease peak-hour latency. This need
    gave rise to the peering exchange’s edge data centers of big ISP and content providers.
    Even when the number of network devices is not as high as cloud data centers,
    they too can benefit from network automation in terms of the increased reliability,
    flexibility, security, and visibility network automation brings.
  prefs: []
  type: TYPE_NORMAL
- en: If we extend the concept of edge nodes and get creative, we can see that some
    of the latest technologies, such as self-driving cars and **Software-Defined Wide-Area-Networks**
    (**SD-WANs**) are also applications of edge nodes. The self-driving car needs
    to make split-second decisions based on its sensors. SD-WAN routers need to route
    packets locally, without the need to consult a central “brain.” These are all
    concepts of intelligent edge nodes.
  prefs: []
  type: TYPE_NORMAL
- en: As with many complex subjects, we can tackle the complexity by dividing the
    subject into smaller digestible pieces. Networking breaks the complexity by using
    layers to model the functions of its elements. Over the years, there have been
    different networking models. We will look at two of the most important models
    in this book, starting with the OSI model.
  prefs: []
  type: TYPE_NORMAL
- en: The OSI model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No network book is complete without first going over the OSI model. The model
    is a conceptual model that componentizes the telecommunication functions into
    different layers. The model defines seven layers, and each layer sits independently
    on top of another one with defined structures and characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the network layer, IP is located on top of the different data
    link layers, such as Ethernet or frame relay. The OSI reference model is a good
    way to normalize different and diverse technologies into a set of common languages
    that people can agree on. This greatly reduces the scope for parties working on
    individual layers and allows them to look at specific tasks in depth without worrying
    too much about compatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated with medium confidence](img/B18403_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: OSI model'
  prefs: []
  type: TYPE_NORMAL
- en: The OSI model was initially worked on in the late 1970s and was later published
    jointly by the **International Organization for Standardization** (**ISO**), what
    is now known as the **Telecommunication Standardization Sector of the International
    Telecommunication Union** (**ITU-T**). It is widely accepted and commonly referred
    to when introducing a new topic in telecommunication.
  prefs: []
  type: TYPE_NORMAL
- en: Around the same time as the OSI model development, the Internet was taking shape.
    The reference model the original designer used for the Internet is often referred
    to as the TCP/IP model. The TCP and the IP were the original protocol suites contained
    in the design. This is somewhat similar to the OSI model in the sense that they
    divide end-to-end data communication into abstraction layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is different in the TCP/IP model is it combines layers 5 to 7 in the OSI
    model in the **Application** layer, while the **Physical** and **Data link** layers
    are combined in the **Link** layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Internet protocol suite'
  prefs: []
  type: TYPE_NORMAL
- en: Both the OSI and TCP/IP models are useful for providing standards for end-to-end
    data communication. We will refer to either the OSI or the TCP/IP model when needed,
    such as when we are discussing the web framework in the upcoming chapters. Just
    like models at the transport layer, there are also reference models that govern
    communication at the application level. In the modern network, the client-server
    model is what most applications are based on. We will look at the client-server
    model in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The client-server model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client-server reference models demonstrated a standard way for data to communicate
    between two nodes. Of course, by now, we all know that not all nodes are created
    equal. Even in the earliest **Advanced Research Projects Agency Network** (**ARPANET**)
    days, there were workstation nodes, and there were server nodes with the purpose
    of providing content to other workstation nodes.
  prefs: []
  type: TYPE_NORMAL
- en: These server nodes typically have higher hardware specifications and are managed
    more closely by engineers. Since these nodes provide resources and services to
    others, they are appropriately referred to as servers. Servers typically sit idle,
    waiting for clients to initiate requests for their resources. This model of distributed
    resources that are requested by the client request is referred to as the client-server
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this important? If you think about it for a minute, the importance of
    networking is greatly highlighted by this client-server model. Without the need
    to transfer services between clients and servers, there is not a lot of need for
    network interconnections. It is the need to transfer bits and bytes from the client
    to the server that shines a light on the importance of network engineering. Of
    course, we are all aware of how the biggest network of them all, the Internet,
    has been transforming the lives of all of us and is continuing to do so.
  prefs: []
  type: TYPE_NORMAL
- en: You might be asking, how can each node determine the time, speed, source, and
    destination every time they need to talk to each other? This brings us to network
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Network protocol suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early days of computer networking, protocols were proprietary and closely
    controlled by the company that designed the connection method. If you were using
    **Novell’s IPX/SPX** protocol in your hosts, the same hosts would not be able
    to communicate with Apple’s **AppleTalk** hosts, and vice versa. These proprietary
    protocol suites generally have analogous layers to the OSI reference model and
    follow the client-server communication method but are not compatible with each
    other. The proprietary protocols generally only work in LANs that are closed,
    without the need to communicate with the outside world. When traffic does need
    to move beyond the local LAN, typically a protocol translation device, such as
    a router, is used to translate from one protocol to another. For example, to connect
    an AppleTalk-based network to the Internet, a router would be used to connect
    and translate the AppleTalk protocol to an IP-based network. The additional translation
    is usually not perfect, but since most of the communication happened within the
    LAN in the early days, it was accepted by the network administrators.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the need for inter-network communication rises beyond the LAN, the
    need for standardizing the network protocol suites becomes greater. The proprietary
    protocols eventually gave way to the standardized protocol suites of TCP, UDP,
    and IP, which greatly enhanced the ability of one network to talk to another.
    The Internet, the greatest network of them all, relies on these protocols to function
    properly. In the next few sections, we will look at each of the protocol suites.
  prefs: []
  type: TYPE_NORMAL
- en: The transmission control protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCP is one of the main protocols used for the Internet today. If you have opened
    a web page or have sent an email, you have come across the TCP protocol. The protocol
    sits at layer 4 of the OSI model, and it is responsible for delivering the data
    segment between two nodes in a reliable and error-checked manner. The TCP consists
    of a 160-bit header that contains, among other fields, source and destination
    ports, a sequence number, an acknowledgment number, control flags, and a checksum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18403_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: TCP header'
  prefs: []
  type: TYPE_NORMAL
- en: Functions and characteristics of TCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TCP uses datagram sockets or ports to establish host-to-host communication.
    The standard body, called the **Internet Assigned Numbers Authority** (**IANA**),
    designates well-known ports to indicate certain services, such as `port 80` for
    HTTP (web) and `port 25` for SMTP (mail). The server in the client-server model
    typically listens on one of these well-known ports in order to receive communication
    requests from the client. The TCP connection is managed by the operating system
    with the socket representing the local endpoint for the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol operation consists of a state machine, which the machine needs
    to keep track of when it is listening for an incoming connection during the communication
    session, as well as releasing resources once the connection is closed. Each TCP
    connection goes through a series of states such as `Listen`, `SYN-SENT`, `SYN-RECEIVED`,
    `ESTABLISHED`, `FIN-WAIT`, `CLOSE-WAIT`, `CLOSING`, `LAST-ACK`, `TIME-WAIT`, and
    `CLOSED`. The different states help in managing the TCP messages.
  prefs: []
  type: TYPE_NORMAL
- en: TCP messages and data transfer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The biggest difference between TCP and UDP, which is its close cousin on the
    same layer, is that it transmits data in an ordered and reliable fashion. The
    fact that the TCP operation guarantees delivery is often referred to TCP as a
    connection-oriented protocol. It does this by first establishing a three-way handshake
    to synchronize the sequence number between the transmitter and the receiver, `SYN`,
    `SYN-ACK`, and `ACK`.
  prefs: []
  type: TYPE_NORMAL
- en: The acknowledgment is used to keep track of subsequent segments in the conversation.
    Finally, at the end of the conversation, one side will send a `FIN` message, and
    the other side will `ACK` the `FIN` message as well as sending a `FIN` message
    of its own. The `FIN` initiator will then `ACK` the `FIN` message that it received.
  prefs: []
  type: TYPE_NORMAL
- en: As many of us who have troubleshot a TCP connection can tell you, the operation
    can get quite complex. One can certainly appreciate that, most of the time, the
    operation just happens silently in the background.
  prefs: []
  type: TYPE_NORMAL
- en: A whole book could be written about the TCP protocol; in fact, many excellent
    books have been written on the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: As this section is a quick overview, if interested, The *TCP/IP Guide* ([http://www.tcpipguide.com](http://www.tcpipguide.com))
    is an excellent free resource that you can use to dig deeper into the subject.
  prefs: []
  type: TYPE_NORMAL
- en: The user datagram protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UDP is also a core member of the protocol suites used. Like TCP, it operates
    on layer 4 of the OSI model that is responsible for delivering data segments between
    the application and the IP layer. Unlike TCP, the header is only 64 bits, which
    only consists of a source and destination port, length, and checksum. The lightweight
    header makes it ideal for applications that prefer faster data delivery without
    setting up the session between two hosts or needing reliable data delivery. Perhaps
    it’s hard to imagine with today’s fast internet connections, but the lightweight
    header made a big difference to the speed of transmission in the early days of
    `X.21` and frame relay links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the speed difference, not having to maintain various states, such as
    TCP, also saves computer resources on the two endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_01_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: UDP header'
  prefs: []
  type: TYPE_NORMAL
- en: You might now wonder why UDP was ever used at all in the modern age; given the
    lack of reliable transmissions, wouldn’t we want all the connections to be reliable
    and error-free? If you think about multimedia video streaming or Skype calls,
    those applications benefit from a lighter header when the application just wants
    to deliver the datagram as quickly as possible. You can also consider the fast
    **Domain Name System** (**DNS**) lookup process based on the UDP protocol. The
    tradeoff between accuracy and latency usually tips to the side of low latency.
  prefs: []
  type: TYPE_NORMAL
- en: When the address you type in on the browser is translated into a computer-understandable
    address, the user will benefit from a lightweight process, since this has to happen
    before even the first bit of information is delivered to you from your favorite
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this section does not do justice to the topic of UDP, and you are encouraged
    to explore the topic through various resources if you are interested in learning
    more about UDP.
  prefs: []
  type: TYPE_NORMAL
- en: The Wikipedia article on UDP, [https://en.wikipedia.org/wiki/User_Datagram_Protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol),
    is a good starting point to learn more about UDP.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As network engineers will tell you, we live at the IP layer, which is layer
    3 on the OSI model. IP has the job of addressing and routing between end nodes,
    among others. The addressing of an IP is probably its most important job. The
    address space is divided into two parts: the network and the host portion. The
    subnet mask is used to indicate which portion in the network address consists
    of the network and which portion is the host by matching the network portion with
    a 1 and the host portion with a 0\. IPv4 expresses the address in the dotted notation,
    for example, `192.168.0.1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The subnet mask can either be in a dotted notation (`255.255.255.0`) or use
    a forward slash to express the number of bits that should be considered in the
    network bit (`255.255.255.0` or `/24`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, table  Description automatically generated](img/B18403_01_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: IPv4 header'
  prefs: []
  type: TYPE_NORMAL
- en: 'The IPv6 header, the next generation of the IP header of IPv4, has a fixed
    portion and various extension headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, table  Description automatically
    generated](img/B18403_01_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: IPv6 header'
  prefs: []
  type: TYPE_NORMAL
- en: The IPv6 **Next Header** field in the fixed header section can indicate an extension
    header to be followed that carries additional information. It can also identify
    the upper-layer protocol such as TCP and UDP. The extension headers can include
    routing and fragment information. For example, the extension header can include
    how the original packet is fragmented so the destination node can reassemble the
    packet accordingly. As much as the protocol designer would like to move from IPv4
    to IPv6, the Internet today is still mainly addressed with IPv4, with some of
    the service provider networks addressed with IPv6 natively.
  prefs: []
  type: TYPE_NORMAL
- en: IP network address translation (NAT) and network security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NAT is typically used for translating a range of private IPv4 addresses into
    publicly routable IPv4 addresses. But it can also mean a translation between IPv4
    and IPv6, such as at a carrier edge when they use IPv6 inside of the network that
    needs to be translated to IPv4 when the packet leaves the network. Sometimes,
    NAT6 to IPv6 is used as well for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Security is a continuous process that integrates all the aspects of networking,
    including automation and Python. This book aims to use Python to help you manage
    the network; security will be addressed as part of the following chapters in the
    book, such as using Python to implement access lists, search for breaches in the
    log, and so on. We will also look at how we can use Python and other tools to
    gain visibility in the network, such as a graphic network topology dynamically
    based on the network device information.
  prefs: []
  type: TYPE_NORMAL
- en: IP routing concepts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IP routing is about having the intermediate devices between the two endpoints
    transmit the packets between them based on the IP header. For all communication
    that happens on the Internet, the packet will traverse through various intermediate
    devices. As mentioned, the intermediate devices consist of routers, switches,
    optical gears, and various other gears that might not examine beyond the network
    and transport layer. In a road trip analogy, you might travel in the United States
    from the city of San Diego in California to the city of Seattle in Washington.
    The IP source address is analogous to San Diego and the destination IP address
    can be thought of as Seattle. On your road trip, you will stop by many different
    intermediate spots, such as Los Angeles, San Francisco, and Portland; these can
    be thought of as the intermediary routers and switches between the source and
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: Why was this important? In a way, this book is about managing and optimizing
    these intermediate devices. In the age of mega data centers that span the size
    of multiple American football fields, the need for efficient, agile, reliable,
    and cost-effective ways to manage the network becomes a major point of competitive
    advantage for companies. In future chapters, we will dive into how we can use
    Python programming to effectively manage a network.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at network reference models and protocol suites, we’re
    ready to dive into the Python language itself. In this chapter, we’ll begin with
    a broad overview of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python language overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a nutshell, this book is about making our network engineering lives easier
    with Python. But what is Python and why is it the language of choice of many DevOps
    engineers? In the words of the Python Foundation Executive Summary ([https://www.python.org/doc/essays/blurb/](https://www.python.org/doc/essays/blurb/)):'
  prefs: []
  type: TYPE_NORMAL
- en: ”Python is an interpreted, object-oriented, high-level programming language
    with dynamic semantics. Its high-level, built-in data structure, combined with
    dynamic typing and dynamic binding, makes it very attractive for Rapid Application
    Development, as well as for use as a scripting or glue language to connect existing
    components together. Python’s simple, easy-to-learn syntax emphasizes readability
    and therefore reduces the cost of program maintenance.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you are somewhat new to programming, the “object-oriented,” and “dynamic
    semantics” mentioned in the summary probably do not mean much to you. But I think
    we can all agree that “rapid application development” and “simple, easy-to-learn
    syntax” sound good. Python, as an interpreted language, means there is little
    to no compilation process required before execution, so the time needed to write,
    test, and edit Python programs is significantly reduced. For simple scripts, if
    your script fails, a print statement could be all you need to troubleshoot the
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Using the interpreter also means that Python is easily ported to different operating
    systems, such as Windows and Linux. A Python program written on one operating
    system can be used on another with little to no change.
  prefs: []
  type: TYPE_NORMAL
- en: The functions, modules, and packages encourage code reuse by breaking a large
    program into simple reusable pieces. The object-oriented nature of Python takes
    it one step further for grouping the components into objects. In fact, all Python
    files are modules that can be reused or imported into another Python program.
    This makes it easy to share programs between engineers and encourages code reuse.
    Python also has a *batteries-included* mantra, which means for everyday tasks,
    you need not download any additional packages outside of the Python language itself.
    To achieve this goal without the code being too bloated, a set of Python modules,
    a.k.a. standard libraries, are installed when you install the Python interpreter.
    For common tasks such as regular expressions, mathematical functions, and JSON
    decoding, all you need is the *import* statement, and the interpreter will move
    those functions into your program. This *batteries-included* mantra is what I
    would consider one of the killer features of the Python language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the fact that Python code can start in a relatively small-sized script
    with a few lines of code and grow into a complete production system is convenient
    for network engineers. As many of us know, the network typically grows organically
    without a master plan. A language that can grow with your network is invaluable.
    You might be surprised to see that a language deemed a scripting language by many
    is being used for whole production systems of many cutting-edge companies (organizations
    using Python: [https://wiki.python.org/moin/OrganizationsUsingPython](https://wiki.python.org/moin/OrganizationsUsingPython)).'
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever worked in an environment where you must switch between working
    on different vendor platforms, such as Cisco IOS and Juniper Junos, you know how
    painful it is to switch between syntaxes and usage when trying to achieve the
    same task. Since Python is flexible enough for both small and large programs,
    there is no such dramatic context switching. It is just the same Python code from
    small to large!
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the chapter, we will take a high-level tour of the Python language.
    If you are already familiar with the basics, feel free to quickly scan through
    it or skip ahead to *Chapter 2*.
  prefs: []
  type: TYPE_NORMAL
- en: Python versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As many readers will already be aware, Python has been going through a transition
    from Python 2 to Python 3 for the last few years. Python 3 was released in 2008,
    over 10 years ago, **with active development**, with the most recent release of
    3.10\. Unfortunately, Python 3 is not backward compatible with Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing the fourth edition of this book, in mid-2022, the Python
    community has all but moved over to Python 3\. In fact, Python 2 officially entered
    end-of-life as of January 1, 2020\. The latest Python 2.x release, 2.7, was released
    over six years ago in mid-2010\. Since Python 2 is end-of-life and is no longer
    maintained by the Python Software Foundation, we should all be using Python 3\.
    In this book, we will be using the latest stable Python 3 release, Python 3.10\.
    Python 3.10 has many exciting features, such as a stable asynchronous I/O that
    is very helpful in network automation. This book will use Python 3 for the code
    examples unless otherwise stated. When applicable, we will point out the Python
    2 and Python 3 differences.
  prefs: []
  type: TYPE_NORMAL
- en: Operating system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, Python is cross-platform. Python programs can be run on Windows,
    Mac, and Linux. In reality, certain care needs to be taken when you need to ensure
    cross-platform compatibilities, such as taking care of the subtle differences
    between backslashes in Windows filenames and the steps to activate Python virtual
    environments on different operating systems. Since this book is written for DevOps,
    systems, and network engineers, Linux is the preferred platform for the intended
    audience, especially in production.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this book will be tested on Linux Ubuntu 22.04 LTS machines. As
    of this writing, Python 3.10.4 is the default version that ships with 22.04, so
    we do not need to install Python 3 separately. I will also try my best to make
    sure the code runs the same on the Windows and the macOS platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in the OS details, they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Running a Python program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python programs are executed by an interpreter, which means the code is fed
    through this interpreter to be executed by the underlying operating system. There
    are several different implementations of the interpreter by the Python development
    community, such as IronPython and Jython. In this book, we will use the most common
    Python interpreter today, CPython. Whenever we mention Python in this book, we
    refer to CPython unless otherwise indicated.
  prefs: []
  type: TYPE_NORMAL
- en: One way you can use Python is by taking advantage of the interactive prompt.
    This is useful when you want to quickly test a piece of Python code or concept
    without writing a whole program.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is typically done by simply typing in the `Python3` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The interactive mode is one of Python’s most useful features. In the interactive
    shell, you can type any valid statement or sequence of statements and immediately
    get a result back. I typically use the interactive shell to explore a feature
    or library that I am not familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: The interactive mode can also be used for more complex tasks such as experimenting
    with data structure behaviors, for example, mutable versus immutable data types.
    Talk about instant gratification!
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, if you do not get a Python shell prompt back, you might not have
    the program in your system search path. The latest Windows Python installation
    program provides a checkbox for adding Python to your system path; make sure that
    is checked during installation. Or, you can add the program to the path manually
    by going to **Environment settings**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more common way to run the Python program, however, is to save your Python
    file and run it via the interpreter after. This will save you from typing in the
    same statements repeatedly. Python files are just regular text files typically
    saved with the `.py` extension. In the *Nix world, you can also add the **shebang**
    (#!) line on top to specify the interpreter that will be used to run the file.
    The `#` character can be used to specify comments that will not be executed by
    the interpreter. The file `helloworld.py` has the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let us take a look at the basic Python building structures, built-in data types.
  prefs: []
  type: TYPE_NORMAL
- en: Python built-in types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In computer programming, data types typically refer to a way for the computer
    program to know the kind of value a variable can have, such as a word or a number.
    Python implements dynamic typing, or duck typing, and tries to determine the object’s
    type as you declare it automatically. Python has several standard types built
    into the interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numerics**: `int`, `float`, complex, and `bool` (the subclass of `int` with
    a `True` or `False` value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequences**: `str`, `list`, `tuple`, and `range`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mappings**: `dict`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sets**: `set` and `frozenset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None**: The `null` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will briefly examine the different types in Python. If they do not make sense
    to you at this moment, they might make more sense when we apply them in examples
    in the section that follows.
  prefs: []
  type: TYPE_NORMAL
- en: The None type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `None` type denotes an object with no value. The `None` type is returned
    in functions that do not explicitly return anything such as a function but just
    do some math calculation and exit. The `None` type is also used in function arguments
    to error out if the caller does not pass in an actual value. For example, we can
    specify in a function ‘if a==None, raise an error’.
  prefs: []
  type: TYPE_NORMAL
- en: Numerics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python numeric objects are basically numbers. With the exception of Booleans,
    the numeric types of `int`, `long`, `float`, and `complex` are all signed, meaning
    they can be positive or negative. A Boolean is a subclass of the integer, which
    can be one of two values: 1 for True, and 0 for False. In practice, we are almost
    always testing Booleans with True or False instead of the numerics 1 and 0\. The
    rest of the numeric types are differentiated by how precisely they can represent
    the number; in Python 3, `int` does not have a maximum size while in Python 2
    `int` indicates whole numbers with a limited range. Floats are numbers using the
    double-precision representation (64-bit) on the machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sequences are ordered sets of objects with an index of non-negative integers.
    Since there are many different sequence types in Python (str, lists, tuple, etc),
    let us use the interactive interpreter to illustrate the different sequence types.
  prefs: []
  type: TYPE_NORMAL
- en: Please feel free to type along on your own computer.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it surprises people that `string` (think of words) is a sequence
    type. But if you look closely, strings are a series of characters put together.
    Strings are enclosed by either single, double, or triple quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note in the following examples, the quotes must match. A beginning double quote
    needs to be matched with an ending double quote. Triple quotes allow the string
    to span different lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The other two commonly used sequence types are lists and tuples. Lists are sequences
    of arbitrary objects. Lists can be created by enclosing objects in square brackets.
    Just like strings, lists are indexed by non-zero integers that start at zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of a list are retrieved by referencing the index number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples are like lists, created by enclosing values in parentheses. Like lists,
    the values in the tuple are retrieved by referencing its index number. Unlike
    lists, the values cannot be modified after creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Some operations are common to all sequence types, such as returning an element
    by index. A sequence can also be sliced for a portion of its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the index starts at 0\. Therefore, the index of 1 is the second
    element in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also common functions that can be applied to sequence types, such
    as checking the number of elements and finding the minimum and maximum values
    amongst all the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are various methods that are applicable only to strings. It is worth
    noting that these methods do not modify the underlying string data itself and
    always return a new string. In short, mutable objects such as lists and dictionaries
    can be changed after creation, and immutable objects, for example, strings, cannot.
    If you want to use the new returned value for other operations, you will need
    to catch the return value and assign it to a different variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some of the common methods for a list. The Python list data type is
    a very useful structure in terms of putting multiple items together and iterating
    through them one at a time. For example, we can make a list of data center spine
    switches and apply the same access list to all of them by iterating through them
    one by one. Since a list’s value can be modified after creation (unlike tuples),
    we can also expand and contract the existing list as we move along the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Python lists are great for storing data, but it is a bit tricky at times to
    keep track of data if we need to reference it by location. If that is an issue,
    we can use a different Python data type. Let’s look at Python mapping type next.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python provides one mapping type, called the **dictionary**. The dictionary
    data type is what I think of as a poor man’s database because it contains objects
    that can be indexed by keys. This is often referred to as an *associated array
    or hashing table* in other programming languages. If you have used any of the
    dictionary-like objects in other languages, you will know how powerful this type
    can be, because you can refer to the object with a human-readable key.
  prefs: []
  type: TYPE_NORMAL
- en: This key, instead of just a number, will make much more sense to the poor guy
    who is trying to maintain and troubleshoot the code. That guy could be you only
    a few months after you wrote the code, trying to troubleshoot the code at 2 AM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object in the dictionary value can also be another data type, such as a
    list. As we have used square brackets for lists and round braces for tuples, we
    use curly braces to create a dictionary. Here is an example of how we can use
    a dictionary to represent our data center devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Python dictionary is one of my favorite data containers to use in network
    scripts and I use it all the time. However, there are other data containers that
    can come in handy in different use cases – a set is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **set** is used to contain an unordered collection of objects. Unlike lists
    and tuples, sets are unordered and cannot be indexed by numbers. But there is
    one character that makes sets stand out as useful: the elements of a set are never
    duplicated. Imagine you have a list of IPs that you need to put in an access list.
    The only problem with this list of IPs is that they are full of duplicates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, think about how many lines of code you would use to loop through the list
    of IPs to sort out unique items, one at a time. Now consider this: the built-in
    set type would allow you to eliminate duplicate entries with just one line of
    code. Personally, the Python set data type is not used that much in my code, but
    when I need it, I am always very thankful it exists. Once the set or sets are
    created, they can be compared with each other using the `union`, `intersection`,
    and `differences`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have looked at different data types, we will take a tour of Python
    operators next.
  prefs: []
  type: TYPE_NORMAL
- en: Python operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has some *numeric operators* that you would expect from any programming
    language, such as `+`, `-`, and so on; note that the truncating division (`//`,
    also known as **floor division**) truncates the result to an integer and a floating-point
    but only the integer value is returned. The modulo (`%`) operator returns the
    remainder value in the division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also *comparison operators*. Note the double equals sign is used
    for comparison and a single equals sign is used for variable assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use two of the common membership operators to test whether an object
    is in a sequence type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Python operators allow us to perform simple operations efficiently. In the
    next section, we will look at how we can use control flows to repeat these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Python control flow tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `if`, `else`, and `elif` statements control conditional code execution.
    Unlike some other programming languages, Python uses indentation to structure
    blocks. There can be any number of indentation spaces as long as they align. Common
    practice is typically to use 2 or 4 spaces. The format of the conditional statement
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` loop will continue to execute until the condition is `False`, so
    be careful with this one if you don’t want to continue to execute (and crash your
    process):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop works with any object that supports iteration; this means all
    the built-in sequence types, such as `lists`, `tuples`, and `strings`, can be
    used in a `for` loop. The letter `i` in the following for loop is an iterating
    variable, so you can typically pick something that makes sense within the context
    of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have looked at Python data types, operators, and control flows,
    we are ready to group them together into reusable code pieces called functions.
  prefs: []
  type: TYPE_NORMAL
- en: Python functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often times when you find yourself copying and pasting some pieces of code,
    it is a good sign you should break it up into self-contained chunks of functions.
    This practice allows for better modularity, is easier to maintain, and allows
    for code reuse. Python functions are defined by using the `def` keyword with the
    function name, followed by the function parameters. The body of the function consists
    of the Python statements that are to be executed. At the end of the function,
    you can choose to return a value to the function caller. By default, it will return
    the `None` object if you do not specify a return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see a lot more examples of functions in the following chapters, but
    here is a quick example. In the following example, we use positional parameters,
    so the first element is referred to by the first variable in the function. Another
    way of referring to parameters is keywords with default values, such as `def subtract(a=10,
    b=5)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Python functions are great for grouping tasks together. Can we group different
    functions into a bigger piece of reusable code? Yes, we can do that via Python
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Python classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is an **object-oriented programming** (**OOP**) language. The way Python
    creates objects is with the `class` keyword. A Python object is most commonly
    a collection of functions (methods), variables, and attributes (properties). Once
    a class is defined, you can create instances of the class. The class serves as
    a blueprint for subsequent instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topic of OOP is outside the scope of this chapter, but here is a simple
    example of a `router` object definition to illustrate the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once defined, we can create as many instances of that class as we’d like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there is a lot more to Python objects and OOP. We will look at more
    examples in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Python modules and packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any Python source file can be used as a module and any functions and classes
    you define in that source file can be reused by other Python scripts. To load
    the code, the file referencing the module needs to use the `import` keyword. Three
    things happen when the file is imported:'
  prefs: []
  type: TYPE_NORMAL
- en: The file creates a new namespace for the objects defined in the source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The caller executes all the code contained in the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file creates a name within the caller that refers to the module being imported.
    The name matches the name of the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember the `subtract()` function that we defined using the interactive shell?
    To reuse the function, we can put it into a file named `subtract.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In a file within the same directory of `subtract.py`, you can start the Python
    interpreter and import this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This works because, by default, Python will first search for the current directory
    for the available modules. Remember the standard library that we mentioned a while
    back? You guessed it, those are just Python files being used as modules.
  prefs: []
  type: TYPE_NORMAL
- en: If you are in a different directory, you can manually add a search path location
    using the `sys` module with `sys.path`.
  prefs: []
  type: TYPE_NORMAL
- en: Can we group multiple modules together in Python? Yes, Python packages allow
    a collection of modules to be grouped together. This further organizes Python
    modules for more namespace protection and better reusability. A package is defined
    by creating a directory with a name you want to use as the namespace, then placing
    the module source file under that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for Python to recognize the directory as a Python package, just create
    a `__init__.py` file in this directory. The `__init__.py` file can be an empty
    file. In the same example as the `subtract.py` file, let’s say if you were to
    create a directory called `math_stuff`, we can create a `__init__.py` file in
    the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The way to refer to the module is to include the package name using dot notation,
    for example, `math_stuff.subtract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, modules and packages are great ways to organize large code files
    and make sharing Python code a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the OSI model and reviewed network protocol suites,
    such as TCP, UDP, and IP. They work as the layers that handle the addressing and
    communication negotiation between any two hosts. The protocols were designed with
    extensibility in mind and have largely been unchanged from their original design.
    Considering the explosive growth of the internet, that is quite an accomplishment.
  prefs: []
  type: TYPE_NORMAL
- en: We also quickly reviewed the Python language, including built-in types, operators,
    control flows, functions, classes, modules, and packages. Python is a powerful,
    production-ready language that is also easy to read. This makes the language an
    ideal choice when it comes to network automation. Network engineers can leverage
    Python to start with simple scripts and gradually move on to other advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Low-Level Network Device Interactions*, we will start to look
    at using Python to programmatically interact with network equipment.
  prefs: []
  type: TYPE_NORMAL
- en: Join our book community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2903617220506617062.png)'
  prefs: []
  type: TYPE_IMG
