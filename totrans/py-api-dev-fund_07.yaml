- en: 7\. Working with Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a user avatar function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop an image uploading API using Flask-Uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize images using an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compress images using Pillow to enhance API performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to perform image uploads so that we can let
    users post a profile picture and recipe cover image to our Smilecook application.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we completed the account opening workflow by activating
    the user accounts via email. In this chapter, we will develop a function so that
    we can upload pictures. These pictures are the user's profile picture and the
    recipe cover images. Aside from uploading images, we will also discuss image compression.
    Pillow is an image processing package that we are going to use to compress images
    up to 90%. This can greatly enhance the performance of our API without compromising
    on the image's quality.
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, we will introduce two Python packages, Flask-Uploads and
    Pillow, in this chapter. Flask-Uploads allows us to quickly develop image uploading
    functions. For image compression, we will be using Pillow. It can generate images
    in our specified format and compress them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Building the User Avatar Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our Smilecook application, there are user profile pages that list user information.
    While this is useful enough, it would be much better if we could allow users to
    upload a profile picture (avatar) to their profile page. This would make the application
    more sociable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To store the user avatar, we will create a new attribute (`avatar_image`) in
    the user model. We are not going to store the image directly in this attribute.
    Instead, we are going to store the image on the server, and the new attribute
    will have the filename of the image. Later, when our API gets a client request
    asking for the image, we will find the filename in this attribute and generate
    the URL to point to the image location and then return it to the frontend client-side.
    The frontend client will then base on the image URL and fetch it from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Building a user model avatar diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: Building a user model avatar diagram'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We are going to create a new endpoint, `http://localhost:5000/users/avatar`,
    that will take `PUT` requests. The reason we have designed it to accept `PUT`
    requests is that there should be only one avatar picture for each user. So, every
    time there is a client request, it should be either replacing an empty image with
    the new image for the first time, or it will be replacing the old image with a
    new one. This is a replacement action. In this case, we should use the HTTP verb,
    PUT.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add the `avatar_image` attribute in our model. We will have to use
    Flask-Migrate to update the underlying database table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 45: Adding the avatar_image Attribute to the User Model'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will work on changing the user model. First, we will create
    an additional attribute (`avatar_image`) in the user model. Then, we will reflect
    it in the database schema and use the Flask-Migrate Python package to create the
    corresponding field in the database table. Finally, we will confirm the change
    is successful by using pgAdmin. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `avatar_image` attribute to the user model. The code file is `models/user
    .py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `avatar_image` attribute is designed to store the filename of the uploaded
    image. Due to this, it is a string with a length of `100`. The default is `None`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to generate the database migration script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see that a new column called `user.avatar_image` has been detected:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the content in `/migrations/versions/7aafe51af016_.py`, which is the
    database migration script that we generated in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From its content, we can see that two functions have been generated in the
    script: `upgrade` and `downgrade`. The `upgrade` function is used to add the new
    `avatar_image` column to the database table, while the `downgrade` function is
    used to remove the `avatar_image` column so that it can go back to its original
    state.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following `flask db upgrade` command to update the database schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the schema `change` in pgAdmin. *Right-click* on the `user` table and
    choose `Properties`. A new window will appear. Then, click the `Columns` tab to
    check the columns:![Figure 7.2: Checking all the columns in the Columns tab'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_07_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.2: Checking all the columns in the Columns tab'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we can see the new `avatar_image` column being added to the `user` table.
    Now, our Smilecook application is ready to take in the image path of the user
    avatar.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-Uploads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using the Flask-Uploads package to complete our image upload function.
    This is a very powerful package that simplifies most of the tedious coding for
    us. By simply calling a few methods provided by the package, it allows us to efficiently
    and flexibly develop the file upload function. Flask-Uploads can handle various
    common file types out of the box. What we need to define is the Set that classifies
    the types of uploaded files, such as `IMAGES`, `DOCUMENT`, `AUDIO`, and so on.
    Then, we simply need to set the destination of the uploaded files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few basic concepts and functions in Flask-Uploads before we
    implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Upload Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we upload any files, we need to define the `UploadSet`. An upload set
    is a single collection of files. Take `images` as an example; we can define the
    image upload set as follows, where `''images''` is the name of the upload set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the `image_set`, you can use the `save` method to save the uploaded
    image from the incoming HTTP request, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An upload set''s configuration also needs to be stored on an app. We can use
    the `configure_uploads` function from Flask-Uploads to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In addition, you can also use `patch_request_class` to restrict the maximum
    upload size of the uploaded file. In the next exercise, we will work on the image
    upload function together. The image user is going to upload their avatar picture.
    We will define the destination as `static/images/avatars`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 46: Implementing the User Avatar Upload Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will start by installing the Flask-Uploads package to
    our virtual environment. Then, we will do some simple configurations and get to
    work on the image upload function development. By completing this exercise, we
    will see an image URL being returned to the client. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line in `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to install the Flask-Uploads package in the PyCharm
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following installation result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `UploadSet` and `IMAGES` into `extensions.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `extensions.py` file, define a set called `''images''` and an extension
    called `IMAGES`. This will cover the common image file extensions (`.jpg`, `.jpeg`,
    `.png`, and so on):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the image destination in `Config.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The `UPLOADED_IMAGES_DEST` attribute name is decided by the name of the upload
    set. Since we set the upload set name to be `'images'`, the attribute name here
    must be `UPLOADED_IMAGES_DEST`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import `configure_uploads`, `patch_request_class`, and `image_set` into `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the `configure_uploads` function that we have just imported, pass in
    the `image_set` that we want to upload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the maximum file size allowed for uploads as 10 MB using `patch_request_class`.
    This step is important because, by default, there is no upload size limit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `url_for` function in `schemas/user.py` and add the `avatar_url`
    attribute and `dump_avatar_url` method under the `UserSchema` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `url_for` function is used to help generate the URL of the image file. The
    `dump_avatar_url` method is used to return the URL of the user avatar after serialization.
    If no image is being uploaded, we will simply return the URL of the default avatar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a folder called `assets` under `static/images` and place the `default-avatar.jpg`
    image inside it. This image is going to be our default user avatar:![Figure 7.3:
    Folder structure after adding the image'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_07_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.3: Folder structure after adding the image'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: You can put any image you like in here. We have also provided a default avatar
    image in our sample code folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the `uuid` extension, and `image_set` into `utils.py`. You will see
    how these modules/methods are used next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `save_image` function to `utils.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `save_image` method, we used the `uuid` function to generate the filename
    for the uploaded image. We got the file extension from the uploaded image using
    the extension function from Flask-Uploads. Then, we saved the image using the
    `image_set.save` function; the saving destination is `static/images`. If we pass
    in `folder='avatar'` as the parameter, the destination will be `static/images/avatar`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the `image_set` and `save_image` functions from `utils` into `resources/user.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `user_avatar_schema` to `resources/user.py`. This schema is just to show
    the `avatar_url`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `UserAvatarUploadResource` class, in `resources/user.py`, and define
    the `put` method inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `@jwt_required` decorator before the `put` method means that login is required
    before this method is triggered. In the `put` method, we got the avatar image
    file from `request.files`. Then, we validated whether the image file exists and
    whether the file extension is permitted. If everything is okay, we will get back
    the user object and check whether an avatar already exists. If so, that will be
    removed before we replace it with our uploaded image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we used `save_image` to save the uploaded image. Once the image is saved,
    we will get the filename of the image and save it to `user.avatar_image`. Then,
    we used `user.save()` to save the update to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `user_avatar_schema.dump(user).data` to return the image URL and the HTTP
    status code, **200 OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `UserAvatarUploadResource` class into `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Link the resource to the route, that is `/users/avatar in app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have successfully created the user avatar image upload function in our Smilecook
    application. Now, we can upload an image to the user profile page. In the next
    exercise, we will test that using Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 47: Testing the User Avatar Upload Function Using Postman'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous exercise, we finished developing the avatar uploading function.
    To make sure things are working as expected, we need to test the function from
    the client-side. We will be using Postman to send the client request, which will
    have the user avatar image in it. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, log in to a user account. Now, click on the **Collections** tab and
    select the **POST Token** request. Then, click the **Send** button. The result
    can be seen in the following screenshot:![Figure 7.4: Sending the POST Token request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_07_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.4: Sending the POST Token request'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we are going to use the `PUT` method to upload an avatar. Send an HTTP
    `PUT` request to the following URL: `http://localhost:5000/users/avatar`. Click
    on the `User` folder, and then create a new request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `UserAvatarUpload` and save it in the **User** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `PUT` as the HTTP method and type in `http://locaohost:5000/users/avatar`
    as the request URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select the `Authorization` into the `Bearer {token}` into the **VALUE**
    field, where the token is the access token we got in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Body** tab. Then, select the **form-data** radio button and put
    "avatar" as the **KEY**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **File** in the drop-down menu next to **Key** and select the image file
    to upload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click the `avatar_url` in the response, meaning that our image upload request
    was successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clicking on `avatar_url` should bring you to the uploaded image. Check the
    path, `static/images/avatars`, in PyCharm. You should see the uploaded image there:![Figure
    7.6: Checking the uploaded image'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_07_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.6: Checking the uploaded image'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Send a request to get a user back by their `username`. Click on the **Collections**
    tab and select the **GET User** request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `http://localhost:5000/users/john` into the URL field. You can replace
    the username, that is, **John**, with any username that is appropriate and then
    click the **Send** button. The result can be seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.7: Checking the user avatar URL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: Checking the user avatar URL'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we can see the new avatar URL attribute in the user.
  prefs: []
  type: TYPE_NORMAL
- en: This testing exercise proves that the image upload function is working as expected.
    We can also look up the user by placing the username in the endpoint URL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can test two more aspects of the `avatar image upload` functions. The first
    one is to upload an image that's greater than 10 MB in size. The second is to
    test whether the default avatar image (that is, `default-avatar.jpg`) will be
    used for a user account that has no uploaded avatar.
  prefs: []
  type: TYPE_NORMAL
- en: Image Resizing and Compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The size of the image will affect the speed of the website. Imagine looking
    at a picture that's 10 MB in size. If there are 10 pictures on one page, this
    website will be 100 MB in size, and so it will take a lot of time to get a page.
    Due to this, a good practice to reduce the size of the image and compress it so
    that it's around 500 KB in size instead.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will also convert the image into JPEG (it has the `.JPG` file
    extension). JPEG is an image compression technology that can remove unnoticeable,
    insignificant details in an image, thus achieving a smaller file size. Besides,
    it is often regarded as acceptable to have a lower image quality for web use.
  prefs: []
  type: TYPE_NORMAL
- en: In our Smilecook application, we will convert all our uploaded images into JPG
    format and compress them. We will do this through the Pillow package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We cannot have a transparent image in JPEG format. If we save an image with
    the background removed as a JPEG, the background will become white, instead of
    transparent. The other two commonly used image formats, PNG and GIF. These two
    image formats will support transparency in images.
  prefs: []
  type: TYPE_NORMAL
- en: In our Smilecook application, however, we won't be displaying a transparent
    image, so using JPG images will be good enough here.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pillow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pillow, previously known as the `Image`. We can use `Image.open` to create an
    object from an `image` file. We can then get the image dimension in pixels by
    using the attribute `size`. We can also find out the color mode of the image by
    using the attribute mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common color modes you should expect to see include `L` for black and
    white, `RGB` for red-green-blue, and `CMYK` for cyan-magenta-yellow-black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to change the color mode of the picture to RGB, use the `convert`
    function. We usually change the color mode to ensure the color accuracy of our
    images. RGB is the most commonly used color mode for computer monitors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If we want to resize an image so that it has smaller dimensions, we should use
    the `thumbnail` method. This method can maintain the aspect ratio of the image,
    and at the same time make sure that each side of the image is less than our defined
    limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the resultant image''s sides will be less than `1600` px, while
    keeping the aspect ratio intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we save our changes using the Pillow package, we can pass in a `quality`
    parameter. This is done to specify how much JPEG compression we want. The quality
    can range from 1 to 100, with 1 being the worst and 95 being the best. We should
    avoid putting in a value higher than 95 because that means almost no compression.
    The default quality value is 75:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let's complete an exercise in order to implement image compression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 48: Implementing Image Compression in Our Smilecook Application'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we''ve learned about the theory and the tools we can use to perform
    image compression, let''s apply that to our Smilecook application. We would like
    to compress the user''s avatar. We will be using the Pillow package to do this.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Pillow` package to `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the `Pillow` package by running the `pip install` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following installation result after running the preceding
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the necessary package and module into `utils.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `utils.py`, define the `compress_image` function, which takes the filename
    and `folder` as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we will use `image_set.path(filename=filename, folder=folder)` to get
    the actual image file''s location. Then, by using `Image.open(file_path)`, we
    will create the `image` object from the image file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the color mode to `RGB` and resize it so that each side is no bigger
    than `1600` px:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate the new filename and path for our compressed image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the compressed image with `quality = 85`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `os.stat(file_path)` to get the size in bytes. By doing this, we will have
    the original size for a before and after comparison in our testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The `os.stat` method is a Python method that returns basic folder/file information
    (for example, owner ID, group owner ID, and file size).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remove the original image and then return the compressed image filename by
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in the `save_image` function, under `utils.py`, call the `compress_image`
    function right after the image is saved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have created our compress_image function. The function just needs to
    know where the image file is, and it will compress the image for us.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will test the image compression function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 49: Testing the Image Compression Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have developed an image compression function that can compress the
    avatar that was uploaded by the user. In this exercise, we will test and see how
    the image compression function does. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to use the `PUT` method to upload an avatar. We will send
    an HTTP `http://localhost:5000/users/avatar`. Click on **PUT UserAvatarUpload**
    and select the **Body** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select a large image file to upload and click the **Send** button. The result
    can be seen in the following screenshot:![Figure 7.8: Uploading an avatar using
    the PUT method'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_07_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 7.8: Uploading an avatar using the PUT method'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'From the application log in PyCharm, we can see that the original size of the
    uploaded image was 7.6 MB; it is reduced to 618 KB after compression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9: Image size after compression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: Image size after compression'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By doing this, we can see that the image compression function that we implemented
    previously works. Now, the image size has been significantly reduced. In the next
    activity, we will implement the recipe cover image upload function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11: Implementing the Recipe Cover Image Upload Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have learned how to develop the image upload and compression function.
    In this activity, we are going to work on the recipe cover image upload function
    for the Smilecook application. We want to make our recipe more attractive by providing
    a cover image for it. Similar to the user avatar, only one cover image is allowed
    per recipe. Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `cover_image` attribute to the user model in `models/recipe.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the corresponding DB schema using the `flask db migrate` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `recipe_cover_schema` to show the `cover_url` in the HTTP response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `RecipeCoverUploadResource` for the recipe cover image upload function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 323.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 12: Testing the Image Upload Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we are going to test the recipe cover image uploading function.
    First, we will create a new recipe, upload a recipe cover image, and verify whether
    it has been uploaded by fetching the recipe back. Follow these steps to complete
    this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Smilecook user account using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a client request to our API to create a recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the recipe images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the image is compressed in PyCharm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the uploaded image in `static/images/recipes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the recipe back and confirm that the `cover_url` attribute is populated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 328.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use Flask-Uploads to upload images for
    our user avatar and recipe cover. Since our maximum uploaded image size is 10
    MB, this allows users to upload huge images, thereby slowing down the performance
    of the website. To address this performance issue, we introduced the concept of
    image resizing and compression. From here, we worked on developing the function
    using the Pillow package.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from learning about new techniques regarding image manipulation, we also
    revisited things we learned in the previous chapters, such as updating the database
    schema using Flask-Migrate and displaying the URL of the uploaded image during
    deserialization using marshmallow's schema.
  prefs: []
  type: TYPE_NORMAL
- en: We have completed most of the key functionality of our Smilecook recipe sharing
    platform. In the next chapter, we will develop the recipe searching and pagination
    functions.
  prefs: []
  type: TYPE_NORMAL
