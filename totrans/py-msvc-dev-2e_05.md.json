["```py\n$ git clone https://gitlab.com/pgjones/quart\n$ cd quart\n$ radon  cc .  --average --min c\nasgi.py\n    M 205:4 ASGIWebsocketConnection.handle_websocket - C\nblueprints.py\n    M 510:4 Blueprint.register - D\ncli.py\n    F 278:0 routes_command - C\n    M 48:4 ScriptInfo.load_app - C\napp.py\n    M 1178:4 Quart.run - C\nhelpers.py\n    F 154:0 url_for - C\n    F 347:0 send_file - C\ntesting/utils.py\n    F 60:0 make_test_body_with_headers - C\n\n8 blocks (classes, functions, methods) analyzed.\nAverage complexity: C (15.125) \n```", "```py\n app.registry = Registry()\n    app.api_requests_gauge = Gauge(\n        \"quart_active_requests\", \"Number of active requests per endpoint\"\n    )\n    app.request_timer = Summary(\n        \"request_processing_seconds\", \"Time spent processing request\"\n    )\n    app.registry.register(app.api_requests_gauge)\n    app.registry.register(app.request_timer) \n```", "```py\n@app.route(\"/metrics\")\nasync def handle_metrics():\n    return render(app.registry, request.headers.getlist(\"accept\")) \n```", "```py\n# quart_metrics.py\nimport asyncio\nfrom random import randint\nfrom aioprometheus import Gauge, Registry, Summary, inprogress, render, timer\nfrom quart import Quart, request\napp = Quart(__name__)\napp.registry = Registry()\napp.api_requests_gauge = Gauge(\n    \"quart_active_requests\", \"Number of active requests per endpoint\"\n)\napp.request_timer = Summary(\n    \"request_processing_seconds\", \"Time spent processing request\"\n)\napp.registry.register(app.api_requests_gauge)\napp.registry.register(app.request_timer)\n@app.route(\"/\")\n@timer(app.request_timer, labels={\"path\": \"/\"})\n@inprogress(app.api_requests_gauge, labels={\"path\": \"/\"})\nasync def index_handler():\n    await asyncio.sleep(1.0)\n    return \"index\"\n@app.route(\"/endpoint1\")\n@timer(app.request_timer, labels={\"path\": \"/endpoint1\"})\n@inprogress(app.api_requests_gauge, labels={\"path\": \"/endpoint1\"})\nasync def endpoint1_handler():\n    await asyncio.sleep(randint(1000, 1500) / 1000.0)\n    return \"endpoint1\"\n@app.route(\"/endpoint2\")\n@timer(app.request_timer, labels={\"path\": \"/endpoint2\"})\n@inprogress(app.api_requests_gauge, labels={\"path\": \"/endpoint2\"})\nasync def endpoint2_handler():\n    await asyncio.sleep(randint(2000, 2500) / 1000.0)\n    return \"endpoint2\"\n@app.route(\"/metrics\")\nasync def handle_metrics():\n    return render(app.registry, request.headers.getlist(\"accept\"))\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\") \n```", "```py\n# prometheus.yml\n---\nglobal:\n  scrape_interval: 15s\n  external_labels:\n    monitor: 'quart-monitor'\nscrape_configs:\n  - job_name: 'prometheus'\n    scrape_interval: 5s\n    static_configs:\n      - targets: ['192.168.1.100:5000']  # Replace with your app's IP address\n        labels:\n          group: 'quart' \n```", "```py\ndocker run \\\n    -p 9090:9090 \\\n    -v /path/to/prometheus.yml:/etc/prometheus/prometheus.yml \\\n    prom/prometheus \n```", "```py\n# quart_logging.py\nimport logging\nfrom quart import Quart, request\napp = Quart(__name__)\napp.logger.setLevel(logging.INFO)\n@app.route(\"/hello\")\ndef hello_handler():\n    app.logger.info(\"hello_handler called\")\n    app.logger.debug(f\"The request was {request}\")\n    return {\"Hello\": \"World!\"}\nif __name__ == \"__main__\":\n    app.run() \n```", "```py\n [2021-06-26 21:21:41,144] Running on http://127.0.0.1:5000 (CTRL + C to quit)\n    [2021-06-26 21:21:42,743] INFO in quart_logging: hello_handler called\n    [2021-06-26 21:21:42,747] 127.0.0.1:51270 GET /hello 1.1 200 18 4702 \n```", "```py\n# quart_structlog.py\nimport logging\nfrom quart import Quart, request\nimport structlog\nfrom structlog import wrap_logger\nfrom structlog.processors import JSONRenderer\napp = Quart(__name__)\nlogger = wrap_logger(\napp.logger,\n    processors=[\n        structlog.processors.add_log_level,\n        structlog.processors.TimeStamper(),\n        JSONRenderer(indent=4, sort_keys=True),\n    ],\n)\napp.logger.setLevel(logging.DEBUG)\n@app.route(\"/hello\")\ndef hello_handler():\n    logger.info(\"hello_handler called\")\n    logger.debug(f\"The request was {request}\")\n    return {\"Hello\": \"World!\"}\nif __name__ == \"__main__\":\n    app.run() \n```", "```py\n[2021-06-26 21:54:24,208] INFO in _base: {\n    \"event\": \"hello_handler called\",\n    \"level\": \"info\",\n    \"timestamp\": 1624740864.2083042\n}\n[2021-06-26 21:54:24,211] DEBUG in _base: {\n    \"event\": \"The request was <Request 'http://localhost:5000/hello' [GET]>\",\n    \"level\": \"debug\",\n    \"timestamp\": 1624740864.211336\n} \n```", "```py\n# Decide which action to take, and take it.\nasync def process_message(message, metadata):\n    \"\"\"Decide on an action for a chat message.\n    Arguments:\n        message (str): The body of the chat message\n        metadata (dict): Data about who sent the message,\n                         the time and channel.\n    \"\"\"\n    reply = None\n    for test, action in ACTION_MAP.items():\n        if message.startswith(test):\n            reply = await action(message[len(test):] metadata)\n            break\n    if reply:\n        post_to_slack(reply, metadata)\n# Process the weather action\nasync def weather_action(text, metadata):\n    if text:\n        location = text.strip()\n    else:\n        with user_dal() as ud:\n            user = ud.get_user_by_slack_id(metadata[metadata[\"sender\"])\n            if user.location:\n                location = user.location\n            else:\n                return \"I don't know where you are.\"\n    return await fetch_weather(location) \n```", "```py\nasync def extract_location(text):\n    \"\"\"Extract location information from free-form text.\"\"\"\n    return re.sub(r'^weather (in )?', '', text)\nasync def fetch_user_location(slack_id):\n    location = None\n    with user_dal() as ud:\n           user = ud.get_user_by_slack_id(metadata[metadata[\"sender\"])\n        location = user.location\n    return location \n```", "```py\nasync def process_weather_action(text, metadata):\n    potential_location = await extract_location(text)\n    if not potential_location:\n        potential_location = await fetch_user_location(metadata[\"sender\"])\n    if potential_location:\n        await weather_action(potential_location, metadata)\n    else:\n        await send_response(\"I don't know where you are\", metadata)\nasync def weather_action(location, metadata):\n    reply = await fetch_weather(location)\n    await send_response(reply, metadata) \n```", "```py\n@app.route(\"/migrating_endpoint\")\nasync def migration_example():\n    if current_app.config.get(\"USE_NEW_WORKER\"):\n        return await new_worker()\n    else:\n        return await original_worker()\n@app.route(\"/migrating_gradually\")\nasync def migrating_gradually_example():\n    percentage_split = current_app.config.get(\"NEW_WORKER_PERCENTAGE\")\n    if percentage_split and random.randint(1,100) <= percentage_split:\n        return await new_worker()\n    else:\n        return await original_worker() \n```"]