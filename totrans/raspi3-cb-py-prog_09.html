<html><head></head><body><div><h1 class="header-title">Using Python to Drive Hardware</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Controlling an LED</li>
<li>Responding to a button</li>
<li>The controlled shutdown button</li>
<li>The GPIO keypad input</li>
<li>Multiplexed color LEDs</li>
<li>Writing messages using persistence of vision</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>One of the key features of a Raspberry Pi computer that sets it apart from most other home/office computers is that it has the ability to directly interface with other hardware. The <strong>general-purpose input/output</strong> (<strong>GPIO</strong>) pins on the Raspberry Pi can control a wide range of low-level electronics, from <strong>light-emitting diodes</strong> (<strong>LEDs</strong>) to switches, sensors, motors, servos, and even extra displays.</p>
<p>This chapter will focus on connecting the Raspberry Pi with some simple circuits and getting to grips with using Python to control and respond to the connected components.</p>
<p>The Raspberry Pi hardware interface consists of 40 pins located along one side of the board.</p>
<p>The GPIO pins and their layout will vary slightly according to the particular model you have.<br/>
<br/>
The Raspberry Pi 3, Raspberry Pi 2, and Raspberry Pi B+ all have the same 40-pin layout.<br/>
<br/>
The older Raspberry Pi 1 models (nonplus types) have a 26-pin header, which is the same as the 1-26 pins of the newer models.</p>
<div><img src="img/e50c6102-ea75-4379-9ac2-05c5d73b0826.png" style="width:27.92em;height:30.33em;" width="537" height="582"/></div>
<p>Raspberry Pi 2, Raspberry Pi B+, and Raspberry Pi Model Plus GPIO header pins (pin functions)</p>
<p>The layout of the connector is shown in the preceding diagram; the pin numbers are shown as seen from pin 1 of the GPIO header.</p>
<p><strong>Pin 1</strong> is at the end that is nearest to the SD card, as shown in the following photo:</p>
<div><img src="img/f196e25a-2289-4e35-8cd5-6606c5cb27ee.png" style="width:35.67em;height:19.50em;" width="1009" height="551"/></div>
<p>The Raspberry Pi GPIO header location</p>
<p>Care should be taken when using the GPIO header, since it also includes power pins (3V3 and 5 V), as well as <strong>ground</strong> (<strong>GND</strong>) pins. All of the GPIO pins can be used as standard GPIO, but several also have special functions; these are labeled and highlighted with different colors.</p>
<p>It is common for engineers to use a 3V3 notation to specify values in schematics in order to avoid using decimal places that could easily be missed (using 33V rather than 3.3V would cause severe damage to the circuitry). The same can be applied to the values of other components, such as resistors, for example, 1.2K ohms can be written as 1K2 ohms.</p>
<p>The <strong>TX</strong> and <strong>RX</strong> pins are used for serial communications, and with the aid of a voltage-level converter, information can be transferred via a serial cable to another computer or device.</p>
<p>We also have the <strong>SDA</strong> and <strong>SCL</strong> pins, which are able to support a two-wire bus communication protocol called <strong>I</strong><sup>2</sup><strong>C</strong> (there are two I<sup>2</sup>C channels on Raspberry Pi 3 and Model Plus boards: <strong>channel 1 ARM</strong>, which is for general use, and <strong>channel 0 VC</strong>, which is typically used for identifying <strong>hardware attached on top</strong> (<strong>HAT</strong>) modules). There are also the <strong>SPI MOSI</strong>, <strong>SPI MISO</strong>, <strong>SPI SCLK</strong>, <strong>SPI CE0</strong>, and <strong>SPI CE1</strong> pins, which support another type of bus protocol called <strong>SPI</strong> for high-speed data. Finally, we have the <strong>PWM0/1</strong> pin, which allows a <strong>pulse-width modulation</strong> signal to be generated, which is useful for servos and generating analog signals.</p>
<p>However, we will focus on using just the standard GPIO functions in this chapter. The GPIO pin layout is shown in the following diagram:</p>
<div><img src="img/d59a7392-0b90-4ff4-925f-6ba223b41867.png" style="width:40.25em;height:27.83em;" width="894" height="618"/></div>
<p>Raspberry Pi GPIO header pins (GPIO.BOARD and GPIO.BCM)</p>
<p class="mce-root">The Raspberry Pi Rev 2 (pre-July 2014) has the following differences compared to the Raspberry Pi 2 GPIO layout:</p>
<ul>
<li>26-GPIO-pin header (matching the first 26 pins).</li>
<li>An additional secondary set of eight holes (P5) located next to the pin header. The details are as follows:</li>
</ul>
<div><img src="img/b09b727f-30eb-4aba-a332-fb0c12da3f55.png" style="width:35.08em;height:7.75em;" width="1146" height="254"/></div>
<p>Raspberry Pi Rev 2 P5 GPIO header pins</p>
<ul>
<li>The original Raspberry Pi Rev 1 (pre-October 2012) has only 26 GPIO pins in total, (matching the first 26 pins of the current Raspberry Pi, except for the following details:</li>
</ul>
<div><img src="img/6b1df0d2-c988-41a3-bb88-18def3482504.png" style="width:29.50em;height:12.25em;" width="792" height="328"/></div>
<p>Raspberry Pi Rev 1 GPIO header differences</p>
<p>The <kbd>RPi.GPIO</kbd> library can reference the pins on the Raspberry Pi using one of two systems. The numbers shown in the center refer to the physical position of the pins, and are also the numbers referenced by the <kbd>RPi.GPIO</kbd> library when in <strong>GPIO.BOARD</strong> mode. The numbers on the outside (<strong>GPIO.BCM</strong>) are the actual reference numbers of the physical ports of the processor that indicate which of the pins are wired (which is why they are not in any specific order). They are used when the mode is set to <strong>GPIO.BCM</strong>, and they allow control of the GPIO header pins as well as any peripherals connected to other GPIO lines. This includes the LED on the add-on camera on BCM GPIO 4 and the status LED on the board. However, this can also include the GPIO lines used for reading/writing to the SD card, which would cause serious errors if interfered with.</p>
<p>If you use other programming languages to access the GPIO pins, the numbering scheme may be different, so it will be helpful if you are aware of the BCM GPIO references, which refer to the physical GPIO ports of the processor.</p>
<p>Be sure to check out the Appendix, <em>Hardware and Software List</em>, which lists all the items used in this chapter and the places that you can obtain them from.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Controlling an LED</h1>
                
            
            
                
<p>The hardware equivalent of <kbd>hello world</kbd> is an LED flash, which is a great test to ensure that everything is working and that you have wired it correctly. To make it a little more interesting, I've suggested using a <strong>red, blue, and green</strong> (<strong>RGB</strong>) LED, but feel free to use separate LEDs if that is all you have available.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need the following equipment:</p>
<ul>
<li>4 x DuPont female-to-male patch wires</li>
<li>Mini breadboard (170 tie points) or a larger one</li>
<li>RGB LED (common cathode)/3 standard LEDs (ideally red, green, and blue)</li>
<li>Breadboard wire (solid core)</li>
<li>3 x 470 ohm resistors</li>
</ul>
<p>Each of the preceding components shouldn't cost many dollars and can be reused for other projects afterwards. The breadboard is a particularly useful item that allows you to try out your own circuits without needing to solder them:</p>
<div><img src="img/96e27010-2851-4ffb-8b57-4fe8ef3d20b4.png" style="width:37.33em;height:17.17em;" width="1499" height="690"/></div>
<p>Diagrams of an RGB LED, a standard LED, and an RGB circuit</p>
<p>The following diagram shows the breadboard circuitry:</p>
<div><img src="img/03967de1-5654-44d2-9db7-5d44a5bfa065.png" style="width:28.58em;height:34.42em;" width="450" height="543"/></div>
<p>The wiring of an RGB LED/standard LEDs connected to the GPIO header</p>
<p>There are several different kinds of RGB LEDs available, so check the datasheet of your component to confirm the pin order and type you have. Some are RGB, so ensure that you wire accordingly or adjust the <kbd>RGB_</kbd> pin settings in the code. You can also get common anode variants, which will require the anode to be connected to 3V3 (GPIO-pin 1) for it to light up (and they will also require <kbd>RGB_ENABLE</kbd> and <kbd>RGB_DISABLE</kbd> to be set to <kbd>0</kbd> and <kbd>1</kbd> <kbd>respectively</kbd>).</p>
<p>The breadboard and component diagrams of this book have been created using a free tool called <strong>Fritzing</strong> (<a href="http://www.fritzing.org" target="_blank">www.fritzing.org</a>); it is great for planning your own Raspberry Pi projects.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the <kbd>ledtest.py</kbd> script as follows:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#ledtest.py 
import time 
import RPi.GPIO as GPIO 
# RGB LED module 
#HARDWARE SETUP 
# GPIO 
# 2[======XRG=B==]26[=======]40 
# 1[=============]25[=======]39 
# X=GND R=Red G=Green B=Blue  
#Setup Active States 
#Common Cathode RGB-LED (Cathode=Active Low) 
RGB_ENABLE = 1; RGB_DISABLE = 0 
 
#LED CONFIG - Set GPIO Ports 
RGB_RED = 16; RGB_GREEN = 18; RGB_BLUE = 22 
RGB = [RGB_RED,RGB_GREEN,RGB_BLUE] 
 
def led_setup(): 
  #Setup the wiring 
  GPIO.setmode(GPIO.BOARD) 
  #Setup Ports 
  for val in RGB: 
    GPIO.setup(val,GPIO.OUT) 
 
def main(): 
  led_setup() 
  for val in RGB: 
    GPIO.output(val,RGB_ENABLE) 
    print("LED ON") 
    time.sleep(5) 
    GPIO.output(val,RGB_DISABLE) 
    print("LED OFF") 
 
try: 
  main() 
finally: 
  GPIO.cleanup() 
  print("Closed Everything. END") 
#End</pre>
<ol start="2">
<li>The <kbd>RPi.GPIO</kbd> library will require <kbd>sudo</kbd> permissions to access the GPIO pin hardware, so you will need to run the script using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo python3 ledtest.py</strong>  </pre>
<p style="padding-left: 60px">When you run the script, you should see the red, green, and blue parts of the LED (or each LED, if you're using separate ones) light up in turn. If not, double-check your wiring or confirm that the LED is working by temporarily connecting the red, green, or blue wire to the 3V3 pin (pin 1 of the GPIO header).</p>
<p>The <kbd>sudo</kbd> command is required for most hardware-related scripts because it isn't normal for users to directly control hardware at such a low level. For example, setting or clearing a control pin that is part of the SD card controller could corrupt data being written to it. Therefore, for security purposes, superuser permissions are required to stop programs from using hardware by accident (or with malicious intent).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>To access the GPIO pins using Python, we import the <kbd>RPi.GPIO</kbd> library, which allows direct control of the pins through the module functions. We also require the <kbd>time</kbd> module to pause the program for a set number of seconds.</p>
<p>We then define values for the LED wiring and active states (see <em>Controlling the GPIO current</em> segment in the <em>There's more...</em> section of this recipe).</p>
<p>Before the GPIO pins are used by the program, we need to set them up by specifying the numbering method—<kbd>GPIO.BOARD</kbd>—and the direction—<kbd>GPIO.OUT</kbd> or <kbd>GPIO.IN</kbd> (in this case, we set all the RGB pins to outputs). If a pin is configured as an output, we will be able to set the pin state; similarly, if it is configured as an input, we will be able to read the pin state.</p>
<p>Next, we control the pins using <kbd>GPIO.ouput()</kbd> by stating the number of the GPIO pin and the state we want it to be in (<kbd>1</kbd> = high/on and <kbd>0</kbd> = low/off). We switch each LED on, wait five seconds, and then switch it back off.</p>
<p>Finally, we use <kbd>GPIO.cleanup()</kbd> to return the GPIO pins back to their original default state and release control of the pins for use by other programs.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Using the GPIO pins on the Raspberry Pi must be done with care since these pins are directly connected to the main processor of the Raspberry Pi without any additional protection. Caution must be used as any incorrect wiring will probably damage the Raspberry Pi processor and cause it to stop functioning altogether.</p>
<p>Alternatively, you could use one of the many modules available that plug directly into the GPIO header pins (reducing the chance of wiring mistakes):</p>
<p>For example, the Pi-Stop is a simple pre-built LED board that simulates a set of traffic lights, designed to be a stepping stone for those who are interested in controlling hardware but want to avoid the risk of damaging their Raspberry Pi. After the basics have been mastered, it also makes an excellent indicator to aid debugging.<br/>
<br/>
Just ensure that you update the <kbd>LED CONFIG</kbd> pin references in the <kbd>ledtest.py</kbd> script to reference the pin layout and location used for the hardware you are using.</p>
<div><img src="img/74c29f6d-4113-4a2d-b3f1-0efe6f4b73f9.png" style="width:23.08em;height:20.25em;" width="678" height="594"/></div>
<p>See the Appendix, <em>Hardware and Software List</em>, for a list of Raspberry Pi hardware retailers.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Controlling the GPIO current</h1>
                
            
            
                
<p>Each GPIO pin is only able to handle a certain current before it burns out (a maximum of 16 mA from a single pin or 30 mA in total), and similarly, the RGB LED should be limited to no more than 100 mA. By adding a resistor before or after an LED, we will be able to limit the current that will be passed through it and control how bright it is (more current will equal a brighter LED).</p>
<p>Since we may wish to power more than one LED at a time, we typically aim to set the current as low as we can get away with while still providing enough power to light up the LED.</p>
<p>We can use Ohm's law to tell us how much resistance to use to provide a particular current. The law is as shown in the following diagram:</p>
<div><img src="img/a3c149d7-3baf-422d-9168-f80691dd9d82.png" style="width:30.25em;height:8.92em;" width="925" height="273"/></div>
<p>Ohm's law: The relationship between the current, resistance, and voltage in electrical circuits</p>
<p>We will aim for a minimum current (3 mA) and maximum current (16 mA), while still producing a reasonably bright light from each of the LEDs. To get a balanced output for the RGB LEDs, I tested different resistors until they provided a near white light (when viewed through a card). A 470 ohm resistor was selected for each one (your LEDs may differ slightly):</p>
<div><img src="img/6ac65729-679f-4038-87ab-1b3c1043b09a.png" style="width:30.75em;height:25.00em;" width="565" height="459"/></div>
<p>Resistors are needed to limit the current that passes through the LEDs</p>
<p>The voltage across the resistor is equal to the GPIO voltage (<strong>Vgpio</strong> = 3.3V) minus the voltage drop on the particular LED (<strong>Vfwd</strong>); we can then use this resistance to calculate the current used by each of the LEDs, as shown in the following formulas:</p>
<div><img src="img/86a42336-dc5c-4e66-9a97-1a8116abf611.png" style="width:35.17em;height:9.33em;" width="974" height="258"/></div>
<p>We can calculate the current drawn by each of the LEDs</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Responding to a button</h1>
                
            
            
                
<p>Many applications using the Raspberry Pi require that actions are activated without requiring a keyboard and screen to be attached to it. The GPIO pins provide an excellent way for the Raspberry Pi to be controlled by your own buttons and switches without a mouse/keyboard and screen.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need the following equipment:</p>
<ul>
<li>2 x DuPont female-to-male patch wires</li>
<li>Mini breadboard (170 tie points) or a larger one</li>
<li>Push-button switch (momentary close) or a wire connection to make/break the circuit</li>
<li>Breadboard wire (solid core)</li>
<li>1K ohm resistor</li>
</ul>
<p>The switches are as shown in the following diagram:</p>
<div><img src="img/327bd9b0-47ff-4ca7-b466-fbf8ac361c4f.png" style="width:19.42em;height:10.50em;" width="1262" height="682"/></div>
<p>The push-button switch and other types of switch</p>
<p>The switches used in the following examples are <strong>single-pole, single-throw</strong> (<strong>SPST</strong>), momentary close, push-button switches. <strong>Single pole</strong> (<strong>SP</strong>) means that there is one set of contacts that makes a connection. In the case of the push switch used here, the legs on each side are connected together with a single-pole switch in the middle. A <strong>double-pole</strong> (<strong>DP</strong>) switch acts just like a SP switch, except that the two sides are separated electrically, allowing you to switch two separate components on/off at the same time.<br/>
<br/>
<strong>Single throw</strong> (<strong>ST</strong>) means the switch will make a connection with just one position; the other side will be left open. <strong>Double throw</strong> (<strong>DT</strong>) means both positions of the switch will connect to different parts.<br/>
<br/>
<strong>Momentary close</strong> means that the button will close the switch when pressed and automatically open it when released. A <strong>latched</strong> push-button switch will remain closed until it is pressed again.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Trying a speaker or headphone with Raspberry Pi</h1>
                
            
            
                
<div><img src="img/b945e963-5897-43c3-84f4-c75001fb73c6.png" style="width:22.42em;height:22.42em;" width="602" height="602"/></div>
<p>The layout of the button circuit</p>
<p>We will use sound in this example, so you will also need speakers or headphones attached to the audio socket of the Raspberry Pi.</p>
<p>You will need to install a program called <kbd>flite</kbd> using the following command, which will let us make the Raspberry Pi talk:</p>
<pre><strong>sudo apt-get install flite</strong>  </pre>
<p>After it has been installed, you can test it with the following command:</p>
<pre><strong>sudo flite -t "hello I can talk"</strong>  </pre>
<p>If it is a little too quiet (or too loud), you can adjust the volume (0-100 percent) using the following command:</p>
<pre><strong>amixer set PCM 100%</strong>  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create the <kbd>btntest.py</kbd> script as follows:</p>
<pre>#!/usr/bin/python3 
#btntest.py 
import time 
import os 
import RPi.GPIO as GPIO 
#HARDWARE SETUP 
# GPIO 
# 2[==X==1=======]26[=======]40 
# 1[=============]25[=======]39 
#Button Config 
BTN = 12 
 
def gpio_setup(): 
  #Setup the wiring 
  GPIO.setmode(GPIO.BOARD) 
  #Setup Ports 
  GPIO.setup(BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP) 
   
 
def main(): 
  gpio_setup() 
  count=0 
  btn_closed = True 
  while True: 
    btn_val = GPIO.input(BTN) 
    if btn_val and btn_closed: 
       print("OPEN") 
       btn_closed=False 
    elif btn_val==False and btn_closed==False: 
       count+=1 
       print("CLOSE %s" % count) 
       os.system("flite -t '%s'" % count) 
       btn_closed=True 
    time.sleep(0.1) 
 
 
try: 
  main() 
finally: 
  GPIO.cleanup() 
  print("Closed Everything. END") 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As in the previous recipe, we set up the GPIO pin as required, but this time as an input, and we also enable the internal pull-up resistor (see <em>Pull-up and pull-down resistor circuits</em> in the <em>There's more...</em> section of this recipe for more information) using the following code:</p>
<pre>GPIO.setup(BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP) </pre>
<p>After the GPIO pin is set up, we create a loop that will continuously check the state of <kbd>BTN</kbd> using <kbd>GPIO.input()</kbd>. If the value returned is <kbd>false</kbd>, the pin has been connected to 0V (ground) through the switch, and we will use <kbd>flite</kbd> to count out loud for us each time the button is pressed.</p>
<p>Since we have called the main function from within a <kbd>try</kbd>/<kbd>finally</kbd> condition, it will still call <kbd>GPIO.cleanup()</kbd> even if we close the program using <em>Ctrl</em> + <em>Z</em>.</p>
<p>We use a short delay in the loop; this ensures that any noise from the contacts on the switch is ignored. This is because when we press the button, there isn't always perfect contact as we press or release it, and it may produce several triggers if we press it again too quickly. This is known as <strong>software debouncing</strong>; we ignore the bounce in the signal here.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The Raspberry Pi GPIO pins must be used with care; voltages used for inputs should be<br/>
within specific ranges, and any current drawn from them should be minimized using<br/>
protective resistors.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Safe voltages</h1>
                
            
            
                
<p>We must ensure that we only connect inputs that are between 0 (ground) and 3V3. Some processors use voltages between 0V and 5V, so extra components are required to interface safely with them. Never connect an input or component that uses 5V unless you are certain it is safe, or you will damage the GPIO ports of the Raspberry Pi.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Pull-up and pull-down resistor circuits</h1>
                
            
            
                
<p>The previous code sets the GPIO pins to use an internal pull-up resistor. Without a pull-up resistor (or pull-down resistor) on the GPIO pin, the voltage is free to float somewhere between 3V3 and 0V, and the actual logical state remains undetermined (sometimes 1 and sometimes 0).</p>
<p>Raspberry Pi's internal pull-up resistors are 50K ohm-65K ohm, and the pull-down resistors are 50K ohm-65K ohm. External pull-up/pull-down resistors are often used in GPIO circuits (as shown in the following diagram), typically using 10K ohm or larger for similar reasons (giving a very small current draw when they are not active).</p>
<p>A pull-up resistor allows a small amount of current to flow through the GPIO pin and will provide a high voltage when the switch isn't pressed. When the switch is pressed, the small current is replaced by the larger one flowing to 0V, so we get a low voltage on the GPIO pin instead. The switch is active low and logic 0 when pressed. It works as shown in the following diagram:</p>
<div><img src="img/47dd205d-c592-49ae-b43b-c7edc60236e8.png" style="width:44.33em;height:19.25em;" width="684" height="297"/></div>
<p>A pull-up resistor circuit</p>
<p>Pull-down resistors work in the same way, except the switch is active high (the GPIO pin is logic 1 when pressed). It works as shown in the following diagram:</p>
<div><img src="img/bc223b08-57bc-41a4-ba6e-0f12573ca47c.png" style="width:44.50em;height:19.25em;" width="684" height="296"/></div>
<p>A pull-down resistor circuit</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Protection resistors</h1>
                
            
            
                
<p>In addition to the switch, the circuit includes a resistor in series with the switch to protect the GPIO pin, as shown in the following diagram:</p>
<div><img src="img/6e8ea49d-ab35-4ac6-bfc0-68b17642fcae.png" style="width:15.08em;height:4.83em;" width="376" height="121"/></div>
<p>A GPIO protective current-limiting resistor</p>
<p>The purpose of the protection resistor is to protect the GPIO pin if it is accidentally set as an output rather than an input. Imagine, for instance, that we have our switch connected between the GPIO and ground. Now the GPIO pin is set as an output and switched on (driving it to 3V3) as soon as we press the switch, without a resistor present, the GPIO pin will be directly connected to 0V. The GPIO will still try to drive it to 3V3; this will cause the GPIO pin to burn out (since it will use too much current to drive the pin to the high state). If we use a 1K ohm resistor here, the pin is able to be driven high using an acceptable amount of current (I = V/R = 3.3/1K = 3.3 mA).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">A controlled shutdown button</h1>
                
            
            
                
<p>The Raspberry Pi should always be shut down correctly to avoid the SD card being corrupted (by losing power while performing a write operation to the card). This can pose a problem if you don't have a keyboard or screen connected (you might be running an automated program or controlling it remotely over a network and forget to turn it off) as you can't type the command or see what you are doing. By adding our own buttons and LED indicator, we can easily command a shutdown and reset, and then start up again to indicate when the system is active.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need the following equipment:</p>
<ul>
<li>3 x DuPont female-to-male patch wires</li>
<li>Mini breadboard (170 tie points) or a larger one</li>
<li>Push-button switch (momentary close)</li>
<li>General-purpose LED</li>
<li>2 x 470 ohm resistors</li>
<li>Breadboard wire (solid core)</li>
</ul>
<p>The entire layout of the shutdown circuit will look as shown in the following figure:</p>
<div><img src="img/1940ff02-9a95-429b-a649-2eeeaa0497ae.png" style="width:22.25em;height:23.17em;" width="580" height="603"/></div>
<p>The controlled shutdown circuit layout</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create the <kbd>shtdwn.py</kbd> script as follows:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#shtdwn.py 
import time 
import RPi.GPIO as GPIO 
import os 
 
# Shutdown Script 
DEBUG=True #Simulate Only 
SNDON=True 
#HARDWARE SETUP 
# GPIO 
# 2[==X==L=======]26[=======]40 
# 1[===1=========]25[=======]39 
 
#BTN CONFIG - Set GPIO Ports 
GPIO_MODE=GPIO.BOARD 
SHTDWN_BTN = 7 #1 
LED = 12       #L 
 
def gpio_setup(): 
  #Setup the wiring 
  GPIO.setmode(GPIO_MODE) 
  #Setup Ports 
  GPIO.setup(SHTDWN_BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP) 
  GPIO.setup(LED,GPIO.OUT) 
 
def doShutdown(): 
  if(DEBUG):print("Press detected") 
  time.sleep(3) 
  if GPIO.input(SHTDWN_BTN): 
    if(DEBUG):print("Ignore the shutdown (&lt;3sec)") 
  else: 
    if(DEBUG):print ("Would shutdown the RPi Now") 
    GPIO.output(LED,0) 
    time.sleep(0.5) 
    GPIO.output(LED,1) 
    if(SNDON):os.system("flite -t 'Warning commencing power down 3 2 1'") 
    if(DEBUG==False):os.system("sudo shutdown -h now") 
    if(DEBUG):GPIO.cleanup() 
    if(DEBUG):exit() 
 
def main(): 
  gpio_setup() 
  GPIO.output(LED,1) 
  while True: 
    if(DEBUG):print("Waiting for &gt;3sec button press") 
    if GPIO.input(SHTDWN_BTN)==False: 
       doShutdown() 
    time.sleep(1) 
 
try: 
  main() 
finally: 
  GPIO.cleanup() 
  print("Closed Everything. END") 
#End</pre>
<ol start="2">
<li>To get this script to run automatically (once we have tested it), we can place the script in the <kbd>~/bin</kbd> (we can use <kbd>cp</kbd> instead of <kbd>mv</kbd> if we just want to copy it) and add it to <kbd>crontab</kbd> with the following code:</li>
</ol>
<pre style="padding-left: 60px">mkdir ~/bin 
mv shtdwn.py ~/bin/shtdwn.py  
crontab -e </pre>
<ol start="3">
<li>At the end of the file, we add the following code:</li>
</ol>
<pre style="padding-left: 60px">@reboot sudo python3 ~/bin/shtdwn.py </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This time, when we set up the GPIO pin, we define the pin connected to the shutdown button as an input and the pin connected to the LED as an output. We turn the LED on to indicate that the system is running.</p>
<p>By setting the <kbd>DEBUG</kbd> flag to <kbd>True</kbd>, we can test the functionality of our script without causing an actual shutdown (by reading the terminal messages); we just need to ensure that we set <kbd>DEBUG</kbd> to <kbd>False</kbd> when using the script for real.</p>
<p>We enter a <kbd>while</kbd> loop and check the pin every second to see whether the GPIO pin is set to <kbd>LOW</kbd> (that is, to check whether the switch has been pressed); if so, we enter the <kbd>doShutdown()</kbd> function.</p>
<p>The program will wait for three seconds and then test again to see whether the button is still being pressed. If the button is no longer being pressed, we return to the previous <kbd>while</kbd> loop. However, if it is still being pressed after three seconds, the program will flash the LED and trigger the shutdown (and also provide an audio warning using <kbd>flite</kbd>).</p>
<p>When we are happy with how the script is operating, we can disable the <kbd>DEBUG</kbd> flag (by setting it to <kbd>False</kbd>) and add the script to <kbd>crontab</kbd>. <kbd>crontab</kbd> is a special program that runs in the background and allows us to schedule (at specific times, dates, or periodically) programs and actions when the system is started (<kbd>@reboot</kbd>). This allows the script to be started automatically every time the Raspberry Pi is powered up. When we press and hold the shutdown button for more than three seconds, it safely shuts down the system and enters a low power state (the LED switches off just before this, indicating that it is safe to remove the power shortly after). To restart the Raspberry Pi, we briefly remove the power; this will restart the system, and the LED will light up when the Raspberry Pi has loaded.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We can extend this example further using the reset header by adding extra functionality and making use of additional GPIO connections (if available).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Resetting and rebooting Raspberry Pi</h1>
                
            
            
                
<p>The Raspberry Pi has holes for mounting a reset header (marked <strong>RUN</strong> on the Raspberry Pi 3/2 and <strong>P6</strong> on the Raspberry Pi 1 Model A and Model B Rev 2). The reset pin allows the device to be reset using a button rather than removing the micro USB connector each<br/>
time to cycle the power:</p>
<div><img src="img/458dc851-ae96-414c-bb35-ea425a7fbd96.png" style="width:38.08em;height:26.67em;" width="786" height="551"/></div>
<p>Raspberry Pi reset headers - on the left, Raspberry Pi Model A/B (Rev2), and on the right, Raspberry Pi 3</p>
<p>To make use of it, you will need to solder a wire or pin header to the Raspberry Pi and connect a button to it (or briefly touch a wire between the two holes each time). Alternatively, we can extend our previous circuit, as shown in the following diagram:</p>
<div><img src="img/6715c947-d675-486c-b7c1-ff809307cbe9.png" style="width:34.17em;height:32.08em;" width="642" height="604"/></div>
<p>The controlled shutdown circuit layout and reset button</p>
<p>We can add this extra button to our circuit, which can be connected to the reset header (this is the hole nearest the middle on the Raspberry Pi 3 or closest to the edge on other models). This pin, when temporarily pulled low by connecting to ground (such as the hole next to it or by another ground point, such as pin 6 of the GPIO header), will reset the Raspberry Pi and allow it to boot up again following a shutdown.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding extra functions</h1>
                
            
            
                
<p>Since we now have the script monitoring the shutdown button all the time, we can add extra buttons/switches/jumpers to be monitored at the same time. This will allow us to trigger specific programs or set up particular states just by changing the inputs. The following example allows us to easily switch between automatic DHCP networking (the default networking setup) and using a direct IP address, as used in the <em>Networking directly to a laptop or computer</em> recipe of <a href="b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started with a Raspberry Pi 3 Computer</em>, for direct LAN connections.</p>
<p>Add the following components to the previous circuit:</p>
<ul>
<li>A 470 ohm resistor</li>
<li>Two pin headers with a jumper connector (or, optionally, a switch)</li>
<li>Breadboard wire (solid core)</li>
</ul>
<p>After adding the preceding components, our controlled shutdown circuit now looks as follows:</p>
<div><img src="img/66c0e8be-1385-478a-be3c-d584f60cef5f.png" style="width:27.00em;height:25.00em;" width="647" height="598"/></div>
<p>The controlled shutdown circuit layout, reset button, and jumper pins</p>
<p>In the previous script, we add an additional input to detect the status of the <kbd>LAN_SWA</kbd> pin (the jumper pins we added to the circuit) using the following code:</p>
<pre>LAN_SWA = 11    #2 </pre>
<p>Ensure that it is set up as an input (with a pull-up resistor) in the <kbd>gpio_setup()</kbd> function using the following code:</p>
<pre>GPIO.setup(LAN_SWA,GPIO.IN,pull_up_down=GPIO.PUD_UP) </pre>
<p>Add a new function to switch between the LAN modes and read out the new IP address. The <kbd>doChangeLAN()</kbd> function checks whether the status of the <kbd>LAN_SWA</kbd> pin has changed since the last call, and if so, it sets the network adapter to DHCP or sets the direct LAN settings accordingly (and uses <kbd>flite</kbd> to speak the new IP setting, if available). Finally, the LAN being set for direct connection causes the LED to flash slowly while that mode is active. Use the following code to do this:</p>
<pre>def doChangeLAN(direct): 
  if(DEBUG):print("Direct LAN: %s" % direct) 
  if GPIO.input(LAN_SWA) and direct==True: 
    if(DEBUG):print("LAN Switch OFF") 
    cmd="sudo dhclient eth0" 
    direct=False 
    GPIO.output(LED,1) 
  elif GPIO.input(LAN_SWA)==False and direct==False: 
    if(DEBUG):print("LAN Switch ON") 
    cmd="sudo ifconfig eth0 169.254.69.69" 
    direct=True 
  else: 
    return direct 
  if(DEBUG==False):os.system(cmd) 
  if(SNDON):os.system("hostname -I | flite") 
  return direct </pre>
<p>Add another function, <kbd>flashled()</kbd>, which will just toggle the state of the LED each time it is called. The code for this function is as follows:</p>
<pre>def flashled(ledon): 
  if ledon: 
    ledon=False 
  else: 
    ledon=True 
  GPIO.output(LED,ledon) 
  return ledon</pre>
<p>Finally, we adjust the main loop to also call <kbd>doChangeLAN()</kbd> and use the result to decide whether we call <kbd>flashled()</kbd> using <kbd>ledon</kbd> to keep track of the LED's previous state each time. The <kbd>main()</kbd> function should now be updated as follows:</p>
<pre>def main(): 
  gpio_setup() 
  GPIO.output(LED,1) 
  directlan=False 
  ledon=True 
  while True: 
    if(DEBUG):print("Waiting for &gt;3sec button press") 
    if GPIO.input(SHTDWN_BTN)==False: 
       doShutdown() 
    directlan= doChangeLAN(directlan) 
    if directlan: 
      flashled(ledon) 
    time.sleep(1) </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">The GPIO keypad input</h1>
                
            
            
                
<p>We have seen how we can monitor inputs on the GPIO to launch applications and control the Raspberry Pi; however, sometimes we need to control third-party programs. Using the <kbd>uInput</kbd> library, we can emulate key presses from a keyboard (or even mouse movement) to control any program using our own custom hardware.</p>
<p>For more information about using <kbd>uInput</kbd>, visit <a href="http://tjjr.fi/sw/python-uinput/" target="_blank">http://tjjr.fi/sw/python-uinput/</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Perform the following steps to install <kbd>uInput</kbd>:</p>
<ol>
<li>First, we need to download <kbd>uInput</kbd>.</li>
</ol>
<p style="padding-left: 60px">You will need to download the <kbd>uInput</kbd> Python library from GitHub (~50 KB) using the following commands:</p>
<pre style="padding-left: 60px"><strong>wget https://github.com/tuomasjjrasanen/python-uinput/archive/master.zip</strong>
<strong>unzip master.zip</strong>
  </pre>
<p style="padding-left: 60px">The library will unzip to a directory called <kbd>python-uinput-master</kbd>.</p>
<ol start="2">
<li>Once completed, you can remove the ZIP file using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>rm master.zip</strong>  </pre>
<ol start="3">
<li>Install the required packages using the following commands (if you have installed them already, the <kbd>apt-get</kbd> command will ignore them):</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo apt-get install python3-setuptools python3-dev</strong>
<strong>sudo apt-get install libudev-dev</strong>  </pre>
<ol start="4">
<li>Compile and install <kbd>uInput</kbd> using the following commands:</li>
</ol>
<pre style="padding-left: 60px"><strong>cd python-uinput-master</strong>
<strong>sudo python3 setup.py install</strong>  </pre>
<ol start="5">
<li>Finally, we load the new <kbd>uinput</kbd> kernel module using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo modprobe uinput</strong>  </pre>
<p style="padding-left: 60px">To ensure it is loaded upon startup, we can add <kbd>uinput</kbd> to the <kbd>modules</kbd> file using the following command:</p>
<pre style="padding-left: 60px"><strong>sudo nano /etc/modules</strong>  </pre>
<p style="padding-left: 60px">Put <kbd>uinput</kbd> on a new line in the file and save it (<em>Ctrl</em> + <em>X</em>, <em>Y</em>).</p>
<ol start="6">
<li>Create the following circuit using the following equipment:
<ul>
<li>Breadboard (half-sized or larger)</li>
<li>7 x DuPont female-to-male patch wires</li>
<li>Six push buttons</li>
<li>6 x 470 ohm resistors</li>
<li>Breadboarding wire (solid core)</li>
</ul>
</li>
</ol>
<div><img src="img/3d2b7fcf-7078-441c-8d25-a2ece8737c81.png" style="width:43.00em;height:19.08em;" width="1332" height="591"/></div>
<p>GPIO keypad circuit layout</p>
<p style="padding-left: 60px">The keypad circuit can also be built into a permanent circuit by soldering the components into a Vero prototype board (also known as a stripboard), as shown in the following photo:</p>
<div><img src="img/5f5f6c94-8411-4fad-b732-34157090a0a5.png" style="width:30.17em;height:18.17em;" width="1019" height="612"/></div>
<p>GPIO keypad Pi hardware module</p>
<p>This circuit is available as a solder-yourself kit from <a href="http://pihardware.com/" target="_blank">PiHardware.com</a>.</p>
<ol start="7">
<li>Connect the circuit to the Raspberry Pi GPIO pins by matching the appropriate buttons with the appropriate pins, as shown in the following table:</li>
</ol>
<table class="table">
<tbody>
<tr>
<td/>
<td>
<p><strong>Button</strong></p>
</td>
<td>
<p><strong>GPIO pin</strong></p>
</td>
</tr>
<tr>
<td>
<p>GND</p>
</td>
<td/>
<td>
<p>6</p>
</td>
</tr>
<tr>
<td>
<p>v</p>
</td>
<td>
<p>B_DOWN</p>
</td>
<td>
<p>22</p>
</td>
</tr>
<tr>
<td>
<p>&lt;</p>
</td>
<td>
<p>B_LEFT</p>
</td>
<td>
<p>18</p>
</td>
</tr>
<tr>
<td>
<p>^</p>
</td>
<td>
<p>B_UP</p>
</td>
<td>
<p>15</p>
</td>
</tr>
<tr>
<td>
<p>&gt;</p>
</td>
<td>
<p>B_RIGHT</p>
</td>
<td>
<p>13</p>
</td>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>B_1</p>
</td>
<td>
<p>11</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>B_2</p>
</td>
<td>
<p>7</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create a <kbd>gpiokeys.py</kbd> script as follows:</p>
<pre>#!/usr/bin/python3 
#gpiokeys.py 
import time 
import RPi.GPIO as GPIO 
import uinput 
 
#HARDWARE SETUP 
# GPIO 
# 2[==G=====&lt;=V==]26[=======]40 
# 1[===2=1&gt;^=====]25[=======]39 
B_DOWN  = 22    #V 
B_LEFT  = 18   #&lt; 
B_UP    = 15   #^ 
B_RIGHT = 13   #&gt; 
B_1  = 11   #1 
B_2  = 7   #2 
 
DEBUG=True 
BTN = [B_UP,B_DOWN,B_LEFT,B_RIGHT,B_1,B_2] 
MSG = ["UP","DOWN","LEFT","RIGHT","1","2"] 
 
#Setup the DPad module pins and pull-ups 
def dpad_setup(): 
  #Set up the wiring 
  GPIO.setmode(GPIO.BOARD) 
  # Setup BTN Ports as INPUTS 
  for val in BTN: 
    # set up GPIO input with pull-up control 
    #(pull_up_down can be: 
    #    PUD_OFF, PUD_UP or PUD_DOWN, default PUD_OFF) 
    GPIO.setup(val, GPIO.IN, pull_up_down=GPIO.PUD_UP) 
 
def main(): 
  #Setup uinput 
  events = (uinput.KEY_UP,uinput.KEY_DOWN,uinput.KEY_LEFT, 
           uinput.KEY_RIGHT,uinput.KEY_ENTER,uinput.KEY_ENTER) 
  device = uinput.Device(events) 
  time.sleep(2) # seconds 
  dpad_setup() 
  print("DPad Ready!") 
 
  btn_state=[False,False,False,False,False,False] 
  key_state=[False,False,False,False,False,False] 
  while True: 
    #Catch all the buttons pressed before pressing the related keys 
    for idx, val in enumerate(BTN): 
      if GPIO.input(val) == False: 
        btn_state[idx]=True 
      else: 
        btn_state[idx]=False 
 
    #Perform the button presses/releases (but only change state once) 
    for idx, val in enumerate(btn_state): 
      if val == True and key_state[idx] == False: 
        if DEBUG:print (str(val) + ":" + MSG[idx]) 
        device.emit(events[idx], 1) # Press. 
        key_state[idx]=True 
      elif val == False and key_state[idx] == True: 
        if DEBUG:print (str(val) + ":!" + MSG[idx]) 
        device.emit(events[idx], 0) # Release. 
        key_state[idx]=False 
 
    time.sleep(.1) 
     
try: 
  main() 
finally: 
  GPIO.cleanup() 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First, we import <kbd>uinput</kbd> and define the wiring of the keypad buttons. For each of the buttons in <kbd>BTN</kbd>, we enable them as inputs, with internal pull-ups enabled.</p>
<p>Next, we set up <kbd>uinput</kbd>, defining the keys we want to emulate and adding them to the <kbd>uinput.Device()</kbd> function. We wait a few seconds to allow <kbd>uinput</kbd> to initialize, set the initial button and key states, and start our <kbd>main</kbd> loop.</p>
<p>The <kbd>main</kbd> loop is split into two sections: the first section checks through the buttons and records the states in <kbd>btn_state</kbd>, and the second section compares the <kbd>btn_state</kbd> with the current <kbd>key_state</kbd> array. This way, we can detect a change in <kbd>btn_state</kbd> and call <kbd>device.emit()</kbd> to toggle the state of the key.</p>
<p>To allow us to run this script in the background, we can run it with <kbd>&amp;</kbd>, as shown in the<br/>
following command:</p>
<pre><strong>sudo python3 gpiokeys.py &amp;</strong>  </pre>
<p>The <kbd>&amp;</kbd> character allows the command to run in the background, so we can continue with the command line to run other programs. You can use <kbd>fg</kbd> to bring it back to the foreground, or <kbd>%1</kbd>, <kbd>%2</kbd>, and so on if you have several commands running. Use <kbd>jobs</kbd> to get a list.<br/>
<br/>
You can even put a process/program on hold to get to Command Prompt by pressing <em>Ctrl</em> + <em>Z</em> and then resume it with <kbd>bg</kbd> (which will let it run in the background).<br/>
<br/>
You can test the keys using the game created in the <em>Creating an overhead scrolling game</em> recipe in <a href="d795b1aa-9d5e-4ad6-8352-600d547f0af3.xhtml" target="_blank">Chapter 5</a>, <em>Creating Games and Graphics</em>, which you can now control using your GPIO directional pad. Don't forget that if you are connecting to the Raspberry Pi remotely, any key presses will only be active on the locally connected screen.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We can do more using <kbd>uinput</kbd> to provide hardware control for other programs, including those that require mouse input.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Generating other key combinations</h1>
                
            
            
                
<p>You can create several different key mappings in your file to support different programs. For instance, the <kbd>events_z80</kbd> key mapping would be useful for a spectrum emulator, such as <strong>Fuse</strong> (browse to <a href="http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi">http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi</a> for more details). The <kbd>events_omx</kbd> key mappings are suitable for controlling video played through the OMXPlayer using the following command:</p>
<pre><strong>omxplayer filename.mp4</strong>  </pre>
<p>You can get a list of keys supported by <kbd>omxplayer</kbd> by using the <kbd>-k</kbd> parameter.</p>
<p>Replace the line that defines the <kbd>events</kbd> list with a new key mapping, and select different ones by assigning them to events using the following code:</p>
<pre>events_dpad = (uinput.KEY_UP,uinput.KEY_DOWN,uinput.KEY_LEFT, 
              uinput.KEY_RIGHT,uinput.KEY_ENTER,uinput.KEY_ENTER) 
events_z80 = (uinput.KEY_Q,uinput.KEY_A,uinput.KEY_O, 
             uinput.KEY_P,uinput.KEY_M,uinput.KEY_ENTER) 
events_omx = (uinput.KEY_EQUAL,uinput.KEY_MINUS,uinput.KEY_LEFT, 
             uinput.KEY_RIGHT,uinput.KEY_P,uinput.KEY_Q) </pre>
<p>You can find all the <kbd>KEY</kbd> definitions in the <kbd>input.h</kbd> file; you can view it using the <kbd>less</kbd> command (press <em>Q</em> to exit), as shown in the following command:</p>
<pre><strong>less /usr/include/linux/input.h</strong>  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Emulating mouse events</h1>
                
            
            
                
<p>The <kbd>uinput</kbd> library can emulate mouse and joystick events, as well as keyboard presses. To use the buttons to simulate a mouse, we can adjust the script to use mouse events (as well as defining <kbd>mousemove</kbd> to set the step size of the movement) using the following code:</p>
<pre>MSG = ["M_UP","M_DOWN","M_LEFT","M_RIGHT","1","Enter"] 
events_mouse=(uinput.REL_Y,uinput.REL_Y, uinput.REL_X, 
             uinput.REL_X,uinput.BTN_LEFT,uinput.BTN_RIGHT) 
mousemove=1 </pre>
<p>We also need to modify the button handling to provide continuous movement, as we don't need to keep track of the state of the keys for the mouse. To do so, use the following code:</p>
<pre>#Perform the button presses/releases 
#(but only change state once) 
for idx, val in enumerate(btn_state): 
  if MSG[idx] == "M_UP" or MSG[idx] == "M_LEFT": 
    state = -mousemove 
  else: 
    state = mousemove 
  if val == True: 
    device.emit(events[idx], state) # Press. 
  elif val == False: 
    device.emit(events[idx], 0) # Release. 
time.sleep(0.01) </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Multiplexed color LEDs</h1>
                
            
            
                
<p>The next example in this chapter demonstrates that some seemingly simple hardware can produce some impressive results if controlled with software. For this, we will go back to using RGB LEDs. We will use five RGB LEDs that are wired so that we only need to use eight GPIO pins to control their red, green, and blue elements using a method called <strong>hardware multiplexing</strong> (see the <em>Hardware multiplexing</em> subsection in the <em>There's more...</em> section of this recipe).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You will need the RGB LED module shown in the following picture:</p>
<div><img src="img/83669445-a359-4f4f-9842-78585d70168e.png" style="width:30.08em;height:18.08em;" width="1079" height="647"/></div>
<p>The RGB LED module from PiHardware.com</p>
<p>As you can see in the preceding photo, the RGB LED module from <a href="http://pihardware.com/" target="_blank">http://pihardware.com/</a> comes with GPIO pins and a DuPont female-to-female cable for connecting it. Although there are two sets of pins labelled from 1 to 5, only one side needs to be connected.</p>
<p>Alternatively, you can recreate your own with the following circuit using five common cathode RGB LEDs, 3 x 470 ohm resistors, and a Vero prototype board (or large breadboard). The circuit will look as shown in the following diagram:</p>
<div><img src="img/34cf8120-46bf-4b71-9ed0-9b0aea34f126.png" width="1999" height="852"/></div>
<p>Circuit diagram for the RGB LED module</p>
<p>Strictly speaking, we should use 15 resistors in this circuit (one for each RGB LED element), which will avoid interference from LEDs sharing the same resistor, and will also prolong the life of the LEDs themselves if switched on together. However, there is only a slight advantage in using this, particularly since we intend to drive each RGB LED independently of the other four to achieve multi-color effects.</p>
<p>You will need to connect the circuit to the Raspberry Pi GPIO header as follows:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>RGB LED</strong></p>
</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td>
<p>1</p>
</td>
<td/>
<td>
<p>2</p>
</td>
<td>
<p>3</p>
</td>
<td/>
<td>
<p>4</p>
</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>
<p><strong>Rpi GPIO pin</strong></p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>10</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>14</p>
</td>
<td>
<p>16</p>
</td>
<td>
<p>18</p>
</td>
<td>
<p>20</p>
</td>
<td>
<p>22</p>
</td>
<td>
<p>24</p>
</td>
<td>
<p>26</p>
</td>
<td>
<p>28</p>
</td>
<td>
<p>30</p>
</td>
<td>
<p>32</p>
</td>
<td>
<p>34</p>
</td>
<td>
<p>36</p>
</td>
<td>
<p>38</p>
</td>
<td>
<p>40</p>
</td>
</tr>
<tr>
<td>
<p><strong>Rpi GPIO pin</strong></p>
</td>
<td>
<p>1</p>
</td>
<td>
<p>3</p>
</td>
<td>
<p>5</p>
</td>
<td>
<p>7</p>
</td>
<td>
<p>9</p>
</td>
<td>
<p>11</p>
</td>
<td>
<p>13</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>17</p>
</td>
<td>
<p>19</p>
</td>
<td>
<p>21</p>
</td>
<td>
<p>23</p>
</td>
<td>
<p>25</p>
</td>
<td>
<p>27</p>
</td>
<td>
<p>29</p>
</td>
<td>
<p>31</p>
</td>
<td>
<p>33</p>
</td>
<td>
<p>35</p>
</td>
<td>
<p>37</p>
</td>
<td>
<p>39</p>
</td>
</tr>
<tr>
<td>
<p><strong>RGB LED</strong></p>
</td>
<td/>
<td/>
<td/>
<td>
<p>5</p>
</td>
<td/>
<td>
<p>R</p>
</td>
<td>
<p>G</p>
</td>
<td>
<p>B</p>
</td>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create the <kbd>rgbled.py</kbd> script and perform the following steps:</p>
<ol>
<li>Import all the required modules and define the values to be used with the help of the following code:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#rgbled.py 
import time 
import RPi.GPIO as GPIO 
 
#Setup Active states 
#Common Cathode RGB-LEDs (Cathode=Active Low) 
LED_ENABLE = 0; LED_DISABLE = 1 
RGB_ENABLE = 1; RGB_DISABLE = 0 
#HARDWARE SETUP 
# GPIO 
# 2[=====1=23=4==]26[=======]40 
# 1[===5=RGB=====]25[=======]39 
#LED CONFIG - Set GPIO Ports 
LED1 = 12; LED2 = 16; LED3 = 18; LED4 = 22; LED5 = 7 
LED = [LED1,LED2,LED3,LED4,LED5] 
RGB_RED = 11; RGB_GREEN = 13; RGB_BLUE = 15 
RGB = [RGB_RED,RGB_GREEN,RGB_BLUE] 
#Mixed Colors 
RGB_CYAN = [RGB_GREEN,RGB_BLUE] 
RGB_MAGENTA = [RGB_RED,RGB_BLUE] 
RGB_YELLOW = [RGB_RED,RGB_GREEN] 
RGB_WHITE = [RGB_RED,RGB_GREEN,RGB_BLUE] 
RGB_LIST = [RGB_RED,RGB_GREEN,RGB_BLUE,RGB_CYAN, 
            RGB_MAGENTA,RGB_YELLOW,RGB_WHITE] </pre>
<ol start="2">
<li>Define functions to set up the GPIO pins using the following code:</li>
</ol>
<pre style="padding-left: 60px">def led_setup(): 
  '''Setup the RGB-LED module pins and state.''' 
  #Set up the wiring 
  GPIO.setmode(GPIO.BOARD) 
  # Setup Ports 
  for val in LED: 
    GPIO.setup(val, GPIO.OUT) 
  for val in RGB: 
    GPIO.setup(val, GPIO.OUT) 
  led_clear()</pre>
<ol start="3">
<li>Define our utility functions to help control the LEDs using the following code:</li>
</ol>
<pre style="padding-left: 60px">def led_gpiocontrol(pins,state): 
  '''This function will control the state of 
  a single or multiple pins in a list.''' 
  #determine if "pins" is a single integer or not 
  if isinstance(pins,int): 
    #Single integer - reference directly 
    GPIO.output(pins,state) 
  else: 
    #if not, then cycle through the "pins" list 
    for i in pins: 
      GPIO.output(i,state) 
 
def led_activate(led,color): 
  '''Enable the selected led(s) and set the required color(s) 
  Will accept single or multiple values''' 
  #Enable led 
  led_gpiocontrol(led,LED_ENABLE) 
  #Enable color 
  led_gpiocontrol(color,RGB_ENABLE) 
 
def led_deactivate(led,color): 
  '''Deactivate the selected led(s) and set the required 
  color(s) will accept single or multiple values''' 
  #Disable led 
  led_gpiocontrol(led,LED_DISABLE) 
  #Disable color 
  led_gpiocontrol(color,RGB_DISABLE) 
   
def led_time(led, color, timeon): 
  '''Switch on the led and color for the timeon period''' 
  led_activate(led,color) 
  time.sleep(timeon) 
  led_deactivate(led,color) 
 
def led_clear(): 
  '''Set the pins to default state.''' 
  for val in LED: 
    GPIO.output(val, LED_DISABLE) 
  for val in RGB: 
    GPIO.output(val, RGB_DISABLE) 
 
def led_cleanup(): 
  '''Reset pins to default state and release GPIO''' 
  led_clear() 
  GPIO.cleanup()</pre>
<ol start="4">
<li>Create a test function to demonstrate the functionality of the module:</li>
</ol>
<pre style="padding-left: 60px">def main(): 
  '''Directly run test function. 
  This function will run if the file is executed directly''' 
  led_setup() 
  led_time(LED1,RGB_RED,5) 
  led_time(LED2,RGB_GREEN,5) 
  led_time(LED3,RGB_BLUE,5) 
  led_time(LED,RGB_MAGENTA,2) 
  led_time(LED,RGB_YELLOW,2) 
  led_time(LED,RGB_CYAN,2)  
 
if __name__=='__main__': 
  try: 
    main() 
  finally: 
    led_cleanup() 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>To start with, we define the hardware setup by defining the states required to <strong>Enable</strong> and <strong>Disable</strong> the LED depending on the type of RGB LED (common cathode) used. If you are using a common anode device, just reverse the <strong>Enable</strong> and <strong>Disable</strong> states.</p>
<p>Next, we define the GPIO mapping to the pins to match the wiring we did previously.</p>
<p>We also define some basic color combinations by combining red, green, and/or blue together, as shown in the following diagram:</p>
<div><img src="img/06b6baa0-aba5-4a4a-a559-54261a81f562.png" width="837" height="110"/></div>
<p>LED color combinations</p>
<p>We define a series of useful functions, the first being <kbd>led_setup()</kbd>, which will set the GPIO numbering to <kbd>GPIO.BOARD</kbd> and define all the pins that are to be used as outputs. We also call a function named <kbd>led_clear()</kbd>, which will set the pins to the default state with all the pins disabled.</p>
<p>This means that the LED pins, 1-5 (the common cathode on each LED), are set to <kbd>HIGH</kbd>, while the RGB pins (the separate anodes for each color) are set to <kbd>LOW</kbd>.</p>
<p>We create a function called <kbd>led_gpiocontrol()</kbd> that will allow us to set the state of one or more pins. The <kbd>isinstance()</kbd> function allows us to test a value to see whether it matches a particular type (in this case, a single integer); then we can either set the state of that single pin or iterate through the list of pins and set each one.</p>
<p>Next, we define two functions, <kbd>led_activate()</kbd> and <kbd>led_deactivate()</kbd>, which will enable and disable the specified LED and color. Finally, we define <kbd>led_time()</kbd>, which will allow us to specify an LED, color, and time to switch it on for.</p>
<p>We also create <kbd>led_cleanup()</kbd> to reset the pins (and LEDs) to the default values and call <kbd>GPIO.cleanup()</kbd> to release the GPIO pins in use.</p>
<p>This script is intended to become a library file, so we will use the <kbd>if __name__=='__main__'</kbd> check to only run our test code when running the file directly:</p>
<p>By checking the value of <kbd>__name__</kbd>, we can determine whether the file was run directly (it will equal <kbd>__main__</kbd>) or whether it was imported by another Python script.<br/>
<br/>
This allows us to define a special test code that is only executed when we directly load and run the file. If we include this file as a module in another script, then this code will not be executed.<br/>
<br/>
As before, we will use <kbd>try</kbd>/<kbd>finally</kbd> to allow us to always perform cleanup actions, even if we exit early.</p>
<p>To test the script, we will set the LEDs to light up in various colors, one after another.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We can create a few different colors by switching on one or more parts of the RGB LED at a time. However, with some clever programming, we can create a whole spectrum of colors. Also, we can display different colors on each LED, seemingly at the same time.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Hardware multiplexing</h1>
                
            
            
                
<p>An LED requires a high voltage on the anode side and a lower voltage on the cathode side in order to light up. The RGB LEDs used in the circuit are common cathodes, so we must apply a high voltage (3V3) on the RGB pins and a low voltage (0V) on the cathode pin (wired to pins 1 to 5 for each of the LEDs).</p>
<p>The cathode and RGB pin states are as follows:</p>
<div><img src="img/1f96fef2-54f1-4b85-8393-ec53785dbfd7.png" style="width:31.67em;height:11.00em;" width="1215" height="422"/></div>
<p>Cathode and RGB pin states</p>
<p>Therefore, we can enable one or more of the RGB pins, but still control which of the LEDs are lit. We enable the pins of the LEDs we want to light up and disable the ones we don't. This allows us to use far fewer pins than we would need to control each of the 15 RGB lines separately.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Displaying random patterns</h1>
                
            
            
                
<p>We can add new functions to our library to produce different effects, such as generating random colors. The following function uses <kbd>randint()</kbd> to get a value between 1 and the number of colors. We ignore any values that are over the number of the available colors so that we can control how often the LEDs are switched off. Perform the following steps to add the required functions:</p>
<ol>
<li>Add the <kbd>randint()</kbd> function from the <kbd>random</kbd> module to the <kbd>rgbled.py</kbd> script using the following code:</li>
</ol>
<pre style="padding-left: 60px">from random import randint</pre>
<ol start="2">
<li>Now add <kbd>led_rgbrandom()</kbd> using the following code:</li>
</ol>
<pre style="padding-left: 60px">def led_rgbrandom(led,period,colors): 
   ''' Light up the selected led, for period in seconds, 
   in one of the possible colors. The colors can be 
   1 to 3 for RGB, or 1-6 for RGB plus combinations, 
   1-7 includes white. Anything over 7 will be set as 
   OFF (larger the number more chance of OFF).'''  
  value = randint(1,colors) 
  if value &lt; len(RGB_LIST): 
    led_time(led,RGB_LIST[value-1],period) </pre>
<ol start="3">
<li>Use the following commands in the <kbd>main()</kbd> function to create a series of<br/>
flashing LEDs:</li>
</ol>
<pre style="padding-left: 60px">for i in range(20): 
  for j in LED: 
    #Select from all, plus OFF 
    led_rgbrandom(j,0.1,20) </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Mixing multiple colors</h1>
                
            
            
                
<p>Until now, we have only displayed a single color at a time on one or more of the LEDs. If you consider how the circuit is wired up, you might wonder how we can get one LED to display one color and another a different one at the same time. The simple answer is that we don't need to-we just do it quickly!</p>
<p>All we need to do is display one color at a time, but change it back and forth, so quickly that the color looks like a mix of the two (or even a combination of the three red/green/blue LEDs). Fortunately, this is something that computers such as the Raspberry Pi can do very easily, even allowing us to combine the RGB elements to make multiple shades of colors across all five LEDs. Perform the following steps to mix the colors:</p>
<ol>
<li>Add combo color definitions to the top of the <kbd>rgbled.py</kbd> script, after the definition of the mixed colors, using the following code:</li>
</ol>
<pre style="padding-left: 60px">#Combo Colors 
RGB_AQUA = [RGB_CYAN,RGB_GREEN] 
RGB_LBLUE = [RGB_CYAN,RGB_BLUE] 
RGB_PINK = [RGB_MAGENTA,RGB_RED] 
RGB_PURPLE = [RGB_MAGENTA,RGB_BLUE] 
RGB_ORANGE = [RGB_YELLOW,RGB_RED] 
RGB_LIME = [RGB_YELLOW,RGB_GREEN] 
RGB_COLORS = [RGB_LIME,RGB_YELLOW,RGB_ORANGE,RGB_RED, 
              RGB_PINK,RGB_MAGENTA,RGB_PURPLE,RGB_BLUE, 
              RGB_LBLUE,RGB_CYAN,RGB_AQUA,RGB_GREEN] </pre>
<p style="padding-left: 60px">The preceding code will provide the combination of colors needed to create our shades, with <kbd>RGB_COLORS</kbd> providing a smooth progression through the shades.</p>
<ol start="2">
<li>Next, we need to create a function called <kbd>led_combo()</kbd> to handle single or multiple colors. The code for the function will be as follows:</li>
</ol>
<pre style="padding-left: 60px">def led_combo(pins,colors,period): 
  #determine if "colors" is a single integer or not 
  if isinstance(colors,int): 
    #Single integer - reference directly 
    led_time(pins,colors,period) 
  else: 
    #if not, then cycle through the "colors" list 
    for i in colors: 
      led_time(pins,i,period) </pre>
<ol start="3">
<li>Now we can create a new script, <kbd>rgbledrainbow.py</kbd>, to make use of the new functions in our <kbd>rgbled.py</kbd> module. The <kbd>rgbledrainbow.py</kbd> script will be as follows:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#rgbledrainbow.py 
import time 
import rgbled as RGBLED 
 
def next_value(number,max): 
  number = number % max 
  return number 
 
def main(): 
  print ("Setup the RGB module") 
  RGBLED.led_setup() 
 
  # Multiple LEDs with different Colors 
  print ("Switch on Rainbow") 
  led_num = 0 
  col_num = 0 
  for l in range(5): 
    print ("Cycle LEDs") 
    for k in range(100): 
      #Set the starting point for the next set of colors 
      col_num = next_value(col_num+1,len(RGBLED.RGB_COLORS)) 
      for i in range(20):  #cycle time 
        for j in range(5): #led cycle 
          led_num = next_value(j,len(RGBLED.LED)) 
          led_color = next_value(col_num+led_num, 
                                 len(RGBLED.RGB_COLORS)) 
          RGBLED.led_combo(RGBLED.LED[led_num], 
                           RGBLED.RGB_COLORS[led_color],0.001) 
 
    print ("Cycle COLORs")         
    for k in range(100): 
      #Set the next color 
      col_num = next_value(col_num+1,len(RGBLED.RGB_COLORS)) 
      for i in range(20): #cycle time 
        for j in range(5): #led cycle 
          led_num = next_value(j,len(RGBLED.LED)) 
          RGBLED.led_combo(RGBLED.LED[led_num], 
                           RGBLED.RGB_COLORS[col_num],0.001) 
  print ("Finished") 
 
if __name__=='__main__': 
  try: 
    main() 
  finally: 
    RGBLED.led_cleanup() 
#End </pre>
<p style="padding-left: 60px">The <kbd>main()</kbd> function will first cycle through the LEDs, setting each color from the <kbd>RGB_COLORS</kbd> array on all the LEDs. Then, it will cycle through the colors, creating a rainbow effect across the LEDs:</p>
<div><img src="img/8db3e951-4809-41ac-931a-18f13f837a74.png" style="width:32.83em;height:10.75em;" width="1782" height="582"/></div>
<p>Cycling through multiple colors on the five RGB LEDs</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Writing messages using persistence of vision</h1>
                
            
            
                
<p><strong>Persistence of vision</strong> (<strong>POV</strong>) displays can produce an almost magical effect, displaying images in the air by moving a line of LEDs back and forth very quickly or around in circles. The effect works because your eyes are unable to adjust fast enough to separate out the individual flashes of light, and so you observe a merged image (the message or picture being displayed):</p>
<div><img src="img/d1a235b8-74b1-4711-8e61-b136becc1ec8.png" style="width:40.67em;height:11.67em;" width="1277" height="366"/></div>
<p>Persistence of vision using RGB LEDs</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe uses the RGB LED kit used in the previous recipe; you will also need the following additional items:</p>
<ul>
<li>Breadboard (half-sized or larger)</li>
<li>2 x DuPont female-to-male patch wires</li>
<li>Tilt switch (the ball-bearing type is suitable)</li>
<li>1 x 470 ohm resistor (R_Protect)</li>
<li>Breadboard wire (solid core)</li>
</ul>
<p>The tilt switch should be added to the RGB LED (as described in the <em>Getting ready</em> section of the <em>Multiplexed color LEDs</em> recipe). The tilt switch is wired as follows:</p>
<div><img src="img/51c2d882-d703-4337-9565-5e74effd196c.png" style="width:27.67em;height:20.25em;" width="825" height="606"/></div>
<p>The tilt switch is connected to GPIO Input (GPIO pin 24) and Gnd (GPIO pin 6)</p>
<p>To reproduce the POV image, you will need to be able to quickly move the LEDs and tilt the switch back and forth. Note how the tilt switch is mounted angled to the side, so the switch will open when moved to the left. It is recommended that the hardware is mounted onto a length of wood or similar piece of equipment. You can even use a portable USB battery pack along with a Wi-Fi dongle to power and control the Raspberry Pi through a remote connection (see the <em>Connecting Remotely to the Raspberry Pi over the Network using SSH (and X11 forwarding) recipe in </em><a href="b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started with a Raspberry Pi 3 Computer</em>, for details):</p>
<div><img src="img/3b79de7f-91ee-469c-b72e-86208b427b38.png" width="1248" height="340"/></div>
<p>Persistence of vision hardware setup</p>
<p>You will also need the completed <kbd>rgbled.py</kbd> file, which we will extend further in the <em>How to do it</em>... section.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a script called <kbd>tilt.py</kbd> to report the state of the tilt switch:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
#tilt.py 
import RPi.GPIO as GPIO 
#HARDWARE SETUP 
# GPIO 
# 2[===========T=]26[=======]40 
# 1[=============]25[=======]39 
#Tilt Config 
TILT_SW = 24 
 
def tilt_setup(): 
  #Setup the wiring 
  GPIO.setmode(GPIO.BOARD) 
  #Setup Ports 
  GPIO.setup(TILT_SW,GPIO.IN,pull_up_down=GPIO.PUD_UP) 
 
def tilt_moving(): 
  #Report the state of the Tilt Switch 
  return GPIO.input(TILT_SW) 
 
def main(): 
  import time 
  tilt_setup() 
  while True: 
    print("TILT %s"% (GPIO.input(TILT_SW))) 
    time.sleep(0.1) 
 
if __name__=='__main__': 
  try: 
    main() 
  finally: 
    GPIO.cleanup() 
    print("Closed Everything. END") 
#End </pre>
<ol start="2">
<li>You can test the script by running it directly with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo python3 tilt.py</strong></pre>
<ol start="3">
<li>Add the following <kbd>rgbled_pov()</kbd> function to the <kbd>rgbled.py</kbd> script we created previously; this will allow us to display a single line of our image:</li>
</ol>
<pre style="padding-left: 60px">def rgbled_pov(led_pattern,color,ontime): 
  '''Disable all the LEDs and re-enable the LED pattern in the required color''' 
  led_deactivate(LED,RGB) 
  for led_num,col_num in enumerate(led_pattern): 
    if col_num &gt;= 1: 
      led_activate(LED[led_num],color) 
  time.sleep(ontime) </pre>
<ol start="4">
<li>We will now create the following file, called <kbd>rgbledmessage.py</kbd>, to perform the required actions to display our message. First, we will import the modules used: the updated <kbd>rgbled</kbd> module, the new <kbd>tilt</kbd> module, and the Python <kbd>os</kbd> module. Initially, we set <kbd>DEBUG</kbd> to <kbd>True</kbd>, so the Python terminal will display additional information while the script is running:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
# rgbledmessage.py 
import rgbled as RGBLED 
import tilt as TILT 
import os 
 
DEBUG = True </pre>
<ol start="5">
<li>Add a <kbd>readMessageFile()</kbd> function to read the content of the <kbd>letters.txt</kbd> file and then add <kbd>processFileContent()</kbd> to generate a <strong>Python dictionary</strong> of the LED patterns for each letter:</li>
</ol>
<pre style="padding-left: 60px">def readMessageFile(filename): 
  assert os.path.exists(filename), 'Cannot find the message file: %s' % (filename) 
  try: 
    with open(filename, 'r') as theFile: 
    fileContent = theFile.readlines() 
  except IOError: 
    print("Unable to open %s" % (filename)) 
  if DEBUG:print ("File Content START:") 
  if DEBUG:print (fileContent) 
  if DEBUG:print ("File Content END") 
  dictionary = processFileContent(fileContent) 
  return dictionary  
 
def processFileContent(content): 
  letterIndex = [] #Will contain a list of letters stored in the file 
  letterList = []  #Will contain a list of letter formats 
  letterFormat = [] #Will contain the format of each letter 
  firstLetter = True 
  nextLetter = False 
  LETTERDIC={} 
  #Process each line that was in the file 
  for line in content: 
    # Ignore the # as comments 
    if '#' in line: 
      if DEBUG:print ("Comment: %s"%line) 
    #Check for " in the line = index name   
    elif '"' in line: 
      nextLetter = True 
      line = line.replace('"','') #Remove " characters 
      LETTER=line.rstrip() 
      if DEBUG:print ("Index: %s"%line) 
    #Remaining lines are formatting codes 
    else: 
      #Skip firstLetter until complete 
      if firstLetter: 
        firstLetter = False 
        nextLetter = False 
        lastLetter = LETTER 
      #Move to next letter if needed 
      if nextLetter: 
        nextLetter = False 
        LETTERDIC[lastLetter]=letterFormat[:] 
        letterFormat[:] = [] 
        lastLetter = LETTER 
      #Save the format data 
      values = line.rstrip().split(' ') 
      row = [] 
      for val in values: 
        row.append(int(val)) 
      letterFormat.append(row) 
  LETTERDIC[lastLetter]=letterFormat[:] 
  #Show letter patterns for debugging 
  if DEBUG:print ("LETTERDIC: %s" %LETTERDIC) 
  if DEBUG:print ("C: %s"%LETTERDIC['C']) 
  if DEBUG:print ("O: %s"%LETTERDIC['O']) 
  return LETTERDIC</pre>
<ol start="6">
<li>Add a <kbd>createBuffer()</kbd> function, which will convert a message into a series of LED patterns for each letter (assuming the letter is defined by the <kbd>letters.txt</kbd> file):</li>
</ol>
<pre style="padding-left: 60px">def createBuffer(message,dictionary): 
  buffer=[] 
  for letter in message: 
    try: 
      letterPattern=dictionary[letter] 
    except KeyError: 
      if DEBUG:print("Unknown letter %s: use _"%letter) 
      letterPattern=dictionary['_'] 
    buffer=addLetter(letterPattern,buffer) 
  if DEBUG:print("Buffer: %s"%buffer) 
  return buffer 
 
def addLetter(letter,buffer): 
  for row in letter: 
    buffer.append(row) 
  buffer.append([0,0,0,0,0]) 
  buffer.append([0,0,0,0,0]) 
  return buffer </pre>
<ol start="7">
<li>Next, we define a <kbd>displayBuffer()</kbd> function to display the LED patterns using the <kbd>rgbled_pov()</kbd> function in the <kbd>rgbled</kbd> module:</li>
</ol>
<pre style="padding-left: 60px">def displayBuffer(buffer): 
  position=0 
  while(1): 
    if(TILT.tilt_moving()==False): 
      position=0 
    elif (position+1)&lt;len(buffer): 
      position+=1 
      if DEBUG:print("Pos:%s ROW:%s"%(position,buffer[position])) 
    RGBLED.rgbled_pov(buffer[position],RGBLED.RGB_GREEN,0.001) 
    RGBLED.rgbled_pov(buffer[position],RGBLED.RGB_BLUE,0.001) </pre>
<ol start="8">
<li>Finally, we create a <kbd>main()</kbd> function to perform each of the required steps:
<ol>
<li>Set up the hardware components (RGB LEDs and the tilt switch).</li>
<li>Read the <kbd>letters.txt</kbd> file.</li>
<li>Define the dictionary of LED letter patterns.</li>
<li>Generate a buffer to represent the required message.</li>
<li>Display the buffer using the <kbd>rgbled</kbd> module and control it with the <kbd>tilt</kbd> module:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 120px">def main(): 
  RGBLED.led_setup() 
  TILT.tilt_setup() 
  dict=readMessageFile('letters.txt') 
  buffer=createBuffer('_COOKBOOK_',dict) 
  displayBuffer(buffer) 
   
if __name__=='__main__': 
  try: 
    main() 
  finally: 
    RGBLED.led_cleanup() 
    print("Closed Everything. END") 
#End </pre>
<ol start="9">
<li>Create the following file, called <kbd>letters.txt</kbd>, to define the LED patterns needed to display the example <kbd>'_COOKBOOK_'</kbd> message. Note that this file only needs to define a pattern for each unique letter or symbol in the message:</li>
</ol>
<pre style="padding-left: 60px">#COOKBOOK 
"C" 
0 1 1 1 0 
1 0 0 0 1 
1 0 0 0 1 
"O" 
0 1 1 1 0 
1 0 0 0 1 
1 0 0 0 1 
0 1 1 1 0 
"K" 
1 1 1 1 1 
0 1 0 1 0 
1 0 0 0 1 
"B" 
1 1 1 1 1 
1 0 1 0 1 
0 1 0 1 0 
"_" 
0 0 0 0 0 
0 0 0 0 0 
0 0 0 0 0 
0 0 0 0 0 
0 0 0 0 0 </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The first function, <kbd>readMessageFile()</kbd>, will open and read the contents of a given file. This will then use <kbd>processFileContent()</kbd> to return a Python dictionary containing the corresponding patterns for the letters defined in the file provided. Each line in the file is processed, ignoring any line containing a <kbd>#</kbd> character and checking for <kbd>"</kbd> characters to indicate the name of the LED pattern that follows after. After the file has been processed, we end up with a Python dictionary that contains LED patterns for the <kbd>'_'</kbd>, <kbd>'C'</kbd>, <kbd>'B'</kbd>, <kbd>'K'</kbd>, and <kbd>'O'</kbd> characters:</p>
<pre>'_': [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] 
'C': [[0, 1, 1, 1, 0], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1]] 
'B': [[1, 1, 1, 1, 1], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0]] 
'K': [[1, 1, 1, 1, 1], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]] 
'O': [[0, 1, 1, 1, 0], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [0, 1, 1, 1, 0]] </pre>
<p>Now that we have a selection of letters to choose from, we can create a sequence of LED patterns using the <kbd>createBuffer()</kbd> function. As the name suggests, the function will build up a buffer of LED patterns by looking up each letter in the message and adding the related pattern row by row. If a letter isn't found in the dictionary, then a space will be used instead.</p>
<p>Finally, we now have a list of LED patterns ready to display. To control when we start the sequence, we will use the TILT module and check the status of the tilt switch:</p>
<div><img src="img/498405aa-c0f8-4de7-bade-88e49cf495ba.png" style="width:21.42em;height:10.67em;" width="463" height="230"/></div>
<p>The tilt switch position when not moving (left) and moving (right)</p>
<p>The tilt switch consists of a small ball bearing enclosed in a hollow, insulated cylinder; the connection between the two pins is closed when the ball is resting at the bottom of the cylinder. The tilt switch is open when the ball is moved to the other end of the cylinder, out of contact of the pins:</p>
<div><img src="img/b0ca0f15-3e36-44a7-a184-ffc2fad38031.jpg" style="width:16.75em;height:11.25em;" width="604" height="408"/></div>
<p>The tilt switch circuit with the switch closed and with the switch open</p>
<p>The tilt switch circuit shown previously will allow GPIO pin 24 to be connected to the ground when the switch is closed. Then, if we read the pin, it will return <kbd>False</kbd> when it is at rest. By setting the GPIO pin as an input and enabling the internal pull-up resistor, when the tilt switch is open, it will report <kbd>True</kbd>.</p>
<p>If the tilt switch is open (reporting <kbd>True</kbd>), then we will assume the unit is being moved and begin displaying the LED sequences, incrementing the current position each time we display a row of the LED pattern. Just to make the pattern a little more colorful (just because we can!) we repeat each row in another color. As soon as the <kbd>TILT.tilt_moving()</kbd> function reports that we have stopped moving or that we are moving in the opposite direction, we will reset the current position, ready to start the whole pattern all over again:</p>
<div><img src="img/e772078c-2e3f-47de-94f9-10ba77b34d50.png" style="width:18.42em;height:6.08em;" width="1999" height="655"/></div>
<p>The message is displayed by the RGB LEDs - here, we are using green and blue together</p>
<p>When the RGB LED module and tilt switch are moved back and forth, we should see the message displayed in the air!</p>
<p>Try experimenting with different color combinations, speeds, and arm waviness to see what effects you can produce. You could even create a similar setup mounted on a wheel to produce a continuous POV effect.</p>


            

            
        
    </div>



  </body></html>