<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Application Presentation and Page Layout</h1></div></div></div><p>Up to this point, we have developed a fairly simple, but a complete application. There are some rough edges that need to be polished, obviously. For example, the templates that we use, all have a different layout, and although they use more or less the same styles and colors, they lack uniformity.</p><p>In this chapter, we are going to learn how to lay out an application. Some important points that we will cover include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Viewlet managers and viewlets</li><li class="listitem" style="list-style-type: disc">Layout definition using viewlets</li><li class="listitem" style="list-style-type: disc">Inserting forms into viewlets</li><li class="listitem" style="list-style-type: disc">Layers and skins</li><li class="listitem" style="list-style-type: disc">Defining an alternative skin for the application</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec01"/>Viewlets and viewlet managers</h1></div></div></div><p>In a typical web application, there are many parts of its layout that need to be repeated on almost every page. Sometimes these pieces need to be present in different combinations. For example, a login prompt should not appear if the user is already logged in, but a search box should be visible at all times.<a id="id235" class="indexterm"/>
</p><p>Grok solves this problem by allowing the developer to break up web pages into small pieces of HTML called<strong> viewlets</strong>, which can then be assembled as required inside a given view.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec01"/>Viewlets</h2></div></div></div><p>Viewlets provide a mechanism for separating the different components of a page into independent pieces, such as header, footer, and navigation. It's possible to further decompose these into HTML snippets, which can be shown on the page or not, depending on contextual information. This concept allows us to have great flexibility in assembling pages.<a id="id236" class="indexterm"/>
</p><p>Unlike a view, which is meant to show a complete page, a viewlet is the representation of an HTML snippet that usually has one clear function. When using viewlets, we can think of a page as a collection of these snippets.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec02"/>Viewlet managers</h2></div></div></div><p>To avoid making a view, keep track of all possible viewlet combinations. Viewlets are assigned to specific viewlet managers. A<strong> viewlet manager</strong> can represent a section of the page layout, such as the header, for instance. Viewlets register with this manager, so that it takes care of their order and rendering. In our header viewlet manager, we could have for example title, login, search box, and main navigation viewlets.<a id="id237" class="indexterm"/>
</p><p>This means that the viewlets are never called directly from a template. Instead, their viewlet manager is called and this, in turn, calls each of its registered viewlets in the desired order and renders them on the page. Viewlet managers have a few other responsibilities:<a id="id238" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Aggregation of all viewlets registered to the manager.</li><li class="listitem" style="list-style-type: disc">Applying a set of filters to determine the availability of the viewlets.</li><li class="listitem" style="list-style-type: disc">Sorting the viewlets based on an implemented policy. The default is to show them in the order in which they were declared, and Grok can also numerically sort them according to the<code class="literal"> grok.order([number])</code> directive for the viewlets.</li><li class="listitem" style="list-style-type: disc">Providing an environment in which the viewlets are rendered.</li><li class="listitem" style="list-style-type: disc">Rendering itself, containing the HTML content of the viewlets.</li></ul></div><p>Viewlets can also be tied to specific views, contexts, or permissions, so the overall system is very flexible, and is easier to manage than a collection of macros with conditional tags.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec02"/>Understanding how the pieces fit together</h1></div></div></div><p>We now have all of the pieces of how Grok constructs the page layout. When a Grok application serves a page, here's what's going on behind the scenes:</p><div><ol class="orderedlist arabic"><li class="listitem"> The browser makes a request, which contains the desired URL as well as any form input, together with the usual<code class="literal"> HTTP</code> headers, to Grok.</li><li class="listitem"> Based on the URL parts, Grok traverses (walks) the site, starting at the root and continuing on to the next part of the URL until it gets to the last model object. This model object is called the<strong> context.</strong><a id="id239" class="indexterm"/></li><li class="listitem"> When the model object is found, Grok takes the remainder of the URL and uses it as the name of a view. If there is no URL remainder, the name "index" is used.</li><li class="listitem"> Once it has the name of the view, Grok finds it and initializes the view, passing to it the context and the request used to find the view.</li><li class="listitem"> The view usually has a template assigned to it, which is used to render the response to the browser.</li><li class="listitem"> The template may include calls to a number of viewlet managers, which in turn call their contained viewlets to assemble the HTML that will be returned in the response.</li></ol></div><p>The template is the final result of calling the Grok application, and it represents the rendering of the view. The view, in turn, is associated with a context, which is the model object that has been assigned to that view.</p><p>Grok passes a lot of information to the template, in order to let the developer use all of the pieces. This information is in the form of variables that point to the following objects that can be used by the developer to build the template:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">request:</code> The<code class="literal"> HTTP</code> request that was sent by the browser, including all of the headers.<a id="id240" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">context:</code> The model object pointed to by the requested URL. In our application, this could be a project or a to-do list item.<a id="id241" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">view:</code> The view that is configured to be used for the context, according to its name. This is the code that is associated with the current template.<a id="id242" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">viewlet:</code> Inside a viewlet template, this variable represents the viewlet object.<a id="id243" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">viewletmanager:</code> Inside a viewlet template, this variable points to the viewlet manager responsible for the current viewlet.<a id="id244" class="indexterm"/></li></ul></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec03"/>View methods and attributes</h2></div></div></div><p>These methods and attributes are a part of the<code class="literal"> view</code> variable, and can be used by the developer, inside the template.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>View methods and attributes</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">context</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The object that the view is presenting. This is often an instance of a<code class="literal"> grok.Model</code> class, but can be a<code class="literal"> grok.Application</code>, a<code class="literal"> grok.Container</code> object, or any type of Python object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">request</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The<code class="literal"> HTTP Request</code> object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">response</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The<code class="literal"> HTTP Response</code> object that is associated with the request. This is also available as<code class="literal"> self.request.response</code>, but the<code class="literal"> response</code> attribute is provided as a convenience.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">static</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Directory resource containing the static files of the view's package.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">redirect(url)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Redirects to a given URL.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">url(obj=None, name=None, data=None)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Constructs URL.</p>
<p>If no arguments are given, constructs the URL to the view itself.</p>
<p>If only the<code class="literal"> obj</code> argument is given, constructs the URL to<code class="literal"> obj</code>.</p>
<p>If only<code class="literal"> name</code> is given as the first argument, constructs the URL to context/name.</p>
<p>If both of the object and name arguments are supplied, constructs the URL to<code class="literal"> obj/name</code>.</p>
<p>Optionally, you can pass a<code class="literal"> data</code> keyword argument that is added to the URL as a<code class="literal"> cgi</code> query string.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">default_namespace()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns a dictionary of namespaces that the template implementation expects to be available always. This method is<em> not</em> intended to be overridden by application developers.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">namespace()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns a dictionary that is injected into the template namespace in addition to the default namespace. This method is intended to be overridden by the application developer.</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p>View methods and attributes</p>
</td><td style="text-align: left" valign="bottom">
<p>Description</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">update(**kw)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This method is meant to be implemented by<code class="literal"> grok.View</code> subclasses. It will be called before the view's associated template is rendered, and can be used to precompute values for the template.</p>
<p>
<code class="literal">update()</code> can take arbitrary keyword parameters that will be filled in from the request (in which case they<em> must</em> be present in the request).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">render(**kw)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A view can either be rendered by an associated template, or it can implement this method to render itself from Python. This is useful if the view's output isn't XML/HTML but something computed in Python (such as plain text, PDF, and so on).</p>
<p>
<code class="literal">render()</code> can take arbitrary keyword parameters that will be filled in from the request (in which case they<em> must</em> be present in the request).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">application_url(name=None)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the URL of the closest application object in the hierarchy, or the URL of a named object (name parameter) relative to the closest application object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">flash(message, type='message')</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sends a short message to the user.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec04"/>Viewlet methods and attributes</h2></div></div></div><p>From inside a viewlet template, the following methods and attributes are available to the developer:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Viewlet methods and attributes</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">context</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Typically, this is the model object for which this viewlet is being rendered in the context of.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">request</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The<code class="literal"> Request</code> object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">view</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A reference to the view that the viewlet is being provided in.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">viewletmanager</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A reference to the<code class="literal"> ViewletManager</code> that is rendering this viewlet.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">update()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This method is called before the viewlet is rendered, and can be used to perform precomputation.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">render(*args, **kw)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This method renders the content provided by this viewlet.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec05"/>Viewlet manager methods and attributes</h2></div></div></div><p>The<code class="literal"> viewletmanager</code> variable is available to developers from inside a viewlet. These are the methods and attributes that it contains:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Viewlet manager methods and attributes</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">context</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is typically the model object for which this<code class="literal"> ViewletManager</code> is being rendered in the context of.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">request</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The<code class="literal"> Request</code> object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">view</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A reference to the view in which the<code class="literal"> ViewletManager</code> is being provided.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">update()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This method is called before the<code class="literal"> ViewletManager</code> is rendered, and can be used to perform precomputation.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">render(*args, **kw)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This method renders the content provided by this<code class="literal"> ViewletManager</code>. Typically this will mean rendering and concatenating all of the viewlets managed by this<code class="literal"> ViewletManager</code>.</p>
</td></tr></tbody></table></div><p>In addition to these methods, the viewlets contained inside the viewlet manager can be accessed using standard Python dictionary syntax.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec03"/>To-do list manager layout</h1></div></div></div><p>For our application then, we will use viewlets to generate the layout. First, let's define our layout structure, which will be more or less what we have now. Take a look at the following screenshot:<a id="id245" class="indexterm"/>
</p><div><img src="img/7481_08_01.jpg" alt="To-do list manager layout"/></div><p>It's a very simple layout. Each of the three sections (Header,<strong> Main</strong>, and<strong> Footer)</strong> represents a viewlet manager and the list of things inside these sections refers to the viewlets that will be needed. To do this in a page template, we need to use a special kind of template expression called a<strong> provider</strong>. This is how our master template will look:<a id="id246" class="indexterm"/>
</p><div><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html  xml:lang="en" lang="en"&gt;
&lt;head&gt;
&lt;tal:headslot content="structure provider:headslot" /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="header"&gt;
&lt;tal:header content="structure provider:header" /&gt;
&lt;/div&gt;
&lt;div id="main"&gt;
&lt;tal:main content="structure provider:main" /&gt;
&lt;/div&gt;
&lt;div id="footer"&gt;
&lt;tal:footer content="structure provider:footer" /&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>As we are thinking about our application's final presentation, the first thing to note is that we inserted a correct<code class="literal">&lt;DOCTYPE&gt;</code> declaration. We also removed the<code class="literal">&lt;title&gt;</code> and<code class="literal">&lt;style&gt;</code> tags from the header, as they will go inside a viewlet now.</p><p>We define four layout areas: headslot, header, main, and footer. The content for each one of those will be provided by a separate viewlet manager. The<code class="literal"> provider:name</code> expression tells Grok to find a viewlet manager with this name, render all of its registered viewlets, and return them in their configured order. As you may recall, the<code class="literal"> structure</code> prefix means to interpret whatever comes from the function call as HTML to be rendered.<a id="id247" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec06"/>Defining viewlet managers in application code</h2></div></div></div><p>We looked at the template first, to see how it relates to the desired layout, but we actually need to define some viewlet managers and viewlets to make this work. Fortunately, Grok has<code class="literal"> Viewlet</code> and<code class="literal"> ViewletManager</code> classes that we can use for this. First, let's define our viewlet managers:<a id="id248" class="indexterm"/>
</p><div><pre class="programlisting">class HeadSlot(grok.ViewletManager):
grok.context(Interface)
grok.name('headslot')
class Header(grok.ViewletManager):
grok.context(Interface)
grok.name('header')
class Main(grok.ViewletManager):
grok.context(Interface)
grok.name('main')
class Footer(grok.ViewletManager):
grok.context(Interface)
grok.name('footer')
</pre></div><p>That's it. We just subclass from<code class="literal"> grok.ViewletManager</code> and Grok will pretty much do it all for us. The key part is the<code class="literal"> grok.name</code> class declaration, as the name we use here is the one that goes inside the provider expressions in the templates. The<code class="literal"> grok.context</code> directive uses<code class="literal"> Interface</code> because it is the most general declaration possible, so doing this will enable the managers in all of our application's views and models.<a id="id249" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec07"/>Registering viewlets</h2></div></div></div><p>To get the viewlets going, we need to modify our application a bit. Up to now, we have been using separate views to define what goes on on each page and who can see it. As may be apparent from the master template that we just defined, this will now be the responsibility of the viewlets themselves.<a id="id250" class="indexterm"/>
</p><p>To convert our application to use viewlets, the first step is to take the parts that we want to turn into viewlets from the<code class="literal"> dashboard.pt</code> template and put them in their own templates. We'll do the title first, as an example. In the project, create a file named<code class="literal"> apptitle.pt</code> and enter the following code into it:</p><div><pre class="programlisting">&lt;div id="apptitle"&gt;
&lt;h1 tal:content="context/title"&gt;To-Do list manager&lt;/h1&gt;
&lt;/div&gt;
</pre></div><p>Right now, this contains only the title, but we could eventually include a logo and other similar elements.</p><p>To register this viewlet with a viewlet manager, the<code class="literal"> Viewlet</code> class is used as a base, and the<code class="literal"> grok.viewletmanager</code> class is invoked:</p><div><pre class="programlisting">class AppTitle(grok.Viewlet):
grok.viewletmanager(Header)
grok.context(Interface)
grok.order(2)
</pre></div><p>That's it. This viewlet will be registered with the<code class="literal"> Header</code> viewlet manager defined earlier. Viewlets also require a context, to let the viewlet managers know if they are to be displayed in the current context or not. As is the case for viewlet managers, we use<code class="literal"> Interface</code> as the context, so that the viewlet is enabled everywhere in the application. Also note the<code class="literal"> grok.order</code> directive, which is useful for specifying the order that the viewlet manager should use when rendering the viewlets. If<code class="literal"> grok.order</code> is not used, the viewlets will be rendered in the order that they are defined.</p><p>A<code class="literal"> Viewlet</code> class is very similar to a view. It has an<code class="literal"> update</code> method to prepare it for rendering, and a<code class="literal"> render</code> method to do the actual rendering. If these methods are omitted, Grok simply renders the corresponding template, which in this case is<code class="literal"> apptitle.pt</code>.</p><p>Now let's go for the other simple viewlets. The template for the head section,<code class="literal"> head.pt</code>, looks like this:</p><div><pre class="programlisting">&lt;meta tal:attributes="http-equiv string:Content-Type; content string:text/html;;charset=utf-8" /&gt;
&lt;title tal:content="context/title"&gt;To-Do list manager&lt;/title&gt;
&lt;link rel="stylesheet" type="text/css" tal:attributes="href static/styles.css" /&gt;
</pre></div><p>The template for the search box,<code class="literal"> searchbox.pt:</code>
<a id="id251" class="indexterm"/>
</p><div><pre class="programlisting">&lt;div id="searchbox"&gt;
&lt;form id="search" tal:attributes= "action python:view.url('search')"&gt;
&lt;input type="text" name="query" /&gt;
&lt;input class="new_button" type="submit" value="search" /&gt;
&lt;/form&gt;
&lt;/div&gt;
</pre></div><p>The logged in information and logout link,<code class="literal"> loggedin.pt</code>, is as follows:</p><div><pre class="programlisting">&lt;div id="loggedin"&gt;
&lt;p&gt;
&lt;span tal:content="string:Logged in as ${request/principal/title}"&gt; &lt;/span&gt;
&lt;a tal:attributes="href python:view.url('logout')"&gt;(Log out)&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
</pre></div><p>And a simple navigational aid,<code class="literal"> navigation.pt</code>, is defined as:</p><div><pre class="programlisting">&lt;div id="navigation"&gt;
&lt;a tal:attributes="href python:view.url('index')"&gt;Go back to main page&lt;/a&gt;
&lt;/div&gt;
</pre></div><p>For the footer, we will use a simple<strong> Powered by Grok</strong> message, along with Grok's logo, which will be defined in<code class="literal"> grokpowered.pt:</code>
</p><div><pre class="programlisting">&lt;div id="grokpowered"&gt;
&lt;a href="http://grok.zope.org"&gt;
&lt;img border="0" tal:attributes="src static/groklogo.png" /&gt;
&lt;/a&gt;
&lt;span id="poweredtext"&gt;Powered by Grok!&lt;/span&gt;
&lt;/div&gt;
</pre></div><p>Now we'll register these viewlets with their managers. We just need to add the appropriate class declarations in<code class="literal"> app.py</code>, as follows:<a id="id252" class="indexterm"/>
</p><div><pre class="programlisting">class Head(grok.Viewlet):
grok.viewletmanager(HeadSlot)
grok.context(Interface)
class SearchBox(grok.Viewlet):
grok.viewletmanager(Header)
grok.context(Interface)
grok.order(1)
class LoggedIn(grok.Viewlet):
grok.viewletmanager(Header)
grok.context(Interface)
grok.order(4)
class Navigation(grok.Viewlet):
grok.viewletmanager(Header)
grok.context(Interface)
grok.order(3)
class GrokPowered(grok.Viewlet):
grok.viewletmanager(Footer)
grok.context(Interface)
</pre></div><p>This way, the<code class="literal"> Header</code> viewlet manager has four viewlets registered in a specific order. The<code class="literal"> Footer</code> has just one viewlet at the moment.<a id="id253" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec08"/>Modifying existing views to use the master template</h2></div></div></div><p>We already have several working views in our application. To get them to use the new layout defined in the master template, we need to do two things:<a id="id254" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make them use the master template</li><li class="listitem" style="list-style-type: disc">Create viewlets that show the main parts of the old template</li></ul></div><p>The first part is easy; we just need to use the<code class="literal"> grok.template</code> directive to force each view to use the master template, like this:</p><div><pre class="programlisting">class DashBoard(grok.View):
grok.context(Todo)
grok.name('index')
grok.require('todo.view')
grok.template('master')
</pre></div><p>The viewlet itself is very similar to the other ones that we have defined, with the addition of a couple of lines:<a id="id255" class="indexterm"/>
</p><div><pre class="programlisting">class DashBoardViewlet(grok.Viewlet):
grok.viewletmanager(Main)
grok.context(Todo)
grok.template('dashboard_viewlet')
grok.view(DashBoard)
</pre></div><p>We use the<code class="literal"> grok.template</code> directive to force the viewlet to use the<code class="literal"> dashboard_viewlet</code> template. The<code class="literal"> grok.view</code> directive is used next, to make this viewlet show up only in the<code class="literal"> DashBoard</code> view. We have to do this to prevent multiple viewlets that are registered with the<code class="literal"> Main</code> viewlet manager from showing up all at once in every view. In other words, this means that the<code class="literal"> DashBoardViewlet</code> will only be rendered inside the<code class="literal"> Main</code> viewlet manager when the user is browsing the default view of the application, which happens to be the<code class="literal"> DashBoard</code> view.<a id="id256" class="indexterm"/>
</p><p>To make this work, we need an additional step. Currently, we have the template<code class="literal"> dashboard.pt</code> in the<code class="literal"> app_templates</code> directory. We can't keep this name because then the<code class="literal"> DashBoard</code> view would have two possible templates to use and Grok will refuse to guess which one to use. Therefore, we'll change the name to<code class="literal"> dashboard_viewlet.pt</code>, which is what we put in the<code class="literal"> grok.template</code> directive.</p><p>The final step is to change the template itself, and remove all of the structure from it. This structure is now included in the<code class="literal"> master.pt</code> template. This is the result:</p><div><pre class="programlisting">&lt;div id="dashboard"&gt;
&lt;p class="create"&gt;&lt;a href="add"&gt;Create a new project&lt;/a&gt;&lt;/p&gt;
&lt;h2 tal:define="projects context/values" tal:condition="projects"&gt;These are your available projects&lt;/h2&gt;
&lt;div class="projects"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;Project name&lt;/th&gt;
&lt;th&gt;Kind&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Created on&lt;/th&gt;
&lt;th&gt;Last modified&lt;/th&gt;
&lt;th&gt;Owner&lt;/th&gt;
&lt;th&gt;Delete&lt;/th&gt;
&lt;/tr&gt;
&lt;tr tal:repeat="project context/values"&gt;
&lt;td&gt;
&lt;a href="" tal:attributes="href python:view.url(project)" tal:content="project/title"&gt;title&lt;/a&gt;
&lt;/td&gt;
&lt;td tal:content="project/kind"&gt;type&lt;/td&gt;
&lt;td tal:content="project/description"&gt;type&lt;/td&gt;
&lt;td tal:content="project/creation_date"&gt;type&lt;/td&gt;
&lt;td tal:content="project/modification_date"&gt;type&lt;/td&gt;
&lt;td tal:content="project/creator"&gt;type&lt;/td&gt;
&lt;td&gt;
&lt;a tal:define="url python:view.url('deleteproject')" tal:attributes="href string:${url}?project=${project/__name__}"&gt;
&lt;img border="0" tal:attributes="src static/bin_closed.png" /&gt;
&lt;/a&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
</pre></div><p>We have to perform the same steps to make the<code class="literal"> TodoSearch</code> and<code class="literal"> UserList</code> views work. We'll end up with<code class="literal"> TodoSearchViewlet</code> and<code class="literal"> UserListViewlet</code> declarations, along with<code class="literal"> todosearch_viewlet.pt</code> and<code class="literal"> userlist_viewlet.pt</code> templates. The<code class="literal"> ProjectIndex</code> view requires extra work, because of its use of JavaScript. We'll see how to fix that later in this chapter.<a id="id257" class="indexterm"/>
</p><p>For now, you can take a look at the next screenshot and see how the layout works:</p><div><img src="img/7481_08_02.jpg" alt="Modifying existing views to use the master template"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec09"/>Inserting forms into viewlets</h2></div></div></div><p>As the "add user" and "add project" forms are generated automatically, they are still not using our new layout. We have to put these forms inside a viewlet so that we can take advantage of the layout. This requires a bit more work because the viewlet needs to render the form.<a id="id258" class="indexterm"/>
</p><div><pre class="programlisting">class AddProject(grok.View):
grok.context(Todo)
grok.template('master')
class AddProjectViewlet(grok.Viewlet):
grok.viewletmanager(Main)
grok.context(Todo)
grok.view(AddProject)
def update(self):
self.form = getMultiAdapter((self.context, self.request), name='add')
self.form.update_form()
def render(self):
return self.form.render()
</pre></div><p>We previously defined the<code class="literal"> AddProjectForm</code> and gave it the name "add". This code uses that form directly to render the viewlet. First, we define a view that will use the master template. We keep the same context that the real form uses, which is<code class="literal"> Todo</code> in this case.</p><p>Next, we create a viewlet that we register with the<code class="literal"> Main</code> viewlet manager in the same context. We assign this viewlet to the view that was just defined. The trick here is to get hold of the form, which we do by using the<code class="literal"> getMultiAdapter</code> method imported from<code class="literal"> zope.component</code>. We'll have more to say about adapters in Chapter 11, but for now, take it on faith that this call will get us the form named "add" in the current context. Once we have the form, we store it in the viewlet and use it in the viewlet's<code class="literal"> render</code> method in order to pull the rendering from the real form.<a id="id259" class="indexterm"/>
</p><p>That's all there is to it, we just need to change the link in<code class="literal"> dashboard_viewlet.pt</code> to point to "addproject" instead of just "add", and we'll get the result that we want, as shown in the following screenshot:</p><div><img src="img/7481_08_03.jpg" alt="Inserting forms into viewlets"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec10"/>Using viewlets to insert different static resources</h2></div></div></div><p>We have almost converted the whole application to use our new layout. The only thing missing is the project view. The problem with this view is that it uses some JavaScript code that is not used elsewhere, so we need to include it in the header, somehow.<a id="id260" class="indexterm"/>
</p><p>As we already have a<code class="literal"> headslot</code> viewlet manager, the easiest way to accomplish this is by registering a viewlet with this manager that will only be applied to the project view. We have done this before. The trick is to use the<code class="literal"> grok.view</code> directive to make the viewlet show only for the selected view:</p><div><pre class="programlisting">class ProjectJavascript(grok.Viewlet):
grok.viewletmanager(HeadSlot)
grok.context(Project)
grok.view(ProjectIndex)
</pre></div><p>We can now add a new template named<code class="literal"> projectjavascript.pt</code> that will include our JavaScript calls:</p><div><pre class="programlisting">&lt;script type="text/javascript" tal:attributes = "src static/todo.js"&gt;
&lt;/script&gt;
&lt;script tal:define="url python:view.url('settitle')"
tal:content="string:window.onload = hideControls;; settitleurl = '${url}';;"&gt;
&lt;/script&gt;
</pre></div><p>Now the JavaScript code will work properly in this view and the project viewlet can be seen without problems.<a id="id261" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec04"/>Layers and skins</h1></div></div></div><p>We have shown how building a flexible layout is possible by using viewlets. Grok allows us to have even more flexibility, by using layers and skins.</p><p>The look and feel of our application was created by combining some viewlets and using appropriate CSS styles. The final combination can be thought of as the 'theme' of the application. In Grok, the name we use for this is 'skin'.</p><p>A<strong> skin</strong> represents the look and feel of our application. It should be possible to rearrange all of the viewlets and edit the styles to create a totally different look and feel without changing the way that the application works. Thus, having a mechanism to handle skins allows us to easily create themes for our applications or create special skins for other uses, such as mobile browser presentation, views that respond to specific HTTP verbs (known as REST views, which are actually built like this inside Grok), or special power-user skins, depending on who is logged in.<a id="id262" class="indexterm"/>
</p><p>To simplify the creation and use of skins, they are composed of a number of layers, each of which will include only the parts of the look and feel that are different for them. This makes it easy to reuse most of the application UI and focus only on what's particular to the skin in question.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec11"/>Skins in Grok</h2></div></div></div><p>In Grok, all views and viewlets have to be assigned to a layer. Up to now, this has been happening in the background because by default there is a layer that all of them use. This is called the<strong> default browser layer</strong>. All applications in Grok have a default skin, which has no name and is composed of only one layer.<a id="id263" class="indexterm"/>
</p><p>However, the difference between a skin and a layer is subtle. In reality they are very similar, but a skin has a name that will be known to the user, whereas a layer is anonymous. The intention is to have skins consisting of a number of layers, and to use the name to refer to the result.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec05"/>Adding themes to our application</h1></div></div></div><p>Let's add different themes to our application by using skins. We'll make it very simple for now. We already have a viewlet that includes the<code class="literal">&lt;link&gt;</code> tag for our stylesheet. To design a theme, we'll simply create a layer that overrides this viewlet and uses a different stylesheet. In this way, we can create a new theme just by adding seven lines of code, a template, and a stylesheet.<a id="id264" class="indexterm"/>
</p><p>We are using blue for the masthead of our application. We'll add a second theme, which uses red, and another one that uses green. As the names will be known to the users, we'll use fancy names: the red theme will be called "martian" and the green theme will be known as "forest".</p><p>A layer in Grok needs to inherit from the<code class="literal"> IDefaultBrowserLayer</code> defined in<code class="literal"> zope.publisher</code>. So the first thing we need to do is to import that:</p><div><pre class="programlisting">from zope.publisher.interfaces.browser import IDefaultBrowserLayer
</pre></div><p>We can now define the skins in<code class="literal"> app.py</code>, as follows:</p><div><pre class="programlisting">class MartianLayer(IDefaultBrowserLayer):
grok.skin('martian')
class ForestLayer(IDefaultBrowserLayer):
grok.skin('forest')
</pre></div><p>For each skin, we just define a class based on<code class="literal"> IDefaultBrowserLayer</code>, and then use the<code class="literal"> grok.skin</code> directive to name it. This name will be used to browse to the skin.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec12"/>Overriding a viewlet</h2></div></div></div><p>Now that we have the skins, we can override the<code class="literal"> Head</code> viewlet, where the stylesheet link is defined. This viewlet is managed by the<code class="literal"> HeadSlot</code> viewlet manager. To override a viewlet, we just have to create another one, with the same name:<a id="id265" class="indexterm"/>
</p><div><pre class="programlisting">class HeadMartian(grok.Viewlet):
grok.viewletmanager(HeadSlot)
grok.context(Interface)
grok.name('head')
grok.template('head_martian')
grok.layer(MartianLayer)
class HeadForest(grok.Viewlet):
grok.viewletmanager(HeadSlot)
grok.context(Interface)
grok.name('head')
grok.template('head_forest')
grok.layer(ForestLayer)
</pre></div><p>Notice how the<code class="literal"> HeadMartian</code> and<code class="literal"> HeadForest</code> viewlets have exactly the same viewlet manager, context, and name as those used by the<code class="literal"> Head</code> viewlet that they override. The difference is that they will use another template. To make the<code class="literal"> HeadMartian</code> viewlet work only on the<code class="literal"> MartianLayer</code> skin, we add the<code class="literal"> grok.layer</code> directive and pass it to the skin. Keep in mind that<code class="literal"> grok.layer</code> can be used in any viewlet or view that we define, so we could override anything from the application, or create new views or viewlets that appear only when using a specific skin.</p><p>In this case, this is all the code that needs to be added to these two themes for our application. We just need to add the templates and styles and we are done. For the martian theme, we directed the viewlet to use the<code class="literal"> head_martian</code> template, so we create a file named<code class="literal"> head_martian.pt</code> and add the following code to it:</p><div><pre class="programlisting">&lt;meta tal:attributes="http-equiv string:Content-Type; content string:text/html;;charset=utf-8"/&gt;
&lt;title tal:content="context/title"&gt;To-Do list manager&lt;/title&gt;
&lt;link rel="stylesheet" type="text/css" tal:attributes="href static/styles_martian.css" /&gt;
</pre></div><p>The only change is the name of the stylesheet in the<code class="literal">&lt;link&gt;</code> tag.</p><p>For the forest theme, we'll create the<code class="literal"> head_forest.pt</code> file and add the same text, except that we have to change the name of the CSS file to<code class="literal"> styles_forest.css</code> in order to use the correct stylesheet.</p><p>All that's left now is to add the new stylesheets. To keep things simple, we'll just copy the<code class="literal"> styles.css</code> file to<code class="literal"> styles_martian.css</code> and<code class="literal"> styles_forest.css</code>, and then make some color substitutions. Using your favorite text editor, change all occurrences of<code class="literal"> #223388</code> to<code class="literal"> #883322</code> in martian and to<code class="literal"> #338822</code> in forest. Other than that, the themes will be exactly the same, but we'll easily be able to see the difference. Feel free to make more style changes if you like.<a id="id266" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec13"/>Using the new skins</h2></div></div></div><p>To actually see the new skins, we need to tell Grok that a different skin than the default has to be used. The simplest way to do this is to use the special<code class="literal"> ++skin++</code> name in the URL, along with the skin name. Grok will see this, and use the correct skin.<a id="id267" class="indexterm"/>
</p><p>For example, we'll see the martian skin if we point the browser to the following URL:<a class="ulink" href="http://localhost:8080/++skin++martian/todo"> http://localhost:8080/++skin++martian/todo</a>. Notice how the<code class="literal"> ++skin++</code> name goes immediately after the hostname. Grok will signal an error if we put it anywhere else in the URL. To see the forest skin, just change the word<code class="literal"> martian</code> to<code class="literal"> forest</code> in the preceding URL. See the next screenshot to take a look at the martian skin:</p><div><img src="img/7481_08_04.jpg" alt="Using the new skins"/></div><p>We are done. If we browse through the application, we'll see that all of the pages now show the header with the corresponding background color.</p><p>Of course, asking the user to type the name of the skin in the URL will not do for production use. In Chapter 11, we'll see how to let the user choose a skin via a preferences menu, and get Grok to apply the correct skin itself.<a id="id268" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec06"/>Summary</h1></div></div></div><p>In this chapter, we learned about Grok's layout and presentation facilities, including viewlets, layers, and skins. We modified our application to have a consistent look and feel, by using these tools. We will now go on to learn about the ZODB and how Grok uses it.</p></div></div>
</body></html>