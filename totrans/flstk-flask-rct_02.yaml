- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Getting Started with React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React入门
- en: So far, we have laid a solid foundation for understanding full stack web development
    using modern software stacks. Hopefully, you have already set up a React development
    environment on your local machine. If not, you can go back to [*Chapter 1*](B18554_01.xhtml#_idTextAnchor014),
    *Getting Full Stack Ready with React and Flask*, and revisit the *Setting up a
    development environment with* *React* section.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为使用现代软件栈理解全栈Web开发奠定了坚实的基础。希望您已经在本地机器上设置了React开发环境。如果没有，您可以回到[*第1章*](B18554_01.xhtml#_idTextAnchor014)，*使用React和Flask准备全栈开发*，并重新阅读*使用React设置开发环境*部分。
- en: In this chapter, we’ll systematically start to introduce you to the world of
    React in a subtle way. You will learn a bunch of cool concepts and techniques
    that will help you develop intuitive user interfaces that enable users to interact
    with your web application. You will learn how to spring up your first React project
    without the hassle of a complex configuration and understand the basic directory
    structure required for every React project. Then, you’ll learn how to use ES6
    features in React.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将系统地以微妙的方式开始向您介绍React的世界。您将学习许多酷炫的概念和技术，这将帮助您开发直观的用户界面，使用户能够与您的Web应用程序进行交互。您将学习如何在无需复杂配置的麻烦下启动您的第一个React项目，并了解每个React项目所需的基本目录结构。然后，您将学习如何在React中使用ES6特性。
- en: '**Components** are the building blocks of any React application. In this chapter,
    you will understand concepts around components and how you can use them to build
    user interfaces in React. This knowledge is vital for building modern frontend
    technologies in your project. With detailed use cases, you will understand the
    use of props in React for passing information between components, and how states
    add interactivity to React applications.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是任何React应用程序的构建块。在本章中，您将了解组件的概念以及如何使用它们在React中构建用户界面。这些知识对于在项目中构建现代前端技术至关重要。通过详细的使用案例，您将了解React中props的使用，用于在组件之间传递信息，以及状态如何为React应用程序添加交互性。'
- en: By the end of this chapter, you will have acquired, in a practical way, the
    skill sets required to get started with any React project. You will also have
    a deeper understanding of React core features (components, props, and state) to
    develop interactivity in any web application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将以实际的方式掌握开始任何React项目所需的技能集。您还将对React的核心功能（组件、props和状态）有更深入的理解，以开发任何Web应用程序的交互性。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Exploring a React project directory structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索React项目目录结构
- en: Arrow functions in React
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的箭头函数
- en: Understanding what destructuring is
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解解构是什么
- en: Default and named exports
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认和命名导出
- en: What is a React component?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是React组件？
- en: What are props?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是props？
- en: React state
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React状态
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter02).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter02)。
- en: Exploring a React project directory structure
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索React项目目录结构
- en: In a moment, we’ll set up a React application project. There are many ways to
    create a React application. You could use the **Create React App** tool to generate
    a boilerplate application with no build configurations. This doesn’t require you
    to have complex configuration knowledge.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将设置一个React应用程序项目。创建React应用程序有许多方法。您可以使用**Create React App**工具生成一个没有构建配置的样板应用程序。这不需要您具备复杂的配置知识。
- en: You can simply focus on the implementation of your application straight up.
    This is what we’ll be using in this book. And if you are open to exploring **Vite**
    ([https://vitejs.dev/](https://vitejs.dev/)), it is another next-generation frontend
    tooling for rapid React application setup.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接关注应用程序的实现。这正是本书将要使用的。如果您愿意探索**Vite**([https://vitejs.dev/](https://vitejs.dev/))，它也是另一个用于快速设置React应用程序的下一代前端工具。
- en: The other way of creating a React application requires knowledge of Webpack
    and Babel configurations. Now, without further delay, let’s dive into creating
    our React project application. You are expected to follow along.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建React应用程序的另一种方式需要了解Webpack和Babel配置。现在，不再拖延，让我们深入了解创建我们的React项目应用程序。你被期望跟随操作。
- en: 'Open your terminal and type the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的终端并输入以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will get the following output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![Figure 2.1 – Screenshot of the create -react-app command](img/Figure_2.1_B18554.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – create-react-app命令的截图](img/Figure_2.1_B18554.jpg)'
- en: Figure 2.1 – Screenshot of the create -react-app command
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – create-react-app命令的截图
- en: 'Navigate into the `frontend` folder after the setup has finished:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，导航到`frontend`文件夹：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can open the application using `code .` on the command line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在命令行中使用`code .`打开应用程序：
- en: "![Figure 2.2 – Screenshot of \uFEFFcreate-react-app showing code \uFEFFto open\
    \ the VS Code editor \uFEFFin the project root directory](img/Figure_2.2_B18554.jpg)"
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – create-react-app的截图，显示在项目根目录中打开VS Code编辑器的代码](img/Figure_2.2_B18554.jpg)'
- en: Figure 2.2 – Screenshot of create-react-app showing code to open the VS Code
    editor in the project root directory
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – create-react-app的截图，显示在项目根目录中打开VS Code编辑器的代码
- en: 'The following extracted folders and files structure will appear in the VS Code
    editor:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code编辑器中会出现以下提取的文件夹和文件结构：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the screenshot of the VS Code project directory
    structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了VS Code项目目录结构的截图：
- en: '![Figure 2.3 – Screenshot showing the project directory structure](img/Figure_2.3_B18554.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 显示项目目录结构的截图](img/Figure_2.3_B18554.jpg)'
- en: Figure 2.3 – Screenshot showing the project directory structure
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 显示项目目录结构的截图
- en: 'So, let’s quickly dive into the preceding file and folder list to understand
    their individual purposes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们快速浏览一下前面的文件和文件夹列表，以了解它们的各自用途：
- en: '`node_modules/`: This folder holds all node packages installed with the Create
    React App tool. All the `dependencies` and `devdependencies` are stored inside.
    It is good to note that all subsequent packages we’ll install in the future will
    also be kept in this folder.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules/`：这个文件夹包含使用Create React App工具安装的所有node包。所有的`dependencies`和`devdependencies`都存储在这里。值得注意的是，我们将来安装的所有后续包也将保存在这个文件夹中。'
- en: '`public/`: This folder contains important public files such as `public/index.html`
    and `public/manifest.json`:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public/`：这个文件夹包含重要的公共文件，如`public/index.html`和`public/manifest.json`：'
- en: The `index` file displays on `localhost:3000` when the app is in the development
    environment or on a hosted domain. Essentially, this file puts React components’
    execution results in the `index` file’s root `div` container for public view.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`文件在开发环境或托管域名中显示在`localhost:3000`上。本质上，这个文件将React组件的执行结果放在公共视图的`index`文件根`div`容器中。'
- en: The folder also contains the `manifest.json` file, which contains application
    metadata and details for responsive screen display.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该文件夹还包含`manifest.json`文件，其中包含应用程序元数据和响应式屏幕显示的详细信息。
- en: '`src/`: This is the most vital folder in React application development. More
    than 80% of your coding activities’ time will be spent here. So, it is important
    to know exactly what you are doing inside this folder. This folder contains components
    and a few other files, such as `src/App.js`, `src/App.css`, `src/index.css`, `src/App.test.js`,
    and `src/index.js`:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/`：这是React应用程序开发中最关键的文件夹。你超过80%的编码活动时间都将在这里度过。因此，了解你在这个文件夹内确切地做什么非常重要。这个文件夹包含组件和一些其他文件，例如`src/App.js`、`src/App.css`、`src/index.css`、`src/App.test.js`和`src/index.js`：'
- en: The `src/App.js` file is used to implement React components. If you are working
    on a small project, you can use it to implement your application without creating
    other component files. All your component code will be put inside a single file.
    As your application grows, you might consider splitting up your components into
    multiple component files. With this split up, each file will then maintain one
    or more components.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/App.js`文件用于实现React组件。如果你正在处理一个小项目，你可以用它来实现你的应用程序，而无需创建其他组件文件。你所有的组件代码都将放在一个单独的文件中。随着你的应用程序的增长，你可能会考虑将组件拆分成多个组件文件。通过这种拆分，每个文件将维护一个或多个组件。'
- en: The `src/App.css` file is used to style your component. The same goes for the
    `src/index.css` file, which is used to style your overall application. Both these
    files can be edited to suit your style requirements.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/App.css`文件用于设置组件的样式。同样，`src/index.css`文件也用于设置整个应用程序的样式。这两个文件都可以编辑以满足您的样式要求。'
- en: The `src/App.test.js` file is used to write unit tests for React applications.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/App.test.js`文件用于编写React应用的单元测试。'
- en: The `index.js` file is the entry point to your React application.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.js`文件是您的React应用的入口点。'
- en: '`.gitignore`: This file contains lists of files and folders that shouldn’t
    be tracked and added to the Git repository in your project. For instance, `node_modules`
    is always listed in the file as it is only needed in the development environment.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.gitignore`: 此文件包含不应跟踪和添加到项目中Git仓库的文件和文件夹列表。例如，`node_modules`总是列在文件中，因为它仅在开发环境中需要。'
- en: '`package.json`: This file contains node package dependencies and other metadata
    used in the project. This makes it easy to set up the same on another computer
    system using **Node Package Manager** (**npm**) without much hassle.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package.json`: 此文件包含项目中使用的节点包依赖和其他元数据。这使得使用**Node包管理器**（**npm**）在另一台计算机系统上设置相同内容变得非常容易，无需太多麻烦。'
- en: '`package-lock.json`: This file stores the version number of your installed
    packages from `npm`. This ensures consistency of package installation from `npm`
    to other developers’ local computer systems.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-lock.json`: 此文件存储了您通过`npm`安装的包的版本号。这确保了从`npm`到其他开发者的本地计算机系统安装包的一致性。'
- en: '`README.md`: This is a Markdown file. `README.md` file helps developers to
    give instructions and essential information about their projects. On GitHub, you
    can use the `README.md` file to display information about the content contained
    in project repositories. The Create React App tool generates this file for us
    out of the box.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`: 这是一个Markdown文件。`README.md`文件帮助开发者提供有关他们项目的说明和必要信息。在GitHub上，您可以使用`README.md`文件显示项目存储库中包含的内容。Create
    React App工具会为我们自动生成此文件。'
- en: 'Now that you know some of the purposes of the folders and files structure of
    your React project, let’s run the `npm start` command in the terminal to see the
    default React application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了React项目中文件夹和文件结构的一些用途，让我们在终端中运行`npm start`命令，以查看默认的React应用：
- en: '![Figure 2.4 – Screenshot of the React app home page on localhost:3000](img/Figure_2.4_B18554.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 本地host:3000上React应用主页的截图](img/Figure_2.4_B18554.jpg)'
- en: Figure 2.4 – Screenshot of the React app home page on localhost:3000
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 本地host:3000上React应用主页的截图
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following shows some of the messages such as success messages, available
    scripts, and how to start the development server after the installation of React:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了某些消息，例如成功消息、可用脚本以及安装React后如何启动开发服务器：
- en: '`npm start`: Starts the development server'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm start`: 启动开发服务器'
- en: '`npm run build`: Bundles the app into static files for production'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm run build`: 将应用打包成用于生产的静态文件'
- en: '`npm test`: Starts the test runner'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm test`: 启动测试运行器'
- en: In summary, we have discussed how you can power up your React application with
    the create-react-app tool. You now know what each folder and file represents in
    detail. With this, you can be confident that you know how to set up a React application.
    Let’s start the next section by discussing arrow functions. Arrow functions are
    one of the features of **ECMAScript 2015** (**ES6**). They’re a nifty addition
    to JavaScript that makes writing functions a breeze!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们讨论了如何使用create-react-app工具来增强您的React应用。现在您已经详细了解了每个文件夹和文件的含义。有了这些，您可以有信心知道如何设置React应用。让我们通过讨论箭头函数来开始下一节。箭头函数是**ECMAScript
    2015**（**ES6**）的一个特性。它们是JavaScript中编写函数的一个便捷的补充，使得编写函数变得轻而易举！
- en: Arrow functions in React
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的箭头函数
- en: '**Arrow functions** provide a more concise and readable syntax for defining
    functions in JavaScript. Arrow functions have become a widely used feature in
    React development for obvious reasons: shorter syntax and implicit return. You
    will have a better understanding of what these mean in a moment.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**箭头函数**为JavaScript中定义函数提供了更简洁、更易读的语法。箭头函数因其简洁的语法和隐式返回而成为React开发中广泛使用的一个特性：您将在稍后更好地理解这些含义。'
- en: 'In traditional JavaScript, you would have to define a regular function that
    adds two numbers together like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的JavaScript中，您必须定义一个常规函数来将两个数字相加，如下所示：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Not bad, right? But arrow functions can make this even simpler and more elegant.
    Check this out:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，对吧？但箭头函数可以使这更加简单和优雅。看看这个：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Pretty cool? The `function` keyword is replaced with a funky-looking arrow,
    `=>`, and you can omit the curly braces and the `return` statement if your function
    is just a one-liner:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷？将 `function` 关键字替换为看起来很酷的箭头 `=>`，如果你的函数只是一行代码，你可以省略花括号和 `return` 语句：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Basically, you define arrow functions by following this syntax rule:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你通过遵循以下语法规则来定义箭头函数：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or, for even shorter function definition with implicit return when the function
    body consists of a single expression, use this rule:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于函数体仅由一个表达式组成时的更短函数定义和隐式返回，可以使用这个规则：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Arrow functions are often used within React applications due to their concise
    syntax and benefits, especially when defining function components, handling event
    callbacks, and mapping arrays. We will see more arrow functions usage in the course
    of this book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数由于其简洁的语法和好处，常在 React 应用中使用，尤其是在定义函数组件、处理事件回调和映射数组时。在这本书的学习过程中，我们将看到更多箭头函数的使用。
- en: However, it’s important to note that arrow functions are not a complete replacement
    for regular functions. They have some limitations, such as not having their own
    `this` context, which makes them unsuitable for certain use cases, such as defining
    object methods.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，箭头函数并不是常规函数的完全替代品。它们有一些限制，例如没有自己的 `this` 上下文，这使得它们不适合某些用例，例如定义对象方法。
- en: When used in defining the object method, arrow functions do not have their own
    context and would not properly access the name property within the object. Let’s
    use the following code example to illustrate it better.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当在定义对象方法时使用箭头函数，它们没有自己的上下文，因此无法正确访问对象内的名称属性。让我们通过以下代码示例来更好地说明这一点。
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s use an arrow function to define the object method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用箭头函数来定义对象方法：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In summary, arrow functions are a fantastic feature in ES6, making your code
    cleaner and more pleasant to work with. They’re perfect for short functions and
    can make your life as a React developer a whole lot easier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，箭头函数是 ES6 中的一个绝佳特性，可以使你的代码更简洁、更易于工作。它们非常适合短函数，并且可以使 React 开发者的生活变得更加轻松。
- en: 'Next, we will take a look at another cool ES6 feature: **destructuring**. You
    will need the destructuring technique to be able to extract values from arrays
    or objects in a more concise and readable way.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨另一个酷炫的 ES6 功能：**解构**。你需要解构技术来能够以更简洁和可读的方式从数组或对象中提取值。
- en: Understanding what destructuring is
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解解构是什么
- en: '**Destructuring** is simply a JavaScript expression that ensures you are able
    to extract multiple values from arrays or properties from objects into separate
    unique variables. Destructuring is one of the awesome JavaScript ES6 features
    used in React to manage data.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**解构**是一种简单的 JavaScript 表达式，确保你能够从数组中提取多个值或从对象中提取属性到单独的独特变量中。解构是 React 中用于管理数据的一些令人惊叹的
    JavaScript ES6 功能之一。'
- en: 'ES6 was a major milestone in the effort to improve standards in the JavaScript
    language. Destructuring takes extracting data from arrays and objects to a new
    concise level. Prior to ES6, you could declare and extract data from an array
    this way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 是改进 JavaScript 语言标准过程中的一个重要里程碑。解构将从数组和对对象提取数据提升到一个新的简洁水平。在 ES6 之前，你可以这样声明并从数组中提取数据：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With destructuring, the code looks like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解构，代码看起来是这样的：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we want to skip `"John"` in the array and write out to the console the remaining
    items in the array, we can do the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在数组中跳过 `"John"` 并将数组中剩余的项输出到控制台，我们可以这样做：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In addition, it is not only arrays that can be destructured; you can perform
    destructuring in objects as well. For instance, the following code shows how to
    destructure object properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不仅数组可以进行解构；你还可以在对象中进行解构。例如，以下代码展示了如何解构对象属性：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can see how we were able to extract the values of properties in the preceding
    code snippet. It is even possible to destructure the nested `address` property
    in the object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们如何在前面的代码片段中提取属性值。甚至可以解构对象中的嵌套 `address` 属性：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, what are the benefits of destructuring in React applications? Destructuring
    makes your code more compact and easier to understand. It allows you to extract
    specific properties from objects or elements from arrays directly, reducing the
    need for repetitive dot notation or array indexing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在React应用中使用解构赋值有哪些好处？解构赋值使你的代码更加紧凑且易于理解。它允许你直接从对象中提取特定属性或从数组中提取元素，减少了重复使用点符号或数组索引的需求。
- en: 'Also, destructuring allows you to set default values for properties – for instance,
    take a look at the following line of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，解构赋值允许你为属性设置默认值 - 例如，看看以下代码行：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code can be useful when working with optional or potentially undefined
    data and default values are required. Destructuring is used in accessing `props`
    and `state` in components. Oh, you don’t know what `components`, `props`, and
    `state` are all about? Fret not, we will discuss these concepts in this chapter
    shortly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在处理可选或可能未定义的数据时非常有用，并且需要默认值。解构赋值在访问组件中的`props`和`state`时被使用。哦，你不知道`components`、`props`和`state`是什么？别担心，我们将在本章稍后讨论这些概念。
- en: In summary, destructuring allows programmers to access data, even complex nested
    data in arrays and objects, in an easy way. It substantially improves the quality
    of code readability and access. And if you want a shorter line of code in your
    React application, destructuring clearly helps. It helps to cut the amount of
    code used in an application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，解构赋值允许程序员以简单的方式访问数据，即使在数组和对象中的复杂嵌套数据。它显著提高了代码的可读性和访问质量。如果你想在React应用中缩短代码行数，解构赋值显然有帮助。它有助于减少应用中使用的代码量。
- en: The next cool concepts to understand in React application development are default
    and named exports. Let’s dive in and understand these React concepts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在React应用开发中，接下来需要理解的两个酷炫概念是默认导出和命名导出。让我们深入探讨并理解这些React概念。
- en: Default and named exports
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认导出和命名导出
- en: As mentioned earlier, ECMAScript 2015, also known as ES6, was a major milestone
    in the effort to improve standards in the JavaScript language. Among the new features
    added were modules and the ability to use `import` expressions. Modules allow
    us to better organize our code base into logical units. Basically, modules could
    be a function or related functions designed to perform specific tasks. They make
    code reusability across projects easier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ECMAScript 2015，也称为ES6，是提高JavaScript语言标准的重要里程碑。其中添加的新特性包括模块和能够使用`import`表达式。模块使我们能够更好地将代码库组织成逻辑单元。基本上，模块可以是执行特定任务的一个或多个相关函数。它们使得在项目间重用代码变得更加容易。
- en: In React, we use a default export to make component functions, variables, classes,
    or objects available to other component files. Only one default export is allowed
    per file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，我们使用默认导出来使组件函数、变量、类或对象对其他组件文件可用。每个文件只允许有一个默认导出。
- en: 'For instance, the following code makes it possible to import a file from the
    `Speaker` component:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码使得从`Speaker`组件导入文件成为可能：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following code makes it possible to export the file to another component
    file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使得将文件导出到另一个组件文件成为可能：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In a named export, you can have multiple named exports per file. And when you
    want to import, you can name the specific import with braces, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名导出中，每个文件可以有多个命名导出。当你想要导入时，你可以用大括号命名特定的导入，如下所示：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To sum up, default and named components are a way to make specific functions
    available across components in any React project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，默认导出和命名导出是使特定函数在React项目的任何组件间可用的一种方式。
- en: Next, we’ll delve into the core essence of React components and gain a clear
    understanding of their purpose and functionality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨React组件的核心本质，并对其目的和功能有一个清晰的理解。
- en: What is a React component?
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是React组件？
- en: A **component** is the core building block of any React application. Sometimes,
    you could perceive React as a JavaScript coated with some chocolate. Chocolate
    is sweet I guess, and so is React. Seriously, building a UI with vanilla JavaScript
    can be cumbersome. You can struggle with the expensive DOM dilemma!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是任何React应用的核心构建块。有时，你可以把React看作是加了点巧克力的JavaScript。我想巧克力是甜的，React也是。说真的，用纯JavaScript构建UI可能会很繁琐。你可能会在昂贵的DOM困境中挣扎！'
- en: The thing is, when working with vanilla JavaScript to handle the **Document
    Object Model** (**DOM**), it can get pretty expensive – both in terms of time
    and effort. Frequent DOM manipulation is high in non-React applications, which
    ultimately results in the slowness of website elements update.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，当使用纯 JavaScript 处理 **文档对象模型**（**DOM**）时，这可能会相当昂贵——无论是时间还是精力。在非 React 应用程序中，频繁的
    DOM 操作很高，这最终导致网站元素更新的缓慢。
- en: The **virtual DOM** solved this problem in React. The DOM only updates what
    was changed, not the entire DOM tree. However, if you remember how you use functions
    in plain JavaScript, writing components won’t be a challenge. A function in JavaScript
    is a code block designed essentially to perform certain tasks.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟 DOM** 在 React 中解决了这个问题。DOM 只更新更改的部分，而不是整个 DOM 树。然而，如果您记得您是如何在纯 JavaScript
    中使用函数的，编写组件不会是一个挑战。JavaScript 中的函数本质上是一个代码块，用于执行某些任务。'
- en: The same applies to React components, which are reusable, maintainable, and
    self-contained blocks of code to return a UI. In React, components return HTML
    elements mixed with some JavaScript.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于 React 组件，它们是可重用、可维护且自包含的代码块，用于返回 UI。在 React 中，组件返回混合了 JavaScript 的 HTML
    元素。
- en: 'There are two types of React components: **class components** and **function
    components**. In this book, we’ll adopt function component coding patterns to
    develop our React application.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: React 有两种类型的组件：**类组件**和**函数组件**。在这本书中，我们将采用函数组件编码模式来开发我们的 React 应用程序。
- en: Function components are the present and future of React, so if you are just
    learning React, the function component is easier to learn without the extras involved
    in writing class components. And if you are already familiar with class components
    in React, you can still use function components along with class components. If
    you find yourself working with a legacy React code base, it’s definitely worth
    considering a gradual migration toward function components.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件是 React 的现在和未来，所以如果您刚开始学习 React，函数组件比编写类组件所涉及的额外内容更容易学习。如果您已经熟悉 React 中的类组件，您仍然可以使用函数组件与类组件一起使用。如果您发现自己正在使用遗留的
    React 代码库，逐步迁移到函数组件绝对值得考虑。
- en: 'Let us learn how to define a function component and use it in React applications
    by doing the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，让我们学习如何定义一个函数组件并在 React 应用程序中使用它：
- en: 'Open `App.js` in the `src/` file of the React project directory. The `src/App.js`
    file contains the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 React 项目的 `src/` 文件夹中打开 `App.js` 文件。`src/App.js` 文件包含以下代码：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s remove all the boilerplate code in the file to easily understand the
    code structure. Replace the preceding code snippet with the following code snippet:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们删除文件中的所有样板代码，以便更容易理解代码结构。用以下代码片段替换前面的代码片段：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Your `src/App.js` file should now look like the preceding snippet.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `src/App.js` 文件现在应该看起来像前面的代码片段。
- en: 'Save the file, start your application with `npm start` in the command line,
    and you will get the following output:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，在命令行中使用 `npm start` 启动您的应用程序，您将得到以下输出：
- en: '![Figure 2.5 – Screenshot showing the output of the npm start command](img/Figure_2.5_B18554.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 展示 npm start 命令输出的截图](img/Figure_2.5_B18554.jpg)'
- en: Figure 2.5 – Screenshot showing the output of the npm start command
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 展示 npm start 命令输出的截图
- en: Check whether **Welcome to Bizza Platform** displays on your browser. If yes,
    you are still on the right track.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 **Welcome to Bizza Platform** 是否显示在您的浏览器上。如果是，您仍然走在正确的道路上。
- en: '![Figure 2.6 – Screenshot of the React app home page on localhost:3000](img/Figure_2.6_B18554.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 本地主机 3000 上的 React 应用程序主页截图](img/Figure_2.6_B18554.jpg)'
- en: Figure 2.6 – Screenshot of the React app home page on localhost:3000
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 本地主机 3000 上的 React 应用程序主页截图
- en: So, let’s dive deeper into each element of the code block to understand function
    components better.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们更深入地研究代码块中的每个元素，以更好地理解函数组件。
- en: Function components
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组件
- en: As stated already, function components are conceptually a typical JavaScript
    function with the ability to receive data as props and return HTML elements in
    the form of JavaScript XML.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数组件在概念上是一个典型的 JavaScript 函数，具有接收数据作为 props 并以 JavaScript XML 形式返回 HTML
    元素的能力。
- en: In the preceding code, the `App` component doesn’t have any parameters yet in
    its function definition.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`App` 组件在其函数定义中还没有任何参数。
- en: 'This is how you define an `App` component in a React application:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您在 React 应用程序中定义 `App` 组件的方式：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The code returns the following HTML elements:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码返回以下 HTML 元素：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `App` component returns HTML code. The returned HTML code is a mixture of
    HTML and JavaScript. This is called **JavaScript XML** (**JSX**). JSX is a syntax
    extension used in React that allows you to write HTML-like code directly within
    JavaScript. JSX makes it easier to describe the structure of user interfaces in
    React components. In [*Chapter 5*](B18554_05.xhtml#_idTextAnchor095), *JSX and
    Displaying Lists in React*, we’ll discuss JSX in depth.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 组件返回 HTML 代码。返回的 HTML 代码是 HTML 和 JavaScript 的混合体。这被称为**JavaScript XML**（**JSX**）。JSX
    是 React 中用于在 JavaScript 中直接编写类似 HTML 代码的语法扩展。JSX 使得在 React 组件中描述用户界面结构变得更加容易。在[*第
    5 章*](B18554_05.xhtml#_idTextAnchor095) *React 中的 JSX 和显示列表*中，我们将深入讨论 JSX。'
- en: As discussed earlier, we’ll be focusing more on function components in this
    book. If you are comfortable writing functions in plain JavaScript, function components
    in React will definitely be familiar. In React function components, you are able
    to have implementation details between the function definition and the `return`
    statement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在这本书中更多地关注函数组件。如果你熟悉用纯 JavaScript 编写函数，React 中的函数组件肯定会让你感到熟悉。在 React
    函数组件中，你可以在函数定义和 `return` 语句之间有实现细节。
- en: 'For instance, let’s check `App` component inside `src/App.js`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们检查 `src/App.js` 中的 `App` 组件：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Any variables defined in the function’s body will be re-defined each time this
    function runs:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中定义的任何变量都会在每次函数运行时重新定义：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Start your browser with `npm start` and check the updated content in your browser.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `npm start` 启动浏览器并检查浏览器中的更新内容。
- en: 'If your server is still running, you do not need to use `npm start` again.
    Your app will recompile and display an updated view as soon as you save your file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务器仍在运行，你不需要再次使用 `npm start`。每次你保存文件时，你的应用程序都会重新编译并显示更新后的视图：
- en: '![Figure 2.7 – Screenshot showing the preceding snippet output](img/Figure_2.7_B18554.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 展示前一个代码片段输出的截图](img/Figure_2.7_B18554.jpg)'
- en: Figure 2.7 – Screenshot showing the preceding snippet output
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 展示前一个代码片段输出的截图
- en: 'Also, you can have your variable defined outside the body of your component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以在组件体外部定义你的变量：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the function component, the results from the function operation can either
    be *run the first time* or *re-rendered on updates.* However, you can define your
    variable outside the function component if it doesn’t need anything from within
    the function component’s body; otherwise, consider defining it in the function
    component’s body.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数组件中，函数操作的结果可以是*第一次运行*或*在更新时重新渲染*。然而，如果你不需要函数组件体内的任何内容，你可以在函数组件外部定义你的变量；否则，考虑在函数组件体内定义它。
- en: In summary, we have been able to discuss function components in React and how
    to write and display the content of your function component. Next, we will discuss
    class components and why they are called **stateful components**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们已经能够讨论 React 中的函数组件以及如何编写和显示函数组件的内容。接下来，我们将讨论类组件以及为什么它们被称为**有状态组件**。
- en: Class components
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类组件
- en: React provides us with the flexibility to construct UI components using either
    functions or classes for the component code. Class components are JavaScript classes
    that extend `React.Component` and call a `render` method that returns an HTML
    element. Classes are stateful and were the only way to manage state in React before
    the React team came up with Hooks. More on Hooks later, in [*Chapter 3*](B18554_03.xhtml#_idTextAnchor064),
    *Managing State with React Hooks*. Let’s look at the class code syntax for writing
    minimal React class components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了使用函数或类来构建 UI 组件的灵活性。类组件是扩展 `React.Component` 的 JavaScript 类，并调用返回 HTML
    元素的 `render` 方法。类是有状态的，在 React 团队提出 Hooks 之前，这是 React 中管理状态的唯一方式。关于 Hooks 的更多内容将在[*第
    3 章*](B18554_03.xhtml#_idTextAnchor064) *使用 React Hooks 管理状态*中讨论。让我们看看编写最小化 React
    类组件的类代码语法。
- en: 'Create a `SpeakerProfile.js` file in `src/` and type in the following code
    in `src/SpeakerProfile.js`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/` 中创建一个 `SpeakerProfile.js` 文件，并在 `src/SpeakerProfile.js` 中输入以下代码：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s dive into each line of code to understand what they do:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析代码以了解它们的功能：
- en: '`import React from ''react''`: This allows us to use the core functions of
    React in our code file'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import React from ''react''`：这允许我们在代码文件中使用 React 的核心功能'
- en: '`class SpeakerProfile extends React.Component { }`: This allows us to create
    the `SpeakerProfile` class component that inherits from the `React.Component`
    base class'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class SpeakerProfile extends React.Component { }`：这允许我们创建继承自 `React.Component`
    基类 `SpeakerProfile` 类组件'
- en: '`render() { return <h1>...</h1>;` `}`: Every class component must have a `render`
    function that returns an HTML element'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render() { return <h1>...</h1>;}`：每个类组件都必须有一个返回HTML元素的`render`函数'
- en: The preceding code lines explain the basic structure of React class components.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行解释了React类组件的基本结构。
- en: 'In `src/App.js`, add the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/App.js`中添加以下内容：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If your `http://localhost:3000/` server is still running, you will see the
    following screen. If not, open your terminal and go to your working directory
    and type the `npm` `start` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的`http://localhost:3000/`服务器仍在运行，你将看到以下屏幕。如果没有，请打开你的终端并转到你的工作目录，然后输入`npm
    start`命令：
- en: '![Figure 2.8 – Screenshot showing output for class component](img/Figure_2.8_B18554.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 展示类组件输出的截图](img/Figure_2.8_B18554.jpg)'
- en: Figure 2.8 – Screenshot showing output for class component
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 展示类组件输出的截图
- en: Note
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `<SpeakerProfile` `/>` component was added to `src/App.js` for rendering
    the content of the `SpeakerProfile` component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`<SpeakerProfile` `/>`组件被添加到`src/App.js`中，用于渲染`SpeakerProfile`组件的内容。'
- en: 'Let’s compare the function component equivalent to the class component we wrote
    in `src/SpeakerProfile.js`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下我们在`src/SpeakerProfile.js`中编写的类组件的函数组件等价物：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, you can see that the function components take fewer lines of code – meaning
    they can be elegant, concise, and readable. When using function components, you
    don’t need to define a `render()` method, and the component itself is the function
    that returns JSX, making the code simpler and easier to read.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到函数组件的代码行数更少——这意味着它们可以更加优雅、简洁和易于阅读。当使用函数组件时，你不需要定义一个`render()`方法，组件本身就是一个返回JSX的函数，这使得代码更加简单和易于阅读。
- en: Let’s briefly discuss the subtle differences in class and function components.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下类组件和函数组件之间的细微差别。
- en: Class component versus function component
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类组件与函数组件
- en: When creating a class component, you must inherit it from `React.Component`
    with the `extend` keyword and create a `render` method that is responsible for
    returning a React element. In the function component, there is no `render` function.
    It accepts `props` as an argument and returns HTML elements.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类组件时，你必须使用`extend`关键字从`React.Component`继承，并创建一个负责返回React元素的`render`方法。在函数组件中，没有`render`函数。它接受`props`作为参数并返回HTML元素。
- en: Class components are stateful when compared to function components, which are
    stateless. The only way you could make a function component stateful was to rewrite
    the code as a class component before Hooks came to its rescue with React version
    16.8\. Now, with Hooks, function components can be stateful.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与无状态的函数组件相比，类组件是有状态的。在Hooks出现之前，使函数组件有状态的唯一方法是将其重写为类组件。现在，随着React 16.8版本的推出，Hooks的出现使得函数组件也可以有状态。
- en: In class components, you can utilize React life cycle methods such as `componentDidMount()`,
    `componentDidUpdate()`, and `componentWillUnmount()`. However, in React function
    components, you cannot use these life cycle methods.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件中，你可以利用React的生命周期方法，如`componentDidMount()`、`componentDidUpdate()`和`componentWillUnmount()`。然而，在React函数组件中，你不能使用这些生命周期方法。
- en: In summary, we discussed class components in React and how to write and display
    the content of your class component. Next, we will be discussing the component
    life cycle to better design reusable and maintainable React components.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们讨论了React中的类组件以及如何编写和显示类组件的内容。接下来，我们将讨论组件生命周期，以便更好地设计可重用和可维护的React组件。
- en: Component life cycle
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: So far, we have seen the component-oriented nature of every React application.
    Components interact with components to provide an interface for user interaction
    in web applications. However, a component – the building block of every UI we
    interact with – has a life cycle.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了每个React应用程序的组件化特性。组件之间相互交互，为Web应用程序提供用户交互的界面。然而，组件——我们与之交互的每个UI的构建块——也有生命周期。
- en: 'As in life, there are different phases involved; we are born, then we grow,
    and then we die. React components experience phases as well. They undergo three
    phases: mounting, updating, and unmounting. Each of these phases will be discussed
    briefly.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生活一样，涉及不同的阶段；我们出生，然后成长，然后死亡。React组件也会经历阶段。它们经历三个阶段：挂载、更新和卸载。每个阶段都将简要讨论。
- en: Mounting phase
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载阶段
- en: 'This represents the birth phase of a React component. This is the phase when
    a component instance is created and inserted into the DOM. There are four methods
    present in this phase, which are listed as follows in their order:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了 React 组件的出生阶段。这是组件实例被创建并插入到 DOM 中的阶段。在这个阶段有四个方法，按照顺序如下列出：
- en: '`constructor()`: This method is called during the mounting phase and actually
    before the component is mounted. Calling the `constructor()` method accepts `props`
    as arguments. This is followed by calling `super(props)` as well. The `constructor()`
    method, however, serves two main purposes:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`constructor()`: 这个方法在挂载阶段被调用，实际上是在组件挂载之前。调用 `constructor()` 方法接受 `props` 作为参数。这之后会调用
    `super(props)`。然而，`constructor()` 方法有两个主要目的：'
- en: Initializes a local state in the class component by assigning an object to `this.state`
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将对象赋值给 `this.state` 在类组件中初始化本地状态
- en: Binds event handler methods
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定事件处理方法
- en: '`static getDerivedStateFromProps()`: This method is invoked immediately before
    rendering the elements in the DOM.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static getDerivedStateFromProps()`: 这个方法在渲染 DOM 中的元素之前立即被调用。'
- en: '`render()`: This method is the most vital and it is always required for outputting
    React HTML elements. It normally injects HTML into the DOM. What you see on your
    interface depends on what this `render` method returns in the form of JSX.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render()`: 这个方法是最重要的，它总是需要用于输出 React HTML 元素。它通常将 HTML 注入到 DOM 中。你界面上看到的内容取决于这个
    `render` 方法以 JSX 形式返回的内容。'
- en: '`componentDidMount()`: This method is initiated after the React component is
    rendered into the DOM tree, essentially after the first `render()` invocation.
    The `componentDidMount()` method allows you to execute user actions and other
    side effects once components are mounted. For instance, the `componentDidMount()`
    method can run statements that require the loading of data from external sources.
    Also, you can trigger a user or system event when components had been rendered.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`componentDidMount()`: 这个方法在 React 组件渲染到 DOM 树后启动，基本上是在第一次 `render()` 调用之后。`componentDidMount()`
    方法允许你在组件挂载后执行用户操作和其他副作用。例如，`componentDidMount()` 方法可以运行需要从外部源加载数据的语句。此外，当组件渲染后，你可以触发用户或系统事件。'
- en: Updating phase
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新阶段
- en: This is the hypothetical growing phase of the React component. This phase occurs
    immediately after the mounting phase of the component life cycle. The `componentDidUpdate()`
    method is commonly used in this phase. A React component is updated whenever there
    is a change in data state or props. The state is re-rendered using the `render()`
    method, and the updated state is returned to the UI.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 React 组件的假设成长阶段。这个阶段发生在组件生命周期挂载阶段之后。在这个阶段通常使用 `componentDidUpdate()` 方法。每当数据状态或属性发生变化时，React
    组件都会被更新。使用 `render()` 方法重新渲染状态，并将更新的状态返回到 UI。
- en: Unmounting phase
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卸载阶段
- en: This phase is regarded as the death phase of the component life cycle process.
    The `componentWillUnmount()` method is invoked in this phase immediately before
    the component is unmounted from the DOM tree.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段被认为是组件生命周期过程的死亡阶段。在组件从 DOM 树卸载之前，立即调用 `componentWillUnmount()` 方法。
- en: Typically, web applications have many user interfaces, such as buttons, form
    input, accordions tabs, and even a navigation bar in our application. Users tend
    to move from one component interaction to another and, on the whole, have a reactive
    experience.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web 应用程序有许多用户界面，例如按钮、表单输入、手风琴标签页，甚至在我们的应用程序中还有导航栏。用户倾向于从一个组件交互移动到另一个组件，总体上有一个反应性的体验。
- en: So, when users stop interacting with a component – say by moving on from a *contact*
    component to an *accordion tab* on the home page of our application – that switch
    from the *contact* page to an *accordion tab* on the home page spells the death
    of the life cycle to the *contact* page component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户停止与组件交互时——比如说，从我们的应用程序主页上的 *联系* 组件移动到 *手风琴标签页*——从 *联系* 页面切换到主页上的 *手风琴标签页*
    意味着 *联系* 页面组件生命周期的结束。
- en: At every point in the user interaction cycle, the React components are either
    inserted into the DOM tree or state changes, or the completion of component’s
    lifecycle.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户交互周期的每一个点上，React 组件要么被插入到 DOM 树中，要么是状态变化，或者是组件生命周期的完成。
- en: 'The following figure shows the React life cycle methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 React 生命周期方法：
- en: '![Figure 2.9 – React life cycle methods (source: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)](img/Figure_2.09_B18554.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – React生命周期方法（来源：https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/）](img/Figure_2.09_B18554.jpg)'
- en: 'Figure 2.9 – React life cycle methods (source: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – React生命周期方法（来源：https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/）
- en: In summary, we have briefly discussed various life cycle methods in React class
    components and why each of them exists in rendering React components. Later in
    the book, we’ll explore how the life cycle is handled in a function component.
    Meanwhile, we will be discussing **properties** (**props**) in React. Props are
    one of the key features that allow React components to communicate with other
    components, making React applications so reusable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们简要讨论了React类组件中的各种生命周期方法以及它们在渲染React组件中存在的原因。在本书的后面，我们将探讨函数组件中如何处理生命周期。同时，我们将讨论**属性**（**props**）。Props是允许React组件与其他组件通信的关键特性之一，使得React应用如此可重用。
- en: What are props?
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: props是什么？
- en: '**Props** are arguments passed to React functions and class components. If
    that is too techy, let’s break it down a bit. Basically, you use props to pass
    data from one component to another component. So, props refer to objects that
    store the value of attributes. This is similar to HTML when you pass a value to
    an attribute of a tag.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Props**是传递给React函数和类组件的参数。如果这听起来太技术化，让我们稍微解释一下。基本上，你使用props从一个组件传递数据到另一个组件。所以，props指的是存储属性值的对象。这类似于HTML，当你将值传递给标签的属性时。'
- en: In the React world, props are used to customize and configure components and
    are passed from parent to child down the component tree. This means the parent
    component can only pass information to the child component. This is a unidirectional
    data flow concept in React. In essence, props are read-only, meaning that the
    component receiving them cannot modify their values directly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在React的世界里，props用于自定义和配置组件，并且从父组件传递到子组件，沿着组件树向下传递。这意味着父组件只能将信息传递给子组件。这是React中单向数据流的概念。本质上，props是只读的，这意味着接收它们的组件不能直接修改它们的值。
- en: Passing data as props
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据作为props传递
- en: Let’s take a look at an example where props are used in React components. As
    we have discussed, props are used in React to pass information from one component
    to another. In the following snippet, we will explain how data is passed as props
    in React.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个props在React组件中使用的例子。正如我们讨论过的，props在React中用于从一个组件传递信息到另一个组件。在下面的片段中，我们将解释如何在React中将数据作为props传递。
- en: 'In `src/App.js`, add the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/App.js`中添加以下内容：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we added a child component, `<SpeakerProfile />`, into
    the parent function component, `App.js`, and have some props passed to the `<``SpeakerProfile/>`
    component.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们向父函数组件`App.js`中添加了一个子组件`<SpeakerProfile />`，并将一些props传递给了`<SpeakerProfile/>`组件。
- en: 'Now, let’s dive into the internal structure of the `SpeakerProfile` snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解`SpeakerProfile`片段的内部结构：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`SpeakerProfile` is a child component. We define a `SpeakerProfile` function
    and pass data props to it in the parent component. In the `SpeakerProfile` component
    body, we return HTML elements, `<h3>{props.name}</h3>`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpeakerProfile`是一个子组件。我们在父组件中定义一个`SpeakerProfile`函数，并将数据props传递给它。在`SpeakerProfile`组件体中，我们返回HTML元素，`<h3>{props.name}</h3>`。'
- en: 'We then pass attribute values to these properties (props) from the `App` parent
    component to the `SpeakerProfile` child component:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将属性值传递给这些属性（props），从`App`父组件传递到`SpeakerProfile`子组件：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following shows the screen output for the props passed to the `SpeakerProfile`
    component:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕输出显示了传递给`SpeakerProfile`组件的props：
- en: '![Figure 2.10 – Screenshot showing props in a component](img/Figure_2.10_B18554.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 展示组件中props的屏幕截图](img/Figure_2.10_B18554.jpg)'
- en: Figure 2.10 – Screenshot showing props in a component
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 展示组件中props的屏幕截图
- en: 'In summary, we learned how to pass information from one component to another
    component in a function component. The flow of information from the parent component
    to the child component is expected to be unidirectional as a rule in React: from
    parent to child component.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们学习了如何在函数组件中从一个组件传递信息到另一个组件。在React中，从父组件到子组件的信息流按照规则应该是单向的：从父组件到子组件。
- en: Props are read-only. Child components cannot mutate directly. Later in the chapter,
    we’ll discuss how this rule can be overridden by passing props from the child
    to the parent component.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是只读的。子组件不能直接修改。在本章的后面部分，我们将讨论如何通过从子组件传递属性到父组件来覆盖此规则。
- en: Now, we will discuss state in React as a way to make React components dynamic
    and interactive.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论 React 中的状态，作为使 React 组件动态和交互式的一种方式。
- en: React state
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 状态
- en: '**State** is a built-in object in React that is used to hold information about
    components. It is what is responsible for the interactivity of components. In
    the React application, state changes. When there is a change in the component
    state, React re-renders the component.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态** 是 React 中的一个内置对象，用于存储有关组件的信息。它是组件交互性的责任所在。在 React 应用程序中，状态会发生变化。当组件状态发生变化时，React
    会重新渲染组件。'
- en: This change also impacts how the component behaves and renders on the screen.
    There are factors that can make the state change – for instance, a response to
    a user’s action or system-generated events. Props and state are twin features
    of React. While props essentially pass information from a parent component to
    a child component, state alters components’ internal data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化也影响了组件在屏幕上的行为和渲染方式。有一些因素可以导致状态变化 – 例如，对用户操作的响应或系统生成的事件。属性和状态是 React 的双胞胎特性。虽然属性本质上是从父组件传递信息到子组件，但状态改变组件的内部数据。
- en: Let’s take a look at a search use case for the implementation of state in components.
    Anytime a user types something into an HTML search input field, the user intends
    to see this typed information, which represents a new state, displayed somewhere
    else in the application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看组件中状态实现的搜索用例。任何时候用户在 HTML 搜索输入字段中输入某些内容，用户都希望看到这些输入的信息，这代表了一种新的状态，在应用程序的其他地方显示。
- en: The default state is the blank search input field. Hence, we need a way to change
    information in the input field and notify React to re-render its component. This
    means displaying the new state of the component.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 默认状态是空白的搜索输入字段。因此，我们需要一种方法来更改输入字段中的信息并通知 React 重新渲染其组件。这意味着显示组件的新状态。
- en: 'Let’s add a new component named `SearchSpeaker.js` to `src/SearchSpeaker/`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `src/SearchSpeaker/` 目录下添加一个名为 `SearchSpeaker.js` 的新组件：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code snippet, the `SearchSpeaker` component has two variables:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`SearchSpeaker` 组件有两个变量：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `searchText` and `setSearchText` variables manage how the `searchSpeaker`
    component updates its state upon changes in state. This line of code is an example
    of the array destructuring we discussed earlier, where we assign the values returned
    by the `useState` hook to two variables in a single line. In [*Chapter 3*](B18554_03.xhtml#_idTextAnchor064),
    *Managing State with React Hooks*, we will discuss `useState` extensively.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchText` 和 `setSearchText` 变量管理 `searchSpeaker` 组件在状态变化时如何更新其状态。此行代码是我们之前讨论过的数组解构的例子，其中我们将
    `useState` 钩子返回的值分配给两个变量一行。在 [*第 3 章*](B18554_03.xhtml#_idTextAnchor064)，*使用 React
    Hooks 管理状态*，我们将详细讨论 `useState`。'
- en: The `searchText` variable is used to set the current state and tells React to
    re-render its `searchSpeaker` component whenever the event handler notifies a
    change in state with the new value or state set by `setSearchText`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchText` 变量用于设置当前状态，并告诉 React 在事件处理程序通知状态发生更改并带有新值或由 `setSearchText` 设置的状态时重新渲染其
    `searchSpeaker` 组件。'
- en: 'In React, `useState` is a utility function that takes an initial state as an
    argument. In this case, the initial state is empty: `useState('''')`. The empty
    string initial state notifies React that the state will change over time. Therefore,
    `useState` comprises a two-entry array. The first entry, `searchText`, represents
    the current state; the second entry is a function to change the state using `setSearchText`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，`useState` 是一个接受初始状态作为参数的实用函数。在这种情况下，初始状态是空的：`useState('')`。空的初始状态通知
    React 状态将随时间变化。因此，`useState` 包含一个两元素数组。第一个元素 `searchText` 代表当前状态；第二个元素是一个函数，用于使用
    `setSearchText` 来更改状态。
- en: These are the mechanisms we use to display the current state or change the state
    inside a React component.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们用来在 React 组件内部显示当前状态或更改状态的机制。
- en: 'In `App.js`, add the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.js` 中添加以下代码：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following screenshot shows how the state changes in a React component:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 React 组件中状态的变化：
- en: '![Figure 2.11 – Screenshot showing the onChange state of the form field](img/Figure_2.12_B18554.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 展示表单字段 onChange 状态的截图](img/Figure_2.12_B18554.jpg)'
- en: Figure 2.11 – Screenshot showing the onChange state of the form field
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 展示表单字段onChange状态的截图
- en: With the understanding of state as an object used by React components to hold
    and manage data that can change over time, developers can create interactive and
    dynamic UIs that respond to user actions, and also provide a better user experience.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解状态作为React组件用来持有和管理随时间变化的数据的对象，开发者可以创建交互式和动态的用户界面，这些界面能够响应用户操作，并提供更好的用户体验。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed some of the core concepts in React applications.
    We started with the basic anatomy of a React project structure as generated by
    the Create React App tool. Some of the purposes of the files and folders were
    explained. We discussed some of the ES6 features, such as using arrow functions,
    destructuring, and default and named exports.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了React应用程序中的某些核心概念。我们从Create React App工具生成的React项目结构的基本结构开始。解释了文件和文件夹的一些用途。我们讨论了一些ES6特性，例如使用箭头函数、解构和默认及命名导出。
- en: 'We also defined components as a core building block of any React application.
    Two types of components were discussed: `class` and `function` components. In
    addition, we discussed props and how to pass information in props. The unidirectional
    information flow in React was clarified. Finally, we discussed state as a way
    React manages the internal data.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了组件作为任何React应用程序的核心构建块。讨论了两种类型的组件：`类`组件和`函数`组件。此外，我们讨论了props以及如何在props中传递信息。在React中明确了单向信息流。最后，我们讨论了状态作为React管理内部数据的方式。
- en: In the next chapter, we’ll dive deeper into React application development by
    discussing some of the hooks available in React. This will expose us to some of
    the advanced topics in React.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过讨论React中可用的一些hooks来深入探讨React应用程序的开发。这将使我们接触到React的一些高级主题。
