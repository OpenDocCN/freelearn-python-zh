- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have laid a solid foundation for understanding full stack web development
    using modern software stacks. Hopefully, you have already set up a React development
    environment on your local machine. If not, you can go back to [*Chapter 1*](B18554_01.xhtml#_idTextAnchor014),
    *Getting Full Stack Ready with React and Flask*, and revisit the *Setting up a
    development environment with* *React* section.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll systematically start to introduce you to the world of
    React in a subtle way. You will learn a bunch of cool concepts and techniques
    that will help you develop intuitive user interfaces that enable users to interact
    with your web application. You will learn how to spring up your first React project
    without the hassle of a complex configuration and understand the basic directory
    structure required for every React project. Then, you’ll learn how to use ES6
    features in React.
  prefs: []
  type: TYPE_NORMAL
- en: '**Components** are the building blocks of any React application. In this chapter,
    you will understand concepts around components and how you can use them to build
    user interfaces in React. This knowledge is vital for building modern frontend
    technologies in your project. With detailed use cases, you will understand the
    use of props in React for passing information between components, and how states
    add interactivity to React applications.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have acquired, in a practical way, the
    skill sets required to get started with any React project. You will also have
    a deeper understanding of React core features (components, props, and state) to
    develop interactivity in any web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a React project directory structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what destructuring is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default and named exports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a React component?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are props?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a React project directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a moment, we’ll set up a React application project. There are many ways to
    create a React application. You could use the **Create React App** tool to generate
    a boilerplate application with no build configurations. This doesn’t require you
    to have complex configuration knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: You can simply focus on the implementation of your application straight up.
    This is what we’ll be using in this book. And if you are open to exploring **Vite**
    ([https://vitejs.dev/](https://vitejs.dev/)), it is another next-generation frontend
    tooling for rapid React application setup.
  prefs: []
  type: TYPE_NORMAL
- en: The other way of creating a React application requires knowledge of Webpack
    and Babel configurations. Now, without further delay, let’s dive into creating
    our React project application. You are expected to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your terminal and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Screenshot of the create -react-app command](img/Figure_2.1_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Screenshot of the create -react-app command
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate into the `frontend` folder after the setup has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can open the application using `code .` on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.2 – Screenshot of \uFEFFcreate-react-app showing code \uFEFFto open\
    \ the VS Code editor \uFEFFin the project root directory](img/Figure_2.2_B18554.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Screenshot of create-react-app showing code to open the VS Code
    editor in the project root directory
  prefs: []
  type: TYPE_NORMAL
- en: 'The following extracted folders and files structure will appear in the VS Code
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the screenshot of the VS Code project directory
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Screenshot showing the project directory structure](img/Figure_2.3_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Screenshot showing the project directory structure
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s quickly dive into the preceding file and folder list to understand
    their individual purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules/`: This folder holds all node packages installed with the Create
    React App tool. All the `dependencies` and `devdependencies` are stored inside.
    It is good to note that all subsequent packages we’ll install in the future will
    also be kept in this folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public/`: This folder contains important public files such as `public/index.html`
    and `public/manifest.json`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index` file displays on `localhost:3000` when the app is in the development
    environment or on a hosted domain. Essentially, this file puts React components’
    execution results in the `index` file’s root `div` container for public view.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The folder also contains the `manifest.json` file, which contains application
    metadata and details for responsive screen display.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/`: This is the most vital folder in React application development. More
    than 80% of your coding activities’ time will be spent here. So, it is important
    to know exactly what you are doing inside this folder. This folder contains components
    and a few other files, such as `src/App.js`, `src/App.css`, `src/index.css`, `src/App.test.js`,
    and `src/index.js`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `src/App.js` file is used to implement React components. If you are working
    on a small project, you can use it to implement your application without creating
    other component files. All your component code will be put inside a single file.
    As your application grows, you might consider splitting up your components into
    multiple component files. With this split up, each file will then maintain one
    or more components.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `src/App.css` file is used to style your component. The same goes for the
    `src/index.css` file, which is used to style your overall application. Both these
    files can be edited to suit your style requirements.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `src/App.test.js` file is used to write unit tests for React applications.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index.js` file is the entry point to your React application.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.gitignore`: This file contains lists of files and folders that shouldn’t
    be tracked and added to the Git repository in your project. For instance, `node_modules`
    is always listed in the file as it is only needed in the development environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json`: This file contains node package dependencies and other metadata
    used in the project. This makes it easy to set up the same on another computer
    system using **Node Package Manager** (**npm**) without much hassle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package-lock.json`: This file stores the version number of your installed
    packages from `npm`. This ensures consistency of package installation from `npm`
    to other developers’ local computer systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`: This is a Markdown file. `README.md` file helps developers to
    give instructions and essential information about their projects. On GitHub, you
    can use the `README.md` file to display information about the content contained
    in project repositories. The Create React App tool generates this file for us
    out of the box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you know some of the purposes of the folders and files structure of
    your React project, let’s run the `npm start` command in the terminal to see the
    default React application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Screenshot of the React app home page on localhost:3000](img/Figure_2.4_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Screenshot of the React app home page on localhost:3000
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows some of the messages such as success messages, available
    scripts, and how to start the development server after the installation of React:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm start`: Starts the development server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run build`: Bundles the app into static files for production'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm test`: Starts the test runner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, we have discussed how you can power up your React application with
    the create-react-app tool. You now know what each folder and file represents in
    detail. With this, you can be confident that you know how to set up a React application.
    Let’s start the next section by discussing arrow functions. Arrow functions are
    one of the features of **ECMAScript 2015** (**ES6**). They’re a nifty addition
    to JavaScript that makes writing functions a breeze!
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Arrow functions** provide a more concise and readable syntax for defining
    functions in JavaScript. Arrow functions have become a widely used feature in
    React development for obvious reasons: shorter syntax and implicit return. You
    will have a better understanding of what these mean in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In traditional JavaScript, you would have to define a regular function that
    adds two numbers together like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Not bad, right? But arrow functions can make this even simpler and more elegant.
    Check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty cool? The `function` keyword is replaced with a funky-looking arrow,
    `=>`, and you can omit the curly braces and the `return` statement if your function
    is just a one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, you define arrow functions by following this syntax rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for even shorter function definition with implicit return when the function
    body consists of a single expression, use this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Arrow functions are often used within React applications due to their concise
    syntax and benefits, especially when defining function components, handling event
    callbacks, and mapping arrays. We will see more arrow functions usage in the course
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s important to note that arrow functions are not a complete replacement
    for regular functions. They have some limitations, such as not having their own
    `this` context, which makes them unsuitable for certain use cases, such as defining
    object methods.
  prefs: []
  type: TYPE_NORMAL
- en: When used in defining the object method, arrow functions do not have their own
    context and would not properly access the name property within the object. Let’s
    use the following code example to illustrate it better.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s use an arrow function to define the object method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In summary, arrow functions are a fantastic feature in ES6, making your code
    cleaner and more pleasant to work with. They’re perfect for short functions and
    can make your life as a React developer a whole lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will take a look at another cool ES6 feature: **destructuring**. You
    will need the destructuring technique to be able to extract values from arrays
    or objects in a more concise and readable way.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what destructuring is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Destructuring** is simply a JavaScript expression that ensures you are able
    to extract multiple values from arrays or properties from objects into separate
    unique variables. Destructuring is one of the awesome JavaScript ES6 features
    used in React to manage data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 was a major milestone in the effort to improve standards in the JavaScript
    language. Destructuring takes extracting data from arrays and objects to a new
    concise level. Prior to ES6, you could declare and extract data from an array
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With destructuring, the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to skip `"John"` in the array and write out to the console the remaining
    items in the array, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, it is not only arrays that can be destructured; you can perform
    destructuring in objects as well. For instance, the following code shows how to
    destructure object properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how we were able to extract the values of properties in the preceding
    code snippet. It is even possible to destructure the nested `address` property
    in the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, what are the benefits of destructuring in React applications? Destructuring
    makes your code more compact and easier to understand. It allows you to extract
    specific properties from objects or elements from arrays directly, reducing the
    need for repetitive dot notation or array indexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, destructuring allows you to set default values for properties – for instance,
    take a look at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code can be useful when working with optional or potentially undefined
    data and default values are required. Destructuring is used in accessing `props`
    and `state` in components. Oh, you don’t know what `components`, `props`, and
    `state` are all about? Fret not, we will discuss these concepts in this chapter
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, destructuring allows programmers to access data, even complex nested
    data in arrays and objects, in an easy way. It substantially improves the quality
    of code readability and access. And if you want a shorter line of code in your
    React application, destructuring clearly helps. It helps to cut the amount of
    code used in an application.
  prefs: []
  type: TYPE_NORMAL
- en: The next cool concepts to understand in React application development are default
    and named exports. Let’s dive in and understand these React concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Default and named exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, ECMAScript 2015, also known as ES6, was a major milestone
    in the effort to improve standards in the JavaScript language. Among the new features
    added were modules and the ability to use `import` expressions. Modules allow
    us to better organize our code base into logical units. Basically, modules could
    be a function or related functions designed to perform specific tasks. They make
    code reusability across projects easier.
  prefs: []
  type: TYPE_NORMAL
- en: In React, we use a default export to make component functions, variables, classes,
    or objects available to other component files. Only one default export is allowed
    per file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following code makes it possible to import a file from the
    `Speaker` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code makes it possible to export the file to another component
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In a named export, you can have multiple named exports per file. And when you
    want to import, you can name the specific import with braces, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To sum up, default and named components are a way to make specific functions
    available across components in any React project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll delve into the core essence of React components and gain a clear
    understanding of their purpose and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: What is a React component?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **component** is the core building block of any React application. Sometimes,
    you could perceive React as a JavaScript coated with some chocolate. Chocolate
    is sweet I guess, and so is React. Seriously, building a UI with vanilla JavaScript
    can be cumbersome. You can struggle with the expensive DOM dilemma!
  prefs: []
  type: TYPE_NORMAL
- en: The thing is, when working with vanilla JavaScript to handle the **Document
    Object Model** (**DOM**), it can get pretty expensive – both in terms of time
    and effort. Frequent DOM manipulation is high in non-React applications, which
    ultimately results in the slowness of website elements update.
  prefs: []
  type: TYPE_NORMAL
- en: The **virtual DOM** solved this problem in React. The DOM only updates what
    was changed, not the entire DOM tree. However, if you remember how you use functions
    in plain JavaScript, writing components won’t be a challenge. A function in JavaScript
    is a code block designed essentially to perform certain tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to React components, which are reusable, maintainable, and
    self-contained blocks of code to return a UI. In React, components return HTML
    elements mixed with some JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of React components: **class components** and **function
    components**. In this book, we’ll adopt function component coding patterns to
    develop our React application.'
  prefs: []
  type: TYPE_NORMAL
- en: Function components are the present and future of React, so if you are just
    learning React, the function component is easier to learn without the extras involved
    in writing class components. And if you are already familiar with class components
    in React, you can still use function components along with class components. If
    you find yourself working with a legacy React code base, it’s definitely worth
    considering a gradual migration toward function components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us learn how to define a function component and use it in React applications
    by doing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `App.js` in the `src/` file of the React project directory. The `src/App.js`
    file contains the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s remove all the boilerplate code in the file to easily understand the
    code structure. Replace the preceding code snippet with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Your `src/App.js` file should now look like the preceding snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file, start your application with `npm start` in the command line,
    and you will get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Screenshot showing the output of the npm start command](img/Figure_2.5_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Screenshot showing the output of the npm start command
  prefs: []
  type: TYPE_NORMAL
- en: Check whether **Welcome to Bizza Platform** displays on your browser. If yes,
    you are still on the right track.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Screenshot of the React app home page on localhost:3000](img/Figure_2.6_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Screenshot of the React app home page on localhost:3000
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s dive deeper into each element of the code block to understand function
    components better.
  prefs: []
  type: TYPE_NORMAL
- en: Function components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated already, function components are conceptually a typical JavaScript
    function with the ability to receive data as props and return HTML elements in
    the form of JavaScript XML.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the `App` component doesn’t have any parameters yet in
    its function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you define an `App` component in a React application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The code returns the following HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `App` component returns HTML code. The returned HTML code is a mixture of
    HTML and JavaScript. This is called **JavaScript XML** (**JSX**). JSX is a syntax
    extension used in React that allows you to write HTML-like code directly within
    JavaScript. JSX makes it easier to describe the structure of user interfaces in
    React components. In [*Chapter 5*](B18554_05.xhtml#_idTextAnchor095), *JSX and
    Displaying Lists in React*, we’ll discuss JSX in depth.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed earlier, we’ll be focusing more on function components in this
    book. If you are comfortable writing functions in plain JavaScript, function components
    in React will definitely be familiar. In React function components, you are able
    to have implementation details between the function definition and the `return`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s check `App` component inside `src/App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Any variables defined in the function’s body will be re-defined each time this
    function runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Start your browser with `npm start` and check the updated content in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your server is still running, you do not need to use `npm start` again.
    Your app will recompile and display an updated view as soon as you save your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Screenshot showing the preceding snippet output](img/Figure_2.7_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Screenshot showing the preceding snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can have your variable defined outside the body of your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the function component, the results from the function operation can either
    be *run the first time* or *re-rendered on updates.* However, you can define your
    variable outside the function component if it doesn’t need anything from within
    the function component’s body; otherwise, consider defining it in the function
    component’s body.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we have been able to discuss function components in React and how
    to write and display the content of your function component. Next, we will discuss
    class components and why they are called **stateful components**.
  prefs: []
  type: TYPE_NORMAL
- en: Class components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React provides us with the flexibility to construct UI components using either
    functions or classes for the component code. Class components are JavaScript classes
    that extend `React.Component` and call a `render` method that returns an HTML
    element. Classes are stateful and were the only way to manage state in React before
    the React team came up with Hooks. More on Hooks later, in [*Chapter 3*](B18554_03.xhtml#_idTextAnchor064),
    *Managing State with React Hooks*. Let’s look at the class code syntax for writing
    minimal React class components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `SpeakerProfile.js` file in `src/` and type in the following code
    in `src/SpeakerProfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s dive into each line of code to understand what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import React from ''react''`: This allows us to use the core functions of
    React in our code file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class SpeakerProfile extends React.Component { }`: This allows us to create
    the `SpeakerProfile` class component that inherits from the `React.Component`
    base class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render() { return <h1>...</h1>;` `}`: Every class component must have a `render`
    function that returns an HTML element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding code lines explain the basic structure of React class components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/App.js`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If your `http://localhost:3000/` server is still running, you will see the
    following screen. If not, open your terminal and go to your working directory
    and type the `npm` `start` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Screenshot showing output for class component](img/Figure_2.8_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Screenshot showing output for class component
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `<SpeakerProfile` `/>` component was added to `src/App.js` for rendering
    the content of the `SpeakerProfile` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare the function component equivalent to the class component we wrote
    in `src/SpeakerProfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So, you can see that the function components take fewer lines of code – meaning
    they can be elegant, concise, and readable. When using function components, you
    don’t need to define a `render()` method, and the component itself is the function
    that returns JSX, making the code simpler and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly discuss the subtle differences in class and function components.
  prefs: []
  type: TYPE_NORMAL
- en: Class component versus function component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating a class component, you must inherit it from `React.Component`
    with the `extend` keyword and create a `render` method that is responsible for
    returning a React element. In the function component, there is no `render` function.
    It accepts `props` as an argument and returns HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: Class components are stateful when compared to function components, which are
    stateless. The only way you could make a function component stateful was to rewrite
    the code as a class component before Hooks came to its rescue with React version
    16.8\. Now, with Hooks, function components can be stateful.
  prefs: []
  type: TYPE_NORMAL
- en: In class components, you can utilize React life cycle methods such as `componentDidMount()`,
    `componentDidUpdate()`, and `componentWillUnmount()`. However, in React function
    components, you cannot use these life cycle methods.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we discussed class components in React and how to write and display
    the content of your class component. Next, we will be discussing the component
    life cycle to better design reusable and maintainable React components.
  prefs: []
  type: TYPE_NORMAL
- en: Component life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen the component-oriented nature of every React application.
    Components interact with components to provide an interface for user interaction
    in web applications. However, a component – the building block of every UI we
    interact with – has a life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in life, there are different phases involved; we are born, then we grow,
    and then we die. React components experience phases as well. They undergo three
    phases: mounting, updating, and unmounting. Each of these phases will be discussed
    briefly.'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This represents the birth phase of a React component. This is the phase when
    a component instance is created and inserted into the DOM. There are four methods
    present in this phase, which are listed as follows in their order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor()`: This method is called during the mounting phase and actually
    before the component is mounted. Calling the `constructor()` method accepts `props`
    as arguments. This is followed by calling `super(props)` as well. The `constructor()`
    method, however, serves two main purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializes a local state in the class component by assigning an object to `this.state`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Binds event handler methods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static getDerivedStateFromProps()`: This method is invoked immediately before
    rendering the elements in the DOM.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`render()`: This method is the most vital and it is always required for outputting
    React HTML elements. It normally injects HTML into the DOM. What you see on your
    interface depends on what this `render` method returns in the form of JSX.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentDidMount()`: This method is initiated after the React component is
    rendered into the DOM tree, essentially after the first `render()` invocation.
    The `componentDidMount()` method allows you to execute user actions and other
    side effects once components are mounted. For instance, the `componentDidMount()`
    method can run statements that require the loading of data from external sources.
    Also, you can trigger a user or system event when components had been rendered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the hypothetical growing phase of the React component. This phase occurs
    immediately after the mounting phase of the component life cycle. The `componentDidUpdate()`
    method is commonly used in this phase. A React component is updated whenever there
    is a change in data state or props. The state is re-rendered using the `render()`
    method, and the updated state is returned to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Unmounting phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This phase is regarded as the death phase of the component life cycle process.
    The `componentWillUnmount()` method is invoked in this phase immediately before
    the component is unmounted from the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, web applications have many user interfaces, such as buttons, form
    input, accordions tabs, and even a navigation bar in our application. Users tend
    to move from one component interaction to another and, on the whole, have a reactive
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: So, when users stop interacting with a component – say by moving on from a *contact*
    component to an *accordion tab* on the home page of our application – that switch
    from the *contact* page to an *accordion tab* on the home page spells the death
    of the life cycle to the *contact* page component.
  prefs: []
  type: TYPE_NORMAL
- en: At every point in the user interaction cycle, the React components are either
    inserted into the DOM tree or state changes, or the completion of component’s
    lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the React life cycle methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – React life cycle methods (source: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)](img/Figure_2.09_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9 – React life cycle methods (source: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we have briefly discussed various life cycle methods in React class
    components and why each of them exists in rendering React components. Later in
    the book, we’ll explore how the life cycle is handled in a function component.
    Meanwhile, we will be discussing **properties** (**props**) in React. Props are
    one of the key features that allow React components to communicate with other
    components, making React applications so reusable.
  prefs: []
  type: TYPE_NORMAL
- en: What are props?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Props** are arguments passed to React functions and class components. If
    that is too techy, let’s break it down a bit. Basically, you use props to pass
    data from one component to another component. So, props refer to objects that
    store the value of attributes. This is similar to HTML when you pass a value to
    an attribute of a tag.'
  prefs: []
  type: TYPE_NORMAL
- en: In the React world, props are used to customize and configure components and
    are passed from parent to child down the component tree. This means the parent
    component can only pass information to the child component. This is a unidirectional
    data flow concept in React. In essence, props are read-only, meaning that the
    component receiving them cannot modify their values directly.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data as props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a look at an example where props are used in React components. As
    we have discussed, props are used in React to pass information from one component
    to another. In the following snippet, we will explain how data is passed as props
    in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/App.js`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added a child component, `<SpeakerProfile />`, into
    the parent function component, `App.js`, and have some props passed to the `<``SpeakerProfile/>`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s dive into the internal structure of the `SpeakerProfile` snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`SpeakerProfile` is a child component. We define a `SpeakerProfile` function
    and pass data props to it in the parent component. In the `SpeakerProfile` component
    body, we return HTML elements, `<h3>{props.name}</h3>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then pass attribute values to these properties (props) from the `App` parent
    component to the `SpeakerProfile` child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the screen output for the props passed to the `SpeakerProfile`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Screenshot showing props in a component](img/Figure_2.10_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Screenshot showing props in a component
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, we learned how to pass information from one component to another
    component in a function component. The flow of information from the parent component
    to the child component is expected to be unidirectional as a rule in React: from
    parent to child component.'
  prefs: []
  type: TYPE_NORMAL
- en: Props are read-only. Child components cannot mutate directly. Later in the chapter,
    we’ll discuss how this rule can be overridden by passing props from the child
    to the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will discuss state in React as a way to make React components dynamic
    and interactive.
  prefs: []
  type: TYPE_NORMAL
- en: React state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**State** is a built-in object in React that is used to hold information about
    components. It is what is responsible for the interactivity of components. In
    the React application, state changes. When there is a change in the component
    state, React re-renders the component.'
  prefs: []
  type: TYPE_NORMAL
- en: This change also impacts how the component behaves and renders on the screen.
    There are factors that can make the state change – for instance, a response to
    a user’s action or system-generated events. Props and state are twin features
    of React. While props essentially pass information from a parent component to
    a child component, state alters components’ internal data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at a search use case for the implementation of state in components.
    Anytime a user types something into an HTML search input field, the user intends
    to see this typed information, which represents a new state, displayed somewhere
    else in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The default state is the blank search input field. Hence, we need a way to change
    information in the input field and notify React to re-render its component. This
    means displaying the new state of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a new component named `SearchSpeaker.js` to `src/SearchSpeaker/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the `SearchSpeaker` component has two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `searchText` and `setSearchText` variables manage how the `searchSpeaker`
    component updates its state upon changes in state. This line of code is an example
    of the array destructuring we discussed earlier, where we assign the values returned
    by the `useState` hook to two variables in a single line. In [*Chapter 3*](B18554_03.xhtml#_idTextAnchor064),
    *Managing State with React Hooks*, we will discuss `useState` extensively.
  prefs: []
  type: TYPE_NORMAL
- en: The `searchText` variable is used to set the current state and tells React to
    re-render its `searchSpeaker` component whenever the event handler notifies a
    change in state with the new value or state set by `setSearchText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, `useState` is a utility function that takes an initial state as an
    argument. In this case, the initial state is empty: `useState('''')`. The empty
    string initial state notifies React that the state will change over time. Therefore,
    `useState` comprises a two-entry array. The first entry, `searchText`, represents
    the current state; the second entry is a function to change the state using `setSearchText`.'
  prefs: []
  type: TYPE_NORMAL
- en: These are the mechanisms we use to display the current state or change the state
    inside a React component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `App.js`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how the state changes in a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Screenshot showing the onChange state of the form field](img/Figure_2.12_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Screenshot showing the onChange state of the form field
  prefs: []
  type: TYPE_NORMAL
- en: With the understanding of state as an object used by React components to hold
    and manage data that can change over time, developers can create interactive and
    dynamic UIs that respond to user actions, and also provide a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed some of the core concepts in React applications.
    We started with the basic anatomy of a React project structure as generated by
    the Create React App tool. Some of the purposes of the files and folders were
    explained. We discussed some of the ES6 features, such as using arrow functions,
    destructuring, and default and named exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also defined components as a core building block of any React application.
    Two types of components were discussed: `class` and `function` components. In
    addition, we discussed props and how to pass information in props. The unidirectional
    information flow in React was clarified. Finally, we discussed state as a way
    React manages the internal data.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll dive deeper into React application development by
    discussing some of the hooks available in React. This will expose us to some of
    the advanced topics in React.
  prefs: []
  type: TYPE_NORMAL
