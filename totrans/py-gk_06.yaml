- en: '*Chapter 4*: Python Libraries for Advanced Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have discussed different approaches to building modular
    and reusable programs in Python. In this chapter, we will investigate a few advanced
    concepts of the Python programming language such as iterators, generators, logging,
    and error handling. These concepts are important to write efficient and reusable
    code. For this chapter, we assume that you are familiar with the Python language
    syntax and know how to write control and loop structures.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how loops work in Python, how files are handled
    and what is the best practice to open and access files, and how to handle erroneous
    situations, which may be expected or unexpected. We will also investigate the
    logging support in Python and different ways of configuring the logging system.
    This chapter will also help you learn how to use the advanced libraries in Python
    for building complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Python data containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterators and generators for data processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling files in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors and exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Python `logging` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to build iterators and
    generators, how to handles errors and exceptions in your program, and how to implement
    logging for your Python project in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirement for this chapter is that you need to have installed
    Python 3.7 or later on your computer. Sample code for this chapter can be found
    at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by refreshing our knowledge about the data containers available
    in Python, which will be helpful for the follow-up topics in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Python data containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python supports several data types, both numeric as well as collections. Defining
    numeric data types such as integers and floating-point numbers is based on assigning
    a value to a variable. The value we assign to a variable determines the type of
    the numeric data type. Note that a specific constructor (for example, `int()`
    and `float()`) can also be used to create a variable of a specific data type.
    Container data types can also be defined either by assigning values in an appropriate
    format or by using a specific constructor for each collection data type. We will
    study five different container data types in this section: **strings**, **lists**,
    **t****uples**, **dictionaries**, and **sets**.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings are not directly a container data type. But it is important to discuss
    the string data type because of its wide use in Python programming and also the
    fact that the string data type is implemented using an **immutable sequence**
    of Unicode code points. The fact that it uses a sequence (a collection type) makes
    it a candidate to be discussed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: String objects are immutable objects in Python. With immutability, string objects
    provide a safe solution for concurrent programs where multiple functions may access
    the same string object and will get the same result back. This safety is not possible
    with mutable objects. Being immutable objects, string objects are popular to use
    as keys for the dictionary data type or as data elements for the set data type.
    The drawback of immutability is that a new instance needs to be created even if
    a small change is to be made to an existing string instance.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable versus immutable objects
  prefs: []
  type: TYPE_NORMAL
- en: A mutable object can be changed after its creation, but it is not possible to
    change an immutable object.
  prefs: []
  type: TYPE_NORMAL
- en: String literals can be enclosed by using matching single quotes (for example,
    *'blah'*), double quotes (for example, *"blah blah"*), or triple single or double
    quotes (for example, *"""none"""* or *'''none'''*). It is also worth mentioning
    that string objects are handled differently in Python 3 versus Python 2\. In Python
    3, string objects can hold only text sequences in the form of Unicode data points,
    but in Python 2 they can hold text as well as byte data. In Python 3, byte data
    is handled by the `bytes` data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Separating text from bytes in Python 3 makes it clean and efficient but at
    the cost of data portability. The Unicode text in strings cannot be saved to disk
    or sent to a remote location on the network without converting it into a binary
    format. This conversion requires encoding the string data into a byte sequence,
    which can be achieved in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UTF-8` being the default) and how to handle the errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bytes` data type by passing the string instance to the bytes constructor along
    with the encoding scheme and the error handling scheme.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The details of methods and the attributes available with any string object can
    be found in the official Python documentation as per the Python release.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list is one of the basic collection types in Python, which is used to store
    multiple objects using a single variable. Lists are dynamic and *mutable*, which
    means the objects in a list can be changed and the list can grow or shrink.
  prefs: []
  type: TYPE_NORMAL
- en: List objects in Python are not implemented using any linked list concept but
    using a variable-length array. The array contains references to objects it is
    storing. The pointer of this array and its length are stored in the list head
    structure, which is kept up to date as objects are added or deleted from a list.
    The behavior of such an array is made to appear like a list but in reality, it
    is not a real list. That is why some of the operations on a Python list are not
    optimized. For example, inserting a new object into a list and deleting objects
    from a list will have a complexity of *n*.
  prefs: []
  type: TYPE_NORMAL
- en: To rescue the situation, Python provides a `deque` data type in the `collections`
    built-in module. The `deque` data type provides the functionality of stacks and
    queues and is a good alternative option for cases when a linked list-like behavior
    is demanded by a problem statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists can be created empty or with an initial value using *square brackets*.
    Next, we present a code snippet that demonstrates how to create an empty or non-empty
    list object using only the square brackets or using the list object constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The details of the operations available with a list object, such as `add`, `insert`,
    `append`, and `delete` can be reviewed in the official Python documentation. We
    will introduce tuples in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is an immutable list, which means it cannot be modified after creation.
    Tuples are usually used for a small number of entries and when the position and
    sequence of the entries in a collection is important. To preserve the sequence
    of entries, tuples are designed as immutable, and this is where tuples differentiate
    themselves from lists. Operations on a tuple are typically faster than a regular
    list datatype. In cases when the values in a collection are required to be constant
    in a particular order, using tuples is the preferred option because of their superior
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples are normally initialized with values because they are immutable. A simple
    tuple can be created using parenthesis. A few ways to create tuple instances are
    shown in the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we created an empty tuple (`w`), a tuple with numbers
    (`x`), and a tuple with the text `Hello World`, which is `z`. The variable `y`
    is not a tuple since, for a 1-tuple (a single-object tuple), we need a trailing
    comma to indicate that it is a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: After introducing lists and tuples, we will briefly introduce dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dictionaries are one of the most used and versatile data types in Python. A
    dictionary is a collection that is used to store data values in the *key:value*
    format. Dictionaries are mutable and unordered data types. In other programming
    languages, they are referred to as *associative arrays* or *hashtables*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary can be created using *curly brackets* with a list of *key:value*
    pairs. The key is separated from its value by a colon *'':''* and the *key:value*
    pairs are separated by a comma *'',''*. A code snippet for a dictionary definition
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Duplicate keys are not allowed in a dictionary. A key must be an immutable object
    type such as a string, tuple, or number. The values in a dictionary can be of
    any data type, which even includes lists, sets, custom objects, and even another
    dictionary itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with dictionaries, three objects or lists are important:'
  prefs: []
  type: TYPE_NORMAL
- en: '`keys()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`values()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`items()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will discuss sets, which are also key data structures in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set is a *unique* collection of objects. A set is a mutable and unordered
    collection. There is no duplication of objects allowed in a set. Python uses a
    hashtable data structure to implement uniqueness in a set, which is the same approach
    used to ensure the uniqueness of keys in a dictionary. The behavior of sets in
    Python is very similar to sets in mathematics. This data type finds its application
    in situations where the order of objects is not important, but their uniqueness
    is. This helps to test whether a certain collection contains a certain object
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If the behavior of a set is required as an immutable data type, Python has a
    variant implementation of sets called `frozenset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new set object is possible using *curly brackets* or using the set
    constructor (`set()`). The next code snippet shows a few examples of creating
    a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Accessing set objects is not possible using an indexing approach. We need to
    pop one object from the set like a list or we can iterate on a set to get objects
    one by one. Like mathematical sets, sets in Python also support operations such
    as *union*, *intersection*, and *difference*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed the key concepts of strings and collection data
    types in Python 3, which are important to understand the upcoming topic – iterators
    and generators.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterators and generators for data processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iteration is one of the key tools used for data processing and data transformation.
    Iterations are especially useful when dealing with large datasets and when bringing
    the whole dataset into memory is not possible or efficient. Iterators provide
    a way to bring the data into memory one item at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators can be created by defining them with a separate class and implementing
    special methods such as `__iter__` and `__next__`. But there is also a new way
    to create iterators using the `yield` operation, known as generators. In the next
    subsections, we will study both iterators and generators.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterators are the objects that are used to iterate on other objects. An object
    on which an iterator can iterate is called `iterable` object class. This is not
    recommended but is technically possible and we will discuss with an example why
    this approach is not a good design approach. In the next code snippet, we provide
    a few examples of using the `for` loop for iteration purposes in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In these code examples, we used different `for` loops to iterate on a list,
    a string, a dictionary, and a file. All these data types are iterable and thus
    we will be using a simple syntax with the `for` loop to get through the items
    in these collections or sequences. Next, we will study what ingredients make an
    object iterable, which is also referred to as the **Iterator Protocol**.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Every collection in Python is *iterable* by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, an iterator object must implement two special methods: `__iter__`
    and `__next__`. To iterate on an object, the object has to implement at least
    the `__iter__` method. Once the object implements the `__iter__` method, we can
    call the object iterable. These methods are described next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__iter__`: This method returns the iterator object. This method is called
    at the start of a loop to get the iterator object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__next__`: This method is called at each iteration of the loop and it returns
    the next item in the iterable object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To explain how to build a custom object that is iterable, we will implement
    the `Week` class, which stores the numbers and names of all weekdays in a dictionary.
    This class will not be iterable by default. To make it iterable, we will add `__iter__`.
    To keep the example simple, we will also add the `__next__` method in the same
    class. Here is the code snippet with the `Week` class and the main program, which
    iterates to get the names of weekdays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We shared this code example just to demonstrate how the `__iter__` and `__next__`
    methods can be implemented in the same object class. This style of implementing
    an iterator is commonly found on the internet, but it is not a recommended approach
    and is considered a bad design. The reason is that when we use it in the `for`
    loop, we get back the main object as an iterator as we implemented `__iter__`
    and `__next__` in the same class. This can give unpredictable results. We can
    demonstrate this by executing the following code snippet for the same class, `Week`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this new main program, we are iterating on the same object using two different
    iterators. The results of this main program are not as expected. This is due to
    a common `_index` attribute shared by the two iterators. Here is a console output
    as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this new main program we deliberately did not use a `for` loop.
    We created two iterator objects for the same object of the `Week` class using
    the `iter` function. The `iter` function is a Python standard function that calls
    the `__iter__` method. To get the next item in the iterable object, we directly
    used the `__next__` method as well as the `next` function. The `next` function
    is also a general function, like the `iter` function. This approach of using an
    iterable as an iterator is also not considered thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best approach is always to use a separate iterator class and always create
    a new instance of an iterator through the `__iter__` method. Each iterator instance
    has to manage its own internal state. A revised version of the same code example
    of the `Week` class is shown next with a separate iterator class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this revised code example, we have a separate iterator class with the `__next__`
    method and it has its own `_index` attribute for managing the iterator state.
    The iterator instance will have a reference to the container object (dictionary).
    The console output of the revised example gives the results as expected: each
    iterator is iterating separately on the same instance of the `Week` class. The
    console output is shown next as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In short, to create an iterator, we need to implement the `__iter__` and `__next__`
    methods, manage internal state, and raise a `StopIteration` exception when there
    are no values available. Next, we will study generators, which will simplify the
    way we return iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A generator is a simple way of returning an iterator instance that can be used
    for iteration, which is achieved by implementing only a generator function. A
    generator function is similar to a normal function but with a `yield` statement
    instead of a `return` statement in it. The `return` statement is still allowed
    in a generator function but will not be used to return the next item in an iterable
    object.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, a function will be a generator function if it has at least one
    `yield` statement in it. The main difference when using the `yield` statement
    is that it pauses the function and saves its internal state, and when the function
    is called next time, it starts from the line it yielded the last time. This design
    pattern makes the iterator functionality simple and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, methods such as `__iter__` and `__next__` are implemented automatically
    and the `StopIteration` exception is also raised automatically. The local attributes
    and their values are preserved between the successive calls and there is no additional
    logic to be implemented by the developer. The Python interpreter provides all
    this functionality whenever it identifies a generator function (a function with
    a `yield` statement in it).
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how the generator works, we will start with a simple generator
    example that is used to generate a sequence of the first three letters of the
    alphabet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code example, we implemented a simple generator function using three
    `yield` statements without a `return` statement. In the main part of the program,
    we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We called the generator function, which returns us an iterator instance. At
    this stage, no line inside the `my_gen()` generator function is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the iterator instance, we called the `__next__` method, which starts the
    execution of the `my_gen()` function, pauses after executing the first `yield`
    statement, and returns `A`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we call the `next()` function on the iterator instance. The result is
    the same as we get with the `__next__` method. But this time, the `my_gen()` function
    starts the execution from the next line from where it paused the last time because
    of the `yield` statement. The next line is another `yield` statement, which results
    in another pause after returning the letter `B`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next `__next__` method will result in the execution of the next `yield`
    statement, which will return the letter `C`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will revisit the `Week` class and its iterator implementation and
    will use a generator instead of an iterator class. The sample code is presented
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In comparison to `iterator4.py`, the implementation of the `Week` class with
    a generator is way simpler and cleaner and we can achieve the same results. This
    is the power of generators and that is why they are very popular in Python. Before
    concluding this topic, it is important to highlight a few other key features of
    generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generator expressions**: Generator expressions can be used to create simple
    generators (also known as **anonymous functions**) on the fly without writing
    a special method. The syntax is similar to list comprehension except we use parentheses
    instead of square brackets. The next code example (an extension of the example
    we introduced for list comprehension) shows how a generator expression can be
    used to create a generator, its usage, and also a comparison with list comprehension:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Infinite streams**: Generators can also be used to implement an infinite
    stream of data. It is always a challenge to bring an infinite stream into memory,
    which is solved easily with generators as they return only one data item at a
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loops, but we will try to solve it using two generators: the `prime_gen`
    generator for generating prime numbers and the `x2_gen` generator for taking the
    square of the prime numbers fed to this generator by the `prime_gen` generator.
    We feed the two generators pipelined into the `sum` function to get the desired
    result. Here is the code snippet for this problem solution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generators operate on an on-demand basis, which makes them not only memory efficient
    but also provides a way to generate values when they are needed. This helps to
    avoid unnecessary data generation, which may not be used at all. Generators are
    well suited to be used for a large amount of data processing, for piping the data
    from one function to others, and to simulate concurrency as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will investigate how to handle files in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Handling files in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading data from a file or writing data to a file is one of the fundamental
    operations supported by any programming language. Python provides extensive support
    for handling file operations, which are mostly available in its standard library.
    In this section, we will discuss core file operations such as opening a file,
    closing a file, reading from a file, writing to a file, file management with context
    managers, and opening multiple files with one handle using the Python standard
    library. We will start our discussion with file operations in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: File operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'File operations typically start with opening a file and then reading or updating
    the contents in that file. The core file operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening and closing a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To apply any read or update operation to a file, we need a pointer or reference
    to the file. A file reference can be obtained by opening a file using the built-in
    `open` function. This function returns a reference to the `file` object, which
    is also known as a `open` function is the name of the file with an absolute or
    relative path. One optional parameter is the access mode to indicate in which
    mode a file is to be opened. The access mode can be `read`, `write`, `append`,
    or others. A full list of access mode options is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`: This option is for opening a file in read-only mode. This is a default
    option if the access mode option is not provided:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`a`: This option is for opening a file to append a new line at the end of the
    file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`w`: This option is for opening a file for writing. If a file does not exist,
    it will create a new file. If the file exists, this option will override it and
    any existing contents in that file will be destroyed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x`: This option is for opening a file for exclusive writing. If the file already
    exists, it will throw an error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`t`: This option is for opening a file in text mode. This is the default option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: This option is for opening a file in binary mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: This option is for opening a file for reading and writing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The mode options can be combined to get multiple options. In addition to the
    filename and the access mode options, we can also pass the encoding type, especially
    for text files. Here is an example of opening a file with `utf-8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When we complete our operations with a file, it is a must to close the file
    to free up the resources for other processes to use the file. A file can be closed
    by using the `close` method on the file instance or the file handle. Here is a
    code snippet showing the use of the `close` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once a file is closed, the resources associated with the file instance and locks
    (if any) will be released by the operating system, which is a best practice in
    any programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A file can be read by opening the file in access mode `r` and then using one
    of the read methods. Next, we summarize different methods available for read operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`read(n)`: This method reads `n` characters from a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readline()`: This method returns one line from a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readlines()`: This method returns all lines from a file as a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, we can append or write to a file once it is opened in an appropriate
    access mode. The methods that are relevant to appending a file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`write (x)`: This method writes a string or a sequence of bytes to a file and
    returns the number of characters added to the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writelines (lines)`: This method writes a list of lines to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next code example, we will create a new file, add a few text lines to
    it, and then read the text data using the read operations discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we write three lines to a file first. In the read operations,
    first, we read four characters, followed by reading two lines using the `readline`
    method. In the end, we move the pointer back to the top of the file using the
    `seek` method and access all lines in the file using the `readlines` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how the use of a context manager makes file
    handling convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Using a context manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Correct and fair usage of resources is critical in any programming language.
    A file handler and a database connection are a couple of many examples where it
    is a common practice to not release the resources on time after working with objects.
    If the resources are not released at all, then it will end up in a situation called
    **memory leakage** and may impact the system performance, and ultimately may result
    in the system crashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this memory leakage and timely resource release problem, Python came
    up with the concept of context managers. A context manager is designed to reserve
    and release resources precisely as per the design. When a context manager is used
    with the `with` keyword, a statement after the `with` keyword is expected to return
    an object that must implement the **context management protocol**. This protocol
    requires two special methods to be implemented by the returned object. These special
    methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.__enter__()`: This method is called with the `with` keyword and is used to
    reserve the resources required as per the statement after the `with` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.__exit__()`: This method is called after the execution of the `with` block
    and is used to release the resources that are reserved in the `.__enter__()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, when a file is opened using the context manager `with` statement
    (block), there is no need to close the file. The file `open` statement will return
    the file handler object, which has already implemented the context management
    protocol and the file will be closed automatically as soon the execution of the
    `with` block is completed. A revised version of the code example for writing and
    reading a file using the context manager is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code with the context manager is simple and easy to read. The use of a context
    manager is a recommended approach for opening and working with files.
  prefs: []
  type: TYPE_NORMAL
- en: Operating on multiple files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python supports opening and operating on multiple files at the same time. We
    can open these files in different modes and operate on them. There is no limit
    on the number of files. We can open two files in read mode by using the following
    sample code and access the files in any order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also read from one file and write to another file using this multifile
    operating option. Sample code to transfer contents from one file to another file
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Python also has a more elegant solution to operate on multiple files using
    the `fileinput` module. This module''s input function can take a list of multiple
    files and then treat all such files as a single input. Sample code with two input
    files, `1.txt` and `2.txt`, and using the `fileinput` module is presented next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, we get one file handle that operates on multiple files sequentially.
    Next, we will discuss error and exception handling in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors and exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many types of errors possible in Python. The most common one is related
    to the syntax of the program and is typically known as a **syntax error**. On
    many occasions, errors are reported during the execution of a program. Such errors
    are called **runtime errors**. The runtime errors that can be handled within our
    program are called **exceptions**. This section will focus on how to handle runtime
    errors or exceptions. Before jumping on to error handling, we will briefly introduce
    the most common runtime errors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IndexError`: This error occurs when a program tries to access an item at an
    invalid index (location in the memory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ModuleNotFoundError`: This error will be thrown when a specified module is
    not found at the system path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZeroDivisionError`: This error is thrown when a program tries to divide a
    number by zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyError`: This error occurs when a program tries to fetch a value from a
    dictionary using an invalid key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StopIteration`: This error is thrown when the `__next__` method does not find
    any further items in a container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypeError`: This error occurs when a program tries to apply an operation on
    an object of an inappropriate type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete list of errors is available in the official documentation of Python.
    In the following subsections, we will discuss how to handle errors, sometimes
    also called exceptions, using appropriate constructs in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Working with exceptions in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When runtime errors arise, the program can terminate abruptly and can cause
    damage to system resources such as corrupting files and database tables. This
    is why error or exception handling is one of the key ingredients of writing robust
    programs in any language. The idea is to anticipate that runtime errors can occur
    and if such an error occurs, what the behavior of our program would be as a response
    to that particular error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like many other languages, Python uses the `try` and `except` keywords. The
    two keywords are followed by separate blocks of code to be executed. The `try`
    block is a regular set of statements for which we anticipate that an error may
    occur. The `except` block will be executed only if there is an error in a `try`
    block. Next is the syntax of writing Python code with `try` and `except` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we anticipate a particular error type or multiple error types, we can define
    an `except` block with the error name and can add as many `except` blocks as we
    need. Such named `except` blocks are executed only if the named exception is raised
    in the `try` block. With the `except` block statement, we can also add an `as`
    statement to store the exception object as a variable that is raised during the
    `try` block. The `try` block in the next code example has many possible runtime
    errors and that is why it has multiple `except` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate a better use of an `except` block(s), we added multiple except
    blocks that are explained next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`try` block tries to access an undefined variable. In our code example, this
    block will be executed when the interpreter tries to execute the `print(x)` statement.
    Additionally, we named the exception object as `e` and used it with the `print`
    statement to get the official error detail associated with this error type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z = x/y` and y = 0\. For this block to be executed, we need to fix the `NameError`
    block first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`except` block, which means if no match is found with the previous two `except`
    blocks, this block will be executed. The last statement `print(''x''+ y)` will
    also raise an error of type `TypeError` and will be handled by this block. Since
    we are not receiving any one particular type of exception in this block, we can
    use the `Exception` keyword to store the exception object in a variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that as soon an error occurs in any statement in the `try` block, the rest
    of the statements are ignored, and the control goes to one of the `except` blocks.
    In our code example, we need to fix the `NameError` error first to see the next
    level of exception and so on. We added three different types of errors in our
    example to demonstrate how to define multiple `except` blocks for the same `try`
    block. The order of the `except` blocks is important because more specific `except`
    blocks with error names have to be defined first and an `except` block without
    specifying an error name has to always be at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows all the exception handling blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Different exception handling blocks in Python'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Different exception handling blocks in Python
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, in addition to `try` and `except` blocks,
    Python also supports `else` and `finally` blocks to enhance the error handling
    functionality. The `else` block is executed if no errors were raised during the
    `try` block. The code in this block will be executed as normal and no exception
    will be thrown if any error occurs within this block. Nested `try` and `except`
    blocks can be added within the `else` block if needed. Note that this block is
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: The `finally` block is executed regardless of whether there is an error in the
    `try` block or not. The code inside the `finally` block is executed without any
    exception handling mechanism. This block is mainly used to free up the resources
    by closing the connections or opened files. Although it is an optional block,
    it is highly recommended to implement this block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at the use of these blocks with a code example. In this
    example, we will open a new file for writing in the `try` block. If an error occurs
    in opening the file, an exception will be thrown, and we will send the error details
    to the console using the `print` statement in the `except` block. If no error
    occurs, we will execute the code in the `else` block that is writing some text
    to the file. In both cases (error or no error), we will close the file in the
    `finally` block. The complete sample code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have covered extensively how to handle an exception in Python. Next, we will
    discuss how to raise an exception from Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions or errors are raised by the Python interpreter at runtime when an
    error occurs. We can also raise errors or exceptions ourselves if a condition
    occurs that may give us bad output or crash the program if we proceed further.
    Raising an error or exception will provide a graceful exit of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'An exception (object) can be thrown to the caller by using the `raise` keyword.
    An exception can be of one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: A built-in exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A generic `Exception` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next code example, we will be calling a simple function to calculate
    a square root and will implement it to throw an exception if the input parameter
    is not a valid positive number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, we raised a built-in exception by creating a new instance
    of the `TypeError` class when the number passed to the `sqrt` function is not
    a number. We also raised a generic exception when the number passed is lower than
    `0`. In both cases, we passed our custom text to its constructor. In the next
    section, we will study how to define our own custom exception and then throw it
    to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, we can define our own custom exceptions by creating a new class
    that has to be derived from the built-in `Exception` class or its subclass. To
    illustrate the concept, we will revise our previous example by defining two custom
    exception classes to replace the built-in `TypeError` and the `Exception` error
    types. The new custom exception classes will be derived from the `TypeError` and
    the `Exception` classes. Here is sample code for reference with custom exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, the `NumTypeError` class is derived from the `TypeError`
    class and we have not added anything in this class. The `NegativeNumError` class
    is inherited from the `Exception` class and we override its constructor and add
    a custom message for this exception as part of the constructor. When we raise
    these custom exceptions in the `sqrt()` function, we do not pass any text with
    the `NegativeNumError` exception class. When we used the main program, we get
    the message with the `print (e)` statement as we have set it as part of the class
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered how to handle built-in error types using `try` and
    `except` blocks, how to define custom exceptions, and how to raise an exception
    declaratively. In the next section, we will cover logging in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Python logging module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logging is a fundamental requirement for any reasonably sized application.
    Logging not only helps in debugging and troubleshooting but also provides insight
    into details of an application''s internal issues. A few advantages of logging
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging code, especially to diagnose why and when an application failed or
    crashed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagnosing unusual application behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing auditing data for regulatory or legal compliance matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying users' behaviors and malicious attempts to access unauthorized resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before discussing any practical examples of logging, we will first discuss the
    key components of the logging system in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing core logging components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following components are fundamental to set up logging for an application
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Logger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging formatter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A high-level architecture of the Python logging system can be summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Logging components in Python'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Logging components in Python
  prefs: []
  type: TYPE_NORMAL
- en: Each of these components is discussed in detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: The logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The logger is the entry point to the Python logging system. It is the interface
    to the application programmer. The `Logger` class available in Python provides
    several methods to log messages with different priorities. We will study the `Logger`
    class methods with code examples later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: An application interacts with the `Logger` instance, which is set up using logging
    configuration such as the logging level. On receiving logging events, the `Logger`
    instance selects one or more appropriate logging handlers and delegates the events
    to the handlers. Each handler is typically designed for a specific output target.
    A handler sends the messages after applying a filter and formatting to the intended
    output target.
  prefs: []
  type: TYPE_NORMAL
- en: Logging levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All events and messages for a logging system are not of the same priority.
    For example, messages about errors are more urgent than warning messages. Logging
    levels are a way to set different priorities for different logging events. There
    are six levels defined in Python. Each level is associated with an integer value
    that indicates the severity. These levels are `NOTSET`, `DEBUG`, `INFO`, `WARNING`,
    `ERROR`, and `CRITICAL`. These are summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Logging levels in Python'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Logging levels in Python
  prefs: []
  type: TYPE_NORMAL
- en: The logging formatter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logging formatter component helps to improve the formatting of messages,
    which is important for consistency and for human and machine readability. The
    logging formatter also adds extra context to messages such as time, module name,
    line number, threads, and process, which is extremely useful for debugging purposes.
    An example formatter expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When such a formatter expression is used, the log message `hello Geeks` of
    level `INFO` will be displayed similar to the console output that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The logging handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The role of a logging handler is to write log data to an appropriate destination,
    which can be a console, a file, or even an email. There are many types of built-in
    logging handlers available in Python. A few popular handlers are introduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StreamHandler` for displaying the logs on a console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileHandler` for writing the logs to a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SMTPHandler` for sending the logs to an email'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SocketHandler` for sending the logs to a network socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SyslogHandler` for sending the logs to a local or remote *Unix* syslog server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTPHandler` for sending the logs to a web server using either `GET` or `POST`
    methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logging handler uses the logging formatter to add more context info to the
    logs and the logging level to filter the logging data.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the logging module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will discuss how to use the `logging` module with code examples.
    We will start with basic logging options and will take them to an advanced level
    in a gradual manner.
  prefs: []
  type: TYPE_NORMAL
- en: Using the default logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Without creating an instance of any logger class, there is already a default
    logger available in Python. The default logger, also known as the `logging` module
    and using its methods to dispatch logging events. The next code snippet shows
    the use of the root logger for capturing log events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `debug`, `warning`, and `info` methods are used to dispatch logging events
    to the logger as per their severity. The default log level for this logger is
    set to `WARNING` and the default output is set to `stderr`, which means all the
    messages will go to the console or terminal only. This setting will block `DEBUG`
    and `INFO` messages to be displayed on the console output, which will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The level of the root logger can be changed by adding the following line after
    the `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After changing the logging level to `DEBUG`, the console output will now show
    all the log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Although we discussed the default or root logger in this subsection, it is not
    recommended to use it other than for basic logging purposes. As a best practice,
    we should create a new logger with a name, which we will discuss in the next code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using a named logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create a separate logger with its own name and possibly with its own
    log level, handlers, and formatters. The next code snippet is an example of creating
    a logger with a custom name and also using a different logging level than the
    root logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When we create a logger instance using the `getLogger` method with a string
    name or using the module name (by using the `__name__` global variable), then
    only one instance is managed for one name. This means if we try to use the `getLogger`
    method with the same name in any part of the application, the Python interpreter
    will check whether there is already an instance created for this name. If there
    is already one created, it will return the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a logger instance, we need to make a call to the root logger
    (`basicConfig()`) to provide a handler and formatter to our logger. Without any
    handler configuration, we will get an internal handler as the last resort, which
    will only output messages without any formatting and the logging level will be
    `WARNING` regardless of the logging level we set for our logger. The console output
    of this code snippet is shown next, and it is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also important to note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We set the logging level for our logger to `INFO` and we were able to log `warning`
    and `info` messages but not the debug message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we used the root logger (by using the `logging` instance), we were not
    able to send out the `info` message. This was because the root logger was still
    using the default logging level, which is `WARNING`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a logger with a built-in handler and custom formatter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create a logger object using a built-in handler but with a custom formatter.
    In this case, the handler object can use a custom formatter object and the handler
    object can be added to the logger object as its handler before we start using
    the logger for any log events. Here is a code snippet to illustrate how to create
    a handler and a formatter programmatically and then add the handler to the logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a logger with the same settings by using the `basicConfig` method
    as well with appropriate arguments. The next code snippet is a revised version
    of `logging3.py` with the `basicConfig` settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Up till now, we have covered cases where we used built-in classes and objects
    to set up our loggers. Next, we will set up a logger with custom handlers and
    formatters.
  prefs: []
  type: TYPE_NORMAL
- en: Using a logger with a file handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logging handler sends the log messages to their final destination. By default,
    every logger is set up to send log messages to the console or terminal associated
    with the running program. But this can be changed by configuring a logger with
    a new handler with a different destination. A file handler can be created by using
    one of the two approaches we already discussed in the previous subsection. In
    this section, we will use a third approach to create a file handler automatically
    with the `basicConfig` method by providing the filename as an attribute to this
    method. This is shown in the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will generate log messages to the file we specified with the `basicConfig`
    method and as per the logging level, which is set to `INFO`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a logger with multiple handlers programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a logger with multiple handlers is pretty straightforward and can
    be achieved either by using the `basicConfig` method or by attaching handlers
    manually to a logger. For illustration purposes, we will revise our code example
    `logging3.py` to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We will create two handlers (one for the console output and one for the file
    output) that are instances of the `streamHandler` and `fileHandler` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will create two separate formatters, one for each handler. We will not include
    the time information for the formatter of the console handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will set separate logging levels for the two handlers. It is important to
    understand that the logging level at the handler level cannot override the root
    level handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the complete code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Although we set different logging levels for the two handlers, which are `INFO`
    and `DEBUG`, they will be effective only if the logging level of the logger is
    at a lower value (the default is `WARNING`). This is why we have to set the logging
    level for our logger to `DEBUG` at the beginning of the program. The logging level
    at the handler level can be `DEBUG` or any higher level. This is a very important
    point to consider whenever designing a logging strategy for your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the code example shared in this section, we basically configured the logger
    programmatically. In the next section, we will work on how to configure a logger
    through a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a logger with multiple handlers using a configuration file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting up a logger programmatically is appealing but not practical for production
    environments. In production environments, we have to set up the logger configuration
    differently as compared to the development setup and sometimes we have to enhance
    the logging level to troubleshoot problems that we encounter only in live environments.
    This is why we have the option of providing the logger configuration through a
    file that is easy to change as per the target environment. The configuration file
    for a logger can be written using `.conf` file. For illustration purposes, we
    will demonstrate the logger configuration using a YAML file, which is exactly
    the same as we achieved programmatically in the previous section. The complete
    YAML file and the Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the YAML config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the Python program using the YAML file to configure the logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To load config from a file, we used the `dictConfig` method instead of the `basicConfig`
    method. The outcome of the YAML-based logger configuration is exactly the same
    as we achieved with Python statements. There are other additional configuration
    options available for a full-featured logger.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we presented different scenarios of configuring one or more
    logger instances for an application. Next, we will discuss what type of events
    to log and what not to log.
  prefs: []
  type: TYPE_NORMAL
- en: What to log and what not to log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is always a debate about what information we should log and what not
    to log. As a best practice, the following information is important for logging:'
  prefs: []
  type: TYPE_NORMAL
- en: An application should log all errors and exceptions and the most appropriate
    way is to log these events at the source module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions that are handled with an alternative flow of code can be logged as
    warnings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For debugging purposes, entry and exit to a function is useful information for
    logging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also useful to log decision points in the code because it can be helpful
    for troubleshooting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The activities and actions of users, especially related to the access of certain
    resources and functions in the application, are important to log for security
    and auditing purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When logging messages, the context information is also important, which includes
    the time, logger name, module name, function name, line number, logging level,
    and so on. This information is critical for identifying the route cause analysis.
  prefs: []
  type: TYPE_NORMAL
- en: A follow-up discussion on this topic is what not to capture for logging. We
    should not log any sensitive information such as user ID, email address, passwords,
    and any private and sensitive data. We should also avoid logging any personal
    and business record data such as health records, government-issued document details,
    and organization details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed a variety of topics that require the use of advanced
    Python modules and libraries. We started by refreshing our knowledge about data
    containers in Python. Next, we learned how to use and build iterators for iterable
    objects. We also covered generators, which are more efficient and easier to build
    and use than iterators. We discussed how to open and read from files and how to
    write to files, followed by the use of a context manager with files. In the next
    topic, we discussed how to handle errors and exceptions in Python, how to raise
    exceptions through programming, and how to define custom exceptions. Exception
    handling is fundamental to any decent Python application. In the last section,
    we covered how to configure the logging framework in Python using different options
    for handlers and formatters.
  prefs: []
  type: TYPE_NORMAL
- en: After going through this chapter, you now know how to build your own iterators
    and design generator functions to iterate on any iterable object, and how to handle
    files, errors, and exceptions in Python. You have also learned how to set up loggers
    with one or more handlers to manage the logging of an application using different
    logging levels. The skills you have learned in this chapter are key to building
    any open source or commercial applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will switch our focus to how to build and automate unit
    tests and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a list and a tuple?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Python statement will always be used when working with a context manager?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the use of the `else` statement with the `try-except` block?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generators are better to use than iterators. Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the use of multiple handlers for logging?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Fluent Python* by Luciano Ramalho'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Advanced Guide to Python 3 Programming* by John Hunt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Python 3 Standard Library by Example* by Doug Hellmann'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python 3.7.10 documentation* ([https://docs.python.org/3.7/](https://docs.python.org/3.7/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about additional options available for configuring a logger, you
    can refer to the official Python documentation at [https://docs.python.org/3/library/logging.config.html](https://docs.python.org/3/library/logging.config.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A list is a mutable object whereas a tuple is immutable. This means we can update
    a list after creating it. This is not true for tuples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `with` statement is used with a context manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `else` block is executed only when the code in the `try` block is executed
    without any error. A follow-up action can be coded in the `else` block once the
    core functionality is executed without any problem in the `try` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generators are efficient in memory and also easy to program as compared to iterators.
    A generator function automatically provides an `iterator` instance and the `next`
    function implementation out of the box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The use of multiple handlers is common because one handler usually focuses on
    one type of destination. If we need to send log events to multiple destinations
    and perhaps with different priority levels, we will need multiple handlers. Also,
    if we need to log messages to multiple files with different logging levels, we
    can create different file handlers to coordinate with multiple files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
