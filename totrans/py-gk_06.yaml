- en: '*Chapter 4*: Python Libraries for Advanced Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：Python 高级编程库'
- en: In previous chapters, we have discussed different approaches to building modular
    and reusable programs in Python. In this chapter, we will investigate a few advanced
    concepts of the Python programming language such as iterators, generators, logging,
    and error handling. These concepts are important to write efficient and reusable
    code. For this chapter, we assume that you are familiar with the Python language
    syntax and know how to write control and loop structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了在 Python 中构建模块化和可重用程序的不同方法。在本章中，我们将探讨 Python 编程语言的几个高级概念，如迭代器、生成器、日志记录和错误处理。这些概念对于编写高效和可重用的代码非常重要。对于本章，我们假设您熟悉
    Python 语言语法，并且知道如何编写控制和循环结构。
- en: In this chapter, we will learn how loops work in Python, how files are handled
    and what is the best practice to open and access files, and how to handle erroneous
    situations, which may be expected or unexpected. We will also investigate the
    logging support in Python and different ways of configuring the logging system.
    This chapter will also help you learn how to use the advanced libraries in Python
    for building complex projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Python 中循环的工作原理，如何处理文件以及打开和访问文件的最佳实践，以及如何处理可能预期或意外的错误情况。我们还将研究 Python
    中的日志记录支持以及配置日志系统的不同方法。本章还将帮助您学习如何使用 Python 的高级库来构建复杂的项目。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing Python data containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Python 数据容器
- en: Using iterators and generators for data processing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器和生成器进行数据处理
- en: Handling files in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的文件处理
- en: Handling errors and exceptions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误和异常
- en: Using the Python `logging` module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 的 `logging` 模块
- en: By the end of this chapter, you will have learned how to build iterators and
    generators, how to handles errors and exceptions in your program, and how to implement
    logging for your Python project in an efficient way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会如何构建迭代器和生成器，如何处理程序中的错误和异常，以及如何以高效的方式为您的 Python 项目实现日志记录。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirement for this chapter is that you need to have installed
    Python 3.7 or later on your computer. Sample code for this chapter can be found
    at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求是您需要在您的计算机上安装 Python 3.7 或更高版本。本章的示例代码可以在[https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter04)找到。
- en: Let's begin by refreshing our knowledge about the data containers available
    in Python, which will be helpful for the follow-up topics in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾 Python 中可用的数据容器开始，这将有助于本章后续主题的学习。
- en: Introducing Python data containers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Python 数据容器
- en: 'Python supports several data types, both numeric as well as collections. Defining
    numeric data types such as integers and floating-point numbers is based on assigning
    a value to a variable. The value we assign to a variable determines the type of
    the numeric data type. Note that a specific constructor (for example, `int()`
    and `float()`) can also be used to create a variable of a specific data type.
    Container data types can also be defined either by assigning values in an appropriate
    format or by using a specific constructor for each collection data type. We will
    study five different container data types in this section: **strings**, **lists**,
    **t****uples**, **dictionaries**, and **sets**.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持多种数据类型，包括数值类型和集合。定义数值数据类型，如整数和浮点数，是基于给变量赋值。我们赋给变量的值决定了数值数据类型的类型。请注意，可以使用特定的构造函数（例如，`int()`
    和 `float()`）来创建特定数据类型的变量。容器数据类型也可以通过在适当格式中赋值或使用每个集合数据类型的特定构造函数来定义。在本节中，我们将研究五种不同的容器数据类型：**字符串**、**列表**、**元组**、**字典**和**集合**。
- en: Strings
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are not directly a container data type. But it is important to discuss
    the string data type because of its wide use in Python programming and also the
    fact that the string data type is implemented using an **immutable sequence**
    of Unicode code points. The fact that it uses a sequence (a collection type) makes
    it a candidate to be discussed in this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不是直接的数据容器类型。但讨论字符串数据类型很重要，因为它在 Python 编程中被广泛使用，并且字符串数据类型是用一个**不可变序列**（Unicode
    代码点序列）实现的。它使用序列（一种集合类型）的事实使其成为本节讨论的候选者。
- en: String objects are immutable objects in Python. With immutability, string objects
    provide a safe solution for concurrent programs where multiple functions may access
    the same string object and will get the same result back. This safety is not possible
    with mutable objects. Being immutable objects, string objects are popular to use
    as keys for the dictionary data type or as data elements for the set data type.
    The drawback of immutability is that a new instance needs to be created even if
    a small change is to be made to an existing string instance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，字符串对象是不可变对象。由于不可变性，字符串对象为并发程序提供了一个安全的解决方案，在这些程序中，多个函数可能访问相同的字符串对象并返回相同的结果。这种安全性在可变对象中是不可能的。作为不可变对象，字符串对象常被用作字典数据类型的键或集合数据类型的数据元素。不可变性的缺点是，即使只是对现有的字符串实例进行微小的更改，也需要创建一个新的实例。
- en: Mutable versus immutable objects
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象与不可变对象
- en: A mutable object can be changed after its creation, but it is not possible to
    change an immutable object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象在创建后可以被更改，但不可变对象则不行。
- en: String literals can be enclosed by using matching single quotes (for example,
    *'blah'*), double quotes (for example, *"blah blah"*), or triple single or double
    quotes (for example, *"""none"""* or *'''none'''*). It is also worth mentioning
    that string objects are handled differently in Python 3 versus Python 2\. In Python
    3, string objects can hold only text sequences in the form of Unicode data points,
    but in Python 2 they can hold text as well as byte data. In Python 3, byte data
    is handled by the `bytes` data type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量可以使用匹配的单引号（例如，*'blah'*）、双引号（例如，*"blah blah"*）或三重单引号或双引号（例如，*"""none"""*
    或 *'''none'''*）来包围。还值得一提的是，Python 3 和 Python 2 中字符串对象的处理方式不同。在 Python 3 中，字符串对象只能以
    Unicode 数据点的形式存储文本序列，但在 Python 2 中，它们可以存储文本以及字节数据。在 Python 3 中，字节数据由 `bytes` 数据类型处理。
- en: 'Separating text from bytes in Python 3 makes it clean and efficient but at
    the cost of data portability. The Unicode text in strings cannot be saved to disk
    or sent to a remote location on the network without converting it into a binary
    format. This conversion requires encoding the string data into a byte sequence,
    which can be achieved in one of the following ways:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，将文本与字节分离使得处理更加清晰和高效，但代价是数据可移植性。字符串中的 Unicode 文本不能直接保存到磁盘或发送到网络上的远程位置，除非将其转换为二进制格式。这种转换需要将字符串数据编码为字节序列，这可以通过以下方式之一实现：
- en: '`UTF-8` being the default) and how to handle the errors.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UTF-8` 是默认编码）以及如何处理错误。'
- en: '`Bytes` data type by passing the string instance to the bytes constructor along
    with the encoding scheme and the error handling scheme.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将字符串实例传递给 `bytes` 构造函数，并附带编码方案和错误处理方案，可以将字符串数据类型转换为 `Bytes` 数据类型。
- en: The details of methods and the attributes available with any string object can
    be found in the official Python documentation as per the Python release.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任何字符串对象的方法细节和可用属性可以在官方 Python 文档中找到，具体取决于 Python 版本。
- en: Lists
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: The list is one of the basic collection types in Python, which is used to store
    multiple objects using a single variable. Lists are dynamic and *mutable*, which
    means the objects in a list can be changed and the list can grow or shrink.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是 Python 中基本集合类型之一，它使用单个变量来存储多个对象。列表是动态的且*可变的*，这意味着列表中的对象可以被更改，列表可以增长或缩小。
- en: List objects in Python are not implemented using any linked list concept but
    using a variable-length array. The array contains references to objects it is
    storing. The pointer of this array and its length are stored in the list head
    structure, which is kept up to date as objects are added or deleted from a list.
    The behavior of such an array is made to appear like a list but in reality, it
    is not a real list. That is why some of the operations on a Python list are not
    optimized. For example, inserting a new object into a list and deleting objects
    from a list will have a complexity of *n*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的列表对象不是使用任何链表概念实现的，而是使用可变长数组。该数组包含它所存储的对象的引用。这个数组的指针及其长度存储在列表头结构中，该结构在对象被添加或从列表中删除时保持最新。这种数组的操作被设计得像列表一样，但实际上它不是一个真正的列表。这就是为什么Python列表的一些操作没有被优化。例如，将新对象插入列表和从列表中删除对象将具有*O(n)*的复杂度。
- en: To rescue the situation, Python provides a `deque` data type in the `collections`
    built-in module. The `deque` data type provides the functionality of stacks and
    queues and is a good alternative option for cases when a linked list-like behavior
    is demanded by a problem statement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这种情况，Python在`collections`内置模块中提供了一个`deque`数据类型。`deque`数据类型提供了栈和队列的功能，并且在需要类似链表的行为时是一个很好的替代选项。
- en: 'Lists can be created empty or with an initial value using *square brackets*.
    Next, we present a code snippet that demonstrates how to create an empty or non-empty
    list object using only the square brackets or using the list object constructor:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以创建为空或带有初始值，使用*方括号*。接下来，我们将展示一个代码片段，演示如何仅使用方括号或使用列表对象构造函数创建空或非空列表对象：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The details of the operations available with a list object, such as `add`, `insert`,
    `append`, and `delete` can be reviewed in the official Python documentation. We
    will introduce tuples in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象可用的操作细节，如`add`、`insert`、`append`和`delete`，可以在官方Python文档中查阅。我们将在下一节介绍元组。
- en: Tuples
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: A tuple is an immutable list, which means it cannot be modified after creation.
    Tuples are usually used for a small number of entries and when the position and
    sequence of the entries in a collection is important. To preserve the sequence
    of entries, tuples are designed as immutable, and this is where tuples differentiate
    themselves from lists. Operations on a tuple are typically faster than a regular
    list datatype. In cases when the values in a collection are required to be constant
    in a particular order, using tuples is the preferred option because of their superior
    performance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个不可变列表，这意味着一旦创建后就不能修改。元组通常用于少量条目，并且当集合中条目的位置和顺序很重要时。为了保持条目的顺序，元组被设计为不可变的，这也是元组与列表区别开来的地方。元组上的操作通常比常规列表数据类型更快。在需要集合中的值以特定顺序保持不变的情况下，由于它们的优越性能，使用元组是首选选项。
- en: 'Tuples are normally initialized with values because they are immutable. A simple
    tuple can be created using parenthesis. A few ways to create tuple instances are
    shown in the next code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 元组通常使用值初始化，因为它们是不可变的。可以使用括号创建一个简单的元组。以下代码片段展示了创建元组实例的几种方法：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code snippet, we created an empty tuple (`w`), a tuple with numbers
    (`x`), and a tuple with the text `Hello World`, which is `z`. The variable `y`
    is not a tuple since, for a 1-tuple (a single-object tuple), we need a trailing
    comma to indicate that it is a tuple.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们创建了一个空元组（`w`），一个包含数字的元组（`x`），以及一个包含文本`Hello World`的元组（`z`）。变量`y`不是一个元组，因为对于单元素元组（单个对象的元组），我们需要一个尾随逗号来表示它是一个元组。
- en: After introducing lists and tuples, we will briefly introduce dictionaries.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍列表和元组之后，我们将简要介绍字典。
- en: Dictionaries
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: Dictionaries are one of the most used and versatile data types in Python. A
    dictionary is a collection that is used to store data values in the *key:value*
    format. Dictionaries are mutable and unordered data types. In other programming
    languages, they are referred to as *associative arrays* or *hashtables*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是Python中最常用且功能多样的数据类型之一。字典是一种用于以*键：值*格式存储数据值的集合。字典是可变且无序的数据类型。在其他编程语言中，它们被称为*关联数组*或*哈希表*。
- en: 'A dictionary can be created using *curly brackets* with a list of *key:value*
    pairs. The key is separated from its value by a colon *'':''* and the *key:value*
    pairs are separated by a comma *'',''*. A code snippet for a dictionary definition
    follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用花括号和一系列 *key:value* 对来创建字典。键与其值由冒号 *':'* 分隔，而 *key:value* 对由逗号 *','* 分隔。以下是一个字典定义的代码片段：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Duplicate keys are not allowed in a dictionary. A key must be an immutable object
    type such as a string, tuple, or number. The values in a dictionary can be of
    any data type, which even includes lists, sets, custom objects, and even another
    dictionary itself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中不允许有重复的键。键必须是一个不可变对象类型，如字符串、元组或数字。字典中的值可以是任何数据类型，甚至包括列表、集合、自定义对象，甚至另一个字典本身。
- en: 'When dealing with dictionaries, three objects or lists are important:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字典时，有三个对象或列表是重要的：
- en: '`keys()` method:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keys()` 方法：'
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`values()` method:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values()` 方法：'
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`items()` method:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items()` 方法：'
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we will discuss sets, which are also key data structures in Python.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论集合，它们也是 Python 中的关键数据结构。
- en: Sets
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: A set is a *unique* collection of objects. A set is a mutable and unordered
    collection. There is no duplication of objects allowed in a set. Python uses a
    hashtable data structure to implement uniqueness in a set, which is the same approach
    used to ensure the uniqueness of keys in a dictionary. The behavior of sets in
    Python is very similar to sets in mathematics. This data type finds its application
    in situations where the order of objects is not important, but their uniqueness
    is. This helps to test whether a certain collection contains a certain object
    or not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一组*独特*的对象集合。集合是一个可变且无序的集合。集合中不允许有对象的重复。Python 使用散列表数据结构来实现集合的唯一性，这与确保字典中键的唯一性的方法相同。Python
    中集合的行为与数学中的集合非常相似。这种数据类型在对象顺序不重要但唯一性很重要的情况下找到其应用。这有助于测试某个集合是否包含某个特定对象。
- en: Tip
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the behavior of a set is required as an immutable data type, Python has a
    variant implementation of sets called `frozenset`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要一个不可变数据类型的集合行为，Python 有一个名为 `frozenset` 的集合的变体实现。
- en: 'Creating a new set object is possible using *curly brackets* or using the set
    constructor (`set()`). The next code snippet shows a few examples of creating
    a set:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用花括号或使用集合构造函数 (`set()`) 来创建一个新的集合对象。以下代码片段展示了创建集合的一些示例：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Accessing set objects is not possible using an indexing approach. We need to
    pop one object from the set like a list or we can iterate on a set to get objects
    one by one. Like mathematical sets, sets in Python also support operations such
    as *union*, *intersection*, and *difference*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引方法无法访问集合对象。我们需要像列表一样从集合中弹出一个对象，或者我们可以迭代集合以逐个获取对象。像数学集合一样，Python 中的集合也支持如
    *并集*、*交集* 和 *差集* 等操作。
- en: In this section, we reviewed the key concepts of strings and collection data
    types in Python 3, which are important to understand the upcoming topic – iterators
    and generators.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了 Python 3 中字符串和集合数据类型的关键概念，这些概念对于理解即将到来的主题——迭代器和生成器至关重要。
- en: Using iterators and generators for data processing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器和生成器进行数据处理
- en: Iteration is one of the key tools used for data processing and data transformation.
    Iterations are especially useful when dealing with large datasets and when bringing
    the whole dataset into memory is not possible or efficient. Iterators provide
    a way to bring the data into memory one item at a time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是数据处理和数据转换中使用的核心工具之一。在处理大型数据集时，当整个数据集无法或效率不高地放入内存时，迭代特别有用。迭代器提供了一种逐个将数据带入内存的方法。
- en: Iterators can be created by defining them with a separate class and implementing
    special methods such as `__iter__` and `__next__`. But there is also a new way
    to create iterators using the `yield` operation, known as generators. In the next
    subsections, we will study both iterators and generators.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过定义一个单独的类并实现特殊方法 `__iter__` 和 `__next__` 来创建迭代器。但还有一种使用 `yield` 操作创建迭代器的新方法，称为生成器。在接下来的小节中，我们将研究迭代器和生成器。
- en: Iterators
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'Iterators are the objects that are used to iterate on other objects. An object
    on which an iterator can iterate is called `iterable` object class. This is not
    recommended but is technically possible and we will discuss with an example why
    this approach is not a good design approach. In the next code snippet, we provide
    a few examples of using the `for` loop for iteration purposes in Python:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是用于遍历其他对象的实体。一个可以由迭代器遍历的对象被称为`iterable`对象类。虽然不推荐这样做，但从技术上讲是可行的，我们将会通过一个例子来讨论为什么这种做法不是一个好的设计方法。在下一个代码片段中，我们提供了几个使用Python中的`for`循环进行迭代操作的例子：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In these code examples, we used different `for` loops to iterate on a list,
    a string, a dictionary, and a file. All these data types are iterable and thus
    we will be using a simple syntax with the `for` loop to get through the items
    in these collections or sequences. Next, we will study what ingredients make an
    object iterable, which is also referred to as the **Iterator Protocol**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码示例中，我们使用了不同的`for`循环来遍历列表、字符串、字典和文件。所有这些数据类型都是可迭代的，因此我们将使用简单的语法，通过`for`循环遍历这些集合或序列中的项目。接下来，我们将研究使对象可迭代的要素，这通常被称为**迭代器协议**。
- en: Important note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Every collection in Python is *iterable* by default.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每个集合默认都是*可迭代的*。
- en: 'In Python, an iterator object must implement two special methods: `__iter__`
    and `__next__`. To iterate on an object, the object has to implement at least
    the `__iter__` method. Once the object implements the `__iter__` method, we can
    call the object iterable. These methods are described next:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，迭代器对象必须实现两个特殊方法：`__iter__`和`__next__`。要迭代一个对象，该对象必须至少实现`__iter__`方法。一旦对象实现了`__iter__`方法，我们就可以称该对象为可迭代的。这些方法将在下面进行描述：
- en: '`__iter__`: This method returns the iterator object. This method is called
    at the start of a loop to get the iterator object.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__iter__`：这个方法返回迭代器对象。这个方法在循环开始时被调用，以获取迭代器对象。'
- en: '`__next__`: This method is called at each iteration of the loop and it returns
    the next item in the iterable object.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__next__`：这个方法在循环的每次迭代中被调用，并返回可迭代对象中的下一个项目。'
- en: 'To explain how to build a custom object that is iterable, we will implement
    the `Week` class, which stores the numbers and names of all weekdays in a dictionary.
    This class will not be iterable by default. To make it iterable, we will add `__iter__`.
    To keep the example simple, we will also add the `__next__` method in the same
    class. Here is the code snippet with the `Week` class and the main program, which
    iterates to get the names of weekdays:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释如何构建一个可迭代的自定义对象，我们将实现`Week`类，该类将所有工作日的数字和名称存储在字典中。这个类默认不是可迭代的。为了使其可迭代，我们将添加`__iter__`方法。为了使例子简单，我们还将在这个类中添加`__next__`方法。以下是包含`Week`类和主程序的代码片段，该程序通过迭代获取工作日的名称：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We shared this code example just to demonstrate how the `__iter__` and `__next__`
    methods can be implemented in the same object class. This style of implementing
    an iterator is commonly found on the internet, but it is not a recommended approach
    and is considered a bad design. The reason is that when we use it in the `for`
    loop, we get back the main object as an iterator as we implemented `__iter__`
    and `__next__` in the same class. This can give unpredictable results. We can
    demonstrate this by executing the following code snippet for the same class, `Week`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分享这个代码示例只是为了演示如何在同一个对象类中实现`__iter__`和`__next__`方法。这种实现迭代器的方式在互联网上很常见，但并不是一个推荐的方法，并且被认为是一个不好的设计。原因是当我们使用它时，在`for`循环中，我们会得到一个作为迭代器的主要对象，因为我们在这个类中实现了`__iter__`和`__next__`。这可能会导致不可预测的结果。我们可以通过执行以下代码片段来证明这一点，针对同一个类`Week`：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this new main program, we are iterating on the same object using two different
    iterators. The results of this main program are not as expected. This is due to
    a common `_index` attribute shared by the two iterators. Here is a console output
    as a reference:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的主程序中，我们使用两个不同的迭代器遍历同一个对象。这个主程序的结果并不像预期的那样。这是因为两个迭代器共享一个常见的基础属性`_index`。以下是作为参考的控制台输出：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that in this new main program we deliberately did not use a `for` loop.
    We created two iterator objects for the same object of the `Week` class using
    the `iter` function. The `iter` function is a Python standard function that calls
    the `__iter__` method. To get the next item in the iterable object, we directly
    used the `__next__` method as well as the `next` function. The `next` function
    is also a general function, like the `iter` function. This approach of using an
    iterable as an iterator is also not considered thread-safe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个新的主程序中，我们故意没有使用`for`循环。我们使用`iter`函数为同一个`Week`类的对象创建了两个迭代器对象。`iter`函数是一个Python标准函数，它调用`__iter__`方法。为了获取可迭代对象中的下一个项目，我们直接使用了`__next__`方法和`next`函数。`next`函数也是一个通用函数，就像`iter`函数一样。这种将可迭代对象用作迭代器的方法也不被认为是线程安全的。
- en: 'The best approach is always to use a separate iterator class and always create
    a new instance of an iterator through the `__iter__` method. Each iterator instance
    has to manage its own internal state. A revised version of the same code example
    of the `Week` class is shown next with a separate iterator class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳做法始终是使用一个单独的迭代器类，并且始终通过`__iter__`方法创建迭代器的新实例。每个迭代器实例都必须管理自己的内部状态。下面是`Week`类相同代码示例的修订版，其中包含一个单独的迭代器类：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this revised code example, we have a separate iterator class with the `__next__`
    method and it has its own `_index` attribute for managing the iterator state.
    The iterator instance will have a reference to the container object (dictionary).
    The console output of the revised example gives the results as expected: each
    iterator is iterating separately on the same instance of the `Week` class. The
    console output is shown next as a reference:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修订的代码示例中，我们有一个包含`__next__`方法的单独迭代器类，它有自己的`_index`属性来管理迭代器状态。迭代器实例将引用容器对象（字典）。修订示例的控制台输出给出了预期的结果：每个迭代器都在单独迭代同一个`Week`类的实例。控制台输出如下作为参考：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In short, to create an iterator, we need to implement the `__iter__` and `__next__`
    methods, manage internal state, and raise a `StopIteration` exception when there
    are no values available. Next, we will study generators, which will simplify the
    way we return iterators.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，要创建一个迭代器，我们需要实现`__iter__`和`__next__`方法，管理内部状态，并在没有值可用时引发`StopIteration`异常。接下来，我们将研究生成器，这将简化我们返回迭代器的方式。
- en: Generators
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: A generator is a simple way of returning an iterator instance that can be used
    for iteration, which is achieved by implementing only a generator function. A
    generator function is similar to a normal function but with a `yield` statement
    instead of a `return` statement in it. The `return` statement is still allowed
    in a generator function but will not be used to return the next item in an iterable
    object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一种简单的方法，用于返回一个迭代器实例，它可以用于迭代，这通过仅实现一个生成器函数来实现。生成器函数类似于一个普通函数，但其中包含的是`yield`语句而不是`return`语句。在生成器函数中仍然允许使用`return`语句，但它不会用于返回可迭代对象中的下一个项目。
- en: By definition, a function will be a generator function if it has at least one
    `yield` statement in it. The main difference when using the `yield` statement
    is that it pauses the function and saves its internal state, and when the function
    is called next time, it starts from the line it yielded the last time. This design
    pattern makes the iterator functionality simple and efficient.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，如果一个函数至少包含一个`yield`语句，那么它将是一个生成器函数。使用`yield`语句时的主要区别是它会暂停函数并保存其内部状态，当函数下次被调用时，它将从上次`yield`的行开始。这种设计模式使得迭代器功能简单且高效。
- en: Internally, methods such as `__iter__` and `__next__` are implemented automatically
    and the `StopIteration` exception is also raised automatically. The local attributes
    and their values are preserved between the successive calls and there is no additional
    logic to be implemented by the developer. The Python interpreter provides all
    this functionality whenever it identifies a generator function (a function with
    a `yield` statement in it).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`__iter__`和`__next__`等方法会自动实现，`StopIteration`异常也会自动引发。局部属性及其值在连续调用之间被保留，开发者不需要实现额外的逻辑。当Python解释器识别到生成器函数（包含`yield`语句的函数）时，它会提供所有这些功能。
- en: 'To understand how the generator works, we will start with a simple generator
    example that is used to generate a sequence of the first three letters of the
    alphabet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解生成器是如何工作的，我们将从一个简单的生成器示例开始，该示例用于生成字母表前三个字母的序列：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this code example, we implemented a simple generator function using three
    `yield` statements without a `return` statement. In the main part of the program,
    we did the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们使用三个`yield`语句实现了一个简单的生成器函数，而没有使用`return`语句。在程序的主要部分，我们做了以下操作：
- en: We called the generator function, which returns us an iterator instance. At
    this stage, no line inside the `my_gen()` generator function is executed.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用了生成器函数，它返回给我们一个迭代器实例。在这个阶段，`my_gen()`生成器函数内部的任何一行都没有执行。
- en: Using the iterator instance, we called the `__next__` method, which starts the
    execution of the `my_gen()` function, pauses after executing the first `yield`
    statement, and returns `A`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用迭代器实例，我们调用了`__next__`方法，这启动了`my_gen()`函数的执行，在执行第一个`yield`语句后暂停，并返回`A`。
- en: Next, we call the `next()` function on the iterator instance. The result is
    the same as we get with the `__next__` method. But this time, the `my_gen()` function
    starts the execution from the next line from where it paused the last time because
    of the `yield` statement. The next line is another `yield` statement, which results
    in another pause after returning the letter `B`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在迭代器实例上调用`next()`函数。结果是我们在使用`__next__`方法时得到的结果相同。但这次，`my_gen()`函数从上次由于`yield`语句而暂停的下一行开始执行。下一行是另一个`yield`语句，这导致在返回字母`B`后再次暂停。
- en: The next `__next__` method will result in the execution of the next `yield`
    statement, which will return the letter `C`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个`__next__`方法将导致执行下一个`yield`语句，这将返回字母`C`。
- en: 'Next, we will revisit the `Week` class and its iterator implementation and
    will use a generator instead of an iterator class. The sample code is presented
    next:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重新审视`Week`类及其迭代器实现，并将使用生成器而不是迭代器类。下面的示例代码将展示：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In comparison to `iterator4.py`, the implementation of the `Week` class with
    a generator is way simpler and cleaner and we can achieve the same results. This
    is the power of generators and that is why they are very popular in Python. Before
    concluding this topic, it is important to highlight a few other key features of
    generators:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与`iterator4.py`相比，使用生成器实现的`Week`类要简单得多，也更干净，我们可以达到相同的结果。这就是生成器的力量，这也是为什么它们在Python中非常受欢迎。在结束这个主题之前，重要的是要强调生成器的几个其他关键特性：
- en: '**Generator expressions**: Generator expressions can be used to create simple
    generators (also known as **anonymous functions**) on the fly without writing
    a special method. The syntax is similar to list comprehension except we use parentheses
    instead of square brackets. The next code example (an extension of the example
    we introduced for list comprehension) shows how a generator expression can be
    used to create a generator, its usage, and also a comparison with list comprehension:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器表达式**：生成器表达式可以用来动态创建简单的生成器（也称为**匿名函数**），而不需要编写特殊的方法。语法与列表推导式类似，只是我们使用圆括号而不是方括号。下面的代码示例（是我们为列表推导式引入的示例的扩展）展示了如何使用生成器表达式创建生成器，其用法，以及与列表推导式的比较：'
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Infinite streams**: Generators can also be used to implement an infinite
    stream of data. It is always a challenge to bring an infinite stream into memory,
    which is solved easily with generators as they return only one data item at a
    time.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无限流**：生成器也可以用来实现无限数据流。将无限流引入内存总是一个挑战，但生成器可以轻松解决这个问题，因为它们一次只返回一个数据项。'
- en: '`for` loops, but we will try to solve it using two generators: the `prime_gen`
    generator for generating prime numbers and the `x2_gen` generator for taking the
    square of the prime numbers fed to this generator by the `prime_gen` generator.
    We feed the two generators pipelined into the `sum` function to get the desired
    result. Here is the code snippet for this problem solution:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环，但我们将尝试使用两个生成器来解决它：`prime_gen`生成器用于生成素数，`x2_gen`生成器用于取`prime_gen`生成器提供的素数的平方。我们将这两个生成器管道化输入到`sum`函数中，以获得所需的结果。以下是此问题解决方案的代码片段：'
- en: '[PRE16]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Generators operate on an on-demand basis, which makes them not only memory efficient
    but also provides a way to generate values when they are needed. This helps to
    avoid unnecessary data generation, which may not be used at all. Generators are
    well suited to be used for a large amount of data processing, for piping the data
    from one function to others, and to simulate concurrency as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器基于按需操作，这使得它们不仅内存效率高，而且提供了一种在需要时生成值的方法。这有助于避免不必要的生成数据，这些数据可能根本不会被使用。生成器非常适合用于大量数据处理、将数据从一个函数传递到另一个函数，以及模拟并发。
- en: In the next section, we will investigate how to handle files in Python.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在Python中处理文件。
- en: Handling files in Python
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中处理文件
- en: Reading data from a file or writing data to a file is one of the fundamental
    operations supported by any programming language. Python provides extensive support
    for handling file operations, which are mostly available in its standard library.
    In this section, we will discuss core file operations such as opening a file,
    closing a file, reading from a file, writing to a file, file management with context
    managers, and opening multiple files with one handle using the Python standard
    library. We will start our discussion with file operations in the next subsection.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取数据或将数据写入文件是任何编程语言支持的基本操作之一。Python提供了广泛的支持来处理文件操作，这些操作大多可在其标准库中找到。在本节中，我们将讨论核心文件操作，如打开文件、关闭文件、从文件中读取、向文件中写入、使用上下文管理器进行文件管理，以及使用Python标准库通过一个句柄打开多个文件。我们将从下一小节开始讨论文件操作。
- en: File operations
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件操作
- en: 'File operations typically start with opening a file and then reading or updating
    the contents in that file. The core file operations are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 文件操作通常从打开文件开始，然后读取或更新该文件的内容。核心文件操作如下：
- en: Opening and closing a file
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开和关闭文件
- en: 'To apply any read or update operation to a file, we need a pointer or reference
    to the file. A file reference can be obtained by opening a file using the built-in
    `open` function. This function returns a reference to the `file` object, which
    is also known as a `open` function is the name of the file with an absolute or
    relative path. One optional parameter is the access mode to indicate in which
    mode a file is to be opened. The access mode can be `read`, `write`, `append`,
    or others. A full list of access mode options is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要对文件执行任何读取或更新操作，我们需要一个指向文件的指针或引用。可以通过使用内置的`open`函数来打开文件来获取文件引用。此函数返回对`file`对象的引用，也称为使用绝对或相对路径命名的文件。一个可选参数是访问模式，用于指示文件应以何种模式打开。访问模式可以是`read`、`write`、`append`或其他。访问模式选项的完整列表如下：
- en: '`r`: This option is for opening a file in read-only mode. This is a default
    option if the access mode option is not provided:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：此选项用于以只读模式打开文件。如果没有提供访问模式选项，这是一个默认选项：'
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`a`: This option is for opening a file to append a new line at the end of the
    file:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：此选项用于打开文件以在文件末尾追加新行：'
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`w`: This option is for opening a file for writing. If a file does not exist,
    it will create a new file. If the file exists, this option will override it and
    any existing contents in that file will be destroyed:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：此选项用于以写入模式打开文件。如果文件不存在，它将创建一个新文件。如果文件存在，此选项将覆盖它，并且该文件中的任何现有内容都将被销毁：'
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`x`: This option is for opening a file for exclusive writing. If the file already
    exists, it will throw an error:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：此选项用于以独占写入模式打开文件。如果文件已存在，它将引发错误：'
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`t`: This option is for opening a file in text mode. This is the default option.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`：此选项用于以文本模式打开文件。这是默认选项。'
- en: '`b`: This option is for opening a file in binary mode.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：此选项用于以二进制模式打开文件。'
- en: '`+`: This option is for opening a file for reading and writing:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：此选项用于以读写模式打开文件：'
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The mode options can be combined to get multiple options. In addition to the
    filename and the access mode options, we can also pass the encoding type, especially
    for text files. Here is an example of opening a file with `utf-8`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 模式选项可以组合使用以获取多个选项。除了文件名和访问模式选项之外，我们还可以传递编码类型，尤其是对于文本文件。以下是一个使用`utf-8`打开文件的示例：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we complete our operations with a file, it is a must to close the file
    to free up the resources for other processes to use the file. A file can be closed
    by using the `close` method on the file instance or the file handle. Here is a
    code snippet showing the use of the `close` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成对文件的操作后，关闭文件以释放资源供其他进程使用文件是必须的。可以通过在文件实例或文件句柄上使用`close`方法来关闭文件。以下是一个展示如何使用`close`方法的代码片段：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once a file is closed, the resources associated with the file instance and locks
    (if any) will be released by the operating system, which is a best practice in
    any programming language.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件关闭，操作系统将释放与文件实例和锁（如果有）相关的资源，这是任何编程语言中的最佳实践。
- en: Reading and writing files
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读写文件
- en: 'A file can be read by opening the file in access mode `r` and then using one
    of the read methods. Next, we summarize different methods available for read operations:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以访问模式`r`打开文件并使用读取方法之一来读取文件。接下来，我们总结可用于读取操作的不同方法：
- en: '`read(n)`: This method reads `n` characters from a file.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read(n)`: 此方法从文件中读取`n`个字符。'
- en: '`readline()`: This method returns one line from a file.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readline()`: 此方法返回文件中的一行。'
- en: '`readlines()`: This method returns all lines from a file as a list.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readlines()`: 此方法返回文件中所有行的列表。'
- en: 'Similarly, we can append or write to a file once it is opened in an appropriate
    access mode. The methods that are relevant to appending a file are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一旦以适当的访问模式打开文件，我们就可以向文件追加或写入内容。与追加文件相关的相关方法如下：
- en: '`write (x)`: This method writes a string or a sequence of bytes to a file and
    returns the number of characters added to the file.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write (x)`: 此方法将字符串或字节序列写入文件，并返回添加到文件中的字符数。'
- en: '`writelines (lines)`: This method writes a list of lines to a file.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writelines (lines)`: 此方法将行列表写入文件。'
- en: 'In the next code example, we will create a new file, add a few text lines to
    it, and then read the text data using the read operations discussed previously:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码示例中，我们将创建一个新文件，向其中添加一些文本行，然后使用之前讨论的读取操作读取文本数据：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this code example, we write three lines to a file first. In the read operations,
    first, we read four characters, followed by reading two lines using the `readline`
    method. In the end, we move the pointer back to the top of the file using the
    `seek` method and access all lines in the file using the `readlines` method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们首先向文件写入三行。在读取操作中，首先读取四个字符，然后使用`readline`方法读取两行。最后，我们使用`seek`方法将指针移回文件顶部，并使用`readlines`方法访问文件中的所有行。
- en: In the next section, we will see how the use of a context manager makes file
    handling convenient.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到使用上下文管理器如何使文件处理变得方便。
- en: Using a context manager
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用上下文管理器
- en: Correct and fair usage of resources is critical in any programming language.
    A file handler and a database connection are a couple of many examples where it
    is a common practice to not release the resources on time after working with objects.
    If the resources are not released at all, then it will end up in a situation called
    **memory leakage** and may impact the system performance, and ultimately may result
    in the system crashing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，正确和公平地使用资源都是至关重要的。文件句柄和数据库连接是许多例子中的常见做法，在处理对象后没有及时释放资源。如果资源根本未释放，最终会导致称为**内存泄漏**的情况，并可能影响系统性能，最终可能导致系统崩溃。
- en: 'To solve this memory leakage and timely resource release problem, Python came
    up with the concept of context managers. A context manager is designed to reserve
    and release resources precisely as per the design. When a context manager is used
    with the `with` keyword, a statement after the `with` keyword is expected to return
    an object that must implement the **context management protocol**. This protocol
    requires two special methods to be implemented by the returned object. These special
    methods are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这种内存泄漏和及时释放资源的问题，Python提出了上下文管理器的概念。上下文管理器旨在精确地保留和释放资源。当使用`with`关键字与上下文管理器一起使用时，`with`关键字后面的语句应返回一个对象，该对象必须实现**上下文管理协议**。该协议要求返回的对象实现两个特殊方法。这些特殊方法如下：
- en: '`.__enter__()`: This method is called with the `with` keyword and is used to
    reserve the resources required as per the statement after the `with` keyword.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.__enter__()`: 此方法与`with`关键字一起调用，用于保留`with`关键字后面的语句所需的资源。'
- en: '`.__exit__()`: This method is called after the execution of the `with` block
    and is used to release the resources that are reserved in the `.__enter__()` method.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.__exit__()`: 此方法在执行`with`块之后被调用，用于释放在`.__enter__()`方法中保留的资源。'
- en: 'For example, when a file is opened using the context manager `with` statement
    (block), there is no need to close the file. The file `open` statement will return
    the file handler object, which has already implemented the context management
    protocol and the file will be closed automatically as soon the execution of the
    `with` block is completed. A revised version of the code example for writing and
    reading a file using the context manager is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用上下文管理器`with`语句（块）打开文件时，不需要关闭文件。`open`语句将返回文件句柄对象，该对象已经实现了上下文管理协议，文件将在`with`块执行完成后自动关闭。以下是一个使用上下文管理器编写和读取文件的代码示例的修订版：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code with the context manager is simple and easy to read. The use of a context
    manager is a recommended approach for opening and working with files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文管理器的代码简单易读。使用上下文管理器是打开和操作文件的一种推荐方法。
- en: Operating on multiple files
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作多个文件
- en: 'Python supports opening and operating on multiple files at the same time. We
    can open these files in different modes and operate on them. There is no limit
    on the number of files. We can open two files in read mode by using the following
    sample code and access the files in any order:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持同时打开和操作多个文件。我们可以以不同的模式打开这些文件并对它们进行操作。文件的数量没有限制。我们可以使用以下示例代码以读取模式打开两个文件，并按任意顺序访问它们：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also read from one file and write to another file using this multifile
    operating option. Sample code to transfer contents from one file to another file
    is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这种多文件操作选项从一个文件读取并写入到另一个文件。以下是将内容从一个文件传输到另一个文件的示例代码：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Python also has a more elegant solution to operate on multiple files using
    the `fileinput` module. This module''s input function can take a list of multiple
    files and then treat all such files as a single input. Sample code with two input
    files, `1.txt` and `2.txt`, and using the `fileinput` module is presented next:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有一个更优雅的解决方案来使用`fileinput`模块操作多个文件。此模块的输入函数可以接受多个文件的列表，然后将所有这些文件视为单个输入。以下是一个使用`fileinput`模块和两个输入文件`1.txt`和`2.txt`的示例代码：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this approach, we get one file handle that operates on multiple files sequentially.
    Next, we will discuss error and exception handling in Python.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们得到一个可以依次操作多个文件的文件句柄。接下来，我们将讨论Python中的错误和异常处理。
- en: Handling errors and exceptions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误和异常
- en: 'There are many types of errors possible in Python. The most common one is related
    to the syntax of the program and is typically known as a **syntax error**. On
    many occasions, errors are reported during the execution of a program. Such errors
    are called **runtime errors**. The runtime errors that can be handled within our
    program are called **exceptions**. This section will focus on how to handle runtime
    errors or exceptions. Before jumping on to error handling, we will briefly introduce
    the most common runtime errors as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可能存在许多类型的错误。最常见的一种与程序的语法相关，通常被称为**语法错误**。在许多情况下，错误会在程序执行过程中被报告。这类错误被称为**运行时错误**。我们程序中可以处理的运行时错误被称为**异常**。本节将重点介绍如何处理运行时错误或异常。在介绍错误处理之前，我们将简要介绍以下最常见的运行时错误：
- en: '`IndexError`: This error occurs when a program tries to access an item at an
    invalid index (location in the memory).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexError`: 当程序尝试访问一个无效索引（内存中的位置）处的项时，将发生此错误。'
- en: '`ModuleNotFoundError`: This error will be thrown when a specified module is
    not found at the system path.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleNotFoundError`: 当在系统路径中找不到指定的模块时，将抛出此错误。'
- en: '`ZeroDivisionError`: This error is thrown when a program tries to divide a
    number by zero.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZeroDivisionError`: 当程序尝试将一个数除以零时，将抛出此错误。'
- en: '`KeyError`: This error occurs when a program tries to fetch a value from a
    dictionary using an invalid key.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyError`: 当程序尝试使用无效的键从一个字典中获取值时，将发生此错误。'
- en: '`StopIteration`: This error is thrown when the `__next__` method does not find
    any further items in a container.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StopIteration`: 当`__next__`方法在容器中找不到更多项时，将抛出此错误。'
- en: '`TypeError`: This error occurs when a program tries to apply an operation on
    an object of an inappropriate type.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeError`: 当程序尝试对一个不适当的类型的对象应用操作时，将发生此错误。'
- en: A complete list of errors is available in the official documentation of Python.
    In the following subsections, we will discuss how to handle errors, sometimes
    also called exceptions, using appropriate constructs in Python.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Python的官方文档中提供了完整的错误列表。在接下来的小节中，我们将讨论如何使用Python中的适当构造来处理错误，有时也称为异常。
- en: Working with exceptions in Python
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中处理异常
- en: When runtime errors arise, the program can terminate abruptly and can cause
    damage to system resources such as corrupting files and database tables. This
    is why error or exception handling is one of the key ingredients of writing robust
    programs in any language. The idea is to anticipate that runtime errors can occur
    and if such an error occurs, what the behavior of our program would be as a response
    to that particular error.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时错误发生时，程序可能会突然终止，并可能损坏系统资源，如损坏文件和数据库表。这就是为什么错误或异常处理是编写任何语言中健壮程序的关键组成部分之一。其思路是预测运行时错误可能会发生，如果发生此类错误，我们的程序将如何响应该特定错误。
- en: 'Like many other languages, Python uses the `try` and `except` keywords. The
    two keywords are followed by separate blocks of code to be executed. The `try`
    block is a regular set of statements for which we anticipate that an error may
    occur. The `except` block will be executed only if there is an error in a `try`
    block. Next is the syntax of writing Python code with `try` and `except` blocks:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言一样，Python使用`try`和`except`关键字。这两个关键字后面跟着要执行的单独的代码块。`try`代码块是一组常规语句，我们预计其中可能发生错误。只有当`try`代码块中发生错误时，`except`代码块才会执行。下面是使用`try`和`except`代码块编写Python代码的语法：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we anticipate a particular error type or multiple error types, we can define
    an `except` block with the error name and can add as many `except` blocks as we
    need. Such named `except` blocks are executed only if the named exception is raised
    in the `try` block. With the `except` block statement, we can also add an `as`
    statement to store the exception object as a variable that is raised during the
    `try` block. The `try` block in the next code example has many possible runtime
    errors and that is why it has multiple `except` blocks:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们预测到特定的错误类型或多个错误类型，我们可以定义一个带有错误名称的`except`代码块，并且可以根据需要添加任意多的`except`代码块。这样的命名`except`代码块仅在`try`代码块中引发命名异常时才会执行。使用`except`代码块语句，我们还可以添加一个`as`语句来将异常对象存储为在`try`代码块中引发的变量。在下一个代码示例中的`try`代码块有许多可能的运行时错误，这就是为什么它有多个`except`代码块：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To illustrate a better use of an `except` block(s), we added multiple except
    blocks that are explained next:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明`except`代码块的使用，我们添加了多个`except`代码块，下面将进行解释：
- en: '`try` block tries to access an undefined variable. In our code example, this
    block will be executed when the interpreter tries to execute the `print(x)` statement.
    Additionally, we named the exception object as `e` and used it with the `print`
    statement to get the official error detail associated with this error type.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`代码块尝试访问一个未定义的变量。在我们的代码示例中，当解释器尝试执行`print(x)`语句时，此代码块将被执行。此外，我们给异常对象命名为`e`，并使用`print`语句获取与该错误类型相关的官方错误详情。'
- en: '`z = x/y` and y = 0\. For this block to be executed, we need to fix the `NameError`
    block first.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z = x/y` 和 y = 0\. 为了执行此代码块，我们首先需要修复`NameError`代码块。'
- en: '`except` block, which means if no match is found with the previous two `except`
    blocks, this block will be executed. The last statement `print(''x''+ y)` will
    also raise an error of type `TypeError` and will be handled by this block. Since
    we are not receiving any one particular type of exception in this block, we can
    use the `Exception` keyword to store the exception object in a variable.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`except`代码块，表示如果与前面的两个`except`代码块不匹配，则此代码块将被执行。最后的语句`print(''x''+ y)`也将引发类型为`TypeError`的错误，并将由此代码块处理。由于我们在此代码块中没有收到任何特定的异常类型，我们可以使用`Exception`关键字将异常对象存储在变量中。'
- en: Note that as soon an error occurs in any statement in the `try` block, the rest
    of the statements are ignored, and the control goes to one of the `except` blocks.
    In our code example, we need to fix the `NameError` error first to see the next
    level of exception and so on. We added three different types of errors in our
    example to demonstrate how to define multiple `except` blocks for the same `try`
    block. The order of the `except` blocks is important because more specific `except`
    blocks with error names have to be defined first and an `except` block without
    specifying an error name has to always be at the end.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦在 `try` 块中的任何语句中发生错误，其余的语句将被忽略，并且控制流将转到其中一个 `except` 块。在我们的代码示例中，我们需要首先修复
    `NameError` 错误，才能看到下一层的异常，依此类推。我们在示例中添加了三种不同类型的错误来演示如何为同一个 `try` 块定义多个 `except`
    块。`except` 块的顺序很重要，因为必须首先定义具有错误名称的更具体的 `except` 块，并且没有指定错误名称的 `except` 块必须始终放在最后。
- en: 'The following figure shows all the exception handling blocks:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了所有的异常处理块：
- en: '![Figure 4.1 – Different exception handling blocks in Python'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – Python 中不同的异常处理块'
- en: '](img/B17189_04_01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_04_01.jpg)'
- en: Figure 4.1 – Different exception handling blocks in Python
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Python 中不同的异常处理块
- en: As shown in the preceding diagram, in addition to `try` and `except` blocks,
    Python also supports `else` and `finally` blocks to enhance the error handling
    functionality. The `else` block is executed if no errors were raised during the
    `try` block. The code in this block will be executed as normal and no exception
    will be thrown if any error occurs within this block. Nested `try` and `except`
    blocks can be added within the `else` block if needed. Note that this block is
    optional.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，除了 `try` 和 `except` 块之外，Python 还支持 `else` 和 `finally` 块以增强错误处理功能。如果没有在
    `try` 块中引发错误，则执行 `else` 块。此块中的代码将按正常方式执行，并且如果此块内发生任何错误，则不会抛出异常。如果需要，可以在 `else`
    块内添加嵌套的 `try` 和 `except` 块。请注意，此块是可选的。
- en: The `finally` block is executed regardless of whether there is an error in the
    `try` block or not. The code inside the `finally` block is executed without any
    exception handling mechanism. This block is mainly used to free up the resources
    by closing the connections or opened files. Although it is an optional block,
    it is highly recommended to implement this block.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块无论在 `try` 块中是否有错误都会被执行。`finally` 块内的代码执行时不会进行任何异常处理机制。此块主要用于通过关闭连接或打开的文件来释放资源。尽管这是一个可选块，但强烈建议实现此块。'
- en: 'Next, we will look at the use of these blocks with a code example. In this
    example, we will open a new file for writing in the `try` block. If an error occurs
    in opening the file, an exception will be thrown, and we will send the error details
    to the console using the `print` statement in the `except` block. If no error
    occurs, we will execute the code in the `else` block that is writing some text
    to the file. In both cases (error or no error), we will close the file in the
    `finally` block. The complete sample code is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过代码示例来查看这些块的使用。在这个例子中，我们将在 `try` 块中打开一个新文件进行写入。如果在打开文件时发生错误，将会抛出异常，并且我们将使用
    `except` 块中的 `print` 语句将错误详情发送到控制台。如果没有发生错误，我们将执行 `else` 块中的代码，该代码将向文件写入一些文本。在两种情况下（错误或无错误），我们将在
    `finally` 块中关闭文件。完整的示例代码如下：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have covered extensively how to handle an exception in Python. Next, we will
    discuss how to raise an exception from Python code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经广泛地介绍了如何在 Python 中处理异常。接下来，我们将讨论如何从 Python 代码中引发异常。
- en: Raising exceptions
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引发异常
- en: Exceptions or errors are raised by the Python interpreter at runtime when an
    error occurs. We can also raise errors or exceptions ourselves if a condition
    occurs that may give us bad output or crash the program if we proceed further.
    Raising an error or exception will provide a graceful exit of the program.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时发生错误时，Python 解释器会引发异常或错误。如果出现可能导致我们得到不良输出或如果我们继续执行程序则可能导致程序崩溃的条件，我们也可以自己引发错误或异常。引发错误或异常将提供程序优雅退出的方式。
- en: 'An exception (object) can be thrown to the caller by using the `raise` keyword.
    An exception can be of one of the following types:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `raise` 关键字将异常（对象）抛给调用者。异常可以是以下类型之一：
- en: A built-in exception
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置异常
- en: A custom exception
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义异常
- en: A generic `Exception` object
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通用的 `Exception` 对象
- en: 'In the next code example, we will be calling a simple function to calculate
    a square root and will implement it to throw an exception if the input parameter
    is not a valid positive number:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码示例中，我们将调用一个简单的函数来计算平方根，并将其实现为如果输入参数不是一个有效的正数则抛出异常：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code example, we raised a built-in exception by creating a new instance
    of the `TypeError` class when the number passed to the `sqrt` function is not
    a number. We also raised a generic exception when the number passed is lower than
    `0`. In both cases, we passed our custom text to its constructor. In the next
    section, we will study how to define our own custom exception and then throw it
    to the caller.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，当传递给 `sqrt` 函数的数字不是数字时，我们通过创建 `TypeError` 类的新实例来抛出一个内置异常。当传递的数字小于 `0`
    时，我们也抛出一个通用异常。在这两种情况下，我们都向其构造函数传递了我们的自定义文本。在下一节中，我们将研究如何定义我们自己的自定义异常并将其抛给调用者。
- en: Defining custom exceptions
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义异常
- en: 'In Python, we can define our own custom exceptions by creating a new class
    that has to be derived from the built-in `Exception` class or its subclass. To
    illustrate the concept, we will revise our previous example by defining two custom
    exception classes to replace the built-in `TypeError` and the `Exception` error
    types. The new custom exception classes will be derived from the `TypeError` and
    the `Exception` classes. Here is sample code for reference with custom exceptions:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以通过创建一个新的类来定义自己的自定义异常，这个类必须从内置的 `Exception` 类或其子类派生。为了说明这个概念，我们将通过定义两个自定义异常类来修改之前的示例，以替换内置的
    `TypeError` 和 `Exception` 错误类型。新的自定义异常类将派生自 `TypeError` 和 `Exception` 类。以下是带有自定义异常的示例代码供参考：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this code example, the `NumTypeError` class is derived from the `TypeError`
    class and we have not added anything in this class. The `NegativeNumError` class
    is inherited from the `Exception` class and we override its constructor and add
    a custom message for this exception as part of the constructor. When we raise
    these custom exceptions in the `sqrt()` function, we do not pass any text with
    the `NegativeNumError` exception class. When we used the main program, we get
    the message with the `print (e)` statement as we have set it as part of the class
    definition.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，`NumTypeError` 类是从 `TypeError` 类派生出来的，我们在这个类中没有添加任何内容。`NegativeNumError`
    类是从 `Exception` 类继承的，我们重写了它的构造函数，并在构造函数中为这个异常添加了一个自定义消息。当我们在这 `sqrt()` 函数中抛出这些自定义异常时，我们不会用
    `NegativeNumError` 异常类传递任何文本。当我们使用主程序时，我们会通过 `print (e)` 语句得到消息，因为我们已经将其设置为类定义的一部分。
- en: In this section, we covered how to handle built-in error types using `try` and
    `except` blocks, how to define custom exceptions, and how to raise an exception
    declaratively. In the next section, we will cover logging in Python.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何使用 `try` 和 `except` 块处理内置错误类型，如何定义自定义异常，以及如何声明性地抛出异常。在下一节中，我们将介绍
    Python 中的日志记录。
- en: Using the Python logging module
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 日志模块
- en: 'Logging is a fundamental requirement for any reasonably sized application.
    Logging not only helps in debugging and troubleshooting but also provides insight
    into details of an application''s internal issues. A few advantages of logging
    are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是任何合理规模的应用程序的基本要求。日志记录不仅有助于调试和故障排除，还能深入了解应用程序内部问题的细节。日志记录的一些优点如下：
- en: Debugging code, especially to diagnose why and when an application failed or
    crashed
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试代码，特别是诊断应用程序失败或崩溃的原因和时间
- en: Diagnosing unusual application behavior
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诊断异常的应用程序行为
- en: Providing auditing data for regulatory or legal compliance matters
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为监管或法律合规性提供审计数据
- en: Identifying users' behaviors and malicious attempts to access unauthorized resources
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别用户行为和恶意尝试访问未经授权的资源
- en: Before discussing any practical examples of logging, we will first discuss the
    key components of the logging system in Python.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论任何日志记录的实际例子之前，我们首先将讨论 Python 日志系统的关键组件。
- en: Introducing core logging components
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍核心日志组件
- en: 'The following components are fundamental to set up logging for an application
    in Python:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下组件对于在 Python 中设置应用程序的日志记录是基本的：
- en: Logger
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录器
- en: Logging levels
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志级别
- en: Logging formatter
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志格式化器
- en: Logging handler
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志处理器
- en: 'A high-level architecture of the Python logging system can be summarized here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Python 日志系统的高级架构可以总结如下：
- en: '![Figure 4.2 – Logging components in Python'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – Python 中的日志组件'
- en: '](img/B17189_04_02.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_04_02.jpg)'
- en: Figure 4.2 – Logging components in Python
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – Python 中的日志组件
- en: Each of these components is discussed in detail in the following subsections.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件将在以下子节中详细讨论。
- en: The logger
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志记录器
- en: The logger is the entry point to the Python logging system. It is the interface
    to the application programmer. The `Logger` class available in Python provides
    several methods to log messages with different priorities. We will study the `Logger`
    class methods with code examples later in this section.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器是 Python 日志系统的入口点。它是应用程序程序员的接口。Python 中的 `Logger` 类提供了多种方法来以不同的优先级记录消息。我们将在本节后面通过代码示例研究
    `Logger` 类的方法。
- en: An application interacts with the `Logger` instance, which is set up using logging
    configuration such as the logging level. On receiving logging events, the `Logger`
    instance selects one or more appropriate logging handlers and delegates the events
    to the handlers. Each handler is typically designed for a specific output target.
    A handler sends the messages after applying a filter and formatting to the intended
    output target.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序与使用日志配置（如日志级别）设置的 `Logger` 实例交互。在接收到日志事件后，`Logger` 实例选择一个或多个合适的日志处理器并将事件委托给处理器。每个处理器通常设计用于特定的输出目标。处理器在应用过滤和格式化后，将消息发送到目标输出。
- en: Logging levels
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志级别
- en: 'All events and messages for a logging system are not of the same priority.
    For example, messages about errors are more urgent than warning messages. Logging
    levels are a way to set different priorities for different logging events. There
    are six levels defined in Python. Each level is associated with an integer value
    that indicates the severity. These levels are `NOTSET`, `DEBUG`, `INFO`, `WARNING`,
    `ERROR`, and `CRITICAL`. These are summarized here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日志系统中的所有事件和消息，优先级并不相同。例如，关于错误的日志比警告消息更紧急。日志级别是设置不同日志事件不同优先级的一种方式。Python 中定义了六个级别。每个级别都与一个表示严重性的整数值相关联。这些级别是
    `NOTSET`、`DEBUG`、`INFO`、`WARNING`、`ERROR` 和 `CRITICAL`。以下是对它们的总结：
- en: '![Figure 4.3 – Logging levels in Python'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – Python 中的日志级别'
- en: '](img/B17189_04_03.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_04_03.jpg)'
- en: Figure 4.3 – Logging levels in Python
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – Python 中的日志级别
- en: The logging formatter
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志格式化
- en: 'The logging formatter component helps to improve the formatting of messages,
    which is important for consistency and for human and machine readability. The
    logging formatter also adds extra context to messages such as time, module name,
    line number, threads, and process, which is extremely useful for debugging purposes.
    An example formatter expression is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 日志格式化组件有助于改进消息的格式，这对于保持一致性和便于人类及机器阅读非常重要。日志格式化组件还会向消息添加额外的上下文信息，例如时间、模块名称、行号、线程和进程，这对于调试目的非常有用。以下是一个示例格式化表达式：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When such a formatter expression is used, the log message `hello Geeks` of
    level `INFO` will be displayed similar to the console output that follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这样的格式化表达式时，级别为 `INFO` 的日志消息 `hello Geeks` 将显示得类似于以下控制台输出：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The logging handler
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志处理器
- en: 'The role of a logging handler is to write log data to an appropriate destination,
    which can be a console, a file, or even an email. There are many types of built-in
    logging handlers available in Python. A few popular handlers are introduced here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 日志处理器的角色是将日志数据写入适当的目的地，这可以是控制台、文件，甚至是电子邮件。Python 中提供了许多内置的日志处理器类型。以下介绍一些流行的处理器：
- en: '`StreamHandler` for displaying the logs on a console'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamHandler` 用于在控制台上显示日志'
- en: '`FileHandler` for writing the logs to a file'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileHandler` 用于将日志写入文件'
- en: '`SMTPHandler` for sending the logs to an email'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SMTPHandler` 用于将日志发送到电子邮件'
- en: '`SocketHandler` for sending the logs to a network socket'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocketHandler` 用于将日志发送到网络套接字'
- en: '`SyslogHandler` for sending the logs to a local or remote *Unix* syslog server'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyslogHandler` 用于将日志发送到本地或远程 *Unix* 系统日志服务器'
- en: '`HTTPHandler` for sending the logs to a web server using either `GET` or `POST`
    methods'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPHandler` 用于通过 `GET` 或 `POST` 方法将日志发送到 Web 服务器'
- en: The logging handler uses the logging formatter to add more context info to the
    logs and the logging level to filter the logging data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 日志处理器使用日志格式化器向日志添加更多上下文信息，并使用日志级别来过滤日志数据。
- en: Working with the logging module
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与日志模块一起工作
- en: In this section, we will discuss how to use the `logging` module with code examples.
    We will start with basic logging options and will take them to an advanced level
    in a gradual manner.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过代码示例讨论如何使用 `logging` 模块。我们将从基本的日志选项开始，并逐步将其提升到高级水平。
- en: Using the default logger
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用默认的日志记录器
- en: 'Without creating an instance of any logger class, there is already a default
    logger available in Python. The default logger, also known as the `logging` module
    and using its methods to dispatch logging events. The next code snippet shows
    the use of the root logger for capturing log events:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在不创建任何日志类实例的情况下，Python中已经有一个默认的日志记录器可用。默认日志记录器，也称为`logging`模块，使用其方法来调度日志事件。下面的代码片段展示了使用根日志记录器来捕获日志事件：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `debug`, `warning`, and `info` methods are used to dispatch logging events
    to the logger as per their severity. The default log level for this logger is
    set to `WARNING` and the default output is set to `stderr`, which means all the
    messages will go to the console or terminal only. This setting will block `DEBUG`
    and `INFO` messages to be displayed on the console output, which will be as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug`、`warning`和`info`方法用于根据它们的严重性将日志事件调度到日志记录器。此日志记录器的默认日志级别设置为`WARNING`，默认输出设置为`stderr`，这意味着所有消息都只会在控制台或终端上显示。此设置将阻止`DEBUG`和`INFO`消息在控制台输出中显示，如下所示：'
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The level of the root logger can be changed by adding the following line after
    the `import` statement:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`import`语句之后添加以下行来更改根日志记录器的级别：
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After changing the logging level to `DEBUG`, the console output will now show
    all the log messages:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在将日志级别更改为`DEBUG`后，控制台输出将现在显示所有日志消息：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Although we discussed the default or root logger in this subsection, it is not
    recommended to use it other than for basic logging purposes. As a best practice,
    we should create a new logger with a name, which we will discuss in the next code
    examples.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本小节中讨论了默认或根日志记录器，但不建议除了基本日志记录目的之外使用它。作为一个最佳实践，我们应该创建一个新的具有名称的日志记录器，我们将在下一个代码示例中讨论。
- en: Using a named logger
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命名日志记录器
- en: 'We can create a separate logger with its own name and possibly with its own
    log level, handlers, and formatters. The next code snippet is an example of creating
    a logger with a custom name and also using a different logging level than the
    root logger:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个具有自己名称的单独日志记录器，可能还有自己的日志级别、处理程序和格式化程序。下面的代码片段是创建具有自定义名称的日志记录器并使用与根日志记录器不同的日志级别的示例：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When we create a logger instance using the `getLogger` method with a string
    name or using the module name (by using the `__name__` global variable), then
    only one instance is managed for one name. This means if we try to use the `getLogger`
    method with the same name in any part of the application, the Python interpreter
    will check whether there is already an instance created for this name. If there
    is already one created, it will return the same instance.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`getLogger`方法通过字符串名称或使用模块名称（通过使用`__name__`全局变量）创建日志记录器实例时，对于每个名称只管理一个实例。这意味着如果我们尝试在任何应用程序的部分使用具有相同名称的`getLogger`方法，Python解释器将检查是否已经为该名称创建了一个实例。如果已经创建了一个实例，它将返回相同的实例。
- en: 'After creating a logger instance, we need to make a call to the root logger
    (`basicConfig()`) to provide a handler and formatter to our logger. Without any
    handler configuration, we will get an internal handler as the last resort, which
    will only output messages without any formatting and the logging level will be
    `WARNING` regardless of the logging level we set for our logger. The console output
    of this code snippet is shown next, and it is as expected:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建日志记录器实例后，我们需要调用根日志记录器（`basicConfig()`）来为我们自己的日志记录器提供一个处理程序和格式化程序。如果没有任何处理程序配置，我们将得到一个内部处理程序作为最后的手段，这将只输出未格式化的消息，并且日志级别将默认为`WARNING`，而不管我们为日志记录器设置的日志级别是什么。下面的代码片段的控制台输出如下，符合预期：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is also important to note the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意以下几点：
- en: We set the logging level for our logger to `INFO` and we were able to log `warning`
    and `info` messages but not the debug message.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将日志记录器的日志级别设置为`INFO`，这样我们就可以记录`warning`和`info`消息，但不能记录调试消息。
- en: When we used the root logger (by using the `logging` instance), we were not
    able to send out the `info` message. This was because the root logger was still
    using the default logging level, which is `WARNING`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用根日志记录器（通过使用`logging`实例）时，我们无法发送出`info`消息。这是因为根日志记录器仍在使用默认的日志级别，即`WARNING`。
- en: Using a logger with a built-in handler and custom formatter
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用具有内置处理程序和自定义格式化程序的日志记录器
- en: 'We can create a logger object using a built-in handler but with a custom formatter.
    In this case, the handler object can use a custom formatter object and the handler
    object can be added to the logger object as its handler before we start using
    the logger for any log events. Here is a code snippet to illustrate how to create
    a handler and a formatter programmatically and then add the handler to the logger:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内置的处理器创建一个日志记录器对象，但带有自定义的格式化器。在这种情况下，处理器对象可以使用自定义的格式化器对象，并且在我们开始使用日志记录器进行任何日志事件之前，可以将处理器对象添加到日志记录器对象中作为其处理器。以下是一个代码片段，说明如何程序化地创建处理器和格式化器，然后将处理器添加到日志记录器中：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can create a logger with the same settings by using the `basicConfig` method
    as well with appropriate arguments. The next code snippet is a revised version
    of `logging3.py` with the `basicConfig` settings:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用`basicConfig`方法并传递适当的参数来创建具有相同设置的日志记录器。下一个代码片段是`logging3.py`的修订版，其中包含了`basicConfig`设置：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Up till now, we have covered cases where we used built-in classes and objects
    to set up our loggers. Next, we will set up a logger with custom handlers and
    formatters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了使用内置类和对象设置日志记录器的情况。接下来，我们将设置一个具有自定义处理器和格式化器的日志记录器。
- en: Using a logger with a file handler
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用具有文件处理器的日志记录器
- en: 'The logging handler sends the log messages to their final destination. By default,
    every logger is set up to send log messages to the console or terminal associated
    with the running program. But this can be changed by configuring a logger with
    a new handler with a different destination. A file handler can be created by using
    one of the two approaches we already discussed in the previous subsection. In
    this section, we will use a third approach to create a file handler automatically
    with the `basicConfig` method by providing the filename as an attribute to this
    method. This is shown in the next code snippet:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 日志处理器将日志消息发送到它们的最终目的地。默认情况下，每个日志记录器都配置为将日志消息发送到与运行程序关联的控制台或终端。但可以通过配置一个具有不同目的地的新的处理器来更改这一点。可以通过使用我们在前一小节中讨论的两种方法之一来创建一个文件处理器。在本节中，我们将使用第三种方法，通过将文件名作为属性传递给`basicConfig`方法来自动创建一个文件处理器。这将在下一个代码片段中展示：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will generate log messages to the file we specified with the `basicConfig`
    method and as per the logging level, which is set to `INFO`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成日志消息，这些消息将按照`basicConfig`方法指定的文件和日志级别（设置为`INFO`）生成。
- en: Using a logger with multiple handlers programmatically
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用程序化方式使用具有多个处理器的日志记录器
- en: 'Creating a logger with multiple handlers is pretty straightforward and can
    be achieved either by using the `basicConfig` method or by attaching handlers
    manually to a logger. For illustration purposes, we will revise our code example
    `logging3.py` to do the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有多个处理器的日志记录器相当简单，可以通过使用`basicConfig`方法或手动将处理器附加到日志记录器来实现。为了说明目的，我们将修订我们的代码示例`logging3.py`以执行以下操作：
- en: We will create two handlers (one for the console output and one for the file
    output) that are instances of the `streamHandler` and `fileHandler` classes.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建两个处理器（一个用于控制台输出，一个用于文件输出），它们是`streamHandler`和`fileHandler`类的实例。
- en: We will create two separate formatters, one for each handler. We will not include
    the time information for the formatter of the console handler.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建两个单独的格式化器，每个处理器一个。我们将不包括控制台处理器的格式化器中的时间信息。
- en: We will set separate logging levels for the two handlers. It is important to
    understand that the logging level at the handler level cannot override the root
    level handler.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为两个处理器设置不同的日志级别。重要的是要理解，处理器级别的日志级别不能覆盖根级别的处理器。
- en: 'Here is the complete code example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整的代码示例：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Although we set different logging levels for the two handlers, which are `INFO`
    and `DEBUG`, they will be effective only if the logging level of the logger is
    at a lower value (the default is `WARNING`). This is why we have to set the logging
    level for our logger to `DEBUG` at the beginning of the program. The logging level
    at the handler level can be `DEBUG` or any higher level. This is a very important
    point to consider whenever designing a logging strategy for your application.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们为两个处理器设置了不同的日志级别，分别是`INFO`和`DEBUG`，但它们只有在日志记录器的日志级别较低（默认为`WARNING`）时才会生效。这就是为什么我们必须在程序开始时将日志级别设置为`DEBUG`。处理器的日志级别可以是`DEBUG`或任何更高的级别。这是一个在设计应用程序的日志策略时需要考虑的非常重要的点。
- en: In the code example shared in this section, we basically configured the logger
    programmatically. In the next section, we will work on how to configure a logger
    through a configuration file.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中共享的代码示例中，我们基本上是程序化地配置了日志记录器。在下一节中，我们将讨论如何通过配置文件配置日志记录器。
- en: Configuring a logger with multiple handlers using a configuration file
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用配置文件配置具有多个处理器的日志记录器
- en: 'Setting up a logger programmatically is appealing but not practical for production
    environments. In production environments, we have to set up the logger configuration
    differently as compared to the development setup and sometimes we have to enhance
    the logging level to troubleshoot problems that we encounter only in live environments.
    This is why we have the option of providing the logger configuration through a
    file that is easy to change as per the target environment. The configuration file
    for a logger can be written using `.conf` file. For illustration purposes, we
    will demonstrate the logger configuration using a YAML file, which is exactly
    the same as we achieved programmatically in the previous section. The complete
    YAML file and the Python code is as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化设置日志记录器很有吸引力，但在生产环境中并不实用。在生产环境中，我们必须以与开发设置不同的方式设置日志记录器配置，有时我们还需要提高日志级别来调试仅在实时环境中遇到的故障。这就是为什么我们提供了通过文件提供日志记录器配置的选项，该文件可以根据目标环境轻松更改。日志记录器的配置文件可以使用`.conf`文件编写。为了说明目的，我们将使用YAML文件演示日志记录器配置，这与我们在上一节中程序化实现的结果完全相同。完整的YAML文件和Python代码如下：
- en: 'The following is the YAML config file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个YAML配置文件：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following is the Python program using the YAML file to configure the logger:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用YAML文件配置日志记录器的Python程序：
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To load config from a file, we used the `dictConfig` method instead of the `basicConfig`
    method. The outcome of the YAML-based logger configuration is exactly the same
    as we achieved with Python statements. There are other additional configuration
    options available for a full-featured logger.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中加载配置，我们使用了`dictConfig`方法而不是`basicConfig`方法。基于YAML的日志配置结果与我们使用Python语句实现的结果完全相同。对于功能齐全的日志记录器，还有其他一些额外的配置选项可用。
- en: In this section, we presented different scenarios of configuring one or more
    logger instances for an application. Next, we will discuss what type of events
    to log and what not to log.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了为应用程序配置一个或多个日志记录器实例的不同场景。接下来，我们将讨论应该记录哪些事件以及不应该记录哪些事件。
- en: What to log and what not to log
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录什么以及不记录什么
- en: 'There is always a debate about what information we should log and what not
    to log. As a best practice, the following information is important for logging:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 总是会有关于我们应该记录什么信息以及不应该记录什么信息的争论。作为最佳实践，以下信息对于记录来说很重要：
- en: An application should log all errors and exceptions and the most appropriate
    way is to log these events at the source module.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该记录所有错误和异常，最合适的方式是在源模块中记录这些事件。
- en: Exceptions that are handled with an alternative flow of code can be logged as
    warnings.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将使用替代代码流处理的异常记录为警告。
- en: For debugging purposes, entry and exit to a function is useful information for
    logging.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了调试目的，记录函数的进入和退出是有用的信息。
- en: It is also useful to log decision points in the code because it can be helpful
    for troubleshooting.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录代码中的决策点也是有用的，因为这有助于故障排除。
- en: The activities and actions of users, especially related to the access of certain
    resources and functions in the application, are important to log for security
    and auditing purposes.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的活动和动作，特别是与应用程序中某些资源和方法访问相关的活动，对于安全和审计目的来说，记录这些信息很重要。
- en: When logging messages, the context information is also important, which includes
    the time, logger name, module name, function name, line number, logging level,
    and so on. This information is critical for identifying the route cause analysis.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录消息时，上下文信息也很重要，包括时间、记录器名称、模块名称、函数名称、行号、记录级别等。这些信息对于识别根本原因分析至关重要。
- en: A follow-up discussion on this topic is what not to capture for logging. We
    should not log any sensitive information such as user ID, email address, passwords,
    and any private and sensitive data. We should also avoid logging any personal
    and business record data such as health records, government-issued document details,
    and organization details.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个话题的后续讨论是关于不应该捕获哪些信息进行记录。我们不应该记录任何敏感信息，例如用户ID、电子邮件地址、密码以及任何私人敏感数据。我们还应该避免记录任何个人和商业记录数据，例如健康记录、政府颁发的文件细节和组织细节。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed a variety of topics that require the use of advanced
    Python modules and libraries. We started by refreshing our knowledge about data
    containers in Python. Next, we learned how to use and build iterators for iterable
    objects. We also covered generators, which are more efficient and easier to build
    and use than iterators. We discussed how to open and read from files and how to
    write to files, followed by the use of a context manager with files. In the next
    topic, we discussed how to handle errors and exceptions in Python, how to raise
    exceptions through programming, and how to define custom exceptions. Exception
    handling is fundamental to any decent Python application. In the last section,
    we covered how to configure the logging framework in Python using different options
    for handlers and formatters.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了需要使用高级Python模块和库的各种主题。我们首先刷新了关于Python中数据容器知识的记忆。接下来，我们学习了如何使用和构建可迭代对象的迭代器。我们还介绍了生成器，它比迭代器更高效、更容易构建和使用。我们讨论了如何打开和读取文件，以及如何写入文件，随后讨论了与文件一起使用上下文管理器。在下一个主题中，我们讨论了如何在Python中处理错误和异常，如何通过编程引发异常，以及如何定义自定义异常。异常处理是任何优秀的Python应用程序的基础。在最后一节中，我们介绍了如何使用不同的处理器和格式化选项配置Python中的日志框架。
- en: After going through this chapter, you now know how to build your own iterators
    and design generator functions to iterate on any iterable object, and how to handle
    files, errors, and exceptions in Python. You have also learned how to set up loggers
    with one or more handlers to manage the logging of an application using different
    logging levels. The skills you have learned in this chapter are key to building
    any open source or commercial applications.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完这一章后，你现在知道如何构建自己的迭代器，设计生成器函数以迭代任何可迭代对象，以及如何在Python中处理文件、错误和异常。你还学习了如何使用一个或多个处理器设置日志记录器，以使用不同的日志级别来管理应用程序的日志记录。本章中你学到的技能对于构建任何开源或商业应用程序都是关键。
- en: In the next chapter, we will switch our focus to how to build and automate unit
    tests and integration tests.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把重点转向如何构建和自动化单元测试和集成测试。
- en: Questions
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a list and a tuple?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表和元组之间的区别是什么？
- en: Which Python statement will always be used when working with a context manager?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用上下文管理器时，哪个Python语句总是会使用？
- en: What is the use of the `else` statement with the `try-except` block?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try-except`块中使用`else`语句有什么用？
- en: Generators are better to use than iterators. Why?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么生成器比迭代器更好用？
- en: What is the use of multiple handlers for logging?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志记录中使用多个处理器有什么用？
- en: Further reading
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Fluent Python* by Luciano Ramalho'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Luciano Ramalho 著的《*流畅的Python*》
- en: '*Advanced Guide to Python 3 Programming* by John Hunt'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: John Hunt 著的《*Python 3 编程高级指南*》
- en: '*The Python 3 Standard Library by Example* by Doug Hellmann'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Doug Hellmann 著的《*Python 3 标准库实例教程*》
- en: '*Python 3.7.10 documentation* ([https://docs.python.org/3.7/](https://docs.python.org/3.7/))'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*Python 3.7.10 文档*》（[https://docs.python.org/3.7/](https://docs.python.org/3.7/)))
- en: To learn more about additional options available for configuring a logger, you
    can refer to the official Python documentation at [https://docs.python.org/3/library/logging.config.html](https://docs.python.org/3/library/logging.config.html)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要了解更多关于配置日志记录器的选项，您可以参考官方Python文档，链接为[https://docs.python.org/3/library/logging.config.html](https://docs.python.org/3/library/logging.config.html)
- en: Answers
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A list is a mutable object whereas a tuple is immutable. This means we can update
    a list after creating it. This is not true for tuples.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表是一个可变对象，而元组是不可变的。这意味着我们可以在创建列表后更新它。对于元组来说，这并不成立。
- en: The `with` statement is used with a context manager.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`with`语句与上下文管理器一起使用。'
- en: The `else` block is executed only when the code in the `try` block is executed
    without any error. A follow-up action can be coded in the `else` block once the
    core functionality is executed without any problem in the `try` block.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当`try`块中的代码执行没有错误时，才会执行`else`块。一旦在`try`块中成功执行核心功能而没有问题，就可以在`else`块中编写后续操作。
- en: Generators are efficient in memory and also easy to program as compared to iterators.
    A generator function automatically provides an `iterator` instance and the `next`
    function implementation out of the box.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与迭代器相比，生成器在内存效率上更高，编程也更容易。生成器函数自动提供一个`iterator`实例和`next`函数的实现。
- en: The use of multiple handlers is common because one handler usually focuses on
    one type of destination. If we need to send log events to multiple destinations
    and perhaps with different priority levels, we will need multiple handlers. Also,
    if we need to log messages to multiple files with different logging levels, we
    can create different file handlers to coordinate with multiple files.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多个处理器很常见，因为通常一个处理器专注于一种目标类型。如果我们需要将日志事件发送到多个目的地，并且可能具有不同的优先级级别，我们将需要多个处理器。此外，如果我们需要将消息记录到多个文件中，并且具有不同的日志级别，我们可以创建不同的文件处理器来与多个文件协调。
