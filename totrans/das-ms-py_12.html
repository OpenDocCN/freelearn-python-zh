<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Extension Modules and Compiled Code</h1>
                </header>
            
            <article>
                
<p>In this chapter, we'll discuss how to integrate compiled code into Python programs. We'll take a look at the benefits and drawbacks of our compiled code and see two ways of making a connection between Python's managed environment and code that runs directly on the hardware.</p>
<p>We'll see how to use the <kbd>ctypes</kbd> package and tie it to the interface of a C dynamic library, calling its functions and receiving their output from within our Python code. We'll also look at an easy way to write compiled code modules so that they could be imported and called directly from Python.</p>
<p>We'll cover the following topics in detail:</p>
<ul style="padding-left: 5px">
<li>Advantages and disadvantages of compiled code</li>
<li>Accessing a dynamic library using <kbd>ctypes</kbd></li>
<li>Interfacing with C code using Cython<br/></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advantages and disadvantages of compiled code</h1>
                </header>
            
            <article>
                
<p>There are many real advantages of using compiled code. Python is a very productive language, but it may not fulfil the requirements of a lot of people. Sometimes, we need to interface with code written in a different language. One reason for doing this would be in case we need to access some functionality that is written in a different language that doesn't exist in Python.</p>
<p>As long as the code in question is in a dynamic library that has a C-compatible interface, it's relatively easy to call the code from within Python, using the <strong>Foreign Function Interface</strong> (<strong>FFI</strong>) provided by Python's standard ctypes package, which we'll discuss in the next section.</p>
<p>Alternatively, we may need to write some code that runs <strong>Close to Metal</strong> (<strong>CTM</strong>), either to maximize the performance of an algorithm that's proven to be a bottleneck in our project, or interface directly with some piece of hardware. In this case, we'll need to compile custom code and link it to the Python environment. You can easily do this using a tool called <strong>Cython</strong> (for more details, refer to <span class="URLPACKT">cython.org</span>), which we'll discuss in the third section of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The downsides of compiled code</h1>
                </header>
            
            <article>
                
<p>While working with compiled code is usually absolutely fine, there can be some significant downsides. Let's take a look at them:</p>
<ul style="padding-left: 5px">
<li>First and foremost is the fact that it's easy to create ridiculously weird bugs when we work at this level of compiled code. Both <kbd>ctypes</kbd> and Cython allow us to make a horrible mess in the program's memory, potentially producing any conceivable kind of bug or error. The following diagram illustrates an example of a potential low-level bug. You can imagine how difficult it would be to troubleshoot such bugs.</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img height="221" width="497" class="aligncenter size-full wp-image-485 image-border" src="assets/2b4fc3be-18a6-41bb-a1c7-02de4a733dd1.jpg"/></div>
<p style="padding-left: 60px">If we're lucky, that bug or error would result in a flat-out termination of our program, that is, if it violates the constraints of the operating system's protected memory manager.</p>
<div class="packt_infobox">I say we'll be lucky because if that doesn't happen, it would mean we've made an effective random change to some part of our program state and who knows what that'll do.</div>
<ul style="padding-left: 5px">
<li>The second downside is that it makes distributing our program more difficult. For a normal Python program, we can distribute a single <kbd>.pyz</kbd> file to our users or upload a set of tools, a compatible source package, or a neutral operating system wheel file to the <strong>Python Package Index</strong> (<strong>PyPI</strong>). Using compiled code means we have to worry about which operating system and hardware architecture our users employ and provide separate packages for each combination we want to support.</li>
<li>The third downside only applies if we're writing our own compiled code primarily for those use cases where Cython is most useful. The problem is that it could be complex to actually get a compiler installed and working, particularly for people who aren't used to working with compilers. Not only that, if we distribute our project as source code, our users would need to go through the same hassle.</li>
</ul>
<p style="padding-left: 90px">Between the danger of bizarre errors and the annoyance involved in creating and distributing projects that use compiled code, we should generally wait until we have a compelling reason for taking the step of creating or interfacing with compiled code.</p>
<p>Now we have a pretty good grasp of the benefits of interfacing with compiled code: it gives us access to C-compatible libraries written in other languages. This code lets us optimize the performance of critical algorithms, and it lets us interface directly with hardware or low-level drivers.</p>
<p>Similarly, we know what the drawbacks are, namely the potential and seemingly inexplicable errors and a generally higher level of annoyance and difficulty throughout the development and distribution process. Now, let's take a look at putting some of the knowledge we've gained into action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing a dynamic library using ctypes</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to narrow down our focus to the Python standard library's <kbd>ctypes</kbd> package, which allows us to interact with dynamic libraries from within Python.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Locating and linking a dynamic library</h1>
                </header>
            
            <article>
                
<p>Probably, the most common need to interact with compiled code is when there's a library out there that does exactly what we need but it's not a Python library. Perhaps it was instead written for C, or it has a C interface.</p>
<p>We're not going to let a little thing like this stop us. Instead, we'll use <kbd>ctypes</kbd> to create an interface module for the library. For basic usage, <kbd>ctypes</kbd> is very simple. We just need to import it, load the dynamic library by the filename, and call a function in that library as shown in the following code example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="66" width="418" class=" image-border" src="assets/29920012-1239-4850-a3cf-9be51f1630ea.png"/></div>
<p>The <kbd>CDLL</kbd> constructor we called in this example creates a Python object that represents a dynamic library containing C functions. We do need to take care when we define the filename of the library here, because of course different operating systems have different naming conventions for their libraries. The <kbd>libc.so.6</kbd> attribute, in our example here, is the filename of the C standard library on current versions of Linux.</p>
<p>The <kbd>ctypes</kbd> package includes a utility function, called <kbd>ctypes.util.find_library</kbd>, to help address this difficulty. If we pass a base name to <kbd>find_library</kbd>, it will try to find the full name of the version installed on the system, as shown in the following code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="62" width="251" class="aligncenter size-full wp-image-486 image-border" src="assets/bc077a2d-e201-45ab-98c2-6bc681198989.png"/></div>
<div class="packt_infobox">The <kbd>ctypes.util.find_library</kbd> is pretty useful on Linux and Mac OS X but less so on Windows because Windows dynamic libraries handle multiple versions in a very different way.<br/>
It's also worth noting that when we pass the C string to <kbd>find_library</kbd>, we'll find the C standard library on Linux and Mac OS X. On Windows, the same library is rather arbitrarily called <kbd>msvcrt</kbd>.</div>
<p>For cross-platform library loading, we need to be able to specify several alternate names for the library; try <kbd>find_library</kbd> on these names (refer to the following code example) and fall back to trying the raw name if <kbd>find_library</kbd> fails.</p>
<div class="CDPAlignCenter CDPAlign"><img height="184" width="466" class="aligncenter size-full wp-image-774 image-border" src="assets/f76438bd-e701-4259-bf81-964332dc115a.jpg"/></div>
<p>There's a <kbd>load_library</kbd> function in the <kbd>demo_ctype/libc.py</kbd> file, available with this book, which also demonstrates this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing functions defined in the library</h1>
                </header>
            
            <article>
                
<p>Once we have the library loaded, we have access to the functions exported from that library, which are exposed as attributes of the library object in Python. We saw this in the previous section when we called C's <kbd>printf</kbd> function.</p>
<p>Now, it's important to know that there's nothing in the C shared library that tells the users of the library what the parameter types of a function are, or the return type, or even how many parameters the function has. This information is used when compiling the library, but it isn't part of the end result. This means it's up to us to know how the function is supposed to be used. For example, the C library contains a quick sort function called <kbd>qsort</kbd>, which is intended to accept several parameters. Let's see what happens if these parameters aren't provided:</p>
<div class="CDPAlignCenter CDPAlign"><img height="50" width="275" class="aligncenter size-full wp-image-488 image-border" src="assets/c9fa4089-cc8e-43c6-b8dd-80fb3acaeb0d.png"/></div>
<p>As you can see in the preceding code example, if we omit the parameters, <kbd>ctypes</kbd> has no way of knowing whether we're making a mistake, and bad things happen with no warning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Assigning attributes to a function</h1>
                </header>
            
            <article>
                
<p>If we're planning on making systematic use of a foreign function, or especially, if we're going to expose it as part of the interface of a module we're writing, it is advisable to tell <kbd>ctypes</kbd> about the function's signature. We can do this by assigning to the function's <kbd>argtypes</kbd> and <kbd>restype</kbd> attributes.</p>
<p>The <kbd>argtypes</kbd> attribute should be a list of C data types defined in the <kbd>ctypes</kbd> package, while <kbd>restype</kbd> should be one of these packages, as shown in the following code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="227" width="425" class="aligncenter size-full wp-image-489 image-border" src="assets/c0d0b711-7cb8-46cc-8d96-2b9811eb23d2.png"/></div>
<p>As you can see in the code, providing this information to <kbd>ctypes</kbd> significantly improves the error handling of a foreign function. The <kbd>atof</kbd> function returns a double-precision floating point number, but <kbd>ctypes</kbd> wouldn't know about this if we don't tell it so. When <kbd>ctypes</kbd> doesn't have the information, it just assumes the return value is an integer; this works in many cases, but it would have been useless in this particular example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a pointer as a parameter of a function</h1>
                </header>
            
            <article>
                
<p>It's pretty common for C functions to accept a pointer as one of the parameters and fill in a value at the address that the pointer refers to. Naturally, <kbd>ctypes</kbd> allows us to work with this sort of interface by letting us create objects that represent memory locations and passing that object using the pointer to the functions we call. The C <kbd>scanf</kbd> function works in a way that can be illustrated by the following code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="137" width="460" class="aligncenter size-full wp-image-490 image-border" src="assets/93dd9490-e720-4ed1-8004-241ce57244b1.png"/></div>
<p>In this example, we created two C-style variables called <kbd>integer</kbd> and <kbd>decimal</kbd>; then, we used the <kbd>scanf</kbd> function to fill them with values, based on user input. The <kbd>byref</kbd> function tells <kbd>ctypes</kbd> that we're not passing the value of the variable to the function, but that we're passing its memory address, so the function can store something there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing a function signature</h1>
                </header>
            
            <article>
                
<p>Another common behavior of C functions is filling bytes into a character buffer. We can use the <kbd>create_string_buffer</kbd> function of <kbd>ctypes</kbd> to allocate such a buffer and then use the result as a parameter for functions that want a string buffer, as shown in the following code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="179" width="456" class="aligncenter size-full wp-image-775 image-border" src="assets/83920145-3f04-4102-b75f-8d56f95971d2.jpg"/></div>
<p>Let's look at this code now. We do not need to use the <kbd>byref</kbd> function here, because the character bumper is inherently by reference. There's just no other way to do this in C.</p>
<p>There's a pitfall here: one that's been tripping up C programmers for decades. Our string buffer has a specific length, but the function we're passing to it doesn't know what that length is. If it starts writing to the buffer and continues beyond the end of the buffer, the program will either crash or begin behaving strangely. Always make sure your buffer is at least large enough for whatever will be written into it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing data structure layouts</h1>
                </header>
            
            <article>
                
<p>Another thing that is not available in a C shared library is the layout of data structures that the functions use, as shown in the following code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="252" width="431" class="aligncenter size-full wp-image-991 image-border" src="assets/b281248c-613f-428e-8c85-f05892d01c77.png"/></div>
<p>Again, <kbd>ctypes</kbd> gives us a way of filling in the missing information. C's <kbd>tm</kbd> structure, which is used for representing date and time information, looks like the following code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="330" width="333" class="aligncenter size-full wp-image-776 image-border" src="assets/0b1b9abc-58d4-47a5-b372-a16f6ee0c392.jpg"/></div>
<p>As shown in this example, the translation into <kbd>ctypes</kbd> is straightforward. We need to create a class that would inherit from <kbd>ctypes.Structure</kbd>, and in that class, we need to create a list called <strong>fields</strong> containing tuples of field name and field type.</p>
<p>Once we get this, we could create instances of the class and assign the attributes as we'd expect in Python. But, we can also pass it to C functions as a parameter, either directly or by reference, and we can use it as part of the signature of a foreign function.</p>
<p>The <kbd>ctypes</kbd> package provides support for pretty much every feature of the C language, but we've now seen the ones that are most useful for calling into a library function and using its results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interfacing with C code using Cython</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to look at a third-party tool called Cython, which is another tool for bridging the gap between Python and the software that has been compiled into machine code.</p>
<p>If we have a situation where we want to implement part of our project in compiled code, we could do this by creating a dynamic library containing the code and calling to it with <kbd>ctypes</kbd>; however, that's a roundabout way to get where we want to go. We'd end up writing a lot of code twice: once for the sake of our compiler and then again to tell <kbd>ctypes</kbd> about details such as function signatures and data structures.</p>
<p>Now this is inefficient and violates one of the most important principles of programming—<em>don't repeat yourself</em>. There's a tool that's better suited to this situation, as you may have surely guessed, and that tool is Cython.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Cython</h1>
                </header>
            
            <article>
                
<p>What Cython does is it translates a Python source code file into a C source code file containing equivalent calls to the Python C API; then it wraps it in the boilerplate necessary to turn it into a Python binary module.</p>
<p>This would be useful enough by itself, but Cython also allows us to inject calls in C functions and low-level data access operations into the module. The end result is that we could pretty much just write our compiled code as if it were Python and still gain the speed or low-level access that prompted our need to compile it in the first place.</p>
<p>The amount of work this saves us over using the Python API directly is considerable. The 100-line Python example included with this course translates into more than 5,000 lines of C when compiled. Let's go through this example piece by piece and talk about the differences while comparing it with plain Python.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional import methods in Cython</h1>
                </header>
            
            <article>
                
<p>Cython allows two import mechanisms in addition to the normal ones provided by Python packages. Let's check out these mechanisms in detail.</p>
<p>The first mechanism is called <kbd>cimport</kbd>, and it imports the signatures of compiled functions and data structures from pre-prepared libraries, as shown in the following command line:</p>
<pre>
from cpython.mem cimport PyMem_Malloc, PyMem_Realloc, PyMem_Free 
</pre>
<p>In this case, since Cython comes with a pre-prepared library of all Python C API functions, we were able to use this mechanism to report the needed information about Python's low-level memory allocation and de-allocation functions.</p>
<p>The second additional importing mechanism is <kbd>cdef extern from</kbd>. When we don't already have the signature of a compiled function available, we use the syntax to make it available in the Cython code.</p>
<p>The indented block can contain any number of function declarations, type definitions, structure definitions, and so on, as shown in the following code example. Note that these don't need to be precisely correct, though, just close enough that Cython is able to generate proper C code:</p>
<pre>
cdef extern from "string.h": 
    void *memcpy(void *str1, const void *str2, size_t n) 
</pre>
<p>A <kbd>cdef extern from</kbd> block references a C header file, which is automatically included in the generated C code. While we could simply use the normal Python syntax for the <kbd>class</kbd> statement, prepending it with <kbd>cdef</kbd> gives the ability to store raw data values in predefined variable members of the class instances, as shown in the following code example:</p>
<pre>
cdef class StatisticalArray: 
    cdef double* values 
    cdef int num_values 
    cdef int max_values 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing extension modules in Cython</h1>
                </header>
            
            <article>
                
<p>The <kbd>num_values</kbd> variable in the previous code example is just a chunk of memory that stores bits that represent an integer value. It doesn't have any of the extra data needed to turn it into a Python object.</p>
<div class="packt_infobox">This is a bad thing in a way because it means that Python can't do any of the smart things it does to help us write good code quickly.We wouldn't be working with these tools if we didn't have a reason to let them do some of this work for us.</div>
<p>So, to resolve this, let's define an extension type called <kbd>StatisticalArray</kbd> (refer to the following code example), which contains a pointer to a memory location and two integers. The memory location is supposed to contain double-precision floating point numbers. These are raw machine-level values, and while primitive in comparison to Python values, they're very fast because they can be fed directly into CPU operations.</p>
<div class="CDPAlignCenter CDPAlign"><img height="256" width="817" class="aligncenter size-full wp-image-987 image-border" src="assets/a448ad99-a805-4d80-87fa-afe00b53595c.png"/></div>
<p>In this code example, we have the functions that set up and dispose of the instances of the <kbd>StatisticalArray</kbd> class.</p>
<p>Notice that the setup function is called <kbd>__cinit__</kbd>, not <kbd>__init__</kbd>. Actually, a Cython <kbd>cdef</kbd> class can have both. The <kbd>__cinit__</kbd> function's job is to set up the raw variables for the class instance, and the normal <kbd>__init__</kbd> function is supposed to set up any normal Python variable it contains.</p>
<p>The <kbd>__cinit__</kbd> function is called first, and it's not guaranteed that <kbd>self</kbd> will actually be a valid Python object itself yet, so it should confine itself only to initializing raw variables. The reason <kbd>__cinit__</kbd> accepts the extra positional and keyword arguments is because if a Python class inherits from our class and adds more parameters to the signature of <kbd>__init__</kbd>, the <kbd>__cinit__</kbd> function will still work.</p>
<p>At the other end of the process, we have the <kbd>__dealloc__</kbd> function, which needs to release any specially allocated resources associated with the class instance. In the preceding case, we allocated a chunk of memory to <kbd>__cinit__</kbd>, so we need to release that memory in the <kbd>__dealloc__</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Methods to increase the execution speed of Python code</h1>
                </header>
            
            <article>
                
<p>Now we are going to define a few of Python's normal magic methods, which will allow us to iterate over the values stored in our object and access them by indexing. For this, refer to the following code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="311" width="480" class="image-border" src="assets/0a066dd8-c2f1-4181-a922-329200742b2c.jpg"/><br/></div>
<p>The thing to notice in this code example is how little has changed from what we've be doing in a pure Python implementation. The only real differences are the type definitions we provided for every parameter and the local variable.</p>
<div class="packt_infobox">We didn't actually have to provide the type definition for every parameter and local variable. The type definition lets Cython generate plain C code for a lot of the operations we're performing, which means we're using the CPU directly instead of the Python virtual machine. We're trading flexibility for speed.</div>
<p>The previous functions were all defined with the <kbd>def</kbd> keyword as normal for Python, and these functions operate as if they were defined in a normal Python module.</p>
<p>Cython gives us two other options, though. Instead of <kbd>def</kbd>, we can use <kbd>cdef</kbd>; in this case, the function is much faster to call, but it's only for use by other Cython code. This is great for internal help functions and such. Alternatively, we can use <kbd>cpdef</kbd> (as shown in the following code example); here, the function is accessible from normal Python, but it's almost as fast as a <kbd>cdef</kbd> function when called from Cython code:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/0811f2f0-ea0e-4629-8e8c-f689c17f9307.jpg"/></div>
<p>We've chosen <kbd>cpdef</kbd> in our case because we want to expose the full feature set to any Python code that uses our compiled module, but we also expect to use the same functionality from within our Cython code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using cpdef in a Cython class</h1>
                </header>
            
            <article>
                
<p>In the following code example, you'll see that we're getting to the reason why we called our class <kbd>StatisticalArray</kbd>. We implemented several discrete statistical calculations using the values stored in the class instance. You don't need to worry about what <kbd>mean</kbd>, <kbd>variance</kbd>, and <kbd>covariance</kbd> actually do, but let's take a look at how they're actually working.</p>
<div class="CDPAlignCenter CDPAlign"><img height="434" width="734" class="image-border" src="assets/61fb2050-6029-4d72-b036-d84f3701b98d.jpg"/></div>
<p>In the <kbd>mean</kbd> function, here, we see a loop that calculates the sum of the values stored in the array. If we were running that code in Python, each cycle through the loop would involve several dictionary lookups and function calls. Cython generates four lines of C code for this that translates into only a few machine code operations.</p>
<p>This is possible because we told Cython that the <kbd>index</kbd> variable should be a C integer, and because Cython is smart about handling loops with C integer variables, we gain a similar benefit in both <kbd>variance</kbd> and <kbd>covariance</kbd> functions. Again, we just use the Python syntax and give Cython additional information that it can use to optimize the generated code.</p>
<p>There is one unusual thing to note with <kbd>covariance</kbd>, though. At the end of the first line shown in the following screenshot, we see <kbd>except? -200.0</kbd>:</p>
<pre>
cpdef double covariance(StatisticalArray self, Statistical other) except? -200.0 
</pre>
<p>What is that? Well, as with most of these functions, we gave the <kbd>covariance</kbd> function an explicit C return type of <kbd>double</kbd>. That's a big gain in terms of speed. But when the code calling the function is also Cython, and stores the return value in a <kbd>cdef</kbd> double variable, there's a downside. Normally, Cython would use the return value to signal that an exception has been raised, but how is it supposed to do that when we have changed the return type, since it cannot know which values are valid at that point?</p>
<p>Well, we'll tell it. Adding <kbd>except? -200.0</kbd> means that if the return value is <kbd>-200</kbd>, Cython would check to see whether an exception has been raised. If we had left off <kbd>?</kbd>, it would have meant that <kbd>-200</kbd> always means there's an exception, which is a bit faster; however, we can't go that far because <kbd>-200</kbd> is still a potentially valid return variable.</p>
<p>Notice that we don't actually return <kbd>-200</kbd>; we just raise an exception as normal. Cython takes care of the rest. Here are a couple of more examples of functions that are built using the earlier functions as building blocks:</p>
<div class="CDPAlignCenter CDPAlign"><img height="110" width="847" class="aligncenter size-full wp-image-778 image-border" src="assets/542ca636-39ff-4cf1-833d-4b5786a3bc6f.jpg"/></div>
<p>Thanks to our use of <kbd>cpdef</kbd>, when we define the <kbd>variance</kbd> and <kbd>covariance</kbd> functions, there's very little overhead involved in calling those functions from here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling an extension module in Python</h1>
                </header>
            
            <article>
                
<p>So let's say we've written a somewhat useful Cython class; now, how do we make it available to Python code? Well, we have to compile it.</p>
<p>First of all, this means we need to have a compiler. The documentation on <span class="URLPACKT">cython.org</span> has a tutorial entry and appendix on this process, and I suggest you refer to them if there's not already a compiler on your system. If you have a compiler, installing Cython is just a matter of asking <kbd>pip</kbd> to grab it for us:</p>
<pre>
<strong>python3.5 -m pip install Cython</strong>
</pre>
<p>The installation can be a little slow because it needs to do some compiling during the installation; just be patient until it finishes.</p>
<p>Once Cython is installed, we need to create a <kbd>setup.py</kbd> file describing how to build our extension, as shown in the following code example. For the base case, the process is very straightforward.</p>
<p>The source code we were working on is saved in <kbd>statistics.pyx</kbd>, as shown in the following code example. The <kbd>.pyx</kbd> extension is the standard filename extension for Cython source code files.</p>
<div class="CDPAlignCenter CDPAlign"><img height="105" width="344" class="aligncenter size-full wp-image-779 image-border" src="assets/0e532917-be58-443e-af3c-a21f42070c91.jpg"/></div>
<p>Once we do this, the last step is a snap. Once the <kbd>build_ext</kbd> command is finished, we should have a compiled extension sitting next to our <kbd>.pyx</kbd> file.</p>
<p>Now, all we have to do is import it and use it as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="460" width="976" class="aligncenter size-full wp-image-1110 image-border" src="assets/aba5b3b4-9805-4737-a700-154fca73000e.jpg"/></div>
<div class="packt_figure CDPAlignLeft CDPAlign">
<p>Notice that when we cause an exception in the compiled code, the traceback is fully filled in and points us to the cause and location of the problem. That's a Cython feature and a nice advantage.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<div class="packt_figure CDPAlignLeft CDPAlign">
<p>In this chapter, we discussed the benefits and drawbacks of using compiled code. We took a look at using Python's standard <kbd>ctypes</kbd> package to access functions stored in compiled C-compatible dynamic libraries, which is a quick way to gain access to the functionality that was written in other languages.</p>
<p>We also saw how to use Cython to operate with one foot at Python's higher level and C's much lower level of abstraction, with surprisingly little pain involved in bridging the gap. We can use this knowledge to optimize bottlenecks in our programs or access functionality that's only available when we operate close to the hardware.</p>
<p>With this, we've come to the end of this course. I hope you've learned a lot and have gained immense knowledge about Python. Keep learning!</p>
</div>


            </article>

            
        </section>
    </body></html>