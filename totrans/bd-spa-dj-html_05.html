<html><head></head><body>
		<div><h1 id="_idParaDest-42"><a id="_idTextAnchor055"/>Chapter 3: Adding WebSockets to Django</h1>
			<p>Channels is a Django <a id="_idIndexMarker082"/>extension that allows us to use protocols other than HTTP. The Django team, knowing the existing limitations of including other protocols, had to create a new <a id="_idIndexMarker083"/>server called Daphne that is natively compatible <a id="_idIndexMarker084"/>with the <strong class="bold">Asynchronous Server Gateway Interface</strong> (<strong class="bold">ASGI</strong>), an update of the <strong class="bold">Web Server Gateway Interface</strong> (<strong class="bold">WSGI</strong>). Without <a id="_idIndexMarker085"/>Channels, it would be impossible to have the WebSockets protocol.</p>
			<p>You may wonder why the migration from WSGI to ASGI is so important. First, we need to understand what communication interfaces are. When we want to serve a Python site, be it Django or any other framework, we need to run software capable of keeping an instance active and mediating with any web server that makes requests. There are many interfaces for a web server to understand Python, but the most recommended is the WSGI specification, a Python standard for communication between a web server (Apache, Nginx, Caddy, etc.) and any Python web app or frameworks/applications (Django, Flask, FastAPI, etc.). Unfortunately, there is a limitation. </p>
			<p>When we want to use HTTP with another protocol (WebSockets, etc.) it is not possible; HTTP was not designed to work with other protocols. The alternative is to use the ASGI specification, which will allow us to accept different protocols and asynchronous requests, split tasks into events, and keep a request alive after its response. In addition, it is compatible with applications using WSGI, so it will work perfectly with existing applications. That’s why Daphne (remember that it’s Django’s new ASGI server) is a spiritual successor as it maintains compatibility and extends Django possibilities. And this is the reason why we included the dependencies of <strong class="bold">daphne</strong>, <strong class="bold">asgiref</strong>, and <strong class="bold">channels</strong> in <a href="B18321_02_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Creating a Django Project around Docker</em>, when we created the Docker container; they are the minimum tools required to be able to work with the WebSockets protocol.</p>
			<p>In this chapter, we’ll learn how to activate Channels, configure Django to use Daphne, create a communication channel between the backend and frontend, send different formats (plain text, JSON, and HTML), where Django will generate the HTML blocks that will be displayed in the frontend. We will also delve into other essential Channels components such as <strong class="bold">scope</strong>, <strong class="bold">consumers</strong>, <strong class="bold">routing</strong>, and events.</p>
			<p>By the end of this chapter, we will acquire the minimum skills required to establish bidirectional communication between the server and the client using Django.</p>
			<p>We will be covering the following topics in this chapter:</p>
			<ul>
				<li>Creating our first page with Daphne</li>
				<li>Listening to events with consumers</li>
				<li>Sending plain text from the backend</li>
				<li>Sending and receiving messages in JSON</li>
				<li>Rendering HTML in the backend</li>
			</ul>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor056"/>Technical requirements</h1>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-3">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-3</a>.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor057"/>Creating our first page with Daphne</h1>
			<p>Let’s begin by activating all the real-time capabilities that Channels has to offer. So, we are going <a id="_idIndexMarker086"/>to enable Channels in the configuration, change the WSGI server for ASGI, and build a minimal HTML page to check that <a id="_idIndexMarker087"/>everything is running correctly. We will continue the application we started in <a href="B18321_02_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Creating a Django Project around Docker</em>. If you don’t have the code, you can use the example available in the following repository: <a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-2">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-2</a>.</p>
			<p>Let’s begin:</p>
			<ol>
				<li>The first thing we are going to do is to activate Channels. To do this, we open <code>hello_world/settings.py</code>, and under <code>INSTALLED_APPS</code>, we add <code>app.simple_app</code> (put it at the end) and <code>channels</code> (put it first):<pre>INSTALLED_APPS = [
<a id="_idTextAnchor058"/>    ' channels', # New line
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles'<a id="_idTextAnchor059"/>,
    'app.simple_app', #New line
]</pre></li>
				<li>As we <a id="_idIndexMarker088"/>learned in the introduction, Channels needs <a id="_idIndexMarker089"/>an ASGI-compatible server to work. If we don’t meet this requirement, Django won’t even be able to get up. That’s why we have to indicate where the file with the configuration for Daphne, or any other server that manages the interface, is located. In our case, we will go to the end of <code>settings.py</code> and add the followin<a id="_idTextAnchor060"/>g line:<pre><strong class="bold">ASGI_APPLICATION = "hello_world.asgi.application"</strong></pre></li>
				<li>As the project is inside the <code>app</code> folder, Django may not be able to handle imports properly. To fix this, we’ll change the name of our application. We open <code>app/simple_app/apps.py</code> and leave it as follows:<pre>from django.apps import AppConfig
class SimpleAppConfig(AppConfig):
    default_auto_field = 'django.db.models.
        BigAutoField'.
    name = 'app.simple_app' # Update</pre></li>
				<li>We will <a id="_idIndexMarker090"/>next create a basic HTML page, where <a id="_idIndexMarker091"/>JavaScript will interact with the future WebSockets server.</li>
			</ol>
			<p>Inside <code>app/simple_app/</code>, we create the <code>templates</code> folder, and inside it we create a new fi<a id="_idTextAnchor061"/>le called <code>index.html</code>. The full path would be <code>app/simple_app/templates/index.html</code>. We include the following content:</p>
			<pre>&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, 
      user-scalable=no, initial-scale=1.0, maximum- 
        scale=1.0, minimum-scale=1.0"&gt;
    &lt;title&gt; Index &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt; Hello Django! &lt;h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
			<ol>
				<li value="5">Next, let’s create a view that serves the HTML file we just created. We open <code>app/simple_app/views.py</code> and create the view <code>index</code>. In <code>return</code>, we’ll tell it to respond with the content of the <a id="_idTextAnchor062"/>template:<pre>from django.shortcuts import render
 
def index(request):
    return render(request, 'index.html', {})</pre></li>
				<li>Now we <a id="_idIndexMarker092"/>just need to give a route. We go into <code>hello_world/urls.py</code>. Import <a id="_idIndexMarker093"/>the view and add a new <code>path</code>:<pre>from django.contrib import admin
from django.urls <a id="_idTextAnchor063"/>import path
from app.simple_app import views
 
urlpatte<a id="_idTextAnchor064"/>rns = [
    path('', views.index, name='index'), # New line
    path('admin/', admin.site.urls),
]</pre></li>
				<li>We pull up Docker and go to <code>http://hello.localhost/</code>. It will respond with a minimalist message:</li>
			</ol>
			<div><div><img src="img/Figure_3.1_B18321.jpg" alt="Figure 3.1 – Displaying a static HTML page on the domain hello.localhost&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Displaying a static HTML page on the domain hello.localhost</p>
			<p>Congratulations! You have <a id="_idIndexMarker094"/>built a web page with Daphne <a id="_idIndexMarker095"/>and Django that is ready to handle WebSockets connections.</p>
			<p>The next step is to build and learn about the concept of Consumers, Channels’ way of handling events. We’ll connect the frontend with a simple Consumer that will act as an intermediary to communicate between Django and the JavaScript WebSocket client. </p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor065"/>Listening to events with consumers</h1>
			<p>We are <a id="_idIndexMarker096"/>going to build an example where we can send <a id="_idIndexMarker097"/>messages between a backend and frontend in real time. We will need an intermediary to listen to both and make decisions. Channels <a id="_idIndexMarker098"/>comes ready with a specially prepared tool called a consumer. It is a series of functions that are invoked when an event is triggered by a WebSocket client.</p>
			<p>Here you can see a minimal consumer structure for WebSockets: </p>
			<pre class="source-code">from channels.generic.websocket import WebsocketConsumer</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class NameConsumer(WebsocketConsumer):</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def connect(self):</pre>
			<pre class="source-code">        """Event when client connects"""</pre>
			<pre class="source-code">        # Informs client of successful connection</pre>
			<pre class="source-code">        self.accept()</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">    def disconnect(self, close_code):</pre>
			<pre class="source-code">        """Event when client disconnects"""</pre>
			<pre class="source-code">        pass</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def receive(self, text_data):</pre>
			<pre class="source-code">        """Event when data is received"""</pre>
			<pre class="source-code">        pass</pre>
			<p>Let us <a id="_idIndexMarker099"/>go through what each of these events in the <a id="_idIndexMarker100"/>preceding code snippet does: </p>
			<ul>
				<li><code>connect</code>: Asks for permission to connect. If we accept, we will assign a group. More on this later.</li>
				<li><code>receive</code>: Sends us information and we decide what to do with it. It may trigger some actions, or we may ignore it; we are not obliged to process it.</li>
				<li><code>disconnect</code>: Notifies us that it is going to close the connection. It is important to be aware in advance if the connection is going to close.</li>
			</ul>
			<p>Being technical, Consumers are an abstraction for making event-driven applications using ASGI. They allow us to execute the code we need when a change occurs. If you have worked with JavaScript events, you will be very familiar with them. And if you haven’t, you could think of them as Channels views, except, instead of being triggered by requests to the URLs we link to the views, they are actions that execute functions. </p>
			<p>Django is able <a id="_idIndexMarker101"/>to capture client events. Channels knows whether <a id="_idIndexMarker102"/>a new client has connected, disconnected, or sent information. However, the backend has a very powerful ability: to select the recipients of the information. When a client asks to connect, Django must assign the client a group or channel. The client can be left alone or grouped with other clients, depending on the need. When the time comes to send a message, we must decide who will receive it—a specific client or a group.</p>
			<p>In what situation will I need to send data to a client or a group? Let’s use the example of a chat. When I write a private message, Django will send the new text to a specific client, that is the specific user I’m talking to. On the other hand, if I am in a group with other users, when I write a message, the backend will send the text only to a specific selection, that is all the users subscribed to the chat room. The frontend does not decide whether it receives new information or who the recipients are; it is the consumer who is the master of who moves the available information.</p>
			<p>Now that we have seen how consumers can be useful, let’s look at the role they play when sending plain text to a server/client. We will explore how a client can capture information received from a channel. </p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor066"/>Sending plain text from the backend</h1>
			<p>Let’s build <a id="_idIndexMarker103"/>the first minimalistic consumer that greets <a id="_idIndexMarker104"/>a WebSocket client when it connects. Later, we will add complexity and other actions.</p>
			<p>All the code for the example can be found at <a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-3/Sending%20plain%20text">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-3/Sending%20plain%20text</a>:</p>
			<ol>
				<li value="1">We <a id="_idTextAnchor067"/><a id="_idIndexMarker105"/>create <code>app/simple_app/consumers.py</code> with <a id="_idTextAnchor068"/><a id="_idIndexMarker106"/>the following content:<pre># app/simple_app/consumers.py
from channels.generic.websocket import WebsocketConsumer
 
class EchoConsumer(WebsocketConsumer):
 
    def connect(self):
        """Event when client connects"""
 
        # Informs client of successful connection
        self.accept()
 
        # Send message to client
        self.send(text_data="You are connected by WebSockets!")
 
    def disconnect(self, close_code):
        """Event when client disconnects"""
        pass
 
    def receive(self, text_data):
        """Event when data is received"""
        pass</pre></li>
			</ol>
			<p>Let's explain each element of the file we have just created:</p>
			<ul>
				<li>With <code>from channels.generic.websocket import WebsocketConsumer</code>, we import the consumer object for WebSockets.</li>
				<li>We declare the Consumer with <code>class EchoConsumer(WebsocketConsumer):</code> and call it <code>EchoConsumer</code>.</li>
				<li>You need at least three functions that are the events that will be triggered by the frontend actions: <code>connect</code>, <code>disconnect</code>, and <code>receive</code>. We are going to focus on <code>connect</code>.</li>
				<li>When <a id="_idIndexMarker107"/>clients connect, the first thing <a id="_idIndexMarker108"/>we’ll do is confirm the connection to establish future communication between Django and the client. We use <code>self.accept()</code>.</li>
				<li>Finally, we will send a message with <code>self.send</code>, the string <code>"You are connected by WebSockets!"</code>. That way every client that connects will receive a greeting.</li>
			</ul>
			<ol>
				<li value="2">Now we need to assign the consumer a route for a WebSockets client to connect to. For this, we add the routes on the ASGI server that connects to the consumers. We open <code>hello_world/asgi.py</code> and update with the path <code>/ws/echo/</code> pointing to <code>EchoConsumer</code>:<pre># hello_world/asgi.py
import os
from django.core.asgi import get_asgi_application
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, 
    URLRouter
from django.urls import re_path
from app.simple_app.consumers import EchoConsumer
 os.environ.setdefault('DJANGO_SETTINGS_MODULE', 
    'hello_world.settings')
 
application = ProtocolTypeRouter({
    # Django's ASGI application to handle traditional 
    HTTP requests
    "http": get_asgi_application(),
    # WebSocket handler
    "websocket": AuthMiddlewareStack(
        URLRouter([
            re_path(r"^ws/echo/$", EchoConsumer.
                as_asgi()),
        ])
    ),
})</pre></li>
			</ol>
			<p>In <code>asgi.py</code>, you will <a id="_idIndexMarker109"/>find all the configurations <a id="_idIndexMarker110"/>that you can apply to the ASGI server:</p>
			<ul>
				<li>Since ASGI loads before Django, it can’t know the path to Django’s own configuration file. We must preempt this with <code>os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hello_world.settings')</code>.</li>
				<li>In <code>application</code>, we configure all routes, whether HTTP or any other protocol. We use the <code>ProtocolTypeRouter</code> object to indicate the type and destination of each route.</li>
				<li>It will still be necessary to use traditional HTTP requests: loading pages via HTTP, managing sessions, cookies, and other particularities. For this task, we include <code>"http": get_asgi_application()</code> inside <code>ProtocolTypeRouter</code>.</li>
				<li>Finally, we include the consumer path with <code>re_path(r'ws/echo/$', consumers.EchoConsumer.as_asgi())</code>. Now the path to connect to <code>EchoConsumer</code> is <code>/ws/echo/</code>.</li>
			</ul>
			<ol>
				<li value="3">Next, we <a id="_idIndexMarker111"/>connect a WebSockets client to Django.</li>
			</ol>
			<p>We go to <code>app/simple_app/templates/index.html</code>, where we are going to <a id="_idIndexMarker112"/>define with JavaScript a WebSockets client that connects to the path we just created: </p>
			<pre>{# app/simple_app/templates/index.html #}
&lt;! doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, 
      user-scalable=no, initial-scale=1.0, maximum-
        scale=1.0, minimum-scale=1.0"&gt;
    &lt; title&gt; Index &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello Django!&lt;/h1&gt;
 
    &lt;!-- Place where we will display the connection 
    message. --&gt;
    &lt;h2 id="welcome"&gt;&lt;/h2&gt;
    &lt;script&gt;
        // Connect to WebSockets server (EchoConsumer)
        const myWebSocket = new WebSocket("ws://{{ 
            request.get_host }}/ws/echo/");
 
        // Event when a new message is received by 
        WebSockets
        myWebSocket.addEventListener("message", 
            (event) =&gt; {
            // Display the message in '#welcome'.
            document.querySelector("#welcome").
                textContent = event.data;
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
			<p>We've created a minimalistic WebSockets client in JavaScript to listen to everything we receive from the backend:</p>
			<ul>
				<li>We define <a id="_idIndexMarker113"/>an HTML tag to display the welcome <a id="_idIndexMarker114"/>message that the backend will send us. Adding <code>&lt;h2 id="welcome"&gt;&lt;/h2&gt;</code> will be enough; later, we will fill it with JavaScript.</li>
				<li>We connect with <code>new WebSocket()</code> to <code>/ws/echo/</code>. The address must contain the following structure: <code>protocol://domain/path</code>. In our case, it will be <code>ws://hello.localhost/ws/echo/</code>.</li>
				<li>The <code>message</code> event will be fired when the backend sends a message. As soon as we <a id="_idIndexMarker115"/>connect to Django, we’ll receive the <a id="_idIndexMarker116"/>message we’ve programmed and then display it in <code>&lt;h2&gt;</code>.</li>
			</ul>
			<p class="callout-heading">WebSocket secure protocol</p>
			<p class="callout">We can use the <code>ws://</code> protocol, where information is sent in plain text, or <code>wss://</code> to maintain a secure connection. The difference is similar to using <code>http://</code> or <code>https://</code>. We will change the protocol to secure when it is in production or when we can provide an SSL certificate; while we are developing, it is not necessary.</p>
			<p>Open in your favorite browser the address <code>http://hello.localhost</code>.</p>
			<div><div><img src="img/Figure_3.2_B18321.jpg" alt="Figure 3.2 – Sending plain text from the backend a plain text (&quot;You are connected by WebSockets&quot;) and rendering the message in an HTML element, below the title"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Sending plain text from the backend a plain text ("You are connected by WebSockets") and rendering the message in an HTML element, below the title</p>
			<p>We just learned how to send asynchronous plain text from the backend to the frontend via WebSockets. OK! It’s not very spectacular; it’s sent at the very moment we connect. However, as we have it built, we can send messages whenever we need to.</p>
			<p>Let’s make it more interesting: do we synchronize the time for all our visitors? In other words, send the same information to all connected clients in real-time. Of course!</p>
			<p>We go back to <code>app/simple_app/consumers.py</code>. We will create an infinite loop wherein every second a text is sent to the frontend, specifically, the current time. We’ll use <strong class="bold">threading</strong> to <a id="_idIndexMarker117"/>create a <a id="_idIndexMarker118"/>background task and not <a id="_idIndexMarker119"/>produce any interruptions:</p>
			<pre class="source-code"># app/simple_app/consumers.py</pre>
			<pre class="source-code">from channels.generic.websocket import WebsocketConsumer</pre>
			<pre class="source-code">from datetime import datetime # New line</pre>
			<pre class="source-code">import time # New line</pre>
			<pre class="source-code">import threading # New line</pre>
			<pre class="source-code">class EchoConsumer(WebsocketConsumer):</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def connect(self):</pre>
			<pre class="source-code">        """Event when client connects"""</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        # Informs client of successful connection</pre>
			<pre class="source-code">        self.accept()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        # Send message to client</pre>
			<pre class="source-code">        self.send(text_data="You are connected by </pre>
			<pre class="source-code">            WebSockets!")</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        # Send message to client every second</pre>
			<pre class="source-code">        def send_time(self): # New line</pre>
			<pre class="source-code">            while True:</pre>
			<pre class="source-code">                # Send message to client</pre>
			<pre class="source-code">                self.send(text_data=str(datetime.now(). </pre>
			<pre class="source-code">                    Strftime("%H:%M:%S")))</pre>
			<pre class="source-code">                # Sleep for 1 second</pre>
			<pre class="source-code">                time.sleep(1)</pre>
			<pre class="source-code">        threading.Thread(target=send_time, args=(self,)).</pre>
			<pre class="source-code">            start() # New line</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def disconnect(self, close_code):</pre>
			<pre class="source-code">        """Event when client disconnects"""</pre>
			<pre class="source-code">        pass</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def receive(self, text_data):</pre>
			<pre class="source-code">        """Event when data is received"""</pre>
			<pre class="source-code">        pass</pre>
			<p>Now, open <a id="_idIndexMarker120"/>the same address <code>hello.localhost</code> in different <a id="_idIndexMarker121"/>tabs or browsers; you’ll see how they show the exact same time. All clients are synchronized, receiving the same. No waiting, no need to ask the backend.</p>
			<div><div><img src="img/Figure_3.3_B18321.jpg" alt="Figure 3.3 – Showing the same time to all visitors in real time&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Showing the same time to all visitors in real time</p>
			<p>The power <a id="_idIndexMarker122"/>of real time before your eyes. Maybe it’s inspiring your imagination; the possibilities are endless: an election system? An <a id="_idIndexMarker123"/>auction site? Notifications? Taxi locator? Food order? Chat? We’ll keep exploring with small projects. </p>
			<p>In the following sections, we will continue to learn how to send messages from the backend in different formats, such as JSON or HTML.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor069"/>Sending JSON from the backend</h1>
			<p>We are <a id="_idIndexMarker124"/>going to send content in JSON <a id="_idIndexMarker125"/>format from the backend and <a id="_idIndexMarker126"/>consume it at the frontend. In addition, we will give the code a reusable structure that will be useful throughout the book.</p>
			<p>All the code for the example can be found at <a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-3/Sending%20JSON">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-3/Sending%20JSON</a>.</p>
			<p>We have a consumer type adapted for the purpose of sending or receiving JSON called <code>JsonWebsocketConsumer</code>. It is the same as <code>WebsocketConsumer</code> except for two differences:</p>
			<ul>
				<li>We <a id="_idIndexMarker127"/>need to add the <code>send_json</code> function to encode to JSON:<pre>book = {
    'title': 'Don Quixote',
    author': 'Miguel de Cervantes'.
}
self.send_json(content=book)</pre></li>
				<li>We <a id="_idIndexMarker128"/>have a new event, called <code>receive_json</code>, which <a id="_idIndexMarker129"/>automatically decodes JSON when a message <a id="_idIndexMarker130"/>is received from the client:<pre>def receive_json(self, data):
    """Event when data is received"""
    pass</pre></li>
			</ul>
			<p>To exemplify how we can send content in JSON format, we will create a Bingo project.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor070"/>Example project – Generating a ticket of random numbers</h2>
			<p>When a client connects, a ticket with a series of random numbers will be generated and delivered <a id="_idIndexMarker131"/>to them via WebSockets. Then, every so often, we will send a random ball from Django. When the player has all the numbers, we will display a winner message.</p>
			<p>Let’s get started:</p>
			<ol>
				<li value="1">We add to <code>app/simple_app/consumers.py</code> a new consumer extending from <code>JsonWebsocketConsumer</code>:<pre>from channels.generic.websocket import JsonWebsocketConsumer
class BingoConsumer(JsonWebsocketConsumer):
 
    def connect(self):
        self.accept()
 
    def disconnect(self, close_code):
        """Event when client disconnects"""
        pass
 
    def receive_json(self, data):
        """Event when data is received"""
        Pass</pre></li>
				<li>We generate <a id="_idIndexMarker132"/>a ticket of five numbers between <a id="_idTextAnchor071"/>1 and 10. We will avoid repetitions with <code>set()</code>:<pre>class BingoConsumer(JsonWebsocketConsumer):
 
    def connect(self):
        self.accept()
        ## Send numbers to client
        # Generates numbers 5 random numbers,  
           approximately, between 1 and 10
        random_numbers = list(set([randint(1, 10) for 
            _ in range(5)])))
        message = {
            ' action': 'New ticket',
            ' ticket': random_numbers
        }
        self.send_json(content=message)
 
    def disconnect(self, close_code):
        """Event when client disconnects"""
        pass
 
    def receive_json(self, data):
        """Event when data is received"""
        pass</pre></li>
			</ol>
			<p>To inform <a id="_idIndexMarker133"/>the client what kind of action we are going to perform, we include in the JSON to send <code>action</code>. Separately, in <code>ticket</code>, we include the list of numbers.</p>
			<ol>
				<li value="3">Edit <code>hello_world/asgi.py</code> and add the path <code>/ws/bingo/</code> pointing to <code>BingoConsumer</code>. Don’t forget to import it. Now we have a new endpoint to feed the future WebSockets client. It's time to create the HTML:<pre># hello_world/asgi.py
import os 
from django.core.asgi import get_asgi_application
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from django.urls import re_path
fr<a id="_idTextAnchor072"/>om app.simple_app.consumers import EchoConsumer, BingoConsumer # Update
 
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 
    'hello_world.settings')
 
application = ProtocolTypeRouter({
    # Django's ASGI application to handle traditional 
    HTTP requests
    "http": get_asgi_application(),
    # WebSocket handler
    "websocket": AuthMiddlewareStack(
        URLRouter([
            re_path(r"^ws/echo/$", EchoC<a id="_idTextAnchor073"/>onsumer.
                as_asgi()),
            re_path(r"^ws/bingo/$", BingoConsumer.
                as_asgi()), # New line
        ])
    ),
})</pre></li>
			</ol>
			<p>The consumer <a id="_idIndexMarker134"/>is prepared to send a ticket with random numbers to every client that connects. The next step will be to prepare the frontend to receive it and render it in the appropriate HTML element.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor074"/>Receiving JSON in the frontend</h1>
			<p>The goal <a id="_idIndexMarker135"/>will be to receive an <a id="_idIndexMarker136"/>asynchronous JSON from the backend that JavaScript will detect in an event. With the data, we will show in the HTML the information to the visitor:</p>
			<ol>
				<li value="1">We create a new HTML in <code>app/simple_app/templates/bingo.html</code> that will contain all the frontend: <pre>{# app/simple_app/templates/bingo.html #}
&lt;! doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport"
          content="width=device-width, user
            scalable=no, initial-scale=1.0, maximum-
              scale=1.0, minimum-scale=1.0"&gt;
    &lt;title&gt;Bingo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Bingo&lt;/h1&gt;
    &lt;h2&gt;Ball: &lt;span id="ball"&gt;&lt;/span&gt;&lt;/h2&gt;.
    &lt;h2 id="ticket"&gt;&lt;/h2&gt;
 
    &lt;script&gt;
        // Connect to WebSockets server
        (BingoConsumer)
        const myWebSocket = new WebSocket("ws://{{ 
            request.get_host }}/ws/bingo/");
        let ticket = [];
 
        // Event when a new message is received by 
           WebSockets
        myWebSocket.addEventListener("message", 
            (event) =&gt; {
            const myData = JSON.parse(event.data);
            switch (myData.action) {
                case "New ticket":
                    // Save the new ticket
                    ticket = myData.ticket;
                    // Render ticket
                    document.getElementById("ticket"). 
                         textContent = "Ticket: " + 
                             ticket.join(", ");
                    break;
                } }
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>
				<li>We <a id="_idIndexMarker137"/>will need a view <a id="_idIndexMarker138"/>for the template we have created. We add to <code>app/simple_app/views.py</code> the following function:<pre>from django.shortcuts import render
 
def index(req<a id="_idTextAnchor075"/>uest):
    return render(request, 'index.html', {})
 
def bingo(request): # New function
    return render(request, 'bingo.html', {})</pre></li>
				<li>In <code>hello_world/urls.py</code>, we <a id="_idIndexMarker139"/>include <a id="_idIndexMarker140"/>the <code>/bingo/</code> path:<pre>from django.contrib import admin
from django.urls import path
from app.simple_app import views
 
urlpa<a id="_idTextAnchor076"/>tterns = [
    path('', views.index, name='index'),
    path('bingo/', views.bingo, name='bingo'), # New line
    path('admin/', admin.site.urls),
]</pre></li>
			</ol>
			<p>And with this change, ticket generation will be ready.</p>
			<ol>
				<li value="4">When we enter <code>http://hello.localhost/bingo/</code>, we will see a ticket of random numbers that will only be given to us: </li>
			</ol>
			<div><div><img src="img/Figure_3.4_B18321.jpg" alt="Figure 3.4 – Backend returning a set of random numbers when we connect via WebSockets&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Backend returning a set of random numbers when we connect via WebSockets</p>
			<p>Currently, the <a id="_idIndexMarker141"/>consumer <a id="_idIndexMarker142"/>returns a JSON like the following to any client that connects to <code>/ws/bingo/</code>:</p>
			<pre>{
<code>"</code> action<code>"</code>: <code>"</code> New ticket<code> "</code>
<code>"</code> ticket<code>"</code>: [1, 2, 3...] // Random numbers
}</pre>
			<p>JavaScript waits, listening. If it receives a JSON whose <code>"action"</code> is <code>"New ticket"</code>, it will store the entire contents of <code>"ticket"</code> in the <code>ticket</code> variable. Finally, the JSON displays the HTML:</p>
			<pre>myWebSocket.addEventListener("message", (event) =&gt; {
const myData = JSON.parse(event.data);
switch (myData.action) {
case "New ticket":
// Save the new ticket
ticket = myData.ticket;
// Render ticket
document.getElementById("ticket"). textContent = 
    "Ticket: " + ticket.join(", ");
                    break;
} 
}
});</pre>
			<p>We now <a id="_idIndexMarker143"/>have an automated <a id="_idIndexMarker144"/>system for each customer to generate their own set of numbers to play. The next step will be to send all customers the same random number to represent the ball.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor077"/>Example project – Checking for matching numbers </h2>
			<p>The next <a id="_idIndexMarker145"/>milestone is to send random numbers, on a recurring basis, from the backend for the frontend to check for matches. It’s time to mix the balls!</p>
			<ol>
				<li value="1">We create a thread that generates random numbers and sends them every second. We will call the action <code>'New ball'</code>:<pre># app/simple_app/consumers.py
from channels.generic.websocket import WebsocketConsumer
from datetime import datetime
import time
import threading
from random import randint
from channels.generic.websocket import JsonWebsocketConsumer
 
class EchoConsumer(WebsocketConsumer):
 # E<a id="_idTextAnchor078"/>cho Code
class BingoConsumer(JsonWebsocketConsumer):
 
    def connect(self):
        self.accept()
        ## Send numbers to client
        # Generates numbers 5 random numbers, approximately, between 1 and 10
        random_numbers = list(set([randint(1, 10) for 
            _ in range(5)]))
        message = {
            ' action': 'New ticket',
            ' ticket': random_numbers
        }
        self.send_json(content=message)
 
        ## Send balls
        def send_ball(self):
            while True:
                # Send message to client
                random_ball = randint(1, 10)
                message = {
                    ' action': 'New ball',
                    ' ball': random_ball
                }
                self.send_json(content=message)
                # Sleep for 1 second
                time.sleep(1)
 
        threading.Thread(target=send_ball, 
            args=(self,)). start()
 
    def disconnect(self, close_code):
        """Event when client disconnects"""
        pass
 
    def receive_json(self, data):
        """Event when data is received"""
        Pass</pre></li>
				<li>In the <a id="_idIndexMarker146"/>JavaScript event that listens to Django, we’ll add the case to detect whether an action with <code>"New ball"</code> arrives: <pre>{# app/simple_app/templates/bingo.html #}
&lt;! doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport"
          content="width=device-width, user-
            scalable=no, initial-scale=1.0, maximum-
              scale=1.0, minimum-scale=1.0"&gt;
    &lt;title&gt;Bingo&lt;/title&gt;
&lt;/head&gt;
&lt; body&gt;
    &lt;h1&gt;Bingo&lt;/h1&gt;
    &lt;h2&gt;Ball: &lt;span id="ball"&gt;&lt;/span&gt;&lt;/h2&gt;.
    &lt;h2 id="ticket"&gt;&lt;/h2&gt;
 
    &lt;script&gt;
        // Connect to WebSockets server (BingoConsumer)
        const myWebSocket = new WebSocket("ws://{{ 
            request.get_host }}/ws/bingo/");
        let ticket = [];
 
        // Event when a new message is received by 
        WebSockets
        myWebSocket.addEventListener("message", 
           (event) =&gt; {
            const myData = JSON.parse(event.data);
            switch (myData.action) {
                case "New ticket":
                    // Save the new ticket
                    ticket = myData.ticket;
                    // Render ticket
                    document.getElementById("ticket"). 
                        textContent = "Ticket: " + 
                            t<a id="_idTextAnchor079"/>icket.join(", ");
                    break;
                case "New ball":
                    // Get the ball number
                    ball = myData.ball;
                    // Check if ball is in the ticket 
                    and remove it
                    ticket = ticket.map(item =&gt; item 
                        === ball ? "X" : item);
                    // Render ticket
                    document.getElementById("ticket"). 
                        textContent = "Ticket: " + 
                            ticket.join(", ");
                    // Render ball
                    document.getElementById("ball"). 
                        textContent = ball;
                    // Check if we have a winner
                    if (ticket.find(number =&gt; number 
                        !== "X") === undefined) {
                        // We have a winner
                        document.getElementById
                            ("ticket"). textContent = 
                                "Winner!";
                    }
                    break;
            }
        });
 
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>
				<li>If so, we search <a id="_idIndexMarker147"/>the array of tickets for a match and replace the number with an <code>X</code>:</li>
			</ol>
			<div><div><img src="img/Figure_3.5_B18321.jpg" alt="Figure 3.5 – If any of the balls matches a number on the ticket, we replace it with an X&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – If any of the balls matches a number on the ticket, we replace it with an X</p>
			<p>And how do we know we have won? If all the contents of my ticket are <code>X</code>: game over!</p>
			<div><div><img src="img/Figure_3.6_B18321.jpg" alt="Figure 3.6 – All ticket numbers have been crossed out, so we display a winner message&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – All ticket numbers have been crossed out, so we display a winner message</p>
			<p>So far, all that the frontend has done is listen and obey like a good child. However, they’re now <a id="_idIndexMarker148"/>mature enough to be heard. From JavaScript, we’re going to communicate with Django by making requests or sending information, and the backend will respond in two ways: either with JSON (as we’ve learned in this section) or with rendered HTML.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor080"/>Rendering HTML in the backend</h1>
			<p>In this chapter, we will take the first steps on the principles of HTML over WebSockets. The backend <a id="_idIndexMarker149"/>will be in charge of rendering the HTML, taking the responsibility away from JavaScript and simplifying its tasks. On the other hand, we will <a id="_idIndexMarker150"/>avoid the need to incorporate a framework such as React, Vue, or Angular, and an API for an HTTP client.</p>
			<p>The goal <a id="_idIndexMarker151"/>will be to build a <strong class="bold">body mass index</strong> (<strong class="bold">BMI</strong>) calculator for adults using the metric system. All calculations and HTML creation will be a Django task.</p>
			<p>All the code for the example can be found at <a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-3/Rendering%20HTML">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-3/Rendering%20HTML</a>.</p>
			<p>We will ask for the height, in centimeters, and the weight, in kilograms. The formula to get it is <em class="italic">weight (kg) / (height (m))</em>2.</p>
			<p>In Python, it would be translated as follows: <code>weight / (height ** 2)</code>.</p>
			<p>And its result will indicate the status:</p>
			<div><div><img src="img/011.jpg" alt=" Table 1.1 – BMI status&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Table 1.1 – BMI status</p>
			<p>For example, if I weigh 78 kg and I am 180 cm tall (or 1.8 m), the calculation would be 78 / (1.8 ** 2), resulting in <code>24</code>. I would be in a <em class="italic">Normal</em> state, just one point away from <em class="italic">Overweight</em> – I think <a id="_idIndexMarker152"/>this is life’s warning for me to give up my daily chocolate desserts:</p>
			<ol>
				<li value="1">I start <a id="_idIndexMarker153"/>by adding a consumer name<a id="_idTextAnchor081"/>d <code>BMIConsumer</code> in <code>app/simple_app/consumers.py<a id="_idTextAnchor082"/></code>:<pre>from django.template.loader import render_to_string<a id="_idTextAnchor083"/>
class BMIConsumer(JsonWebsocketConsumer):
 
    def connect(self):
        self.accept()
 
    def disconnect(self, close_code):
        """Event when client disconnects"""
        pass
 
    def receive_json(self, data):
        """Event when data is received"""
        height = data['height'] / 100
        weight = data['weight']
        bmi = round(weight / (height ** 2), 1)
        self.send_json(
            content={
                    "action": "BMI result",
                    "html": render_to_string(
                        "components/_bmi_result.html",
                        {"height": height, "weight": 
                            weight, "bmi": bmi}
                    )
            }
        )</pre></li>
			</ol>
			<p>For the first time, we will receive information from the client. The client will provide <a id="_idIndexMarker154"/>us with the values of a future form with weight <a id="_idIndexMarker155"/>and height, and in return we will return the HTML ready to display.</p>
			<p>Let’s explain what’s going on in the preceding code snippet:</p>
			<ul>
				<li>We import the Django function to render HTML: <code>from django.template.loader import render_to_string</code>.</li>
				<li>Everything happens inside the <code>receive_json</code> function. With <code>data['height']</code> and <code>data['weight']</code>, we collect two pieces of data that we will send from JavaScript.</li>
				<li>Calculate the index with <code>round(weight / (height ** 2), 1)</code>.</li>
				<li>We send back to the client a JSON with two fields: <code>"action"</code>, where we simply inform the client what action to take, and <code>"html"</code> with the HTML generated from <strong class="bold">render_to_string</strong>.</li>
			</ul>
			<ol>
				<li value="2">Edit <code>hello_world/asgi.py</code> and <a id="_idIndexMarker156"/>add the <code>/ws/bmi/</code> path <a id="_idIndexMarker157"/>pointing to <code>BMIConsumer</code>.<pre># hello_world/asgi.py
Import
from django.core.asgi import get_asgi_application
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from django.urls import re_path
from app.simple_app.consumers import EchoConsumer, BingoCons<a id="_idTextAnchor084"/>umer, BMIConsumer # Update
 
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hello_world.settings')
 
application = ProtocolTypeRouter({
    # Django's ASGI application to handle traditional 
    HTTP requests
    "http": get_asgi_application(),
    # WebSocket handler
    "websocket": AuthMiddlewareStack(
        URLRouter([
            re_path(r"^ws/echo/$", EchoConsumer.
                as_asgi()),
            re_path(r"^ws/bingo/$", BingoConsumer.
                as_asgi()),
      <a id="_idTextAnchor085"/>      re_path(r"^ws/bmi/$", BMIConsumer.
                as_asgi()), # New line
        ])
    ),
})</pre></li>
				<li>We create <a id="_idIndexMarker158"/>a new HTML in <code>app/simple_app/templates/bmi.html</code> that will contain the form and the JavaScript <a id="_idIndexMarker159"/>that will send the information:<pre>{# app/simple_app/templates/bmi.html #}
&lt;! doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport"
          content="width=device-width, user-
            scalable=no, initial-scale=1.0, maximum-
              scale=1.0, minimum-scale=1.0"&gt;
    &lt;title&gt;BMI Calculator&lt;/title&gt;.
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;BMI Calculator&lt;/h1&gt;
    &lt;label for="height"&gt; Height (cm):
        &lt;input type="text" name="height" id="height"&gt;
    &lt;/label&gt;
    &lt;label for="weight"&gt; Weight (kg)
        &lt;input type="text" name="weight" id="weight"&gt;
    &lt;/label&gt;
    &lt;input type="button" id="calculate" value=
        "Calculate"&gt;
    &lt;div id="result"&gt;&lt;/div&gt;
 
    &lt;script&gt;
        // Connect to WebSockets server 
        (BingoConsumer)
        const myWebSocket = new WebSocket("ws://{{ 
            request.get_host }}/ws/bmi/");
 
        // Event when a new message is received by 
        WebSockets
        myWebSocket.addEventListener("message", 
           (event) =&gt; {
            const myData = JSON.parse(event.data);
            switch (myData.action) {
                case "BMI result":
                    document.getElementById("result"). 
                        innerHTML = myData.html;
                    break;
            }
        });
 
        document.querySelector('#calculate'). 
            addEventListener('click', () =&gt; {
            const height = parseFloat(document.
                querySelector('#height'). value);
            const weight = parseFloat(document.
                querySelector('#weight'). value);
            myWebSocket.send(JSON.stringify({
                height: height,
                weight: weight
            }));
        });
 
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ol>
			<p>The mechanism <a id="_idIndexMarker160"/>is simple. When the <code>"action"</code> <code>"BMI results"</code>, it will inject the HTML in the appropriate place.</p>
			<ol>
				<li value="4">We will need a view for the template we have created. We add to <code>app/simple_app/views.py</code> the <code>bmi</code> function that points to the template:<pre>from django.shortcuts import render
 
def index(request):
    return render(request, 'index.html', {})
 
def bingo(request):
    return render(request, 'bingo.htm<a id="_idTextAnchor086"/>l', {})
 
def bmi(request): # New function
    return render(request, 'bmi. html', {})</pre></li>
				<li>In <code>hello_world/urls.py</code>, we <a id="_idIndexMarker162"/>include the <code>/bmi/</code> path:<pre>from django.contrib import admin
from django.urls import path
from app.simple_app import views
 
urlpatterns = [
    path('', views.index, name='index'),
    path('bingo/', views.bingo, name='bin<a id="_idTextAnchor087"/>go'),
    path('bmi/', views.bmi, name='bmi'), # New line
    path('admin/', admin.site.urls),
]</pre></li>
			</ol>
			<p>Now when <a id="_idIndexMarker163"/>we enter <code>http://hello.localhost/bmi/</code>, we will be shown the website with the form:</p>
			<div><div><img src="img/Figure_3.7_B18321.jpg" alt="Figure 3.7 – The form is displayed ready for use&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The form is displayed ready for use</p>
			<ol>
				<li value="6">We only need the HTML component that we will use to display the content. We create in <code>app/simple_app/templates/<a id="_idTextAnchor088"/>components/_bmi_result.html</code> a document <a id="_idIndexMarker164"/>with the following content:<pre>&lt;p&gt;&lt;strong&gt; Weight&lt;/strong&gt; {{ weight }} Kg&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Height&lt;/strong&gt; {{ height }} m&lt;/p&gt;
&lt;p&gt;&lt;p&gt;&lt;strong&gt;BMI&lt;/strong&gt; {{ bmi }}&lt; /p&gt;
{% if bmi &lt; 18.5 %}
&lt;p&gt;Underweight&lt;/p&gt;
{% elif bmi &lt; 25 %}
&lt;p&gt;Normal&lt;/p&gt;
{% elif bmi &lt; 30 %}
&lt;p&gt;Overweight&lt;/p&gt;
{% else %}
&lt;p&gt;Obese&lt;/p&gt;
{% endif %}</pre></li>
			</ol>
			<p>Everything <a id="_idIndexMarker165"/>is ready, you can now calculate your body mass index. Warning! I am only responsible for bugs; for any other problem, you should consult a nutritionist.</p>
			<div><div><img src="img/Figure_3.8_B18321.jpg" alt="Figure 3.8 – When the form is filled in and Calculate is clicked, the HTML of the component is displayed&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – When the form is filled in and Calculate is clicked, the HTML of the component is displayed</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor089"/>Summary</h1>
			<p>We have acquired the skills to create a bidirectional communication tunnel between a backend and frontend using the WebSockets protocol. We can send plain text, JSON, or HTML—totally asynchronous and without waiting. We even know how to ask the backend to take care of rendering HTML fragments that we will inject without the visitor noticing a delay.</p>
			<p>Despite everything we have learned, we still have some issues, such as the fact that the backend can only send information to individual clients, and not to groups. In addition, we still don’t know how to interact with the database, create sessions, or identify users. And without all these elements, we will be unable to make an application that facilitates communication between two visitors or manipulate the database. We need to go deeper.</p>
			<p>In the next chapter, we will be introduced to database models and create a complete <strong class="bold">Browse-Read-Edit-Add-Delete</strong> (<strong class="bold">BREAD</strong>) with a completely new project.</p>
			<p class="callout-heading">BREAD Is an Evolution of CRUD</p>
			<p class="callout"><strong class="bold">CRUD</strong> is well known when you want to create a complete data processing system (<strong class="bold">Create-Read-Update-Delete</strong>). It is traditionally used in interfaces, APIs, databases, and Web Apps, but it does not consider actions such as pagination, search, or sorting. BREAD was born as an expansion to highlight the fact that information must be navigable, browsea: Browse-Read-Edit-Add-Delete.</p>
			<p class="callout">Reference: <a href="https://guvena.wordpress.com/2017/11/12/bread-is-the-new-crud/">https://guvena.wordpress.com/2017/11/12/bread-is-the-new-crud/</a>.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>