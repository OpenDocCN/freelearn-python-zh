- en: Making a Command-Line Utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we visited some best practices that would help us in
    the long run when using Python. In this chapter, we're going to see how to make
    Python command-line programs and some features that make such programs easier
    and more useful. We're going to see how to create an entry point for code execution
    in a package and see how to run the package as a program.
  prefs: []
  type: TYPE_NORMAL
- en: We're also going to see how to make the program read data from its command line
    and how to easily handle reading data from our program's command-line arguments.
    We'll also look at how to actually run other programs from inside our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a package executable via Python `-m`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling command-line argument with `argparse`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python tools to interact with the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing other programs with subprocess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shell script or batch files to run our programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a package executable via Python -m
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we ran command-line tools, such as `doctest` and `venv`,
    by typing in the `python3 -m` command followed by the name of the tool we wanted
    it to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7708e7b2-2b70-4976-a5bb-db912475dd01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What were we actually asking Python to do when we did that?
  prefs: []
  type: TYPE_NORMAL
- en: The `-m` command-line switch for Python tells it to run a module. It uses the
    same mechanism to find the module that it would if we'd used an `import` statement
    with the module's name and then it executes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `venv` isn''t a module, it''s a package. So, what''s happening when
    we use `python -m venv`? We gave Python a package name, but we didn''t give it
    a module name inside the package that it should run. When that happens, Python
    looks for a module named `__main__` in the package and runs that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86829831-f3ee-469a-8014-1b8f271088bb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, `python -m venv` means the same thing as `python -m venv.__main__`.
  prefs: []
  type: TYPE_NORMAL
- en: Any module that's meant to contain a program's entry point has a problem because
    simply importing the module will run the code too. This can be annoying or troublesome
    at the best of times, but it becomes unacceptable when we're using tools, such
    as Sphinx or doctest, that need to import modules in order to do their jobs, but
    which really shouldn't actually run the module code as a program.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there's an easy fix because the Python interpreter itself knows
    which module it was told to start running and marks it as such. All modules are
    automatically given a variable called `__name__`, which contains the module's
    name. All modules, that is, except for the program entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program entry point is always given the name `__main__`, even if its filename
    is something entirely different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c876c86-f805-4e4d-81d5-6471f1450d5c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, we can check whether our code was the program entry point by checking this,
    `__name__ == '__main__'`. If our code was indeed the program entry point, then
    we should run the program, as in the example above. If it isn't, we would import
    it normally as code and should not run the program as main code.
  prefs: []
  type: TYPE_NORMAL
- en: This distinguishes between importing of the `__main__` module of the package
    and running it. Because when we import it, the name variable contains the package
    name `__main__`, not just `__main__`. In the upcoming sections in this chapter,
    we're going to work through the process of building a complete utility program
    called **Pipeline**.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipeline will be a text-mode program that can be configured to run a sequence
    of other programs and feed data from each program into the next. In each section,
    we'll apply what we talked about developing Pipeline further.
  prefs: []
  type: TYPE_NORMAL
- en: So far, what we talked about in this chapter is how to make the program able
    to be run from `python -m`, but in the previous chapters, we saw how to create
    a virtual environment to work in, how to create a package, and how to layout the
    code in the packages modules for readability.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's put those lessons to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder within the virtual environment to be the package and call it
    `pipeline`. Inside the `package` folder, place an `__init__.py` file, which can
    be empty, and a `__main__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94ad8085-b6b8-4473-b127-d286074bc5ea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For now, the contents of the `__main__.py` file can be very simple, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3a07e6f-53d5-4ce2-ae82-c7a3a36ca49f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The contents of the `__main__.py` file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A docstring for the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that should be called if the module is the program entry point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `if` statement that decides whether or not to call the **launch function**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The launch function doesn't have a docstring, which is allowed because it's
    marked as non-public by having an underscore as the first letter of its name.
    The launch function also doesn't do anything interesting yet; it just uses the
    print function to tell us that it was successfully executed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run it so we can see for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Open a command-line window,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the virtual environment where we created the package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7d01bc6-4d55-454e-bb00-808b1d21e48a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We should see the message printed out (as shown in the preceding screenshot)
    and then the program will end.
  prefs: []
  type: TYPE_NORMAL
- en: Handling command-line arguments with argparse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll see how to make the program read data from its command
    line, a common feature for programs of all sorts. Most command-line programs and
    a surprising number of graphical user interface programs as well can be given
    extra information on the command line, after the command that invokes the program.
    These extra bits of information are referred to as **arguments** and they are
    delivered to Python programs as a list of strings. It turns out that there's quite
    a lot of code involved in turning an argument list into useful information, especially,
    if we want to make the program as convenient for our users as possible. Fortunately,
    a lot of that code can be the same from program to program, and the Python standard
    library's **argparse** module takes care of much of the effort for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ArgumentParser object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary component of the `argparse` module is the `ArgumentParser` class.
    In the minimal case, it only takes three lines of code to use `argparse`. We need
    to import it, create an argument parser instance, and call that instance''s `parse_args()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55cb4b89-7a8b-4907-b5cc-65d1907de2f7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As usual, with minimal cases that's not very useful. The only arguments that
    the program will respond to are `-h` or `--help`, either of which would print
    out an automatically generated `how to use this program` message and then exit
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we could do to make the `ArgumentParser` class more useful
    is to provide a value for the `description` parameter of its constructor, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4100d3b-1264-4c12-9f1c-5ffee58fa9df.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ArgumentParser's automatically generated help message will explain all the arguments
    that the program expects, but it doesn't say anything about what the program is
    actually supposed to do, unless we provide a description ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next way we can improve the ArgumentParser''s behavior is by telling it
    the name of the program. If we don''t provide a name, it will do its best to make
    a reasonable guess, but we''re better off telling it ourselves. I consider the
    `python3 -m` command (refer to the following code example) to be the canonical
    name for my own programs so that''s what we''ll use in our examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9bd1132-8524-4c32-8d46-6e36dc6e1906.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the name of argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We set the name of an argument by passing it as a string to the `ArgumentParser`
    constructor's `prog` parameter. These changes make the help output of the program
    prettier and more useful, but they don't actually give the program any new capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We need to start adding argument specifications to the parser, so it can check
    for them in the argument list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do that by calling the `ArgumentParser` instance''s `add_argument` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/081e4595-1f00-4df7-bc52-de2106ddf0ea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `argparse` module recognizes two kinds of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Optional arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positional arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the name implies, **optional arguments** are not required, but if the user
    chooses to include them, they have meaning. **Positional arguments**, on the other
    hand, are required by default, although we can modify that behavior. Optional
    arguments have names that start with the `-` character. They can have more than
    one alternate name for the same argument. The names are passed as parameters to
    the `add_argument` method, as in the preceding example, where `-p` and `--print`
    are alternate names for the same optional argument.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of ways of configuring an argument when we add it to the parser,
    which are detailed in the `argparse` documentation in the library reference at
    [https://docs.python.org/3/](https://docs.python.org/3/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For options like our print example though, the important configuration items
    are `action` and `default`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `action` parameter tells `argparse` what to do when it finds the argument
    on the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default` parameter tells it what to do when it doesn't find the argument
    on the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `action` parameter can either be a string containing the name of one of
    the well-known actions, such as `store_true`, or it could be a subclass of the
    `argparse.action` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/268fc3eb-9a19-4411-89fc-07303539e8f1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `default` parameter can be any arbitrary value, which will be stored as
    the value of the argument. If it's missing when we actually ask the `parser` to
    parse out the argument values, the other kind of argument has to have just one
    name and it can't start with a `-` character.
  prefs: []
  type: TYPE_NORMAL
- en: By default, these arguments collect one word that isn't part of an optional
    argument from the command line in the order that they were added to the parser.
    If we configure the argument using the `nargs` option, we can change the number
    of words that the argument collects.
  prefs: []
  type: TYPE_NORMAL
- en: nargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we set `nargs` to a number, that many words will be collected for the argument.
    We can also set `nargs` to `*` to mean any number of words or `+` to mean at least
    one word. There are a few other values we could set `nargs` to, but we won't talk
    about them here in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look back at our Pipeline program. I think we want it to understand
    two arguments-an `optional` argument that tells it to keep going, even if one
    of the programs returns an error code, and a filename, where it should load and
    store a pipeline configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b0c5e43-5496-4877-ba32-e0a176d61ad2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After the call to parse `parse_args`, we have an object named `args` that contains
    a `keep_going` attribute set to either `true` or `false` and a `filename` attribute
    containing a string.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the attribute of the arguments object is `keep_going`, not `keep-going`.
    Python doesn't allow `-` characters inside of attribute names and `argparse` is
    smart enough to fix that for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to set the name of the argument object attribute manually, we could
    have passed the name we wanted to the `add_argument` method as its best parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Python tools to interact with the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how to get information from the user on the
    command line, but what do we do when we need a more dynamic form of interaction?
    So, let's take a look at some of Python's tools for sending information to the
    user and requesting information from the user.
  prefs: []
  type: TYPE_NORMAL
- en: Python's built-in functions - print and input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fundamentals of interactivity are simple. We need to be able to tell the
    user things and we need the user to be able to tell us things. In service of those
    two goals, Python provides two built-in functions. These are `print` and `input`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `simple.py` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d62021f-27e7-4b79-8c36-319b6af93530.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `print` function takes any number of Python objects as parameters and prints
    them on the screen. The `input` function takes a string prompt as its parameter,
    prints it out, then reads text until the user hits *Enter*, and returns what the
    user typed as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to see how the `print` and `input` functions work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s about as simple as interactivity can get. The following screenshot
    shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/004d1d55-dd68-4898-914b-4ed3dcb65a3f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `print` and `input` functions can do a lot, but there are a couple of corner
    cases where they don't work so well.
  prefs: []
  type: TYPE_NORMAL
- en: The getpass package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of those corner cases I just mentioned is when we want the user to type
    in a password. If we use the `input` function to read the password, it would be
    displayed on the screen for anybody to read. The `getpass` package contains a
    function, also called `getpass`, which works just like `input`, except that it
    doesn't show the text that the user types.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6436f6cd-4ec0-48fc-8d46-8e2b7ada0e5c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other corner case I want to mention is that, although the `print`  function
    can print out any Python object, it doesn't do a good job presenting complex data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: The pprint package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pprint` function, from the package of the same name, makes complex data
    structures much more readable. If we want to display a list of dictionaries, `pprint`
    will do a better job of it than the `print` function would.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `special.py` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d12adfd5-c031-4985-9656-934dfa0a8470.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the following command to execute the `special.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97978ef3-bccf-4f42-ba90-e88c389a366e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Between these four functions - `print`, `input`, `getpass`, and `pprint` - there's
    a wide range of user interfaces we could make, but they are pretty basic tools.
    We'd be reinventing a lot of wheels and wasting time. Fortunately, thanks to Python's
    *batteries included* philosophy, we don't have to do that. Instead, we'll use
    the `cmd` package of the standard libraries to quickly build our user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The cmd class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All we have to do is inherit from the `cmd` class and define the methods that
    implement commands the user can type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `usecmd.py` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71be32bb-288a-450d-9e93-63cfc2ae4f32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll set the prompt attribute to a string that will be used to prompt the
    user for a command. Run the following command to execute the `usecmd.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66c6e417-b161-461a-9275-cf7ca3ed803e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we''ll create an instance of our `Interface` class (shown in the following
    screenshot) and call it the `cmdloop` method. Presto! Instant interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/942b5989-76ae-420b-94ec-05172467b332.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we see that the `cmd` class takes care of displaying props,
    reading and commands, and invoking the correct methods, but that's all it does.
    We still need the `print` function if we want to display data from inside of a
    command handler method.
  prefs: []
  type: TYPE_NORMAL
- en: The `cmd` class isn't exclusive. It does a lot of work for us, but we could
    still use the `print` and `input` functions directly, if we need to. That's very
    nearly everything there is to say about text mode interactivity in Python, at
    least if we want our programs to be portable across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The Pipeline user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's another standard library module called `curses`, which enables much
    more sophisticated text load operations; however, as the `curses` module is not
    portable to Windows, we're not going to go into detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let''s look at defining the user interface for our **Pipeline** program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/feca7569-39dd-4280-9b2f-a545966ed81e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it seems like we''d want to be able to add programs to Pipeline and manipulate
    the data passing between the programs in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d99c6ec-3ca7-4ee2-a699-3f309e36f14f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We'll also want to be able to save the pipeline when we're happy with it and
    to be able to actually run it. Finally, we'll want to be able to quit the program
    using the `quit` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `help` command would also be helpful, but luckily, the `cmd` class will provide
    that automatically using the `docstrings` for the command handler functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e05f26cc-fef3-4fc3-b6d8-b88eb3a8bb12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We're just going to stub in the command handlers here because we're focusing
    on the interface implementation for now. So, there we have a pretty decent user
    interface with very little work on our part. That wraps up our look at text-mode
    interaction here. Let's now focus on some of our options around program control.
  prefs: []
  type: TYPE_NORMAL
- en: Executing other programs with subprocess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to execute and control other programs from
    within our own, allowing us to create the heart of our example program. This ability
    is often useful for all sorts of system automation tasks. Create an `echo.py`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d789add-216e-49ee-b304-1843ca0b448d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making other programs run used to be something of a mess. There were different
    mechanisms that worked on different platforms, there were mechanisms that were
    convenient and there were different mechanisms that were secure. Fortunately,
    all that changed since Python version 2.4 with the introduction of the `subprocess`
    module, which abstracts away the differences between platforms and makes some
    more secure paradigms easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Subprocess and its variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are six objects in the `subprocess` package that are of particular interest.
    Three of them are the `call`, `check_call`, and `check_output` functions, which
    are three variants on the same basic idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These three objects run a program, wait for it to terminate, and then tell
    us something about what the program did:'
  prefs: []
  type: TYPE_NORMAL
- en: The `call` function returns the program's exit code, which is an integer that
    has a program-defined meaning, which is usually used to know whether the program
    has succeeded or failed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `check_call` function raises an exception if the program's exit code is
    non-zero, which, by convention, means that it exited with an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `check_output` function returns whatever text the program printed and raises
    an exception if the program exited with a non-zero exit code. The raised exception
    has an attribute called `output` that contains the text output of the program.
    So, even if the program exited with an error code, we could still get the output
    if we want it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `run` function is similar to the `call` function we were looking at just
    a moment ago:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In fact, the `run` function is capable of doing anything that anyone would do,
    in combination. However it is not necessarily possible to use it in other projects,
    at least not yet.
  prefs: []
  type: TYPE_NORMAL
- en: The three call functions and the run function are invoked in largely the same
    way. Each of them is passed as a list containing the program name and its arguments.
    We see the output of this `'ls','-l'` function on the screen that wasn't from
    the call because `'ls','-l'` prints something out when it runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2469ea6e-4110-43d6-800b-dd5ca6b0d595.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The exit code returned `0`, though. So that becomes your call. If you wanted
    to take that printout from the `'ls'` program and use it in our program, we need
    to capture it.
  prefs: []
  type: TYPE_NORMAL
- en: The `check_output` function has a noteworthy keyword-only parameter called `universal_newlines`,
    which defaults to `False`. If we set `universal_newlines` to `True`, the text
    output of the program is decoded into unicode characters, using the system's default
    text codec, and the newline characters are normalized.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we leave `universal_newlines` at its default value of `False`, the program
    output is returned as bytes and it''s up to us to do any decoding and to deal
    with whatever sequence of characters the current system considers to be a newline
    character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now type the following and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code example, we did set `universal_newlines` to `True` and then split
    it at `\n`, which is the standard newline character, and that gave us back a list
    of the lines that are output from the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52af42cf-6348-4020-8a1b-dda1e719bfc1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we want to get fancier with our running of other programs, we'll want to
    use instances of the `Popen` class-the fourth interesting thing in the `subprocess`
    package and which allows us a great deal of flexibility and control over the execution
    of other programs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Popen subprocess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the cost of a bit more complexity, the `Popen` constructor accepts the same
    list of program and command-line arguments that the call functions do and a very
    large number of optional keyword arguments, including `universal_newlines`.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to focus on a particular use of the `Popen` constructor that is
    useful, but goes beyond what we can achieve using one of the call functions. We're
    going to see how to run a program in the background while our own code is also
    running, and send and receive data between the two programs.
  prefs: []
  type: TYPE_NORMAL
- en: The PIPE constant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To manage that, we''re going to need the last of our six interesting things
    in the `subprocess` package-the `PIPE` constant. The `PIPE` constant is used in
    conjunction with the `stdin`, `stdout`, or `stderr` keyword parameters of the
    `Popen` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These parameters represent the other program's textual input, output, and error
    reporting. Any of them that we set to `PIPE` are redirected to our program. In
    the preceding example, we're redirecting the program's inputs and output to ourselves,
    which gives us a bi-directional data channel with the other programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you see, we are interacting programmatically with the code on screen that
    was at the beginning of this example. However, since it sets in a loop, inputs,
    and then outputs, accord. Also, whenever there is input, once we have `PIPE` set
    up, we could send data to the other program by calling the `write` method on the
    Popen object''s `stdin` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05f55bf5-c7bb-4baf-982c-742dca0180f6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can read data by calling the `read` method or its relatives on the Popen
    object's `stdout` attribute, as shown in the preceding example code.
  prefs: []
  type: TYPE_NORMAL
- en: In spite of disabling buffering with the `bufsize = 0` parameter to the `Popen`
    constructor, it's usually a good idea to call the `flush` method on `stdin` after
    writing to it and on `stdout` before reading from it. We can keep on sending and
    receiving data for as long as both programs are running. However, if the time
    comes when we're done interacting and just want to wait for the other program
    to terminate, we can call the Popen object's `wait` method to do that.
  prefs: []
  type: TYPE_NORMAL
- en: The wait method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `wait` method will return the exit code of the other program once it''s
    done running. A lot of the complexity of working with `PIPE`, `stdin`, and `stdout`
    is wrapped up in the `Popen` class''s `communicate` method, which accepts the
    input as a parameter and returns the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c1f0a89-bd57-47f9-8f33-8daca8e3650a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Communication is simple, but somewhat limited because it can only be called
    once for each `Popen` object and doesn't return until the other program finishes.
    This isn't any good for two programs that need to talk back and forth to each
    other, but it should be just perfect for our pipeline program, where each program
    receives the output of the previous program as its input.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up our code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to create a bunch of classes to represent the different kinds of
    steps in the pipeline and integrate those classes into the interface as well.
    Once we've done that, the program is functional, although there's plenty of room
    for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Our particular interest is the `ExecStep` class on the top right-hand side of
    the following screenshot, which uses `Popen` to actually execute a program and
    break free of the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2b4eb14-bff6-4b46-8db4-bf89a74d2e7d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've got our example program working now, so we're going to move on to the
    last section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a shell script or batch file to launch the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to wrap up this chapter''s example program by
    making it simple to launch. We can run our program using `python -m` as long as
    it''s installed in the system `PYTHONPATH` or we''ve activated the virtual environment
    containing it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66009b75-2947-4004-bd9b-836294b749b5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating launches for our program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the program is solid, we really just want to be able to type its name
    or double-click on it and have it run. One convenient way to do that is to use
    a shell script or a batch file:'
  prefs: []
  type: TYPE_NORMAL
- en: On Unix-style operating systems including macOS, a shell script is a text file
    that starts with `#bang/bin/sh` and has been marked as executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, a batch file is a file whose name ends in `.bat`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both shell scripts and batch files are text files containing a sequence of command-line
    commands, one on each line. When we type the name of the script or batch file,
    those commands are executed one after the other, as if we type them all into the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if we trigger the script or batch file through a graphical user
    interface, the commands are still executed as if we typed them into a command
    line one by one. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec7b834a-3cc2-42c4-90e9-b84dbb98aa9f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For our purposes here, this means that we can put whatever sequence of commands
    necessary to launch a program into a shell script or a batch file. After that,
    we could treat that script as if it were the program itself. That's all there
    is to the simple case.
  prefs: []
  type: TYPE_NORMAL
- en: Shell scripts are capable of representing a lot more complexity, but Python
    is a better tool for that. So, the simple case, here, is all we really need.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the earlier sections of the chapter, you learned about how to make our Python
    packages into programs, get data from the command line, interact with the user,
    and run other programs as subprocesses. We saw how to make our Python programs
    as simple to watch as any other program from the GUI or the command line. We constructed
    a user interface for our Pipeline program and learned about several of Python's
    text mode tools along the way.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how to use parallel processing to take advantage
    of computers with multiple processors or cores.
  prefs: []
  type: TYPE_NORMAL
