- en: Making a Command-Line Utility
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令行实用工具
- en: In the previous chapter, we visited some best practices that would help us in
    the long run when using Python. In this chapter, we're going to see how to make
    Python command-line programs and some features that make such programs easier
    and more useful. We're going to see how to create an entry point for code execution
    in a package and see how to run the package as a program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了一些有助于我们长期使用 Python 的最佳实践。在本章中，我们将探讨如何创建 Python 命令行程序以及使这些程序更易于使用和更有用的特性。我们将学习如何在包中创建代码执行入口点，以及如何将包作为程序运行。
- en: We're also going to see how to make the program read data from its command line
    and how to easily handle reading data from our program's command-line arguments.
    We'll also look at how to actually run other programs from inside our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将了解如何使程序从其命令行读取数据，以及如何轻松处理从程序命令行参数读取数据。我们还将探讨如何在代码内部实际运行其他程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Making a package executable via Python `-m`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Python `-m` 使包可执行
- en: Handling command-line argument with `argparse`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `argparse` 处理命令行参数
- en: Python tools to interact with the user
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 工具用于与用户交互
- en: Executing other programs with subprocess
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 subprocess 执行其他程序
- en: Using shell script or batch files to run our programs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 shell 脚本或批处理文件来运行我们的程序
- en: Making a package executable via Python -m
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Python -m 使包可执行
- en: 'In the previous chapter, we ran command-line tools, such as `doctest` and `venv`,
    by typing in the `python3 -m` command followed by the name of the tool we wanted
    it to run:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过输入 `python3 -m` 命令后跟要运行的工具名称来运行命令行工具，如 `doctest` 和 `venv`：
- en: '![](img/7708e7b2-2b70-4976-a5bb-db912475dd01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7708e7b2-2b70-4976-a5bb-db912475dd01.jpg)'
- en: What were we actually asking Python to do when we did that?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们实际上要求 Python 做什么？
- en: The `-m` command-line switch for Python tells it to run a module. It uses the
    same mechanism to find the module that it would if we'd used an `import` statement
    with the module's name and then it executes it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `-m` 命令行选项告诉它运行一个模块。它使用与使用模块名称的 `import` 语句相同的机制来查找模块，然后执行它。
- en: 'However, `venv` isn''t a module, it''s a package. So, what''s happening when
    we use `python -m venv`? We gave Python a package name, but we didn''t give it
    a module name inside the package that it should run. When that happens, Python
    looks for a module named `__main__` in the package and runs that:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`venv` 不是一个模块，而是一个包。那么，当我们使用 `python -m venv` 时发生了什么？我们给了 Python 一个包名，但没有给它一个包内应该运行的模块名。在这种情况下，Python
    会查找包中的名为 `__main__` 的模块并运行它：
- en: '![](img/86829831-f3ee-469a-8014-1b8f271088bb.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86829831-f3ee-469a-8014-1b8f271088bb.jpg)'
- en: So, `python -m venv` means the same thing as `python -m venv.__main__`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`python -m venv` 与 `python -m venv.__main__` 意义相同。
- en: Any module that's meant to contain a program's entry point has a problem because
    simply importing the module will run the code too. This can be annoying or troublesome
    at the best of times, but it becomes unacceptable when we're using tools, such
    as Sphinx or doctest, that need to import modules in order to do their jobs, but
    which really shouldn't actually run the module code as a program.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何打算包含程序入口点的模块都存在问题，因为简单地导入模块也会运行代码。在最坏的情况下，这可能会很烦人或有麻烦，但当我们使用像 Sphinx 或 doctest
    这样的工具时，这些工具需要导入模块来完成工作，但实际上不应该作为程序运行模块代码，这时就变得无法接受了。
- en: Fortunately, there's an easy fix because the Python interpreter itself knows
    which module it was told to start running and marks it as such. All modules are
    automatically given a variable called `__name__`, which contains the module's
    name. All modules, that is, except for the program entry point.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个简单的解决方案，因为 Python 解释器本身知道它被指示启动运行的模块，并将其标记为这样的模块。所有模块都自动赋予一个名为 `__name__`
    的变量，该变量包含模块的名称。也就是说，所有模块都如此，除了程序入口点。
- en: 'The program entry point is always given the name `__main__`, even if its filename
    is something entirely different:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 程序入口点始终命名为 `__main__`，即使其文件名完全不同：
- en: '![](img/8c876c86-f805-4e4d-81d5-6471f1450d5c.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c876c86-f805-4e4d-81d5-6471f1450d5c.jpg)'
- en: So, we can check whether our code was the program entry point by checking this,
    `__name__ == '__main__'`. If our code was indeed the program entry point, then
    we should run the program, as in the example above. If it isn't, we would import
    it normally as code and should not run the program as main code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过检查这个，`__name__ == '__main__'` 来检查我们的代码是否是程序入口点。如果我们的代码确实是程序入口点，那么我们应该像上面的例子那样运行程序。如果不是，我们将像普通代码一样导入它，不应将程序作为主代码运行。
- en: This distinguishes between importing of the `__main__` module of the package
    and running it. Because when we import it, the name variable contains the package
    name `__main__`, not just `__main__`. In the upcoming sections in this chapter,
    we're going to work through the process of building a complete utility program
    called **Pipeline**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这区分了包的 `__main__` 模块的导入和运行。因为当我们导入它时，名称变量包含包名 `__main__`，而不仅仅是 `__main__`。在本章接下来的部分，我们将通过构建一个名为
    **Pipeline** 的完整实用程序的过程进行操作。
- en: Pipeline program
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道程序
- en: Pipeline will be a text-mode program that can be configured to run a sequence
    of other programs and feed data from each program into the next. In each section,
    we'll apply what we talked about developing Pipeline further.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 管道程序将是一个文本模式程序，可以配置为运行一系列其他程序，并将每个程序的数据馈送到下一个程序。在每个部分，我们将进一步开发管道程序。
- en: So far, what we talked about in this chapter is how to make the program able
    to be run from `python -m`, but in the previous chapters, we saw how to create
    a virtual environment to work in, how to create a package, and how to layout the
    code in the packages modules for readability.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中我们讨论的是如何使程序能够通过 `python -m` 运行，但在前面的章节中，我们看到了如何创建工作环境，如何创建包，以及如何在包的模块中布局代码以提高可读性。
- en: So, let's put those lessons to use.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们应用这些课程。
- en: 'Create a folder within the virtual environment to be the package and call it
    `pipeline`. Inside the `package` folder, place an `__init__.py` file, which can
    be empty, and a `__main__.py` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境中创建一个文件夹作为包，并命名为 `pipeline`。在 `package` 文件夹中放置一个 `__init__.py` 文件，它可以空着，以及一个
    `__main__.py` 文件：
- en: '![](img/94ad8085-b6b8-4473-b127-d286074bc5ea.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94ad8085-b6b8-4473-b127-d286074bc5ea.jpg)'
- en: 'For now, the contents of the `__main__.py` file can be very simple, as shown
    in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`__main__.py` 文件的内容可以非常简单，如下面的屏幕截图所示：
- en: '![](img/e3a07e6f-53d5-4ce2-ae82-c7a3a36ca49f.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3a07e6f-53d5-4ce2-ae82-c7a3a36ca49f.jpg)'
- en: 'The contents of the `__main__.py` file are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__.py` 文件的内容如下：'
- en: A docstring for the module
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的文档字符串
- en: A function that should be called if the module is the program entry point
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模块是程序入口点，则应该调用的函数
- en: The `if` statement that decides whether or not to call the **launch function**
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定是否调用**启动函数**的 `if` 语句
- en: The launch function doesn't have a docstring, which is allowed because it's
    marked as non-public by having an underscore as the first letter of its name.
    The launch function also doesn't do anything interesting yet; it just uses the
    print function to tell us that it was successfully executed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 启动函数没有文档字符串，这是允许的，因为它以名称的第一个字母为下划线标记为非公共的。启动函数目前也没有做什么有趣的事情；它只是使用打印函数告诉我们它已成功执行。
- en: Let's run it so we can see for ourselves.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它，以便我们可以亲自看到。
- en: Open a command-line window,
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个命令行窗口，
- en: Go to the virtual environment where we created the package
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往我们创建包的虚拟环境
- en: Activate the virtual environment.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活虚拟环境。
- en: 'Then, type the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输入以下命令：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/f7d01bc6-4d55-454e-bb00-808b1d21e48a.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7d01bc6-4d55-454e-bb00-808b1d21e48a.jpg)'
- en: We should see the message printed out (as shown in the preceding screenshot)
    and then the program will end.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到打印出的消息（如前一个屏幕截图所示），然后程序将结束。
- en: Handling command-line arguments with argparse
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 argparse 处理命令行参数
- en: In this section, we'll see how to make the program read data from its command
    line, a common feature for programs of all sorts. Most command-line programs and
    a surprising number of graphical user interface programs as well can be given
    extra information on the command line, after the command that invokes the program.
    These extra bits of information are referred to as **arguments** and they are
    delivered to Python programs as a list of strings. It turns out that there's quite
    a lot of code involved in turning an argument list into useful information, especially,
    if we want to make the program as convenient for our users as possible. Fortunately,
    a lot of that code can be the same from program to program, and the Python standard
    library's **argparse** module takes care of much of the effort for us.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ArgumentParser object
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary component of the `argparse` module is the `ArgumentParser` class.
    In the minimal case, it only takes three lines of code to use `argparse`. We need
    to import it, create an argument parser instance, and call that instance''s `parse_args()`
    function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55cb4b89-7a8b-4907-b5cc-65d1907de2f7.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: As usual, with minimal cases that's not very useful. The only arguments that
    the program will respond to are `-h` or `--help`, either of which would print
    out an automatically generated `how to use this program` message and then exit
    the program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we could do to make the `ArgumentParser` class more useful
    is to provide a value for the `description` parameter of its constructor, as shown
    in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4100d3b-1264-4c12-9f1c-5ffee58fa9df.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: ArgumentParser's automatically generated help message will explain all the arguments
    that the program expects, but it doesn't say anything about what the program is
    actually supposed to do, unless we provide a description ourselves.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The next way we can improve the ArgumentParser''s behavior is by telling it
    the name of the program. If we don''t provide a name, it will do its best to make
    a reasonable guess, but we''re better off telling it ourselves. I consider the
    `python3 -m` command (refer to the following code example) to be the canonical
    name for my own programs so that''s what we''ll use in our examples:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9bd1132-8524-4c32-8d46-6e36dc6e1906.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Setting the name of argument
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We set the name of an argument by passing it as a string to the `ArgumentParser`
    constructor's `prog` parameter. These changes make the help output of the program
    prettier and more useful, but they don't actually give the program any new capabilities.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: We need to start adding argument specifications to the parser, so it can check
    for them in the argument list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'We do that by calling the `ArgumentParser` instance''s `add_argument` method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/081e4595-1f00-4df7-bc52-de2106ddf0ea.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'The `argparse` module recognizes two kinds of arguments:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Optional arguments
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positional arguments
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the name implies, **optional arguments** are not required, but if the user
    chooses to include them, they have meaning. **Positional arguments**, on the other
    hand, are required by default, although we can modify that behavior. Optional
    arguments have names that start with the `-` character. They can have more than
    one alternate name for the same argument. The names are passed as parameters to
    the `add_argument` method, as in the preceding example, where `-p` and `--print`
    are alternate names for the same optional argument.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of ways of configuring an argument when we add it to the parser,
    which are detailed in the `argparse` documentation in the library reference at
    [https://docs.python.org/3/](https://docs.python.org/3/).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'For options like our print example though, the important configuration items
    are `action` and `default`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The `action` parameter tells `argparse` what to do when it finds the argument
    on the command line
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default` parameter tells it what to do when it doesn't find the argument
    on the command line
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `action` parameter can either be a string containing the name of one of
    the well-known actions, such as `store_true`, or it could be a subclass of the
    `argparse.action` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/268fc3eb-9a19-4411-89fc-07303539e8f1.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: The `default` parameter can be any arbitrary value, which will be stored as
    the value of the argument. If it's missing when we actually ask the `parser` to
    parse out the argument values, the other kind of argument has to have just one
    name and it can't start with a `-` character.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: By default, these arguments collect one word that isn't part of an optional
    argument from the command line in the order that they were added to the parser.
    If we configure the argument using the `nargs` option, we can change the number
    of words that the argument collects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: nargs
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we set `nargs` to a number, that many words will be collected for the argument.
    We can also set `nargs` to `*` to mean any number of words or `+` to mean at least
    one word. There are a few other values we could set `nargs` to, but we won't talk
    about them here in this section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look back at our Pipeline program. I think we want it to understand
    two arguments-an `optional` argument that tells it to keep going, even if one
    of the programs returns an error code, and a filename, where it should load and
    store a pipeline configuration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b0c5e43-5496-4877-ba32-e0a176d61ad2.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: After the call to parse `parse_args`, we have an object named `args` that contains
    a `keep_going` attribute set to either `true` or `false` and a `filename` attribute
    containing a string.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the attribute of the arguments object is `keep_going`, not `keep-going`.
    Python doesn't allow `-` characters inside of attribute names and `argparse` is
    smart enough to fix that for us automatically.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to set the name of the argument object attribute manually, we could
    have passed the name we wanted to the `add_argument` method as its best parameter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Python tools to interact with the user
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python与用户交互的工具
- en: In the previous section, we saw how to get information from the user on the
    command line, but what do we do when we need a more dynamic form of interaction?
    So, let's take a look at some of Python's tools for sending information to the
    user and requesting information from the user.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何在命令行中从用户那里获取信息，但当我们需要更动态的交互形式时，我们该怎么办？所以，让我们来看看Python的一些工具，用于向用户发送信息并从用户那里获取信息。
- en: Python's built-in functions - print and input
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的内置函数——`print`和`input`
- en: The fundamentals of interactivity are simple. We need to be able to tell the
    user things and we need the user to be able to tell us things. In service of those
    two goals, Python provides two built-in functions. These are `print` and `input`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 交互性的基础很简单。我们需要能够告诉用户事情，并且我们需要用户能够告诉我们事情。为了实现这两个目标，Python提供了两个内置函数。这些是`print`和`input`。
- en: 'Create a `simple.py` file with the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的`simple.py`文件：
- en: '![](img/1d62021f-27e7-4b79-8c36-319b6af93530.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d62021f-27e7-4b79-8c36-319b6af93530.jpg)'
- en: The `print` function takes any number of Python objects as parameters and prints
    them on the screen. The `input` function takes a string prompt as its parameter,
    prints it out, then reads text until the user hits *Enter*, and returns what the
    user typed as a string.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`函数接受任意数量的Python对象作为参数，并将它们打印到屏幕上。`input`函数接受一个字符串提示作为其参数，将其打印出来，然后读取文本，直到用户按下*Enter*键，并返回用户输入的字符串。'
- en: 'Run the following command to see how the `print` and `input` functions work:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以查看`print`和`input`函数的工作方式：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That''s about as simple as interactivity can get. The following screenshot
    shows the output of the preceding command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 交互性可以简单到这种程度。以下截图显示了前面命令的输出：
- en: '![](img/004d1d55-dd68-4898-914b-4ed3dcb65a3f.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/004d1d55-dd68-4898-914b-4ed3dcb65a3f.jpg)'
- en: The `print` and `input` functions can do a lot, but there are a couple of corner
    cases where they don't work so well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`和`input`函数可以做很多事情，但有几个边缘情况它们处理得不是很好。'
- en: The getpass package
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getpass`包'
- en: One of those corner cases I just mentioned is when we want the user to type
    in a password. If we use the `input` function to read the password, it would be
    displayed on the screen for anybody to read. The `getpass` package contains a
    function, also called `getpass`, which works just like `input`, except that it
    doesn't show the text that the user types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才提到的那些边缘情况之一是我们想要用户输入密码。如果我们使用`input`函数来读取密码，它就会显示在屏幕上，任何人都可以阅读。`getpass`包包含一个名为`getpass`的函数，它的工作方式与`input`类似，但不会显示用户输入的文本。
- en: '![](img/6436f6cd-4ec0-48fc-8d46-8e2b7ada0e5c.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6436f6cd-4ec0-48fc-8d46-8e2b7ada0e5c.jpg)'
- en: The other corner case I want to mention is that, although the `print`  function
    can print out any Python object, it doesn't do a good job presenting complex data
    structures.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想提到的另一个边缘情况是，尽管`print`函数可以打印出任何Python对象，但它并不擅长展示复杂的数据结构。
- en: The pprint package
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`pprint`包'
- en: The `pprint` function, from the package of the same name, makes complex data
    structures much more readable. If we want to display a list of dictionaries, `pprint`
    will do a better job of it than the `print` function would.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 来自同名包的`pprint`函数使复杂的数据结构更容易阅读。如果我们想显示字典列表，`pprint`会比`print`函数做得更好。
- en: 'Create a `special.py` file with the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的`special.py`文件：
- en: '![](img/d12adfd5-c031-4985-9656-934dfa0a8470.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d12adfd5-c031-4985-9656-934dfa0a8470.jpg)'
- en: 'Run the following command to execute the `special.py` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来执行`special.py`文件：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot is the output of the preceding command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是前面命令的输出：
- en: '![](img/97978ef3-bccf-4f42-ba90-e88c389a366e.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97978ef3-bccf-4f42-ba90-e88c389a366e.jpg)'
- en: Between these four functions - `print`, `input`, `getpass`, and `pprint` - there's
    a wide range of user interfaces we could make, but they are pretty basic tools.
    We'd be reinventing a lot of wheels and wasting time. Fortunately, thanks to Python's
    *batteries included* philosophy, we don't have to do that. Instead, we'll use
    the `cmd` package of the standard libraries to quickly build our user interface.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四个函数——`print`、`input`、`getpass`和`pprint`——之间，我们可以创建广泛范围的用户界面，但它们都是非常基本的工具。我们将会重新发明很多轮子，浪费时间。幸运的是，得益于Python的*batteries
    included*哲学，我们不必这样做。相反，我们将使用标准库中的`cmd`包来快速构建我们的用户界面。
- en: The cmd class
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`cmd`类'
- en: All we have to do is inherit from the `cmd` class and define the methods that
    implement commands the user can type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是从`cmd`类继承并定义实现用户可以输入的命令的方法。
- en: 'Create a `usecmd.py` file with the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的`usecmd.py`文件：
- en: '![](img/71be32bb-288a-450d-9e93-63cfc2ae4f32.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71be32bb-288a-450d-9e93-63cfc2ae4f32.jpg)'
- en: 'We''ll set the prompt attribute to a string that will be used to prompt the
    user for a command. Run the following command to execute the `usecmd.py` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提示属性设置为一个字符串，该字符串将用于提示用户输入命令。运行以下命令以执行`usecmd.py`文件：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/66c6e417-b161-461a-9275-cf7ca3ed803e.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66c6e417-b161-461a-9275-cf7ca3ed803e.jpg)'
- en: 'Next, we''ll create an instance of our `Interface` class (shown in the following
    screenshot) and call it the `cmdloop` method. Presto! Instant interface:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的`Interface`类的一个实例（如下面的截图所示），并将其称为`cmdloop`方法。 presto！即时界面：
- en: '![](img/942b5989-76ae-420b-94ec-05172467b332.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/942b5989-76ae-420b-94ec-05172467b332.jpg)'
- en: In this example, we see that the `cmd` class takes care of displaying props,
    reading and commands, and invoking the correct methods, but that's all it does.
    We still need the `print` function if we want to display data from inside of a
    command handler method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到`cmd`类负责显示提示、读取命令和调用正确的方法，但这只是它所做的一切。如果我们想在命令处理器方法内部显示数据，我们仍然需要`print`函数。
- en: The `cmd` class isn't exclusive. It does a lot of work for us, but we could
    still use the `print` and `input` functions directly, if we need to. That's very
    nearly everything there is to say about text mode interactivity in Python, at
    least if we want our programs to be portable across platforms.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd`类不是唯一的。它为我们做了很多工作，但如果我们需要，我们仍然可以直接使用`print`和`input`函数。这就是关于Python中文本模式交互的所有内容，至少如果我们希望我们的程序能够在不同平台上移植的话。'
- en: The Pipeline user interface
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道用户界面
- en: There's another standard library module called `curses`, which enables much
    more sophisticated text load operations; however, as the `curses` module is not
    portable to Windows, we're not going to go into detail in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个名为`curses`的标准库模块，它能够实现更复杂的文本加载操作；然而，由于`curses`模块无法移植到Windows，我们不会在本章中详细介绍。
- en: 'Instead, let''s look at defining the user interface for our **Pipeline** program:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们看看如何定义我们的**管道**程序的界面：
- en: '![](img/feca7569-39dd-4280-9b2f-a545966ed81e.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/feca7569-39dd-4280-9b2f-a545966ed81e.jpg)'
- en: 'Now it seems like we''d want to be able to add programs to Pipeline and manipulate
    the data passing between the programs in various ways:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们似乎想要能够将程序添加到管道中，并以各种方式操作程序之间的数据传递：
- en: '![](img/0d99c6ec-3ca7-4ee2-a699-3f309e36f14f.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d99c6ec-3ca7-4ee2-a699-3f309e36f14f.jpg)'
- en: We'll also want to be able to save the pipeline when we're happy with it and
    to be able to actually run it. Finally, we'll want to be able to quit the program
    using the `quit` command.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对管道满意时，我们还想能够保存它，并能够实际运行它。最后，我们还想能够使用`quit`命令退出程序。
- en: 'A `help` command would also be helpful, but luckily, the `cmd` class will provide
    that automatically using the `docstrings` for the command handler functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`help`命令也会很有帮助，但幸运的是，`cmd`类将自动使用命令处理函数的`docstrings`来提供这个功能：
- en: '![](img/e05f26cc-fef3-4fc3-b6d8-b88eb3a8bb12.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e05f26cc-fef3-4fc3-b6d8-b88eb3a8bb12.jpg)'
- en: We're just going to stub in the command handlers here because we're focusing
    on the interface implementation for now. So, there we have a pretty decent user
    interface with very little work on our part. That wraps up our look at text-mode
    interaction here. Let's now focus on some of our options around program control.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是简单地设置命令处理器，因为我们现在专注于接口实现。所以，我们得到了一个相当不错的用户界面，而我们几乎不需要做太多工作。这就结束了我们对文本模式交互的探讨。现在，让我们关注一下程序控制的一些选项。
- en: Executing other programs with subprocess
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子进程执行其他程序
- en: 'In this section, you will learn how to execute and control other programs from
    within our own, allowing us to create the heart of our example program. This ability
    is often useful for all sorts of system automation tasks. Create an `echo.py`
    file with the following content:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在我们的程序内部执行和控制其他程序，从而让我们能够创建示例程序的精髓。这种能力对于各种系统自动化任务非常有用。创建一个包含以下内容的`echo.py`文件：
- en: '![](img/7d789add-216e-49ee-b304-1843ca0b448d.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d789add-216e-49ee-b304-1843ca0b448d.jpg)'
- en: Making other programs run used to be something of a mess. There were different
    mechanisms that worked on different platforms, there were mechanisms that were
    convenient and there were different mechanisms that were secure. Fortunately,
    all that changed since Python version 2.4 with the introduction of the `subprocess`
    module, which abstracts away the differences between platforms and makes some
    more secure paradigms easy to use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以前让其他程序运行总是一件有点混乱的事情。不同的平台有不同的机制，有方便的机制，也有不同的安全机制。幸运的是，自从 Python 2.4 版本引入 `subprocess`
    模块以来，所有这些都发生了变化，该模块抽象了平台之间的差异，并使得一些更安全的范式更容易使用。
- en: Subprocess and its variants
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子进程及其变体
- en: 'There are six objects in the `subprocess` package that are of particular interest.
    Three of them are the `call`, `check_call`, and `check_output` functions, which
    are three variants on the same basic idea:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `subprocess` 包中有六个对象特别引人注目。其中三个是 `call`、`check_call` 和 `check_output` 函数，它们都是基于相同基本思想的变体：
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These three objects run a program, wait for it to terminate, and then tell
    us something about what the program did:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个对象运行程序，等待其终止，然后告诉我们程序做了什么：
- en: The `call` function returns the program's exit code, which is an integer that
    has a program-defined meaning, which is usually used to know whether the program
    has succeeded or failed.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call` 函数返回程序的退出代码，这是一个具有程序定义意义的整数，通常用来判断程序是否成功或失败。'
- en: The `check_call` function raises an exception if the program's exit code is
    non-zero, which, by convention, means that it exited with an error.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_call` 函数如果程序的退出代码非零，则抛出异常，按照惯例，这意味着程序以错误退出。'
- en: The `check_output` function returns whatever text the program printed and raises
    an exception if the program exited with a non-zero exit code. The raised exception
    has an attribute called `output` that contains the text output of the program.
    So, even if the program exited with an error code, we could still get the output
    if we want it.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_output` 函数返回程序打印的任何文本，如果程序以非零退出代码退出，则抛出异常。抛出的异常有一个名为 `output` 的属性，包含程序的文本输出。因此，即使程序以错误代码退出，我们仍然可以获取输出（如果我们想要的话）。'
- en: 'The `run` function is similar to the `call` function we were looking at just
    a moment ago:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 函数与我们刚才提到的 `call` 函数类似：'
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In fact, the `run` function is capable of doing anything that anyone would do,
    in combination. However it is not necessarily possible to use it in other projects,
    at least not yet.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`run` 函数能够做任何任何人会做的事情，结合在一起。然而，它不一定可以在其他项目中使用，至少目前还不能。
- en: The three call functions and the run function are invoked in largely the same
    way. Each of them is passed as a list containing the program name and its arguments.
    We see the output of this `'ls','-l'` function on the screen that wasn't from
    the call because `'ls','-l'` prints something out when it runs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个 `call` 函数和 `run` 函数的调用方式在很大程度上是相同的。每个函数都通过一个包含程序名称及其参数的列表传递。我们在屏幕上看到这个 `'ls','-l'`
    函数的输出，它并不是来自调用，因为 `'ls','-l'` 在运行时会打印出一些内容。
- en: 'Type the following statement:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下语句：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output of the preceding statement:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面语句的输出：
- en: '![](img/2469ea6e-4110-43d6-800b-dd5ca6b0d595.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2469ea6e-4110-43d6-800b-dd5ca6b0d595.jpg)'
- en: The exit code returned `0`, though. So that becomes your call. If you wanted
    to take that printout from the `'ls'` program and use it in our program, we need
    to capture it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但是返回的退出代码是 `0`，所以这就是你的调用。如果你想要从 `'ls'` 程序中获取打印输出并将其用于我们的程序，我们需要捕获它。
- en: The `check_output` function has a noteworthy keyword-only parameter called `universal_newlines`,
    which defaults to `False`. If we set `universal_newlines` to `True`, the text
    output of the program is decoded into unicode characters, using the system's default
    text codec, and the newline characters are normalized.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_output` 函数有一个值得注意的关键字参数，称为 `universal_newlines`，默认值为 `False`。如果我们将 `universal_newlines`
    设置为 `True`，程序文本输出将被解码为 Unicode 字符，使用系统默认的文本编码器，并且新行字符将被标准化。'
- en: 'If we leave `universal_newlines` at its default value of `False`, the program
    output is returned as bytes and it''s up to us to do any decoding and to deal
    with whatever sequence of characters the current system considers to be a newline
    character:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `universal_newlines` 设置为其默认值 `False`，程序输出将以字节形式返回，我们需要自己进行解码并处理当前系统认为的新行字符序列：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now type the following and press *Enter*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入以下内容并按 *Enter*：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this code example, we did set `universal_newlines` to `True` and then split
    it at `\n`, which is the standard newline character, and that gave us back a list
    of the lines that are output from the program:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们确实将 `universal_newlines` 设置为 `True`，然后使用标准换行符 `\n` 来分割它，这给了我们程序输出的行列表：
- en: '![](img/52af42cf-6348-4020-8a1b-dda1e719bfc1.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52af42cf-6348-4020-8a1b-dda1e719bfc1.jpg)'
- en: If we want to get fancier with our running of other programs, we'll want to
    use instances of the `Popen` class-the fourth interesting thing in the `subprocess`
    package and which allows us a great deal of flexibility and control over the execution
    of other programs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在运行其他程序时更加复杂，我们将想要使用 `Popen` 类的实例——`subprocess` 包中的第四个有趣的东西，它为我们提供了对其他程序执行的大量灵活性和控制。
- en: Using the Popen subprocess
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `Popen` 子进程
- en: At the cost of a bit more complexity, the `Popen` constructor accepts the same
    list of program and command-line arguments that the call functions do and a very
    large number of optional keyword arguments, including `universal_newlines`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在增加一点复杂度的代价下，`Popen` 构造函数接受与调用函数相同的程序和命令行参数列表，以及一个非常大的可选关键字参数列表，包括 `universal_newlines`。
- en: We're going to focus on a particular use of the `Popen` constructor that is
    useful, but goes beyond what we can achieve using one of the call functions. We're
    going to see how to run a program in the background while our own code is also
    running, and send and receive data between the two programs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注 `Popen` 构造函数的一个特定用途，这个用途很有用，但超出了我们使用调用函数所能达到的范围。我们将看到如何在我们的代码也在运行的同时在后台运行一个程序，并在两个程序之间发送和接收数据。
- en: The PIPE constant
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`PIPE` 常量'
- en: 'To manage that, we''re going to need the last of our six interesting things
    in the `subprocess` package-the `PIPE` constant. The `PIPE` constant is used in
    conjunction with the `stdin`, `stdout`, or `stderr` keyword parameters of the
    `Popen` constructor:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理这些，我们需要使用 `subprocess` 包中的第六个有趣的东西——`PIPE` 常量。`PIPE` 常量与 `Popen` 构造函数的 `stdin`、`stdout`
    或 `stderr` 关键字参数一起使用：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These parameters represent the other program's textual input, output, and error
    reporting. Any of them that we set to `PIPE` are redirected to our program. In
    the preceding example, we're redirecting the program's inputs and output to ourselves,
    which gives us a bi-directional data channel with the other programs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数代表其他程序的文本输入、输出和错误报告。我们将它们中的任何一个设置为 `PIPE` 的都将被重定向到我们的程序。在前面的例子中，我们将程序的输入和输出重定向到我们自己，这给了我们与其他程序的双向数据通道。
- en: 'Now you see, we are interacting programmatically with the code on screen that
    was at the beginning of this example. However, since it sets in a loop, inputs,
    and then outputs, accord. Also, whenever there is input, once we have `PIPE` set
    up, we could send data to the other program by calling the `write` method on the
    Popen object''s `stdin` attribute:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到了，我们正在以编程方式与屏幕上最初这个示例中的代码进行交互。然而，由于它设置了一个循环，输入，然后输出。此外，每当有输入时，一旦我们设置了 `PIPE`，我们就可以通过在
    Popen 对象的 `stdin` 属性上调用 `write` 方法将数据发送到其他程序：
- en: '![](img/05f55bf5-c7bb-4baf-982c-742dca0180f6.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05f55bf5-c7bb-4baf-982c-742dca0180f6.jpg)'
- en: We can read data by calling the `read` method or its relatives on the Popen
    object's `stdout` attribute, as shown in the preceding example code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 Popen 对象的 `stdout` 属性上的 `read` 方法或其相关方法来读取数据，如前例代码所示。
- en: In spite of disabling buffering with the `bufsize = 0` parameter to the `Popen`
    constructor, it's usually a good idea to call the `flush` method on `stdin` after
    writing to it and on `stdout` before reading from it. We can keep on sending and
    receiving data for as long as both programs are running. However, if the time
    comes when we're done interacting and just want to wait for the other program
    to terminate, we can call the Popen object's `wait` method to do that.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过将 `bufsize = 0` 参数传递给 `Popen` 构造函数来禁用了缓冲，但在向 `stdin` 写入后调用 `flush` 方法，以及在从
    `stdout` 读取之前调用 `flush` 方法通常是个好主意。我们可以继续发送和接收数据，直到两个程序都在运行。然而，如果我们完成交互并只想等待其他程序终止，我们可以调用
    Popen 对象的 `wait` 方法来实现这一点。
- en: The wait method
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`wait` 方法'
- en: 'The `wait` method will return the exit code of the other program once it''s
    done running. A lot of the complexity of working with `PIPE`, `stdin`, and `stdout`
    is wrapped up in the `Popen` class''s `communicate` method, which accepts the
    input as a parameter and returns the output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait` 方法将在其他程序运行完成后返回其退出代码。与 `PIPE`、`stdin` 和 `stdout` 一起工作的许多复杂性都封装在 `Popen`
    类的 `communicate` 方法中，该方法接受输入作为参数并返回输出：'
- en: '![](img/4c1f0a89-bd57-47f9-8f33-8daca8e3650a.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Communication is simple, but somewhat limited because it can only be called
    once for each `Popen` object and doesn't return until the other program finishes.
    This isn't any good for two programs that need to talk back and forth to each
    other, but it should be just perfect for our pipeline program, where each program
    receives the output of the previous program as its input.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up our code example
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to create a bunch of classes to represent the different kinds of
    steps in the pipeline and integrate those classes into the interface as well.
    Once we've done that, the program is functional, although there's plenty of room
    for improvement.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Our particular interest is the `ExecStep` class on the top right-hand side of
    the following screenshot, which uses `Popen` to actually execute a program and
    break free of the output.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2b4eb14-bff6-4b46-8db4-bf89a74d2e7d.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: We've got our example program working now, so we're going to move on to the
    last section in this chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a shell script or batch file to launch the program
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to wrap up this chapter''s example program by
    making it simple to launch. We can run our program using `python -m` as long as
    it''s installed in the system `PYTHONPATH` or we''ve activated the virtual environment
    containing it, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66009b75-2947-4004-bd9b-836294b749b5.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Creating launches for our program
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the program is solid, we really just want to be able to type its name
    or double-click on it and have it run. One convenient way to do that is to use
    a shell script or a batch file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: On Unix-style operating systems including macOS, a shell script is a text file
    that starts with `#bang/bin/sh` and has been marked as executable
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, a batch file is a file whose name ends in `.bat`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both shell scripts and batch files are text files containing a sequence of command-line
    commands, one on each line. When we type the name of the script or batch file,
    those commands are executed one after the other, as if we type them all into the
    command line.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if we trigger the script or batch file through a graphical user
    interface, the commands are still executed as if we typed them into a command
    line one by one. Consider this example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec7b834a-3cc2-42c4-90e9-b84dbb98aa9f.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: For our purposes here, this means that we can put whatever sequence of commands
    necessary to launch a program into a shell script or a batch file. After that,
    we could treat that script as if it were the program itself. That's all there
    is to the simple case.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Shell scripts are capable of representing a lot more complexity, but Python
    is a better tool for that. So, the simple case, here, is all we really need.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the earlier sections of the chapter, you learned about how to make our Python
    packages into programs, get data from the command line, interact with the user,
    and run other programs as subprocesses. We saw how to make our Python programs
    as simple to watch as any other program from the GUI or the command line. We constructed
    a user interface for our Pipeline program and learned about several of Python's
    text mode tools along the way.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，你学习了如何将我们的Python包转换为程序，从命令行获取数据，与用户交互，以及以子进程运行其他程序。我们看到了如何使我们的Python程序像任何其他程序一样，无论是从GUI还是命令行都可以轻松观察。我们在构建Pipeline程序的用户界面过程中，还了解了几种Python的文本模式工具。
- en: In the next chapter, we'll look at how to use parallel processing to take advantage
    of computers with multiple processors or cores.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何利用并行处理来充分利用具有多个处理器或核心的计算机。
