- en: Chapter 36
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第36章
- en: Tips and Tricks with Subprograms
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 子程序的使用技巧和窍门
- en: 36.1 Can Two Subprograms use Variables of the Same Name?
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.1 两个子程序能否使用相同名称的变量？
- en: Each subprogram uses its own memory space to hold the values of its variables.
    Even the main code has its own memory space! This means that you can have a variable
    named test in main code, another variable named test in a subprogram, and yet
    another variable named test in another subprogram. Pay attention! Those three
    variables are three completely different variables, in different memory locations,
    and they can hold completely different values.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子程序都使用自己的内存空间来存储其变量的值。即使是主代码也有自己的内存空间！这意味着你可以在主代码中有一个名为test的变量，在子程序中有一个名为test的变量，在另一个子程序中还有一个名为test的变量。请注意！这三个变量是完全不同的变量，位于不同的内存位置，它们可以存储完全不同的值。
- en: As you can see in the program that follows, there are three variables named
    test in three different memory locations and each one of them holds a completely
    different value. The trace table below can help you understand what really goes
    on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的程序中可以看到的，有三个名为test的变量位于三个不同的内存位置，每个变量都持有完全不同的值。下面的跟踪表可以帮助你理解实际发生了什么。
- en: '![](img/my_exercise_header.png) file_36.1'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.1'
- en: 'def f1():'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f1():'
- en: test = "Testing!"
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: test = "Testing!"
- en: print(test)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: print(test)
- en: 'def f2(test):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f2(test):'
- en: print(test)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: print(test)
- en: '#Main code starts here'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: test = 5
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: test = 5
- en: print(test)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: print(test)
- en: f1()
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: f1()
- en: f2(10)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: f2(10)
- en: print(test)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: print(test)
- en: The trace table is shown here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪表如下所示。
- en: '| Step | Statement | Notes | Main Code | void Function f1() | void Function
    f2() |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 语句 | 备注 | 主代码 | 无返回值函数f1() | 无返回值函数f2() |'
- en: '| test | test | test |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| test | test | test |'
- en: '| 1 | test = 5 |   | 5 |   |   |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 1 | test = 5 |   | 5 |   |   |'
- en: '| 2 | print(test) | It displays: 5 | 5 |   |   |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 2 | print(test) | 它显示：5 | 5 |   |   |'
- en: '| 3 | f1() | f1() is called |   | ? |   |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 3 | f1() | f1()被调用 |   | ? |   |'
- en: '| 4 | test = "Testing!" |   |   | Testing! |   |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 4 | test = "Testing!" |   |   | Testing! |   |'
- en: '| 5 | print(test) | It displays: Testing! |   | Testing! |   |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 5 | print(test) | 它显示：Testing! |   | Testing! |   |'
- en: '| 6 | f2(10) | f2() is called |   |   | 10 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 6 | f2(10) | f2()被调用 |   |   | 10 |'
- en: '| 7 | print(test) | It displays: 10 |   |   | 10 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 7 | print(test) | 它显示：10 |   |   | 10 |'
- en: '| 8 | print(test) | It displays: 5 | 5 |   |   |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 8 | print(test) | 它显示：5 | 5 |   |   |'
- en: '![](img/notice.jpg)Note that variables used in a subprogram “live” as long
    as the subprogram is being executed. This means that before calling the subprogram,
    none of its variables (including those in the formal argument list) exists in
    main memory (RAM). They are all defined in the main memory when the subprogram
    is called, and they are all removed from the main memory when the subprogram finishes
    and the flow of execution returns to the caller. The only variables that “live”
    forever, or at least for as long as the Python program is being executed, are
    the variables of the main code and the global variables! You will learn more about
    global variables in [Section 36.6](#toc_6).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)请注意，在子程序中使用的变量“存在”的时间与子程序执行的时间一样长。这意味着在调用子程序之前，它的任何变量（包括形式参数列表中的变量）都不存在于主内存（RAM）中。它们都是在子程序被调用时在主内存中定义的，当子程序完成并且执行流程返回调用者时，它们都会从主内存中移除。唯一“永远存在”或至少在Python程序执行期间存在的变量是主代码的变量和全局变量！你将在第36.6节中了解更多关于全局变量的内容。'
- en: 36.2 Can a Subprogram Call Another Subprogram?
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.2 子程序能否调用另一个子程序？
- en: Up to this point, you might have gotten the impression that only the main code
    can call a subprogram. However, this is not true! A subprogram can call any other
    subprogram which in turn can call another subprogram, and so on. You can make
    whichever combination you wish. For example, you can write a function that calls
    a void function, a void function that calls a function, a function that calls
    another function, or even a function that calls one of the built-in functions
    of Python.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能会有这样的印象，只有主代码可以调用子程序。然而，这并不正确！一个子程序可以调用任何其他子程序，而这个被调用的子程序又可以调用另一个子程序，以此类推。你可以创建任何你想要的组合。例如，你可以编写一个调用无返回值函数的函数，一个无返回值函数调用一个函数，一个函数调用另一个函数，甚至是一个调用Python内置函数的函数。
- en: The next example presents exactly this situation. The main code calls the void
    function displaySum(), which in turn calls the function add().
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例正好展示了这种情况。主代码调用无返回值函数displaySum()，然后它又调用函数add()。
- en: '![](img/my_exercise_header.png) file_36.2'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.2'
- en: 'def add(number1, number2):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add(number1, number2):'
- en: result = number1 + number2
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: result = number1 + number2
- en: return result
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: return result
- en: 'def displaySum(num1, num2):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displaySum(num1, num2):'
- en: print(add(num1, num2))
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 打印(add(num1, num2))
- en: '#Main code starts here'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: a = int(input())
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: b = int(input())
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())
- en: displaySum(a, b)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: displaySum(a, b)
- en: '![](img/notice.jpg)When the flow of execution reaches the return statement
    of the function add(), it returns to its caller, that is to the void function
    displaySum(). Then, when the flow of execution reaches the end of the void function
    displaySum(), it returns to its caller, that is, to the main code.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)When the flow of execution reaches the return statement
    of the function add(), it returns to its caller, that is to the void function
    displaySum(). Then, when the flow of execution reaches the end of the void function
    displaySum(), it returns to its caller, that is, to the main code.'
- en: '![](img/notice.jpg)Note that there is no restriction on the order in which
    the two subprograms should be written. It would have been exactly the same if
    the void function displaySum() had been written before the function add().'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)Note that there is no restriction on the order in which
    the two subprograms should be written. It would have been exactly the same if
    the void function displaySum() had been written before the function add().'
- en: 36.3 Passing Arguments by Value and by Reference
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.3 通过值和引用传递参数
- en: In Python, variables are passed to subprograms by value. This means that if
    the value of an argument is changed within the subprogram, it does not get changed
    outside of it. Take a look at the following example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: In Python, variables are passed to subprograms by value. This means that if
    the value of an argument is changed within the subprogram, it does not get changed
    outside of it. Take a look at the following example.
- en: '![](img/my_exercise_header.png) file_36.3a'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.3a'
- en: 'def f1(b):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f1(b):'
- en: b += 1      #This is a variable of void function f1()
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'b += 1      #This is a variable of void function f1()'
- en: 'print(b)    #It displays: 11'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '打印(b)       #It displays: 11'
- en: '#Main code starts here'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: a = 10          #This is a variable of the main code
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'a = 10         #This is a variable of the main code'
- en: f1(a)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: f1(a)
- en: 'print(a)        #It displays: 10'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '打印(a)        #It displays: 10'
- en: The value 10 of variable a is passed to void function f1() through argument
    b. However, although the content of variable b is altered within the void function,
    when the flow of execution returns to the main code this change does not affect
    the value of variable a.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: The value 10 of variable a is passed to void function f1() through argument
    b. However, although the content of variable b is altered within the void function,
    when the flow of execution returns to the main code this change does not affect
    the value of variable a.
- en: In the previous example, the main code and the void function are using two variables
    with different names. Yet, the same would have happened if, for instance, both
    the main code and the void function had used two variables of the same name. The
    next example operates exactly the same way and displays exactly the same results
    as the previous example did.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: In the previous example, the main code and the void function are using two variables
    with different names. Yet, the same would have happened if, for instance, both
    the main code and the void function had used two variables of the same name. The
    next example operates exactly the same way and displays exactly the same results
    as the previous example did.
- en: '![](img/my_exercise_header.png) file_36.3b'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.3b'
- en: 'def f1(a):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f1(a):'
- en: a += 1      #This is a variable of void function f1()
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'a += 1      #This is a variable of void function f1()'
- en: 'print(a)    #It displays: 11'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '打印(a)         #It displays: 11'
- en: '#Main code starts here'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: a = 10          #This is a variable of the main code
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'a = 10         #This is a variable of the main code'
- en: f1(a)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: f1(a)
- en: 'print(a)        #It displays: 10'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '打印(a)         #It displays: 10'
- en: Passing a list to a subprogram as an argument is as easy as passing a simple
    variable. The next example passes list a to the void function display(), and the
    latter displays the list.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Passing a list to a subprogram as an argument is as easy as passing a simple
    variable. The next example passes list a to the void function display(), and the
    latter displays the list.
- en: '![](img/my_exercise_header.png) file_36.3c'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.3c'
- en: ELEMENTS = 10
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 10
- en: 'def display(b):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display(b):'
- en: 'for i in range(ELEMENTS):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: print(b[i], end = "\t")
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打印(b[i], end = "\t")
- en: '#Main code starts here'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: a = [None] * ELEMENTS
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: a = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: a[i] = int(input())
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: a[i] = int(input())
- en: display(a)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: display(a)
- en: Contrary to variables, data structures in Python are, by default, passed by
    reference. This means that if you pass, for example, a list to a subprogram, and
    that subprogram changes the value of one or more elements of the list, these changes
    are also reflected outside the subprogram. Take a look at the following example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Contrary to variables, data structures in Python are, by default, passed by
    reference. This means that if you pass, for example, a list to a subprogram, and
    that subprogram changes the value of one or more elements of the list, these changes
    are also reflected outside the subprogram. Take a look at the following example.
- en: '![](img/my_exercise_header.png) file_36.3d'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.3d'
- en: 'def f1(x):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f1(x):'
- en: x[0] += 1
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: x[0] += 1
- en: 'print(x[0]) #It displays: 6'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '打印(x[0]) #It displays: 6'
- en: '#Main code starts here'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: y = [5, 10, 15, 20]
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: y = [5, 10, 15, 20]
- en: 'print(y[0])     #It displays: 5'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '打印(y[0])     #It displays: 5'
- en: f1(y)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: f1(y)
- en: 'print(y[0])     #It displays: 6'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '打印(y[0])     #It displays: 6'
- en: '![](img/notice.jpg)Passing a list to a subprogram passes a reference to the
    list, not a copy of the list, meaning that y and x are actually aliases of the
    same list. Only one copy of the list exists in the main memory (RAM). If a subprogram
    changes the value of an element, this change is also reflected in the main program.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)将列表传递给子程序传递的是列表的引用，而不是列表的副本，这意味着y和x实际上是同一列表的别名。主内存（RAM）中只存在列表的一个副本。如果一个子程序更改了一个元素的值，这种更改也会反映在主程序中。'
- en: So, as you have probably realized, passing lists by reference can provide an
    indirect way for a subprogram to “return” more than one value. Keep in mind, though,
    that using a list to return more than one value from a subprogram is quite unusual
    in Python since, as you have already learned, Python provides a more convenient
    way to accomplish this. However, let's see, albeit formally, one such example.
    In the next example, the function myDivmod() divides variable a by variable b
    and finds their integer quotient and their integer remainder. If all goes well,
    it returns True; otherwise, it returns False. Moreover, through the list results,
    the function also indirectly returns the calculated quotient and the calculated
    remainder.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你可能已经意识到的，通过引用传递列表可以为子程序提供一个间接的方式“返回”多个值。然而，请记住，在Python中，使用列表从子程序返回多个值是非常不寻常的，因为你已经学过，Python提供了更方便的方式来完成这个任务。但是，让我们看看，尽管是形式上的，一个这样的例子。在下一个示例中，函数myDivmod()将变量a除以变量b，并找到它们的整数商和整数余数。如果一切顺利，它返回True；否则，它返回False。此外，通过列表results，函数还间接返回计算出的商和余数。
- en: '![](img/my_exercise_header.png) file_36.3e'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_36.3e'
- en: 'def myDivmod(a, b, results):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myDivmod(a, b, results):'
- en: returnValue = True
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: returnValue = True
- en: 'if b == 0:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'if b == 0:'
- en: returnValue = False
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: returnValue = False
- en: 'else:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: results[0] = a // b
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: results[0] = a // b
- en: results[1] = a % b
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: results[1] = a % b
- en: return returnValue
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: return returnValue
- en: '#Main code starts here'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: res = [None] * 2
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: res = [None] * 2
- en: val1 = int(input())
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: val1 = int(input())
- en: val2 = int(input())
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: val2 = int(input())
- en: ret = myDivmod(val1, val2, res)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ret = myDivmod(val1, val2, res)
- en: 'if ret:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'if ret:'
- en: print(res[0], res[1])
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: print(res[0], res[1])
- en: 'else:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Sorry, wrong values entered!");
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: print("对不起，输入了错误的值！")
- en: '![](img/notice.jpg)A very good tactic regarding the arguments in the formal
    argument list is to have all of those being passed by value written before those
    being passed by reference.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)关于形式参数列表中的参数的一个很好的策略是将所有通过值传递的参数写在通过引用传递的参数之前。'
- en: 36.4 Returning a List
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.4 返回列表
- en: In the next example, the Python program must find the three lowest values of
    list t. To do so, the program calls and passes the list to the void function getList()
    through its formal argument x, which in turn sorts list x using the insertion
    sort algorithm. When the flow of execution returns to the main code, list t is
    also sorted. This happens because, as already stated, lists in Python are passed
    by reference. So what the main code finally does is just display the values of
    the first three elements of the list.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，Python程序必须找到列表t中的三个最小值。为此，程序调用并传递列表t到通过其形式参数x调用的void函数getList()，该函数随后使用插入排序算法对列表x进行排序。当执行流程返回主代码时，列表t也被排序。这是因为，如前所述，Python中的列表是通过引用传递的。因此，主代码最终所做的只是显示列表的前三个元素的值。
- en: '![](img/my_exercise_header.png) file_36.4a'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_36.4a'
- en: ELEMENTS = 10
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 10
- en: def getList(  x  ):     [[More…]](more.html#more_36_4_1)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: def getList(  x  ):     [[更多…]](more.html#more_36_4_1)
- en: 'for m in range(1, ELEMENTS):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'for m in range(1, ELEMENTS):'
- en: element = x[m]
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: element = x[m]
- en: n = m
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: n = m
- en: 'while n > 0 and x[n - 1] > element:'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'while n > 0 and x[n - 1] > element:'
- en: x[n] = x[n - 1]
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x[n] = x[n - 1]
- en: n -= 1
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: n -= 1
- en: x[n] = element
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x[n] = element
- en: '#Main code starts here'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]
- en: getList(t)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: getList(t)
- en: 'print("Three lowest values are: ", t[0], t[1], t[2])'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: print("三个最小值是：", t[0], t[1], t[2])
- en: '#In this step, list t is sorted'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#在此步骤中，列表t被排序'
- en: 'for i in range(ELEMENTS):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: print(t[i], end = "\t")
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: print(t[i], end = "\t")
- en: '![](img/notice.jpg)Since the list t of the main code is passed to the void
    function by reference, only one copy of the list exists in the main memory (RAM),
    meaning that t and x are actually aliases of the same list. When the flow of execution
    returns to the main code, the list t is also sorted.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)由于主代码中的列表t是通过引用传递给void函数的，因此在主内存（RAM）中只存在列表的一个副本，这意味着t和x实际上是同一列表的别名。当执行流程返回主代码时，列表t也被排序。'
- en: However, there are many times when passing a list by reference can be completely
    disastrous. Suppose you have the following two lists. List names contains the
    names of 10 cities, and list t contains their corresponding temperatures recorded
    at a specific hour on a specific day.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很多时候通过引用传递列表可能会完全灾难性。假设您有两个列表。列表 names 包含 10 个城市的名称，列表 t 包含在特定一天特定时间记录的相应温度。
- en: '![Image](img/chapter36-01.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter36-01.png)'
- en: Now, suppose that for list t you wish to display the three lowest temperatures.
    If you call void function getList() of the previous Python program, you have a
    problem. Although the three lowest temperatures can be displayed as required,
    the list t becomes sorted; therefore, the one-to-one correspondence between its
    elements and the elements of list names is lost forever!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您希望显示列表 t 的三个最低温度。如果您调用前一个 Python 程序中的 void 函数 getList()，您会遇到问题。尽管可以按要求显示三个最低温度，但列表
    t 变得排序了；因此，其元素与列表 names 的元素之间的一一对应关系永远丢失了！
- en: One possible solution would be to write a function in which the list is copied
    to an auxiliary list and the function would return a smaller list that contains
    only the three lowest values. The proposed solution is shown here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是编写一个函数，其中将列表复制到一个辅助列表中，该函数将返回一个只包含三个最低值的较小列表。提出的解决方案如下所示。
- en: '![](img/my_exercise_header.png) file_36.4b'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.4b'
- en: ELEMENTS = 10
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 10
- en: 'def getList(x):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getList(x):'
- en: '#Copy list x to list auxX'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#将列表 x 复制到列表 auxX'
- en: auxX = [None] * ELEMENTS
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: auxX = [None] * ELEMENTS
- en: 'for m in range(ELEMENTS):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'for m in range(ELEMENTS):'
- en: auxX[m] = x[m]
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: auxX[m] = x[m]
- en: '#and sort list auxX'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#并对列表 auxX 进行排序'
- en: 'for m in range(1, ELEMENTS):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'for m in range(1, ELEMENTS):'
- en: element = auxX[m]
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: element = auxX[m]
- en: n = m
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: n = m
- en: 'while n > 0 and auxX[n - 1] > element:'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'while n > 0 and auxX[n - 1] > element:'
- en: auxX[n] = auxX[n - 1]
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: auxX[n] = auxX[n - 1]
- en: n -= 1
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: n -= 1
- en: auxX[n] = element
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: auxX[n] = element
- en: return auxX[:3]  #Use slicing to return only the first 3 elements as a list
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: return auxX[:3]  #使用切片返回列表的前 3 个元素作为列表
- en: '#Main code starts here'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: names = ["City1", "City2", "City3", "City4", "City5",   \
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: names = ["City1", "City2", "City3", "City4", "City5",   \
- en: '"City6", "City7", "City8", "City9", "City10"]'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"City6", "City7", "City8", "City9", "City10"]'
- en: t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]
- en: low = getList(t)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: low = getList(t)
- en: 'print("Three lowest values are: ", low[0], low[1], low[2])'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("三个最低值是: ", low[0], low[1], low[2])'
- en: '#In this step, list t is NOT sorted'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，列表 t 未排序
- en: 'for i in range(ELEMENTS):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: print(t[i], "\t", names[i])
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: print(t[i], "\t", names[i])
- en: '![](img/notice.jpg)Note that you cannot use a statement such as auxX = x to
    copy the elements of list x to auxX. This statement just creates two aliases of
    the same list. This is why a for-loop is used in the previous example to copy
    the elements of list x to the list auxX.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)请注意，您不能使用类似于 auxX = x 这样的语句来复制列表 x 的元素到 auxX。这个语句只是创建了同一列表的两个别名。这就是为什么在前一个例子中使用
    for 循环将列表 x 的元素复制到列表 auxX 的原因。'
- en: '![](img/notice.jpg)A more Pythonic way to copy all the elements of a list to
    another list is to use the slicing mechanism. In the previous example, you could
    do this using the statement auxX = x[:]'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)将一个列表的所有元素复制到另一个列表的更 Pythonic 的方法是使用切片机制。在前面的例子中，您可以使用语句
    auxX = x[:] 来这样做。'
- en: Another, more Pythonic, way is shown here.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了另一种更 Pythonic 的方法。
- en: '![](img/my_exercise_header.png) file_36.4c'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.4c'
- en: 'def getList(x):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getList(x):'
- en: return sorted(x)[:3]  #Return only the first 3 elements of the sorted list
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: return sorted(x)[:3]  #只返回排序列表的前 3 个元素
- en: '#Main code starts here'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: names = ["City1", "City2", "City3", "City4", "City5",   \
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: names = ["City1", "City2", "City3", "City4", "City5",   \
- en: '"City6", "City7", "City8", "City9", "City10"]'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"City6", "City7", "City8", "City9", "City10"]'
- en: t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]
- en: low = getList(t)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: low = getList(t)
- en: 'print("Three lowest values are: ", low[0], low[1], low[2])'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("三个最低值是: ", low[0], low[1], low[2])'
- en: '#In this step, list t is NOT sorted'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '#在这一步，列表 t 未排序'
- en: 'for i in range(len(t)):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(t)):'
- en: print(t[i], "\t", names[i])
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: print(t[i], "\t", names[i])
- en: '![](img/remember.jpg)The function sorted(x) returns a new sorted list, leaving
    the initial list x intact (see [Section 32.7](chapter32.html#toc_12)).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/remember.jpg)函数 sorted(x) 返回一个新的排序列表，同时保持初始列表 x 完好无损（见[第 32.7 节](chapter32.html#toc_12)）。'
- en: 36.5 Default Argument Values (Optional Arguments) and Keyword Arguments
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.5 默认参数值（可选参数）和关键字参数
- en: If you assign a default value to an argument within the formal argument list,
    it means that if no value is passed for that argument then the default value is
    used. In the next example, the function prependTitle() is designed to prepend
    (add a prefix to) a title before the name. However, if no value for argument title
    is passed, the function uses the default value “M”.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在形式参数列表中为参数分配默认值，这意味着如果没有为该参数传递值，则使用默认值。在下一个例子中，函数prependTitle()被设计为在名称之前添加（添加前缀）一个头衔。然而，如果没有为参数title传递值，则函数使用默认值“M”。
- en: '![](img/my_exercise_header.png) file_36.5a'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_36.5a'
- en: 'def prependTitle(name, title = "M"):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'def prependTitle(name, title = "M"):'
- en: return title + " " + name
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: return title + " " + name
- en: '#Main code starts here'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'print(prependTitle("John King"))          #It displays: M John King'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: print(prependTitle("John King"))          #它显示：M John King
- en: 'print(prependTitle("Maria Miller", "Ms")) #It displays: Ms Maria Miller'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(prependTitle("Maria Miller", "Ms")) #它显示：Ms Maria Miller'
- en: '![](img/notice.jpg)When a default value is assigned to an argument within the
    formal argument list, this argument is called an “optional argument”.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)当在形式参数列表中为参数分配默认值时，该参数被称为“可选参数”。'
- en: '![](img/notice.jpg)Within the formal argument list, any optional arguments
    must be on the right side of any non-optional arguments; to do the opposite of
    this would be incorrect.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)在形式参数列表中，任何可选参数都必须位于任何非可选参数的右侧；否则，这种做法是不正确的。'
- en: Moreover, in Python, subprograms can be called using a keyword argument with
    the form
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Python中，可以使用关键字参数以如下形式调用子程序：
- en: argument_name = value
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: argument_name = value
- en: Python assumes that keyword arguments are optional. If no argument is provided
    in a subprogram call, the default value is used. Take a look at the following
    Python program. The function prependTitle() is called four times. In the last
    call however, a keyword argument is used.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Python假设关键字参数是可选的。如果在子程序调用中未提供任何参数，则使用默认值。看看下面的Python程序。函数prependTitle()被调用了四次。然而，在最后一次调用中，使用了关键字参数。
- en: '![](img/my_exercise_header.png) file_36.5b'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_36.5b'
- en: 'def prependTitle(firstName, lastName, title = "M", reverse = False):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'def prependTitle(firstName, lastName, title = "M", reverse = False):'
- en: 'if not reverse:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not reverse:'
- en: returnValue = title + " " + firstName + " " + lastName
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: returnValue = title + " " + firstName + " " + lastName
- en: 'else:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: returnValue = title + " " + lastName + " " + firstName
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: returnValue = title + " " + lastName + " " + firstName
- en: return returnValue
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: return returnValue
- en: '#Main code starts here'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'print(prependTitle("John", "King"))          #It displays: M John King'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: print(prependTitle("John", "King"))          #它显示：M John King
- en: 'print(prependTitle("Maria", "Miller", "Ms")) #It displays: Ms Maria Miller'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(prependTitle("Maria", "Miller", "Ms")) #它显示：Ms Maria Miller'
- en: 'print(prependTitle("Maria", "Miller", "Ms", True)) #It displays: Ms Miller
    Maria'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(prependTitle("Maria", "Miller", "Ms", True)) #它显示：Ms Miller Maria'
- en: '#Call the function using a keyword argument'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '#使用关键字参数调用函数'
- en: 'print(prependTitle("John", "King", reverse = True)) #It displays: M King John'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(prependTitle("John", "King", reverse = True)) #它显示：M King John'
- en: '![](img/notice.jpg)Note that the argument reverse is the fourth in order in
    the formal argument list. Using a keyword argument though, you can bypass this
    order.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)请注意，参数reverse在形式参数列表中的顺序是第四位。但是，使用关键字参数可以绕过这个顺序。'
- en: '![](img/notice.jpg)Instead of using the term “keyword arguments”, many computer
    languages such as PHP, C#, and Visual Basic (to name a few), prefer to use the
    term “named arguments”.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)与使用“关键字参数”这个术语不同，许多计算机语言，如PHP、C#和Visual Basic（仅举几个例子），更倾向于使用“命名参数”这个术语。'
- en: 36.6 The Scope of a Variable
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.6 变量的作用域
- en: The scope of a variable refers to the range of effect of that variable. In Python,
    a variable can have a local or global scope. A variable declared within a subprogram
    has a local scope and can be accessed only from within that subprogram. On the
    other hand, a variable declared outside of a subprogram has a global scope and
    can be accessed from within any subprogram, as well as from the main code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域指的是该变量的作用范围。在Python中，一个变量可以具有局部或全局作用域。在子程序内部声明的变量具有局部作用域，并且只能从该子程序内部访问。另一方面，在子程序外部声明的变量具有全局作用域，可以从任何子程序以及主代码中访问。
- en: Let's see some examples. The next example declares a global variable test. The
    value of this global variable, though, is accessed and displayed within the void
    function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子。下一个例子声明了一个全局变量test。然而，这个全局变量的值是在void函数内部访问和显示的。
- en: '![](img/my_exercise_header.png) file_36.6a'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_36.6a'
- en: 'def displayValue():'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValue():'
- en: 'print(test)     #It displays: 10'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)     #It displays: 10'
- en: '#Main code starts here'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: 'test = 10           #This is a global variable'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'test = 10           #This is a global variable'
- en: displayValue()
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: displayValue()
- en: 'print(test)         #It displays: 10'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)         #It displays: 10'
- en: The question now is, “What happens, if you try to change the value of variable
    test within function displayValue()? Will it affect the global variable test as
    well?” In the next example the values 20 and 10 are displayed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，“如果你尝试在函数displayValue()中更改变量test的值，会发生什么？这会影响全局变量test吗？”在下一个示例中，将显示值20和10。
- en: '![](img/my_exercise_header.png) file_36.6b'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.6b'
- en: 'def displayValue():'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValue():'
- en: 'test = 20       #This is a local variable'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'test = 20       #This is a local variable'
- en: 'print(test)     #It displays: 20'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)     #It displays: 20'
- en: '#Main code starts here'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: 'test = 10           #This is a global variable'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'test = 10         #This is a global variable'
- en: displayValue()
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: displayValue()
- en: 'print(test)         #It displays: 10'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)         #It displays: 10'
- en: This happens because Python declares two variables in main memory (RAM); that
    is, a global variable test and a local variable test.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: This happens because Python declares two variables in main memory (RAM); that
    is, a global variable test and a local variable test.
- en: Now let's combine the first example with the second one and see what happens.
    First the subprogram will access the variable test, and then it will assign a
    value to it, as shown in the code that follows.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Now let's combine the first example with the second one and see what happens.
    First the subprogram will access the variable test, and then it will assign a
    value to it, as shown in the code that follows.
- en: '![](img/my_exercise_header.png) file_36.6c'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.6c'
- en: 'def displayValue():'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValue():'
- en: print(test)    #This statement throws an error
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: print(test)    #This statement throws an error
- en: test = 20
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: test = 20
- en: print(test)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: print(test)
- en: '#Main code starts here'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: 'test = 10         #This is a global variable'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 'test = 10         #This is a global variable'
- en: displayValue()
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: displayValue()
- en: print(test)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: print(test)
- en: Unfortunately, this example throws the error message “local variable 'test'
    referenced before assignment”. This happens because Python “assumes” that you
    want a local variable due to the assignment statement test = 20 within function
    displayValue(). Therefore, the first print() statement inevitably throws this
    error message. Any variable that is defined or altered within a function is automatically
    declared as local, unless it has been forced to be a global variable. To force
    Python to use the global variable you have to use the keyword global, as you can
    see in the following example.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Unfortunately, this example throws the error message “local variable 'test'
    referenced before assignment”. This happens because Python “assumes” that you
    want a local variable due to the assignment statement test = 20 within function
    displayValue(). Therefore, the first print() statement inevitably throws this
    error message. Any variable that is defined or altered within a function is automatically
    declared as local, unless it has been forced to be a global variable. To force
    Python to use the global variable you have to use the keyword global, as you can
    see in the following example.
- en: '![](img/my_exercise_header.png) file_36.6d'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.6d'
- en: 'def displayValue():'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValue():'
- en: global test    #Force Python to use the global variable test
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: global test    #Force Python to use the global variable test
- en: 'print(test)    #It displays: 10'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)    #It displays: 10'
- en: test = 20
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: test = 20
- en: 'print(test)    #It displays: 20'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)    #It displays: 20'
- en: '#Main code starts here'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '#Main code starts here'
- en: test = 10          #This is a global variable
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: test = 10          #This is a global variable
- en: displayValue()
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: displayValue()
- en: 'print(test)        #It displays: 20'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)     #It displays: 20'
- en: If you wish to access more than one global variable from within a subprogram,
    you can write the keyword global and, next to it, all the variables separated
    with commas, as shown here.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在子程序中访问多个全局变量，你可以写下关键字global，然后在其旁边，用逗号分隔所有变量，如下所示。
- en: global a, b, c
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: global a, b, c
- en: '![](img/notice.jpg)If the value of a global variable is altered within a subprogram,
    this change is also reflected outside of the subprogram. Please note that the
    last print(test) statement of the main code displays the value of 20.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)If the value of a global variable is altered within a subprogram,
    this change is also reflected outside of the subprogram. Please note that the
    last print(test) statement of the main code displays the value of 20.'
- en: '![](img/remember.jpg)Any variable that is defined or altered within a function
    is local unless it is declared as a global variable using the keyword global.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/remember.jpg)Any variable that is defined or altered within a function
    is local unless it is declared as a global variable using the keyword global.'
- en: The next program declares a global variable test, a local variable test within
    the void function displayValueA(), and another local variable test within the
    void function displayValueB(). Keep in mind that the global variable test and
    the two local variables test are three different variables! Furthermore, the third
    void function displayValueC() uses and alters the value of the global variable
    test.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个程序声明了一个全局变量test，一个在无返回值函数displayValueA()内的本地变量test，以及另一个在无返回值函数displayValueB()内的本地变量test。请记住，全局变量test和这两个本地变量test是三个不同的变量！此外，第三个无返回值函数displayValueC()使用并改变了全局变量test的值。
- en: '![](img/my_exercise_header.png) file_36.6e'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.6e'
- en: 'def displayValueA():'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValueA():'
- en: test = 7      #Local variable test
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: test = 7      # 本地变量test
- en: 'print(test)   #It displays: 7'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)   # 显示：7'
- en: 'def displayValueB():'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValueB():'
- en: test = 9      #Local variable test
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: test = 9      # 本地变量test
- en: 'print(test)   #It displays: 9'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)   # 显示：9'
- en: 'def displayValueC():'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayValueC():'
- en: 'global test   #Use the value of the global variable test'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'global test   # 使用全局变量test的值'
- en: 'print(test)   #It displays: 10'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)   # 显示：10'
- en: 'test += 1     #Increase the value of the global variable test'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'test += 1     # 增加全局变量test的值'
- en: '#Main code starts here'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主代码从这里开始'
- en: 'test = 10         #This is the global variable test'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'test = 10         # 这是全局变量test'
- en: 'print(test)       #It displays: 10'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)     # 显示：10'
- en: displayValueA()
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: displayValueA()
- en: 'print(test)       #It displays: 10'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)     # 显示：10'
- en: displayValueB()
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: displayValueB()
- en: 'print(test)       #It displays: 10'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)     # 显示：10'
- en: displayValueC()
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: displayValueC()
- en: 'print(test)       #It displays: 11'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(test)     # 显示：11'
- en: '![](img/notice.jpg)You can have variables of local scope of the same name within
    different subprograms, because they are recognized only by the subprogram in which
    they are declared.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)你可以在不同的子程序中拥有同名的局部作用域变量，因为它们只在其声明的子程序中被识别。'
- en: 36.7 Converting Parts of Code into Subprograms
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.7 将代码部分转换为子程序
- en: Writing large programs without subdividing them into smaller subprograms results
    in a code that cannot be easily understood or maintained. Suppose you have a large
    program and you wish to subdivide it into smaller subprograms. The next program
    is an example explaining the steps that must be followed. The parts of the program
    marked with a dashed rectangle must be converted into subprograms.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将大型程序不分割成更小的子程序会导致难以理解和维护的代码。假设你有一个大型程序，并且希望将其分割成更小的子程序。下一个程序是一个示例，解释必须遵循的步骤。程序中用虚线矩形标记的部分必须转换为子程序。
- en: '![](img/my_exercise_header.png) file_36.7a'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.7a'
- en: totalYes = 0
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: totalYes = 0
- en: femaleNo = 0
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: femaleNo = 0
- en: 'for i in range(100):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100):'
- en: 'while True:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'temp1 = input("Enter gender for citizen No" + str(i + 1) + ": ")'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: temp1 = input("为公民编号" + str(i + 1) + "输入性别：")
- en: gender = temp1.lower()
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: gender = temp1.lower()
- en: 'if gender in ["male", "female", "other"]: break'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if gender in ["male", "female", "other"]: break'
- en: 'while True:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: temp2 = input("Do you go jogging in the afternoon? ")
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: temp2 = input("你下午去慢跑吗？")
- en: answer = temp2.lower()
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: answer = temp2.lower()
- en: 'if answer in ["yes", "no", "sometimes"]: break'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if answer in ["yes", "no", "sometimes"]: break'
- en: 'if answer == "yes":'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer == "yes":'
- en: totalYes += 1
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: totalYes += 1
- en: 'if gender == "female" and answer == "no":'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'if gender == "female" and answer == "no":'
- en: femaleNo += 1
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: femaleNo += 1
- en: print("Total positive answers:", totalYes)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: print("总肯定回答数：", totalYes)
- en: print("Women's negative answers:", femaleNo)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: print("女性的否定回答数：", femaleNo)
- en: 'To convert parts of this program into subprograms you must:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此程序的部分转换为子程序，你必须：
- en: ►decide, for each dashed rectangle, whether to use a function or a void function.
    This depends on whether or not, the subprogram will return a result.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ►对于每个虚线矩形，决定是否使用函数或无返回值函数。这取决于子程序是否会返回结果。
- en: ►determine which variables exist in each dashed rectangle and their roles in
    that dashed rectangle.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ►确定每个虚线矩形中存在的变量及其在该虚线矩形中的作用。
- en: The flowchart that follows can help you decide what to do with each variable,
    whether it must be passed to the subprogram and/or returned from the subprogram,
    or if it must just be a local variable within the subprogram.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的流程图可以帮助你决定每个变量的处理方式，无论是必须传递给子程序和/或从子程序返回，还是只需在子程序内部作为本地变量。
- en: '![Image](img/chapter36-02.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter36-02.png)'
- en: '![](img/notice.jpg)Keep in mind that functions in Python can return more than
    one result!'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)请记住，Python中的函数可以返回多个结果！'
- en: So, with the help of this flowchart, let's deal with each dashed rectangle one
    by one! The parts that are not marked with a dashed rectangle will comprise the
    main code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，借助这个流程图，让我们逐个处理每个虚线矩形！未标记虚线矩形的部分将构成主代码。
- en: First part
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分
- en: 'In the first dashed rectangle, there are three variables: i, temp1, and gender.
    However, not all of them must be included in the formal argument list of the subprogram
    that will replace the dashed rectangle. Let''s find out why!'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个虚线矩形中，有三个变量：i、temp1和gender。然而，并非所有这些都必须包含在替换虚线矩形的子程序的形式参数列表中。让我们找出原因！
- en: '►Variable i:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ►变量i：
- en: ►is initialized/updated outside the dashed rectangle; thus, it must be passed
    to the subprogram
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形外初始化/更新；因此，必须将其传递给子程序
- en: ►is not updated within the dashed rectangle; thus, it should not be returned
    to the caller
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形内未更新；因此，不应将其返回给调用者
- en: '►Variable temp1:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ►变量temp1：
- en: ►is not initialized/updated outside of the dashed rectangle; thus, it should
    not be passed to the subprogram
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形外未初始化/更新；因此，不应将其传递给子程序
- en: ►is initialized within the dashed rectangle but its value is not used outside
    of it; thus, it should not be returned to the caller
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形内初始化，但其值在矩形外未使用；因此，不应将其返回给调用者
- en: According to the flowchart, since variable temp1 should neither be passed nor
    returned, this variable can just be a local variable within the subprogram.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 根据流程图，由于变量temp1既不应传递也不应返回，因此这个变量可以是子程序内的局部变量。
- en: '►Variable gender:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ►变量gender：
- en: ►is not initialized/updated outside of the dashed rectangle; thus, it should
    not be passed to the subprogram
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形外未初始化/更新；因此，不应将其传递给子程序
- en: ►is initialized within the dashed rectangle and then its value is used outside
    of it; thus, it must be returned to the caller
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形内初始化，然后其值在矩形外使用；因此，必须将其返回给调用者
- en: Therefore, since one value must be returned to the main code, a function can
    be used as shown here.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于必须将一个值返回给主代码，可以使用如下所示的功能。
- en: '#First part'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '#第一部分'
- en: 'def getGender(i):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getGender(i):'
- en: 'while True:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'temp1 = input("Enter gender for citizen No" + str(i + 1) + ": ")'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: temp1 = input("请输入公民编号" + str(i + 1) + "的性别：")
- en: gender = temp1.lower()
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: gender = temp1.lower()
- en: 'if gender in ["male", "female", "other"]: break'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if gender in ["male", "female", "other"]: break'
- en: return gender
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: return gender
- en: Second part
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分
- en: In the second dashed rectangle there are two variables, temp2 and answer, but
    they do not both need to be included in the formal argument list of the subprogram
    that will replace the dashed rectangle. Let's find out why!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个虚线矩形中有两个变量，temp2和answer，但它们并不都需要包含在替换虚线矩形的子程序的形式参数列表中。让我们找出原因！
- en: '►Variable temp2:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ►变量temp2：
- en: ►is not initialized/updated outside of the dashed rectangle; thus, it should
    not be passed to the subprogram
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形外未初始化/更新；因此，不应将其传递给子程序
- en: ►is initialized/updated within the dashed rectangle but its value is not used
    outside of it; thus, it should not be returned to the caller
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形内初始化/更新，但其值在矩形外未使用；因此，不应将其返回给调用者
- en: According to the flowchart, since variable temp2 should neither be passed nor
    returned, this variable can just be a local variable within the subprogram.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 根据流程图，由于变量temp2既不应传递也不应返回，因此这个变量可以是子程序内的局部变量。
- en: '►Variable answer:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ►变量answer：
- en: ►is not initialized/updated outside of the dashed rectangle; thus, it should
    not be passed to the subprogram
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形外未初始化/更新；因此，不应将其传递给子程序
- en: ►is initialized within the dashed rectangle and then its value is used outside
    of it; thus, it must be returned to the caller
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形内初始化，然后其值在矩形外使用；因此，必须将其返回给调用者
- en: Therefore, since one value must be returned to the main code, a function can
    be used, as shown here.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于必须将一个值返回给主代码，可以使用功能，如下所示。
- en: '#Second part'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '#第二部分'
- en: 'def getAnswer():'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getAnswer():'
- en: 'while True:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: temp2 = input("Do you go jogging in the afternoon? ")
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: temp2 = input("你下午去慢跑吗？ ")
- en: answer = temp2.lower()
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: answer = temp2.lower()
- en: 'if answer in ["yes", "no", "sometimes"]: break'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if answer in ["yes", "no", "sometimes"]: break'
- en: return answer
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: return answer
- en: Third part
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分
- en: 'In the third dashed rectangle of the example, there are four variables: answer,
    totalYes, gender and femaleNo and all of them must be included in the formal argument
    list of the subprogram that will replace the dashed rectangle. Let''s find out
    why!'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的第三个虚线矩形中，有四个变量：answer、totalYes、gender 和 femaleNo，它们都必须包含在替换虚线矩形的子程序的正式参数列表中。让我们找出原因！
- en: '►Both variables answer and gender:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ►两个变量 answer 和 gender：
- en: ►are initialized/updated outside of the dashed rectangle; thus, they must be
    passed to the subprogram
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形外部初始化/更新；因此，它们必须传递给子程序
- en: ►are not updated within the dashed rectangle; thus, they should not be returned
    to the caller
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形内部没有更新；因此，它们不应该返回给调用者
- en: '►Both variables totalYes and femaleNo:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ►两个变量 totalYes 和 femaleNo：
- en: ►are initialized outside of the dashed rectangle; thus, they must be passed
    to the subprogram
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形外部初始化；因此，它们必须传递给子程序
- en: ►are updated within the dashed rectangle and then their value is used outside
    of it; thus, they must be returned to the caller
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形内部更新并随后在矩形外部使用其值；因此，它们必须返回给调用者
- en: Therefore, since two values must be returned to the main code, a function can
    be used, as shown here.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于必须将两个值返回到主代码，可以使用如下所示的功能。
- en: '#Third part'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '# 第三部分'
- en: 'def countResults(answer, gender, totalYes, femaleNo):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 'def countResults(answer, gender, totalYes, femaleNo):'
- en: 'if answer == "yes":'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer == "yes":'
- en: totalYes += 1
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: totalYes += 1
- en: 'if gender == "female" and answer == "no":'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 'if gender == "female" and answer == "no":'
- en: femaleNo += 1
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: femaleNo += 1
- en: return totalYes, femaleNo
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: return totalYes, femaleNo
- en: Fourth part
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分
- en: 'In the fourth dashed rectangle of the example, there are two variables: totalYes
    and femaleNo. Let''s see what you should do with them.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的第四个虚线矩形中，有两个变量：totalYes 和 femaleNo。让我们看看你应该如何处理它们。
- en: '►Both variables totalYes and femaleNo:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ►两个变量 totalYes 和 femaleNo：
- en: ►are updated outside of the dashed rectangle; thus, they must be passed to the
    subprogram
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形外部更新；因此，它们必须传递给子程序
- en: ►are not updated within the dashed rectangle; thus, they should not be returned
    to the caller
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ►在虚线矩形内部没有更新；因此，它们不应该返回给调用者
- en: Therefore, since no value should be returned to the main code, a void function
    can be used, as follows.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于不应将任何值返回到主代码，可以使用如下所示的 void 函数。
- en: '#Fourth part'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '# 第四部分'
- en: 'def displayResults(totalYes, femaleNo):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayResults(totalYes, femaleNo):'
- en: print("Total positive answers:", totalYes)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: print("总肯定回答数：", totalYes)
- en: print("Women's negative answers:", femaleNo)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: print("女性的否定回答数：", femaleNo)
- en: The final program
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的程序
- en: The final program, including the main code and all the subprograms cited above,
    is shown here.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 包含主代码和上述所有子程序的最后程序如下所示。
- en: '![](img/my_exercise_header.png) file_36.7b'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.7b'
- en: '#First part'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '# 第一部分'
- en: 'def getGender(i):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getGender(i):'
- en: 'while True:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'temp1 = input("Enter gender for citizen No " + str(i + 1) + ": ")'
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: temp1 = input("为公民 No " + str(i + 1) + " 输入性别：")
- en: gender = temp1.lower()
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: gender = temp1.lower()
- en: 'if gender in ["male", "female", "other"]: break'
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if gender in ["male", "female", "other"]: break'
- en: return gender
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: return gender
- en: '#Second part'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '# 第二部分'
- en: 'def getAnswer():'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getAnswer():'
- en: 'while True:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: temp2 = input("Do you go jogging in the afternoon? ")
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: temp2 = input("你下午去慢跑吗？")
- en: answer = temp2.lower()
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: answer = temp2.lower()
- en: 'if answer in ["yes", "no", "sometimes"]: break'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if answer in ["yes", "no", "sometimes"]: break'
- en: return answer
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: return answer
- en: '#Third part'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '# 第三部分'
- en: 'def countResults(answer, gender, totalYes, femaleNo):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'def countResults(answer, gender, totalYes, femaleNo):'
- en: 'if answer == "yes":'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'if answer == "yes":'
- en: totalYes += 1
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: totalYes += 1
- en: 'if gender == "female" and answer == "no":'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'if gender == "female" and answer == "no":'
- en: femaleNo += 1
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: femaleNo += 1
- en: return totalYes, femaleNo
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: return totalYes, femaleNo
- en: '#Fourth part'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '# 第四部分'
- en: 'def displayResults(totalYes, femaleNo):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 'def displayResults(totalYes, femaleNo):'
- en: print("Total positive answers:", totalYes)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: print("总肯定回答数：", totalYes)
- en: print("Women's negative answers:", femaleNo)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: print("女性的否定回答数：", femaleNo)
- en: '#Main code starts here'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主代码从这里开始'
- en: totalYes = 0
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: totalYes = 0
- en: femaleNo = 0
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: femaleNo = 0
- en: 'for i in range(100):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(100):'
- en: gender = getGender(i)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: gender = getGender(i)
- en: answer = getAnswer()
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: answer = getAnswer()
- en: totalYes, femaleNo = countResults(answer, gender, totalYes, femaleNo)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: totalYes, femaleNo = countResults(answer, gender, totalYes, femaleNo)
- en: displayResults(totalYes, femaleNo)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: displayResults(totalYes, femaleNo)
- en: 36.8 Recursion
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.8 递归
- en: Recursion is a programming technique in which a subprogram calls itself. This
    might initially seem like an endless loop, but of course this is not true; a subprogram
    that uses recursion must be written in a way that obviously satisfies the property
    of finiteness.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种编程技术，其中子程序调用自身。这最初可能看起来像是一个无限循环，但当然这不是真的；使用递归的子程序必须以明显满足有限性属性的方式编写。
- en: Imagine that the next Python program helps you find your way home. In this program,
    recursion occurs because the void function find_your_way_home() calls itself within
    the function.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下下一个Python程序能帮助你找到回家的路。在这个程序中，由于void函数find_your_way_home()在函数内部调用自身，因此发生了递归。
- en: 'def find_your_way_home():'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_your_way_home():'
- en: 'if you_are_already_at_home:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 'if you_are_already_at_home:'
- en: stop_walking()
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: stop_walking()
- en: 'else:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: take_one_step_toward_home()
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: take_one_step_toward_home()
- en: find_your_way_home()
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: find_your_way_home()
- en: '#Main code starts here'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: find_your_way_home()
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: find_your_way_home()
- en: Now, let's try to analyze recursion through a real example. The next Python
    program calculates the factorial of 5 using recursion.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个真实示例来尝试分析递归。下一个Python程序使用递归计算5的阶乘。
- en: '![](img/my_exercise_header.png) file_36.8'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_36.8'
- en: 'def factorial(value):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 'def factorial(value):'
- en: 'if value == 1:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'if value == 1:'
- en: return 1
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return 1
- en: 'else:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return factorial(value - 1) * value
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return factorial(value - 1) * value
- en: '#Main code starts here'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: 'print(factorial(5)) #It displays: 120'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(factorial(5)) #它显示：120'
- en: '![](img/remember.jpg)In mathematics, the factorial of a non-negative integer
    N is the product of all positive integers less than or equal to N. It is denoted
    by N! and the factorial of 0 is, by definition, equal to 1\. For example, the
    factorial of 5 is 1 × 2 × 3 × 4 × 5 = 120.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/remember.jpg)在数学中，非负整数N的阶乘是所有小于或等于N的正整数的乘积。它用N!表示，0的阶乘按定义等于1。例如，5的阶乘是1
    × 2 × 3 × 4 × 5 = 120。'
- en: '![](img/notice.jpg)Recursion occurs because the function factorial() calls
    itself within the function.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)递归发生是因为factorial()函数在函数内部调用自身。'
- en: '![](img/notice.jpg)Note that there isn''t any loop control structure!'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)请注意，这里没有循环控制结构！'
- en: You are probably confused right now. How on Earth is the product 1 × 2 × 3 ×
    4 × 5 calculated without using a loop control structure? The next diagram may
    help you understand. It shows the multiplication operations that are performed
    as function factorial(5) works its way backwards through the series of calls.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能感到困惑。没有使用循环控制结构，如何计算1 × 2 × 3 × 4 × 5的乘积呢？下一个图可能有助于你理解。它显示了当factorial(5)函数通过一系列调用向后工作时执行的乘法操作。
- en: '![Image](img/chapter36-03.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter36-03.png)'
- en: Let's see how this diagram works. The main code calls the function factorial(5),
    which in turn calls the function factorial(4), and the latter calls the function
    factorial(3), and so on. The last call (factorial(1)) returns to its caller (factorial(2))
    the value 1, which in turn returns to its caller (factorial(3)) the value 1 ×
    2 = 2, and so on. When the function factorial(5) returns from the topmost call,
    you have the final solution.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个图是如何工作的。主代码调用factorial(5)函数，该函数反过来调用factorial(4)函数，然后factorial(4)调用factorial(3)，依此类推。最后一个调用(factorial(1))将其值1返回给调用者(factorial(2))，然后factorial(2)将其值1
    × 2 = 2返回给调用者(factorial(3))，依此类推。当factorial(5)从最顶层的调用返回时，你就有了解决方案。
- en: 'To avoid logic errors, all recursive subprograms must adhere to three important
    rules:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免逻辑错误，所有递归子程序都必须遵循三个重要的规则：
- en: 1)They must call themselves.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 1)它们必须调用自己。
- en: 2)They must have a base case, which is the condition that “tells” the subprogram
    to stop recursions. The base case is usually a very small problem that can be
    solved directly. It is the solution to the "simplest" possible problem. In the
    function factorial() of the previous example, the base case is the factorial of
    1\.  When factorial(1) is called, the Boolean expression value == 1 evaluates
    to True and signals the end of the recursions.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 2)它们必须有一个基本情况，这是告诉子程序停止递归的条件。基本情况通常是一个非常小的问题，可以直接解决。它是“最简单”可能问题的解决方案。在上一个示例中的factorial()函数中，基本情况是1的阶乘。当调用factorial(1)时，布尔表达式value
    == 1计算为True，并标志着递归的结束。
- en: 3)They must change their state and move toward the base case. A change of state
    means that the subprogram alters some of its data. Usually, data are getting smaller
    and smaller in some way. In the function factorial() of the previous example,
    since the base case is the factorial of 1, the whole concept relies on the idea
    of moving toward that base case.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 3)它们必须改变它们的状态，并向基本情况移动。状态改变意味着子程序改变了一些数据。通常，数据以某种方式逐渐减小。在上一个示例中的factorial()函数中，因为基本情况是1的阶乘，整个概念依赖于向那个基本情况移动的想法。
- en: In conclusion, recursion helps you write more creative and more elegant programs,
    but keep in mind that it is not always the best option. The main disadvantage
    of recursion is that it is hard for a programmer to think through the logic, and
    therefore it is difficult to debug a code that contains a recursive subprogram.
    Furthermore, a recursive algorithm may prove worse than a non-recursive one because
    it may consume too much CPU time and/or too much main memory (RAM). So, there
    are times where it would be better to follow the KISS principle and, instead of
    using a recursion, solve the algorithm using loop control structures.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，递归有助于你编写更富有创意和更优雅的程序，但请记住，它并不总是最佳选择。递归的主要缺点是程序员难以理解其逻辑，因此包含递归子程序的代码难以调试。此外，递归算法可能比非递归算法更差，因为它可能消耗过多的CPU时间或过多的主内存（RAM）。因此，有时遵循KISS原则会更好，而不是使用递归，而是使用循环控制结构来解决算法。
- en: '![](img/notice.jpg)For you who don''t know what the KISS principle is, it is
    an acronym for “Keep It Simple, Stupid”! It states that most systems work best
    if they are kept simple, avoiding any unnecessary complexity!'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)对于不知道KISS原则的人来说，它是一个缩写，代表“Keep It Simple, Stupid”！它表明，大多数系统如果保持简单，则工作得最好，避免任何不必要的复杂性！'
- en: '36.9 Review Questions: True/False'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.9 复习问题：正确/错误
- en: Choose true or false for each of the following statements.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每个陈述，选择正确或错误。
- en: 1)Each subprogram uses its own memory space to hold the values of its variables.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 1)每个子程序都使用自己的内存空间来存储其变量的值。
- en: 2)Variables used in a subprogram "live" as long as the subprogram is being executed.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 2)在子程序中使用的变量只要子程序正在执行就会“存活”。
- en: 3)The only variables that “live” for as long as the Python program is being
    executed are the variables of the main code and the global variables.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 3)唯一在Python程序执行期间“存活”的变量是主代码的变量和全局变量。
- en: 4)A subprogram can call the main code.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 4)子程序可以调用主代码。
- en: 5)If an argument is passed by value and its value is changed within the subprogram,
    it does not get changed outside of it.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 5)如果通过值传递一个参数并在子程序中更改其值，则该值在外部不会改变。
- en: 6)The name of an actual argument and the name of the corresponding formal argument
    must be the same.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 6)实际参数的名称必须与相应的形式参数的名称相同。
- en: 7)The total number of actual arguments cannot be greater than the total number
    of formal arguments.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 7)实际参数的总数不能超过形式参数的总数。
- en: 8)An expression cannot be passed to a subprogram.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 8)表达式不能传递给子程序。
- en: 9)By default, lists in Python are passed by reference.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 9)默认情况下，Python中的列表是通过引用传递的。
- en: 10)You can pass a list to a void function but the void function cannot return
    (directly or indirectly) a list to the caller.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 10)你可以将列表传递给void函数，但void函数不能（直接或间接地）将列表返回给调用者。
- en: 11)A function can accept a list through its formal argument list.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 11)函数可以通过其形式参数列表接受一个列表。
- en: 12)In general, a void function can call any function.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 12)通常，void函数可以调用任何函数。
- en: 13)In general, a function can call any void function.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 13)通常，一个函数可以调用任何void函数。
- en: 14)Within a statement, a function can be called only once.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 14)在语句内部，一个函数只能调用一次。
- en: 15)A void function can return a value through its formal argument list.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 15)void函数可以通过其形式参数列表返回一个值。
- en: 16)A subprogram can be called by another subprogram or by the main code.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 16)子程序可以被另一个子程序或主代码调用。
- en: 17)If you assign a default value to an argument within the formal argument list,
    it means that no matter what value is passed for that argument, the default value
    is used.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 17)如果你在形式参数列表中为参数分配了一个默认值，这意味着无论传递给该参数的值是什么，都将使用默认值。
- en: 18)An argument is called an optional argument when a default value is assigned
    to that argument within the actual argument list.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 18)当一个参数在实参列表中分配了默认值时，该参数被称为可选参数。
- en: 19)Optional arguments must be on the left side of any non-optional arguments.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 19)可选参数必须位于任何非可选参数的左侧。
- en: 20)The default value of an argument cannot be a string.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 20)参数的默认值不能是字符串。
- en: 21)The scope of a variable refers to the range of effect of that variable.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 21)变量的作用域指的是该变量的作用范围。
- en: 22)If the value of a global variable is altered within a subprogram, this change
    is reflected outside the subprogram as well.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 22)如果在子程序中更改了全局变量的值，这种更改也会在子程序外部反映出来。
- en: 23)You can have two variables of global scope of the same name.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 23)你可以有两个同名的全局变量。
- en: 24)Recursion is a programming technique in which a subprogram calls itself.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 24)递归是一种编程技术，其中子程序会调用自身。
- en: 25)A recursive algorithm must have a base case.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 25)递归算法必须有一个基本情况。
- en: 26)Using recursion to solve a problem is not always the best option.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 26)使用递归解决问题并不总是最佳选择。
- en: 36.10 Review Exercises
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 36.10 复习练习
- en: Complete the following exercises.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下练习。
- en: 1)Without using a trace table, can you find out what the next Python program
    displays?
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 1)在不使用跟踪表的情况下，你能找出下一个Python程序显示的内容吗？
- en: 'def f1():'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f1():'
- en: a = 22
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: a = 22
- en: 'def f2():'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f2():'
- en: a = 33
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: a = 33
- en: a = 5
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: a = 5
- en: f1()
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: f1()
- en: f2()
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: f2()
- en: print(a)
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: print(a)
- en: 2)Without using a trace table, can you find out what the next Python program
    displays?
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 2)在不使用跟踪表的情况下，你能找出下一个Python程序显示的内容吗？
- en: 'def f1(number1):'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f1(number1):'
- en: return 2 * number1
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: return 2 * number1
- en: 'def f2(number1, number2):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f2(number1, number2):'
- en: return f1(number1) + f1(number2)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: return f1(number1) + f1(number2)
- en: a = 3
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: a = 3
- en: b = 4
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: b = 4
- en: print(f2(a, b))
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: print(f2(a, b))
- en: 3)Without using a trace table, can you find out what the next Python program
    displays?
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 3)在不使用跟踪表的情况下，你能找出下一个Python程序显示的内容吗？
- en: 'def f1(number1):'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f1(number1):'
- en: return number1 * 2
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: return number1 * 2
- en: 'def f2(number1, number2):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f2(number1, number2):'
- en: number1 = f1(number1)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: number1 = f1(number1)
- en: number2 = f1(number2)
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: number2 = f1(number2)
- en: return number1 + number2
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: return number1 + number2
- en: a = 2
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: a = 2
- en: b = 5
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: b = 5
- en: print(f2(a, b))
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: print(f2(a, b))
- en: 4)Without using a trace table, can you find out what the next Python program
    displays?
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 4)在不使用跟踪表的情况下，你能找出下一个Python程序显示的内容吗？
- en: 'def display(s = "hello"):'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display(s = "hello"):'
- en: s = s.replace("a", "e")
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: s = s.replace("a", "e")
- en: print(s, end = "")
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: print(s, end = "")
- en: display("hello")
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: display("hello")
- en: display()
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: display()
- en: display("hallo")
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: display("hallo")
- en: 5)Without using a trace table, can you find out what the next Python program
    displays?
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 5)在不使用跟踪表的情况下，你能找出下一个Python程序显示的内容吗？
- en: 'def f1():'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f1():'
- en: global a
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: global a
- en: a = a + b
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: a = a + b
- en: a = 10
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: a = 10
- en: b = 5
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: b = 5
- en: f1()
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: f1()
- en: b -= 1
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: b -= 1
- en: print(a)
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: print(a)
- en: 6)Without using a trace table, can you find out what the next Python program
    displays?
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 6)在不使用跟踪表的情况下，你能找出下一个Python程序显示的内容吗？
- en: 'def f2():'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f2():'
- en: global a
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: global a
- en: a = a + b
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: a = a + b
- en: 'def f1():'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'def f1():'
- en: global a
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: global a
- en: a = a + b
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: a = a + b
- en: f2()
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: f2()
- en: a = 3
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: a = 3
- en: b = 4
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: b = 4
- en: f1()
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: f1()
- en: print(a, b)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: print(a, b)
- en: 7)Without using a trace table, can you find out what the next Python program
    displays?
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 7)在不使用跟踪表的情况下，你能找出下一个Python程序显示的内容吗？
- en: 'def foo(a, b):'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 'def foo(a, b):'
- en: c = 0
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: c = 0
- en: 'for x in a:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in a:'
- en: 'if x == b:'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if x == b:'
- en: c += 1
  id: totrans-514
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c += 1
- en: return c
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: return c
- en: print(foo([5, 9, 2, 5, 5], 5))
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: print(foo([5, 9, 2, 5, 5], 5))
- en: '8)The following Python program is supposed to prompt the user to enter five
    integers into a list and then display, for each element, its number of digits
    and the integer itself. For example, if the user enters the values 35, 13565,
    113, 278955, 9999, the program is supposed to display:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 8)以下Python程序旨在提示用户将五个整数输入到列表中，然后显示每个元素的位数和整数本身。例如，如果用户输入的值是35、13565、113、278955、9999，则程序应显示：
- en: 2 digits in number 35
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 数字35中有2位
- en: 5 digits in number 13565
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 数字13565中有5位
- en: 3 digits in number 113
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 3 digits in number 113
- en: 6 digits in number 278955
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 数字278955中有6位
- en: 4 digits in number 9999
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 4 digits in number 9999
- en: Unfortunately, the program displays
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，程序显示
- en: 2 digits in number 0
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 数字0中有2位
- en: 5 digits in number 0
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 数字0中有5位
- en: 3 digits in number 0
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 数字0中有3位
- en: 6 digits in number 0
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 数字0中有6位
- en: 4 digits in number 0
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 数字0中有4位
- en: Can you find out why?
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找出原因吗？
- en: ELEMENTS = 5
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 5
- en: 'def getNumOfDigits(x, index):'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getNumOfDigits(x, index):'
- en: count = 0
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: 'while x[index] != 0:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x[index] != 0:'
- en: count += 1
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: count += 1
- en: x[index] = x[index] // 10
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x[index] = x[index] // 10
- en: return count
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: return count
- en: '#Main code starts here'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '#主代码从这里开始'
- en: val = [None] * ELEMENTS
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: val = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: val[i] = int(input())
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: val[i] = int(input())
- en: 'for i in range(ELEMENTS):'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: print(getNumOfDigits(val, i), "digits in number", val[i])
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: print(getNumOfDigits(val, i), "digits in number", val[i])
- en: 9)For the following Python program, convert the parts marked with a dashed rectangle
    into subprograms.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 9)对于以下Python程序，将标记为虚线矩形的部分转换为子程序。
- en: STUDENTS = 10
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: STUDENTS = 10
- en: LESSONS = 5
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: LESSONS = 5
- en: names = [None] * STUDENTS
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: names = [None] * STUDENTS
- en: grades = [[None] * LESSONS for i in range(STUDENTS)]
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: grades = [[None] * LESSONS for i in range(STUDENTS)]
- en: 'for i in range(STUDENTS):'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(STUDENTS):'
- en: 'names[i] = input("Enter name No. " + str(i + 1) + ": ")'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 'names[i] = input("Enter name No. " + str(i + 1) + ": ")'
- en: 'for j in range(LESSONS):'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(LESSONS):'
- en: 'grades[i][j] = int(input("Enter grade for lesson No. " + str(j + 1) + ": "))'
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'grades[i][j] = int(input("Enter grade for lesson No. " + str(j + 1) + ": "))'
- en: average = [None] * STUDENTS
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: average = [None] * STUDENTS
- en: 'for i in range(STUDENTS):'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(STUDENTS):'
- en: average[i] = 0
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: average[i] = 0
- en: 'for j in range(LESSONS):'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(LESSONS):'
- en: average[i] += grades[i][j]
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: average[i] += grades[i][j]
- en: average[i] /= LESSONS
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: average[i] /= LESSONS
- en: 'for m in range(1, STUDENTS):'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 'for m in range(1, STUDENTS):'
- en: 'for n in range(STUDENTS - 1, m - 1, -1):'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 'for n in range(STUDENTS - 1, m - 1, -1):'
- en: 'if average[n] > average[n - 1]:'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if average[n] > average[n - 1]:'
- en: average[n], average[n - 1] = average[n - 1], average[n]
  id: totrans-561
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: average[n], average[n - 1] = average[n - 1], average[n]
- en: names[n], names[n - 1] = names[n - 1], names[n]
  id: totrans-562
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: names[n], names[n - 1] = names[n - 1], names[n]
- en: 'elif average[n] == average[n - 1]:'
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'elif average[n] == average[n - 1]:'
- en: 'if names[n] < names[n - 1]:'
  id: totrans-564
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if names[n] < names[n - 1]:'
- en: names[n], names[n - 1] = names[n - 1], names[n]
  id: totrans-565
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: names[n], names[n - 1] = names[n - 1], names[n]
- en: 'for i in range(STUDENTS):'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(STUDENTS):'
- en: print(names[i], "\t", average[i])
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: print(names[i], "\t", average[i])
- en: 10)For the following Python program, convert the parts marked with a dashed
    rectangle into subprograms.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 10)对于以下Python程序，将带有虚线矩形标记的部分转换为子程序。
- en: 'message = input("Enter a message: ").lower()'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 'message = input("Enter a message: ").lower()'
- en: messageClean = ""
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: messageClean = ""
- en: 'for i in range(len(message)):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(message)):'
- en: 'if message[i] not in " ,.?":'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 'if message[i] not in " ,.?":'
- en: messageClean += message[i]
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: messageClean += message[i]
- en: middlePos = (len(messageClean) - 1) // 2
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: middlePos = (len(messageClean) - 1) // 2
- en: j = len(messageClean) - 1
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: j = len(messageClean) - 1
- en: palindrome = True
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: palindrome = True
- en: 'for i in range(middlePos + 1):'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(middlePos + 1):'
- en: 'if messageClean[i] != messageClean[j]:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 'if messageClean[i] != messageClean[j]:'
- en: palindrome = False
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: palindrome = False
- en: break
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: break
- en: j -= 1
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: j -= 1
- en: 'if palindrome:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 'if palindrome:'
- en: print("The message is palindrome")
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: print("The message is palindrome")
- en: 11)The next Python program finds the greatest value among four user-provided
    values. Rewrite the program without using subprograms.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 11)下一个Python程序在四个用户提供的值中找到最大值。重写该程序，不使用子程序。
- en: 'def myMax(n, m):'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myMax(n, m):'
- en: 'if n > m:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 'if n > m:'
- en: m = n
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m = n
- en: return m
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: return m
- en: a = int(input())
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: a = int(input())
- en: b = int(input())
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: b = int(input())
- en: c = int(input())
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: c = int(input())
- en: d = int(input())
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: d = int(input())
- en: maximum = a
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = a
- en: maximum = myMax(b, maximum)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = myMax(b, maximum)
- en: maximum = myMax(c, maximum)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = myMax(d, maximum)
- en: maximum = myMax(d, maximum)
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = myMax(c, maximum)
- en: print(maximum)
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: print(maximum)
- en: 12)Write two subprograms, a function and a void function. They must both accept
    three numbers through their formal argument list and then return their sum and
    average.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 12)编写两个子程序，一个函数和一个void函数。它们都必须通过其形式参数列表接受三个数字，然后返回它们的总和和平均值。
- en: 13)Write a subprogram named myRound that accepts a real (a float) and an integer
    through its formal argument list and then returns the real rounded to as many
    decimal places as the integer indicates. Moreover, if no value is passed for the
    integer, the subprogram must return the real rounded to two decimal places by
    default. Try not to use the round() function of Python.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 13)编写一个名为myRound的子程序，通过其形式参数列表接受一个实数（浮点数）和一个整数，然后返回实数四舍五入到整数指示的小数位数。此外，如果未传递整数值，则子程序必须默认将实数四舍五入到两位小数。尽量不使用Python的round()函数。
- en: '14)Do the following:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 14)执行以下操作：
- en: i)Write a subprogram named getInput that prompts the user to enter an answer
    “yes” or “no” and then returns the value True or False correspondingly to the
    caller. Make the subprogram accept the answer in all possible forms such as “yes”,
    “YES”, “Yes”, “No”, “NO”, “nO”, and so on.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为getInput的子程序，提示用户输入“是”或“否”的答案，然后相应地返回True或False给调用者。该子程序应接受所有可能的答案形式，如“是”、“YES”、“Yes”、“No”、“NO”、“nO”等。
- en: ii)Write a subprogram named findArea that accepts the base and the height of
    a parallelogram through its formal argument list and then returns its area.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: ii)编写一个名为findArea的子程序，通过其形式参数列表接受平行四边形的底和高，然后返回其面积。
- en: iii)Using the subprograms cited above, write a Python program that prompts the
    user to enter the base and the height of a parallelogram and then calculates and
    displays its area. The program must iterate as many times as the user wishes.
    At the end of each calculation, the program must ask the user whether they wish
    to calculate the area of another parallelogram. If the answer is “yes” the program
    must repeat.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: iii)使用上述子程序，编写一个Python程序，提示用户输入平行四边形的底和高，然后计算并显示其面积。程序必须根据用户的意愿迭代多次。每次计算结束后，程序必须询问用户是否希望计算另一个平行四边形的面积。如果答案是“是”，则程序必须重复。
- en: '15)Do the following:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 15)执行以下操作：
- en: i)Write a subprogram named getLists that prompts the user to enter the grades
    and the names of 100 students into the lists grades and names, correspondingly.
    The two lists must be returned to the caller.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为getLists的子程序，提示用户输入100名学生的成绩和姓名，分别存储在grades和names列表中。这两个列表必须返回给调用者。
- en: ii)Write a subprogram named getAverage that accepts the list grades through
    its formal argument list and returns the average grade.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: ii)编写一个名为getAverage的子程序，通过其形式参数列表接受成绩列表grades，并返回平均成绩。
- en: iii)Write a subprogram named sortLists that accepts the lists grades and names
    through its formal argument list and sorts the list grades in descending order
    using the insertion sort algorithm. The subprogram must preserve the one-to-one
    correspondence between the elements of the two lists.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: iii)编写一个名为sortLists的子程序，该子程序通过其形式参数列表接受成绩和姓名列表，并使用插入排序算法按降序对成绩列表进行排序。该子程序必须保持两个列表元素的一对一对应关系。
- en: iv)Using the subprograms cited above, write a Python program that prompts the
    user to enter the grades and the names of 100 students and then displays all student
    names whose grade is less than the average grade, sorted by grade in descending
    order.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: iv)使用上述子程序，编写一个Python程序，提示用户输入100名学生的成绩和姓名，然后按成绩降序显示所有成绩低于平均成绩的学生姓名。
- en: '16)In a song contest, there is an artist who is scored by 10 judges. However,
    according to the rules of this contest, the total score is calculated after excluding
    the highest and lowest scores. Do the following:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 16)在一场歌唱比赛中，有一位艺术家由10位评委评分。然而，根据该比赛的规则，总分是在排除最高分和最低分之后计算的。执行以下操作：
- en: i)Write a subprogram named getList that prompts the user to enter the scores
    of the 10 judges into a list and then returns the list to the caller. Assume that
    each score is unique.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为getList的子程序，该子程序提示用户输入10位评委的分数到一个列表中，然后返回该列表给调用者。假设每个分数都是唯一的。
- en: ii)Write a subprogram named findMinMax that accepts a list through its formal
    argument list and then returns the maximum and the minimum value.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: ii)编写一个名为findMinMax的子程序，该子程序通过其形式参数列表接受一个列表，然后返回最大值和最小值。
- en: iii)Using the subprograms cited above, write a Python program that prompts the
    user to enter the name of the artist and the score they get from each judge. The
    program must then display the message “Artist NN got XX points” where NN and XX
    must be replaced by actual values.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: iii)使用上述子程序，编写一个Python程序，提示用户输入艺术家的姓名和每位评委给出的分数。然后程序必须显示消息“艺术家NN获得了XX分”，其中NN和XX必须替换为实际值。
- en: '17)Do the following:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 17)执行以下操作：
- en: i)Write a recursive function named sumRecursive that accepts an integer through
    its formal argument list and then returns the sum of numbers from 1 to that integer.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为sumRecursive的递归函数，该函数通过其形式参数列表接受一个整数，然后返回从1到该整数的数字之和。
- en: ii)Using the subprogram cited above, write a Python program that lets the user
    enter a positive integer, and then displays the sum of numbers from 1 to that
    user-provided integer.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述子程序，编写一个Python程序，允许用户输入一个正整数，然后显示从1到该用户提供的整数的所有数字之和。
- en: '18)On a chessboard you must place grains of wheat on each square, such that
    one grain is placed on the first square, two on the second, four on the third,
    and so on (doubling the number of grains on each subsequent square). Do the following:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 18)在棋盘上，你必须在每个方格上放置麦粒，第一个方格放一粒，第二个方格放两粒，第三个方格放四粒，依此类推（每个后续方格上的麦粒数是前一个方格的两倍）。执行以下操作：
- en: i)Write a recursive function named woc that accepts the index of a square and
    returns the number of grains of wheat that are on this square. Since a chessboard
    contains 8 × 8 = 64 squares, assume that the index is an integer between 1 and
    64.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为woc的递归函数，该函数接受一个方格的索引并返回该方格上的麦粒数量。由于棋盘包含8 × 8 = 64个方格，假设索引是一个介于1和64之间的整数。
- en: ii)Using the subprogram cited above, write a Python program that calculates
    and displays the total number of grains of wheat that are on the chessboard in
    the end.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述子程序，编写一个Python程序，计算并显示棋盘上最终的总麦粒数。
- en: '19)The Fibonacci sequence is a series of numbers in the following sequence:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 19)斐波那契数列是一系列数字，其顺序如下：
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …
- en: By definition, the first two terms are 0 and 1 and each subsequent term is the
    sum of the previous two.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，前两项是0和1，每一项后续都是前两项之和。
- en: 'Do the following:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: i)Write a recursive function named fib that accepts an integer through its formal
    argument list and then returns the N^(th) term of the Fibonacci series.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为fib的递归函数，该函数通过其形式参数列表接受一个整数，然后返回斐波那契数列的第N项。
- en: ii)Using the subprogram cited above, write a Python program that lets the user
    enter a positive integer N and then displays the N^(th) term of the Fibonacci
    series.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述子程序，编写一个Python程序，允许用户输入一个正整数N，然后显示斐波那契数列的第N项。
- en: 20)The Tribonacci sequence is similar to the Fibonacci sequence but each term
    is the sum of the three preceding terms. Write a recursive function named trib
    that accepts an integer through its formal argument list and then returns the
    N^(th) term of the Tribonacci series.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 20)三进制数列与斐波那契数列类似，但每个项是前三个项的和。编写一个名为 trib 的递归函数，该函数通过其形式参数列表接受一个整数，然后返回三进制数列的第
    N 项。
- en: 21)Write a recursive function named myPow that accepts a real and an integer
    and then returns the result of the first number raised to the power of the second
    number, without using either the exponentiation operator ( ** ) or even the built-in
    pow() function of Python. Ensure that the function works correctly for both positive
    and negative exponent values.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 21)编写一个名为 myPow 的递归函数，该函数接受一个实数和一个整数，然后返回第一个数以第二个数为指数的结果，不使用指数运算符（**）或甚至 Python
    的内置 pow() 函数。确保该函数对于正指数值和负指数值都能正确工作。
- en: '22)Do the following:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 22)执行以下操作：
- en: i)Write a recursive function named factorial that accepts an integer through
    its formal argument list and then returns its factorial.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: i)编写一个名为 factorial 的递归函数，该函数通过其形式参数列表接受一个整数，然后返回其阶乘。
- en: ii)Using the function cited above, write a recursive function named myCos that
    calculates and returns the cosine of x using the Taylor series, shown next.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: ii)使用上述引用的函数，编写一个名为 myCos 的递归函数，该函数使用泰勒级数计算并返回 x 的余弦值，如下所示。
- en: .![Image](img/chapter29-28.png)
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter29-28.png)
- en: 'Hint: Keep in mind that x is in radians and ![Image](img/chapter29-25.png).'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：请记住 x 是以弧度为单位的，![Image](img/chapter29-25.png)。
- en: iii)Using the function myCos() cited above, write a Python program that calculates
    and displays the cosine of 45^o.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: iii)使用上述引用的函数 myCos()，编写一个 Python 程序，计算并显示 45^o 的余弦值。
- en: 'Hint: To verify the result, note that the cosine of 45^o is approximately 0.7071067811865475.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了验证结果，请注意 45^o 的余弦值大约为 0.7071067811865475。
