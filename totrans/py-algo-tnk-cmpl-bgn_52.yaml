- en: Chapter 36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tips and Tricks with Subprograms
  prefs: []
  type: TYPE_NORMAL
- en: 36.1 Can Two Subprograms use Variables of the Same Name?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each subprogram uses its own memory space to hold the values of its variables.
    Even the main code has its own memory space! This means that you can have a variable
    named test in main code, another variable named test in a subprogram, and yet
    another variable named test in another subprogram. Pay attention! Those three
    variables are three completely different variables, in different memory locations,
    and they can hold completely different values.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the program that follows, there are three variables named
    test in three different memory locations and each one of them holds a completely
    different value. The trace table below can help you understand what really goes
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.1'
  prefs: []
  type: TYPE_NORMAL
- en: 'def f1():'
  prefs: []
  type: TYPE_NORMAL
- en: test = "Testing!"
  prefs: []
  type: TYPE_NORMAL
- en: print(test)
  prefs: []
  type: TYPE_NORMAL
- en: 'def f2(test):'
  prefs: []
  type: TYPE_NORMAL
- en: print(test)
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: test = 5
  prefs: []
  type: TYPE_NORMAL
- en: print(test)
  prefs: []
  type: TYPE_NORMAL
- en: f1()
  prefs: []
  type: TYPE_NORMAL
- en: f2(10)
  prefs: []
  type: TYPE_NORMAL
- en: print(test)
  prefs: []
  type: TYPE_NORMAL
- en: The trace table is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Statement | Notes | Main Code | void Function f1() | void Function
    f2() |'
  prefs: []
  type: TYPE_TB
- en: '| test | test | test |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | test = 5 |   | 5 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | print(test) | It displays: 5 | 5 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | f1() | f1() is called |   | ? |   |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | test = "Testing!" |   |   | Testing! |   |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | print(test) | It displays: Testing! |   | Testing! |   |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | f2(10) | f2() is called |   |   | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | print(test) | It displays: 10 |   |   | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | print(test) | It displays: 5 | 5 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '![](img/notice.jpg)Note that variables used in a subprogram “live” as long
    as the subprogram is being executed. This means that before calling the subprogram,
    none of its variables (including those in the formal argument list) exists in
    main memory (RAM). They are all defined in the main memory when the subprogram
    is called, and they are all removed from the main memory when the subprogram finishes
    and the flow of execution returns to the caller. The only variables that “live”
    forever, or at least for as long as the Python program is being executed, are
    the variables of the main code and the global variables! You will learn more about
    global variables in [Section 36.6](#toc_6).'
  prefs: []
  type: TYPE_NORMAL
- en: 36.2 Can a Subprogram Call Another Subprogram?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, you might have gotten the impression that only the main code
    can call a subprogram. However, this is not true! A subprogram can call any other
    subprogram which in turn can call another subprogram, and so on. You can make
    whichever combination you wish. For example, you can write a function that calls
    a void function, a void function that calls a function, a function that calls
    another function, or even a function that calls one of the built-in functions
    of Python.
  prefs: []
  type: TYPE_NORMAL
- en: The next example presents exactly this situation. The main code calls the void
    function displaySum(), which in turn calls the function add().
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.2'
  prefs: []
  type: TYPE_NORMAL
- en: 'def add(number1, number2):'
  prefs: []
  type: TYPE_NORMAL
- en: result = number1 + number2
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: 'def displaySum(num1, num2):'
  prefs: []
  type: TYPE_NORMAL
- en: print(add(num1, num2))
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: displaySum(a, b)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)When the flow of execution reaches the return statement
    of the function add(), it returns to its caller, that is to the void function
    displaySum(). Then, when the flow of execution reaches the end of the void function
    displaySum(), it returns to its caller, that is, to the main code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that there is no restriction on the order in which
    the two subprograms should be written. It would have been exactly the same if
    the void function displaySum() had been written before the function add().'
  prefs: []
  type: TYPE_NORMAL
- en: 36.3 Passing Arguments by Value and by Reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, variables are passed to subprograms by value. This means that if
    the value of an argument is changed within the subprogram, it does not get changed
    outside of it. Take a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.3a'
  prefs: []
  type: TYPE_NORMAL
- en: 'def f1(b):'
  prefs: []
  type: TYPE_NORMAL
- en: b += 1      #This is a variable of void function f1()
  prefs: []
  type: TYPE_NORMAL
- en: 'print(b)    #It displays: 11'
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: a = 10          #This is a variable of the main code
  prefs: []
  type: TYPE_NORMAL
- en: f1(a)
  prefs: []
  type: TYPE_NORMAL
- en: 'print(a)        #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: The value 10 of variable a is passed to void function f1() through argument
    b. However, although the content of variable b is altered within the void function,
    when the flow of execution returns to the main code this change does not affect
    the value of variable a.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the main code and the void function are using two variables
    with different names. Yet, the same would have happened if, for instance, both
    the main code and the void function had used two variables of the same name. The
    next example operates exactly the same way and displays exactly the same results
    as the previous example did.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.3b'
  prefs: []
  type: TYPE_NORMAL
- en: 'def f1(a):'
  prefs: []
  type: TYPE_NORMAL
- en: a += 1      #This is a variable of void function f1()
  prefs: []
  type: TYPE_NORMAL
- en: 'print(a)    #It displays: 11'
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: a = 10          #This is a variable of the main code
  prefs: []
  type: TYPE_NORMAL
- en: f1(a)
  prefs: []
  type: TYPE_NORMAL
- en: 'print(a)        #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: Passing a list to a subprogram as an argument is as easy as passing a simple
    variable. The next example passes list a to the void function display(), and the
    latter displays the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.3c'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 10
  prefs: []
  type: TYPE_NORMAL
- en: 'def display(b):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(b[i], end = "\t")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: a[i] = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: display(a)
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to variables, data structures in Python are, by default, passed by
    reference. This means that if you pass, for example, a list to a subprogram, and
    that subprogram changes the value of one or more elements of the list, these changes
    are also reflected outside the subprogram. Take a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.3d'
  prefs: []
  type: TYPE_NORMAL
- en: 'def f1(x):'
  prefs: []
  type: TYPE_NORMAL
- en: x[0] += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'print(x[0]) #It displays: 6'
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: y = [5, 10, 15, 20]
  prefs: []
  type: TYPE_NORMAL
- en: 'print(y[0])     #It displays: 5'
  prefs: []
  type: TYPE_NORMAL
- en: f1(y)
  prefs: []
  type: TYPE_NORMAL
- en: 'print(y[0])     #It displays: 6'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Passing a list to a subprogram passes a reference to the
    list, not a copy of the list, meaning that y and x are actually aliases of the
    same list. Only one copy of the list exists in the main memory (RAM). If a subprogram
    changes the value of an element, this change is also reflected in the main program.'
  prefs: []
  type: TYPE_NORMAL
- en: So, as you have probably realized, passing lists by reference can provide an
    indirect way for a subprogram to “return” more than one value. Keep in mind, though,
    that using a list to return more than one value from a subprogram is quite unusual
    in Python since, as you have already learned, Python provides a more convenient
    way to accomplish this. However, let's see, albeit formally, one such example.
    In the next example, the function myDivmod() divides variable a by variable b
    and finds their integer quotient and their integer remainder. If all goes well,
    it returns True; otherwise, it returns False. Moreover, through the list results,
    the function also indirectly returns the calculated quotient and the calculated
    remainder.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.3e'
  prefs: []
  type: TYPE_NORMAL
- en: 'def myDivmod(a, b, results):'
  prefs: []
  type: TYPE_NORMAL
- en: returnValue = True
  prefs: []
  type: TYPE_NORMAL
- en: 'if b == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: returnValue = False
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: results[0] = a // b
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: results[1] = a % b
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return returnValue
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: res = [None] * 2
  prefs: []
  type: TYPE_NORMAL
- en: val1 = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: val2 = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: ret = myDivmod(val1, val2, res)
  prefs: []
  type: TYPE_NORMAL
- en: 'if ret:'
  prefs: []
  type: TYPE_NORMAL
- en: print(res[0], res[1])
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Sorry, wrong values entered!");
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A very good tactic regarding the arguments in the formal
    argument list is to have all of those being passed by value written before those
    being passed by reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 36.4 Returning a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next example, the Python program must find the three lowest values of
    list t. To do so, the program calls and passes the list to the void function getList()
    through its formal argument x, which in turn sorts list x using the insertion
    sort algorithm. When the flow of execution returns to the main code, list t is
    also sorted. This happens because, as already stated, lists in Python are passed
    by reference. So what the main code finally does is just display the values of
    the first three elements of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.4a'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 10
  prefs: []
  type: TYPE_NORMAL
- en: def getList(  x  ):     [[More…]](more.html#more_36_4_1)
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: element = x[m]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n = m
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while n > 0 and x[n - 1] > element:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x[n] = x[n - 1]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: x[n] = element
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]
  prefs: []
  type: TYPE_NORMAL
- en: getList(t)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Three lowest values are: ", t[0], t[1], t[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '#In this step, list t is sorted'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(t[i], end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Since the list t of the main code is passed to the void
    function by reference, only one copy of the list exists in the main memory (RAM),
    meaning that t and x are actually aliases of the same list. When the flow of execution
    returns to the main code, the list t is also sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: However, there are many times when passing a list by reference can be completely
    disastrous. Suppose you have the following two lists. List names contains the
    names of 10 cities, and list t contains their corresponding temperatures recorded
    at a specific hour on a specific day.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter36-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, suppose that for list t you wish to display the three lowest temperatures.
    If you call void function getList() of the previous Python program, you have a
    problem. Although the three lowest temperatures can be displayed as required,
    the list t becomes sorted; therefore, the one-to-one correspondence between its
    elements and the elements of list names is lost forever!
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution would be to write a function in which the list is copied
    to an auxiliary list and the function would return a smaller list that contains
    only the three lowest values. The proposed solution is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.4b'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 10
  prefs: []
  type: TYPE_NORMAL
- en: 'def getList(x):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Copy list x to list auxX'
  prefs: []
  type: TYPE_NORMAL
- en: auxX = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: auxX[m] = x[m]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#and sort list auxX'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: element = auxX[m]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n = m
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while n > 0 and auxX[n - 1] > element:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: auxX[n] = auxX[n - 1]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: auxX[n] = element
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return auxX[:3]  #Use slicing to return only the first 3 elements as a list
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: names = ["City1", "City2", "City3", "City4", "City5",   \
  prefs: []
  type: TYPE_NORMAL
- en: '"City6", "City7", "City8", "City9", "City10"]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]
  prefs: []
  type: TYPE_NORMAL
- en: low = getList(t)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Three lowest values are: ", low[0], low[1], low[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '#In this step, list t is NOT sorted'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(t[i], "\t", names[i])
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that you cannot use a statement such as auxX = x to
    copy the elements of list x to auxX. This statement just creates two aliases of
    the same list. This is why a for-loop is used in the previous example to copy
    the elements of list x to the list auxX.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A more Pythonic way to copy all the elements of a list to
    another list is to use the slicing mechanism. In the previous example, you could
    do this using the statement auxX = x[:]'
  prefs: []
  type: TYPE_NORMAL
- en: Another, more Pythonic, way is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.4c'
  prefs: []
  type: TYPE_NORMAL
- en: 'def getList(x):'
  prefs: []
  type: TYPE_NORMAL
- en: return sorted(x)[:3]  #Return only the first 3 elements of the sorted list
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: names = ["City1", "City2", "City3", "City4", "City5",   \
  prefs: []
  type: TYPE_NORMAL
- en: '"City6", "City7", "City8", "City9", "City10"]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: t = [75, 73, 78, 70, 71, 74, 72, 69, 79, 77]
  prefs: []
  type: TYPE_NORMAL
- en: low = getList(t)
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Three lowest values are: ", low[0], low[1], low[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '#In this step, list t is NOT sorted'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(t)):'
  prefs: []
  type: TYPE_NORMAL
- en: print(t[i], "\t", names[i])
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)The function sorted(x) returns a new sorted list, leaving
    the initial list x intact (see [Section 32.7](chapter32.html#toc_12)).'
  prefs: []
  type: TYPE_NORMAL
- en: 36.5 Default Argument Values (Optional Arguments) and Keyword Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you assign a default value to an argument within the formal argument list,
    it means that if no value is passed for that argument then the default value is
    used. In the next example, the function prependTitle() is designed to prepend
    (add a prefix to) a title before the name. However, if no value for argument title
    is passed, the function uses the default value “M”.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.5a'
  prefs: []
  type: TYPE_NORMAL
- en: 'def prependTitle(name, title = "M"):'
  prefs: []
  type: TYPE_NORMAL
- en: return title + " " + name
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(prependTitle("John King"))          #It displays: M John King'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(prependTitle("Maria Miller", "Ms")) #It displays: Ms Maria Miller'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)When a default value is assigned to an argument within the
    formal argument list, this argument is called an “optional argument”.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Within the formal argument list, any optional arguments
    must be on the right side of any non-optional arguments; to do the opposite of
    this would be incorrect.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in Python, subprograms can be called using a keyword argument with
    the form
  prefs: []
  type: TYPE_NORMAL
- en: argument_name = value
  prefs: []
  type: TYPE_NORMAL
- en: Python assumes that keyword arguments are optional. If no argument is provided
    in a subprogram call, the default value is used. Take a look at the following
    Python program. The function prependTitle() is called four times. In the last
    call however, a keyword argument is used.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.5b'
  prefs: []
  type: TYPE_NORMAL
- en: 'def prependTitle(firstName, lastName, title = "M", reverse = False):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: returnValue = title + " " + firstName + " " + lastName
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: returnValue = title + " " + lastName + " " + firstName
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return returnValue
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(prependTitle("John", "King"))          #It displays: M John King'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(prependTitle("Maria", "Miller", "Ms")) #It displays: Ms Maria Miller'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(prependTitle("Maria", "Miller", "Ms", True)) #It displays: Ms Miller
    Maria'
  prefs: []
  type: TYPE_NORMAL
- en: '#Call the function using a keyword argument'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(prependTitle("John", "King", reverse = True)) #It displays: M King John'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that the argument reverse is the fourth in order in
    the formal argument list. Using a keyword argument though, you can bypass this
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Instead of using the term “keyword arguments”, many computer
    languages such as PHP, C#, and Visual Basic (to name a few), prefer to use the
    term “named arguments”.'
  prefs: []
  type: TYPE_NORMAL
- en: 36.6 The Scope of a Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The scope of a variable refers to the range of effect of that variable. In Python,
    a variable can have a local or global scope. A variable declared within a subprogram
    has a local scope and can be accessed only from within that subprogram. On the
    other hand, a variable declared outside of a subprogram has a global scope and
    can be accessed from within any subprogram, as well as from the main code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some examples. The next example declares a global variable test. The
    value of this global variable, though, is accessed and displayed within the void
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.6a'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValue():'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)     #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'test = 10           #This is a global variable'
  prefs: []
  type: TYPE_NORMAL
- en: displayValue()
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)         #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: The question now is, “What happens, if you try to change the value of variable
    test within function displayValue()? Will it affect the global variable test as
    well?” In the next example the values 20 and 10 are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.6b'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValue():'
  prefs: []
  type: TYPE_NORMAL
- en: 'test = 20       #This is a local variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)     #It displays: 20'
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'test = 10           #This is a global variable'
  prefs: []
  type: TYPE_NORMAL
- en: displayValue()
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)         #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: This happens because Python declares two variables in main memory (RAM); that
    is, a global variable test and a local variable test.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's combine the first example with the second one and see what happens.
    First the subprogram will access the variable test, and then it will assign a
    value to it, as shown in the code that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.6c'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValue():'
  prefs: []
  type: TYPE_NORMAL
- en: print(test)    #This statement throws an error
  prefs: []
  type: TYPE_NORMAL
- en: test = 20
  prefs: []
  type: TYPE_NORMAL
- en: print(test)
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'test = 10         #This is a global variable'
  prefs: []
  type: TYPE_NORMAL
- en: displayValue()
  prefs: []
  type: TYPE_NORMAL
- en: print(test)
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this example throws the error message “local variable 'test'
    referenced before assignment”. This happens because Python “assumes” that you
    want a local variable due to the assignment statement test = 20 within function
    displayValue(). Therefore, the first print() statement inevitably throws this
    error message. Any variable that is defined or altered within a function is automatically
    declared as local, unless it has been forced to be a global variable. To force
    Python to use the global variable you have to use the keyword global, as you can
    see in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.6d'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValue():'
  prefs: []
  type: TYPE_NORMAL
- en: global test    #Force Python to use the global variable test
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)    #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: test = 20
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)    #It displays: 20'
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: test = 10          #This is a global variable
  prefs: []
  type: TYPE_NORMAL
- en: displayValue()
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)        #It displays: 20'
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to access more than one global variable from within a subprogram,
    you can write the keyword global and, next to it, all the variables separated
    with commas, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: global a, b, c
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If the value of a global variable is altered within a subprogram,
    this change is also reflected outside of the subprogram. Please note that the
    last print(test) statement of the main code displays the value of 20.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Any variable that is defined or altered within a function
    is local unless it is declared as a global variable using the keyword global.'
  prefs: []
  type: TYPE_NORMAL
- en: The next program declares a global variable test, a local variable test within
    the void function displayValueA(), and another local variable test within the
    void function displayValueB(). Keep in mind that the global variable test and
    the two local variables test are three different variables! Furthermore, the third
    void function displayValueC() uses and alters the value of the global variable
    test.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.6e'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValueA():'
  prefs: []
  type: TYPE_NORMAL
- en: test = 7      #Local variable test
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)   #It displays: 7'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValueB():'
  prefs: []
  type: TYPE_NORMAL
- en: test = 9      #Local variable test
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)   #It displays: 9'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayValueC():'
  prefs: []
  type: TYPE_NORMAL
- en: 'global test   #Use the value of the global variable test'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)   #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'test += 1     #Increase the value of the global variable test'
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'test = 10         #This is the global variable test'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)       #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: displayValueA()
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)       #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: displayValueB()
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)       #It displays: 10'
  prefs: []
  type: TYPE_NORMAL
- en: displayValueC()
  prefs: []
  type: TYPE_NORMAL
- en: 'print(test)       #It displays: 11'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)You can have variables of local scope of the same name within
    different subprograms, because they are recognized only by the subprogram in which
    they are declared.'
  prefs: []
  type: TYPE_NORMAL
- en: 36.7 Converting Parts of Code into Subprograms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing large programs without subdividing them into smaller subprograms results
    in a code that cannot be easily understood or maintained. Suppose you have a large
    program and you wish to subdivide it into smaller subprograms. The next program
    is an example explaining the steps that must be followed. The parts of the program
    marked with a dashed rectangle must be converted into subprograms.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.7a'
  prefs: []
  type: TYPE_NORMAL
- en: totalYes = 0
  prefs: []
  type: TYPE_NORMAL
- en: femaleNo = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100):'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'temp1 = input("Enter gender for citizen No" + str(i + 1) + ": ")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: gender = temp1.lower()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if gender in ["male", "female", "other"]: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: temp2 = input("Do you go jogging in the afternoon? ")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: answer = temp2.lower()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if answer in ["yes", "no", "sometimes"]: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if answer == "yes":'
  prefs: []
  type: TYPE_NORMAL
- en: totalYes += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if gender == "female" and answer == "no":'
  prefs: []
  type: TYPE_NORMAL
- en: femaleNo += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Total positive answers:", totalYes)
  prefs: []
  type: TYPE_NORMAL
- en: print("Women's negative answers:", femaleNo)
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert parts of this program into subprograms you must:'
  prefs: []
  type: TYPE_NORMAL
- en: ►decide, for each dashed rectangle, whether to use a function or a void function.
    This depends on whether or not, the subprogram will return a result.
  prefs: []
  type: TYPE_NORMAL
- en: ►determine which variables exist in each dashed rectangle and their roles in
    that dashed rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: The flowchart that follows can help you decide what to do with each variable,
    whether it must be passed to the subprogram and/or returned from the subprogram,
    or if it must just be a local variable within the subprogram.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter36-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)Keep in mind that functions in Python can return more than
    one result!'
  prefs: []
  type: TYPE_NORMAL
- en: So, with the help of this flowchart, let's deal with each dashed rectangle one
    by one! The parts that are not marked with a dashed rectangle will comprise the
    main code.
  prefs: []
  type: TYPE_NORMAL
- en: First part
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first dashed rectangle, there are three variables: i, temp1, and gender.
    However, not all of them must be included in the formal argument list of the subprogram
    that will replace the dashed rectangle. Let''s find out why!'
  prefs: []
  type: TYPE_NORMAL
- en: '►Variable i:'
  prefs: []
  type: TYPE_NORMAL
- en: ►is initialized/updated outside the dashed rectangle; thus, it must be passed
    to the subprogram
  prefs: []
  type: TYPE_NORMAL
- en: ►is not updated within the dashed rectangle; thus, it should not be returned
    to the caller
  prefs: []
  type: TYPE_NORMAL
- en: '►Variable temp1:'
  prefs: []
  type: TYPE_NORMAL
- en: ►is not initialized/updated outside of the dashed rectangle; thus, it should
    not be passed to the subprogram
  prefs: []
  type: TYPE_NORMAL
- en: ►is initialized within the dashed rectangle but its value is not used outside
    of it; thus, it should not be returned to the caller
  prefs: []
  type: TYPE_NORMAL
- en: According to the flowchart, since variable temp1 should neither be passed nor
    returned, this variable can just be a local variable within the subprogram.
  prefs: []
  type: TYPE_NORMAL
- en: '►Variable gender:'
  prefs: []
  type: TYPE_NORMAL
- en: ►is not initialized/updated outside of the dashed rectangle; thus, it should
    not be passed to the subprogram
  prefs: []
  type: TYPE_NORMAL
- en: ►is initialized within the dashed rectangle and then its value is used outside
    of it; thus, it must be returned to the caller
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, since one value must be returned to the main code, a function can
    be used as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '#First part'
  prefs: []
  type: TYPE_NORMAL
- en: 'def getGender(i):'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'temp1 = input("Enter gender for citizen No" + str(i + 1) + ": ")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: gender = temp1.lower()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if gender in ["male", "female", "other"]: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return gender
  prefs: []
  type: TYPE_NORMAL
- en: Second part
  prefs: []
  type: TYPE_NORMAL
- en: In the second dashed rectangle there are two variables, temp2 and answer, but
    they do not both need to be included in the formal argument list of the subprogram
    that will replace the dashed rectangle. Let's find out why!
  prefs: []
  type: TYPE_NORMAL
- en: '►Variable temp2:'
  prefs: []
  type: TYPE_NORMAL
- en: ►is not initialized/updated outside of the dashed rectangle; thus, it should
    not be passed to the subprogram
  prefs: []
  type: TYPE_NORMAL
- en: ►is initialized/updated within the dashed rectangle but its value is not used
    outside of it; thus, it should not be returned to the caller
  prefs: []
  type: TYPE_NORMAL
- en: According to the flowchart, since variable temp2 should neither be passed nor
    returned, this variable can just be a local variable within the subprogram.
  prefs: []
  type: TYPE_NORMAL
- en: '►Variable answer:'
  prefs: []
  type: TYPE_NORMAL
- en: ►is not initialized/updated outside of the dashed rectangle; thus, it should
    not be passed to the subprogram
  prefs: []
  type: TYPE_NORMAL
- en: ►is initialized within the dashed rectangle and then its value is used outside
    of it; thus, it must be returned to the caller
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, since one value must be returned to the main code, a function can
    be used, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '#Second part'
  prefs: []
  type: TYPE_NORMAL
- en: 'def getAnswer():'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: temp2 = input("Do you go jogging in the afternoon? ")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: answer = temp2.lower()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if answer in ["yes", "no", "sometimes"]: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return answer
  prefs: []
  type: TYPE_NORMAL
- en: Third part
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third dashed rectangle of the example, there are four variables: answer,
    totalYes, gender and femaleNo and all of them must be included in the formal argument
    list of the subprogram that will replace the dashed rectangle. Let''s find out
    why!'
  prefs: []
  type: TYPE_NORMAL
- en: '►Both variables answer and gender:'
  prefs: []
  type: TYPE_NORMAL
- en: ►are initialized/updated outside of the dashed rectangle; thus, they must be
    passed to the subprogram
  prefs: []
  type: TYPE_NORMAL
- en: ►are not updated within the dashed rectangle; thus, they should not be returned
    to the caller
  prefs: []
  type: TYPE_NORMAL
- en: '►Both variables totalYes and femaleNo:'
  prefs: []
  type: TYPE_NORMAL
- en: ►are initialized outside of the dashed rectangle; thus, they must be passed
    to the subprogram
  prefs: []
  type: TYPE_NORMAL
- en: ►are updated within the dashed rectangle and then their value is used outside
    of it; thus, they must be returned to the caller
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, since two values must be returned to the main code, a function can
    be used, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '#Third part'
  prefs: []
  type: TYPE_NORMAL
- en: 'def countResults(answer, gender, totalYes, femaleNo):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if answer == "yes":'
  prefs: []
  type: TYPE_NORMAL
- en: totalYes += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if gender == "female" and answer == "no":'
  prefs: []
  type: TYPE_NORMAL
- en: femaleNo += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return totalYes, femaleNo
  prefs: []
  type: TYPE_NORMAL
- en: Fourth part
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fourth dashed rectangle of the example, there are two variables: totalYes
    and femaleNo. Let''s see what you should do with them.'
  prefs: []
  type: TYPE_NORMAL
- en: '►Both variables totalYes and femaleNo:'
  prefs: []
  type: TYPE_NORMAL
- en: ►are updated outside of the dashed rectangle; thus, they must be passed to the
    subprogram
  prefs: []
  type: TYPE_NORMAL
- en: ►are not updated within the dashed rectangle; thus, they should not be returned
    to the caller
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, since no value should be returned to the main code, a void function
    can be used, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '#Fourth part'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayResults(totalYes, femaleNo):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Total positive answers:", totalYes)
  prefs: []
  type: TYPE_NORMAL
- en: print("Women's negative answers:", femaleNo)
  prefs: []
  type: TYPE_NORMAL
- en: The final program
  prefs: []
  type: TYPE_NORMAL
- en: The final program, including the main code and all the subprograms cited above,
    is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.7b'
  prefs: []
  type: TYPE_NORMAL
- en: '#First part'
  prefs: []
  type: TYPE_NORMAL
- en: 'def getGender(i):'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'temp1 = input("Enter gender for citizen No " + str(i + 1) + ": ")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: gender = temp1.lower()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if gender in ["male", "female", "other"]: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return gender
  prefs: []
  type: TYPE_NORMAL
- en: '#Second part'
  prefs: []
  type: TYPE_NORMAL
- en: 'def getAnswer():'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: temp2 = input("Do you go jogging in the afternoon? ")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: answer = temp2.lower()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if answer in ["yes", "no", "sometimes"]: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return answer
  prefs: []
  type: TYPE_NORMAL
- en: '#Third part'
  prefs: []
  type: TYPE_NORMAL
- en: 'def countResults(answer, gender, totalYes, femaleNo):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if answer == "yes":'
  prefs: []
  type: TYPE_NORMAL
- en: totalYes += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if gender == "female" and answer == "no":'
  prefs: []
  type: TYPE_NORMAL
- en: femaleNo += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return totalYes, femaleNo
  prefs: []
  type: TYPE_NORMAL
- en: '#Fourth part'
  prefs: []
  type: TYPE_NORMAL
- en: 'def displayResults(totalYes, femaleNo):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Total positive answers:", totalYes)
  prefs: []
  type: TYPE_NORMAL
- en: print("Women's negative answers:", femaleNo)
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: totalYes = 0
  prefs: []
  type: TYPE_NORMAL
- en: femaleNo = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100):'
  prefs: []
  type: TYPE_NORMAL
- en: gender = getGender(i)
  prefs: []
  type: TYPE_NORMAL
- en: answer = getAnswer()
  prefs: []
  type: TYPE_NORMAL
- en: totalYes, femaleNo = countResults(answer, gender, totalYes, femaleNo)
  prefs: []
  type: TYPE_NORMAL
- en: displayResults(totalYes, femaleNo)
  prefs: []
  type: TYPE_NORMAL
- en: 36.8 Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recursion is a programming technique in which a subprogram calls itself. This
    might initially seem like an endless loop, but of course this is not true; a subprogram
    that uses recursion must be written in a way that obviously satisfies the property
    of finiteness.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the next Python program helps you find your way home. In this program,
    recursion occurs because the void function find_your_way_home() calls itself within
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'def find_your_way_home():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if you_are_already_at_home:'
  prefs: []
  type: TYPE_NORMAL
- en: stop_walking()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: take_one_step_toward_home()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: find_your_way_home()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: find_your_way_home()
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try to analyze recursion through a real example. The next Python
    program calculates the factorial of 5 using recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_36.8'
  prefs: []
  type: TYPE_NORMAL
- en: 'def factorial(value):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if value == 1:'
  prefs: []
  type: TYPE_NORMAL
- en: return 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: return factorial(value - 1) * value
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(factorial(5)) #It displays: 120'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)In mathematics, the factorial of a non-negative integer
    N is the product of all positive integers less than or equal to N. It is denoted
    by N! and the factorial of 0 is, by definition, equal to 1\. For example, the
    factorial of 5 is 1 × 2 × 3 × 4 × 5 = 120.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Recursion occurs because the function factorial() calls
    itself within the function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that there isn''t any loop control structure!'
  prefs: []
  type: TYPE_NORMAL
- en: You are probably confused right now. How on Earth is the product 1 × 2 × 3 ×
    4 × 5 calculated without using a loop control structure? The next diagram may
    help you understand. It shows the multiplication operations that are performed
    as function factorial(5) works its way backwards through the series of calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter36-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's see how this diagram works. The main code calls the function factorial(5),
    which in turn calls the function factorial(4), and the latter calls the function
    factorial(3), and so on. The last call (factorial(1)) returns to its caller (factorial(2))
    the value 1, which in turn returns to its caller (factorial(3)) the value 1 ×
    2 = 2, and so on. When the function factorial(5) returns from the topmost call,
    you have the final solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid logic errors, all recursive subprograms must adhere to three important
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 1)They must call themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 2)They must have a base case, which is the condition that “tells” the subprogram
    to stop recursions. The base case is usually a very small problem that can be
    solved directly. It is the solution to the "simplest" possible problem. In the
    function factorial() of the previous example, the base case is the factorial of
    1\.  When factorial(1) is called, the Boolean expression value == 1 evaluates
    to True and signals the end of the recursions.
  prefs: []
  type: TYPE_NORMAL
- en: 3)They must change their state and move toward the base case. A change of state
    means that the subprogram alters some of its data. Usually, data are getting smaller
    and smaller in some way. In the function factorial() of the previous example,
    since the base case is the factorial of 1, the whole concept relies on the idea
    of moving toward that base case.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, recursion helps you write more creative and more elegant programs,
    but keep in mind that it is not always the best option. The main disadvantage
    of recursion is that it is hard for a programmer to think through the logic, and
    therefore it is difficult to debug a code that contains a recursive subprogram.
    Furthermore, a recursive algorithm may prove worse than a non-recursive one because
    it may consume too much CPU time and/or too much main memory (RAM). So, there
    are times where it would be better to follow the KISS principle and, instead of
    using a recursion, solve the algorithm using loop control structures.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)For you who don''t know what the KISS principle is, it is
    an acronym for “Keep It Simple, Stupid”! It states that most systems work best
    if they are kept simple, avoiding any unnecessary complexity!'
  prefs: []
  type: TYPE_NORMAL
- en: '36.9 Review Questions: True/False'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Each subprogram uses its own memory space to hold the values of its variables.
  prefs: []
  type: TYPE_NORMAL
- en: 2)Variables used in a subprogram "live" as long as the subprogram is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 3)The only variables that “live” for as long as the Python program is being
    executed are the variables of the main code and the global variables.
  prefs: []
  type: TYPE_NORMAL
- en: 4)A subprogram can call the main code.
  prefs: []
  type: TYPE_NORMAL
- en: 5)If an argument is passed by value and its value is changed within the subprogram,
    it does not get changed outside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 6)The name of an actual argument and the name of the corresponding formal argument
    must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 7)The total number of actual arguments cannot be greater than the total number
    of formal arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 8)An expression cannot be passed to a subprogram.
  prefs: []
  type: TYPE_NORMAL
- en: 9)By default, lists in Python are passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 10)You can pass a list to a void function but the void function cannot return
    (directly or indirectly) a list to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 11)A function can accept a list through its formal argument list.
  prefs: []
  type: TYPE_NORMAL
- en: 12)In general, a void function can call any function.
  prefs: []
  type: TYPE_NORMAL
- en: 13)In general, a function can call any void function.
  prefs: []
  type: TYPE_NORMAL
- en: 14)Within a statement, a function can be called only once.
  prefs: []
  type: TYPE_NORMAL
- en: 15)A void function can return a value through its formal argument list.
  prefs: []
  type: TYPE_NORMAL
- en: 16)A subprogram can be called by another subprogram or by the main code.
  prefs: []
  type: TYPE_NORMAL
- en: 17)If you assign a default value to an argument within the formal argument list,
    it means that no matter what value is passed for that argument, the default value
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 18)An argument is called an optional argument when a default value is assigned
    to that argument within the actual argument list.
  prefs: []
  type: TYPE_NORMAL
- en: 19)Optional arguments must be on the left side of any non-optional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 20)The default value of an argument cannot be a string.
  prefs: []
  type: TYPE_NORMAL
- en: 21)The scope of a variable refers to the range of effect of that variable.
  prefs: []
  type: TYPE_NORMAL
- en: 22)If the value of a global variable is altered within a subprogram, this change
    is reflected outside the subprogram as well.
  prefs: []
  type: TYPE_NORMAL
- en: 23)You can have two variables of global scope of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 24)Recursion is a programming technique in which a subprogram calls itself.
  prefs: []
  type: TYPE_NORMAL
- en: 25)A recursive algorithm must have a base case.
  prefs: []
  type: TYPE_NORMAL
- en: 26)Using recursion to solve a problem is not always the best option.
  prefs: []
  type: TYPE_NORMAL
- en: 36.10 Review Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Without using a trace table, can you find out what the next Python program
    displays?
  prefs: []
  type: TYPE_NORMAL
- en: 'def f1():'
  prefs: []
  type: TYPE_NORMAL
- en: a = 22
  prefs: []
  type: TYPE_NORMAL
- en: 'def f2():'
  prefs: []
  type: TYPE_NORMAL
- en: a = 33
  prefs: []
  type: TYPE_NORMAL
- en: a = 5
  prefs: []
  type: TYPE_NORMAL
- en: f1()
  prefs: []
  type: TYPE_NORMAL
- en: f2()
  prefs: []
  type: TYPE_NORMAL
- en: print(a)
  prefs: []
  type: TYPE_NORMAL
- en: 2)Without using a trace table, can you find out what the next Python program
    displays?
  prefs: []
  type: TYPE_NORMAL
- en: 'def f1(number1):'
  prefs: []
  type: TYPE_NORMAL
- en: return 2 * number1
  prefs: []
  type: TYPE_NORMAL
- en: 'def f2(number1, number2):'
  prefs: []
  type: TYPE_NORMAL
- en: return f1(number1) + f1(number2)
  prefs: []
  type: TYPE_NORMAL
- en: a = 3
  prefs: []
  type: TYPE_NORMAL
- en: b = 4
  prefs: []
  type: TYPE_NORMAL
- en: print(f2(a, b))
  prefs: []
  type: TYPE_NORMAL
- en: 3)Without using a trace table, can you find out what the next Python program
    displays?
  prefs: []
  type: TYPE_NORMAL
- en: 'def f1(number1):'
  prefs: []
  type: TYPE_NORMAL
- en: return number1 * 2
  prefs: []
  type: TYPE_NORMAL
- en: 'def f2(number1, number2):'
  prefs: []
  type: TYPE_NORMAL
- en: number1 = f1(number1)
  prefs: []
  type: TYPE_NORMAL
- en: number2 = f1(number2)
  prefs: []
  type: TYPE_NORMAL
- en: return number1 + number2
  prefs: []
  type: TYPE_NORMAL
- en: a = 2
  prefs: []
  type: TYPE_NORMAL
- en: b = 5
  prefs: []
  type: TYPE_NORMAL
- en: print(f2(a, b))
  prefs: []
  type: TYPE_NORMAL
- en: 4)Without using a trace table, can you find out what the next Python program
    displays?
  prefs: []
  type: TYPE_NORMAL
- en: 'def display(s = "hello"):'
  prefs: []
  type: TYPE_NORMAL
- en: s = s.replace("a", "e")
  prefs: []
  type: TYPE_NORMAL
- en: print(s, end = "")
  prefs: []
  type: TYPE_NORMAL
- en: display("hello")
  prefs: []
  type: TYPE_NORMAL
- en: display()
  prefs: []
  type: TYPE_NORMAL
- en: display("hallo")
  prefs: []
  type: TYPE_NORMAL
- en: 5)Without using a trace table, can you find out what the next Python program
    displays?
  prefs: []
  type: TYPE_NORMAL
- en: 'def f1():'
  prefs: []
  type: TYPE_NORMAL
- en: global a
  prefs: []
  type: TYPE_NORMAL
- en: a = a + b
  prefs: []
  type: TYPE_NORMAL
- en: a = 10
  prefs: []
  type: TYPE_NORMAL
- en: b = 5
  prefs: []
  type: TYPE_NORMAL
- en: f1()
  prefs: []
  type: TYPE_NORMAL
- en: b -= 1
  prefs: []
  type: TYPE_NORMAL
- en: print(a)
  prefs: []
  type: TYPE_NORMAL
- en: 6)Without using a trace table, can you find out what the next Python program
    displays?
  prefs: []
  type: TYPE_NORMAL
- en: 'def f2():'
  prefs: []
  type: TYPE_NORMAL
- en: global a
  prefs: []
  type: TYPE_NORMAL
- en: a = a + b
  prefs: []
  type: TYPE_NORMAL
- en: 'def f1():'
  prefs: []
  type: TYPE_NORMAL
- en: global a
  prefs: []
  type: TYPE_NORMAL
- en: a = a + b
  prefs: []
  type: TYPE_NORMAL
- en: f2()
  prefs: []
  type: TYPE_NORMAL
- en: a = 3
  prefs: []
  type: TYPE_NORMAL
- en: b = 4
  prefs: []
  type: TYPE_NORMAL
- en: f1()
  prefs: []
  type: TYPE_NORMAL
- en: print(a, b)
  prefs: []
  type: TYPE_NORMAL
- en: 7)Without using a trace table, can you find out what the next Python program
    displays?
  prefs: []
  type: TYPE_NORMAL
- en: 'def foo(a, b):'
  prefs: []
  type: TYPE_NORMAL
- en: c = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in a:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x == b:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c += 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: return c
  prefs: []
  type: TYPE_NORMAL
- en: print(foo([5, 9, 2, 5, 5], 5))
  prefs: []
  type: TYPE_NORMAL
- en: '8)The following Python program is supposed to prompt the user to enter five
    integers into a list and then display, for each element, its number of digits
    and the integer itself. For example, if the user enters the values 35, 13565,
    113, 278955, 9999, the program is supposed to display:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 digits in number 35
  prefs: []
  type: TYPE_NORMAL
- en: 5 digits in number 13565
  prefs: []
  type: TYPE_NORMAL
- en: 3 digits in number 113
  prefs: []
  type: TYPE_NORMAL
- en: 6 digits in number 278955
  prefs: []
  type: TYPE_NORMAL
- en: 4 digits in number 9999
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the program displays
  prefs: []
  type: TYPE_NORMAL
- en: 2 digits in number 0
  prefs: []
  type: TYPE_NORMAL
- en: 5 digits in number 0
  prefs: []
  type: TYPE_NORMAL
- en: 3 digits in number 0
  prefs: []
  type: TYPE_NORMAL
- en: 6 digits in number 0
  prefs: []
  type: TYPE_NORMAL
- en: 4 digits in number 0
  prefs: []
  type: TYPE_NORMAL
- en: Can you find out why?
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 5
  prefs: []
  type: TYPE_NORMAL
- en: 'def getNumOfDigits(x, index):'
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while x[index] != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: x[index] = x[index] // 10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return count
  prefs: []
  type: TYPE_NORMAL
- en: '#Main code starts here'
  prefs: []
  type: TYPE_NORMAL
- en: val = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: val[i] = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(getNumOfDigits(val, i), "digits in number", val[i])
  prefs: []
  type: TYPE_NORMAL
- en: 9)For the following Python program, convert the parts marked with a dashed rectangle
    into subprograms.
  prefs: []
  type: TYPE_NORMAL
- en: STUDENTS = 10
  prefs: []
  type: TYPE_NORMAL
- en: LESSONS = 5
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * STUDENTS
  prefs: []
  type: TYPE_NORMAL
- en: grades = [[None] * LESSONS for i in range(STUDENTS)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name No. " + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(LESSONS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'grades[i][j] = int(input("Enter grade for lesson No. " + str(j + 1) + ": "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: average = [None] * STUDENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: average[i] = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(LESSONS):'
  prefs: []
  type: TYPE_NORMAL
- en: average[i] += grades[i][j]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: average[i] /= LESSONS
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(STUDENTS - 1, m - 1, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if average[n] > average[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: average[n], average[n - 1] = average[n - 1], average[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif average[n] == average[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if names[n] < names[n - 1]:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i], "\t", average[i])
  prefs: []
  type: TYPE_NORMAL
- en: 10)For the following Python program, convert the parts marked with a dashed
    rectangle into subprograms.
  prefs: []
  type: TYPE_NORMAL
- en: 'message = input("Enter a message: ").lower()'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean = ""
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(message)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if message[i] not in " ,.?":'
  prefs: []
  type: TYPE_NORMAL
- en: messageClean += message[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: middlePos = (len(messageClean) - 1) // 2
  prefs: []
  type: TYPE_NORMAL
- en: j = len(messageClean) - 1
  prefs: []
  type: TYPE_NORMAL
- en: palindrome = True
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(middlePos + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if messageClean[i] != messageClean[j]:'
  prefs: []
  type: TYPE_NORMAL
- en: palindrome = False
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: j -= 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if palindrome:'
  prefs: []
  type: TYPE_NORMAL
- en: print("The message is palindrome")
  prefs: []
  type: TYPE_NORMAL
- en: 11)The next Python program finds the greatest value among four user-provided
    values. Rewrite the program without using subprograms.
  prefs: []
  type: TYPE_NORMAL
- en: 'def myMax(n, m):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if n > m:'
  prefs: []
  type: TYPE_NORMAL
- en: m = n
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return m
  prefs: []
  type: TYPE_NORMAL
- en: a = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: b = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: c = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: d = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: maximum = a
  prefs: []
  type: TYPE_NORMAL
- en: maximum = myMax(b, maximum)
  prefs: []
  type: TYPE_NORMAL
- en: maximum = myMax(c, maximum)
  prefs: []
  type: TYPE_NORMAL
- en: maximum = myMax(d, maximum)
  prefs: []
  type: TYPE_NORMAL
- en: print(maximum)
  prefs: []
  type: TYPE_NORMAL
- en: 12)Write two subprograms, a function and a void function. They must both accept
    three numbers through their formal argument list and then return their sum and
    average.
  prefs: []
  type: TYPE_NORMAL
- en: 13)Write a subprogram named myRound that accepts a real (a float) and an integer
    through its formal argument list and then returns the real rounded to as many
    decimal places as the integer indicates. Moreover, if no value is passed for the
    integer, the subprogram must return the real rounded to two decimal places by
    default. Try not to use the round() function of Python.
  prefs: []
  type: TYPE_NORMAL
- en: '14)Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a subprogram named getInput that prompts the user to enter an answer
    “yes” or “no” and then returns the value True or False correspondingly to the
    caller. Make the subprogram accept the answer in all possible forms such as “yes”,
    “YES”, “Yes”, “No”, “NO”, “nO”, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Write a subprogram named findArea that accepts the base and the height of
    a parallelogram through its formal argument list and then returns its area.
  prefs: []
  type: TYPE_NORMAL
- en: iii)Using the subprograms cited above, write a Python program that prompts the
    user to enter the base and the height of a parallelogram and then calculates and
    displays its area. The program must iterate as many times as the user wishes.
    At the end of each calculation, the program must ask the user whether they wish
    to calculate the area of another parallelogram. If the answer is “yes” the program
    must repeat.
  prefs: []
  type: TYPE_NORMAL
- en: '15)Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a subprogram named getLists that prompts the user to enter the grades
    and the names of 100 students into the lists grades and names, correspondingly.
    The two lists must be returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Write a subprogram named getAverage that accepts the list grades through
    its formal argument list and returns the average grade.
  prefs: []
  type: TYPE_NORMAL
- en: iii)Write a subprogram named sortLists that accepts the lists grades and names
    through its formal argument list and sorts the list grades in descending order
    using the insertion sort algorithm. The subprogram must preserve the one-to-one
    correspondence between the elements of the two lists.
  prefs: []
  type: TYPE_NORMAL
- en: iv)Using the subprograms cited above, write a Python program that prompts the
    user to enter the grades and the names of 100 students and then displays all student
    names whose grade is less than the average grade, sorted by grade in descending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '16)In a song contest, there is an artist who is scored by 10 judges. However,
    according to the rules of this contest, the total score is calculated after excluding
    the highest and lowest scores. Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a subprogram named getList that prompts the user to enter the scores
    of the 10 judges into a list and then returns the list to the caller. Assume that
    each score is unique.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Write a subprogram named findMinMax that accepts a list through its formal
    argument list and then returns the maximum and the minimum value.
  prefs: []
  type: TYPE_NORMAL
- en: iii)Using the subprograms cited above, write a Python program that prompts the
    user to enter the name of the artist and the score they get from each judge. The
    program must then display the message “Artist NN got XX points” where NN and XX
    must be replaced by actual values.
  prefs: []
  type: TYPE_NORMAL
- en: '17)Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a recursive function named sumRecursive that accepts an integer through
    its formal argument list and then returns the sum of numbers from 1 to that integer.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the subprogram cited above, write a Python program that lets the user
    enter a positive integer, and then displays the sum of numbers from 1 to that
    user-provided integer.
  prefs: []
  type: TYPE_NORMAL
- en: '18)On a chessboard you must place grains of wheat on each square, such that
    one grain is placed on the first square, two on the second, four on the third,
    and so on (doubling the number of grains on each subsequent square). Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a recursive function named woc that accepts the index of a square and
    returns the number of grains of wheat that are on this square. Since a chessboard
    contains 8 × 8 = 64 squares, assume that the index is an integer between 1 and
    64.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the subprogram cited above, write a Python program that calculates
    and displays the total number of grains of wheat that are on the chessboard in
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: '19)The Fibonacci sequence is a series of numbers in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …
  prefs: []
  type: TYPE_NORMAL
- en: By definition, the first two terms are 0 and 1 and each subsequent term is the
    sum of the previous two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a recursive function named fib that accepts an integer through its formal
    argument list and then returns the N^(th) term of the Fibonacci series.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the subprogram cited above, write a Python program that lets the user
    enter a positive integer N and then displays the N^(th) term of the Fibonacci
    series.
  prefs: []
  type: TYPE_NORMAL
- en: 20)The Tribonacci sequence is similar to the Fibonacci sequence but each term
    is the sum of the three preceding terms. Write a recursive function named trib
    that accepts an integer through its formal argument list and then returns the
    N^(th) term of the Tribonacci series.
  prefs: []
  type: TYPE_NORMAL
- en: 21)Write a recursive function named myPow that accepts a real and an integer
    and then returns the result of the first number raised to the power of the second
    number, without using either the exponentiation operator ( ** ) or even the built-in
    pow() function of Python. Ensure that the function works correctly for both positive
    and negative exponent values.
  prefs: []
  type: TYPE_NORMAL
- en: '22)Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: i)Write a recursive function named factorial that accepts an integer through
    its formal argument list and then returns its factorial.
  prefs: []
  type: TYPE_NORMAL
- en: ii)Using the function cited above, write a recursive function named myCos that
    calculates and returns the cosine of x using the Taylor series, shown next.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter29-28.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Keep in mind that x is in radians and ![Image](img/chapter29-25.png).'
  prefs: []
  type: TYPE_NORMAL
- en: iii)Using the function myCos() cited above, write a Python program that calculates
    and displays the cosine of 45^o.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: To verify the result, note that the cosine of 45^o is approximately 0.7071067811865475.'
  prefs: []
  type: TYPE_NORMAL
