["```py\nsudo apt-get update\nsudo apt-get install python3-pip\nsudo apt-get install libjpeg-dev\nsudo pip-3.2 install pillow  \n```", "```py\nsudo pip-3.2 install pi3d    \n```", "```py\nmv pi3d_demos-master pi3d  \n```", "```py\ncd pi3d\npython3 Raspberry_Rain.py     \n```", "```py\n#!/usr/bin/python3 \n\"\"\" Create a 3D space with a Tetrahedron inside and rotate the \n    view around using the mouse. \n\"\"\" \nfrom math import sin, cos, radians \n\nimport demo \nimport pi3d \n\nKEY = {'ESC':27,'NONE':-1} \n\nDISPLAY = pi3d.Display.create(x=50, y=50) \n#capture mouse and key presses \nmykeys = pi3d.Keyboard() \nmymouse = pi3d.Mouse(restrict = False) \nmymouse.start() \n\ndef main(): \n  CAMERA = pi3d.Camera.instance() \n  tex = pi3d.Texture(\"textures/stripwood.jpg\") \n  flatsh = pi3d.Shader(\"uv_flat\") \n\n  #Define the coordinates for our shape (x,y,z)  \n  A = (-1.0,-1.0,-1.0) \n  B = (1.0,-1.0,1.0) \n  C = (-1.0,-1.0,1.0) \n  D = (-1.0,1.0,1.0) \n  ids = [\"A\",\"B\",\"C\",\"D\"] \n  coords = [A,B,C,D] \n  myTetra = pi3d.Tetrahedron(x=0.0, y=0.0, z=0.0, \n                             corners=(A,B,C,D)) \n  myTetra.set_draw_details(flatsh,[tex]) \n  # Load ttf font and set the font to black \n  arialFont = pi3d.Font(\"fonts/FreeMonoBoldOblique.ttf\", \n                        \"#000000\") \n  mystring = [] \n  #Create string objects to show the coordinates \n  for i,pos in enumerate(coords): \n    mystring.append(pi3d.String(font=arialFont, \n                            string=ids[i]+str(pos), \n                            x=pos[0], y=pos[1],z=pos[2])) \n    mystring.append(pi3d.String(font=arialFont, \n                            string=ids[i]+str(pos), \n                            x=pos[0], y=pos[1],z=pos[2], ry=180)) \n  for string in mystring: \n    string.set_shader(flatsh) \n\n  camRad = 4.0 # radius of camera position \n  rot = 0.0 # rotation of camera \n  tilt = 0.0 # tilt of camera \n  k = KEY['NONE'] \n  omx, omy = mymouse.position() \n\n  # main display loop \n  while DISPLAY.loop_running() and not k == KEY['ESC']: \n    k = mykeys.read() \n    mx, my = mymouse.position() \n    rot -= (mx-omx)*0.8 \n    tilt += (my-omy)*0.8 \n    omx = mx \n    omy = my \n\n    CAMERA.reset() \n    CAMERA.rotate(-tilt, rot, 0) \n    CAMERA.position((camRad * sin(radians(rot)) * \n                     cos(radians(tilt)),  \n                     camRad * sin(radians(tilt)),  \n                     -camRad * cos(radians(rot)) * \n                     cos(radians(tilt)))) \n    #Draw the Tetrahedron \n    myTetra.draw() \n    for string in mystring: \n      string.draw() \n\ntry: \n  main() \nfinally: \n  mykeys.close() \n  mymouse.stop() \n  DISPLAY.destroy() \n  print(\"Closed Everything. END\") \n#End \n```", "```py\npi3d.Camera.Camera(at=(0, 0, 0), eye=(0, 0, -0.1), \n                   lens=None, is_3d=True, scale=1.0) \n```", "```py\nclass pi3d.Shader.Shader(shfile=None, vshader_source=None, \n                                      fshader_source=None) \n```", "```py\nclass pi3d.Light (lightpos=(10, -10, 20), \n                       lightcol=(1.0, 1.0, 1.0), \n                       lightamb=(0.1, 0.1, 0.2)) \n```", "```py\n#!/usr/bin/python3 \n\"\"\" Wavefront obj model loading. Material properties set in \n    mtl file. Uses the import pi3d method to load *everything* \n\"\"\" \nimport demo \nimport pi3d \nfrom math import sin, cos, radians \n\nKEY = {'ESC':27,'NONE':-1} \n\n# Setup display and initialise pi3d \nDISPLAY = pi3d.Display.create() \n#capture mouse and key presses \nmykeys = pi3d.Keyboard() \nmymouse = pi3d.Mouse(restrict = False) \nmymouse.start() \n\ndef main(): \n  #Model textures and shaders \n  shader = pi3d.Shader(\"uv_reflect\") \n  bumptex = pi3d.Texture(\"textures/floor_nm.jpg\") \n  shinetex = pi3d.Texture(\"textures/stars.jpg\") \n  # load model \n  #mymodel = pi3d.Model(file_string='models/teapot.obj', z=10) \n  mymodel = pi3d.Model(file_string='models/monkey.obj', z=10) \n  mymodel.set_shader(shader) \n  mymodel.set_normal_shine(bumptex, 4.0, shinetex, 0.5) \n\n  #Create environment box \n  flatsh = pi3d.Shader(\"uv_flat\") \n  ectex = pi3d.loadECfiles(\"textures/ecubes\",\"sbox\") \n  myecube = pi3d.EnvironmentCube(size=900.0, maptype=\"FACES\", \n                                 name=\"cube\") \n  myecube.set_draw_details(flatsh, ectex) \n\n  CAMERA = pi3d.Camera.instance() \n  rot = 0.0 # rotation of camera \n  tilt = 0.0 # tilt of camera \n  k = KEY['NONE'] \n  omx, omy = mymouse.position() \n\n  while DISPLAY.loop_running() and not k == KEY['ESC']: \n    k = mykeys.read() \n    #Rotate camera - camera steered by mouse \n    mx, my = mymouse.position() \n    rot -= (mx-omx)*0.8 \n    tilt += (my-omy)*0.8 \n    omx = mx \n    omy = my \n    CAMERA.reset() \n    CAMERA.rotate(tilt, rot, 0) \n    #Rotate object \n    mymodel.rotateIncY(2.0) \n    mymodel.rotateIncZ(0.1) \n    mymodel.rotateIncX(0.3) \n    #Draw objects \n    mymodel.draw() \n    myecube.draw() \n\ntry: \n  main() \nfinally: \n  mykeys.close() \n  mymouse.stop() \n  DISPLAY.destroy() \n  print(\"Closed Everything. END\") \n#End \n```", "```py\nmymodel = pi3d.Model(file_string='models/monkey.obj', \n   name='monkey', z=4) \n```", "```py\nmap_Kd ../textures/water.jpg \n```", "```py\nshotnum = 0 #Set counter to 0 \nwhile DISPLAY.loop_running() \n... \n  if inputs.key_state(\"KEY_P\"): \n    while inputs.key_state(\"KEY_P\"): \n      inputs.do_input_events()         # wait for key to go up \n      pi3d.screenshot(\"screenshot%04d.jpg\"%( shotnum)) \n      shotnum += 1 \n... \n```", "```py\n#!/usr/bin/python3 \nfrom __future__ import absolute_import, division \nfrom __future__ import print_function, unicode_literals \n\"\"\" An example of generating a 3D environment using a elevation map \n\"\"\" \nfrom math import sin, cos, radians \nimport demo \nimport pi3d \n\nKEY = {'R':114,'S':115,'T':116,'W':119,'ESC':27,'NONE':-1} \n\nDISPLAY = pi3d.Display.create(x=50, y=50) \n#capture mouse and key presses \nmykeys = pi3d.Keyboard() \nmymouse = pi3d.Mouse(restrict = False) \nmymouse.start() \n\ndef limit(value,min,max): \n  if (value < min): \n    value = min \n  elif (value > max): \n    value = max \n  return value \n\ndef main(): \n  CAMERA = pi3d.Camera.instance() \n  tex = pi3d.Texture(\"textures/grass.jpg\") \n  flatsh = pi3d.Shader(\"uv_flat\") \n  # Create elevation map \n  mapwidth,mapdepth,mapheight = 200.0,200.0,50.0 \n  mymap = pi3d.ElevationMap(\"textures/Map.png\", \n                width=mapwidth, depth=mapdepth, height=mapheight, \n                divx=128, divy=128, ntiles=20) \n  mymap.set_draw_details(flatsh, [tex], 1.0, 1.0) \n\n  rot = 0.0 # rotation of camera \n  tilt = 0.0 # tilt of camera \n  height = 20 \n  viewhight = 4 \n  sky = 200 \n  xm,ym,zm = 0.0,height,0.0 \n  k = KEY['NONE'] \n  omx, omy = mymouse.position() \n  onGround = False \n  # main display loop \n  while DISPLAY.loop_running() and not k == KEY['ESC']: \n    CAMERA.reset() \n    CAMERA.rotate(-tilt, rot, 0) \n    CAMERA.position((xm,ym,zm)) \n    mymap.draw() \n\n    mx, my = mymouse.position() \n    rot -= (mx-omx)*0.8 \n    tilt += (my-omy)*0.8 \n    omx = mx \n    omy = my \n\n    #Read keyboard keys \n    k = mykeys.read() \n    if k == KEY['W']: \n      xm -= sin(radians(rot)) \n      zm += cos(radians(rot)) \n    elif k == KEY['S']: \n      xm += sin(radians(rot)) \n      zm -= cos(radians(rot)) \n    elif k == KEY['R']: \n      ym += 2 \n      onGround = False \n    elif k == KEY['T']: \n      ym -= 2 \n    ym -= 0.1 #Float down! \n    #Limit the movement \n    xm = limit(xm,-(mapwidth/2),mapwidth/2) \n    zm = limit(zm,-(mapdepth/2),mapdepth/2) \n    if ym >= sky: \n      ym = sky \n    #Check onGround \n    ground = mymap.calcHeight(xm, zm) + viewhight \n    if (onGround == True) or (ym <= ground): \n      ym = mymap.calcHeight(xm, zm) + viewhight \n      onGround = True \n\ntry: \n  main() \nfinally: \n  mykeys.close() \n  mymouse.stop() \n  DISPLAY.destroy() \n  print(\"Closed Everything. END\") \n#End \n```", "```py\n#!/usr/bin/python3 \n\"\"\"Small maze game, try to find the exit \n\"\"\" \nfrom math import sin, cos, radians \nimport demo \nimport pi3d \nfrom pi3d.shape.Building import Building, SolidObject \nfrom pi3d.shape.Building import Size, Position \n\nKEY = {'A':97,'D':100,'H':104,'R':114,'S':115,'T':116, \n       'W':119,'ESC':27,'APOST':39,'SLASH':47,'NONE':-1} \n\n# Setup display and initialise pi3d \nDISPLAY = pi3d.Display.create() \n#capture mouse and key presses \nmykeys = pi3d.Keyboard() \nmymouse = pi3d.Mouse(restrict = False) \n\n#Load shader \nshader = pi3d.Shader(\"uv_reflect\") \nflatsh = pi3d.Shader(\"uv_flat\") \n# Load textures \nceilingimg = pi3d.Texture(\"textures/squareblocks4.png\") \nwallimg = pi3d.Texture(\"textures/squareblocksred.png\") \nfloorimg = pi3d.Texture(\"textures/dunes3_512.jpg\") \nbumpimg = pi3d.Texture(\"textures/mudnormal.jpg\") \nstartimg = pi3d.Texture(\"textures/rock1.jpg\")     \nendimg = pi3d.Texture(\"textures/water.jpg\") \n# Create elevation map \nmapwidth = 1000.0 \nmapdepth = 1000.0 \n#We shall assume we are using a flat floor in this example \nmapheight = 0.0 \nmymap = pi3d.ElevationMap(mapfile=\"textures/floor.png\", \n                width=mapwidth, depth=mapdepth, height=mapheight, \n                divx=64, divy=64) \nmymap.set_draw_details(shader,[floorimg, bumpimg],128.0, 0.0) \nlevelList = [\"textures/inside_map0.png\",\"textures/inside_map1.png\", \n             \"textures/inside_map2.png\"] \navhgt = 5.0 \naveyelevel = 4.0 \nMAP_BLOCK = 15.0 \naveyeleveladjust = aveyelevel - avhgt/2 \nPLAYERHEIGHT = (mymap.calcHeight(5, 5) + avhgt/2) \n#Start the player in the top-left corner \nstartpos = [(8*MAP_BLOCK),PLAYERHEIGHT,(8*MAP_BLOCK)] \nendpos = [0,PLAYERHEIGHT,0] #Set the end pos in the centre \nperson = SolidObject(\"person\", Size(1, avhgt, 1), \n                Position(startpos[0],startpos[1],startpos[2]), 1) \n#Add spheres for start and end, end must also have a solid object \n#so we can detect when we hit it \nstartobject = pi3d.Sphere(name=\"start\",x=startpos[0], \n                          y=startpos[1]+avhgt,z=startpos[2]) \nstartobject.set_draw_details(shader, [startimg, bumpimg], \n                             32.0, 0.3) \nendobject = pi3d.Sphere(name=\"end\",x=endpos[0], \n                        y=endpos[1],z=endpos[2]) \nendobject.set_draw_details(shader, [endimg, bumpimg], 32.0, 0.3) \nendSolid = SolidObject(\"end\", Size(1, avhgt, 1), \n                Position(endpos[0],endpos[1],endpos[2]), 1) \n\nmazeScheme = {\"#models\": 3, \n      (1,None): [[\"C\",2]],      #white cell : Ceiling \n      (0,1,\"edge\"): [[\"W\",1]],  #white cell on edge next \n                                #   black cell : Wall \n      (1,0,\"edge\"): [[\"W\",1]],  #black cell on edge next \n                                #   to white cell : Wall \n      (0,1):[[\"W\",0]]}          #white cell next \n                                #   to black cell : Wall \n\ndetails = [[shader, [wallimg], 1.0, 0.0, 4.0, 16.0], \n            [shader, [wallimg], 1.0, 0.0, 4.0, 8.0], \n            [shader, [ceilingimg], 1.0, 0.0, 4.0, 4.0]] \n\narialFont = pi3d.Font(\"fonts/FreeMonoBoldOblique.ttf\", \n                      \"#ffffff\", font_size=10) \n```", "```py\ndef loadLevel(next_level): \n  print(\">>> Please wait while maze is constructed...\") \n  next_level=next_level%len(levelList) \n  building = pi3d.Building(levelList[next_level], 0, 0, mymap, \n      width=MAP_BLOCK, depth=MAP_BLOCK, height=30.0, \n      name=\"\", draw_details=details, yoff=-15, scheme=mazeScheme) \n  return building \n\ndef showMessage(text,rot=0): \n  message = pi3d.String(font=arialFont, string=text, \n                        x=endpos[0],y=endpos[1]+(avhgt/4), \n                        z=endpos[2], sx=0.05, sy=0.05,ry=-rot) \n  message.set_shader(flatsh) \n  message.draw() \n```", "```py\ndef main(): \n  #Load a level \n  level=0 \n  building = loadLevel(level) \n  lights = pi3d.Light(lightpos=(10, -10, 20), \n                      lightcol =(0.7, 0.7, 0.7), \n                      lightamb=(0.7, 0.7, 0.7)) \n  rot=0.0 \n  tilt=0.0 \n  #capture mouse movements \n  mymouse.start() \n  omx, omy = mymouse.position() \n\n  CAMERA = pi3d.Camera.instance() \n  while DISPLAY.loop_running() and not  \n                               inputs.key_state(\"KEY_ESC\"): \n    CAMERA.reset() \n    CAMERA.rotate(tilt, rot, 0) \n    CAMERA.position((person.x(), person.y(), \n                     person.z() - aveyeleveladjust)) \n    #draw objects \n    person.drawall() \n    building.drawAll() \n    mymap.draw() \n    startobject.draw() \n    endobject.draw() \n    #Apply the light to all the objects in the building \n    for b in building.model: \n      b.set_light(lights, 0) \n    mymap.set_light(lights, 0) \n\n   #Get mouse position \n    mx, my = mymouse.position() \n    rot -= (mx-omx)*0.8 \n    tilt += (my-omy)*0.8 \n    omx = mx \n    omy = my \n    xm = person.x() \n    ym = person.y() \n    zm = person.z() \n```", "```py\n#Read keyboard keys \nk = mykeys.read() \nif k == KEY['APOST']: #' Key \n  tilt -= 2.0 \nelif k == KEY['SLASH']: #/ Key \n  tilt += 2.0 \nelif k == KEY['A']: \n  rot += 2.0 \nelif k == KEY['D']: \n  rot -= 2.0 \nelif k == KEY['H']: \n  #Use point_at as help - will turn the player to face \n  #  the direction of the end point \n  tilt, rot = CAMERA.point_at([endobject.x(), endobject.y(), \n                                   endobject.z()]) \nelif k == KEY['W']: \n  xm -= sin(radians(rot)) \n  zm += cos(radians(rot)) \nelif k == KEY['S']: \n  xm += sin(radians(rot)) \n  zm -= cos(radians(rot)) \n\nNewPos = Position(xm, ym, zm) \ncollisions = person.CollisionList(NewPos) \nif collisions: \n  #If we reach the end, reset to start position! \n  for obj in collisions: \n    if obj.name == \"end\": \n      #Required to remove the building walls from the \n      #  solidobject list \n      building.remove_walls() \n      showMessage(\"Loading Level\",rot) \n      DISPLAY.loop_running() \n      level+=1 \n      building = loadLevel(level) \n      showMessage(\"\") \n      person.move(Position(startpos[0],startpos[1], \n                               startpos[2])) \nelse: \n  person.move(NewPos) \n\ntry: \n  main() \nfinally: \n  mykeys.close() \n  mymouse.stop() \n  DISPLAY.destroy() \n  print(\"Closed Everything. END\") \n#End \n```", "```py\nmazeScheme = {\"#models\": 3, \n  (1,None): [[\"C\",2]],     #white cell : Ceiling \n  (0,1,\"edge\"): [[\"W\",1]], #white cell on edge by black cell : Wall \n  (1,0,\"edge\"): [[\"W\",1]], #black cell on edge by white cell : Wall \n  (0,1):[[\"W\",0]]}         #white cell next to black cell : Wall  \n```", "```py\ndetails = [[shader, [wallimg], 1.0, 0.0, 4.0, 16.0], \n           [shader, [wallimg], 1.0, 0.0, 4.0, 8.0], \n           [shader, [ceilingimg], 1.0, 0.0, 4.0, 4.0]] \n```", "```py\nbuilding = pi3d.Building(levelList[next_level], 0, 0, mymap,\n    width=MAP_BLOCK, depth=MAP_BLOCK, height=30.0, name=\"\",\n      draw_details=details, yoff=-15, scheme=mazeScheme) \n```"]