<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;The Template Method Pattern &#x2013; Encapsulating Algorithm"><div class="book" id="1UU542-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. The Template Method Pattern – Encapsulating Algorithm</h1></div></div></div><p class="calibre6">In the previous chapter, we started with an introduction to the Command design pattern in which an object is used to encapsulate all the information needed to perform an action or trigger an event at a later time. We understood the concept of the Command design pattern with a UML diagram and also saw how it's applied in the real world with the help of the Python implementation. We discussed the pros and cons of Command patterns, explored more in the FAQ section, and summarized the discussion at the end of the chapter.</p><p class="calibre6">In this chapter, we will talk about the Template design pattern, such as the Command pattern and Template pattern that falls under the hood of Behavioral patterns. We will get introduced to the Template design pattern and discuss how it is used in software application development. We will also work with a sample use case and implement it in Python v3.5.</p><p class="calibre6">In this chapter, we will cover the following topics in brief:</p><div class="book"><ul class="itemizedlist"><li class="listitem">An introduction to the Template Method design pattern</li><li class="listitem">The Template pattern and its UML diagram</li><li class="listitem">A real-world use case with the Python v3.5 code implementation</li><li class="listitem">The Template pattern – pros and cons</li><li class="listitem">The Hollywood principle, Template Method, and Template hook</li><li class="listitem">Frequently asked questions</li></ul></div><p class="calibre6">At the end of this chapter, you will be able to analyze situations where the Template design pattern is applicable and efficiently use them to solve design-related problems. We will also summarize the entire discussion on the Template Method pattern as a takeaway.</p></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;The Template Method Pattern &#x2013; Encapsulating Algorithm">
<div class="book" title="Defining the Template Method pattern"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec59" class="calibre1"/>Defining the Template Method pattern</h1></div></div></div><p class="calibre6">As we saw <a id="id199" class="calibre1"/>in the previous chapter, Behavioral patterns focus on the responsibilities that an object has. It deals with the interaction among objects to achieve larger functionality. The Template Method pattern is a behavioral design pattern that defines the program skeleton or an algorithm in a method called <a id="id200" class="calibre1"/>the Template Method. For example, you could define the steps to prepare a beverage as an algorithm in a Template Method. The Template Method pattern also helps redefine or customize certain steps of the algorithm by deferring the implementation of some of these steps to subclasses. This means that the subclasses can redefine their own behavior. For example, in this case, subclasses can implement steps to prepare tea using the Template Method to prepare a beverage. It is important to note that the change in the steps (as done by the subclasses) don't impact the original algorithm's structure. Thus, the facility of overriding by subclasses in the Template Method pattern allows the creation of different behaviors or algorithms.</p><p class="calibre6">To talk about the Template Method pattern in software development terminology, an abstract class is used to define the steps of the algorithm. These steps are also known as <span class="strong"><em class="calibre13">primitive operations</em></span> in the context of the Template Method pattern. These steps are defined with abstract methods, and the Template Method defines the algorithm. The <code class="email">ConcreteClass</code> (that subclasses the abstract class) implements subclass-specific steps of the algorithm.</p><p class="calibre6">The<a id="id201" class="calibre1"/> Template Method pattern is used in the following cases:</p><div class="book"><ul class="itemizedlist"><li class="listitem">When multiple algorithms or classes implement similar or identical logic</li><li class="listitem">The implementation of algorithms in subclasses helps reduce code duplication</li><li class="listitem">Multiple algorithms can be defined by letting the subclasses implement the behavior through overriding</li></ul></div><p class="calibre6">Let's understand the pattern with a very simple day-to-day example. Think of what all you do when you prepare tea or coffee. In the case of coffee, you perform the following steps to prepare the beverage:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Boil water.</li><li class="listitem" value="2">Brew coffee beans.</li><li class="listitem" value="3">Pour it in the coffee cup.</li><li class="listitem" value="4">Add sugar and milk to the cup.</li><li class="listitem" value="5">Stir, and the coffee is done.</li></ol><div class="calibre17"/></div><p class="calibre6">Now, if you want to prepare a cup of tea, you will perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Boil water.</li><li class="listitem" value="2">Steep the tea bag.</li><li class="listitem" value="3">Pour the tea in a cup.</li><li class="listitem" value="4">Add lemon to the tea.</li><li class="listitem" value="5">Stir, and the tea is done.</li></ol><div class="calibre17"/></div><p class="calibre6">If you <a id="id202" class="calibre1"/>analyze both the preparations, you will find that both the procedures are more or less the same. In this case, we can use the Template Method pattern effectively. How do we implement it? We define a <code class="email">Beverage</code> class that has abstract methods common to preparing tea and coffee, such as <code class="email">boilWater()</code>. We also define the <code class="email">preparation()</code> Template Method that will call out the sequence of steps in preparing the beverage (the algorithm). We let the concrete classes, <code class="email">PrepareCoffee</code> and <code class="email">PrepareTea</code>, define the customized steps to achieve the goals of preparing coffee and tea. This is how the Template Method pattern avoids code duplication.</p><p class="calibre6">Another easy example is that of the compiler used by computer languages. A compiler essentially does two things: collects the source and compiles to the target object. Now, if we need to define a cross compiler for iOS devices, we can implement this with the help of the Template Method pattern. We will read about this example in detail later in the chapter.</p></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;The Template Method Pattern &#x2013; Encapsulating Algorithm">
<div class="book" title="Defining the Template Method pattern">
<div class="book" title="Understanding the Template Method design pattern"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec42" class="calibre1"/>Understanding the Template Method design pattern</h2></div></div></div><p class="calibre6">In <a id="id203" class="calibre1"/>short, the main intentions of the Template Method pattern are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Defining a skeleton of an algorithm with primitive operations</li><li class="listitem">Redefining certain operations of the subclass without changing the algorithm's structure</li><li class="listitem">Achieving code reuse and avoiding duplicate efforts</li><li class="listitem">Leveraging common interfaces or implementations</li></ul></div><p class="calibre6">The Template Method pattern works with the following terms—<code class="email">AbstractClass</code>, <code class="email">ConcreteClass</code>, Template Method, and <code class="email">Client</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">AbstractClass</code>: This declares an interface to define the steps of the algorithm</li><li class="listitem"><code class="email">ConcreteClass</code>: This defines subclass-specific step definitions</li><li class="listitem"><code class="email">template_method()</code>: This defines the algorithm by calling the step methods</li></ul></div><p class="calibre6">We talked about the example of a compiler earlier in the chapter. Consider that we want to develop our own cross compiler for an iOS device and run the program.</p><p class="calibre6">We first develop an abstract class (compiler) that defines the algorithm of a compiler. The operations done by the compiler are collecting the source of the code written in a program language and then compiling it to get the object code (binary format). We define these steps as the <code class="email">collectSource()</code> and <code class="email">compileToObject()</code> abstract methods and also define <a id="id204" class="calibre1"/>the <code class="email">run()</code> method that is responsible for executing the program. The algorithm is defined by the <code class="email">compileAndRun()</code> method, which internally calls the <code class="email">collectSource()</code>, <code class="email">compileToObject()</code>, and <code class="email">run()</code> methods to define the algorithm of the compiler. The <code class="email">iOSCompiler</code> concrete class now implements the abstract methods and compiles/runs the Swift code on the iOS device.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre6">The Swift programming language is used to develop applications on the iOS platform.</p></div><p class="calibre6">The following Python code implements the Template Method design pattern:</p><div class="informalexample"><pre class="programlisting">from abc import  ABCMeta, abstractmethod

class Compiler(metaclass=ABCMeta):
    @abstractmethod
    def collectSource(self):
        pass

    @abstractmethod
    def compileToObject(self):
        pass

    @abstractmethod
    def run(self):
        pass
    
    def compileAndRun(self):
        self.collectSource()
        self.compileToObject()
        self.run()


class iOSCompiler(Compiler):
    def collectSource(self):
        print("Collecting Swift Source Code")
    
    def compileToObject(self):
        print("Compiling Swift code to LLVM bitcode")
    
    def run(self):
        print("Program runing on runtime environment")


iOS = iOSCompiler()
iOS.compileAndRun()</pre></div><p class="calibre6">The <a id="id205" class="calibre1"/>output of the preceding code should look as follows:</p><div class="mediaobject"><img src="../images/00026.jpeg" alt="Understanding the Template Method design pattern" class="calibre14"/></div><p class="calibre15"> </p></div></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;The Template Method Pattern &#x2013; Encapsulating Algorithm">
<div class="book" title="Defining the Template Method pattern">
<div class="book" title="A UML class diagram for the Template Method pattern"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec43" class="calibre1"/>A UML class diagram for the Template Method pattern</h2></div></div></div><p class="calibre6">Let's<a id="id206" class="calibre1"/> understand more about the Template method pattern with the help of a UML diagram.</p><p class="calibre6">As we discussed in the previous section, the Template method pattern has the following main participants: the abstract class, concrete class, Template method, and client. Let's put these in a UML diagram and see how the classes look:</p><div class="mediaobject"><img src="../images/00027.jpeg" alt="A UML class diagram for the Template Method pattern" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">As we look at the UML diagram, you'll realize that there are four main participants in this pattern:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">AbstractClass</code>: This defines the operations or steps of an algorithm with the help<a id="id207" class="calibre1"/> of abstract methods. These steps are overridden by concrete subclasses.</li><li class="listitem"><code class="email">template_method()</code>: This defines the skeleton of the algorithm. Multiple steps as defined by abstract methods are called in the Template method to define the sequence or the algorithm itself.</li><li class="listitem"><code class="email">ConcreteClass</code>: This implements the steps (as defined by the abstract methods) to perform subclass-specific steps of the algorithm.</li></ul></div><p class="calibre6">The following is a code example to understand the pattern with all the participants involved:</p><div class="informalexample"><pre class="programlisting">from abc import ABCMeta, abstractmethod

class AbstractClass(metaclass=ABCMeta):
    def __init__(self):
        pass

    @abstractmethod
    def operation1(self):
        pass

    @abstractmethod
    def operation2(self):
        pass
    
    def template_method(self):
        print("Defining the Algorithm. Operation1 follows Operation2")
        self.operation2()
        self.operation1()


class ConcreteClass(AbstractClass):

    def operation1(self):
        print("My Concrete Operation1")
    
    def operation2(self):
        print("Operation 2 remains same")


class Client:
    def main(self):
        self.concreate = ConcreteClass()
        self.concreate.template_method()

client = Client()
client.main()</pre></div><p class="calibre6">The <a id="id208" class="calibre1"/>output of the preceding code should look as follows:</p><div class="mediaobject"><img src="../images/00028.jpeg" alt="A UML class diagram for the Template Method pattern" class="calibre14"/></div><p class="calibre15"> </p></div></div></div>
<div class="book" title="The Template Method pattern in the real world"><div class="book" id="1VSLM2-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec60" class="calibre1"/>The Template Method pattern in the real world</h1></div></div></div><p class="calibre6">Let's take a<a id="id209" class="calibre1"/> very easy-to-understand scenario to implement the Template method pattern. Imagine the case of a travel agency, say, Dev Travels. Now how do they typically work? They define various trips to various locations and come up with a holiday package for you. A package is essentially a trip that you, as a customer, undertakes. A trip has details such as the places visited, transportation used, and other factors that define the trip itinerary. This same trip can be customized differently based on the needs of the customers. This calls for the Template Method pattern, doesn't it?</p><p class="calibre6">Design Considerations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">For <a id="id210" class="calibre1"/>the preceding scenario, based on the UML diagram, we should create an <code class="email">AbstractClass</code> interface that defines a trip</li><li class="listitem">The trip should contain multiple abstract methods that define the transportation used, places visited on <code class="email">day1</code>, <code class="email">day2</code>, and <code class="email">day3</code>, assuming that it's a three-day long weekend trip, and also define the return journey</li><li class="listitem">The <code class="email">itinerary()</code> Template Method will actually define the trip's itinerary</li><li class="listitem">We should define <code class="email">ConcreteClasses</code> that would help us customize trips differently based on the customer's needs</li></ul></div><p class="calibre6">Let's develop an application in Python v3.5 and implement the preceding use case. We start with the abstract class, <code class="email">Trip</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The abstract object is represented by the <code class="email">Trip</code> class. It is an interface (Python's abstract base class) that defines the details such as the transportation<a id="id211" class="calibre1"/> used and places to visit on different days.</li><li class="listitem">The <code class="email">setTransport</code> is an<a id="id212" class="calibre1"/> abstract method that should be implemented by <code class="email">ConcreteClass</code> to set the mode of transportation.</li><li class="listitem">The <code class="email">day1()</code>, <code class="email">day2()</code>, <code class="email">day3()</code> abstract methods define the places visited on the given day.</li><li class="listitem">The <code class="email">itinerary()</code> Template Method creates the complete itinerary (the algorithm, in this case, the trip). The sequence of the trip is to first define the transportation mode, then the places to visit on each day, and the <code class="email">returnHome</code>.</li></ul></div><p class="calibre6">The following code implements the scenario of Dev Travels:</p><div class="informalexample"><pre class="programlisting">from abc import abstractmethod, ABCMeta

class Trip(metaclass=ABCMeta):

    @abstractmethod
    def setTransport(self):
        pass

    @abstractmethod
    def day1(self):
        pass

    @abstractmethod
    def day2(self):
        pass

    @abstractmethod
    def day3(self):
        pass

    @abstractmethod
    def returnHome(self):
        pass
    
    def itinerary(self):
        self.setTransport()
        self.day1()
        self.day2()
        self.day3()
        self.returnHome()</pre></div><p class="calibre6">We have also developed certain classes that represent the concrete class:</p><div class="book"><ul class="itemizedlist"><li class="listitem">In this case, we have two main concrete classes—<code class="email">VeniceTrip</code> and <code class="email">MaldivesTrip</code>—that implement the <code class="email">Trip</code> interface</li><li class="listitem">Concrete classes represent two different trips taken by the tourists based on their choice and interests</li><li class="listitem"><code class="email">VeniceTrip</code> and <code class="email">MaldivesTrip</code> both implement <code class="email">setTransport()</code>, <code class="email">day1()</code>, <code class="email">day2()</code>, <code class="email">day3()</code>, and <code class="email">returnHome()</code></li></ul></div><p class="calibre6">Let's define<a id="id213" class="calibre1"/> the concrete classes in Python code:</p><div class="informalexample"><pre class="programlisting">class VeniceTrip(Trip):
    def setTransport(self):
        print("Take a boat and find your way in the Grand Canal")
    
    def day1(self):
        print("Visit St Mark's Basilica in St Mark's Square")
    
    def day2(self):
        print("Appreciate Doge's Palace")
    
    def day3(self):
        print("Enjoy the food near the Rialto Bridge")
    
    def returnHome(self):
        print("Get souvenirs for friends and get back")


class MaldivesTrip(Trip):
    def setTransport(self):
        print("On foot, on any island, Wow!")
    
    def day1(self):
        print("Enjoy the marine life of Banana Reef")
    
    def day2(self):
        print("Go for the water sports and snorkelling")
    
    def day3(self):
        print("Relax on the beach and enjoy the sun")
    
    def returnHome(self):
        print("Dont feel like leaving the beach..")</pre></div><p class="calibre6">Now, let's talk about the travel agency and tourists who want to have an awesome vacation:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">TravelAgency</code> class represents the <code class="email">Client</code> object in this example</li><li class="listitem">It defines<a id="id214" class="calibre1"/> the <code class="email">arrange_trip()</code> method that provides customers with the choice of whether they want to have a historical trip or beach trip</li><li class="listitem">Based on the choice made by the tourist, an appropriate class is instantiated</li><li class="listitem">This object then calls the <code class="email">itinerary()</code> Template Method and the trip is arranged for the tourists as per the choice of the customers</li></ul></div><p class="calibre6">The following is the implementation for the Dev travel agency and how they arrange for the trip based on the customer's choice:</p><div class="informalexample"><pre class="programlisting">class TravelAgency:
    def arrange_trip(self):
        choice = input("What kind of place you'd like to go historical or to a beach?")
        if choice == 'historical':
            self.trip = VeniceTrip()
            self.trip.itinerary()
        if choice == 'beach':
            self.trip = MaldivesTrip()
            self.trip.itinerary()

TravelAgency().arrange_trip()</pre></div><p class="calibre6">The output of the preceding code should look as follows:</p><div class="mediaobject"><img src="../images/00029.jpeg" alt="The Template Method pattern in the real world" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">If you decide to go on a historical trip, this will be the output of the code:</p><div class="mediaobject"><img src="../images/00030.jpeg" alt="The Template Method pattern in the real world" class="calibre14"/></div><p class="calibre15"> </p></div>
<div class="book" title="The Template Method pattern &#x2013; hooks" id="20R681-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec61" class="calibre1"/>The Template Method pattern – hooks</h1></div></div></div><p class="calibre6">A hook is<a id="id215" class="calibre1"/> a method that is declared in the abstract class. It is generally given a default implementation. The idea behind hooks is to give a subclass the ability to <span class="strong"><em class="calibre13">hook into</em></span> the algorithm whenever needed. It's not imperative for the subclass to use hooks and it can easily ignore this.</p><p class="calibre6">For example, in the beverage example, we can add a simple hook to see if condiments need to be served along with tea or coffee based on the wish of the customer.</p><p class="calibre6">Another example of hook can be in the case of the travel agency example. Now, if we have a few elderly tourists, they may not want to go out on all three days of the trip as they may get tired easily. In this case, we can develop a hook that will ensure <code class="email">day2</code> is lightly loaded, which means that they can go to a few nearby places and be back with the plan of <code class="email">day3</code>.</p><p class="calibre6">Basically, we use abstract methods when the subclass must provide the implementation, and hook is used when it is optional for the subclass to implement it.</p></div>
<div class="book" title="The Hollywood principle and the Template Method" id="21PMQ1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec62" class="calibre1"/>The Hollywood principle and the Template Method</h1></div></div></div><p class="calibre6">The Hollywood <a id="id216" class="calibre1"/>principle is the design principle that is <a id="id217" class="calibre1"/>summarized by <span class="strong"><em class="calibre13">Don't call us, we'll call you</em></span>. It comes from the Hollywood philosophy where the production houses call actors if there is any role for the actor.</p><p class="calibre6">In the object-oriented world, we allow low-level components to hook themselves into the system with the Hollywood principle. However, the high-level components determine how the low-level systems are needed and when they are needed. In other words, high-level components treat low-level components as <span class="strong"><em class="calibre13">Don't call us, we'll call you</em></span>.</p><p class="calibre6">This relates to the Template Method pattern in the sense that it's the high-level abstract class that arranges the steps to define the algorithm. Based on how the algorithm is, low-level classes are called on to define the concrete implementation for the steps.</p></div>
<div class="book" title="The advantages and disadvantages of the Template Method pattern" id="22O7C1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec63" class="calibre1"/>The advantages and disadvantages of the Template Method pattern</h1></div></div></div><p class="calibre6">The<a id="id218" class="calibre1"/> Template Method pattern provides you with the following advantages:</p><div class="book"><ul class="itemizedlist"><li class="listitem">As we saw earlier in the chapter, there is no code duplication.</li><li class="listitem">Code reuse happens with the Template Method pattern as it uses inheritance and not composition. Only a few methods need to be overridden.</li><li class="listitem">Flexibility lets subclasses decide how to implement steps in an algorithm.</li></ul></div><p class="calibre6">The <a id="id219" class="calibre1"/>disadvantages of Template Method patterns are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Debugging and understanding the sequence of flow in the Template Method pattern can be confusing at times. You may end up implementing a method that shouldn't be implemented or not implementing an abstract method at all. Documentation and strict error handling has to be done by the programmer.</li><li class="listitem">Maintenance of the template framework can be a problem as changes at any level (low-level or high-level) can disturb the implementation. Hence, maintenance can be painful with the Template Method pattern.</li></ul></div></div>
<div class="book" title="Frequently asked questions" id="23MNU1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec64" class="calibre1"/>Frequently asked questions</h1></div></div></div><p class="calibre6">Q1. Should a<a id="id220" class="calibre1"/> low-level component be disallowed from calling a method in a higher-level component?</p><p class="calibre6">A: No, a low-level component would definitely call the higher-level component through inheritance. However, what the programmer needs to make sure is that there is no circular dependency where the low-level and high-level components are dependent on each other.</p><p class="calibre6">Q2. Isn't the strategy pattern similar to the Template pattern?</p><p class="calibre6">A: The strategy pattern and Template pattern both encapsulate algorithms. Template depends on inheritance while strategy uses composition. The Template Method pattern is a compile-time algorithm selection by sub-classing while the strategy pattern is a runtime selection.</p></div>
<div class="book" title="Summary" id="24L8G1-5ae934a69a004514b92177e2702ed0a9"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec65" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">We began the chapter by understanding the Template Method design pattern and how it is effectively used in software architecture.</p><p class="calibre6">We also looked at how the Template Method design pattern is used to encapsulate the algorithm and provide the flexibility of implementing different behavior by overriding the methods in the subclasses.</p><p class="calibre6">You learned the pattern with a UML diagram and sample code implementation in Python v3.5 along with the explanation.</p><p class="calibre6">We also covered a section on FAQs that would help you get a better idea of the pattern and its possible advantages/disadvantages.</p><p class="calibre6">We will now talk about a composite pattern in the next chapter—the MVC design pattern.</p></div></body></html>