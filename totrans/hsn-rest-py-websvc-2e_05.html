<html><head></head><body><div><h1 class="header-title">Developing RESTful APIs with Django 2.1</h1>
                
            
            
                
<p>In this chapter, we will start working with Django and Django REST framework, and we will create a RESTful web API that performs CRUD operations on a simple SQLite database. We will do the following:</p>
<ul>
<li>Design a RESTful API to interact with a simple SQLite database</li>
<li>Understand the tasks performed by each HTTP method</li>
<li>Set up a virtual environment with Django REST framework</li>
<li>Create models</li>
<li>Manage serialization and deserialization</li>
<li>Understand status codes for responses</li>
<li>Write API views</li>
<li>Make HTTP requests to the API with command-line tools</li>
<li>Make HTTP requests to the API with GUI tools</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Designing a RESTful API to interact with a simple SQLite database</h1>
                
            
            
                
<p>Imagine that we have to start working on a mobile app that has to interact with a RESTful API to perform CRUD operations with games. We don't want to spend time choosing and configuring the most appropriate <strong>ORM</strong> (short for <strong>Object-Relational Mapping</strong>); we just want to finish the RESTful API as soon as possible to start interacting with it in our mobile app. We really want the games to persist in a database but we don't need it to be production-ready, and therefore, we can use the simplest possible relational database, as long as we don't have to spend time making complex installations or configurations.</p>
<p>We need the shortest possible development time. <strong>Django Rest Framework</strong> (<strong>DRF</strong>) will allow us to easily accomplish this task and start making HTTP requests to our first version of our RESTful web service. In this case, we will work with a very simple SQLite database, the default database for a new Django Rest Framework project.</p>
<p>First, we must specify the requirements for our main resource: a game. We need the following attributes or fields for a game:</p>
<ul>
<li>An integer identifier</li>
<li>A name or title</li>
<li>A release date</li>
<li>An <strong>ESRB</strong> (short for <strong>Entertainment Software Rating Board</strong>) rating description, such as <em>T</em> (<em>Teen</em>) and <em>EC</em> (<em>Early Childhood</em>). You can read more about the ESRB at <a href="http://www.esrb.org">http://www.esrb.org</a></li>
<li>A <kbd>bool</kbd> value indicating whether the game was played at least once by a player or not</li>
<li>An integer indicating the number of times the game was played</li>
</ul>
<p>In addition, we want our database to save a timestamp with the date and time in which the game was inserted in the database.</p>
<p>The following table shows the HTTP verbs, the scope, and the semantics for the methods that our first version of the API must support. Each method is composed by an HTTP verb and a scope and all the methods have a well-defined meaning for the games and the collection of games:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>HTTP verb</strong></p>
</td>
<td>
<p><strong>Scope</strong></p>
</td>
<td>
<p><strong>Semantics</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of games</p>
</td>
<td>
<p>Retrieve all the stored games in the collection, sorted by their name in ascending order</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Game</p>
</td>
<td>
<p>Retrieve a single game</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of games</p>
</td>
<td>
<p>Create a new game in the collection</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p>Game</p>
</td>
<td>
<p>Update an existing game</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>Game</p>
</td>
<td>
<p>Delete an existing game</p>
</td>
</tr>
</tbody>
</table>
<p>In a RESTful API, each resource has its own unique URL. In our API, each game has its own unique URL.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding the tasks performed by each HTTP method</h1>
                
            
            
                
<p>In the previous table, the <kbd>GET</kbd> HTTP verb appears twice but with two different scopes. The first row shows a <kbd>GET</kbd> HTTP verb applied to a collection of games (collection of resources) and the second row shows a <kbd>GET</kbd> HTTP verb applied to a game (a single resource).</p>
<p>Let's assume that <kbd>http://localhost:8000/games/</kbd> is the URL for the collection of games. If we add a number and a slash (<kbd>/</kbd>) to the previous URL, we identify a specific game whose ID is equal to the specified numeric value. For example, <kbd>http://localhost:8000/games/25/</kbd> identifies the game whose ID is equal to <kbd>25</kbd>.</p>
<p>We have to compose and send an HTTP request with the following HTTP verb (<kbd>POST</kbd>) and request URL (<kbd>http://localhost:8000/games/ ...</kbd></p></div>



  
<div><h1 class="header-title">Setting up the virtual environment with Django REST framework</h1>
                
            
            
                
<p>In <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>, we learned that, throughout this book, we are going to work with the lightweight virtual environments introduced and improved in Python 3.4. Now we will follow many steps to create a new lightweight virtual environment to work with Flask and Flask-RESTful.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>It is highly recommended that you read the section named <em>Working with lightweight virtual environments</em> in <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>, if you don't have experience with lightweight virtual environments in modern Python. The chapter includes all the detailed explanations about the effects of the steps we are going to follow.</p>
<p>The following commands assume that you have Python 3.7.1 or greater installed on Linux, macOS, or Windows.</p>
<p>First, we have to select the target folder or directory for our lightweight virtual environment. The following is the path we will use in the example for Linux and macOS:</p>
<pre>   <strong> ~/HillarPythonREST2/Django01</strong></pre>
<p>The target folder for the virtual environment will be the <kbd>HillarPythonREST2/Django01</kbd> folder within our home directory. For example, if our home directory in macOS or Linux is <kbd>/Users/gaston</kbd>, the virtual environment will be created within <kbd>/Users/gaston/HillarPythonREST2/Django01</kbd>. You can replace the specified path with your desired path in each command.</p>
<p>The following is the path we will use in the example for Windows:</p>
<pre>    <strong>%USERPROFILE%\HillarPythonREST2\Django01</strong></pre>
<p>The target folder for the virtual environment will be the <kbd>HillarPythonREST2\Django01</kbd> folder within our user profile folder. For example, if our user profile folder is <kbd>C:\Users\gaston</kbd>, the virtual environment will be created within <kbd>C:\Users\gaston\HillarPythonREST2\Django01</kbd>. Of course, you can replace the specified path with your desired path in each command.</p>
<p>In Windows PowerShell, the previous path would be as follows:</p>
<pre>    <strong>$env:userprofile\HillarPythonREST2\Django01</strong></pre>
<p>Now we have to use the <kbd>-m</kbd> option followed by the <kbd>venv</kbd> module name and the desired path to make Python run this module as a script and create a virtual environment in the specified path. The instructions are different depending on the platform in which we are creating the virtual environment. Thus, make sure you follow the instructions for your operating system.</p>
<p>Open a Terminal in Linux or macOS and execute the following command to create a virtual environment:</p>
<pre>    <strong>python3 -m venv ~/HillarPythonREST2/Django01</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In Windows, in the Command Prompt, execute the following command to create a virtual environment:</p>
<pre>    <strong>python -m venv %USERPROFILE%\HillarPythonREST2\Django01</strong></pre>
<p>If you want to work with Windows PowerShell, execute the following command to create a virtual environment:</p>
<pre>    <strong>python -m venv $env:userprofile\HillarPythonREST2\Django01</strong> </pre>
<p>The previous commands don't produce any output. Now that we have created a virtual environment, we will run a platform-specific script to activate it. After we activate the virtual environment, we will install packages that will only be available in this virtual environment.</p>
<p>If your Terminal is configured to use the <kbd>bash</kbd> shell in macOS or Linux, run the following command to activate the virtual environment. The command also works for the <kbd>zsh</kbd> shell:</p>
<pre>    <strong>source ~/PythonREST/Django01/bin/activate</strong></pre>
<p>If your Terminal is configured to use either the <kbd>csh</kbd> or <kbd>tcsh</kbd> shell, run the following command to activate the virtual environment:</p>
<pre>    <strong>source ~/PythonREST/Django01/bin/activate.csh</strong> </pre>
<p>If your Terminal is configured to use the <kbd>fish</kbd> shell, run the following command to activate the virtual environment:</p>
<pre>    <strong>source ~/PythonREST/Django01/bin/activate.fish</strong></pre>
<p>In Windows, you can run either a batch file in the Command Prompt or a Windows PowerShell script to activate the virtual environment. If you prefer the Command Prompt, run the following command in the Windows command line to activate the virtual environment:</p>
<pre>    <strong>%USERPROFILE%\PythonREST\Django01\Scripts\activate.bat</strong></pre>
<p>If you prefer the Windows PowerShell, launch it and run the following commands to activate the virtual environment. However, notice that you should have script execution enabled in Windows PowerShell to be able to run the script:</p>
<pre>    <strong>cd $env:USERPROFILE</strong>
    <strong>PythonREST\Django01\Scripts\Activate.ps1</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>After you activate the virtual environment, the Command Prompt will display the virtual environment root folder name enclosed in parenthesis as a prefix of the default prompt to remind us that we are working in the virtual environment. In this case, we will see (<kbd>Django01</kbd>) as a prefix for the Command Prompt because the root folder for the activated virtual environment is <kbd>Django01</kbd>.</p>
<p>We have followed the necessary steps to create and activate a virtual environment. Now we will create a <kbd>requirements.txt</kbd> file to specify the set of packages that our application requires to be installed in any supported platform. This way, it will be extremely easy to repeat the installation of the specified packages with their versions in any new virtual environment.</p>
<p>Use your favorite editor to create a new text file named <kbd>requirements.txt</kbd> within the root folder for the recently created virtual environment. The following lines show the contents for the file that declares the packages and the versions that our API requires. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/requirements.txt</kbd> file:</p>
<pre>Django==2.1.4 
djangorestframework==3.9.0 
httpie==0.9.9 </pre>
<p>Each line in the <kbd>requirements.txt</kbd> file indicates the package and the version that needs to be installed. In this case, we are working with exact versions by using the <kbd>==</kbd> operator because we want to make sure that the specified version is installed. The following table summarizes the packages and the version numbers that we specified as requirements:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p>Package name</p>
</td>
<td>
<p>Version to be installed</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Django</kbd></p>
</td>
<td>
<p>2.1.4</p>
</td>
</tr>
<tr>
<td>
<p><kbd>djangorestframework</kbd></p>
</td>
<td>
<p>3.9.0</p>
</td>
</tr>
<tr>
<td>
<p><kbd>httpie</kbd></p>
</td>
<td>
<p>1.0.2</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Go to the root folder for the virtual environment: <kbd>Django01</kbd>. In macOS or Linux, enter the following command:</p>
<pre>    <strong>cd ~/PythonREST/Django01</strong></pre>
<p>In Windows Command Prompt, enter the following command:</p>
<pre>    <strong>cd /d %USERPROFILE%\PythonREST\Django01</strong></pre>
<p class="mce-root"/>
<p>In Windows PowerShell, enter the following command:</p>
<pre>    <strong>cd $env:USERPROFILE</strong>
    <strong>cd PythonREST\Django01</strong> </pre>
<p>Now we must run the following command on macOS, Linux, or Windows to install the packages and the versions explained in the previous table with <kbd>pip</kbd> by using the recently created <kbd>requirements</kbd> file. Notice that <kbd>Django</kbd> is a dependency for <kbd>djangorestframework</kbd>. Make sure you are in the folder that has the <kbd>requirements.txt</kbd> file before running the command (<kbd>Django01</kbd>):</p>
<pre><strong>pip install -r requirements.txt</strong> </pre>
<p>The final lines for the output will indicate all the packages that have been successfully installed, including <kbd>Django</kbd>, <kbd>djangorestframework</kbd>, and <kbd>httpie</kbd>:</p>
<pre><strong>Installing collected packages: pytz, Django, djangorestframework, Pygments, certifi, chardet, idna, urllib3, requests, httpie</strong>
<strong>Successfully installed Django-2.1.4 Pygments-2.2.0 certifi-2018.10.15 chardet-3.0.4 djangorestframework-3.9.0 httpie-1.0.2 idna-2.7 pytz-2018.6 requests-2.20.0 urllib3-1.24</strong>
  </pre>
<p>Now run the following command to create a new Django project named <kbd>games_service</kbd>. The command won't produce any output:</p>
<pre>    <strong>django-admin.py startproject games_service</strong></pre>
<p>The previous command created a <kbd>games_service</kbd> folder with other subfolders and Python files. Now go to the recently created <kbd>games_service</kbd> folder. Just execute the following command:</p>
<pre>    <strong>cd games_service</strong></pre>
<p>Then, run the following command to create a new Django app named <kbd>games</kbd> within the <kbd>games_service</kbd> Django project. The command won't produce any output:</p>
<pre>    <strong>python manage.py startapp games</strong></pre>
<p>The previous command created a new <kbd>games_service/games</kbd> subfolder, with the following files:</p>
<ul>
<li><kbd>__init__.py</kbd></li>
<li><kbd>admin.py</kbd></li>
<li><kbd>apps.py</kbd></li>
<li><kbd>models.py</kbd></li>
<li><kbd>tests.py</kbd></li>
<li><kbd>views.py</kbd></li>
</ul>
<p>In addition, the <kbd>games_service/games</kbd> folder will have a <kbd>migrations</kbd> subfolder with a <kbd>__init__.py</kbd> Python script. The following screenshot shows the folders and files in the directory trees starting at the <kbd>games_service</kbd> folder:</p>
<div><img src="img/a9394409-5001-444d-bc88-bc861894f1b4.png" style="width:11.83em;height:32.25em;" width="413" height="1126"/></div>
<p>Let's check the Python code in the <kbd>apps.py</kbd> file within the <kbd>games_service/games</kbd> folder. The following lines show the code for this file:</p>
<pre>from django.apps import AppConfig 
 
 
class GamesConfig(AppConfig): 
    name = 'games'</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The code declares the <kbd>GamesConfig</kbd> class as a subclass of the <kbd>django.apps.AppConfig</kbd> superclass, which represents a Django application and its configuration. The <kbd>GamesConfig</kbd> class just defines the <kbd>name</kbd> class attribute and sets its value to <kbd>'games'</kbd>.</p>
<p>We have to add <kbd>games.apps.GamesConfig</kbd> as one of the installed apps in the <kbd>games_service/game_service/settings.py</kbd> file, which configures settings for the <kbd>games_service</kbd> Django project. We built the previous string as follows: <kbd>app name</kbd> + <kbd>.apps.</kbd> + <kbd>class name</kbd>, which is <kbd>games</kbd> + <kbd>.apps.</kbd> + <kbd>GamesConfig</kbd>. In addition, we have to add the <kbd>rest_framework</kbd> app to make it possible for us to use Django REST Framework.</p>
<p>The <kbd>games_service/games_service/settings.py</kbd> file is a Python module with module-level variables that define the configuration of Django for the <kbd>games_service</kbd> project. We will make some changes to this Django settings file. Open the <kbd>games_service/games_service/settings.py</kbd> file and locate the following lines, which specify the strings list that declares the installed apps and save it in the <kbd>INSTALLED_APPS</kbd> variable:</p>
<pre>INSTALLED_APPS = [ 
    'django.contrib.admin', 
    'django.contrib.auth', 
    'django.contrib.contenttypes', 
    'django.contrib.sessions', 
    'django.contrib.messages', 
    'django.contrib.staticfiles', 
] </pre>
<p>Add the following two strings to the <kbd>INSTALLED_APPS</kbd> strings list and save the changes to the <kbd>games_service/games_service/settings.py</kbd> file:</p>
<ul>
<li><kbd>'rest_framework'</kbd></li>
<li><kbd>'games.apps.GamesConfig'</kbd></li>
</ul>
<p>The following lines show the new code that declares the <kbd>INSTALLED_APPS</kbd> strings list with the added lines highlighted. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/games_service/games-service/settings.py</kbd> file:</p>
<pre>INSTALLED_APPS = [ 
    'django.contrib.admin', 
    'django.contrib.auth', 
    'django.contrib.contenttypes', 
    'django.contrib.sessions', 
    'django.contrib.messages', 
    'django.contrib.staticfiles', 
    # Django REST Framework 
    'rest_framework', 
    # Our Games application 
    'games.apps.GamesConfig', 
] </pre>
<p>This way, we have added Django REST Framework and the <kbd>games</kbd> application to our initial Django project named <kbd>games_service</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating the models</h1>
                
            
            
                
<p>Now we will create a simple <kbd>Game</kbd> model that we will use to represent and persist games. Open the <kbd>games_service/games/models.py</kbd> file. The following lines show the initial code for this file, with just one import statement and a comment that indicates we should create the models:</p>
<pre>from django.db import models 
 
# Create your models here. </pre>
<p>Replace the code for the <kbd>games_service/games/models.py</kbd> file with the following lines. The new code creates a <kbd>Game</kbd> class, specifically, a <kbd>Game</kbd> model in the <kbd>games/models.py</kbd> file. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/games_service/games/apps.py</kbd> file:</p>
<pre>from django.db import models class Game(models.Model): created_timestamp = models.DateTimeField(auto_now_add=True) ...</pre></div>



  
<div><h1 class="header-title">Managing serialization and deserialization</h1>
                
            
            
                
<p>Our RESTful web API has to be able to serialize the game instances into JSON representations and also deserialize the JSON representations to build game instances. With Django REST Framework, we just need to create a serializer class for the game instances to manage serialization to JSON and deserialization from JSON.</p>
<p>Django REST Framework uses a two-phase process for serialization. The serializers are mediators between the model instances and Python primitives. Parsers and renderers act as mediators between Python primitives and HTTP requests and responses.</p>
<p>We will configure our mediator between the <kbd>Game</kbd> model instances and Python primitives by creating a subclass of the <kbd>rest_framework.serializers.Serializer</kbd> class to declare the fields and the necessary methods to manage serialization and deserialization. We will repeat some of the information about the fields that we have included in the <kbd>Game</kbd> model so that we understand all the things that we can configure in a subclass of the <kbd>Serializer</kbd> class. However, we will work with shortcuts that will reduce boilerplate code later in the next examples. We will write less code in the next examples by using the <kbd>ModelSerializer</kbd> class.</p>
<p class="mce-root"/>
<p>Now go to the <kbd>games_service/games</kbd> folder and create a new Python code file named <kbd>serializers.py</kbd>. The following lines show the code that declares the new <kbd>GameSerializer</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/games_service/games/serializers.py</kbd> file:</p>
<pre>from rest_framework import serializers 
from games.models import Game 
 
 
class GameSerializer(serializers.Serializer): 
    id = serializers.IntegerField(read_only=True) 
    name = serializers.CharField(max_length=200) 
    release_date = serializers.DateTimeField() 
    esrb_rating = serializers.CharField(max_length=150) 
    played_once = serializers.BooleanField(required=False) 
    played_times = serializers.IntegerField(required=False) 
 
    def create(self, validated_data): 
        return Game.objects.create(**validated_data) 
 
    def update(self, instance, validated_data): 
        instance.name = validated_data.get('name',  
            instance.name) 
        instance.release_date = validated_data.get('release_date',  
            instance.release_date) 
        instance.esrb_rating = validated_data.get('esrb_rating',  
            instance.esrb_rating) 
        instance.played_once = validated_data.get('played_once',  
            instance.played_once) 
        instance.played_times = validated_data.get('played_times',  
            instance.played_times) 
        instance.save() 
        return instance </pre>
<p>The <kbd>GameSerializer</kbd> class declares the attributes that represent the fields that we want to be serialized. Notice that we have omitted the <kbd>created_timestamp</kbd> attribute that was present in the <kbd>Game</kbd> model. When there is a call to the inherited <kbd>save</kbd> method for this class, the overridden <kbd>create</kbd> and <kbd>update</kbd> methods define how to create or modify an instance. In fact, these methods must be implemented in our class because they just raise a <kbd>NotImplementedError</kbd> exception in their base declaration in the <kbd>Serializer</kbd> superclass.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>create</kbd> method receives the validated data in the <kbd>validated_data</kbd> argument. The code creates and returns a new <kbd>Game</kbd> instance based on the received validated data.</p>
<p>The <kbd>update</kbd> method receives an existing <kbd>Game</kbd> instance that is being updated and the new validated data in the <kbd>instance</kbd> and <kbd>validated_data</kbd> arguments. The code updates the values for the attributes of the instance with the updated attribute values retrieved from the validated data, calls the save method for the updated <kbd>Game</kbd> instance, and returns the updated and saved instance.</p>
<p>We can launch our default Python interactive shell and make all the Django project modules available before it starts. This way, we can check that the serializer works as expected. In addition, it will help us understand how serialization works in Django.</p>
<p>Run the following command to launch the interactive shell. Make sure you are within the <kbd>games_service</kbd> folder in the Terminal or Command Prompt:</p>
<pre>    <strong>python manage.py shell</strong></pre>
<p>You will notice that a line that says (<kbd>InteractiveConsole</kbd>) is displayed after the usual lines that introduce your default Python interactive shell. Enter the following code in the Python interactive shell to import all the things we will need to test the <kbd>Game</kbd> model and its serializer. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/serializers_test_01.py</kbd> file:</p>
<pre>from datetime import datetime 
from django.utils import timezone 
from django.utils.six import BytesIO 
from rest_framework.renderers import JSONRenderer 
from rest_framework.parsers import JSONParser 
from games.models import Game 
from games.serializers import GameSerializer </pre>
<p>Now enter the following code to create two instances of the <kbd>Game</kbd> model and save them. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/serializers_test_01.py</kbd> file:</p>
<pre>gamedatetime = timezone.make_aware(datetime.now(), timezone.get_current_timezone()) 
game1 = Game(name='PAW Patrol: On A Roll!', release_date=gamedatetime, esrb_rating='E (Everyone)') 
game1.save() 
game2 = Game(name='Spider-Man', release_date=gamedatetime, esrb_rating='T (Teen)') 
game2.save()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>After we execute the previous code, we can check the SQLite database with the previously introduced command-line command or GUI tool to check the contents of the <kbd>games_game</kbd> table. We will notice the table has two rows and the columns have the values we have provided to the different attributes of the <kbd>Game</kbd> instances. However, make sure you run the commands in another Terminal or Command Prompt to avoid leaving the interactive shell that we will continue to use. The following screenshot shows the contents of the <kbd>games_game</kbd> table:</p>
<div><img src="img/da48bd1e-6a9c-4946-b66f-0988c38183f8.png" width="1208" height="121"/></div>
<p>Enter the following commands in the interactive shell to check the values for the identifiers for the saved <kbd>Game</kbd> instances and the value of the <kbd>created_timestamp</kbd> attribute that includes the date and time in which we saved the instance to the database. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/serializers_test_01.py</kbd> file:</p>
<pre>print(game1.id) 
print(game1.name) 
print(game1.created_timestamp) 
print(game2.id) 
print(game2.name) 
print(game2.created_timestamp) </pre>
<p>Now let's write the following code to serialize the first game instance (<kbd>game1</kbd>). The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/serializers_test_01.py</kbd> file:</p>
<pre>game_serializer1 = GameSerializer(game1) 
print(game_serializer1.data) </pre>
<p>The following line shows the generated dictionary, specifically, a <kbd>rest_framework.utils.serializer_helpers.ReturnDict</kbd> instance:</p>
<pre><strong>{'id': 1, 'name': 'PAW Patrol: On A Roll!', 'release_date': '2018-10-24T17:47:30.177610Z', 'esrb_rating': 'E (Everyone)', 'played_once': False, 'played_times': 0}</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now let's serialize the second game instance (<kbd>game2</kbd>). The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/serializers_test_01.py</kbd> file:</p>
<pre>game_serializer2 = GameSerializer(game2) 
print(game_serializer2.data) </pre>
<p>The following line shows the generated dictionary:</p>
<pre><strong>{'id': 2, 'name': 'Spider-Man', 'release_date': '2018-10-24T17:47:30.177610Z', 'esrb_rating': 'T (Teen)', 'played_once': False, 'played_times': 0}</strong>
  </pre>
<p>We can easily render the dictionaries held in the <kbd>data</kbd> attribute into JSON with the help of the <kbd>rest_framework.renderers.JSONRenderer</kbd> class. The following lines create an instance of this class and then call the <kbd>render</kbd> method to render the dictionaries held in the <kbd>data</kbd> attribute into their JSON representation. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/serializers_test_01.py</kbd> file:</p>
<pre>renderer = JSONRenderer() 
rendered_game1 = renderer.render(game_serializer1.data) 
rendered_game2 = renderer.render(game_serializer2.data) 
print(rendered_game1) 
print(rendered_game2) </pre>
<p>The following lines show the output generated from the two calls to the <kbd>render</kbd> method:</p>
<pre>    <strong>b'{"id":1,"name":"PAW Patrol: On A Roll!","release_date":"2018-10-24T17:47:30.177610Z","esrb_rating":"E (Everyone)","played_once":false,"played_times":0}'</strong>
    <strong>b'{"id":2,"name":"Spider-Man","release_date":"2018-10-24T17:47:30.177610Z","esrb_rating":"T (Teen)","played_once":false,"played_times":0}'</strong>
  </pre>
<p>Now we will work in the opposite direction, from serialized data to the population of a <kbd>Game</kbd> instance. The following lines generate a new <kbd>Game</kbd> instance from a JSON string (serialized data); that is, we will write code that deserializes. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/serializers_test_01.py</kbd> file:</p>
<pre>json_string_for_new_game = '{"name":"Tomb Raider Extreme Edition","release_date":"2016-05-18T03:02:00.776594Z","game_category":"3D RPG","played":false}' 
json_bytes_for_new_game = bytes(json_string_for_new_game , encoding="UTF-8") 
stream_for_new_game = BytesIO(json_bytes_for_new_game) 
parser = JSONParser() 
parsed_new_game = parser.parse(stream_for_new_game) 
print(parsed_new_game) </pre>
<p>The first line creates a new string with the JSON that defines a new game (<kbd>json_string_for_new_game</kbd>). Then, the code converts the string to <kbd>bytes</kbd> and saves the results of the conversion in the <kbd>json_bytes_for_new_game</kbd> variable. The <kbd>django.utils.six.BytesIO</kbd> class provides a buffered I/O implementation using an in-memory bytes buffer. The code uses this class to create a stream from the previously generated JSON bytes with the serialized data, <kbd>json_bytes_for_new_game</kbd>, and saves the generated instance in the <kbd>stream_for_new_game</kbd> variable.</p>
<p>We can easily deserialize and parse a stream into the Python models with the help of the <kbd>rest_framework.parsers.JSONParser</kbd> class. The next line creates an instance of this class and then calls the <kbd>parse</kbd> method with <kbd>stream_for_new_game</kbd> as an argument, parses the stream into Python native datatypes, and saves the results in the <kbd>parsed_new_game</kbd> variable.</p>
<p>After executing the previous lines, <kbd>parsed_new_game</kbd> holds a Python dictionary, parsed from the stream. The following lines show the output generated after executing the previous code snippet:</p>
<pre><strong>{'name': 'Red Dead Redemption 2', 'release_date': '2018-10-26T01:01:00.776594Z', 'esrb_rating': 'M (Mature)'}</strong>
  </pre>
<p>The following lines use the <kbd>GameSerializer</kbd> class to generate a fully populated <kbd>Game</kbd> instance named <kbd>new_game</kbd> from the Python dictionary, parsed from the stream. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/serializers_test_01.py</kbd> file:</p>
<pre>new_game_serializer = GameSerializer(data=parsed_new_game) 
if new_game_serializer.is_valid(): 
    new_game = new_game_serializer.save() 
    print(new_game.name) </pre>
<p>First, the code creates an instance of the <kbd>GameSerializer</kbd> class with the Python dictionary that we previously parsed from the stream (<kbd>parsed_new_game</kbd>) passed as the <kbd>data</kbd> keyword argument. Then, the code calls the <kbd>is_valid</kbd> method to determine whether the data is valid or not.</p>
<p class="mce-root"/>
<p>Notice that we must always call <kbd>is_valid</kbd> before we attempt to access the serialized data representation when we pass a <kbd>data</kbd> keyword argument in the creation of a serializer.</p>
<p>If the method returns <kbd>true</kbd>, we can access the serialized representation in the <kbd>data</kbd> attribute, and therefore, the code calls the <kbd>save</kbd> method that inserts the corresponding row in the database and returns a fully populated <kbd>Game</kbd> instance, saved in the <kbd>new_game</kbd> local variable. Then, the code prints one of the attributes from the fully populated <kbd>Game</kbd> instance named <kbd>new_game</kbd>.</p>
<p>As we can see from the previous code, Django REST Framework makes it easy to serialize from objects to JSON and deserialize from JSON to objects, which are core requirements for our RESTful web API, which has to perform CRUD operations.</p>
<p>Enter the following command to leave the shell with the Django project modules that we started to test serialization and deserialization:</p>
<pre><strong>quit()</strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding status codes for the responses</h1>
                
            
            
                
<p>Django REST Framework declares a set of named constants for the different HTTP status codes in the <kbd>status</kbd> module. We will always use these named constants to return HTTP status codes.</p>
<p>It is bad practice to return numbers as status codes. We want our code to be easy to read and understand, and therefore, we will use descriptive HTTP status codes.</p>
<p>For example, in case we have to return a <kbd>404 Not Found</kbd> status code, we will return <kbd>status.HTTP_404_NOT_FOUND</kbd>, instead of just <kbd>404</kbd>. If we have to return a <kbd>201 Created</kbd> status code, we will return <kbd>status.HTTP_201_CREATED</kbd>, instead of just <kbd>201</kbd>.</p>



            

            
        
    </div>



  
<div><h1 class="header-title">Writing API views</h1>
                
            
            
                
<p>Now we will create Django views that will use the previously created <kbd>GameSerializer</kbd> class to return JSON representations for each HTTP request that our API will handle. Open the <kbd>views.py</kbd> file located within the <kbd>games_service/games</kbd> folder. The following lines show the initial code for this file, with just one import statement and a comment that indicates we should create the views:</p>
<pre>from django.shortcuts import render 
 
# Create your views here. </pre>
<p>Replace the existing code with the following lines. The new code creates a <kbd>JSONResponse</kbd> class and declares two functions: <kbd>game_collection</kbd> and <kbd>game_detail</kbd>. We are creating our first version of the API, and we use functions to keep the code as simple as possible. We will work with classes and more complex code in the next examples. The highlighted lines show the expressions that evaluate the value of the <kbd>request.method</kbd> attribute to determine the actions to be performed based on the HTTP verb. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/games-service/games/views.py</kbd> file:</p>
<pre>from django.http import HttpResponse 
from django.views.decorators.csrf import csrf_exempt 
from rest_framework.renderers import JSONRenderer 
from rest_framework.parsers import JSONParser 
from rest_framework import status 
from games.models import Game 
from games.serializers import GameSerializer 
 
 
class JSONResponse(HttpResponse): 
    def __init__(self, data, **kwargs): 
        content = JSONRenderer().render(data) 
        kwargs['content_type'] = 'application/json' 
        super(JSONResponse, self).__init__(content, **kwargs) 
 
 
@csrf_exempt 
def game_collection(request): 
    <strong>if request.method == 'GET':</strong> 
        games = Game.objects.all() 
        games_serializer = GameSerializer(games, many=True) 
        return JSONResponse(games_serializer.data) 
   <strong> elif request.method == 'POST':</strong> 
        game_data = JSONParser().parse(request) 
        game_serializer = GameSerializer(data=game_data) 
        if game_serializer.is_valid(): 
            game_serializer.save() 
            return JSONResponse(game_serializer.data,  
                status=status.HTTP_201_CREATED) 
        return JSONResponse(game_serializer.errors,  
            status=status.HTTP_400_BAD_REQUEST) 
 
 
@csrf_exempt 
def game_detail(request, id): 
    try: 
        game = Game.objects.get(id=id) 
    except Game.DoesNotExist: 
        return HttpResponse(status=status.HTTP_404_NOT_FOUND) 
  <strong>  if request.method == 'GET':</strong> 
        game_serializer = GameSerializer(game) 
        return JSONResponse(game_serializer.data) 
    <strong>elif request.method == 'PUT':</strong> 
        game_data = JSONParser().parse(request) 
        game_serializer = GameSerializer(game,  
            data=game_data) 
        if game_serializer.is_valid(): 
            game_serializer.save() 
            return JSONResponse(game_serializer.data) 
        return JSONResponse(game_serializer.errors,  
            status=status.HTTP_400_BAD_REQUEST) 
<strong>    elif request.method == 'DELETE':</strong> 
        game.delete() 
        return HttpResponse(status=status.HTTP_204_NO_CONTENT) </pre>
<p>The <kbd>JSONResponse</kbd> class is a subclass of the <kbd>django.http.HttpResponse</kbd> class. The superclass represents an HTTP response with a string as content. The <kbd>JSONResponse</kbd> class renders its content into JSON. The class defines just declare the <kbd>__init__</kbd> method that created a <kbd>rest_framework.renderers.JSONRenderer</kbd> instance and calls its <kbd>render</kbd> method to render the received data into JSON and save the returned <kbd>bytestring</kbd> in the <kbd>content</kbd> local variable. Then, the code adds the <kbd>'content_type'</kbd> key to the response header with <kbd>'application/json'</kbd> as its value. Finally, the code calls the initializer for the base class with the JSON <kbd>bytestring</kbd> and the key-value pair added to the header. This way, the class represents a JSON response that we use in the two functions to easily return a JSON response.</p>
<p class="mce-root"/>
<p>The code uses the <kbd>@csrf_exempt</kbd> decorator in the two functions to ensure that the view sets a <strong>CSRF</strong> (short for <strong>Cross-Site Request Forgery</strong>) cookie. We do this to make it simple to test this example that doesn't represent a production-ready web service. We will add security features to our RESTful API later.</p>
<p>When the Django server receives an HTTP request, Django creates an <kbd>HttpRequest</kbd> instance, specifically a <kbd>django.http.HttpRequest</kbd> object. This instance contains metadata about the request, including the HTTP verb. The <kbd>method</kbd> attribute provides a string representing the HTTP verb or method used in the request.</p>
<p>When Django loads the appropriate view that will process the requests, it passes the <kbd>HttpRequest</kbd> instance as the first argument to the view function. The view function has to return an <kbd>HttpResponse</kbd> instance, specifically, a <kbd>django.http.HttpResponse</kbd> instance.</p>
<p>The <kbd>game_collection</kbd> function lists all the games or creates a new game. The function receives an <kbd>HttpRequest</kbd> instance in the <kbd>request</kbd> argument. The function is capable of processing two HTTP verbs: <kbd>GET</kbd> and <kbd>POST</kbd>. The code checks the value of the <kbd>request.method</kbd> attribute to determine the code to be executed based on the HTTP verb. If the HTTP verb is <kbd>GET</kbd>, the <kbd>request.method == 'GET'</kbd> expression will evaluate to <kbd>True</kbd> and the code has to list all the games. The code will retrieve all the <kbd>Game</kbd> objects from the database, use the <kbd>GameSerializer</kbd> to serialize all of them and return a <kbd>JSONResponse</kbd> instance built with the data generated by <kbd>GameSerializer</kbd>. The code creates the <kbd>GameSerializer</kbd> instance with the <kbd>many=True</kbd> argument to specify that multiple instances have to be serialized and not just one. Under the hood, Django uses a <kbd>ListSerializer</kbd> when the <kbd>many</kbd> argument value is set to <kbd>True</kbd>.</p>
<p>If the HTTP verb is <kbd>POST</kbd>, the code has to create a new game based on the JSON data that is included in the HTTP request. First, the code uses a <kbd>JSONParser</kbd> instance and calls its parse method with <kbd>request</kbd> as an argument to parse the game data provided as <kbd>JSON</kbd> data in the request and saves the results in the <kbd>game_data</kbd> local variable. Then, the code creates a <kbd>GameSerializer</kbd> instance with the previously retrieved data and calls the <kbd>is_valid</kbd> method to determine whether the <kbd>Game</kbd> instance is valid or not. If the instance is valid, the code calls the <kbd>save</kbd> method to persist the instance in the database and returns a <kbd>JSONResponse</kbd> with the saved data in its body and a status equal to <kbd>status.HTTP_201_CREATED</kbd>, that is, <kbd>201 Created</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>game_detail</kbd> function retrieves, updates, or deletes an existing game. The function receives an <kbd>HttpRequest</kbd> instance in the <kbd>request</kbd> argument and the ID for the game to be retrieved, updated, or deleted in the <kbd>id</kbd> argument. The function is capable of processing three HTTP verbs: <kbd>GET</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd>. The code checks the value of the <kbd>request.method</kbd> attribute to determine the code to be executed based on the HTTP verb. Irrespective of the HTTP verb, the function calls the <kbd>Game.objects.get</kbd> method with the received <kbd>id</kbd> as the <kbd>id</kbd> argument to retrieve a <kbd>Game</kbd> instance from the database based on the specified id, and saves it in the <kbd>game</kbd> local variable. If a game with the specified id doesn't exist in the database, the code returns an <kbd>HttpResponse</kbd> with its status equal to <kbd>status.HTTP_404_NOT_FOUND</kbd>, that is, <kbd>404 Not Found</kbd>.</p>
<p>If the HTTP verb is <kbd>GET</kbd>, the code creates a <kbd>GameSerializer</kbd> instance with <kbd>game</kbd> as an argument and returns the data for the serialized game in a <kbd>JSONResponse</kbd> that will include the default <kbd>200 OK</kbd> status. The code returns the retrieved game serialized as JSON.</p>
<p>If the HTTP verb is <kbd>PUT</kbd>, the code has to create a new game based on the JSON data that is included in the HTTP request, and use it to replace an existing game. First, the code uses a <kbd>JSONParser</kbd> instance and calls its parse method with <kbd>request</kbd> as an argument to parse the game data provided as <kbd>JSON</kbd> data in the request and saves the results in the <kbd>game_data</kbd> local variable. Then, the code creates a <kbd>GameSerializer</kbd> instance with the <kbd>Game</kbd> instance previously retrieved from the database, <kbd>game</kbd>, and the retrieved data that will replace the existing data, <kbd>game_data</kbd>. Then, the code calls the <kbd>is_valid</kbd> method to determine whether the <kbd>Game</kbd> instance is valid or not. If the instance is valid, the code calls the <kbd>save</kbd> method to persist the instance with the replaced values in the database and returns a <kbd>JSONResponse</kbd> with the saved data in its body and the default <kbd>200 OK</kbd> status. If the parsed data doesn't generate a valid <kbd>Game</kbd> instance, the code returns a <kbd>JSONResponse</kbd> with a status equal to <kbd>status.HTTP_400_BAD_REQUEST</kbd>, that is, <kbd>400 Bad Request</kbd>.</p>
<p>If the HTTP verb is <kbd>DELETE</kbd>, the code calls the <kbd>delete</kbd> method for the <kbd>Game</kbd> instance previously retrieved from the database (<kbd>game</kbd>). The call to the <kbd>delete</kbd> method erases the underlying row in the <kbd>games_game</kbd> table, and therefore, the game won't be available anymore. Then, the code returns a <kbd>JSONResponse</kbd> with a status equal to <kbd>status.HTTP_204_NO_CONTENT</kbd> that is, <kbd>204 No Content</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now we have to create a new Python file named <kbd>urls.py</kbd> in the <kbd>games_service/games</kbd> folder, specifically, the <kbd>games_service/games/urls.py</kbd> file. The following lines show the code for this file that defines the URL patterns that specifies the regular expressions that have to be matched in the request to run a specific function defined in the <kbd>views.py</kbd> file. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/games-service/games/urls.py</kbd> file:</p>
<pre>from django.conf.urls import url 
from games import views 
 
urlpatterns = [ 
    url(r'^games/$', views.game_collection), 
    url(r'^games/(?P&lt;id&gt;[0-9]+)/$', views.game_detail), 
] </pre>
<p>The <kbd>urlpatterns</kbd> list makes it possible to route URLs to views. The code calls the <kbd>django.conf.urls.url</kbd> function with the regular expression that has to be matched, and the view function defined in the views module as arguments to create a <kbd>RegexURLPattern</kbd> instance for each entry in the <kbd>urlpatterns</kbd> list.</p>
<p>Now we have to replace the code in the <kbd>urls.py</kbd> that Django built automatically in the <kbd>games_service</kbd> folder, specifically, the <kbd>games_service/urls.py</kbd> file. Don't confuse this file with the previously created <kbd>urls.py</kbd> file that is saved in another folder. The <kbd>games_service/urls.py</kbd> file defines the root URL configurations, and therefore, we must include the URL patterns declared in the previously coded <kbd>games_service/games/urls.py</kbd> file. The following lines show the new code for the <kbd>games_service/urls.py</kbd> file. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/games-service/urls.py</kbd> file:</p>
<pre>from django.conf.urls import url, include 
 
urlpatterns = [ 
    url(r'^', include('games.urls')), 
] </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Making HTTP requests to the Django API</h1>
                
            
            
                
<p>Now we can launch Django's development server to compose and send HTTP requests to our unsecure web API (we will definitely add security later). Execute the following command:</p>
<pre>    <strong>python manage.py runserver</strong></pre>
<p>The following lines show the output after we execute the previous command. The development server is listening at port <kbd>8000</kbd>.</p>
<pre>    <strong>Performing system checks...</strong>
    
    <strong>System check identified no issues (0 silenced).</strong>
    <strong>October 24, 2018 - 19:58:03</strong>
    <strong>Django version 2.1.2, using settings 'games_service.settings'</strong>
    <strong>Starting development server at http://127.0.0.1:8000/</strong>
    <strong>Quit the server with CONTROL-C.</strong> </pre>
<p>With the previous command, we will start Django development server and we will only be able to access it in our development computer. ...</p></div>



  
<div><h1 class="header-title">Working with command-line tools - curl and httpie</h1>
                
            
            
                
<p>We will start composing and sending HTTP requests with the <kbd>curl</kbd> and HTTPie command-line tools we introduced in <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservice with Flask 1.0.2</em>, in the section named <em>Working with command-line tools - curl and httpie</em>. Make sure you read this section before executing the next examples.</p>
<p>Whenever we compose HTTP requests with the command line, we will use two versions of the same command: the first one with HTTPie and the second one with <kbd>curl</kbd>. This way, you will be able to use the most convenient for you.</p>
<p>Make sure you leave the Django development server running. Don't close the Terminal or Command Prompt that is running this development server. Open a new Terminal in macOS or Linux, or a Command Prompt in Windows, and run the following command. We will compose and send an HTTP request to create a new notification. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd01.txt</kbd> file:</p>
<pre>    <strong>http ":8000/games/"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd02.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:8000/games/"</strong></pre>
<p>It is very important that you enter the ending slash (<kbd>/</kbd>) when specified because <kbd>/service/notifications</kbd> won't match any of the configured URL routes. Thus, we must enter <kbd>/service/notifications/</kbd>, including the ending slash (<kbd>/</kbd>).</p>
<p>The previous command will compose and send the following HTTP request: <kbd>GET http://localhost:8000/games/</kbd>. The request is the simplest case in our RESTful API because it will match and run the <kbd>views.game_collection</kbd> function, that is, the <kbd>game_collection</kbd> function declared within the <kbd>game_service/games/views.py</kbd> file. The function only receives <kbd>request</kbd> as a parameter because the URL pattern doesn't include any parameters. As the HTTP verb for the request is <kbd>GET</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'GET'</kbd>, and therefore, the function will execute the code that retrieves all the <kbd>Game</kbd> objects and generate a JSON response with all of these <kbd>Game</kbd> objects serialized.</p>
<p class="mce-root"/>
<p>The following lines show an example response for the HTTP request, with three <kbd>Game</kbd> objects in the JSON response:</p>
<pre>    <strong>HTTP/1.1 200 OK</strong>
    <strong>Content-Length: 438</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Wed, 24 Oct 2018 20:25:45 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.7.1</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>[</strong>
    <strong>    {</strong>
    <strong>        "esrb_rating": "E (Everyone)",</strong>
    <strong>        "id": 1,</strong>
    <strong>        "name": "PAW Patrol: On A Roll!",</strong>
    <strong>        "played_once": false,</strong>
    <strong>        "played_times": 0,</strong>
    <strong>        "release_date": "2018-10-24T17:47:30.177610Z"</strong>
    <strong>    },</strong>
    <strong>    {</strong>
    <strong>        "esrb_rating": "M (Mature)",</strong>
    <strong>        "id": 3,</strong>
    <strong>        "name": "Red Dead Redemption 2",</strong>
    <strong>        "played_once": false,</strong>
    <strong>        "played_times": 0,</strong>
    <strong>        "release_date": "2018-10-26T01:01:00.776594Z"</strong>
    <strong>    },</strong>
    <strong>    {</strong>
    <strong>        "esrb_rating": "T (Teen)",</strong>
    <strong>        "id": 2,</strong>
    <strong>        "name": "Spider-Man",</strong>
    <strong>        "played_once": false,</strong>
    <strong>        "played_times": 0,</strong>
    <strong>        "release_date": "2018-10-24T17:47:30.177610Z"</strong>
    <strong>    }</strong>
    <strong>]</strong>
  </pre>
<p>After we run a request, we will see the following line in the window that is running the Django development server. The output indicates that the server received an HTTP request with the <kbd>GET</kbd> verb and <kbd>/games/</kbd> as the URI. The server processed the HTTP requests, the returned status code <kbd>200</kbd> and the response length was equal to <kbd>438</kbd> characters. The response length can be different because the value for <kbd>id</kbd> assigned to each game will have an incidence in the response length. The first number after <kbd>HTTP/1.1."</kbd> indicates the returned status code (<kbd>200</kbd>) and the second number the response length (<kbd>438</kbd>):</p>
<pre>    <strong>[24/Oct/2018 20:25:45] "GET /games/ HTTP/1.1" 200 438    </strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following screenshot shows two Terminal windows side by side on macOS. The Terminal window at the left-hand side is running the Django development server and displays the received and processed HTTP requests. The Terminal window at the right-hand side is running <kbd>http</kbd> commands to generate the HTTP requests. It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6ffae235-3361-45e1-bb29-66247cdef340.png" width="1219" height="747"/></p>
<p>Now we will select one of the games from the previous list and we will compose an HTTP request to retrieve just the chosen game. For example, in the previous list, the first game has an <kbd>id</kbd> value equal to <kbd>3</kbd>. Run the following command to retrieve this game. Use the <kbd>id</kbd> value you have retrieved in the previous command for the first game, as the <kbd>id</kbd> number might be different. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd03.txt</kbd> file:</p>
<pre>    <strong>http ":8000/games/3/"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd04.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:8000/games/3/"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/games/3/</kbd>. The request has a number after <kbd>/games/</kbd>, and therefore, it will match <kbd>'^games/(?P&lt;id&gt;[0-9]+)/$'</kbd> and run the <kbd>views.game_detail</kbd> function, that is, the <kbd>game_detail</kbd> function declared within the <kbd>games_service/games/views.py</kbd> file. The function receives <kbd>request</kbd> and <kbd>id</kbd> as parameters because the URL pattern passes the number specified after <kbd>/games/</kbd> in the <kbd>id</kbd> parameter. As the HTTP verb for the request is <kbd>GET</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'GET'</kbd>, and therefore, the function will execute the code that retrieves the <kbd>Game</kbd> object whose primary key matches the <kbd>id</kbd> value received as an argument and, if found, generates a JSON response with this <kbd>Game</kbd> object serialized. The following lines show an example response for the HTTP request, with the <kbd>Game</kbd> object that matches the <kbd>id</kbd> value in the JSON response:</p>
<pre>    <strong>HTTP/1.1 200 OK</strong>
    <strong>Content-Length: 148</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Wed, 24 Oct 2018 22:04:50 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.7.1</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "esrb_rating": "M (Mature)",</strong>
    <strong>    "id": 3,</strong>
    <strong>    "name": "Red Dead Redemption 2",</strong>
    <strong>    "played_once": false,</strong>
    <strong>    "played_times": 0,</strong>
    <strong>    "release_date": "2018-10-26T01:01:00.776594Z"</strong>
    <strong>}</strong>
  </pre>
<p>Now we will compose and send an HTTP request to retrieve a game that doesn't exist. For example, in the previous list, there is no game with an <kbd>id</kbd> value equal to <kbd>888</kbd>. Run the following command to try to retrieve this game. Make sure you use an <kbd>id</kbd> value that doesn't exist. We must make sure that the utilities display the headers as part of the response because the response won't have a body. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd05.txt</kbd> file:</p>
<pre>    <strong>http ":8000/games/888/"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd06.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:8000/games/888/"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/games/888/</kbd>. The request is the same as the previous one we have analyzed, with a different number for the <kbd>id</kbd> parameter. The server will run the <kbd>views.game_detail</kbd> function, that is, the <kbd>game_detail</kbd> function declared within the <kbd>games_service/games/views.py</kbd> file. The function will execute the code that retrieves the <kbd>Game</kbd> object whose primary key matches the <kbd>id</kbd> value received as an argument and a <kbd>Game.DoesNotExist</kbd> exception will be thrown and captured because there is no game with the specified <kbd>id</kbd> value. Thus, the code will return an HTTP <kbd>404 Not Found</kbd> status code. The following lines show an example header response for the HTTP request:</p>
<pre>    <strong>HTTP/1.1 404 Not Found</strong>
    <strong>Content-Length: 0</strong>
    <strong>Content-Type: text/html; charset=utf-8</strong>
    <strong>Date: Wed, 24 Oct 2018 22:12:02 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.7.1</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
  </pre>
<p>Now run the following command to compose and send an HTTP <kbd>POST</kbd> request to create a new game. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd07.txt</kbd> file:</p>
<pre><strong>http POST ":8000/games/" name='Fortnite' esrb_rating='T (Teen)' release_date='2017-05-18T03:02:00.776594Z'</strong>
  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. It is very important to use the <kbd>-H "Content-Type: application/json"</kbd> option to indicate <kbd>curl</kbd> to send the data specified after the <kbd>-d</kbd> option as <kbd>application/json</kbd> instead of the default <kbd>application/x-www-form-urlencoded</kbd>. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd08.txt</kbd> file:</p>
<pre><strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Fortnite", "esrb_rating":"T (Teen)", "release_date": "2017-05-18T03:02:00.776594Z"}' "localhost:8000/games/"</strong>
  </pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>POST http://localhost:8000/games/</kbd> with the following JSON key-value pairs:</p>
<pre>{ 
    "name": "Fortnite",  
    "esrb_rating": "T (Teen)",  
    "release_date": "2017-05-18T03:02:00.776594Z" 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The request specifies <kbd>/games/</kbd>, and therefore, it will match <kbd>'^games/$'</kbd> and run the <kbd>views.game_collection</kbd> function, that is, the <kbd>game_collection</kbd> function declared within the <kbd>games_service/ames/views.py</kbd> file. The function just receives <kbd>request</kbd> as a parameter because the URL pattern doesn't include any parameters. As the HTTP verb for the request is <kbd>POST</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'POST'</kbd>, and therefore, the function executes the code that parses the JSON data received in the request, creates a new <kbd>Game</kbd> and, if the data is valid, it saves the new <kbd>Game</kbd> instance. If the new <kbd>Game</kbd> instance was successfully persisted in the database, the function returns an HTTP <kbd>201 Created</kbd> status code and the recently persisted <kbd>Game</kbd> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <kbd>Game</kbd> object in the JSON response:</p>
<pre>    <strong>HTTP/1.1 201 Created</strong>
    <strong>Content-Length: 133</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Wed, 24 Oct 2018 22:18:36 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "esrb_rating": "T (Teen)",</strong>
    <strong>    "id": 4,</strong>
    <strong>    "name": "Fortnite",</strong>
    <strong>    "played_once": false,</strong>
    <strong>    "played_times": 0,</strong>
    <strong>    "release_date": "2017-05-18T03:02:00.776594Z"</strong>
    <strong>}</strong>
  </pre>
<p>Now we run the following command to compose and send an HTTP <kbd>PUT</kbd> request to update an existing game, specifically, to replace the previously added game with a new one. We have to check the value assigned to <kbd>id</kbd> in the previous response and replace <kbd>4</kbd> in the command with the returned value. For example, if the value for <kbd>id</kbd> was <kbd>8</kbd>, you should use <kbd>games/8/</kbd> instead of <kbd>games/4/</kbd>. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd09.txt</kbd> file:</p>
<pre> <strong>http PUT ":8000/games/4/" name='Fortnite Battle Royale' esrb_rating='T (Teen)' played_once=true played_times=3 release_date='2017-05-20T03:02:00.776594Z'</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following is the equivalent <kbd>curl</kbd> command. As happened with the previous <kbd>curl</kbd> example, it is very important to use the <kbd>-H "Content-Type: application/json"</kbd> option to indicate <kbd>curl</kbd> to send the data specified after the <kbd>-d</kbd> option as <kbd>application/json</kbd> instead of the default <kbd>application/x-www-form-urlencoded</kbd>. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd10.txt</kbd> file:</p>
<pre><strong>curl -iX PUT -H "Content-Type: application/json" -d '{"name":"Fortnite Battle Royale", "esrb_rating":"T (Teen)", "played_once": "true", "played_times": 3, "release_date": "2017-05-20T03:02:00.776594Z"}' "localhost:8000/games/4/"</strong>
  </pre>
<p>The previous commands will compose and send the HTTP request <kbd>PUT http://localhost:8000/games/15/</kbd> with the following JSON key-value pairs:</p>
<pre>{  
    "name": "Fortnite Battle Royale",  
    "esrb_rating": "T (Teen)",  
    "played_once": true,<br/>     "played_times": 3, 
    "release_date": "2017-05-20T03:02:00.776594Z" 
} </pre>
<p>The request has a number after <kbd>/games/</kbd>, and therefore, it will match <kbd>'^games/(?P&lt;id&gt;[0-9]+)/$'</kbd> and run the <kbd>views.game_detail</kbd> function, that is, the <kbd>game_detail</kbd> function declared within the <kbd>games_service/games/views.py</kbd> file. The function receives <kbd>request</kbd> and <kbd>id</kbd> as parameters because the URL pattern passes the number specified after <kbd>/games/</kbd> in the <kbd>id</kbd> parameter. As the HTTP verb for the request is <kbd>PUT</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'PUT'</kbd>, and therefore, the function executes the code that parses the JSON data received in the request, creates a <kbd>Game</kbd> instance from this data and updates all the fields for the existing game in the database. If the game was successfully updated in the database, the function returns an HTTP <kbd>200 OK</kbd> status code and the recently updated <kbd>Game</kbd> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the updated <kbd>Game</kbd> object in the JSON response:</p>
<pre>    <strong>HTTP/1.1 200 OK</strong>
    <strong>Content-Length: 146</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Wed, 24 Oct 2018 22:27:36 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "esrb_rating": "T (Teen)",</strong>
    <strong>    "id": 4,</strong>
    <strong>    "name": "Fortnite Battle Royale",</strong>
    <strong>    "played_once": true,</strong>
    <strong>    "played_times": 3,</strong>
    <strong>    "release_date": "2017-05-20T03:02:00.776594Z"</strong>
    <strong>}</strong>
  </pre>
<p>In order to successfully process an HTTP <kbd>PUT</kbd> request that updates an existing game with a new one, we must provide values for all the required fields. We will compose and send an HTTP request to try to update an existing game, and we will fail to do so because we will just provide a value for the name. As happened in the previous request, we will use the value assigned to <kbd>id</kbd> in the last game we added. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd11.txt</kbd> file:</p>
<pre>    <strong>http PUT ":8000/games/4/" name='Fortnite Forever'</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd12.txt</kbd> file:</p>
<pre>  <strong>curl -iX PUT -H "Content-Type: application/json" -d '{"name":"Fortnite Forever"}' "localhost:8000/games/4/"</strong>
  </pre>
<p>The previous commands will compose and send the HTTP request <kbd>PUT http://localhost:8000/games/15/</kbd> with the following JSON key-value pair:</p>
<pre>{  
    "name": "Fortnite Forever",  
} </pre>
<p>The request will execute the same code we explained for the previous request. Because we didn't provide all the required values for a <kbd>Game</kbd> instance, the <kbd>game_serializer.is_valid()</kbd> method will return <kbd>False</kbd> and the function will return an HTTP <kbd>400 Bad Request</kbd> status code and the details generated in the <kbd>game_serializer.errors</kbd> attribute are serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the required fields that didn't include values in our request listed in the JSON response. The list uses the field name as a key and the error message as a value:</p>
<pre>    <strong>HTTP/1.1 400 Bad Request</strong>
    <strong>Content-Length: 86</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Wed, 24 Oct 2018 22:33:37 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "esrb_rating": [</strong>
    <strong>        "This field is required."</strong>
    <strong>    ],</strong>
    <strong>    "release_date": [</strong>
    <strong>        "This field is required."</strong>
    <strong>    ]</strong>
    <strong>}</strong>
  </pre>
<p>When we want our API to be able to update a single field for an existing resource, in this case, an existing game, we should provide an implementation for the <kbd>PATCH</kbd> method. The <kbd>PUT</kbd> method is meant to replace an entire resource and the <kbd>PATCH</kbd> method is meant to apply a delta to an existing resource. We can write code in the handler for the <kbd>PUT</kbd> method to apply a delta to an existing resource, but it is a better practice to use the <kbd>PATCH</kbd> method for this specific task. We will work with the <kbd>PATCH</kbd> method later when we code an improved version of our API.</p>
<p>Now run the following command to compose and send an HTTP request to delete an existing game, specifically, the last game we added and updated. As happened in our last HTTP requests, we have to check the value assigned to <kbd>id</kbd> in the previous response and replace <kbd>4</kbd> in the command with the returned value. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd13.txt</kbd> file:</p>
<pre>    <strong>http DELETE ":8000/games/4/"</strong>  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_05_01</kbd> folder, in the <kbd>Django01/cmd/cmd14.txt</kbd> file:</p>
<pre>    <strong>curl -iX DELETE "localhost:8000/games/4/"</strong>  </pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>DELETE http://localhost:8000/games/4/</kbd>. The request has a number after <kbd>/games/</kbd>, and therefore, it will match <kbd>'^games/(?P&lt;id&gt;[0-9]+)/$'</kbd> and run the <kbd>views.game_detail</kbd> function, that is, the <kbd>game_detail</kbd> function declared within the <kbd>games_service/views.py</kbd> file. The function receives <kbd>request</kbd> and <kbd>id</kbd> as parameters because the URL pattern passes the number specified after <kbd>/games/</kbd> in the <kbd>id</kbd> parameter. As the HTTP verb for the request is <kbd>DELETE</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'DELETE'</kbd>, and therefore, the function will execute the code that parses the JSON data received in the request, creates a <kbd>Game</kbd> instance from this data and deletes the existing game in the database. If the game was successfully deleted in the database, the function returns an HTTP <kbd>204 No Content</kbd> status code.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following lines show an example response for the HTTP request after successfully deleting an existing game:</p>
<pre>    <strong>HTTP/1.1 204 No Content</strong>
    <strong>Content-Length: 0</strong>
    <strong>Content-Type: text/html; charset=utf-8</strong>
    <strong>Date: Wed, 24 Oct 2018 22:39:15 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with GUI tools - Postman and others</h1>
                
            
            
                
<p>So far, we have been working with two Terminal-based or command-line tools to compose and send HTTP requests to our Django development server: cURL and HTTPie. Now we will work with Postman, one of the GUI tools we used when composing and sending HTTP requests to the Flask development server on <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>. If you skipped this chapter, make sure you check the installation instructions in the section named <em>Working with GUI tools - Postman and others</em> in that chapter.</p>
<p>Once you launch Postman, make sure you close the modal dialog box that provides shortcuts to common tasks. Select GET Request in the + new drop-down menu at the upper-left corner ...</p></div>



  
<div><h1 class="header-title">Test your knowledge</h1>
                
            
            
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>Which of the following commands run the script to create a new Django app named <kbd>recipes</kbd>:
<ol>
<li><kbd>python django.py startapp recipes</kbd></li>
<li><kbd>python manage.py startapp recipes</kbd></li>
<li><kbd>python starapp.py recipes</kbd></li>
</ol>
</li>
</ol>
<ol start="2">
<li>Which of the following strings must be added to the <kbd>INSTALLED_APPS</kbd> variable to add Django REST Framework in the Django application:
<ol>
<li><kbd>'rest-framework'</kbd></li>
<li><kbd>'django-rest-framework'</kbd></li>
<li><kbd>'rest_framework'</kbd></li>
</ol>
</li>
</ol>
<ol start="3">
<li>Django's ORM:
<ol>
<li>Is integrated with Django</li>
<li>Has to be configured as an optional component in Django</li>
<li>Has to be installed after configuring SQLAlchemy</li>
</ol>
</li>
</ol>
<ol start="4">
<li>In Django REST Framework, serializers are:
<ol>
<li>Mediators between the view functions and Python primitives</li>
<li>Mediators between the URLs and view functions</li>
<li>Mediators between the model instances and Python primitives</li>
</ol>
</li>
</ol>
<ol start="5">
<li>The <kbd>urlpatterns</kbd> list declared in the <kbd>urls.py</kbd> file makes it possible to:
<ol>
<li>Route URLs to models</li>
<li>Route URLs to Python primitives</li>
<li>Route URLs to views</li>
</ol>
</li>
</ol>
<ol start="6">
<li>In Django REST Framework, parsers and renderers handle as mediators between:
<ol>
<li>Model instances and Python primitives</li>
<li>Python primitives and HTTP requests and responses</li>
<li>URLs and view functions</li>
</ol>
</li>
</ol>
<p class="mce-root"/>
<ol start="7">
<li>If we want to create a simple <kbd>Game</kbd> model to represent and persist games in Django REST Framework, we can create:
<ol>
<li>A <kbd>Game</kbd> class as a subclass of the <kbd>django.db.models.Model</kbd> superclass</li>
<li>A <kbd>Game</kbd> class as a subclass of the <kbd>djangorestframework.models.Model</kbd> superclass</li>
<li>A <kbd>Game</kbd> function in the <kbd>restframeworkmodels.py</kbd> file</li>
</ol>
</li>
</ol>
<p> </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we designed a RESTful API to interact with a simple SQLite database and perform CRUD operations with games. We defined the requirements for our API and we understood the tasks performed by each HTTP method. We set up a virtual environment with Django and Django REST Framework.</p>
<p>We created a model to represent and persist games and we executed migrations in Django. We learned to manage serialization and serialization of game instances into JSON representations with Django REST Framework. We wrote API views to process the different HTTP requests and we configured the URL patterns list to route URLs to views.</p>
<p>Finally, we started the Django development server and we used command-line tools to compose and send HTTP requests ...</p></div>



  </body></html>