<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using Frames, Labels, and Text Fields</h1>
                </header>
            
            <article>
                
<p class="mce-root">The elements that will be covered in this chapter are the graphical components used to organize the application in the first stage of development. These components provide the ability to implement some windows to visualize the application, labels with text to inform the user about the application's features, and varieties of text fields to input the text and operate with text. We will start by describing the methods, and we will then implement them in the application at the end of the chapter. No modern application can do without these components. The user may want to have a perfect visualization, explain what things are or what they need to do, or maybe an event occurs. Text fields have the functionality required to work with various texts, such as short texts, long descriptions, visualizing text, loading text from files, copying/pasting text, other additional operations with <span>text</span>, and saving text to files from text fields. All of these are available with various different options.</p>
<p class="mce-root">In this chapter, we'll cover the following topics:</p>
<ul>
<li>Frames</li>
<li>Labels</li>
<li>Line edit fields</li>
<li>Text edit fields</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QFrame</h1>
                </header>
            
            <article>
                
<p>This class from the <kbd>QtWidgets</kbd> module is the base class for widgets that can have frames. <kbd>QFrame</kbd> inherits the <kbd>QWidget</kbd> class. Frames can be used to combine some elements by similarity and/or used as parents of the components inside the frame. The second assertion is useful when you need to hide some elements, and, instead of hiding each of them individually, you can <span>just </span>hide the parent frame. The syntax to create the frame is as follows:</p>
<pre><strong>frame</strong> = QtWidgets.QFrame()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions of QFrame</h1>
                </header>
            
            <article>
                
<p><kbd>QFrame</kbd> extends the <kbd>QWidget</kbd> class and provides the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p>These functions set the parameters/properties of the frame, such as style and width:</p>
<p><kbd>frame.setFrameRect(QtCore.QRect)</kbd>: This sets the rectangle that the frame is drawn in.</p>
<p><kbd>frame.setFrameShadow(QtWidgets.QFrame.Shadow)</kbd>: This sets the shadow for this frame.</p>
<p><kbd>frame.setFrameShape(QtWidgets.QFrame.Shape)</kbd>: This sets the shape of this frame.</p>
<p><kbd>frame.setFrameStyle(int)</kbd>: This sets the frame's style. The available values are as follows:</p>
<ul>
<li><kbd>0</kbd>: No frame</li>
<li><kbd>1</kbd>: Box</li>
<li><kbd>2</kbd>: Panel</li>
<li><kbd>3</kbd>: Win panel</li>
<li><kbd>4</kbd>/<kbd>5</kbd>: <kbd>HLine</kbd>/<kbd>VLine</kbd> and styled panel</li>
</ul>
<p><kbd>frame.setLineWidth(int)</kbd>: This sets the line width for this frame.</p>
<p><kbd>frame.setMidLineWidth(int)</kbd>: This sets the middle line width for this frame.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p>These functions return the current values of the frame or change the functionality:</p>
<p><kbd>frame.frameRect()</kbd>: This returns the rectangle of the <kbd>QtCore.QRect</kbd> type where the frame is drawn.</p>
<p><kbd>frame.frameShadow()</kbd>: This returns <span>the frame shadow value from the frame style </span>of the <kbd>QtWidgets.QFrame.Shadow</kbd> type.</p>
<p><kbd>frame.frameShape()</kbd>: This returns <span>the frame shape value from the frame style </span>of the <kbd>QtWidgets.QFrame.Shape</kbd> type.</p>
<p><kbd>frame.frameStyle()</kbd>: This returns the<span> frame style </span>as an integer value.</p>
<p><kbd>frame.frameWidth()</kbd>: This returns the width as an integer value of the frame that is drawn.</p>
<p><kbd>frame.initStyleOption(QtWidgets.QStyleOptionFrame)</kbd>: This initializes style options with the values from the parameter.</p>
<p><kbd>frame.lineWidth()</kbd>: This returns the line width of the frame as an integer value.</p>
<p><kbd>frame.midLineWidth()</kbd>: This returns the width as an integer of the middle line of this frame.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p class="mce-root">These functions relate to events, such as event handlers:</p>
<p><kbd>frame.changeEvent(QtCore.QEvent)</kbd>: This handles state changes of the frame.</p>
<p><kbd>frame.event(QtCore.QEvent)</kbd>: This receives events sent to the frame object and should return <kbd>true</kbd> if the event is recognized and processed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QFrame example</h1>
                </header>
            
            <article>
                
<p>Let's create simple frames in the application. Put two frames in the <kbd>Documents</kbd> tab of the main window by adding the following lines to the <kbd>u_style.py</kbd> file:</p>
<ol>
<li>Add the <kbd>UFrame</kbd> class that inherits <kbd>QtWidgets.QFrame</kbd> to the <kbd>u_style.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UFrame(QtWidgets.QFrame):<br/><br/>    def __init__(self, parent=None):<br/>        super(UFrame, self).__init__(parent)<br/>        self.setStyleSheet("background-color: %s;" % (color[2],))<br/>...</pre>
<p style="padding-left: 60px">In this class, we use the <kbd>setStyleSheet()</kbd> method to set the background color of the frame. Now, we need to add some lines to the <kbd>u_app.py</kbd><span> file.</span></p>
<ol start="2">
<li>Add the new imports to the import section of the <kbd>u_app.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_style import UWid, UFrame<br/>...</pre>
<p style="padding-left: 60px">When we use some components i<span>n the future,</span> we<span> need to add the created classes of the</span> <kbd>u_style.py</kbd> <span>file to the import section of the main application file</span>. </p>
<ol start="3">
<li>Now, add the frames and layout for them <span>in the </span><kbd>UApp</kbd><span> class in</span> the <kbd>u_app.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.frame1 = UFrame(self.twid3)<br/>        self.frame1.setLineWidth(3)<br/>        self.frame1.setFrameStyle(6)<br/>        self.frame2 = UFrame(self.twid3)<br/>        self.frame2.setLineWidth(3)<br/>        self.frame2.setFrameStyle(0)<br/>        self.lay1 = QtWidgets.QGridLayout()<br/>        self.lay1.addWidget(self.frame1, 0, 0, 1, 1)<br/>        self.lay1.addWidget(self.frame2, 0, 1, 1, 1)<br/>        self.twid3.setLayout(self.lay1)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Two frames have been created and arranged with a grid layout. Now we can see two different frames inside the <kbd>Documents</kbd> tab of the main application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/71e6fb28-b09e-4f1a-b94f-184bd0791119.png"/></p>
<p><span>Now, let's move on to the <kbd>QLabel</kbd> class.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLabel</h1>
                </header>
            
            <article>
                
<p>The label is a widget that provides a text or image display in the GUI application. <strong><kbd>QLabel</kbd></strong> inherits the <kbd>QFrame</kbd> class. Labels demonstrate or visualize some information in the GUI app. A<span>n image or a movie, or information for the user as text can be displayed o</span>n a label. The syntax to create a label in the application's code is as follows:</p>
<pre><strong>label</strong> = QtWidgets.QLabel()</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions of the QLabel</h1>
                </header>
            
            <article>
                
<p><kbd>QLabel</kbd> extends the <kbd>QWidget</kbd> and <kbd>QFrame</kbd> classes and provides the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p>These functions set the parameters/properties of the label, such as text and alignment:</p>
<p><kbd>label.setAlignment(QtCore.Qt.Alignment)</kbd>: This sets the alignment of the contents in the label.</p>
<p><kbd>label.setBuddy(QtWidgets.QWidget)</kbd>: This sets the label's buddy as specified in the parameter. The buddy mechanism is when the user presses the label's shortcut key, the keyboard focus will be transferred to the label’s buddy widget.</p>
<p><kbd>label.setIndent(int)</kbd>: This sets the label's text indent in pixels.</p>
<p><kbd>label.setMargin(int)</kbd>: This sets the distance between the innermost pixel of the frame and the outermost pixel of the contents of the label.</p>
<p><kbd>label.setMovie(QtGui.QMovie)</kbd>: This sets the movie that will be displayed on this label.</p>
<p><kbd>label.setNum(float<strong>)</strong></kbd>: This sets a textual representation of float numbers.</p>
<p><kbd>label.setNum(int)</kbd>: This sets a textual representation of integer numbers.</p>
<p><kbd>label.setOpenExternalLinks(bool)</kbd>: If this is set to <kbd>True</kbd>, the label will open external links automatically.</p>
<p><kbd>label.setPicture(QtGui.QPicture)</kbd>: This sets the picture that will be displayed on the label.</p>
<p><kbd>label.setPixmap(QtGui.QPixmap)</kbd>: This sets the label's pixmap.</p>
<p><kbd>label.setScaledContents(bool)</kbd>: If this is set to <kbd>True</kbd>, this label will scale the contents to fill all the available space.</p>
<p><kbd>label.setSelection(start, length)</kbd>: This sets the start position of the text (the first parameter, an integer) and the length (the second parameter, also an integer).</p>
<p><kbd>label.setText(str)</kbd>: This sets text for this label in the Unicode string type.</p>
<p><kbd>label.setTextFormat(QtCore.Qt.TextFormat)</kbd>: This sets the label's text format according to the specified parameter.</p>
<p><kbd>label.setTextInteractionFlags(QtCore.Qt.TextInteractionFlags)</kbd>: This sets how the label will interact with user input if it displays text.</p>
<p><kbd>label.setWordWrap(bool)</kbd>: If this is set to <kbd>True</kbd>, the text will be wrapped to the width of the label.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">has</h1>
                </header>
            
            <article>
                
<p class="mce-root">The following are the functions that return a Boolean value (<kbd>bool</kbd>) related to the label states:</p>
<p><kbd>label.hasScaledContents()</kbd>: This returns <kbd>True</kbd> if the label allows us to scale the contents to fill all the available space.</p>
<p><kbd>label.hasSelectedText()</kbd>: This returns <kbd>True</kbd> if some or all of the label's text has been selected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p>These are functions that are related to the returns of the current values of the label or changes of the functionality:</p>
<p><kbd>label.alignment()</kbd>: This returns the alignment of the <kbd>QtCore.Qt.Alignment</kbd> type for the elements in the label.</p>
<p><kbd>label.buddy()</kbd>: This returns the label's buddy of the <kbd>QtWidgets.QWidget</kbd> type.</p>
<p><kbd>label.clear()</kbd>: This clears the content of the label.</p>
<p><kbd>label.focusNextPrevChild(bool)</kbd>: This returns <kbd>True</kbd> if it can find a new label that gives the keyboard focus. If the parameter is <kbd>True</kbd> it searches forward, and if it's <kbd>False</kbd>, it searches backward.</p>
<p><kbd>label.heightForWidth(width)</kbd>: This returns the preferred height for this label, given the <kbd>width</kbd> parameter as an integer.</p>
<p><kbd>label.indent()</kbd>: This returns the label's text indent in pixels.</p>
<p><kbd>label.margin()</kbd>: This returns the distance between the innermost pixel of the frame and the outermost pixel of the contents of this label.</p>
<p><kbd>label.minimumSizeHint()</kbd>: This returns the minimum size of hint of the <kbd>QtCore.QSize</kbd> type that's available for this label.</p>
<p><kbd>label.movie()</kbd>: This returns the pointer to the label's movie of the <kbd>QtGui.QMovie</kbd> type.</p>
<p><kbd>label.openExternalLinks()</kbd>: This returns <kbd>True</kbd> if the label should open links automatically.</p>
<p><kbd>label.picture()</kbd>: This returns the label’s picture of the <kbd>QtGui.QPicture</kbd> type.</p>
<p><kbd>label.pixmap()</kbd>: This returns the label's pixmap of the <kbd>QtGui.QPixmap</kbd> type.</p>
<p><kbd>label.selectedText()</kbd>: This returns the Unicode string as the selected text of this label.</p>
<p><kbd>label.selectionStart()</kbd>: This returns the index of the first selected character of this label, or, if no text is selected, it returns <kbd>-1</kbd>.</p>
<p><kbd>label.text()</kbd>: This returns the label's text as a Unicode string.</p>
<p><kbd>label.textFormat()</kbd>: This returns the formatting for the label's text in the <kbd>QtCore.Qt.TextFormat</kbd> type.</p>
<p><kbd>label.textInteractionFlags()</kbd>: This returns text interaction flags for this label of the <kbd>QtCore.Qt.TextInteractionFlags</kbd> type.</p>
<p><kbd>label.wordWrap()</kbd>: This returns <kbd>True</kbd> if the text in the label is wrapped to the width of the label.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p>These functions are related to events, and include event handlers:</p>
<p><kbd>label.changeEvent(QtCore.QEvent)</kbd>: This handles state changes of the label.</p>
<p><kbd>label.contextMenuEvent(QtGui.QContextMenuEvent)</kbd>: This event handler receives context menu events.</p>
<p><kbd>label.event(QtCore.QEvent)</kbd>: This receives events sent to the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>label.keyPressEvent(QtGui.QKeyEvent)</kbd>: This event handler receives keypress events for this label with the event passed in as the parameter.</p>
<p><kbd>label.focusOutEvent(QtGui.QFocusEvent)</kbd>: This event handler receives the label's keyboard focus events, which are passed in as the <kbd>event</kbd> parameter when the focus is lost.</p>
<p><kbd>label.focusInEvent(QtGui.QFocusEvent)</kbd>: This event handler receives the label's keyboard focus events, which are passed in as the event parameter when the focus is received.</p>
<p><kbd>label.mouseMoveEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse-move events for this label with the event passed in as the parameter.</p>
<p><kbd>label.mousePressEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse-press events for this label with the event passed in as the parameter.</p>
<p><kbd>label.mouseReleaseEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse-release events for this label with the event passed in as the parameter.</p>
<p><kbd>label.paintEvent(QtGui.QPaintEvent)</kbd>: This event handler receives paint events for this label with the event passed in as the parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signals</h1>
                </header>
            
            <article>
                
<p>These are the available signals of the <kbd>QLabel</kbd> class:</p>
<p><kbd>label.linkActivated(str)</kbd>: This signal is emitted when the user clicks on a link, with the URL referred to by the anchor that's passed to the parameter.</p>
<p><kbd>label.linkHovered(str)</kbd>: This signal is emitted when the user hovers over a link, with the URL passed to the parameter.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLabel example</h1>
                </header>
            
            <article>
                
<p>The label will be used in the application more than once. This is only a short demonstration. Now we have a reason to create a class with fonts in the <kbd>u_style.py</kbd> file. These fonts will be used with further components:</p>
<ol start="1">
<li>Insert the <kbd>UFonts</kbd> class at the beginning of the <kbd>u_style.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UFonts(object):<br/><br/>    def __init__(self, parent=None, ls=2.0, ws=2.0,<br/>                 family="Verdana", size=12, weight=34):<br/>        self.font1 = QtGui.QFont() <br/>        self.font1.setLetterSpacing(QtGui.QFont.AbsoluteSpacing, ls)<br/>        self.font1.setWordSpacing(ws)<br/>        self.font1.setFamily(family)<br/>        self.font1.setPixelSize(size)<br/>        self.font1.setWeight(weight)<br/>...</pre>
<p style="padding-left: 60px">This class will be used to change the text font of a widget or a graphical element.</p>
<ol start="2">
<li>Add the <kbd>ULabel</kbd> class to the <kbd>u_style.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class ULabel(QtWidgets.QLabel):<br/><br/>    def __init__(self, parent=None):<br/>        super(ULabel, self).__init__(parent)<br/>        font = UFonts(ls=3.0, size=14, weight=59)<br/>        self.setFont(font.font1)<br/>        self.setStyleSheet("""background-color: %s;<br/>                               color: %s;"""<br/>                               % (color[0], color[3]))<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">The <kbd>setFont()</kbd> method sets the font of the label using the <kbd>UFonts</kbd> <span>class</span>. Now, we need to add some lines to the <kbd>u_app.py</kbd><span> file.</span></p>
<ol start="3">
<li>Add <span>the created </span><kbd>ULabel</kbd><span> class </span>to the <kbd>import</kbd> section of the <kbd>u_app.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_style import UWid, UFrame, ULabel<br/>...</pre>
<ol start="4">
<li>Add the lines with the label inside the <kbd>UApp</kbd><span> </span>class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(self, parent=None):<br/>    ...<br/>        ...<br/>        self.label1 = ULabel(self.frame2)<br/>        self.label1.setText("User Information")<br/>        self.label1.setAlignment(QtCore.Qt.AlignCenter)<br/>        ...<br/>        self.layfr2 = QtWidgets.QGridLayout()<br/>        self.layfr2.addWidget(self.label1, 0, 0, 1, 1)<br/>        self.frame2.setLayout(self.layfr2)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We've set the label instance with text and alignment. Add this label to the grid layout of the second frame. Now, we can run the <kbd>u_app.py</kbd> file, and the result looks like this (with the label on the right-hand side):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0023b8cc-b702-4faf-ae13-285efc03706a.png" style="width:42.58em;height:29.92em;"/></p>
<p>Now, let's move on to the <kbd>QLineEdit</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLineEdit</h1>
                </header>
            
            <article>
                
<p>The line edit field provides a one-line text editor. The <kbd>QLineEdit</kbd> class can be used to create one-line user input fields for entering plain text, such as usernames, emails, and passwords. Also, some other kinds of text input fields provide information that is more convenient to use separately from another piece of text and have some special purpose. The line edit field is commonly used with user forms in applications. The declaration syntax of the line edit field in the application is as follows:</p>
<pre><strong>line_edit</strong> = QtWidgets.QLineEdit()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions of QLineEdit</h1>
                </header>
            
            <article>
                
<p>The <kbd>QLineEdit</kbd> class inherits the <kbd>QWidget</kbd> class and improves functionality with the following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">add</h1>
                </header>
            
            <article>
                
<p>These functions add the elements or actions to the line <kbd>edit_field</kbd>:</p>
<p><kbd>line_edit.addAction(QtWidgets.QAction, QtWidgets.QLineEdit.ActionPosition)</kbd>: This adds an action (the first parameter) to the list of actions at a certain position (the second parameter).</p>
<p><kbd>line_edit.addAction(QtGui.QIcon, QtWidgets.QLineEdit.ActionPosition)</kbd>: This adds a new action with an icon (the first parameter) at a certain position (the second parameter).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p>These functions set parameters/properties to the line edit field, such as text, alignment, and functionality:</p>
<p><kbd>line_edit.setAlignment(QtCore.Qt.Alignment)</kbd>: This sets the alignment of the content of the line edit field.</p>
<p><kbd>line_edit.setClearButtonEnabled(bool)</kbd>: If this parameter is <kbd>True</kbd>, it sets the line edit field to display a clear button when it's not empty. If the parameter is <kbd>False</kbd>, a clear button will not be displayed in the line edit field.</p>
<p><kbd>line_edit.setCompleter(QtWidgets.QCompleter)</kbd>: This sets the line edit field to autocomplete from the completer that is passed in the parameter.</p>
<p><kbd>line_edit.setCursorMoveStyle(QtCore.Qt.CursorMoveStyle)</kbd>: This sets the movement style of the cursor of this line edit field.</p>
<p><kbd>line_edit.setCursorPosition(int)</kbd>: This sets the position of the cursor for this line edit field.</p>
<p><kbd>line_edit.setDragEnabled(bool)</kbd>: If this parameter is <kbd>True</kbd>, it enables dragging for this field.</p>
<p><kbd>line_edit.setEchoMode(QtWidgets.QLineEdit.EchoMode)</kbd>: This sets echo mode for the line edit field. The available parameters are as follows:</p>
<ul>
<li><kbd>QtWidgets.QLineEdit.Normal</kbd>: <kbd>0</kbd></li>
<li><kbd>QtWidgets.QLineEdit.NoEcho</kbd>: <kbd>1</kbd></li>
<li><kbd>QtWidgets.QLineEdit.Password</kbd>: <kbd>2</kbd></li>
<li><kbd>QtWidgets.QLineEdit.PasswordEchoOnEdit</kbd>: <kbd>3</kbd></li>
</ul>
<p><kbd>line_edit.setFrame(bool)</kbd>: If this parameter is <kbd>True</kbd>, it sets the frame around the line edit field.</p>
<p><kbd>line_edit.setInputMask(str)</kbd>: This sets an input mask for this line edit field.</p>
<p><kbd>line_edit.setMaxLength(int)</kbd>: This sets the maximum length of the characters for this field.</p>
<p><kbd>line_edit.setModified(bool)</kbd>: If this parameter is <kbd>True</kbd>, it sets the line edit content as modified or changed/edited.</p>
<p><kbd>line_edit.setPlaceholderText("Placeholder text")</kbd>: This sets the placeholder text of the line edit field, which is the text that will be displayed if the field will be empty.</p>
<p><kbd>line_edit.setReadOnly(bool)</kbd>: If the parameter is <kbd>True</kbd>, this sets the line edit field in read-only mode so that the content inside cannot be edited by the user.</p>
<p><kbd>line_edit.setSelection(start, length)</kbd>: This <span>selects text in the line edit field on the basis of the</span> <kbd>start</kbd> parameter <span>(the first parameter) and</span> <kbd>length</kbd><span> (the second parameter)</span>.</p>
<p><kbd>line_edit.setText("Text in this field")</kbd>: This sets the text that will be displayed with this line edit field.</p>
<p><kbd>line_edit.setTextMargins(QtCore.QMargins)</kbd>: This sets the margins that will be around the text inside the frame of the line edit field.</p>
<p><kbd>line_edit.setTextMargins(left, top, right, bottom)</kbd>: This sets the margins that will be around the text inside the frame of the line edit field. E<span>ach parameter is an </span>integer value.</p>
<p><kbd>line_edit.setValidator(QtGui.QValidator)</kbd>: This sets the validator, specified in the parameter, of the <kbd>QtGui.QValidator</kbd> type, which means that this line edit field will only accept the input that this validator will accept.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">edit</h1>
                </header>
            
            <article>
                
<p>These functions make some changes to the current content of the line edit field, such as clear, undo, and redo:</p>
<p><kbd>line_edit.clear()</kbd>: This clears the content of the line edit field.</p>
<p><kbd>line_edit.copy()</kbd>: This copies the selected text of the line edit field to the clipboard.</p>
<p><kbd>line_edit.cut()</kbd>: This copies the selected text of the line edit field to the clipboard and deletes it from the field.</p>
<p><kbd>line_edit.paste()</kbd>: This inserts the clipboard's text at the cursor position of the line edit, and all the selected text will be deleted.</p>
<p><kbd>line_edit.redo()</kbd>: This redoes the last operation, if available.</p>
<p><kbd>line_edit.undo()</kbd>: This undoes the last operation, if available.</p>
<p><kbd>line_edit.selectAll()</kbd>: This selects all the text in the line edit field and moves the cursor to the end.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">has/is</h1>
                </header>
            
            <article>
                
<p>These functions return a Boolean value (<kbd>bool</kbd>) related to the line edit states; for example, to check the availability of the undo function:</p>
<p><kbd>line_edit.hasAcceptableInput()</kbd>: This returns <kbd>True</kbd> if the input satisfies the <kbd>inputMask</kbd> and the validator.</p>
<p><kbd>line_edit.hasFrame()</kbd>: This returns <kbd>True</kbd> if the line edit field has a frame around itself.</p>
<p><kbd>line_edit.hasSelectedText()</kbd>: This returns <kbd>True</kbd> if the line edit has the selected text.</p>
<p><kbd>line_edit.isClearButtonEnabled()</kbd>: This returns <kbd>True</kbd> if the line edit field displays a clear button when it's not empty.</p>
<p><kbd>line_edit.isModified()</kbd>: This returns <kbd>True</kbd> if the content of the line edit was modified.</p>
<p><kbd>line_edit.isReadOnly()</kbd>: This returns <kbd>True</kbd> if the line edit is in read-only mode, so that content inside it cannot be edited by the user.</p>
<p><kbd>line_edit.isRedoAvailable()</kbd>: This returns <kbd>True</kbd> if the redo functionality is available for the content of the line edit field, or if content was previously undone.</p>
<p><kbd>line_edit.isUndoAvailable()</kbd>: This returns <kbd>True</kbd> if the undo functionality is available for the content of the line edit field or if content was previous edited/changed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p>These functions return the current values of the line edit field and change it to the functionality:</p>
<p><kbd>line_edit.alignment()</kbd>: This returns the alignment of the text in the line edit field of the <kbd>QtCore.Qt.Alignment</kbd> type.</p>
<p><kbd>line_edit.backspace()</kbd>: If no text in the line edit field has been selected, the character to the left of the cursor will be deleted and <span>the cursor will </span>move <span>one position </span>to the left. If <span>any </span>text is selected, the selected text will be deleted and the cursor will move to the beginning of the selected text.</p>
<p><kbd>line_edit.completer()</kbd>: This returns the current completer for the text in the line edit of the <kbd>QtWidgets.QCompleter</kbd> type.</p>
<p><kbd>line_edit.createStandardContextMenu()</kbd>: This creates a standard context menu that will be displayed when the user right-clicks on the line edit field.</p>
<p><kbd>line_edit.cursorBackward(bool,steps)</kbd>: This moves the cursor back by characters (the second parameter). If the first parameter is <kbd>True</kbd>, each character will be selected; otherwise, the selection will be cleared.</p>
<p><kbd>line_edit.cursorForward(bool, steps)</kbd>: This moves the cursor forward by characters (the second parameter). If the first parameter is <kbd>True</kbd>, each character will be selected; otherwise, the selection will be cleared.</p>
<p><kbd>line_edit.cursorMoveStyle()</kbd>: This returns the movement style of the cursor for this line edit field of the <kbd>QtCore.Qt.CursorMoveStyle</kbd> type.</p>
<p><kbd>line_edit.cursorPosition()</kbd>: This returns the current cursor position as an integer value inside the line edit field.</p>
<p><kbd>line_edit.cursorPositionAt(QtCore.QPoint)</kbd>: This returns the cursor position for the point specified in the parameter.</p>
<p><kbd>line_edit.cursorRect()</kbd>: This returns a rectangle of the <kbd>QtCore.QRect</kbd> type where the cursor of the line edit is placed.</p>
<p><kbd>line_edit.cursorWordBackward(bool)</kbd>: This moves the cursor backward by one word. If the parameter is <kbd>True</kbd>, the word will be selected.</p>
<p><kbd>line_edit.cursorWordForward(bool)</kbd>: This moves the cursor forward by one word. If the parameter is <kbd>True</kbd>, the word will be selected.</p>
<p><kbd>line_edit.del_()</kbd>: If the line edit field has no <span>text </span>selected, it will delete the character to the right of the cursor. If text is selected, the cursor will move to the beginning of the selection and the selected text will be deleted.</p>
<p><kbd>line_edit.deselect()</kbd>: This deselects the selected text.</p>
<p><kbd>line_edit.displayText()</kbd>: This returns the displayed text.</p>
<p><kbd>line_edit.dragEnabled()</kbd>: This returns <kbd>True</kbd> if dragging for this line edit field is enabled.</p>
<p><kbd>line_edit.echoMode()</kbd>: This returns the echo mode for this line edit field of the <kbd>QtWidgets.QLineEdit.EchoMode</kbd> type.</p>
<p><kbd>line_edit.end(bool)</kbd>: This moves the text cursor to the end of the line edit field.</p>
<p><kbd>line_edit.getTextMargins()</kbd>: This returns the line edit text margins for the left, top, right, and bottom sides.</p>
<p><kbd>line_edit.home(bool)</kbd>: This moves the cursor to the beginning of the line edit field. If the parameter is <kbd>True</kbd>, the text will be selected; otherwise, any selected text will be unselected.</p>
<p><kbd>line_edit.inputMask()</kbd>: This returns the validation input mask of the line edit field.</p>
<p><kbd>line_edit.inputMethodQuery(QtCore.Qt.InputMethodQuery, object)</kbd>: This is used to query a set of properties of the line edit field in order to support complex input method operations.</p>
<p><kbd>line_edit.insert("Text will be inserted")</kbd>: This inserts new text in the line edit field. It also deletes any selected text and validates the result.</p>
<p><kbd>line_edit.maxLength()</kbd>: This returns the maximum length of the text of this line edit field.</p>
<p><kbd>line_edit.minimumSizeHint()</kbd>: This returns the minimum size hint of the <kbd>QtCore.QSize</kbd> type for this line edit field.</p>
<p><kbd>line_edit.placeholderText()</kbd>: This returns the placeholder text of the line edit field. This text will be displayed as long as the field is empty.</p>
<p><kbd>line_edit.selectedText()</kbd>: This returns the selected text in the line edit field.</p>
<p><kbd>line_edit.selectionStart()</kbd>: This returns the index of the first character in selected text in the field, or returns <kbd>-1</kbd> if no text is selected.</p>
<p><kbd>line_edit.selectionEnd()</kbd>: This returns the index of the last character of the text selected in the field, or returns <kbd>-1</kbd> if no text is selected.</p>
<p><kbd>line_edit.selectionLength()</kbd>: This returns the length of the selected characters in the line edit field.</p>
<p><kbd>line_edit.text()</kbd>: This returns the content of the line edit field as a Unicode string.</p>
<p><kbd>line_edit.textMargins()</kbd>: This returns the margins for the text of this field.</p>
<p><kbd>line_edit.validator()</kbd>: This returns the validator for this line edit field.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p>These functions are related to events, including event handlers:</p>
<p><kbd>line_edit.changeEvent(QtCore.QEvent)</kbd>: This handles state changes of the line edit field.</p>
<p><kbd>line_edit.contextMenuEvent(QtGui.QContextMenuEvent)</kbd>: This event handler receives line edit context menu events.</p>
<p><kbd>line_edit.dragEnterEvent(QtGui.QDragEnterEvent)</kbd>: This event handler is called with an event parameter when the mouse enters the line edit field and a drag is in progress.</p>
<p><kbd>line_edit.dragLeaveEvent(QtGui.QDragLeaveEvent)</kbd>: This event handler is called with an event parameter when the mouse leaves the line edit field and a drag is in progress.</p>
<p><kbd>line_edit.dragMoveEvent(QtGui.QDragMoveEvent)</kbd>: This event handler is called with an event parameter when certain conditions occur, such as the cursor entering the field; the cursor moving within the field; or the modifier key being pressed on the keyboard while the line edit field has the focus, and a drag is in progress.</p>
<p><kbd>line_edit.dropEvent(QtGui.QDropEvent)</kbd>: This event handler is called with an event parameter when a drag is dropped on the line edit field.</p>
<p><kbd>line_edit.event(QtCore.QEvent)</kbd>: This receives events sent to the object and should return <kbd>True</kbd> if the event is recognized and has been processed.</p>
<p><kbd>line_edit.focusOutEvent(QtGui.QFocusEvent)</kbd>: This event handler receives line edit keyboard focus events that are passed with an event parameter when the focus is lost.</p>
<p><kbd>line_edit.focusInEvent(QtGui.QFocusEvent)</kbd>: This event handler receives line edit keyboard focus events that are passed with an event parameter when the focus is received.</p>
<p><kbd>line_edit.inputMethodEvent(QtGui.QInputMethodEvent)</kbd>: This event handler receives input method composition events with an event passed in the parameter.</p>
<p><kbd>line_edit.keyPressEvent(QtGui.QKeyEvent)</kbd>: This event handler receives key press events for the line edit field with an event passed in the parameter.</p>
<p><kbd>line_edit.mouseMoveEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse move events for this line edit field with an event passed in the parameter.</p>
<p><kbd>line_edit.mousePressEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse press events for this line edit field with an event passed in the parameter.</p>
<p><kbd>line_edit.mouseReleaseEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse release events for this line edit field with an event passed in the parameter.</p>
<p><kbd>line_edit.mouseDoubleClickEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse double-click events for this line edit field with an event passed in the parameter.</p>
<p><kbd>line_edit.paintEvent(QtGui.QPaintEvent)</kbd>: This event handler receives paint events for this line edit field with an event passed in the parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signals</h1>
                </header>
            
            <article>
                
<p>The following signals are available with the <kbd>QLineEdit</kbd> class:</p>
<p><kbd>line_edit.cursorPositionChanged(int, int)</kbd>: This signal is emitted when the cursor moves inside the line edit field. The old and new positions are passed as parameters.</p>
<p><kbd>line_edit.editingFinished()</kbd>: This signal is emitted when the <em>Enter</em> key is pressed, or the field loses focus.</p>
<p><kbd>line_edit.returnPressed()</kbd>: This signal is emitted when the <em>Enter</em> key is pressed.</p>
<p><kbd>line_edit.selectionChanged()</kbd>: This signal is emitted when the text selection of the line edit changes.</p>
<p><kbd>line_edit.textChanged(str)</kbd>: This signal is emitted when the text in the field changes; this can also be done programmatically with the <kbd>setText()</kbd> method.</p>
<p><kbd>line_edit.textEdited(str)</kbd>: This signal is emitted when the text in the field is edited. It is not related to changing text with the <kbd>setText()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QLineEdit example</h1>
                </header>
            
            <article>
                
<p>To demonstrate the functionality of the line edit field, let's put this field to the application:</p>
<ol>
<li>Add the <kbd>ULineEd</kbd> class to the <kbd>u_style.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class ULineEd(QtWidgets.QLineEdit):<br/><br/>    def __init__(self, parent=None, tmrgl=10,<br/>                 tmrgt=10, tmrgr=10, tmrgb=10,<br/>                 drg=True, bdr=5, bdw=1, bdc=color[3]):<br/>        super(ULineEd, self).__init__(parent)<br/>        self.setClearButtonEnabled(True)<br/>        self.setDragEnabled(drg)<br/>        self.setTextMargins(tmrgl, tmrgt, tmrgr, tmrgb)<br/>        self.bdr = bdr<br/>        self.bdw = bdw<br/>        self.bdc = bdc<br/>        font = UFonts(size=14, weight=59)<br/>        self.setFont(font.font1)<br/>        self.setStyleSheet(<br/>                """background-color: %s; color: %s;<br/>                   border-radius: %spx; border-width: %spx;<br/>                   border-color: %s;"""  % (color[0],<br/>                   color[3], self.bdr, self.bdw, self.bdc))<br/>  ...</pre>
<p style="padding-left: 60px">We added the various properties to this class, such as the text margins and the color of the line edit field borders. Now, we need to realize this field in the <kbd>u_app.py</kbd><span> file.</span></p>
<ol start="2">
<li>Add this to the <kbd>import</kbd> section of the <kbd>u_app.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_style import ULineEd<br/>...</pre>
<ol start="3">
<li>Add this to the <kbd>__init__()</kbd> function of the <kbd>u_app.py</kbd><strong> </strong>file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>def __init__(self, parent=None):<br/>    ...<br/>    self.line_ed1 = ULineEd(self.frame2)<br/>    self.line_ed1.setPlaceholderText("Full Name...")<br/>    self.line_ed2 = ULineEd(self.frame2)<br/>    self.line_ed2.setPlaceholderText("Email...")<br/>    self.line_ed3 = ULineEd(self.frame2)<br/>    self.line_ed3.setPlaceholderText("Password...")<br/>    self.line_ed3.setEchoMode(QtWidgets.QLineEdit.Password)<br/>    self.layfr2 = QtWidgets.QGridLayout()<br/>    self.layfr2.addWidget(self.label1, 0, 0, 1, 1)<br/>    self.layfr2.addWidget(self.line_ed1, 1, 0, 1, 1)<br/>    self.layfr2.addWidget(self.line_ed2, 2, 0, 1, 1)<br/>    self.layfr2.addWidget(self.line_ed3, 3, 0, 1, 1)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We've added three line edit fields to input the username, email, and password. We've also added to the layout of the second frame.</p>
<ol start="4">
<li>
<p>Now, run the app to see the line edit fields:</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/93918555-fef6-4b04-8f64-5773e0957767.png"/></p>
<p>Now, let's move on to the <kbd>QTextEdit</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QTextEdit</h1>
                </header>
            
            <article>
                
<p>The <kbd>QTextEdit</kbd> class is used for multiline text representations. This field supports both rich and plain formats of text. Usually, rich text formatting is used to insert HTML-style tags into the field with the ability to display and edit them. Multiline fields are the most popular instrument for working with texts in editing mode in order to create text editors and visualize and edit text files. Fields of this type are used for writing text messages, creating text files, saving information to databases, and many other things. Text fields created with the <kbd>QTextEdit</kbd> class allow us to display text, images, lists, tables, and other elements. To implement a multiline text editor in the GUI application, we need to understand the basics of the text representations. End-of-line special characters, such as <kbd>\n</kbd><strong> </strong>for a new line and <kbd>\r</kbd> for a carriage return, are used, depending on the operating system (OS), for example, <kbd>\n</kbd> in Unix-like systems and <kbd>\r\n</kbd> for Windows (<span><strong>Disk Operating Systems</strong> (<strong>DOS</strong>)</span>). Also available are other special characters, such as <kbd>\t</kbd> for a tab and <kbd>\v</kbd> for a vertical tab. By default, <kbd><span>\n</span></kbd> <span>is used </span>in the <kbd>QTextEdit</kbd> field as the symbol for the end of a line, but you need to remember that these special symbols can be different for external text used in the text field. The inheritance scheme of the <kbd>QTextEdit</kbd> class is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/863992e0-bbfd-4511-9cd4-c6931d687638.png"/></p>
<p>The declaration of this class in the application is as follows:</p>
<pre><strong>text_edit</strong> = QtWidgets.QTextEdit()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions of QTextEdit</h1>
                </header>
            
            <article>
                
<p>The <kbd>QTextEdit</kbd> class improves the functionality of the inherited classes with following functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">set</h1>
                </header>
            
            <article>
                
<p>These functions set parameters/properties to the text edit field, such as text, alignment, and functionality:</p>
<p><kbd>text_edit.setAcceptRichText(bool)</kbd>: If the parameter is <kbd>True</kbd>, the text field will accept rich text.</p>
<p><kbd>text_edit.setAlignment(QtCore.Qt.Alignment)</kbd>: This sets the alignment of the current paragraph. The available parameters are <kbd>QtCore.Qt.AlignLeft</kbd>, which aligns text to the left (the default); <kbd>QtCore.Qt.AlignRight</kbd>, which aligns text to the right; <kbd>QtCore.Qt.AlignCenter</kbd>, which aligns text to the center; and <kbd>QtCore.Qt.AlignJustify</kbd>, which justifies text.</p>
<p><kbd>text_edit.setAutoFormatting(QtWidgets.QTextEdit.AutoFormatting)</kbd>: This sets the auto-formatting features for this text field.</p>
<p><kbd>text_edit.setCurrentCharFormat(QtGui.QTextCharFormat)</kbd>: This sets the character format that will be used when inserting new text.</p>
<p><kbd>text_edit.setCurrentFont(QtGui.QFont)</kbd>: This sets the font of the current character format.</p>
<p><kbd>text_edit.setCursorWidth(int)</kbd>: This sets the width of the cursor that will be visible with this text field.</p>
<p><kbd>text_edit.setDocument(QtGui.QTextDocument)</kbd>: This sets the underlying document of this text field.</p>
<p><kbd>text_edit.setDocumentTitle("Document Title")</kbd>: This sets the title of the underlying document.</p>
<p><kbd>text_edit.setExtraSelections(selections)</kbd>: This allows temporary marking of certain regions in the text with a color, specified in the <kbd>selections</kbd> parameter.</p>
<p><kbd>text_edit.setFontFamily("Font Family")</kbd>: This sets the family of the font of the current format.</p>
<p><kbd>text_edit.setFontItalic(bool)</kbd>: If this parameter is <kbd>True</kbd>, the font of the current format will be italic.</p>
<p><kbd>text_edit.setFontPointSize(float)</kbd>: This sets the font point size of the current format.</p>
<p><kbd>text_edit.setFontUnderline(bool)</kbd>: If this parameter is <kbd>True</kbd>, the font of the current format will be underlined.</p>
<p><kbd>text_edit.setFontWeight(int)</kbd>: This sets the font weight of the current format.</p>
<p><kbd>text_edit.setHtml("&lt;p&gt;Html tags&lt;/p&gt;")</kbd>: This sets the text with HTML-style formatting. All previous text will be deleted.</p>
<p class="mce-root"/>
<p><kbd>text_edit.setLineWrapColumnOrWidth(int)</kbd>: This sets the position in pixels or columns (depending on the wrap mode) where text will be wrapped.</p>
<p><kbd>text_edit.setLineWrapMode(QtWidgets.QTextEdit.LineWrapMode)</kbd>: This sets the line wrap mode specified in the parameter for this text field.</p>
<p><kbd>text_edit.setOverwriteMode(bool)</kbd>: If this parameter is <kbd>True</kbd>, the entered text will overwrite existing text.</p>
<p><kbd>text_edit.setPlaceholderText("Placeholder text")</kbd>: This sets the text that will be used when this text field is empty.</p>
<p><kbd>text_edit.setPlainText("Text")</kbd>: This adds plain text to the text field. All previous text will be deleted. If the text has HTML-style tags, these will be displayed in-text as is (without HTML-style formatting).</p>
<p><kbd>text_edit.setReadOnly(bool)</kbd>: If this parameter is <kbd>True</kbd>, it sets the read-only mode for this text field so that content inside it cannot be edited by the user.</p>
<p><kbd>text_edit.setTabChangesFocus(bool)</kbd>: If this parameter is <kbd>True</kbd>, this allows the <em>Tab</em> key to change the focus; otherwise, the <em>Tab</em> key is accepted as input.</p>
<p><kbd>text_edit.setTabStopDistance(float)</kbd>: This sets the <em>Tab</em> stop distance (the default is <kbd>80.0</kbd> pixels).</p>
<p><kbd>text_edit.setTabStopWidth(int)</kbd>: This sets the <em>Tab</em> stop width.</p>
<p><kbd>text_edit.setText("Text")</kbd>: This sets the text to the text field. All previous text will be deleted. The text can have HTML-style formatting or plain text. HTML will be formatted.</p>
<p><kbd>text_edit.setTextBackgroundColor(QtGui.QColor)</kbd>: This sets the background color of the text.</p>
<p><kbd>text_edit.setTextColor(QtGui.QColor)</kbd>: This sets the text color.</p>
<p><kbd>text_edit.setTextCursor(QtGui.QTextCursor)</kbd>: This sets the cursor that will be visible with this text field.</p>
<p><kbd>text_edit.setTextInteractionFlags(QtCore.Qt.TextInteractionFlags)</kbd>: This sets flags that will specify how the text field will interact with user input.</p>
<p><kbd>text_edit.setUndoRedoEnabled(bool)</kbd>: If this parameter is <kbd>True</kbd>, it allows us to execute undo/redo operations in this text field.</p>
<p><kbd>text_edit.setWordWrapMode(QtGui.QTextOption.WrapMode)</kbd>: This sets the mode that will be used when wrapping text in this text edit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">edit</h1>
                </header>
            
            <article>
                
<p>These functions make some changes to the content of the text edit field, such as clear, undo, and redo:</p>
<p><kbd>text_edit.clear()</kbd>: This clears the content of the text edit field, and the undo/redo history will be cleared.</p>
<p><kbd>text_edit.copy()</kbd>: This copies the selected text of this text edit field to the clipboard.</p>
<p><kbd>text_edit.cut()</kbd>: This copies the selected text of the text field to the clipboard and deletes it from the text edit field.</p>
<p><kbd>text_edit.paste()</kbd>: This pastes the clipboard's text at the cursor position of the text field.</p>
<p><kbd>text_edit.redo()</kbd>: This redoes the last operation if it is available for this text field.</p>
<p><kbd>text_edit.undo()</kbd>: This undoes the last operation if it is available for this text field.</p>
<p><kbd>text_edit.selectAll()</kbd>: This selects all the text in the text edit field and moves the cursor to the end of the text.</p>
<p><kbd>text_edit.zoomIn(int)</kbd>: This zooms in on the text by making the font size larger with in the range in the parameter (<kbd>int</kbd>), and recalculating all font sizes. It does not change the size of images.</p>
<p><kbd>text_edit.zoomInF(float)</kbd>: This zooms in on the text by making the font size larger with in the range in the parameter (<kbd>float</kbd>), and recalculating all font sizes. It does not change the size of images. </p>
<p><kbd>text_edit.zoomOut(int)</kbd>: This zooms out in on the text by making the font size smaller with in the range in the parameter, and recalculating all font sizes. It does not change the size of images.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">is</h1>
                </header>
            
            <article>
                
<p>These functions return a Boolean value (<kbd>bool</kbd>) related to the text edit states, for example, to check the availability of the undo functionality:</p>
<p><kbd>text_edit.isReadOnly()</kbd>: This returns <kbd>True</kbd> if the text field is in read-only mode, so that content inside it cannot be edited by the user.</p>
<p><kbd>text_edit.isUndoRedoEnabled()</kbd>: This returns <kbd>True</kbd> if undo and redo operations are enabled for this text edit field.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">functional</h1>
                </header>
            
            <article>
                
<p>These functions return the current values of the text edit field and changes in functionality:</p>
<p><kbd>text_edit.acceptRichText()</kbd>: This returns <kbd>True</kbd> if the text field accepts rich text insertions that allow HTML-style tags. If it returns <kbd>False</kbd>, the text field <span>only </span>accepts plain text input.</p>
<p><kbd>text_edit.alignment()</kbd>: This returns the alignment of the text for the current paragraph.</p>
<p><kbd>text_edit.anchorAt(QtCore.QPoint)</kbd>: This returns the reference as a Unicode string of the anchor at the position specified in the parameter.</p>
<p><kbd>text_edit.append("Text to append")</kbd>: This appends a new text paragraph to the text field as a new line after the last line in the field.</p>
<p><kbd>text_edit.autoFormatting()</kbd>: This returns the auto-formatting features of the <kbd>QtWidgets.QTextEdit.AutoFormatting</kbd> type that are enabled for this text field.</p>
<p><kbd>text_edit.canInsertFromMimeData(QtCore.QMimeData)</kbd>: This returns <kbd>True</kbd> if the contents of the MIME data object, specified in the parameter, can be decoded and inserted into the text field.</p>
<p><kbd>text_edit.canPaste()</kbd>: This returns <kbd>True</kbd> if text can be pasted from the clipboard into this text field.</p>
<p><kbd>text_edit.createMimeDataFromSelection()</kbd>: This returns a new MIME data object of the <kbd>QtCore.QMimeData</kbd> type to represent the contents of this text edit field selection.</p>
<p><kbd>text_edit.createStandardContextMenu()</kbd>: This creates a standard context menu that will be displayed when the user clicks on the text edit field with the right mouse button.</p>
<p><kbd>text_edit.createStandardContextMenu(QtCore.QPoint)</kbd>: This creates a standard context menu that will be displayed when the user right-clicks on the text edit field and<span> appears on the </span>position, specified in the parameter, where the mouse click happens.</p>
<p><kbd>text_edit.currentCharFormat()</kbd>: This returns the current character formatting that will be used when new text is inserted.</p>
<p><kbd>text_edit.currentFont()</kbd>: This returns the current font of the text formatting.</p>
<p><kbd>text_edit.cursorForPosition(QtCore.QPoint)</kbd>: This returns the cursor of the <kbd>QtGui.QTextCursor</kbd> type at the position specified in the parameter (in viewport coordinates).</p>
<p><kbd>text_edit.cursorRect()</kbd>: This returns a rectangle of the <kbd>QtCore.QRect</kbd> type (in viewport coordinates) that includes the cursor of this text field.</p>
<p><kbd>text_edit.cursorRect(QtGui.QTextCursor)</kbd>: This returns a rectangle of the <kbd>QtCore.QRect</kbd> type (in viewport coordinates) that includes the cursor specified in the parameter.</p>
<p><kbd>text_edit.cursorWidth()</kbd>: This returns the width of the cursor in pixels (the default is <kbd>1</kbd>).</p>
<p><kbd>text_edit.document()</kbd>: This returns the content of the text edit field represented as the underlying document of the <kbd>QtGui.QTextDocument</kbd> type.</p>
<p><kbd>text_edit.documentTitle()</kbd>: This returns the title of the underlying document parsed from the text.</p>
<p><kbd>text_edit.ensureCursorVisible()</kbd>: This ensures that the text cursor is visible and, if necessary, scrolls the text edit field.</p>
<p><kbd>text_edit.extraSelections()</kbd>: This returns extra selections that were previously set.</p>
<p><kbd>text_edit.find("Text to find", QtGui.QTextDocument.FindFlags)</kbd>: This finds the next occurrence of the text (the first parameter) using the specified search rules (the second parameter), returns <kbd>True</kbd> if the text was found, and selects this text.</p>
<p><kbd>text_edit.find(QtCore.QRegExp, QtGui.QTextDocument.FindFlags)</kbd>: This finds the next occurrence matching the regular expression (the first parameter) using the specified search rules (the second parameter), returns <kbd>True</kbd> if the text was found, and selects this text in the field.</p>
<p><kbd>text_edit.fontFamily()</kbd>: This returns the font family of the current text format.</p>
<p><kbd>text_edit.fontItalic()</kbd>: This returns <kbd>True</kbd> if the current text format is italic.</p>
<p><kbd>text_edit.fontPointSize()</kbd>: This returns the font point size of the current text format.</p>
<p><kbd>text_edit.fontUnderline()</kbd>: This returns <kbd>True</kbd> if the current text format is underline.</p>
<p><kbd>text_edit.fontWeight()</kbd>: This returns font weight of the current text format.</p>
<p><kbd>text_edit.inputMethodQuery(QtCore.Qt.InputMethodQuery, object)</kbd>: This is used to query a set of properties of the text edit field to support complex input method operations, such as support for surrounding text and reconversions.</p>
<p><kbd>text_edit.insertFromMimeData(QtCore.QMimeData)</kbd>: This inserts the contents of the MIME data object, specified in the parameter, to the text edit field at the current cursor position.</p>
<p><kbd>text_edit.insertHtml("&lt;p&gt;Html tags&lt;/p&gt;")</kbd>: This inserts the text with HTML formatting (if the text is HTML-styled) at the current cursor position.</p>
<p><kbd>text_edit.insertPlainText("Text")</kbd>: This inserts the text at the current cursor position. If the text has HTML formatting, the tags will be not formatted and text will be represented as is.</p>
<p><kbd>text_edit.lineWrapColumnOrWidth()</kbd>: This returns the position in pixels or columns (depending on the wrap mode) where the text will be wrapped.</p>
<p><kbd>text_edit.lineWrapMode()</kbd>: This returns the line wrap mode of the <kbd>QtWidgets.QTextEdit.LineWrapMode</kbd> type for this text field.</p>
<p><kbd>text_edit.loadResource(int, QtCore.QUrl)</kbd>: This loads the resource specified with the type (the first parameter) and the URL (the second parameter).</p>
<p><kbd>text_edit.mergeCurrentCharFormat(QtGui.QTextCharFormat)</kbd>: This merges the properties specified in the parameter into the current character's format.</p>
<p><kbd>text_edit.moveCursor(QtGui.QTextCursor.MoveOperation, QtGui.QTextCursor.MoveMode)</kbd>: This moves the cursor depending on the parameters. If the second parameter is <kbd>QtGui.QTextCursor.KeepAnchor</kbd>, the cursor will select the text as it moves. The available move operations are as follows:</p>
<ul>
<li><kbd>QtGui.QTextCursor.NoMove</kbd> – <kbd>0</kbd>: The cursor stays where it is.</li>
<li><kbd>QtGui.QTextCursor.Start</kbd> – <kbd>1</kbd>: T<span>he cursor moves </span>to the start of text.</li>
<li><kbd>QtGui.QTextCursor.StartOfLine</kbd> – <kbd>3</kbd>: T<span>he cursor moves </span>to the start of the current line.</li>
<li><kbd>QtGui.QTextCursor.StartOfBlock</kbd> – <kbd>4</kbd>: T<span>he cursor moves </span>to the start of the current block (paragraph).</li>
<li><kbd>QtGui.QTextCursor.StartOfWord</kbd> – <kbd>5</kbd>: T<span>he cursor moves </span>to the start of the current word.</li>
<li><kbd>QtGui.QTextCursor.PreviousBlock</kbd> – <kbd>6</kbd>: T<span>he cursor moves </span>to the start of the previous block.</li>
<li><kbd>QtGui.QTextCursor.PreviousCharacter</kbd> – <kbd>7</kbd>: T<span>he cursor moves </span>to the start of the previous character.</li>
<li><kbd>QtGui.QTextCursor.PreviousWord</kbd> – <kbd>8</kbd>: T<span>he cursor moves </span>to the start of the previous word.</li>
<li><kbd>QtGui.QTextCursor.Up</kbd> – <kbd>2</kbd>: T<span>he cursor moves </span>up one line.</li>
<li><kbd>QtGui.QTextCursor.Left</kbd> – <kbd>9</kbd>: T<span>he cursor moves </span>left one character.</li>
<li><kbd>QtGui.QTextCursor.WordLeft</kbd> – <kbd>10</kbd>: T<span>he cursor moves </span>left one word.</li>
<li><kbd>QtGui.QTextCursor.End</kbd> – <kbd>11</kbd>: T<span>he cursor moves </span>to the end of the text.</li>
<li><kbd>QtGui.QTextCursor.EndOfLine</kbd> – <kbd>13</kbd>: T<span>he cursor moves </span>to the end of the current line.</li>
<li><kbd>QtGui.QTextCursor.EndOfWord</kbd> – <kbd>14</kbd>: T<span>he cursor moves </span>to the end of the current word.</li>
<li><kbd>QtGui.QTextCursor.EndOfBlock</kbd> – <kbd>15</kbd>: T<span>he cursor moves </span>to the end of the current block.</li>
<li><kbd>QtGui.QTextCursor.NextBlock</kbd> – <kbd>16</kbd>: T<span>he cursor moves </span>to the beginning of the next block.</li>
<li><kbd>QtGui.QTextCursor.NextCharacter</kbd> – <kbd>17</kbd>: T<span>he cursor moves </span>to the next character.</li>
<li><kbd>QtGui.QTextCursor.NextWord</kbd> – <kbd>18</kbd>: T<span>he cursor moves </span>to the next word.</li>
<li><kbd>QtGui.QTextCursor.Down</kbd> – <kbd>12</kbd>: T<span>he cursor moves </span>down one line.</li>
<li><kbd>QtGui.QTextCursor.Right</kbd> – <kbd>19</kbd>: T<span>he cursor moves </span>right one character.</li>
<li><kbd>QtGui.QTextCursor.WordRight</kbd> – <kbd>20</kbd>: T<span>he cursor moves </span>right one word.</li>
<li><kbd>QtGui.QTextCursor.NextCell</kbd> – <kbd>21</kbd>: T<span>he cursor moves </span>to the next cell inside the current table.</li>
<li><kbd>QtGui.QTextCursor.PreviousCell</kbd> – <kbd>22</kbd>: T<span>he cursor moves </span>to the previous cell inside the current table.</li>
<li><kbd>QtGui.QTextCursor.NextRow</kbd> – <kbd>23</kbd>: T<span>he cursor moves </span>to the next row inside the current table.</li>
<li><kbd>QtGui.QTextCursor.PreviousRow</kbd> – <kbd>24</kbd>: T<span>he cursor moves </span>to the previous row inside the current table.</li>
</ul>
<p><kbd>text_edit.overwriteMode()</kbd>: This returns <kbd>True</kbd> if the entered text will overwrite existing text.</p>
<p><kbd>text_edit.placeholderText()</kbd>: This returns placeholder text that will be used when this text field is empty.</p>
<p><kbd>text_edit.print(QtGui.QPagedPaintDevice)</kbd>: This is a convenience function that prints the text in the text field with a printer device.</p>
<p><kbd>text_edit.print_(QtGui.QPagedPaintDevice)</kbd>: This prints the text of the text field with a printer device.</p>
<p><kbd>text_edit.scrollToAnchor(str)</kbd>: This scrolls the text edit field so that the anchor with the string in the parameter is visible.</p>
<p><kbd>text_edit.tabChangesFocus()</kbd>: This returns <kbd>True</kbd> if the <em>Tab</em> key changes focus.</p>
<p><kbd>text_edit.tabStopDistance()</kbd>: This returns the <em>Tab</em> stop distance.</p>
<p><kbd>text_edit.tabStopWidth()</kbd>: This returns the <em>Tab</em> stop width.</p>
<p><kbd>text_edit.textBackgroundColor()</kbd>: This returns the background color of the <kbd>QtGui.QColor</kbd> type for the text.</p>
<p><kbd>text_edit.textColor()</kbd>: This returns the color of the <kbd>QtGui.QColor</kbd> type for the text.</p>
<p><kbd>text_edit.textCursor()</kbd>: This returns a copy of the cursor of the <kbd>QtGui.QTextCursor</kbd> type, which shows the cursor that is currently visible.</p>
<p><kbd>text_edit.textInteractionFlags()</kbd>: This returns the flags of the <kbd>QtCore.Qt.TextInteractionFlags</kbd> type that specify the interaction with the user input.</p>
<p><kbd>text_edit.toHtml()</kbd>: This returns the text of the text field with HTML-style formatting.</p>
<p><kbd>text_edit.toPlainText()</kbd>: This returns the plain text of the text field.</p>
<p><kbd>text_edit.wordWrapMode()</kbd>: This returns the mode of the <kbd>QtGui.QTextOption.WrapMode</kbd> type that is used when wrapping text in the text edit field.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">events</h1>
                </header>
            
            <article>
                
<p>These functions are related to events, such as event handlers:</p>
<p><kbd>text_edit.changeEvent(QtCore.QEvent)</kbd>: This handles state changes of this text edit field.</p>
<p><kbd>text_edit.contextMenuEvent(QtGui.QContextMenuEvent)</kbd>: This event handler receives text edit context menu events.</p>
<p><kbd>text_edit.dragEnterEvent(QtGui.QDragEnterEvent)</kbd>: This event handler is called with an event parameter when the mouse enters the text edit field and a drag is in progress.</p>
<p><kbd>text_edit.dragLeaveEvent(QtGui.QDragLeaveEvent)</kbd>: This event handler is called with an event parameter when the mouse leaves the text edit field and a drag is in progress.</p>
<p><kbd>text_edit.dragMoveEvent(QtGui.QDragMoveEvent)</kbd>: This event handler is called with an event parameter when certain conditions occur, such as the cursor entering the field, the cursor moving within the field, the modifier key being pressed on the keyboard while the text edit field has the focus, or if a drag is in progress.</p>
<p><kbd>text_edit.dropEvent(QtGui.QDropEvent)</kbd>: This event handler is called with an event parameter when the drag is dropped on the text edit field.</p>
<p><kbd>text_edit.event(QtCore.QEvent)</kbd>: This receives events sent to the object and should return <kbd>True</kbd> if the event is recognized and processed.</p>
<p><kbd>text_edit.focusOutEvent(QtGui.QFocusEvent)</kbd>: This event handler receives the text edit field keyboard focus events that are passed with an event parameter when the focus is lost.</p>
<p><kbd>text_edit.focusInEvent(QtGui.QFocusEvent)</kbd>: This event handler receives the text field keyboard focus events that are passed with an event parameter when the focus is received.</p>
<p><kbd>text_edit.inputMethodEvent(QtGui.QInputMethodEvent)</kbd>: This event handler receives input method composition events with an event passed in the parameter.</p>
<p><kbd>text_edit.keyPressEvent(QtGui.QKeyEvent)</kbd>: This event handler receives keypress events for this text edit field with an event passed in the parameter.</p>
<p><kbd>text_edit.keyReleaseEvent(QtGui.QKeyEvent)</kbd>: This event handler receives key-release events for this text field with an event passed in the parameter.</p>
<p><kbd>text_edit.mouseMoveEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse-move events for this text edit field with an event passed in the parameter.</p>
<p><kbd>text_edit.mousePressEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse-press events for this text field with an event passed in the parameter.</p>
<p><kbd>text_edit.mouseReleaseEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse-release events for this text field with an event passed in the parameter.</p>
<p><kbd>text_edit.mouseDoubleClickEvent(QtGui.QMouseEvent)</kbd>: This event handler receives mouse double-click events for this text edit field with an event passed in the parameter.</p>
<p><kbd>text_edit.paintEvent(QtGui.QPaintEvent)</kbd>: This event handler receives paint events for this text field with an event passed in the parameter.</p>
<p><kbd>text_edit.resizeEvent(QtGui.QResizeEvent)</kbd>: This event handler receives resize events for this text field with an event passed in the parameter.</p>
<p><kbd>text_edit.showEvent(QtGui.QShowEvent)</kbd>: This event handler receives show events for the text field with an event passed in the parameter.</p>
<p><kbd>text_edit.timerEvent(QtCore.QTimerEvent)</kbd>: This event handler receives timer events for the text field with an event passed in the parameter.</p>
<p><kbd>text_edit.wheelEvent(QtGui.QWheelEvent)</kbd>: This event handler receives mouse-wheel events for this field with an event passed in the parameter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">signals</h1>
                </header>
            
            <article>
                
<p>The signals available with the <kbd>QTextEdit</kbd> class are as follows:</p>
<p><kbd>text_edit.copyAvailable(bool)</kbd>: This signal is emitted when text is selected or de-selected in the text field. If the text is selected, the parameter will be <kbd>True</kbd>.</p>
<p><kbd>text_edit.currentCharFormatChanged(QtGui.QTextCharFormat)</kbd>: This signal is emitted when the current character format has changed. The new format is in the parameter.</p>
<p><kbd>text_edit.cursorPositionChanged()</kbd>: This signal is emitted when the cursor moves inside the text field.</p>
<p><kbd>text_edit.redoAvailable(bool)</kbd>: This signal is emitted when redo operations become available (the parameter is <kbd>True</kbd>) or unavailable (the parameter is <kbd>False</kbd>).</p>
<p><kbd>text_edit.undoAvailable(bool)</kbd>: This signal is emitted when undo operations become available (the parameter is <kbd>True</kbd>) or unavailable (the parameter is <kbd>False</kbd>).</p>
<p><kbd>text_edit.selectionChanged()</kbd>: This signal is emitted when the text selection of the text edit changes.</p>
<p><kbd>text_edit.textChanged(str)</kbd>: This signal is emitted when the content of the field changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QTextEdit example</h1>
                </header>
            
            <article>
                
<p>Let's demonstrate a multiline text field in our GUI application. Follow the steps described in the following section:</p>
<ol>
<li>Create the <kbd>UTextEd</kbd> class in the <kbd>u_style.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTextEd(QtWidgets.QTextEdit):<br/><br/>    def __init__(self, parent=None, bgcolor=color[0], sbh=7,<br/>              sbv=7, sbc=color[1], tepad=7, tebgcolor=color[1],<br/>              tetxc=color[3], lh=14, bdr=5, bdw=1, bdc=color[3]):<br/>        super(UTextEd, self).__init__(parent)<br/>        self.setAcceptRichText(True)<br/>        self.setUndoRedoEnabled(True)<br/>        self.bgcolor, self.tebgcolor = bgcolor, tebgcolor<br/>        self.sbh, self.sbv, self.sbc  = sbh, sbv, sbc<br/>        self.tepad, self.tetxc, self.lh = tepad, tetxc, lh<br/>        self.bdr, self.bdw, self.bdc = bdr, bdw, bdc<br/>        font = UFonts(size=14, weight=59)<br/>        self.setFont(font.font1)<br/>        self.setStyleSheet(<br/>                 """QWidget {background-color: %s;}<br/>                    QScrollBar:horizontal {width: %spx;<br/>                       height: %spx; background-color: %s;}<br/>                    QScrollBar:vertical {width: %spx;<br/>                       height: %spx; background-color: %s;}<br/>                    QTextEdit {padding: %spx;<br/>                       background-color: %s; color: %s;<br/>                       line-height: %spx; border-style: solid;<br/>                       border-radius: %spx; border-width: %spx;<br/>                       border-color: %s;}"""<br/>                % (self.bgcolor, self.sbh, self.sbv, self.sbc,<br/>                    self.sbh, self.sbv, self.sbc, self.tepad,<br/>                    self.tebgcolor, self.tetxc, self.lh,<br/>                    self.bdr, self.bdw, self.bdc))<br/>...</pre>
<p style="padding-left: 60px">The properties available with this class are the scroll bar properties, the line height of the text field, the border properties, and many more. Now, we need to add this text edit field to the <kbd>u_app.py</kbd> file.</p>
<ol start="2">
<li>Add the <kbd>UTextEd</kbd> to the <kbd>import</kbd> section of the <kbd>u_app.py</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_style import ULineEd, UTextEd<br/>...</pre>
<ol start="3">
<li>Add the <span>text field </span>lines to the <kbd>__init__()</kbd> function <span>of the </span><kbd>u_app.py</kbd><strong><span> </span></strong><span>file:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.text_edit = UTextEd(self.frame1)<br/>        self.layfr1 = QtWidgets.QGridLayout()<br/>        self.layfr1.addWidget(self.text_edit, 0, 0, 1, 1)<br/>        ...<br/>...</pre>
<p style="padding-left: 60px">The text edit instance adds to the grid layout of the first frame. Now, we can type the different texts in this field and cut, copy, paste, and so on, as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional tips</h1>
                </header>
            
            <article>
                
<p>The most popular implementations of text fields in GUI applications are to create various editors. This may be text editors or code editors to work with texts or typing the code. Therefore, functions for spellchecking and working with the syntax of various languages are very popular. Let's describe some implementations of spellchecking in the text edit field of our GUI application. The example is a class that provides spellchecking functionality in the text edit field. To start, we need to install additional packages. The most useful package for this is <kbd>pyenchant</kbd>. To install this package, type the following in the cmd/Terminal:</p>
<pre><strong>&gt; pip install pyenchant</strong></pre>
<p>Then, create two files called <kbd>u_adds.py</kbd><strong> </strong>in the <kbd>App/App_PySide2</kbd> and <kbd>App/App_PyQt5</kbd> directories (if not, choose one of them) and implement the following steps:</p>
<ol>
<li>Add the following to the import section of the PyQt5 <kbd>u_adds.py</kbd><strong> </strong>file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import re<br/>from PyQt5.Qt import QSyntaxHighlighter<br/>from PyQt5.Qt import QTextCharFormat<br/>from PyQt5.Qt import Qt<br/>...</pre>
<ol start="2">
<li><span>Add the following to the <kbd>import</kbd> section of the PySide2 </span><kbd>u_adds.py</kbd><strong> </strong><span>file:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>import re<br/>from PySide2.QtGui import QSyntaxHighlighter<br/>from PySide2.QtGui import QTextCharFormat<br/>from PySide2.QtCore import Qt<br/>...</pre>
<ol start="3">
<li>Add the <kbd>UHighLight</kbd> class inside both <kbd>u_adds.py</kbd> files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UHighLight(QSyntaxHighlighter):<br/><br/>    words = u"(?iu)[\\w\']+"<br/><br/>    def __init__(self, *args):<br/>        super(UHighLight, self).__init__(*args)<br/>        self.dicts = None<br/><br/>    def setDict(self, dicts):<br/>        self.dict = dicts<br/><br/>    def highlightBlock(self, text):<br/>        if not self.dict:<br/>            return<br/>        formats = QTextCharFormat()<br/>        formats.setUnderlineColor(Qt.red)<br/>        formats.setUnderlineStyle(<br/>                        QTextCharFormat.SpellCheckUnderline)<br/>        for w in re.finditer(self.words, text):<br/>            if not self.dict.check(w.group()):<br/>                self.setFormat(w.start(),<br/>                               w.end() - w.start(), formats)<br/>...</pre>
<p style="padding-left: 60px">This class is used to highlight the incorrect text in the text field with the help of the <kbd>enchant</kbd> library. To use this tool in the application's text field, we need to add some lines to the <kbd>u_app.py</kbd><strong> </strong>file.</p>
<ol start="4">
<li>Add <span>these lines</span> to the <kbd>import</kbd> section of the <kbd>u_app.py</kbd> files:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import enchant<br/>from u_adds import UHighLight<br/>...</pre>
<ol start="5">
<li>Add the <span><kbd>UHighLight</kbd> class </span><span>to the</span><span> </span><kbd>__init__ ()</kbd><span> </span><span>function of the </span><kbd>u_app.py</kbd><span> files:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.dicts = enchant.Dict("en_US")<br/>        self.highlighter = UHighLight(self.text_edit.document())<br/>        self.highlighter.setDict(self.dicts)<br/>...</pre>
<p style="padding-left: 60px">We now need to create the dictionary. Add the <kbd>UHighLight</kbd> class instance with <span>the document of the text edit field as a </span>parameter and set the dictionary. The result will look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/93fc635d-b32d-4da2-9c1c-6b6e1c7e9fc4.png" style="width:49.58em;height:35.00em;"/></p>
<p>This is just an example and is optional. Moreover, you must be careful when using this spell<span>check function,</span> because these tools can lead to problems with memory costs, and the performance of the application will suffer if <span>constructions are not </span>threaded in the right way. Other packages that provide additional dictionaries supporting various languages are available as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The elements that were explored in this chapter are the basic components of the GUI application. Frames provide a convenient way to compound graphical components and labels improve informative visualizations. Single-line and multiline text fields are the most popular for user communications. In addition, PyQt5 and PySide2 have other classes you can use to work with text, such as <kbd>QTextBrowser</kbd>, which improves <kbd>QTextEdit</kbd> with additional functionality. Also, <kbd>QTextDocument</kbd> of the <kbd>QtGui</kbd> class represents text in documented form in the text edit field and the <kbd>QTextCursor</kbd> class provides manipulations with the cursor.</p>
<p>In the next chapter, we will continue covering graphical elements and will be looking at mixed components, such as comboboxes and list views, which have text and control functionality.</p>


            </article>

            
        </section>
    </body></html>