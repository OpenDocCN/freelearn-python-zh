- en: Chapter 5. Working with the Python GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first four chapters, we used the Python interactive prompt or Arduino
    serial monitor to observe the results. The method of using text-based output on
    prompt may be useful for basic and quick prototyping, but when it comes to an
    advanced level of prototyping and demonstrating your prototype or final product,
    you need to have a nice looking and user-friendly interface. GUI helps users to
    understand various components of your hardware project and easily interact with
    it. It can also help you to validate the results from your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a number of widely used GUI frameworks such as `Tkinter`, `wxPython`,
    `PyQt`, `PySide`, and `PyGTK`. Each of these frameworks possesses an almost complete
    set of features that are required to create professional applications. Due to
    the complexity involved, these frameworks have different levels of learning curves
    for first-time Python programmers. Now, as this book is dedicated to Python programming
    for Arduino-based projects, we can''t spend a large amount of time learning the
    nitty-gritty of a specific framework. Instead, we will choose our interface library
    based on the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Ease to install and get started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease to implement with negligible learning efforts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of minimum computational resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework that satisfies all these requirements is `Tkinter` ([https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter)).
    `Tkinter` is also the default standard GUI library deployed with all Python installations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although `Tkinter` is the de-facto GUI package for Python, you can learn more
    about other GUI frameworks that were mentioned earlier from their official websites,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**wxPython**: [http://www.wxpython.org/](http://www.wxpython.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyGTK**: [http://www.pygtk.org/](http://www.pygtk.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PySide**: [http://qt-project.org/wiki/PySide](http://qt-project.org/wiki/PySide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyQt**: [http://sourceforge.net/projects/pyqt/](http://sourceforge.net/projects/pyqt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning Tkinter for GUI design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Tkinter`, short for `Tk` interface, is a cross-platform Python interface for
    the `Tk` GUI toolkit. `Tkinter` provides a thin layer on Python while `Tk` provides
    the graphical widgets. `Tkinter` is a cross-platform library and gets deployed
    as part of Python installation packages for major operating systems. For Mac OS
    X 10.9, `Tkinter` is installed with the default Python framework. For Windows,
    when you install Python from the installation file, `Tkinter` gets installed with
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Tkinter` is designed to take minimal programming efforts for developing graphical
    applications, while also being powerful enough to provide support for the majority
    of GUI application features. If required, `Tkinter` can also be extended with
    plugins. `Tkinter` via `Tk` offers an operating system''s natural look and feel
    after the release of `Tk` Version 8.0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test your current version of the `Tk` toolkit, use the following commands
    on the Python prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be prompted with an image similar to that displayed in the following
    screenshot that contains information about your `Tk` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning Tkinter for GUI design](img/5938OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you face any problem in getting this window, check your Python installation
    and reinstall it, as you won't be able to move further ahead in this chapter without
    the `Tkinter` library and the `Tk` toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Tkinter` interface supports various widgets to develop GUIs. The following
    table describes a few of the important widgets that we will be using in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Widget | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Tk()` | This is the root widget that is required by each program |'
  prefs: []
  type: TYPE_TB
- en: '| `Label()` | This shows a text or an image |'
  prefs: []
  type: TYPE_TB
- en: '| `Button()` | This is a simple button that can be used to execute actions
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Entry()` | This is a text field to provide inputs to the program |'
  prefs: []
  type: TYPE_TB
- en: '| `Scale()` | This provides a numeric value by dragging the slider |'
  prefs: []
  type: TYPE_TB
- en: '| `Checkbox()` | This enables you to toggle between two values by checking
    the box |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A detailed description of the `Tkinter` functions and methods to implement the
    majority of functionalities provided by the `Tk` toolkit can be obtained from
    [https://docs.python.org/2/library/tk.html](https://docs.python.org/2/library/tk.html).
  prefs: []
  type: TYPE_NORMAL
- en: Your first Python GUI program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in an earlier chapter, the first program while learning any
    programming language includes printing `Hello World!`. Now, as we are starting
    Python programming for GUI, let's start by printing the same string in a GUI window
    instead of a prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to start with GUI programming, we are going to execute a Python program
    and then jump into explaining the structure and the details of the code. Let''s
    create a Python executable file using the following lines of code, name it `helloGUI.py`,
    and then run it. The execution process should complete without any dependency
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be prompted with the following window on the successful execution
    of the preceding code snippet. As you can see, the `Hello World!` string has been
    printed inside the window and has **Hello GUI** as the title of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your first Python GUI program](img/5938OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, what exactly happened? As you can see from the code snippet, we instantiated
    various `Tkinter` widgets one by one to obtain this result. These widgets are
    the building blocks for any Python GUI application that is developed using `Tkinter`.
    Let's start with the first and the most important widget, `Tk()`.
  prefs: []
  type: TYPE_NORMAL
- en: The root widget Tk() and the top-level methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Tk()` widget initializes a main empty window with a title bar. This is
    a root widget and it is required by each program only once. The main window gets
    its decoration and styles from the operating system's environment. Therefore,
    when you run the same `Tkinter` code on different operating systems, you will
    get the same window and title bar but in a different style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you create a root widget, you can perform some top-level methods to decorate,
    describe, or resize this window. In code, we are using the `title()` method to
    set the title of the main window. This `title()` method takes a string as an input
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call the `minsize()` method on the main window to set the minimum
    size of the window with the argument `(width, height)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can also use the `maxsize()` method to specify the maximum size
    that the main window should have. In the `minsize()` and `maxsize()` methods,
    the values of `width` and `height` are provided in the number of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the entire program has been instantiated, the `mainloop()` function is
    required to start the event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You won't be able to see any other widgets, including the main window, if the
    code does not enter in the main event loop. The event loop will be alive until
    the window is manually closed or the quit method is called.
  prefs: []
  type: TYPE_NORMAL
- en: You might have various questions about updating the window, programmatically
    closing it, arranging widgets in the grid, and so on. There are definitely a lot
    more top-level methods than the ones specified earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The Label() widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other widget used in the code beside `Tk()` is `Label()`. The `Tkinter`
    widgets are part of the widget hierarchy, where `Label()` is the child of the
    root widget, `Tk()`. This widget cannot be called without specifying the root
    widget or the main window on which the label needs to be displayed. The major
    use of this widget is to display text or image in the main window. In the following
    line of code, we use it to display the `Hello World!` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created and initialized a label object called `helloLabel`, which
    has two input parameters: the `top` variable that specifies the root widget and
    a `text` string. The `Label()` widget is highly customizable and accepts various
    configuration parameters for adjusting the width, border, background, and justification
    as options. Examples involving these customizations are covered in the upcoming
    sections. You can learn more about the supported input arguments at [http://effbot.org/tkinterbook/label.htm](http://effbot.org/tkinterbook/label.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: The Pack geometry manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Pack geometry manager organizes widgets in rows and columns. To use this,
    `Tkinter` requires the `pack()` method to be called for each widget to make the
    widget visible on the main window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Pack geometry manager can be used by all `Tkinter` widgets, except root,
    to organize the widget in the root window. In the case of multiple widgets, if
    the positions for the widgets are not specified, the Pack manager arranges them
    in the same root window. The Pack manager is simple to implement, but it has a
    limitation in terms of its degree of customization. An alternative geometry manager
    that is helpful to create a complex layout is called **Grid**, which is explained
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover additional widgets and their associated methods in the upcoming
    coding exercises. In these exercises, we will explain each individual widget with
    practical applications to give you a better understanding of the use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The Button() widget – interfacing GUI with Arduino and LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have had your first hands-on experience in creating a Python graphical
    interface, let's integrate Arduino with it. Python makes it easy to interface
    various heterogeneous packages within each other and that is what you are going
    to do. In the next coding exercise, we will use `Tkinter` and `pyFirmata` to make
    the GUI work with Arduino. In this exercise, we are going to use the `Button()`
    widget to control the LEDs interfaced with the Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump to the exercises, let''s build the circuit that we will need
    for all upcoming programs. The following is a Fritzing diagram of the circuit
    where we use two different colored LEDs with pull up resistors. Connect these
    LEDs to digital pins 10 and 11 on your Arduino Uno board, as displayed in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Button() widget – interfacing GUI with Arduino and LEDs](img/5938OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While working with the programs provided in this and upcoming sections, you
    will have to replace the Arduino port that is used to define the board variable
    according to your operating system. To find out which port your Arduino board
    is connected to, follow the detailed instructions provided in [Chapter 2](ch02.html
    "Chapter 2. Working with the Firmata Protocol and the pySerial Library"), *Working
    with the Firmata Protocol and the pySerial Library*. Also, make sure that you
    provide the correct pin number in the code if you are planning to use any pins
    other than 10 and 11\. For some exercises, you will have to use the PWM pins,
    so make sure that you have correct pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous exercise, we asked you to use the entire code snippet as a
    Python file and run it. This might not be possible in the upcoming exercises due
    to the length of the program and the complexity involved. Therefore, we have assembled
    these exercises in the program files that can be accessed from the code folder
    of [Chapter 4](ch04.html "Chapter 4. Diving into Python-Arduino Prototyping"),
    *Diving into Python-Arduino Prototyping*, which can be downloaded from [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961).
    For the `Button()` widget exercise, open the `exampleButton.py` file from the
    code folder of [Chapter 4](ch04.html "Chapter 4. Diving into Python-Arduino Prototyping"),
    *Diving into Python-Arduino Prototyping*. The code contains three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pyFirmata` library and Arduino configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Tkinter` widget definitions for a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LED blink function that gets executed when you press the button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see in the following code snippet, we have first imported libraries
    and initialized the Arduino board using `pyFirmata` methods. For this exercise,
    we are only going to work with one LED and we have initialized only the `ledPin`
    variable for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we are using the `pyFirmata` library for all the exercises in this chapter,
    make sure that you have uploaded the latest version of the standard Firmata sketch
    on your Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second part of the code, we have initialized the root `Tkinter` widget
    as `top` and provided a title string. We have also fixed the size of this window
    using the `minsize()` method. In order to get more familiar with the root widget,
    you can play around with the minimum and maximum size of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Button()` widget is a standard `Tkinter` widget that is mostly used to
    obtain the manual, external input stimulus from the user. Like the `Label()` widget,
    the `Button()` widget can be used to display text or images. Unlike the `Label()`
    widget, it can be associated with actions or methods when it is pressed. When
    the button is pressed, `Tkinter` executes the methods or commands specified by
    the `command` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this initialization, the function associated with the button is `onStartButtonPress`
    and the `"Start"` string is displayed as the title of the button. Similarly, the
    `top` object specifies the parent or the root widget. Once the button is instantiated,
    you will need to use the `pack()` method to make it available in the main window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding lines of code, the `onStartButonPress()` function includes
    the scripts that are required to blink the LEDs and change the state of the button.
    A button state can have the state as `NORMAL`, `ACTIVE`, or `DISABLED`. If it
    is not specified, the default state of any button is `NORMAL`. The `ACTIVE` and
    `DISABLED` states are useful in applications when repeated pressing of the button
    needs to be avoided. After turning the LED on using the `write(1)` method, we
    will add a time delay of 5 seconds using the `sleep(5)` function before turning
    it off with the `write(0)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the program, we will execute the `mainloop()` method to initiate
    the `Tkinter` loop. Until this function is executed, the main window won't appear.
  prefs: []
  type: TYPE_NORMAL
- en: To run the code, make appropriate changes to the Arduino `board` variable and
    execute the program. The following screenshot with a button and title bar will
    appear as the output of the program. Clicking on the **Start** button will turn
    on the LED on the Arduino board for the specified time delay. Meanwhile, when
    the LED is on, you will not be able to click on the **Start** button again. Now,
    in this particular program, we haven't provided sufficient code to safely disengage
    the Arduino board and it will be covered in upcoming exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Button() widget – interfacing GUI with Arduino and LEDs](img/5938OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Entry() widget – providing manual user inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous exercise, you used a button to blink the LED on the Arduino
    board for a fixed amount of time. Let's say that you want to change this fixed
    time delay and specify a value according to your application's requirement. To
    perform this operation, you will need a widget that accepts custom values that
    can then be converted into the delay. Just like any other GUI framework, `Tkinter`
    provides the interface for a similar widget called `Entry()` and we will utilize
    this in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep the same Arduino and LED configurations that you used for the previous
    exercise and open the `exampleEntry.py` file. In the beginning of the code, you
    will find the same configuration for the Arduino board and the LED pin that we
    used in the previous exercise. Moving on to the next stage, you will be able to
    see the following code snippet that defines the root widget. In this code snippet,
    we have changed the title of the main window to reflect the premise of the exercise.
    The use of unique strings for the title of the window will help you to differentiate
    these windows according to their properties, when you are dealing with multiple
    windows in one application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the `Entry()` widget can be easily initialized by specifying the parent
    widget as the only parameter, it also supports a large number of parameters to
    customize the widget. For example, in our exercise, we are using the `bd` parameter
    to specify the width of the widget border and `width` to provide the expected
    width of the widget. You can learn more about the available options at [http://effbot.org/tkinterbook/entry.htm](http://effbot.org/tkinterbook/entry.htm):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding lines of code, we have initialized two widget objects in our
    main window: `timePeriodEntry` for the `Entry()` widget and `startButton` that
    we used in the previous exercise for the `Button()` widget. The Pack geometry
    manager always sets the graphical pointer to the last widget that has been added
    to the main window. We can manually shift the focus of the graphical pointer to
    the `timePeriodEntry` widget using the `focus_set()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrary to the `onStartButtonPress()` function in the previous exercise, this
    function doesn''t use the time delay fix. It, instead, obtains the value from
    the `timePeriodEntry` object. You can use the `get()` method to obtain the entered
    value from the `timePeriodEntry` object and convert it into a floating value using
    the `float()` function. As you can see in the following code snippet, we use this
    float value as the time delay between switching the LED off from the on state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once you have understood the process of initializing the `Entry()` widget and
    the method to obtain a custom value from it, let's execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this exercise, you should be able to see a window similar to the
    one displayed in the following screenshot. Enter a time delay value in seconds
    and click on **Start** to see the results on the LED. Basically, when the button
    is pressed, the program will call the `onStartButtonPress()` function and it will
    utilize this value to produce the time delay.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Entry() widget – providing manual user inputs](img/5938OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Scale() widget – adjusting the brightness of an LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop some code to change an LED's brightness using
    the Python GUI. Previously, we learned that you can use a digital pin of Arduino
    to produce an analog output using PWM. Although you can use the `Entry()` widget
    to provide one time value for the PWM signal, it will be useful to have a widget
    that can dynamically provide this value. As brightness can be fluctuated between
    0 and 100 percent, it makes sense to use a slider that varies between 0 and 100\.
    The `Tkinter` library provides this kind of sliding interface using the `Scale()`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: As we are working to change the brightness of the LED and supply analog input,
    we will be using a digital pin with the PWM support. In the previous exercise,
    we used digital pin 11, which already supports PWM. If you are using a custom
    version of the circuit different to the one provided earlier, we recommend that
    you change it to a pin that supports PWM. Now it is time to open the program file,
    `exampleScale.py`, for this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The first stage of the program that involves importing the necessary libraries
    and initializing the Arduino board using `pyFirmata` is almost the same as in
    the previous exercise. Change the string that is used to specify the appropriate
    value for the port variable according to the operating system and the port that
    you are using. We will also instantiate the root window with the unique title
    for this exercise, as we did in the previous exercises. This part of the program
    will often reoccur for a large number of exercises and you can refer to the previous
    exercise for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next stage, we will continue building the code that we developed earlier
    to provide a manual time delay for the LED. We will also use the same `Entry()`
    widget to obtain the time interval as an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Scale()` widget offers a slider knob that can be moved over a fixed scale
    to provide a numeric value as an output. The starting and the ending values for
    this scale are provided using the `from_` and `to` options. The orientation of
    this slider can also be configured using the `orient` option, where the acceptable
    values for the orientation are `HORIZONTAL` and `VERTICAL`. However, you will
    have to import `HORIZONTAL` and `VERTICAL` constants from the `Tkinter` library
    before utilizing them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no options are provided, the default widget uses the scale from 0 to 100
    and the vertical orientation. In our program, we have used the horizontal orientation
    as a demonstration of the `orient` option. Once you have defined the widget object,
    `brightnessScale`, you will have to add it to the Pack geometry manager using
    `pack()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to start the process and reuse the previous code, we have kept the
    instantiation of the `startButton` widget and the `onStartButtonPress` function
    as it is. However, the property of the function is changed to accommodate the
    `Scale()` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version of the `onStartButtonPress()` function, we will obtain the
    `ledBrightness` value by using the `get()` method on the `brightnessScale` widget
    object, where the `get()` method will return the value of the current location
    of the slider. As the PWM input requires values between 0 and 1, and the obtained
    slider value is between 0 and 100, we will convert the slider value into the appropriate
    PWM input by dividing it with 100\. This new value will then be used with the
    `write()` method and this will ultimately turn on the LED with the applied brightness
    for the time period that is provided by the `timePeriodEntry` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For information about the `Scale()` widget, you can refer to [http://effbot.org/tkinterbook/scale.htm](http://effbot.org/tkinterbook/scale.htm).
    Now, run the `exampleScale.py` file. You will be able to see the following screenshot
    with the `Entry()` and `Scale()` widgets. Enter the time delay, drag the slider
    to the brightness that you want, and then click on the **Start** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Scale() widget – adjusting the brightness of an LED](img/5938OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will be able to see the LED light up with the brightness set by the `Scale()`
    widget. Once the LED is turned off after the given time delay, you can reset the
    slider to another position to dynamically vary the value for the brightness.
  prefs: []
  type: TYPE_NORMAL
- en: The Grid geometry manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous exercise, we added three different widgets to the root window
    using the **Pack** geometry manager and the `pack()` method. We didn't actively
    organize these widgets but the Pack manager automatically arranged them in the
    vertical position. While designing a meaningful interface, you need to arrange
    these widgets in the appropriate order. If you look at the previous output window,
    it is really difficult to identify the function of each widget or their association
    with others. In order to design an intuitive GUI, you also need to describe these
    widgets using the appropriate labels. As a solution, `Tkinter` provides an alternative
    way to organize your widgets that is called **Grid geometry manager**.
  prefs: []
  type: TYPE_NORMAL
- en: The Grid geometry manager provides a **two-dimensional** (**2D**) table interface
    to arrange widgets. Every cell that results from the row and column of the 2D
    table can be used as a place for the widgets. You will learn the various options
    that are provided by the `grid()` class to organize widgets in the next programming
    exercise. Open the `exampleGridManager.py` file from the code folder of this chapter.
    In terms of functionalities, this file contains the same program that we built
    in the previous exercise. However, we have added more `Label()` widgets and organized
    them using the Grid geometry manager to simplify the GUI and make it more useful.
  prefs: []
  type: TYPE_NORMAL
- en: As you can observe in the code, the `timePeriodEntry` object (an `Entry()` widget)
    now uses the `grid()` method instead of the `pack()` method. The `grid()` method
    is initialized with the column and row options. The values supplied for these
    options determine the position of the cell where the `timePeriodEntry` object
    will be placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we have also created a label object using the `Label()`
    widget and placed it beside the `Entry()` widget in the same row. The label contains
    a description string that is specified using the `text` option. After placing
    it in a cell using the `grid()` method, widgets are arranged in the center in
    that cell. To change this alignment, you can use the `sticky` option with one
    or more values from `N`, `E`, `S`, and `W`, that is, north, east, south, and west:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We have repeated this practice of placing the widget in a cell and describing
    it using a `Label()` widget for the objects of the `Scale()` and `Button()` widgets
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code snippet, we are using different row values
    for the widgets while having similar column values. As a result, our widgets will
    be organized in the same column and they will have their description labels in
    the next column of the same row. You can skip to the output window if you want
    to check this organization pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we were relying on the user to manually close the main window. However,
    you can create another `Button()` widget and through that, call the method to
    close this window. In this coding exercise, we have an additional button compared
    to the previous exercise that is called `exitButton`. The `command` parameter
    associated with this button is `quit`, which ends the loop started by the `Tkinter`
    method `top.mainloop()` and closes the GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code sample, the `quit` method is initialized as a `command` option
    and it can be also be called as a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we go ahead to the next step, perform the appropriate changes in the
    code and run the program. You will be prompted with a window similar to the one
    displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Grid geometry manager](img/5938OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The red dotted lines are inserted later to help you identify the grid and they
    won't appear in the window that is opened by running the program. You can now
    clearly identify the role of each widget due to the presence of the description
    label beside them. In the opened window, play around with the time and brightness
    values while using the **Start** and **Exit** buttons to perform the associated
    actions. From the next exercise, we will start using the `grid()` method regularly
    to arrange the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The Checkbutton() widget – selecting LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing complex projects, you will encounter scenarios where you have
    to depend on the user to select single or multiple options from a given set of
    values. For example, when you have multiple numbers of LEDs interfaced with the
    Arduino board and you want the user to select an LED or LEDs that need to be turned
    on. This level of customization makes your interface more interactive and useful.
    The `Tkinter` library provides an interface for a standard widget called `Checkbutton()`
    that enables the manual selection process from the given options.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we are going to work with both the LEDs, green and red, that
    you connected to the Arduino board at the beginning. The entire Python program
    for this exercise is located in the code folder with the name `exampleCheckbutton.py`.
    Open the file with the same editor that you have been using all along. This program
    implements the `Checkbutton()` widget for users to select the red and/or green
    LED when the **Start** button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the entire program logic, let''s start from the initialization
    and importing of the libraries. As you can see, now we have two pin assignments
    for digital pins 10 and 11 as `redPin` and `greenPin` respectively. The code for
    the initialization of the Arduino board is unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In our utilization of the `Checkbutton()` widget, we are using a very useful
    `Tkinter` variable class that is called `IntVar()`.The `Tkinter` variable can
    tell the system when the value of the variable is changed. To better understand
    the `Tkinter` variable class and its specific utilization in our exercise, take
    a look at the following code snippet from the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Checkbutton()` widget lets a user select between two different values.
    These values are usually `1` (on) or `0` (off), making the `Checkbutton()` widget
    a switch. To capture this selection, the `variable` option is required in the
    widget definition. A variable can be initialized using one of the `Tkinter` variable
    class, `IntVar()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `redVar` variable object that is instantiated using the
    `IntVar()` class is used for the `variable` option while defining the `Checkbutton()`
    widget, `redCheckButton`. Therefore, any operation on the `redCheckButton` object
    will be translated to the `redVar` variable object. As `IntVar()` is a `Tkinter`
    class, it automatically takes care of any changes in the variable values through
    the `Checkbutton()` widget. Therefore, it is advisable to use the `Tkinter` variable
    class for the `Checkbutton()` widget instead of the default Python variables.
    After defining the `Checkbutton()` widget for the red LED, we have repeated this
    process for the green LED, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This program also contains the **Start** and **Exit** buttons and their respective
    association with the `onStartButtonPress` and `top.quit()` functions, similar
    to how we used them in the previous exercise. When called, the `onStartButtonPress`
    function will obtain the values of the `IntVar()` variables, `redVar` and `greenVar`,
    using the `get()` method. In this case, the variable value of the `Checkbutton()`
    widget will be `1` when it is checked and `0` otherwise. This will enable the
    program to send the value `1` or `0` to the Arduino pin using the `write()` method
    by checking or unchecking the widget and ultimately, turn the LED on or off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code also implements an additional **Stop** button to turn
    off the LEDs that were turned on using the **Start** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onStopButtonPrerss()` function associated with this button turns off both
    the LEDs by using `write(0)` on both the pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since you have now learned about the `Tkinter` variables and the `Checkbutton()`
    widget, let's run the Python program, `exampleCheckbutton.py`. As you can see
    in the next screenshot, the GUI has two `Checkbutton()` widgets each for the red
    and green LEDs. As there is a separate initialization of the `Checkbutton()` widgets,
    a user can check both the red and green LEDs. `Tkinter` also provides similar
    widgets such as `Radiobutton()` and `Listbox()` for cases where you want to select
    only a single value from the given options.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Checkbutton() widget – selecting LEDs](img/5938OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn more about the `Radiobutton()` and `Listbox()` widgets from the
    following web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://effbot.org/tkinterbook/radiobutton.htm](http://effbot.org/tkinterbook/radiobutton.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://effbot.org/tkinterbook/listbox.htm](http://effbot.org/tkinterbook/listbox.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Label() widget – monitoring I/O pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arduino projects often deal with real-time systems and are required to continuously
    monitor input values from digital and analog pins. Therefore, if these values
    are being displayed on a graphical interface, they need to be updated periodically
    or when the state of a pin changes.
  prefs: []
  type: TYPE_NORMAL
- en: If you observe the previous GUI exercises, you will notice that we initialized
    the root window using `mainloop()` at the end of the code, which started the `Tkinter`
    loop and initialized all the widgets with the updated values. Once the `mainloop()`
    was initialized, we did not use any other `Tkinter` class or method to periodically
    update the widgets with the latest values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we will use a potentiometer to provide variable input to
    the analog pin 0, which will be reflected by Tkinter''s `Label()` widget. To update
    the label and display the values of the analog input, we are going to implement
    a few Python and `Tkinter` tricks. As we are using a potentiometer to provide
    input, you will need to change the circuit as displayed in the following diagram,
    before jumping to the Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Label() widget – monitoring I/O pins](img/5938OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python file for this exercise is located in the code folder as the `workingWithLabels.py`
    file. For this exercise, let''s run the code first to understand the premise of
    the exercise. Make sure that you have the appropriate string for the Arduino board
    when you define the `port` variable. On successful execution, the program will
    display the following screenshot and you can click on the **Start** button to
    initiate the continuous update of the potentiometer''s input value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Label() widget – monitoring I/O pins](img/5938OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, how did we do this? This code contains complex logic and a different program
    flow compared to what we have done so far. As you can see from the code, we are
    using a variable called `flag` to track the state of the **Exit** button while
    continuously running the `while` loop that monitors and updates the value. To
    understand the program properly, let''s first get familiar with the following
    new `Tkinter` classes and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BooleanVar()`: Just like the `IntVar()` variable class that we used to track
    the integer values, `BooleanVar()` is a `Tkinter` variable class that tracks changes
    in Boolean:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we have created a variable object, `flag`, using
    the `BooleanVar()` class and set the value of the object as `True`. Being a Boolean
    object, `flag` can only have two values, `True` or `False`. `Tkinter` also provides
    classes for string and double type with the `StringVar()` and `DoubleVar()` classes
    respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Due to this, when the **Start** button is clicked, the system starts updating
    the analog read value. The **Exit** button sets the `flag` variable to `false`,
    breaks the `while` loop, and stops the monitoring process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`update_idletasks`: While using the `Tkinter` library in Python, you can link
    a Python code to any changes that happen in a `Tk()` widget. This linked Python
    code is called a **callback**. The `update_idletasks` method calls all idle tasks
    without processing any callbacks. This method also redraws the geometry widgets,
    if required:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our exercise, this method can be used to continuously update the label with
    the latest potentiometer value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`update`: This top-level method processes all the pending events and callbacks
    and also redraws any widget, if it is necessary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using this method with the root window so that it can perform the callback
    for the **Start** button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s go back to the opened Python program. As you can see, besides assigning
    an analog pin through the `get_pin()` method and initializing the `Iterator()`
    class over the Arduino board, the code contains similar programming patterns that
    we used in the exercises for the other `Tkinter` widgets. In this code, we are
    performing the read operation for the analog pin inside the `onStartButtonPress()`
    function This function checks the status of the `flag` variable while performing
    the `read()` operation on the pin and subsequently updates the value of the `analogReadLabel()`
    widget if the value of the `flag` variable is `True`. If the value of the `flag`
    variable is found to be `False`, the function will exit after disengaging the
    Arduino board and closing the root window. Due to the use of the `while` statement,
    this process will continuously check the `flag` value until it is broken by the
    `onExitButtonPress()` function by changing the `flag` value to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onExitButtonPress()` function is called from the **Exit** button and it
    simply resets the `flag` variable to `False` using the `set()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Remaking your first Python-Arduino project with a GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just to refresh your memory, I would like to remind you that we created a motion
    detection system that generated alerts by blinking the red LED when a motion was
    detected. While working with the project, we were printing the state of the proximity
    sensor onto the Python prompt. In this exercise, we are going to use the concepts
    that you learned in the previous exercises and we will create an interface for
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this exercise, you have to connect the same circuit that we used
    in [Chapter 3](ch03.html "Chapter 3. The First Project – Motion-triggered LEDs"),
    *The First Project – Motion-triggered LEDs*. Make sure you have the exact same
    circuit with the PIR sensor and the LEDs before you move ahead. Once you are ready
    with your hardware, open the `firstProjectWithGUI.py` file from the code folder
    of this chapter. In the code, change the appropriate port values and run the GUI
    for the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the pin assignments, we now have three digital pins—two of
    them as outputs and one as an input. The output pins are assigned to the red and
    green LEDs while the input pin is assigned to the PIR motion sensor. If the PIR
    sensor is in idle mode, we will perform a onetime `read()` operation to wake up
    the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the important functions that is implemented by the code is `blinkLED()`.
    This function updates the `Label()` widget that is assigned to describe the status
    of the motion sensor. It also blinks the physical LEDs using the `write()` method
    and the inserted time delay. As input parameters, the `blinkLED()` function accepts
    the pin object and a message string from the function call, where the pin objects,
    that is, `redPin` or `greenPin`, should be one of the pin assignment for the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The other two `Tkinter` related functions, `onStartButtonPress()` and `onExitButtonPress()`,
    are basically derived from the previous exercise. In this version of `onStartButtonPress()`,
    we call the `blinkLED()` function if the `flag` variable is `True` and the motion
    is detected using `pinPir.read()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The program also instantiates two buttons, **Start** and **Exit**, and one label
    using the methods similar to those we used in the previous exercises.
  prefs: []
  type: TYPE_NORMAL
- en: As you can observe from the code, the logic behind the motion detection system
    is still the same. We are only adding a layer of graphical interface to display
    the state of the detected motion continuously using a `Label()` widget. We have
    also added the **Start** and **Exit** buttons to control the project execution
    cycle. Once you run the code, you will be able to see a window similar to the
    one displayed in the following screenshot. Click on the **Start** button and wave
    in front of the motion sensor. If the sensor detects the motion, the label will
    change from **No motion detected** to **Motion detected**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Remaking your first Python-Arduino project with a GUI](img/5938OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you have hands-on experience of building a basic GUI to handle Arduino projects.
    With minor modifications to the included exercises, you can use them to create
    a GUI for a large variety of Arduino prototyping projects. In the previous two
    exercises, we displayed the sensor outputs as strings in label widgets. It will
    be more meaningful if these numerical values are plotted as a graph and stored
    for further analysis. This is what you are going to perform in the next chapter.
  prefs: []
  type: TYPE_NORMAL
