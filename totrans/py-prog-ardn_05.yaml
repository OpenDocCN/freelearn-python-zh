- en: Chapter 5. Working with the Python GUI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：使用Python GUI
- en: In the first four chapters, we used the Python interactive prompt or Arduino
    serial monitor to observe the results. The method of using text-based output on
    prompt may be useful for basic and quick prototyping, but when it comes to an
    advanced level of prototyping and demonstrating your prototype or final product,
    you need to have a nice looking and user-friendly interface. GUI helps users to
    understand various components of your hardware project and easily interact with
    it. It can also help you to validate the results from your project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前四章中，我们使用了Python交互式提示符或Arduino串行监视器来观察结果。在提示符上使用基于文本的输出方法可能对基本的快速原型设计有用，但当你进行高级原型设计和展示你的原型或最终产品时，你需要一个看起来不错且用户友好的界面。GUI可以帮助用户理解你的硬件项目的各个组件，并轻松与之交互。它还可以帮助你验证项目的结果。
- en: 'Python has a number of widely used GUI frameworks such as `Tkinter`, `wxPython`,
    `PyQt`, `PySide`, and `PyGTK`. Each of these frameworks possesses an almost complete
    set of features that are required to create professional applications. Due to
    the complexity involved, these frameworks have different levels of learning curves
    for first-time Python programmers. Now, as this book is dedicated to Python programming
    for Arduino-based projects, we can''t spend a large amount of time learning the
    nitty-gritty of a specific framework. Instead, we will choose our interface library
    based on the following criteria:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python拥有多个广泛使用的GUI框架，如`Tkinter`、`wxPython`、`PyQt`、`PySide`和`PyGTK`。这些框架几乎都具备创建专业应用程序所需的所有功能。由于涉及到的复杂性，这些框架对于初学者Python程序员来说有不同的学习曲线。现在，由于这本书致力于Arduino项目中的Python编程，我们无法花费大量时间学习特定框架的细节。相反，我们将根据以下标准选择我们的界面库：
- en: Ease to install and get started
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装方便，快速上手
- en: Ease to implement with negligible learning efforts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单，学习成本低
- en: Use of minimum computational resources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源消耗最小
- en: The framework that satisfies all these requirements is `Tkinter` ([https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter)).
    `Tkinter` is also the default standard GUI library deployed with all Python installations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 满足所有这些要求的框架是`Tkinter`([https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter))。`Tkinter`也是所有Python安装中默认的标准GUI库。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although `Tkinter` is the de-facto GUI package for Python, you can learn more
    about other GUI frameworks that were mentioned earlier from their official websites,
    which are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Tkinter`是Python的事实上的GUI包，但你也可以从它们各自的官方网站了解更多关于前面提到的其他GUI框架的信息，如下所示：
- en: '**wxPython**: [http://www.wxpython.org/](http://www.wxpython.org/)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wxPython**: [http://www.wxpython.org/](http://www.wxpython.org/)'
- en: '**PyGTK**: [http://www.pygtk.org/](http://www.pygtk.org/)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyGTK**: [http://www.pygtk.org/](http://www.pygtk.org/)'
- en: '**PySide**: [http://qt-project.org/wiki/PySide](http://qt-project.org/wiki/PySide)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PySide**: [http://qt-project.org/wiki/PySide](http://qt-project.org/wiki/PySide)'
- en: '**PyQt**: [http://sourceforge.net/projects/pyqt/](http://sourceforge.net/projects/pyqt/)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyQt**: [http://sourceforge.net/projects/pyqt/](http://sourceforge.net/projects/pyqt/)'
- en: Learning Tkinter for GUI design
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Tkinter进行GUI设计
- en: '`Tkinter`, short for `Tk` interface, is a cross-platform Python interface for
    the `Tk` GUI toolkit. `Tkinter` provides a thin layer on Python while `Tk` provides
    the graphical widgets. `Tkinter` is a cross-platform library and gets deployed
    as part of Python installation packages for major operating systems. For Mac OS
    X 10.9, `Tkinter` is installed with the default Python framework. For Windows,
    when you install Python from the installation file, `Tkinter` gets installed with
    it.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tkinter`，即`Tk`界面，是`Tk` GUI工具包的跨平台Python接口。`Tkinter`在Python上提供了一个薄层，而`Tk`提供了图形小部件。`Tkinter`是一个跨平台库，作为主要操作系统的Python安装包的一部分进行部署。对于Mac
    OS X 10.9，`Tkinter`与默认Python框架一起安装。对于Windows，当你从安装文件安装Python时，`Tkinter`会与之一起安装。'
- en: '`Tkinter` is designed to take minimal programming efforts for developing graphical
    applications, while also being powerful enough to provide support for the majority
    of GUI application features. If required, `Tkinter` can also be extended with
    plugins. `Tkinter` via `Tk` offers an operating system''s natural look and feel
    after the release of `Tk` Version 8.0.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tkinter`旨在以最小的编程努力开发图形应用程序，同时足够强大以支持大多数GUI应用程序功能。如果需要，`Tkinter`还可以通过插件进行扩展。自`Tk`版本8.0发布以来，`Tkinter`通过`Tk`提供了操作系统自然的视觉和感觉。'
- en: 'To test your current version of the `Tk` toolkit, use the following commands
    on the Python prompt:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的`Tk`工具包当前版本，请在Python提示符中使用以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will be prompted with an image similar to that displayed in the following
    screenshot that contains information about your `Tk` version:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个类似于以下截图中的图像，其中包含有关你的`Tk`版本的信息：
- en: '![Learning Tkinter for GUI design](img/5938OS_05_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![学习Tkinter进行GUI设计](img/5938OS_05_01.jpg)'
- en: If you face any problem in getting this window, check your Python installation
    and reinstall it, as you won't be able to move further ahead in this chapter without
    the `Tkinter` library and the `Tk` toolkit.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到获取此窗口的任何问题，请检查你的Python安装并重新安装它，因为没有`Tkinter`库和`Tk`工具包，你将无法在本章中继续前进。
- en: 'The `Tkinter` interface supports various widgets to develop GUIs. The following
    table describes a few of the important widgets that we will be using in this chapter:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tkinter`界面支持各种窗口小部件来开发GUI。以下表格描述了我们将在本章中使用的一些重要窗口小部件：'
- en: '| Widget | Description |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 窗口小部件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Tk()` | This is the root widget that is required by each program |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `Tk()` | 这是每个程序所需的根窗口小部件 |'
- en: '| `Label()` | This shows a text or an image |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `Label()` | 这显示文本或图像 |'
- en: '| `Button()` | This is a simple button that can be used to execute actions
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `Button()` | 这是一个简单的按钮，可以用来执行动作 |'
- en: '| `Entry()` | This is a text field to provide inputs to the program |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `Entry()` | 这是一个文本字段，用于向程序提供输入 |'
- en: '| `Scale()` | This provides a numeric value by dragging the slider |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `Scale()` | 这通过拖动滑块提供数值 |'
- en: '| `Checkbox()` | This enables you to toggle between two values by checking
    the box |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `Checkbox()` | 这允许你通过勾选框在两个值之间切换 |'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A detailed description of the `Tkinter` functions and methods to implement the
    majority of functionalities provided by the `Tk` toolkit can be obtained from
    [https://docs.python.org/2/library/tk.html](https://docs.python.org/2/library/tk.html).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从[https://docs.python.org/2/library/tk.html](https://docs.python.org/2/library/tk.html)获取`Tkinter`函数和方法的详细描述，这些函数和方法实现了`Tk`工具包提供的多数功能。
- en: Your first Python GUI program
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个Python GUI程序
- en: As we discussed in an earlier chapter, the first program while learning any
    programming language includes printing `Hello World!`. Now, as we are starting
    Python programming for GUI, let's start by printing the same string in a GUI window
    instead of a prompt.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中讨论的，学习任何编程语言的第一程序通常包括打印`Hello World!`。现在，由于我们开始Python GUI编程，让我们先在GUI窗口中打印相同的字符串，而不是在提示符中。
- en: 'Just to start with GUI programming, we are going to execute a Python program
    and then jump into explaining the structure and the details of the code. Let''s
    create a Python executable file using the following lines of code, name it `helloGUI.py`,
    and then run it. The execution process should complete without any dependency
    errors:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了开始GUI编程，我们将执行一个Python程序，然后跳入解释代码的结构和细节。让我们使用以下代码行创建一个Python可执行文件，命名为`helloGUI.py`，然后运行它。执行过程应该在没有依赖错误的情况下完成：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should be prompted with the following window on the successful execution
    of the preceding code snippet. As you can see, the `Hello World!` string has been
    printed inside the window and has **Hello GUI** as the title of the window:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行前面的代码片段后，你应该会看到一个以下窗口。如你所见，`Hello World!`字符串已打印在窗口中，窗口标题为**Hello GUI**：
- en: '![Your first Python GUI program](img/5938OS_05_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![你的第一个Python GUI程序](img/5938OS_05_02.jpg)'
- en: So, what exactly happened? As you can see from the code snippet, we instantiated
    various `Tkinter` widgets one by one to obtain this result. These widgets are
    the building blocks for any Python GUI application that is developed using `Tkinter`.
    Let's start with the first and the most important widget, `Tk()`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，究竟发生了什么？如你所见，我们从代码片段中逐个实例化了各种`Tkinter`窗口小部件以获得这个结果。这些窗口小部件是使用`Tkinter`开发的任何Python
    GUI应用程序的构建块。让我们从第一个也是最重要的窗口小部件`Tk()`开始。
- en: The root widget Tk() and the top-level methods
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根窗口小部件Tk()和顶级方法
- en: The `Tk()` widget initializes a main empty window with a title bar. This is
    a root widget and it is required by each program only once. The main window gets
    its decoration and styles from the operating system's environment. Therefore,
    when you run the same `Tkinter` code on different operating systems, you will
    get the same window and title bar but in a different style.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tk()` 小部件初始化一个带有标题栏的主空窗口。这是一个根小部件，每个程序只需要一次。主窗口的装饰和样式来自操作系统的环境。因此，当您在不同的操作系统上运行相同的
    `Tkinter` 代码时，您将得到相同的窗口和标题栏，但风格不同。'
- en: 'Once you create a root widget, you can perform some top-level methods to decorate,
    describe, or resize this window. In code, we are using the `title()` method to
    set the title of the main window. This `title()` method takes a string as an input
    argument:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了根小部件，您就可以执行一些顶层方法来装饰、描述或调整此窗口的大小。在代码中，我们使用 `title()` 方法设置主窗口的标题。这个 `title()`
    方法接受一个字符串作为输入参数：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we call the `minsize()` method on the main window to set the minimum
    size of the window with the argument `(width, height)`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在主窗口上调用 `minsize()` 方法，通过 `(width, height)` 参数设置窗口的最小尺寸：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similarly, you can also use the `maxsize()` method to specify the maximum size
    that the main window should have. In the `minsize()` and `maxsize()` methods,
    the values of `width` and `height` are provided in the number of pixels.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您也可以使用 `maxsize()` 方法来指定主窗口应该有的最大尺寸。在 `minsize()` 和 `maxsize()` 方法中，`width`
    和 `height` 的值以像素为单位提供。
- en: 'Once the entire program has been instantiated, the `mainloop()` function is
    required to start the event loop:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦整个程序实例化完成，就需要 `mainloop()` 函数来启动事件循环：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You won't be able to see any other widgets, including the main window, if the
    code does not enter in the main event loop. The event loop will be alive until
    the window is manually closed or the quit method is called.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码没有进入主事件循环，您将看不到任何其他小部件，包括主窗口。事件循环将一直活跃，直到窗口被手动关闭或调用退出方法。
- en: You might have various questions about updating the window, programmatically
    closing it, arranging widgets in the grid, and so on. There are definitely a lot
    more top-level methods than the ones specified earlier.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能对更新窗口、程序化关闭它、在网格中排列小部件等问题有各种疑问。肯定有比之前指定的更多顶层方法。
- en: The Label() widget
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Label()` 小部件'
- en: 'The other widget used in the code beside `Tk()` is `Label()`. The `Tkinter`
    widgets are part of the widget hierarchy, where `Label()` is the child of the
    root widget, `Tk()`. This widget cannot be called without specifying the root
    widget or the main window on which the label needs to be displayed. The major
    use of this widget is to display text or image in the main window. In the following
    line of code, we use it to display the `Hello World!` string:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Tk()` 之外，代码中使用的另一个小部件是 `Label()`。`Tkinter` 小部件是部件层次结构的一部分，其中 `Label()` 是根小部件
    `Tk()` 的子部件。此小部件不能在没有指定根小部件或标签需要显示的主窗口的情况下调用。此小部件的主要用途是在主窗口中显示文本或图像。在下面的代码行中，我们使用它来显示
    `Hello World!` 字符串：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we created and initialized a label object called `helloLabel`, which
    has two input parameters: the `top` variable that specifies the root widget and
    a `text` string. The `Label()` widget is highly customizable and accepts various
    configuration parameters for adjusting the width, border, background, and justification
    as options. Examples involving these customizations are covered in the upcoming
    sections. You can learn more about the supported input arguments at [http://effbot.org/tkinterbook/label.htm](http://effbot.org/tkinterbook/label.htm).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建并初始化了一个名为 `helloLabel` 的标签对象，它有两个输入参数：指定根小部件的 `top` 变量和一个 `text` 字符串。`Label()`
    小部件高度可定制，并接受各种配置参数以调整宽度、边框、背景和对齐方式作为选项。涉及这些定制的示例将在接下来的章节中介绍。您可以在[http://effbot.org/tkinterbook/label.htm](http://effbot.org/tkinterbook/label.htm)了解更多关于支持的输入参数。
- en: The Pack geometry manager
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Pack` 几何管理器'
- en: 'The Pack geometry manager organizes widgets in rows and columns. To use this,
    `Tkinter` requires the `pack()` method to be called for each widget to make the
    widget visible on the main window:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pack` 几何管理器按行和列组织小部件。要使用它，`Tkinter` 需要为每个小部件调用 `pack()` 方法，以便小部件在主窗口上可见：'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Pack geometry manager can be used by all `Tkinter` widgets, except root,
    to organize the widget in the root window. In the case of multiple widgets, if
    the positions for the widgets are not specified, the Pack manager arranges them
    in the same root window. The Pack manager is simple to implement, but it has a
    limitation in terms of its degree of customization. An alternative geometry manager
    that is helpful to create a complex layout is called **Grid**, which is explained
    in the upcoming sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Pack几何管理器可以被所有`Tkinter`控件使用，除了根控件，用于在根窗口中组织控件。在多个控件的情况下，如果未指定控件的位置，Pack管理器将它们安排在同一个根窗口中。Pack管理器易于实现，但在自定义程度上有限制。一个有助于创建复杂布局的替代几何管理器称为**Grid**，这将在接下来的章节中解释。
- en: We will cover additional widgets and their associated methods in the upcoming
    coding exercises. In these exercises, we will explain each individual widget with
    practical applications to give you a better understanding of the use cases.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的编码练习中，我们将介绍更多的控件及其相关方法。在这些练习中，我们将通过实际应用来解释每个单独的控件，以便您更好地理解使用案例。
- en: The Button() widget – interfacing GUI with Arduino and LEDs
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Button()小部件 – 将GUI与Arduino和LEDs接口
- en: Now that you have had your first hands-on experience in creating a Python graphical
    interface, let's integrate Arduino with it. Python makes it easy to interface
    various heterogeneous packages within each other and that is what you are going
    to do. In the next coding exercise, we will use `Tkinter` and `pyFirmata` to make
    the GUI work with Arduino. In this exercise, we are going to use the `Button()`
    widget to control the LEDs interfaced with the Arduino board.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了创建Python图形界面的第一次动手经验，让我们将其与Arduino集成。Python使得将各种异构包相互接口变得容易，这正是您将要做的。在下一个编码练习中，我们将使用`Tkinter`和`pyFirmata`使GUI与Arduino协同工作。在这个练习中，我们将使用`Button()`控件来控制与Arduino板接口的LED。
- en: 'Before we jump to the exercises, let''s build the circuit that we will need
    for all upcoming programs. The following is a Fritzing diagram of the circuit
    where we use two different colored LEDs with pull up resistors. Connect these
    LEDs to digital pins 10 and 11 on your Arduino Uno board, as displayed in the
    following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始练习之前，让我们构建我们将需要用于所有后续程序的电路。以下是我们使用的电路的Fritzing图，其中我们使用了两种不同颜色的LED和上拉电阻。将这些LED连接到Arduino
    Uno板上的数字引脚10和11，如图所示：
- en: '![The Button() widget – interfacing GUI with Arduino and LEDs](img/5938OS_05_10.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Button()小部件 – 将GUI与Arduino和LEDs接口](img/5938OS_05_10.jpg)'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While working with the programs provided in this and upcoming sections, you
    will have to replace the Arduino port that is used to define the board variable
    according to your operating system. To find out which port your Arduino board
    is connected to, follow the detailed instructions provided in [Chapter 2](ch02.html
    "Chapter 2. Working with the Firmata Protocol and the pySerial Library"), *Working
    with the Firmata Protocol and the pySerial Library*. Also, make sure that you
    provide the correct pin number in the code if you are planning to use any pins
    other than 10 and 11\. For some exercises, you will have to use the PWM pins,
    so make sure that you have correct pins.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用本节和后续章节中提供的程序时，您必须根据您的操作系统替换用于定义板变量的Arduino端口。要找出您的Arduino板连接到哪个端口，请遵循[第2章](ch02.html
    "第2章。使用Firmata协议和pySerial库")中提供的详细说明，*使用Firmata协议和pySerial库*。同时，如果您打算使用除10和11之外的任何引脚，请确保在代码中提供正确的引脚号。对于某些练习，您将需要使用PWM引脚，所以请确保您有正确的引脚。
- en: 'In the previous exercise, we asked you to use the entire code snippet as a
    Python file and run it. This might not be possible in the upcoming exercises due
    to the length of the program and the complexity involved. Therefore, we have assembled
    these exercises in the program files that can be accessed from the code folder
    of [Chapter 4](ch04.html "Chapter 4. Diving into Python-Arduino Prototyping"),
    *Diving into Python-Arduino Prototyping*, which can be downloaded from [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961).
    For the `Button()` widget exercise, open the `exampleButton.py` file from the
    code folder of [Chapter 4](ch04.html "Chapter 4. Diving into Python-Arduino Prototyping"),
    *Diving into Python-Arduino Prototyping*. The code contains three main components:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们要求你将整个代码片段作为一个 Python 文件运行。由于程序长度和复杂性的原因，在接下来的练习中可能无法这样做。因此，我们将这些练习组装在程序文件中，可以从
    [第 4 章](ch04.html "第 4 章. 深入 Python-Arduino 原型设计") 的代码文件夹中访问，*深入 Python-Arduino
    原型设计*，可以从 [https://www.packtpub.com/books/content/support/1961](https://www.packtpub.com/books/content/support/1961)
    下载。对于 `Button()` 小部件练习，请从 [第 4 章](ch04.html "第 4 章. 深入 Python-Arduino 原型设计") 的代码文件夹中打开
    `exampleButton.py` 文件，*深入 Python-Arduino 原型设计*。代码包含三个主要部分：
- en: The `pyFirmata` library and Arduino configurations
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyFirmata` 库和 Arduino 配置'
- en: The `Tkinter` widget definitions for a button
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮的 `Tkinter` 小部件定义
- en: The LED blink function that gets executed when you press the button
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你按下按钮时执行的 LED 闪烁函数
- en: 'As you can see in the following code snippet, we have first imported libraries
    and initialized the Arduino board using `pyFirmata` methods. For this exercise,
    we are only going to work with one LED and we have initialized only the `ledPin`
    variable for it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码片段所示，我们首先使用 `pyFirmata` 方法导入库并初始化 Arduino 板。对于这个练习，我们只将与一个 LED 一起工作，并且只为它初始化了
    `ledPin` 变量：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we are using the `pyFirmata` library for all the exercises in this chapter,
    make sure that you have uploaded the latest version of the standard Firmata sketch
    on your Arduino board.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个章节的所有练习中都使用 `pyFirmata` 库，请确保你已经将标准 Firmata 草图的最新版本上传到你的 Arduino 板上。
- en: 'In the second part of the code, we have initialized the root `Tkinter` widget
    as `top` and provided a title string. We have also fixed the size of this window
    using the `minsize()` method. In order to get more familiar with the root widget,
    you can play around with the minimum and maximum size of the window:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第二部分，我们已经将根 `Tkinter` 小部件初始化为 `top` 并提供了一个标题字符串。我们还使用 `minsize()` 方法固定了窗口的大小。为了更熟悉根小部件，你可以尝试调整窗口的最小和最大尺寸：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Button()` widget is a standard `Tkinter` widget that is mostly used to
    obtain the manual, external input stimulus from the user. Like the `Label()` widget,
    the `Button()` widget can be used to display text or images. Unlike the `Label()`
    widget, it can be associated with actions or methods when it is pressed. When
    the button is pressed, `Tkinter` executes the methods or commands specified by
    the `command` option:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button()` 小部件是一个标准的 `Tkinter` 小部件，主要用于从用户那里获取手动、外部的输入刺激。像 `Label()` 小部件一样，`Button()`
    小部件可以用来显示文本或图像。与 `Label()` 小部件不同的是，当它被按下时，可以与之关联动作或方法。当按钮被按下时，`Tkinter` 执行由 `command`
    选项指定的方法或命令：'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this initialization, the function associated with the button is `onStartButtonPress`
    and the `"Start"` string is displayed as the title of the button. Similarly, the
    `top` object specifies the parent or the root widget. Once the button is instantiated,
    you will need to use the `pack()` method to make it available in the main window.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始化中，与按钮关联的函数是 `onStartButtonPress`，按钮标题显示为 `"Start"` 字符串。同样，`top` 对象指定了父对象或根小部件。一旦按钮实例化，你需要使用
    `pack()` 方法使其在主窗口中可用。
- en: 'In the preceding lines of code, the `onStartButonPress()` function includes
    the scripts that are required to blink the LEDs and change the state of the button.
    A button state can have the state as `NORMAL`, `ACTIVE`, or `DISABLED`. If it
    is not specified, the default state of any button is `NORMAL`. The `ACTIVE` and
    `DISABLED` states are useful in applications when repeated pressing of the button
    needs to be avoided. After turning the LED on using the `write(1)` method, we
    will add a time delay of 5 seconds using the `sleep(5)` function before turning
    it off with the `write(0)` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，`onStartButonPress()`函数包含了闪烁LED和更改按钮状态的脚本。按钮状态可以是`NORMAL`、`ACTIVE`或`DISABLED`。如果没有指定，任何按钮的默认状态都是`NORMAL`。`ACTIVE`和`DISABLED`状态在需要避免按钮重复按下的应用程序中非常有用。在用`write(1)`方法打开LED后，我们将使用`sleep(5)`函数添加5秒的时间延迟，然后再用`write(0)`方法关闭它：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At the end of the program, we will execute the `mainloop()` method to initiate
    the `Tkinter` loop. Until this function is executed, the main window won't appear.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序结束时，我们将执行`mainloop()`方法来启动`Tkinter`循环。直到这个函数被执行，主窗口不会出现。
- en: To run the code, make appropriate changes to the Arduino `board` variable and
    execute the program. The following screenshot with a button and title bar will
    appear as the output of the program. Clicking on the **Start** button will turn
    on the LED on the Arduino board for the specified time delay. Meanwhile, when
    the LED is on, you will not be able to click on the **Start** button again. Now,
    in this particular program, we haven't provided sufficient code to safely disengage
    the Arduino board and it will be covered in upcoming exercises.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，对Arduino的`board`变量进行适当的更改并执行程序。以下带有按钮和标题栏的屏幕截图将作为程序的输出。点击**开始**按钮将在指定的时间延迟内打开Arduino板上的LED。同时，当LED亮起时，你将无法再次点击**开始**按钮。现在，在这个特定的程序中，我们没有提供足够的代码来安全地断开Arduino板，这将在接下来的练习中介绍。
- en: '![The Button() widget – interfacing GUI with Arduino and LEDs](img/5938OS_05_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![The Button() widget – interfacing GUI with Arduino and LEDs](img/5938OS_05_03.jpg)'
- en: The Entry() widget – providing manual user inputs
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Entry()小部件 – 提供手动用户输入
- en: In the previous exercise, you used a button to blink the LED on the Arduino
    board for a fixed amount of time. Let's say that you want to change this fixed
    time delay and specify a value according to your application's requirement. To
    perform this operation, you will need a widget that accepts custom values that
    can then be converted into the delay. Just like any other GUI framework, `Tkinter`
    provides the interface for a similar widget called `Entry()` and we will utilize
    this in the next exercise.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，你使用了一个按钮来在Arduino板上闪烁LED，持续固定的时间。假设你想更改这个固定的时间延迟，并指定一个根据你的应用程序需求的价值。要执行此操作，你需要一个可以接受自定义值并将其转换为延迟的小部件。就像任何其他GUI框架一样，`Tkinter`提供了一个名为`Entry()`的类似小部件的接口，我们将在下一个练习中使用它。
- en: 'Keep the same Arduino and LED configurations that you used for the previous
    exercise and open the `exampleEntry.py` file. In the beginning of the code, you
    will find the same configuration for the Arduino board and the LED pin that we
    used in the previous exercise. Moving on to the next stage, you will be able to
    see the following code snippet that defines the root widget. In this code snippet,
    we have changed the title of the main window to reflect the premise of the exercise.
    The use of unique strings for the title of the window will help you to differentiate
    these windows according to their properties, when you are dealing with multiple
    windows in one application:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 保持与之前练习相同的Arduino和LED配置，并打开`exampleEntry.py`文件。在代码的开头，你会找到与之前练习中使用的相同的Arduino板和LED引脚配置。进入下一阶段，你将能够看到以下代码片段，它定义了根小部件。在这个代码片段中，我们将主窗口的标题更改，以反映练习的前提。使用独特的字符串作为窗口标题将有助于你在处理一个应用程序中的多个窗口时，根据它们的属性来区分这些窗口：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Although the `Entry()` widget can be easily initialized by specifying the parent
    widget as the only parameter, it also supports a large number of parameters to
    customize the widget. For example, in our exercise, we are using the `bd` parameter
    to specify the width of the widget border and `width` to provide the expected
    width of the widget. You can learn more about the available options at [http://effbot.org/tkinterbook/entry.htm](http://effbot.org/tkinterbook/entry.htm):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过指定父小部件作为唯一参数轻松初始化`Entry()`小部件，但它也支持大量参数来自定义小部件。例如，在我们的练习中，我们使用`bd`参数来指定小部件边框的宽度，以及`width`来提供小部件的预期宽度。你可以在[http://effbot.org/tkinterbook/entry.htm](http://effbot.org/tkinterbook/entry.htm)了解更多关于可用选项的信息：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding lines of code, we have initialized two widget objects in our
    main window: `timePeriodEntry` for the `Entry()` widget and `startButton` that
    we used in the previous exercise for the `Button()` widget. The Pack geometry
    manager always sets the graphical pointer to the last widget that has been added
    to the main window. We can manually shift the focus of the graphical pointer to
    the `timePeriodEntry` widget using the `focus_set()` method.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们在主窗口中初始化了两个小部件对象：`timePeriodEntry`用于`Entry()`小部件，以及我们在上一个练习中使用的`startButton`，用于`Button()`小部件。Pack几何管理器始终将图形指针设置为主窗口中最后添加的小部件。我们可以使用`focus_set()`方法手动将图形指针的焦点移到`timePeriodEntry`小部件。
- en: 'Contrary to the `onStartButtonPress()` function in the previous exercise, this
    function doesn''t use the time delay fix. It, instead, obtains the value from
    the `timePeriodEntry` object. You can use the `get()` method to obtain the entered
    value from the `timePeriodEntry` object and convert it into a floating value using
    the `float()` function. As you can see in the following code snippet, we use this
    float value as the time delay between switching the LED off from the on state:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个练习中的`onStartButtonPress()`函数相反，这个函数没有使用时间延迟修复。相反，它从`timePeriodEntry`对象中获取值。你可以使用`get()`方法从`timePeriodEntry`对象中获取输入的值，并使用`float()`函数将其转换为浮点值。正如你可以在以下代码片段中看到的那样，我们使用这个浮点值作为从开启状态切换LED关闭的时间延迟：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once you have understood the process of initializing the `Entry()` widget and
    the method to obtain a custom value from it, let's execute the code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了初始化`Entry()`小部件的过程以及从中获取自定义值的方法，让我们执行代码。
- en: When you run this exercise, you should be able to see a window similar to the
    one displayed in the following screenshot. Enter a time delay value in seconds
    and click on **Start** to see the results on the LED. Basically, when the button
    is pressed, the program will call the `onStartButtonPress()` function and it will
    utilize this value to produce the time delay.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个练习时，你应该能看到一个类似于以下截图所示的窗口。在秒数中输入一个时间延迟值，然后点击**开始**按钮来查看LED上的结果。基本上，当按钮被按下时，程序将调用`onStartButtonPress()`函数，并使用这个值来产生时间延迟。
- en: '![The Entry() widget – providing manual user inputs](img/5938OS_05_04.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![The Entry() widget – providing manual user inputs](img/5938OS_05_04.jpg)'
- en: The Scale() widget – adjusting the brightness of an LED
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Scale()`小部件 – 调整LED的亮度'
- en: In this section, we will develop some code to change an LED's brightness using
    the Python GUI. Previously, we learned that you can use a digital pin of Arduino
    to produce an analog output using PWM. Although you can use the `Entry()` widget
    to provide one time value for the PWM signal, it will be useful to have a widget
    that can dynamically provide this value. As brightness can be fluctuated between
    0 and 100 percent, it makes sense to use a slider that varies between 0 and 100\.
    The `Tkinter` library provides this kind of sliding interface using the `Scale()`
    widget.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一些代码来使用Python GUI改变LED的亮度。之前，我们了解到你可以使用Arduino的数字引脚通过PWM产生模拟输出。虽然你可以使用`Entry()`小部件为PWM信号提供一个一次性值，但有一个可以动态提供这个值的小部件将是有用的。由于亮度可以在0到100百分比之间变化，因此使用介于0和100之间的滑块是有意义的。`Tkinter`库通过`Scale()`小部件提供了这种滑动界面。
- en: As we are working to change the brightness of the LED and supply analog input,
    we will be using a digital pin with the PWM support. In the previous exercise,
    we used digital pin 11, which already supports PWM. If you are using a custom
    version of the circuit different to the one provided earlier, we recommend that
    you change it to a pin that supports PWM. Now it is time to open the program file,
    `exampleScale.py`, for this exercise.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们努力改变LED的亮度和提供模拟输入时，我们将使用支持PWM的数字引脚。在之前的练习中，我们使用了数字引脚11，它已经支持PWM。如果您使用的是与之前提供的不同的自定义电路版本，我们建议您将其更改为支持PWM的引脚。现在，是时候打开程序文件`exampleScale.py`进行这个练习了。
- en: The first stage of the program that involves importing the necessary libraries
    and initializing the Arduino board using `pyFirmata` is almost the same as in
    the previous exercise. Change the string that is used to specify the appropriate
    value for the port variable according to the operating system and the port that
    you are using. We will also instantiate the root window with the unique title
    for this exercise, as we did in the previous exercises. This part of the program
    will often reoccur for a large number of exercises and you can refer to the previous
    exercise for more information.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一个阶段涉及导入必要的库并使用`pyFirmata`初始化Arduino板，这与之前的练习几乎相同。根据操作系统和您使用的端口更改用于指定端口变量的字符串。我们还将实例化根窗口，并为这个练习提供独特的标题，就像在之前的练习中做的那样。这个程序的部分通常会在大量的练习中重复出现，您可以参考之前的练习以获取更多信息。
- en: 'In the next stage, we will continue building the code that we developed earlier
    to provide a manual time delay for the LED. We will also use the same `Entry()`
    widget to obtain the time interval as an input:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一阶段，我们将继续构建我们之前开发的代码，为LED提供手动时间延迟。我们还将使用相同的`Entry()`小部件来获取时间间隔作为输入：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Scale()` widget offers a slider knob that can be moved over a fixed scale
    to provide a numeric value as an output. The starting and the ending values for
    this scale are provided using the `from_` and `to` options. The orientation of
    this slider can also be configured using the `orient` option, where the acceptable
    values for the orientation are `HORIZONTAL` and `VERTICAL`. However, you will
    have to import `HORIZONTAL` and `VERTICAL` constants from the `Tkinter` library
    before utilizing them here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scale()`小部件提供了一个可以沿着固定刻度移动的滑动旋钮，以提供数值输出。此刻度的起始值和结束值使用`from_`和`to`选项提供。此滑动条的朝向也可以使用`orient`选项进行配置，其中朝向的可接受值为`HORIZONTAL`和`VERTICAL`。然而，在使用这些值之前，您必须从`Tkinter`库中导入`HORIZONTAL`和`VERTICAL`常量。'
- en: 'If no options are provided, the default widget uses the scale from 0 to 100
    and the vertical orientation. In our program, we have used the horizontal orientation
    as a demonstration of the `orient` option. Once you have defined the widget object,
    `brightnessScale`, you will have to add it to the Pack geometry manager using
    `pack()`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供选项，默认小部件使用从0到100的刻度以及垂直方向。在我们的程序中，我们使用了水平方向作为`orient`选项的演示。一旦定义了小部件对象`brightnessScale`，您就必须使用`pack()`将其添加到Pack几何管理器中：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to start the process and reuse the previous code, we have kept the
    instantiation of the `startButton` widget and the `onStartButtonPress` function
    as it is. However, the property of the function is changed to accommodate the
    `Scale()` widget:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动过程并重用之前的代码，我们保留了`startButton`小部件的实例化和`onStartButtonPress`函数的原样。然而，函数的属性被更改以适应`Scale()`小部件：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this version of the `onStartButtonPress()` function, we will obtain the
    `ledBrightness` value by using the `get()` method on the `brightnessScale` widget
    object, where the `get()` method will return the value of the current location
    of the slider. As the PWM input requires values between 0 and 1, and the obtained
    slider value is between 0 and 100, we will convert the slider value into the appropriate
    PWM input by dividing it with 100\. This new value will then be used with the
    `write()` method and this will ultimately turn on the LED with the applied brightness
    for the time period that is provided by the `timePeriodEntry` value:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的`onStartButtonPress()`函数中，我们将通过在`brightnessScale`小部件对象上使用`get()`方法来获取`ledBrightness`值，其中`get()`方法将返回滑动条当前位置的价值。由于PWM输入需要介于0和1之间的值，而获取的滑动条值介于0和100之间，我们将通过除以100将滑动条值转换为适当的PWM输入。然后，这个新值将与`write()`方法一起使用，这将最终根据`timePeriodEntry`值提供的时间周期打开LED。
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For information about the `Scale()` widget, you can refer to [http://effbot.org/tkinterbook/scale.htm](http://effbot.org/tkinterbook/scale.htm).
    Now, run the `exampleScale.py` file. You will be able to see the following screenshot
    with the `Entry()` and `Scale()` widgets. Enter the time delay, drag the slider
    to the brightness that you want, and then click on the **Start** button:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Scale()` 小部件的信息，您可以参考 [http://effbot.org/tkinterbook/scale.htm](http://effbot.org/tkinterbook/scale.htm)。现在，运行
    `exampleScale.py` 文件。您将能够看到以下截图，其中包含 `Entry()` 和 `Scale()` 小部件。输入时间延迟，将滑块拖动到您想要的亮度，然后点击
    **开始** 按钮：
- en: '![The Scale() widget – adjusting the brightness of an LED](img/5938OS_05_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Scale() 小部件 – 调整 LED 的亮度](img/5938OS_05_05.jpg)'
- en: You will be able to see the LED light up with the brightness set by the `Scale()`
    widget. Once the LED is turned off after the given time delay, you can reset the
    slider to another position to dynamically vary the value for the brightness.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够看到 LED 以 `Scale()` 小部件设置的亮度点亮。一旦经过给定的时间延迟后 LED 关闭，您可以将滑块重置到另一个位置以动态改变亮度值。
- en: The Grid geometry manager
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格几何管理器
- en: In the previous exercise, we added three different widgets to the root window
    using the **Pack** geometry manager and the `pack()` method. We didn't actively
    organize these widgets but the Pack manager automatically arranged them in the
    vertical position. While designing a meaningful interface, you need to arrange
    these widgets in the appropriate order. If you look at the previous output window,
    it is really difficult to identify the function of each widget or their association
    with others. In order to design an intuitive GUI, you also need to describe these
    widgets using the appropriate labels. As a solution, `Tkinter` provides an alternative
    way to organize your widgets that is called **Grid geometry manager**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们使用 **Pack** 几何管理器和 `pack()` 方法向根窗口添加了三个不同的小部件。我们没有积极组织这些小部件，但 Pack
    管理器自动将它们垂直排列。在设计有意义的界面时，您需要以适当的顺序排列这些小部件。如果您查看先前的输出窗口，很难识别每个小部件的功能或它们与其他小部件的关系。为了设计直观的
    GUI，您还需要使用适当的标签描述这些小部件。作为解决方案，`Tkinter` 提供了一种组织小部件的替代方法，称为 **网格几何管理器**。
- en: The Grid geometry manager provides a **two-dimensional** (**2D**) table interface
    to arrange widgets. Every cell that results from the row and column of the 2D
    table can be used as a place for the widgets. You will learn the various options
    that are provided by the `grid()` class to organize widgets in the next programming
    exercise. Open the `exampleGridManager.py` file from the code folder of this chapter.
    In terms of functionalities, this file contains the same program that we built
    in the previous exercise. However, we have added more `Label()` widgets and organized
    them using the Grid geometry manager to simplify the GUI and make it more useful.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 网格几何管理器提供了一个 **二维**（**2D**）表格界面来排列小部件。2D 表格的每一行和列组合产生的单元格都可以用作小部件的位置。您将在下一个编程练习中学习
    `grid()` 类提供的各种选项，以组织小部件。从本章代码文件夹中打开 `exampleGridManager.py` 文件。从功能上讲，此文件包含我们在上一个练习中构建的相同程序。然而，我们添加了更多的
    `Label()` 小部件，并使用网格几何管理器对它们进行组织，以简化 GUI 并使其更有用。
- en: As you can observe in the code, the `timePeriodEntry` object (an `Entry()` widget)
    now uses the `grid()` method instead of the `pack()` method. The `grid()` method
    is initialized with the column and row options. The values supplied for these
    options determine the position of the cell where the `timePeriodEntry` object
    will be placed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在代码中所观察到的，`timePeriodEntry` 对象（一个 `Entry()` 小部件）现在使用的是 `grid()` 方法而不是 `pack()`
    方法。`grid()` 方法使用列和行选项进行初始化。这些选项提供的值决定了 `timePeriodEntry` 对象将被放置的单元格位置。
- en: 'On the other hand, we have also created a label object using the `Label()`
    widget and placed it beside the `Entry()` widget in the same row. The label contains
    a description string that is specified using the `text` option. After placing
    it in a cell using the `grid()` method, widgets are arranged in the center in
    that cell. To change this alignment, you can use the `sticky` option with one
    or more values from `N`, `E`, `S`, and `W`, that is, north, east, south, and west:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们使用 `Label()` 小部件创建了一个标签对象，并将其放置在 `Entry()` 小部件旁边的同一行。标签包含一个使用 `text`
    选项指定的描述字符串。在用 `grid()` 方法将其放置在单元格后，小部件在该单元格中居中排列。要更改此对齐方式，您可以使用 `sticky` 选项与 `N`、`E`、`S`
    和 `W` 中的一个或多个值，即北、东、南和西：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have repeated this practice of placing the widget in a cell and describing
    it using a `Label()` widget for the objects of the `Scale()` and `Button()` widgets
    as well:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see in the preceding code snippet, we are using different row values
    for the widgets while having similar column values. As a result, our widgets will
    be organized in the same column and they will have their description labels in
    the next column of the same row. You can skip to the output window if you want
    to check this organization pattern.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we were relying on the user to manually close the main window. However,
    you can create another `Button()` widget and through that, call the method to
    close this window. In this coding exercise, we have an additional button compared
    to the previous exercise that is called `exitButton`. The `command` parameter
    associated with this button is `quit`, which ends the loop started by the `Tkinter`
    method `top.mainloop()` and closes the GUI:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this code sample, the `quit` method is initialized as a `command` option
    and it can be also be called as a method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before we go ahead to the next step, perform the appropriate changes in the
    code and run the program. You will be prompted with a window similar to the one
    displayed in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![The Grid geometry manager](img/5938OS_05_06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: The red dotted lines are inserted later to help you identify the grid and they
    won't appear in the window that is opened by running the program. You can now
    clearly identify the role of each widget due to the presence of the description
    label beside them. In the opened window, play around with the time and brightness
    values while using the **Start** and **Exit** buttons to perform the associated
    actions. From the next exercise, we will start using the `grid()` method regularly
    to arrange the widgets.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The Checkbutton() widget – selecting LEDs
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing complex projects, you will encounter scenarios where you have
    to depend on the user to select single or multiple options from a given set of
    values. For example, when you have multiple numbers of LEDs interfaced with the
    Arduino board and you want the user to select an LED or LEDs that need to be turned
    on. This level of customization makes your interface more interactive and useful.
    The `Tkinter` library provides an interface for a standard widget called `Checkbutton()`
    that enables the manual selection process from the given options.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we are going to work with both the LEDs, green and red, that
    you connected to the Arduino board at the beginning. The entire Python program
    for this exercise is located in the code folder with the name `exampleCheckbutton.py`.
    Open the file with the same editor that you have been using all along. This program
    implements the `Checkbutton()` widget for users to select the red and/or green
    LED when the **Start** button is clicked.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the entire program logic, let''s start from the initialization
    and importing of the libraries. As you can see, now we have two pin assignments
    for digital pins 10 and 11 as `redPin` and `greenPin` respectively. The code for
    the initialization of the Arduino board is unchanged:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In our utilization of the `Checkbutton()` widget, we are using a very useful
    `Tkinter` variable class that is called `IntVar()`.The `Tkinter` variable can
    tell the system when the value of the variable is changed. To better understand
    the `Tkinter` variable class and its specific utilization in our exercise, take
    a look at the following code snippet from the program:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Checkbutton()` widget lets a user select between two different values.
    These values are usually `1` (on) or `0` (off), making the `Checkbutton()` widget
    a switch. To capture this selection, the `variable` option is required in the
    widget definition. A variable can be initialized using one of the `Tkinter` variable
    class, `IntVar()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `redVar` variable object that is instantiated using the
    `IntVar()` class is used for the `variable` option while defining the `Checkbutton()`
    widget, `redCheckButton`. Therefore, any operation on the `redCheckButton` object
    will be translated to the `redVar` variable object. As `IntVar()` is a `Tkinter`
    class, it automatically takes care of any changes in the variable values through
    the `Checkbutton()` widget. Therefore, it is advisable to use the `Tkinter` variable
    class for the `Checkbutton()` widget instead of the default Python variables.
    After defining the `Checkbutton()` widget for the red LED, we have repeated this
    process for the green LED, as shown in the following code snippet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This program also contains the **Start** and **Exit** buttons and their respective
    association with the `onStartButtonPress` and `top.quit()` functions, similar
    to how we used them in the previous exercise. When called, the `onStartButtonPress`
    function will obtain the values of the `IntVar()` variables, `redVar` and `greenVar`,
    using the `get()` method. In this case, the variable value of the `Checkbutton()`
    widget will be `1` when it is checked and `0` otherwise. This will enable the
    program to send the value `1` or `0` to the Arduino pin using the `write()` method
    by checking or unchecking the widget and ultimately, turn the LED on or off:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, the code also implements an additional **Stop** button to turn
    off the LEDs that were turned on using the **Start** button:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `onStopButtonPrerss()` function associated with this button turns off both
    the LEDs by using `write(0)` on both the pins:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since you have now learned about the `Tkinter` variables and the `Checkbutton()`
    widget, let's run the Python program, `exampleCheckbutton.py`. As you can see
    in the next screenshot, the GUI has two `Checkbutton()` widgets each for the red
    and green LEDs. As there is a separate initialization of the `Checkbutton()` widgets,
    a user can check both the red and green LEDs. `Tkinter` also provides similar
    widgets such as `Radiobutton()` and `Listbox()` for cases where you want to select
    only a single value from the given options.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![The Checkbutton() widget – selecting LEDs](img/5938OS_05_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn more about the `Radiobutton()` and `Listbox()` widgets from the
    following web pages:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[http://effbot.org/tkinterbook/radiobutton.htm](http://effbot.org/tkinterbook/radiobutton.htm)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://effbot.org/tkinterbook/listbox.htm](http://effbot.org/tkinterbook/listbox.htm)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Label() widget – monitoring I/O pins
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arduino projects often deal with real-time systems and are required to continuously
    monitor input values from digital and analog pins. Therefore, if these values
    are being displayed on a graphical interface, they need to be updated periodically
    or when the state of a pin changes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: If you observe the previous GUI exercises, you will notice that we initialized
    the root window using `mainloop()` at the end of the code, which started the `Tkinter`
    loop and initialized all the widgets with the updated values. Once the `mainloop()`
    was initialized, we did not use any other `Tkinter` class or method to periodically
    update the widgets with the latest values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we will use a potentiometer to provide variable input to
    the analog pin 0, which will be reflected by Tkinter''s `Label()` widget. To update
    the label and display the values of the analog input, we are going to implement
    a few Python and `Tkinter` tricks. As we are using a potentiometer to provide
    input, you will need to change the circuit as displayed in the following diagram,
    before jumping to the Python program:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![The Label() widget – monitoring I/O pins](img/5938OS_05_11.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'The Python file for this exercise is located in the code folder as the `workingWithLabels.py`
    file. For this exercise, let''s run the code first to understand the premise of
    the exercise. Make sure that you have the appropriate string for the Arduino board
    when you define the `port` variable. On successful execution, the program will
    display the following screenshot and you can click on the **Start** button to
    initiate the continuous update of the potentiometer''s input value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![The Label() widget – monitoring I/O pins](img/5938OS_05_08.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: 'So, how did we do this? This code contains complex logic and a different program
    flow compared to what we have done so far. As you can see from the code, we are
    using a variable called `flag` to track the state of the **Exit** button while
    continuously running the `while` loop that monitors and updates the value. To
    understand the program properly, let''s first get familiar with the following
    new `Tkinter` classes and methods:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '`BooleanVar()`: Just like the `IntVar()` variable class that we used to track
    the integer values, `BooleanVar()` is a `Tkinter` variable class that tracks changes
    in Boolean:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code snippet, we have created a variable object, `flag`, using
    the `BooleanVar()` class and set the value of the object as `True`. Being a Boolean
    object, `flag` can only have two values, `True` or `False`. `Tkinter` also provides
    classes for string and double type with the `StringVar()` and `DoubleVar()` classes
    respectively.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Due to this, when the **Start** button is clicked, the system starts updating
    the analog read value. The **Exit** button sets the `flag` variable to `false`,
    breaks the `while` loop, and stops the monitoring process.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`update_idletasks`: While using the `Tkinter` library in Python, you can link
    a Python code to any changes that happen in a `Tk()` widget. This linked Python
    code is called a **callback**. The `update_idletasks` method calls all idle tasks
    without processing any callbacks. This method also redraws the geometry widgets,
    if required:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In our exercise, this method can be used to continuously update the label with
    the latest potentiometer value.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`update`: This top-level method processes all the pending events and callbacks
    and also redraws any widget, if it is necessary:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are using this method with the root window so that it can perform the callback
    for the **Start** button.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s go back to the opened Python program. As you can see, besides assigning
    an analog pin through the `get_pin()` method and initializing the `Iterator()`
    class over the Arduino board, the code contains similar programming patterns that
    we used in the exercises for the other `Tkinter` widgets. In this code, we are
    performing the read operation for the analog pin inside the `onStartButtonPress()`
    function This function checks the status of the `flag` variable while performing
    the `read()` operation on the pin and subsequently updates the value of the `analogReadLabel()`
    widget if the value of the `flag` variable is `True`. If the value of the `flag`
    variable is found to be `False`, the function will exit after disengaging the
    Arduino board and closing the root window. Due to the use of the `while` statement,
    this process will continuously check the `flag` value until it is broken by the
    `onExitButtonPress()` function by changing the `flag` value to `False`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `onExitButtonPress()` function is called from the **Exit** button and it
    simply resets the `flag` variable to `False` using the `set()` method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Remaking your first Python-Arduino project with a GUI
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just to refresh your memory, I would like to remind you that we created a motion
    detection system that generated alerts by blinking the red LED when a motion was
    detected. While working with the project, we were printing the state of the proximity
    sensor onto the Python prompt. In this exercise, we are going to use the concepts
    that you learned in the previous exercises and we will create an interface for
    our project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: As part of this exercise, you have to connect the same circuit that we used
    in [Chapter 3](ch03.html "Chapter 3. The First Project – Motion-triggered LEDs"),
    *The First Project – Motion-triggered LEDs*. Make sure you have the exact same
    circuit with the PIR sensor and the LEDs before you move ahead. Once you are ready
    with your hardware, open the `firstProjectWithGUI.py` file from the code folder
    of this chapter. In the code, change the appropriate port values and run the GUI
    for the project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the pin assignments, we now have three digital pins—two of
    them as outputs and one as an input. The output pins are assigned to the red and
    green LEDs while the input pin is assigned to the PIR motion sensor. If the PIR
    sensor is in idle mode, we will perform a onetime `read()` operation to wake up
    the sensor:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'One of the important functions that is implemented by the code is `blinkLED()`.
    This function updates the `Label()` widget that is assigned to describe the status
    of the motion sensor. It also blinks the physical LEDs using the `write()` method
    and the inserted time delay. As input parameters, the `blinkLED()` function accepts
    the pin object and a message string from the function call, where the pin objects,
    that is, `redPin` or `greenPin`, should be one of the pin assignment for the LEDs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The other two `Tkinter` related functions, `onStartButtonPress()` and `onExitButtonPress()`,
    are basically derived from the previous exercise. In this version of `onStartButtonPress()`,
    we call the `blinkLED()` function if the `flag` variable is `True` and the motion
    is detected using `pinPir.read()`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The program also instantiates two buttons, **Start** and **Exit**, and one label
    using the methods similar to those we used in the previous exercises.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: As you can observe from the code, the logic behind the motion detection system
    is still the same. We are only adding a layer of graphical interface to display
    the state of the detected motion continuously using a `Label()` widget. We have
    also added the **Start** and **Exit** buttons to control the project execution
    cycle. Once you run the code, you will be able to see a window similar to the
    one displayed in the following screenshot. Click on the **Start** button and wave
    in front of the motion sensor. If the sensor detects the motion, the label will
    change from **No motion detected** to **Motion detected**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Remaking your first Python-Arduino project with a GUI](img/5938OS_05_09.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you have hands-on experience of building a basic GUI to handle Arduino projects.
    With minor modifications to the included exercises, you can use them to create
    a GUI for a large variety of Arduino prototyping projects. In the previous two
    exercises, we displayed the sensor outputs as strings in label widgets. It will
    be more meaningful if these numerical values are plotted as a graph and stored
    for further analysis. This is what you are going to perform in the next chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了构建基本GUI以处理Arduino项目的实践经验。通过稍作修改所包含的练习，你可以使用它们为各种Arduino原型设计项目创建GUI。在前两个练习中，我们在标签小部件中显示传感器输出为字符串。如果将这些数值以图表的形式展示并存储以供进一步分析，将会更有意义。这正是你将在下一章中执行的操作。
