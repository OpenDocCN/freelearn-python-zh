<html><head></head><body>
<section id="chapter-8-the-itertools-module" class="level2 chapterHead" data-number="0.12">&#13;
<h2 class="chapterHead" data-number="0.12"><span class="titlemark"> 8</span><br/>&#13;
<span id="x1-1700008"/>The Itertools Module</h2>&#13;
<p>Functional programming emphasizes stateless objects. In Python, this leads us to work with generator expressions, generator functions, and iterables, instead of large, mutable collection objects. In this chapter, we’ll look at elements of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> library. This library has numerous functions to help us work with iterable sequences of objects, as well as collection objects.</p>&#13;
<p>We introduced iterator functions in <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions, Iterators, and</span> <span class="cmti-10x-x-109">Generators</span></a>. In this chapter, we’ll expand on that superficial introduction. We used some related functions in <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>.</p>&#13;
<p>There are a large number of iterator functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module. We’ll examine the combinatoric functions in the next chapter. In this chapter, we’ll look at the following three broad groupings of the remaining iterator<span id="dx1-170001"/> functions:</p>&#13;
<ul>&#13;
<li><p>Functions that work with potentially infinite iterators. These can be applied to any iterable or an iterator over any collection. For example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function doesn’t require an upper bound on the number of items in the iterable.</p></li>&#13;
<li><p>Functions that work with finite iterators. Often, these are used to create a reduction of the source. For example, grouping the items produced by an iterator reduces the source to groups of items with a common key.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> iterator function clones an iterator into several copies that can each be used independently. This provides a way to overcome the primary limitation of Python iterators: they can be used only once. This is memory-intensive, however, and redesign is often required.</p></li>&#13;
</ul>&#13;
<p>We need to emphasize the important limitation of iterables that we’ve touched upon in other places: they can only be used once.</p>&#13;
<div id="tcolobox-179" class="packt_tip">&#13;
&#13;
&#13;
<p>Iterables can be used only once.</p>&#13;
<p>This can be astonishing because there’s no error exception raised by attempting to reuse an iterator that’s been consumed fully. Once exhausted, they appear to have no elements and will only raise the <span class="obeylines-h"><span class="verb"><code class="inlineCode">StopIteration</code></span></span> exception every time they’re used.</p>&#13;
&#13;
</div>&#13;
<p>There are some other features of iterators that don’t involve such profound limitations. Note that many Python functions, as well as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement, will use the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function to create as many iterators as required from a collection object.</p>&#13;
<p>Other features of iterators include:</p>&#13;
<ul>&#13;
<li><p>There’s no <span class="obeylines-h"><span class="verb"><code class="inlineCode">len()</code></span></span> function for an iterator.</p></li>&#13;
<li><p>Iterators, a subclass of iterables, can do <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> operations, unlike a container. We’ll often use the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> to create an iterator that has a <span class="obeylines-h"><span class="verb"><code class="inlineCode">next()</code></span></span> operation.</p></li>&#13;
<li><p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement makes the distinction between containers and other iterables invisible by evaluating the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">iter()</code></span></span> function. A container object, for example, a list, responds to this function by producing an iterator over the items. An iterable object that’s not a collection, for example, a generator function, returns itself, since it is designed to follow the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span> protocol.</p></li>&#13;
</ul>&#13;
<p>These points will provide some necessary background for this chapter. The idea of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module is to leverage what iterables can do to create succinct, expressive applications without the complicated-looking overheads associated with the details of managing the iterables. <span id="x1-170002r170"/></p>&#13;
<section id="working-with-the-infinite-iterators" class="level3 sectionHead" data-number="0.12.1">&#13;
<h3 class="sectionHead" data-number="0.12.1"><span class="titlemark">8.1 </span> <span id="x1-1710001"/>Working with the infinite iterators</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module provides<span id="dx1-171001"/> a number<span id="dx1-171002"/> of functions that we can use to enhance or enrich an iterable<span id="dx1-171003"/> source of data. We’ll look at the following three functions:</p>&#13;
<ul>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span>: This is an unlimited<span id="dx1-171004"/> version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> function. An upper bound must be imposed by the consumer of this sequence.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span>: This will reiterate<span id="dx1-171005"/> a cycle of values. The consumer must decide when enough values have been produced.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">repeat()</code></span></span>: This can repeat a single value an indefinite number of times. The consumer must end the repetition.</p></li>&#13;
</ul>&#13;
<p>Our goal is to understand how these various iterator functions can be used in generator expressions and with generator functions. <span id="x1-171006r175"/></p>&#13;
<section id="counting-with-count" class="level4 subsectionHead" data-number="0.12.1.1">&#13;
<h4 class="subsectionHead" data-number="0.12.1.1"><span class="titlemark">8.1.1 </span> <span id="x1-1720001"/>Counting with count()</h4>&#13;
<p>The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> function is defined<span id="dx1-172001"/> by an upper limit: the lower limit and step values are optional. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> function, on the other hand, has a start and optional step, but no upper limit.</p>&#13;
<p>This function can be thought<span id="dx1-172002"/> of as the primitive basis for a function such as the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function. We can define the <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function in terms of <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> functions, as follows:</p>&#13;
<div id="tcolobox-180" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from itertools import count &#13;
&gt;&gt;&gt; enumerate = lambda x, start=0: zip(count(start), x)</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function behaves as if it’s a <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function that uses the <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> function to generate the values associated with some iterable source of objects.</p>&#13;
<p>Consequently, the following two expressions are equivalent to each other:</p>&#13;
<div id="tcolobox-181" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(zip(count(), iter(’word’))) &#13;
[(0, ’w’), (1, ’o’), (2, ’r’), (3, ’d’)] &#13;
&gt;&gt;&gt; list(enumerate(iter(’word’))) &#13;
[(0, ’w’), (1, ’o’), (2, ’r’), (3, ’d’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>Both will emit a sequence<span id="dx1-172011"/> of numbers<span id="dx1-172012"/> of two-tuples. The first item in each tuple is an integer counter. The second item comes from the iterator. In this example, the iterator is built from a string of characters.</p>&#13;
<p>Here’s something we can do with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> function that’s difficult to do with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function:</p>&#13;
<div id="tcolobox-182" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(zip(count(1, 3), iter(’word’))) &#13;
[(1, ’w’), (4, ’o’), (7, ’r’), (10, ’d’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>The value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">count(b,</code><code class="inlineCode"> s)</code></span></span> is the sequence of values <span class="cmsy-10x-x-109">{</span><span class="italic">b,b </span>+ <span class="italic">s,b </span>+ 2<span class="italic">s,b </span>+ 3<span class="italic">s,...</span><span class="cmsy-10x-x-109">}</span>. In this example, it will provide values of 1, 4, 7, 10, and so on as the identifiers for each value from the enumerator. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function doesn’t provide a way to change the step.</p>&#13;
<p>We can, of course, combine generator functions to achieve this result. Here’s how changing the step can be done with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function:</p>&#13;
<div id="tcolobox-183" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; source = iter(’word’) &#13;
&gt;&gt;&gt; gen3 = ((1+3*e, x) for e, x in enumerate(source)) &#13;
&gt;&gt;&gt; list(gen3) &#13;
[(1, ’w’), (4, ’o’), (7, ’r’), (10, ’d’)]</code></pre>&#13;
&#13;
</div>&#13;
<p>This shows how a new value, 1 + 3<span class="italic">e</span>, is computed from the source enumeration value of <span class="italic">e</span>. This behaves like the sequence started at 1 and is incremented by 3. <span id="x1-172021r179"/></p>&#13;
</section>&#13;
<section id="counting-with-float-arguments" class="level4 subsectionHead" data-number="0.12.1.2">&#13;
<h4 class="subsectionHead" data-number="0.12.1.2"><span class="titlemark">8.1.2 </span> <span id="x1-1730002"/>Counting with float arguments</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> function permits<span id="dx1-173001"/> non-integer values. We can use something such as the <span class="obeylines-h"><span class="verb"><code class="inlineCode">count(0.5,</code><code class="inlineCode"> 0.1)</code></span></span> expression to provide<span id="dx1-173002"/> floating-point values. This will accumulate an error if the increment value doesn’t have an exact representation. It’s generally better to use integer <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span> arguments such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">(0.5+x*.1</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> count())</code></span></span> to ensure that representation errors don’t accumulate.</p>&#13;
<p>Here’s a way to examine the accumulating error. This exploration of the float approximation shows some interesting functional programming techniques.</p>&#13;
<p>We’ll define a function that will evaluate items from an iterator until some condition is met. This is a way to find the first item that meets some criteria defined by a function. Here’s how we can define a <span class="obeylines-h"><span class="verb"><code class="inlineCode">find_first()</code></span></span> function:</p>&#13;
<pre id="listing-182" class="lstlisting"><code>from collections.abc import Callable, Iterator &#13;
from typing import TypeVar &#13;
T = TypeVar("T") &#13;
 &#13;
def find_first( &#13;
    terminate: Callable[[T], bool], &#13;
    iterator: Iterator[T] &#13;
) -&gt; T: &#13;
    i = next(iterator) &#13;
    if terminate(i): &#13;
        return i &#13;
    return find_first(terminate, iterator)</code></pre>&#13;
<p>This function starts by getting the next value from the iterator object. No specific type is provided; the type variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">T</code></span></span> tells <span class="keyWord">mypy </span>that the source iterator and the target result will be the same type. If the chosen item passes the test, that is, this is the desired value, iteration stops and the return value will be of the given type associated with the type variable, <span class="obeylines-h"><span class="verb"><code class="inlineCode">T</code></span></span>. Otherwise, we’ll evaluate this function recursively to search for a subsequent value that passes the test.</p>&#13;
<p>Because the tail-call recursion is not replaced with an optimized <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement, this is limited to iterables with about 1,000 items.</p>&#13;
<p>If we have some<span id="dx1-173015"/> series of values<span id="dx1-173016"/> computed by a generator, this will consume items from the iterator. Here’s a silly example. Let’s say we have an approximation that is a sum of a series of values. One example is this:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file64.jpg" class="math-display" alt=" ( 1 1 1 ) π = 4 arctan (1) = 4 1− 3-+ 5-− 7-⋅⋅⋅ "/>&#13;
</div>&#13;
<p>The terms of this series can be created by a generator function like this:</p>&#13;
<div id="tcolobox-184" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code> &#13;
&gt;&gt;&gt; def term_iter(): &#13;
...     d = 1 &#13;
...     sgn = 1 &#13;
...     while True: &#13;
...         yield Fraction(sgn, d) &#13;
...         d += 2 &#13;
...         sgn = -1 if sgn == 1 else 1</code></pre>&#13;
&#13;
</div>&#13;
<p>This will yield values like <span class="obeylines-h"><span class="verb"><code class="inlineCode">Fraction(1,</code><code class="inlineCode"> 1)</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Fraction(-1,</code><code class="inlineCode"> 3)</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">Fraction(1,</code><code class="inlineCode"> 5)</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">Fraction(-1,</code><code class="inlineCode"> 7)</code></span></span>. It will yield an infinite number of them. We want values up until the first value that meets some criteria. For example, we may want to know the first value that will be less than <img src="../Images/file65.jpg" class="frac" data-align="middle" alt="1100"/> (this is pretty easy to work out with pencil and paper to check the results):</p>&#13;
<div id="tcolobox-185" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code> &#13;
&gt;&gt;&gt; find_first(lambda v: abs(v) &lt; 1E-2, term_iter()) &#13;
Fraction(1, 101)</code></pre>&#13;
&#13;
</div>&#13;
<p>Our goal is to compare counting with float values against counting with integer values and then applying a scaling factor. We want to define a source that has both sequences as pairs. As an introduction to the concept, we’ll look at generating pairs from two parallel sources. Then we’ll return to the computation shown above.</p>&#13;
<p>In the following example, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">source</code></span></span> object is a generator of the pairs of pure float and int-to-float values:</p>&#13;
<pre id="listing-183" class="lstlisting"><code>from itertools import count &#13;
from collections.abc import Iterator &#13;
from typing import NamedTuple, TypeAlias &#13;
 &#13;
Pair = NamedTuple(’Pair’, [(’flt_count’, float), (’int_count’, float)]) &#13;
Pair_Gen: TypeAlias = Iterator[Pair] &#13;
 &#13;
source: Pair_Gen = ( &#13;
  Pair(fc, ic) for fc, ic in &#13;
  zip(count(0, 0.1), (.1*c for c in count())) &#13;
) &#13;
 &#13;
def not_equal(pair: Pair) -&gt; bool: &#13;
  return abs(pair.flt_count - pair.int_count) &gt; 1.0E-12</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">Pair</code></span></span> tuple will have two float<span id="dx1-173040"/> values: one generated by summing float values, and the other generated by counting<span id="dx1-173041"/> integers and multiplying by a floating-point scaling factor.</p>&#13;
<p>The generator, <span class="obeylines-h"><span class="verb"><code class="inlineCode">source</code></span></span>, has provided a type hint on the assignment statement to show that it iterates over the pairs.</p>&#13;
<p>When we evaluate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">find_first(not_equal,</code><code class="inlineCode"> source)</code></span></span> method, we’ll repeatedly compare float approximations of decimal values until they differ. One is a sum of 0.1 values: 0<span class="italic">.</span>1 <span class="cmsy-10x-x-109">×</span><span class="cmex-10x-x-109">∑</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">∈</span><span class="msbm-10x-x-80">ℕ</span></sub>1. The other is a sum of integer values, weighted by 0.1: <span class="cmex-10x-x-109">∑</span> <sub><span class="cmmi-8">x</span><span class="cmsy-8">∈</span><span class="msbm-10x-x-80">ℕ</span></sub>0<span class="italic">.</span>1. Viewed as abstract mathematical definitions, there’s no distinction.</p>&#13;
<p>We can formalize it as follows:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file66.jpg" class="math-display" alt=" ∑ ∑ 0.1 × 1 ≡ 0.1 x∈ℕ x∈ℕ "/>&#13;
</div>&#13;
<p>With concrete approximations of the abstract numbers, however, the two values will differ. The result is as follows:</p>&#13;
<pre>&gt;&gt;&gt; find_first(not_equal, source)&#13;
Pair(flt_count=92.799999999999, int_count=92.80000000000001)&#13;
</pre>&#13;
<p>After about 928 iterations, the sum of the error bits has accumulated to 10<sup><span class="cmsy-8">−</span><span class="cmr-8">12</span></sup>. Neither value has an exact binary<span id="dx1-173045"/> representation.</p>&#13;
<div id="tcolobox-186" class="packt_tip">&#13;
&#13;
&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">find_first()</code></span></span> function example is close to the Python recursion limit. We’d need to rewrite the function to use tail-call optimization to locate examples with a larger cumulative error value.</p>&#13;
<p>We’ve left this as change as an exercise for the reader.</p>&#13;
&#13;
</div>&#13;
<p>The smallest detectable<span id="dx1-173046"/> difference can be computed as follows:</p>&#13;
<div id="tcolobox-187" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; source: Pair_Gen = map(Pair, count(0, 0.1), (.1*c for c in count())) &#13;
 &#13;
&gt;&gt;&gt; find_first(lambda pair: pair.flt_count != pair.int_count, source) &#13;
Pair(flt_count=0.6, int_count=0.6000000000000001)</code></pre>&#13;
&#13;
</div>&#13;
<p>This uses a simple equality check instead of an error range. After six steps, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">count(0,</code><code class="inlineCode"> 0.1)</code></span></span> method has accumulated a tiny, but measurable, error of 10<sup><span class="cmsy-8">−</span><span class="cmr-8">16</span></sup>. While small, these error values can accumulate to become more significant and visible in a longer computation. When looking at how <img src="../Images/file69.jpg" alt="-1 10"/> is represented as a binary value, an infinite binary expansion would be required. This is truncated to about 10<sup><span class="cmsy-8">−</span><span class="cmr-8">16</span></sup> <span class="cmsy-10x-x-109">≈ </span>2<sup><span class="cmsy-8">−</span><span class="cmr-8">53</span></sup> from the conceptual value. The magic number 53 is the number of bits available in IEEE standard for 64-bit floating-point values.</p>&#13;
<p>This is why we generally count things with ordinary integers and apply a weighting to compute a floating-point value. <span id="x1-173052r180"/></p>&#13;
</section>&#13;
<section id="re-iterating-a-cycle-with-cycle" class="level4 subsectionHead" data-number="0.12.1.3">&#13;
<h4 class="subsectionHead" data-number="0.12.1.3"><span class="titlemark">8.1.3 </span> <span id="x1-1740003"/>Re-iterating a cycle with cycle()</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span> function repeats<span id="dx1-174001"/> a sequence<span id="dx1-174002"/> of values. This can be used when partitioning data into subsets by cycling among the dataset identifiers.</p>&#13;
<p>We can imagine using it to solve silly fizz-buzz problems. Visit <a href="http://rosettacode.org/wiki/FizzBuzz" class="url">http://rosettacode.org/wiki/FizzBuzz</a> for a comprehensive set of solutions to a fairly trivial programming problem. Also see <a href="https://projecteuler.net/problem=1" class="url">https://projecteuler.net/problem=1</a> for an interesting variation on this theme.</p>&#13;
<p>We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span> function to emit sequences of <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> values as follows:</p>&#13;
<div id="tcolobox-188" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from itertools import cycle &#13;
 &#13;
&gt;&gt;&gt; m3 = (i == 0 for i in cycle(range(3))) &#13;
&gt;&gt;&gt; m5 = (i == 0 for i in cycle(range(5)))</code></pre>&#13;
&#13;
</div>&#13;
<p>These two generator expressions can produce infinite sequences with a pattern of <span class="lstinline"><span style="color:#000000"><code class="inlineCode">[</code></span><span style="color:#000000"><code class="inlineCode">True</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">True</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">...]</code></span></span> or <span class="lstinline"><span style="color:#000000"><code class="inlineCode">[</code></span><span style="color:#000000"><code class="inlineCode">True</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">True</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">False</code></span><span style="color:#000000"><code class="inlineCode">,</code></span><span style="color:#000000"> </span><span style="color:#000000"><code class="inlineCode">...]</code></span></span>. These are iterators and can only be consumed once. They will tend to maintain their internal state. If we don’t consume precisely 15 values, the least common multiple of their cycles, the next time we consume values, they will be in an unexpected, in-between state.</p>&#13;
<p>If we zip together a finite collection of numbers and these two derived values, we’ll get a set of three-tuples with a number, the multiple of three true-false condition, and the multiple of five true-false condition. It’s important to introduce a finite iterable to create a proper upper bound on the volume of data being generated. Here’s a sequence of values and their multiplier conditions:</p>&#13;
<div id="tcolobox-189" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; multipliers = zip(range(10), m3, m5)</code></pre>&#13;
&#13;
</div>&#13;
<p>This is a generator; we can use <span class="obeylines-h"><span class="verb"><code class="inlineCode">list(multipliers)</code></span></span> to see the resulting object. It looks like this:</p>&#13;
<pre>&gt;&gt;&gt; list(multipliers)&#13;
[(0, True, True), (1, False, False), (2, False, False), ..., (9, True,&#13;
False)]&#13;
</pre>&#13;
<p>We can now decompose the triples and use a filter to pass numbers that are multiples and reject all others:</p>&#13;
<div id="tcolobox-190" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; multipliers = zip(range(10), m3, m5) &#13;
&gt;&gt;&gt; total = sum(i &#13;
...     for i, *multipliers in multipliers &#13;
...     if any(multipliers) &#13;
... )</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> clause decomposes<span id="dx1-174019"/> each triple into two parts: the value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">i</code></span></span>, and the flags, <span class="obeylines-h"><span class="verb"><code class="inlineCode">multipliers</code></span></span>. If any of the multipliers<span id="dx1-174020"/> are true, the value is passed; otherwise, it’s rejected.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span> function has another, more valuable, use for exploratory data analysis.</p>&#13;
<section id="using-cycle-for-data-sampling" class="level5 likesubsubsectionHead" data-number="0.12.1.3.1">&#13;
<h5 class="likesubsubsectionHead" data-number="0.12.1.3.1"><span id="x1-1750003"/>Using cycle() for data sampling</h5>&#13;
<p>We often need to work with samples<span id="dx1-175001"/> of large sets of data. The initial phases of cleansing and model creation<span id="dx1-175002"/> are best developed with small sets of data and tested with larger and larger sets of data. We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span> function to fairly select rows from within a larger set. This is distinct from making random selections and trusting the fairness of the random number generator. Because this approach is repeatable and doesn’t rely on a random number generator, it can be applied to very large datasets processed by multiple computers.</p>&#13;
<p>Given a population size, <span class="italic">N</span><sub><span class="cmmi-8">p</span></sub>, and the desired sample size, <span class="italic">N</span><sub><span class="cmmi-8">s</span></sub>, this is the required size of the cycle, <span class="italic">c</span>, that will produce appropriate subsets:</p>&#13;
<div class="math-display" style="text-align:center">&#13;
<img src="../Images/file72.jpg" class="math-display" alt="c = Np- Ns "/>&#13;
</div>&#13;
<p>We’ll assume that the data can be parsed with a common library like the <span class="obeylines-h"><span class="verb"><code class="inlineCode">csv</code></span></span> module. This leads to an elegant way to create subsets. Given a value for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle_size</code></span></span> and two open files, <span class="obeylines-h"><span class="verb"><code class="inlineCode">source_file</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">target_file</code></span></span>, we can create subsets using the following function definition:</p>&#13;
<pre id="listing-184" class="lstlisting"><code>from collections.abc import Iterable, Iterator &#13;
from itertools import cycle &#13;
from typing import TypeVar &#13;
DT = TypeVar("DT") &#13;
 &#13;
def subset_iter( &#13;
         source: Iterable[DT], cycle_size: int &#13;
) -&gt; Iterator[DT]: &#13;
    chooser = (x == 0 for x in cycle(range(cycle_size))) &#13;
    yield from ( &#13;
        row &#13;
        for keep, row in zip(chooser, source) &#13;
        if keep &#13;
    )</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">subset_iter()</code></span></span> function uses a <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span> function<span id="dx1-175017"/> based on the selection factor, <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle_size</code></span></span>. For example, we might have a population<span id="dx1-175018"/> of ten million records; a 1,000-record subset would be built with <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle_size</code></span></span> set to <span class="italic">c </span>= <img src="../Images/file73.jpg" class="frac" data-align="middle" alt="107 103"/> = 10<span class="italic">,</span>000. We’d keep one record in ten thousand.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">subset_iter()</code></span></span> function can be used by a function that reads from a source file and writes a subset to a destination file. This processing is part of the following function definition:</p>&#13;
<pre id="listing-185" class="lstlisting"><code>import csv &#13;
from pathlib import Path &#13;
 &#13;
def csv_subset( &#13;
        source: Path, target: Path, cycle_size: int = 3 &#13;
) -&gt; None: &#13;
    with ( &#13;
            source.open() as source_file, &#13;
            target.open(’w’, newline=’’) as target_file &#13;
    ): &#13;
        rdr = csv.reader(source_file, delimiter=’\t’) &#13;
        wtr = csv.writer(target_file) &#13;
        wtr.writerows(subset_iter(rdr, cycle_size))</code></pre>&#13;
<p>We can use this generator<span id="dx1-175032"/> function to filter<span id="dx1-175033"/> the data using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span> function and the source data that’s available from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">csv</code></span></span> reader. Since the chooser expression and the expression used to write the rows are both non-strict, there’s little memory overhead from this kind of processing.</p>&#13;
<p>We can also rewrite this method to use <span class="obeylines-h"><span class="verb"><code class="inlineCode">compress()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> functions, as we’ll see later in this chapter.</p>&#13;
<p>This design can also be used to reformat a file from any non-standard CSV-like format into a standardized CSV format. As long as we define a parser function that returns consistently defined tuples of strings and write consumer functions that write tuples to the target files, we can do a great deal of cleansing and filtering with relatively short, clear scripts. <span id="x1-175034r181"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="repeating-a-single-value-with-repeat" class="level4 subsectionHead" data-number="0.12.1.4">&#13;
<h4 class="subsectionHead" data-number="0.12.1.4"><span class="titlemark">8.1.4 </span> <span id="x1-1760004"/>Repeating a single value with repeat()</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">repeat()</code></span></span> function seems<span id="dx1-176001"/> like an odd feature: it returns a single value over and over again. It can serve as an alternative<span id="dx1-176002"/> for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span> function when a single value is needed.</p>&#13;
<p>The difference between selecting all of the data and selecting a subset of the data can be expressed with this. The expression <span class="obeylines-h"><span class="verb"><code class="inlineCode">(x==0</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> cycle(range(size)))</code></span></span> emits a <span class="obeylines-h"><span class="verb"><code class="inlineCode">[True,</code><code class="inlineCode"> False,</code><code class="inlineCode"> False,</code><code class="inlineCode"> ...]</code></span></span> pattern, suitable for picking a subset. The function <span class="obeylines-h"><span class="verb"><code class="inlineCode">(x==0</code><code class="inlineCode"> for</code><code class="inlineCode"> x</code><code class="inlineCode"> in</code><code class="inlineCode"> repeat(0))</code></span></span> emits a <span class="obeylines-h"><span class="verb"><code class="inlineCode">[True,</code><code class="inlineCode"> True,</code><code class="inlineCode"> True,</code><code class="inlineCode"> ...]</code></span></span> pattern, suitable for selecting all of the data.</p>&#13;
<p>We can think of the following kinds of commands:</p>&#13;
<pre id="listing-186" class="lstlisting"><code>from itertools import cycle, repeat &#13;
 &#13;
def subset_rule_iter( &#13;
        source: Iterable[DT], rule: Iterator[bool] &#13;
) -&gt; Iterator[DT]: &#13;
    return ( &#13;
        v &#13;
        for v, keep in zip(source, rule) &#13;
        if keep &#13;
    ) &#13;
 &#13;
all_rows = lambda: repeat(True) &#13;
subset = lambda n: (i == 0 for i in cycle(range(n)))</code></pre>&#13;
<p>This allows us to make<span id="dx1-176016"/> a single parameter<span id="dx1-176017"/> change, which will either pick all data or pick a subset of data. We can also use <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle([True])</code></span></span> instead of <span class="obeylines-h"><span class="verb"><code class="inlineCode">repeat(True)</code></span></span>; the results are identical.</p>&#13;
<p>This pattern can be extended to randomize the subset chosen. The following technique adds an additional kind of choice:</p>&#13;
<pre id="listing-187" class="lstlisting"><code>import random &#13;
 &#13;
def randomized(limit: int) -&gt; Iterator[bool]: &#13;
    while True: &#13;
        yield random.randrange(limit) == 0</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">randomized()</code></span></span> function generates a potentially infinite sequence of random numbers over a given range. This fits the pattern of <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">repeat()</code></span></span>.</p>&#13;
<p>This allows code such as the following:</p>&#13;
<div id="tcolobox-191" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import random &#13;
&gt;&gt;&gt; random.seed(42) &#13;
&gt;&gt;&gt; data = [random.randint(1, 12) for _ in range(12)] &#13;
&gt;&gt;&gt; data &#13;
[11, 2, 1, 12, 5, 4, 4, 3, 12, 2, 11, 12] &#13;
 &#13;
&gt;&gt;&gt; list(subset_rule_iter(data, all_rows())) &#13;
[11, 2, 1, 12, 5, 4, 4, 3, 12, 2, 11, 12] &#13;
&gt;&gt;&gt; list(subset_rule_iter(data, subset(3))) &#13;
[11, 12, 4, 2] &#13;
 &#13;
&gt;&gt;&gt; random.seed(42) &#13;
&gt;&gt;&gt; list(subset_rule_iter(data, randomized(3))) &#13;
[2, 1, 4, 4, 3, 2]</code></pre>&#13;
&#13;
</div>&#13;
<p>This provides<span id="dx1-176038"/> us the ability<span id="dx1-176039"/> to use a variety of techniques for selecting subsets. A small change among available functions <span class="obeylines-h"><span class="verb"><code class="inlineCode">all()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">subset()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">randomized()</code></span></span> lets us change our sampling approach in a way that seems succinct and expressive. <span id="x1-176040r178"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="using-the-finite-iterators" class="level3 sectionHead" data-number="0.12.2">&#13;
<h3 class="sectionHead" data-number="0.12.2"><span class="titlemark">8.2 </span> <span id="x1-1770002"/>Using the finite iterators</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module provides a number of functions that we can use to produce finite<span id="dx1-177001"/> sequences of values. We’ll look at 10 functions in this module, plus some related built-in functions:</p>&#13;
<ul>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span>: This function is actually<span id="dx1-177002"/> part of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">__builtins__</code></span></span> package, but it works with an iterator and is very similar to functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">accumulate()</code></span></span>: This function<span id="dx1-177003"/> returns a sequence<span id="dx1-177004"/> of reductions of the input iterable. It’s a higher-order function and can do a variety of clever calculations.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">chain()</code></span></span>: This function combines multiple<span id="dx1-177005"/> iterables serially.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span>: This function uses a function<span id="dx1-177006"/> to decompose a single iterable into a sequence of iterables over subsets of the input data.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_longest()</code></span></span>: This function combines elements<span id="dx1-177007"/> from multiple iterables. The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function truncates the sequence at the length of the shortest iterable. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_longest()</code></span></span> function pads the shorter iterables with the given fill value.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">compress()</code></span></span>: This function filters one iterable<span id="dx1-177008"/> based on a second, parallel iterable of Boolean values.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span>: This function is the equivalent<span id="dx1-177009"/> of a slice of a sequence when applied to an iterable.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">dropwhile()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span>: Both of these functions use a Boolean function to filter items<span id="dx1-177010"/> from an iterable. Unlike <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">filterfalse()</code></span></span>, these functions rely on a single <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> value to change<span id="dx1-177011"/> their filter behavior for all subsequent values.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">filterfalse()</code></span></span>: This function applies a filter function<span id="dx1-177012"/> to an iterable. This complements the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function.</p></li>&#13;
<li><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span>: This function maps a function<span id="dx1-177013"/> to an iterable sequence of tuples using each iterable as an <span class="obeylines-h"><span class="verb"><code class="inlineCode">*args</code></span></span> argument to the given function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function does a similar thing using multiple parallel iterables.</p></li>&#13;
</ul>&#13;
<p>We’ll start with functions that could be seen as useful for grouping or arranging items of an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterator</code></span></span>. After that, we’ll look at functions that are more appropriate for filtering and mapping the items. <span id="x1-177014r183"/></p>&#13;
<section id="assigning-numbers-with-enumerate" class="level4 subsectionHead" data-number="0.12.2.1">&#13;
<h4 class="subsectionHead" data-number="0.12.2.1"><span class="titlemark">8.2.1 </span> <span id="x1-1780001"/>Assigning numbers with enumerate()</h4>&#13;
<p>In the <a href="Chapter_04.xhtml#x1-920007"><span class="cmti-10x-x-109">Using enumerate() to include a sequence number</span></a> section of <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we used<span id="dx1-178001"/> the <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function to make a naive assignment of rank numbers to sorted data. We can do things such as pairing up a value with its position in the original sequence, as follows:</p>&#13;
<div id="tcolobox-192" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; raw_values = [1.2, .8, 1.2, 2.3, 11, 18] &#13;
 &#13;
&gt;&gt;&gt; tuple(enumerate(sorted(raw_values))) &#13;
((0, 0.8), (1, 1.2), (2, 1.2), (3, 2.3), (4, 11), (5, 18))</code></pre>&#13;
&#13;
</div>&#13;
<p>This will sort the items in <span class="obeylines-h"><span class="verb"><code class="inlineCode">raw_values</code></span></span> in order, create two-tuples with an ascending sequence of numbers, and materialize an object we can use for further calculations.</p>&#13;
<p>In <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex Stateless Objects</span></a>, we implemented an alternative form of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank()</code></span></span> function, which handles ties in a more statistically useful way.</p>&#13;
<p>Enumerating rows of data is a common feature that is added to a parser to record the source data row numbers. In many cases, we’ll create some kind of <span class="obeylines-h"><span class="verb"><code class="inlineCode">row_iter()</code></span></span> function to extract the string values from a source file. This may iterate over the string values in tags of an XML file or in columns of a CSV file. In some cases, we may even be parsing data presented in an HTML file parsed with Beautiful Soup.</p>&#13;
<p>In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we parsed an XML file to create a simple sequence of position tuples. We then created<span id="dx1-178007"/> legs with a start, end, and distance. We did not, however, assign an explicit leg number. If we ever sorted the trip collection, we’d be unable to determine the original ordering of the legs.</p>&#13;
<p>In <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex Stateless Objects</span></a>, we expanded on the basic parser to create named tuples for each leg of the trip. The output from this enhanced parser looks as follows:</p>&#13;
<div id="tcolobox-193" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from textwrap import wrap &#13;
&gt;&gt;&gt; from pprint import pprint &#13;
 &#13;
&gt;&gt;&gt; trip[0] &#13;
LegNT(start=PointNT(latitude=37.54901619777347, longitude=-76.33029518659048), ... &#13;
 &#13;
&gt;&gt;&gt; pprint(wrap(str(trip[0]))) &#13;
[’LegNT(start=PointNT(latitude=37.54901619777347,’, &#13;
 ’longitude=-76.33029518659048), end=PointNT(latitude=37.840832,’, &#13;
 ’longitude=-76.273834), distance=17.7246)’] &#13;
&gt;&gt;&gt; pprint(wrap(str(trip[-1]))) &#13;
[’LegNT(start=PointNT(latitude=38.330166, longitude=-76.458504),’, &#13;
 ’end=PointNT(latitude=38.976334, longitude=-76.473503),’, &#13;
 ’distance=38.8019)’]</code></pre>&#13;
&#13;
</div>&#13;
<p>The value of <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip[0]</code></span></span> is quite wide, too wide for the book. To keep the output in a form that fits in this book’s pages, we’ve wrapped the string representation of the value, and used <span class="obeylines-h"><span class="verb"><code class="inlineCode">pprint</code></span></span> to show the individual lines. The first <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> object is a short trip between two points on the Chesapeake Bay.</p>&#13;
<p>We can add a function that will build a more complex tuple with the input order information as part of the tuple. First, we’ll define a slightly more complex version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> class:</p>&#13;
<pre id="listing-188" class="lstlisting"><code>from typing import NamedTuple &#13;
 &#13;
class Point(NamedTuple): &#13;
    latitude: float &#13;
    longitude: float &#13;
 &#13;
class Leg(NamedTuple): &#13;
    order: int &#13;
    start: Point &#13;
    end: Point &#13;
    distance: float</code></pre>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> definition is similar to the variations shown in <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex</span> <span class="cmti-10x-x-109">Stateless Objects</span></a>, specifically the <span class="obeylines-h"><span class="verb"><code class="inlineCode">LegNT</code></span></span> definition. We’ll define a function<span id="dx1-178034"/> that decomposes pairs and creates <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> instances as follows:</p>&#13;
<pre id="listing-189" class="lstlisting"><code>from typing import Iterator &#13;
from Chapter04.ch04_ex1 import haversine &#13;
 &#13;
def numbered_leg_iter( &#13;
    pair_iter: Iterator[tuple[Point, Point]] &#13;
) -&gt; Iterator[Leg]: &#13;
    for order, pair in enumerate(pair_iter): &#13;
        start, end = pair &#13;
        yield Leg( &#13;
            order, &#13;
            start, &#13;
            end, &#13;
            round(haversine(start, end), 4) &#13;
        )</code></pre>&#13;
<p>We can use this function to enumerate each pair of start and end points. We’ll decompose the pair and then re-assemble the <span class="obeylines-h"><span class="verb"><code class="inlineCode">order</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">start</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">end</code></span></span> parameters and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">haversine(start,end)</code></span></span> parameter’s value as a single <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> instance. This generator function will work with an iterable sequence of pairs.</p>&#13;
<p>In the context of the preceding explanation, it is used as follows:</p>&#13;
<div id="tcolobox-194" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from Chapter06.ch06_ex3 import row_iter_kml &#13;
&gt;&gt;&gt; from Chapter04.ch04_ex1 import legs, haversine &#13;
&gt;&gt;&gt; import urllib.request &#13;
 &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; with urllib.request.urlopen(source_url) as source: &#13;
...     path_iter = float_lat_lon(row_iter_kml(source)) &#13;
...     pair_iter = legs(path_iter) &#13;
...     trip_iter = numbered_leg_iter(pair_iter) &#13;
...     trip = list(trip_iter)</code></pre>&#13;
&#13;
</div>&#13;
<p>We’ve parsed the original<span id="dx1-178060"/> file into the path points, created start-end pairs, and then created a trip that was built of individual <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> objects. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function ensures that each item in the iterable sequence is given a unique number that increments from the default starting value of 0. A second argument value to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span> function can be given to provide a different starting value. <span id="x1-178061r185"/></p>&#13;
</section>&#13;
<section id="running-totals-with-accumulate" class="level4 subsectionHead" data-number="0.12.2.2">&#13;
<h4 class="subsectionHead" data-number="0.12.2.2"><span class="titlemark">8.2.2 </span> <span id="x1-1790002"/>Running totals with accumulate()</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">accumulate()</code></span></span> function folds a given function<span id="dx1-179001"/> into an iterable, accumulating a series of reductions. This will iterate over the running totals from another iterator; the default function is <span class="obeylines-h"><span class="verb"><code class="inlineCode">operator.add()</code></span></span>. We can provide alternative functions to change the essential behavior from sum to product. The Python library documentation shows a particularly clever use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">max()</code></span></span> function to create a sequence of maximum values so far.</p>&#13;
<p>One application of running totals is quartiling data. The <span class="keyWord">quartile </span>is one of many<span id="dx1-179002"/> measures of position. The general approach is to multiply a sample’s value by a scaling factor to convert it to the quartile number. If values range from 0 <span class="cmsy-10x-x-109">≤ </span><span class="italic">v</span><sub><span class="cmmi-8">i</span></sub> <span class="italic">&lt; N</span>, we can scale by <span class="cmsy-10x-x-109">⌈</span><img src="../Images/file74.jpg" class="frac" data-align="middle" alt="N 4-"/><span class="cmsy-10x-x-109">⌉ </span>to convert any value, <span class="italic">v</span><sub><span class="cmmi-8">i</span></sub>, to a value in the range 0 to 3, which map to the various quartiles. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">math.ceil()</code></span></span> function is used to round the scaling fraction up to the next higher integer. This will ensure that no scaled value will produce a scaled result of 4, an impossible fifth quartile.</p>&#13;
<p>If the minimum value of <span class="italic">v</span><sub><span class="cmmi-8">i</span></sub> is not zero, we’ll need to subtract this from each value before multiplying by the scaling factor.</p>&#13;
<p>In the <a href="#x1-1780001"><span class="cmti-10x-x-109">Assigning numbers with enumerate()</span></a> section, we introduced a sequence of latitude-longitude coordinates that describe a sequence of legs on a voyage. We can use the distances as a basis for quartiling the waypoints. This allows us to determine the midpoint in the trip.</p>&#13;
<p>See the previous<span id="dx1-179003"/> section for the value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip</code></span></span> variable. The value is a sequence of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> instances. Each <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> object has a start point, an end point, and a distance. The calculation of quartiles looks like the following code:</p>&#13;
<div id="tcolobox-195" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from itertools import accumulate &#13;
&gt;&gt;&gt; import math &#13;
 &#13;
&gt;&gt;&gt; distances = (leg.distance for leg in trip) &#13;
&gt;&gt;&gt; distance_accum = list(accumulate(distances)) &#13;
&gt;&gt;&gt; scale = math.ceil(distance_accum[-1] / 4) &#13;
 &#13;
&gt;&gt;&gt; quartiles = list(int(scale*d) for d in distance_accum)</code></pre>&#13;
&#13;
</div>&#13;
<p>We extracted the distance values and computed the accumulated distances for each leg. The last of the accumulated distances is the total. The value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">quartiles</code></span></span> variable is as follows:</p>&#13;
<div id="tcolobox-196" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &#13;
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, &#13;
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, &#13;
3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]</code></pre>&#13;
&#13;
</div>&#13;
<p>We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function to merge this sequence of quartile numbers with the original data points. We can also use functions such as <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> to create distinct collections of the legs in each quartile. <span id="x1-179018r186"/></p>&#13;
</section>&#13;
<section id="combining-iterators-with-chain" class="level4 subsectionHead" data-number="0.12.2.3">&#13;
<h4 class="subsectionHead" data-number="0.12.2.3"><span class="titlemark">8.2.3 </span> <span id="x1-1800003"/>Combining iterators with chain()</h4>&#13;
<p>A collection of iterators<span id="dx1-180001"/> can be unified<span id="dx1-180002"/> into a single sequence of values via the <span class="obeylines-h"><span class="verb"><code class="inlineCode">chain()</code></span></span> function. This can be helpful to combine data that was decomposed via the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function. We can use this to process a number of collections as if they were a single collection.</p>&#13;
<p>Python’s <span class="obeylines-h"><span class="verb"><code class="inlineCode">contextlib</code></span></span> offers a clever class, <span class="obeylines-h"><span class="verb"><code class="inlineCode">ExitStack()</code></span></span>, which can be used to perform a number of operations at the end of the context in a <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement. This permits an application to create any number of sub-contexts, all of which will have a proper <span class="obeylines-h"><span class="verb"><code class="inlineCode">__enter__()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">__exit__()</code></span></span> evaluated. This is particularly useful when we have an indefinite number of files to open.</p>&#13;
<p>In this example, we can combine the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.chain()</code></span></span> function with a <span class="obeylines-h"><span class="verb"><code class="inlineCode">contextlib.ExitStack</code></span></span> object to process—and properly close—a collection of files. Further, the data from all of these files will be processed as a single iterable sequence of values. Instead of wrapping each individual file operation in a <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement, we can wrap all of the operations in a single <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> context.</p>&#13;
<p>We can create a single context for multiple files like this:</p>&#13;
<pre id="listing-190" class="lstlisting"><code>import csv &#13;
from collections.abc import Iterator &#13;
from contextlib import ExitStack &#13;
from pathlib import Path &#13;
from typing import TextIO &#13;
 &#13;
def row_iter_csv_tab(*filepaths: Path) -&gt; Iterator[list[str]]: &#13;
    with ExitStack() as stack: &#13;
        files: list[TextIO] = [ &#13;
            stack.enter_context(path.open()) &#13;
            for path in filepaths &#13;
        ] &#13;
        readers = map( &#13;
            lambda f: csv.reader(f, delimiter=’\t’), &#13;
            files) &#13;
        yield from chain(*readers)</code></pre>&#13;
<p>We’ve created an <span class="obeylines-h"><span class="verb"><code class="inlineCode">ExitStack</code></span></span> object that can contain a number of individual contexts open. When the <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement finishes, all items in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ExitStack</code></span></span> object will be closed properly. In the above function, a sequence<span id="dx1-180019"/> of open file objects is assigned to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">files</code></span></span> variable. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">stack.enter_context()</code></span></span> method enters these objects into the <span class="obeylines-h"><span class="verb"><code class="inlineCode">ExitStack</code></span></span> object to be properly closed.</p>&#13;
<p>Given the sequence<span id="dx1-180020"/> of files in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">files</code></span></span> variable, we created a sequence of CSV readers in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">readers</code></span></span> variable. In this case, all of our files have a common tab-delimited format, which makes it very pleasant to open them with a simple, consistent application of a function to the sequence of files.</p>&#13;
<p>Finally, we chained all of the readers into a single iterator with <span class="obeylines-h"><span class="verb"><code class="inlineCode">chain(*readers)</code></span></span>. This was used to yield the sequence of rows from all of the files.</p>&#13;
<p>It’s important to note that we can’t return the <span class="obeylines-h"><span class="verb"><code class="inlineCode">chain(*readers)</code></span></span> object. If we do, this would exit the <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement context, closing all the source files. Instead, we must yield individual rows from the generator so that the <span class="obeylines-h"><span class="verb"><code class="inlineCode">with</code></span></span> statement context is kept active until all the rows are consumed. <span id="x1-180021r187"/></p>&#13;
</section>&#13;
<section id="partitioning-an-iterator-with-groupby" class="level4 subsectionHead" data-number="0.12.2.4">&#13;
<h4 class="subsectionHead" data-number="0.12.2.4"><span class="titlemark">8.2.4 </span> <span id="x1-1810004"/>Partitioning an iterator with groupby()</h4>&#13;
<p>We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function to partition<span id="dx1-181001"/> an iterator<span id="dx1-181002"/> into smaller iterators. This works by evaluating the given <span class="obeylines-h"><span class="verb"><code class="inlineCode">key</code></span></span> function for each item in the given iterable. If the key value matches the previous item’s key, the two items are part of the same partition. If the key does not match the previous item’s key, the previous partition is ended and a new partition is started. Because the matching is done on adjacent items in the iterable, the values must be sorted by the key.</p>&#13;
<p>The output from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function is a sequence of two-tuples. Each tuple has the group’s key value and an iterable over the items in the group, something like <span class="obeylines-h"><span class="verb"><code class="inlineCode">[(key,</code><code class="inlineCode"> iter(group)),</code><code class="inlineCode"> (key,</code><code class="inlineCode"> iter(group)),</code><code class="inlineCode"> ...]</code></span></span>. Each group’s iterator can then be processed to create a materialized collection, or perhaps reduce it to some summary value.</p>&#13;
<p>In the <a href="#x1-1790002"><span class="cmti-10x-x-109">Running totals with accumulate()</span></a> section, earlier in the chapter, we showed how to compute quartile values for an input sequence. We’ll extend that to create groups based on the distance quartiles. Each group will be an iterator over legs that fit into the range of distances.</p>&#13;
<p>Given the <span class="obeylines-h"><span class="verb"><code class="inlineCode">trip</code></span></span> variable with the raw data and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">quartile</code></span></span> variable with the quartile assignments, we can group the data using<span id="dx1-181003"/> the following<span id="dx1-181004"/> commands:</p>&#13;
<div id="tcolobox-197" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from itertools import groupby &#13;
&gt;&gt;&gt; from Chapter07.ch07_ex1 import get_trip &#13;
 &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; trip = get_trip(source_url) &#13;
&gt;&gt;&gt; quartile = quartiles(trip) &#13;
&gt;&gt;&gt; group_iter = groupby(zip(quartile, trip), key=lambda q_raw: q_raw[0]) &#13;
&gt;&gt;&gt; for group_key, group_iter in group_iter: &#13;
...    print(f"Group {group_key+1}: {len(list(group_iter))} legs") &#13;
Group 1: 23 legs &#13;
Group 2: 14 legs &#13;
Group 3: 19 legs &#13;
Group 4: 17 legs</code></pre>&#13;
&#13;
</div>&#13;
<p>This will start by zipping the quartile numbers with the raw trip data, creating an iterator over two-tuples with quartile number and leg. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function will use the given lambda object to group by the quartile number, <span class="obeylines-h"><span class="verb"><code class="inlineCode">q_raw[0]</code></span></span>, in each <span class="obeylines-h"><span class="verb"><code class="inlineCode">q_raw</code></span></span> tuple. We used a <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement to examine the results of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function. This shows how we get a group key value and an iterator over members of each individual group.</p>&#13;
<p>The input to the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function must be sorted by the key values. This will ensure that all of the items in a group will be adjacent. For very large datasets, this may force us to use the operating system’s sort in the rare cases of a file being too large to fit into memory.</p>&#13;
<p>Note that we can also create groups using a <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict(list)</code></span></span> object. This avoids a sort step, but can build a large, in-memory dictionary of lists. The function can be defined as follows:</p>&#13;
<pre id="listing-191" class="lstlisting"><code>from collections import defaultdict &#13;
from collections.abc import Iterable, Callable, Hashable &#13;
 &#13;
DT = TypeVar("DT") &#13;
KT = TypeVar("KT", bound=Hashable) &#13;
 &#13;
def groupby_2( &#13;
    iterable: Iterable[DT], &#13;
    key: Callable[[DT], KT] &#13;
) -&gt; Iterator[tuple[KT, Iterator[DT]]]: &#13;
    groups: dict[KT, list[DT]] = defaultdict(list) &#13;
    for item in iterable: &#13;
        groups[key(item)].append(item) &#13;
    for g in groups: &#13;
        yield g, iter(groups[g])</code></pre>&#13;
<p>We created a <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict</code></span></span> object that will use <span class="obeylines-h"><span class="verb"><code class="inlineCode">list()</code></span></span> as the default value associated with each new key. The type hints clarify the relationship<span id="dx1-181034"/> between the <span class="obeylines-h"><span class="verb"><code class="inlineCode">key</code></span></span> function, which emits objects of some arbitrary<span id="dx1-181035"/> type associated with the type variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">KT</code></span></span>, and the dictionary, which uses the same type, <span class="obeylines-h"><span class="verb"><code class="inlineCode">KT</code></span></span>, for the keys.</p>&#13;
<p>Each item will have the given <span class="obeylines-h"><span class="verb"><code class="inlineCode">key()</code></span></span> function applied to create a key value. The item is appended to the list in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">defaultdict</code></span></span> object with the given key.</p>&#13;
<p>Once all of the items are partitioned, we can then return each partition as an iterator over the items that share a common key. This will retain all of the original values in memory, and introduce a dictionary and a list for each unique key value. For very large datasets, this may require more memory than is available on the processor.</p>&#13;
<p>The type hints clarify that the source is some arbitrary type, associated with the variable <span class="obeylines-h"><span class="verb"><code class="inlineCode">DT</code></span></span>. The result will be an iterator that includes iterators of the type <span class="obeylines-h"><span class="verb"><code class="inlineCode">DT</code></span></span>. This makes a strong statement that no transformation is happening: the range type matches the input domain type. <span id="x1-181036r188"/></p>&#13;
</section>&#13;
<section id="merging-iterables-with-zip_longest-and-zip" class="level4 subsectionHead" data-number="0.12.2.5">&#13;
<h4 class="subsectionHead" data-number="0.12.2.5"><span class="titlemark">8.2.5 </span> <span id="x1-1820005"/>Merging iterables with zip_longest() and zip()</h4>&#13;
<p>We saw the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_longest()</code></span></span> function differs from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function in an important<span id="dx1-182001"/> way: whereas the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span> function stops at the end of the shortest iterable, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_longest()</code></span></span> function pads short iterables with a given value, and stops at the end of the longest iterable.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">fillvalue=</code></span></span> keyword parameter allows filling with a value other than the default value, <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>.</p>&#13;
<p>For most exploratory data analysis applications, padding with a default value is statistically difficult to justify. The <span class="keyWord">Python Standard Library </span>document includes the <span class="obeylines-h"><span class="verb"><code class="inlineCode">grouper</code></span></span> recipe that can be done with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_longest()</code></span></span> function. It’s difficult to expand on this without drifting far from our focus on data analysis. <span id="x1-182002r189"/></p>&#13;
</section>&#13;
<section id="creating-pairs-with-pairwise" class="level4 subsectionHead" data-number="0.12.2.6">&#13;
<h4 class="subsectionHead" data-number="0.12.2.6"><span class="titlemark">8.2.6 </span> <span id="x1-1830006"/>Creating pairs with pairwise())</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">pairwise()</code></span></span> function consumes<span id="dx1-183001"/> a source iterator, emitting the items in pairs. See the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function in <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, for an example of creating pairs from a source iterable.</p>&#13;
<p>Here’s a small example of transforming a sequence of characters into adjacent pairs of characters:</p>&#13;
<div id="tcolobox-198" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from itertools import pairwise &#13;
 &#13;
&gt;&gt;&gt; text = "hello world" &#13;
&gt;&gt;&gt; list(pairwise(text)) &#13;
[(’h’, ’e’), (’e’, ’l’), (’l’, ’l’), ...]</code></pre>&#13;
&#13;
</div>&#13;
<p>This kind of analysis locates letter pairs, called ”bigrams” or ”digraphs.” This can be helpful when trying to understand a simple letter substitution cipher. The frequency of bigrams in encoded text can suggest possible ways to break the cipher.</p>&#13;
<p>In Python 3.10, this function was moved from being a recipe to being a proper <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> function. <span id="x1-183008r190"/></p>&#13;
</section>&#13;
<section id="filtering-with-compress" class="level4 subsectionHead" data-number="0.12.2.7">&#13;
<h4 class="subsectionHead" data-number="0.12.2.7"><span class="titlemark">8.2.7 </span> <span id="x1-1840007"/>Filtering with compress()</h4>&#13;
<p>The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function uses a predicate to determine whether an item is passed or rejected. Instead of a function<span id="dx1-184001"/> that calculates a value, we can use a second, parallel iterable to determine which items to pass and which to reject.</p>&#13;
<p>In the <a href="#x1-1740003"><span class="cmti-10x-x-109">Re-iterating a cycle with cycle()</span></a> section of this chapter, we looked at data selection using a simple generator expression. Its essence was as follows:</p>&#13;
<pre id="listing-192" class="lstlisting"><code>from typing import TypeVar &#13;
 &#13;
DataT = TypeVar("DataT") &#13;
 &#13;
def subset_gen( &#13;
        data: Iterable[DataT], rule: Iterable[bool] &#13;
) -&gt; Iterator[DataT]: &#13;
    return ( &#13;
        v &#13;
        for v, keep in zip(data, rule) &#13;
        if keep &#13;
    )</code></pre>&#13;
<p>Each value for the rule iterable must be a Boolean value. To choose all items, it can repeat a <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> value. To pick a fixed subset, it can cycle among a <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> value followed by copies of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> value. To pick 1/4 of the items, we could use <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle([True]</code><code class="inlineCode"> +</code><code class="inlineCode"> 3*[False])</code></span></span>.</p>&#13;
<p>The list comprehension can be revised as <span class="obeylines-h"><span class="verb"><code class="inlineCode">compress(some_source,</code><code class="inlineCode"> selectors)</code></span></span>, using a function for the <span class="obeylines-h"><span class="verb"><code class="inlineCode">selectors</code></span></span> argument value. If we make that change, the processing is simplified:</p>&#13;
<div id="tcolobox-199" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import random &#13;
&gt;&gt;&gt; random.seed(1) &#13;
&gt;&gt;&gt; data = [random.randint(1, 12) for _ in range(12)] &#13;
 &#13;
&gt;&gt;&gt; from itertools import compress &#13;
 &#13;
&gt;&gt;&gt; copy = compress(data, all_rows()) &#13;
&gt;&gt;&gt; list(copy) &#13;
[3, 10, 2, 5, 2, 8, 8, 8, 11, 7, 4, 2] &#13;
 &#13;
&gt;&gt;&gt; cycle_subset = compress(data, subset(3)) &#13;
&gt;&gt;&gt; list(cycle_subset) &#13;
[3, 5, 8, 7] &#13;
 &#13;
&gt;&gt;&gt; random.seed(1) &#13;
&gt;&gt;&gt; random_subset = compress(data, randomized(3)) &#13;
&gt;&gt;&gt; list(random_subset) &#13;
[3, 2, 2, 4, 2]</code></pre>&#13;
&#13;
</div>&#13;
<p>These examples<span id="dx1-184033"/> rely on the alternative selection rules <span class="obeylines-h"><span class="verb"><code class="inlineCode">all_rows()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">subset()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">randomized()</code></span></span>, as shown previously. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">subset()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">randomized()</code></span></span> functions must be defined with a proper parameter with the value for <span class="italic">c </span>to pick <img src="../Images/file75.jpg" alt="1 c"/> of the rows from the source. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">selectors</code></span></span> expression must build an iterable over <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> values based on one of the selection rule functions. The rows to be kept are selected by applying the <span class="obeylines-h"><span class="verb"><code class="inlineCode">source</code></span></span> iterable to the row-selection iterable.</p>&#13;
<p>Since all of this is done as a lazy evaluation, rows are not read from the source until required. This allows us to process very large sets of data efficiently. Also, the relative simplicity of the Python code means that we don’t really need a complex configuration file and an associated parser to make choices among the selection rules. We have the option to use this bit of Python code as the configuration for a larger data-sampling application.</p>&#13;
<p>We can think of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function as having the following definition:</p>&#13;
<pre id="listing-193" class="lstlisting"><code>from itertools import compress, tee &#13;
from collections.abc import Iterable, Iterator, Callable &#13;
from typing import TypeVar &#13;
 &#13;
SrcT = TypeVar("SrcT") &#13;
 &#13;
def filter_concept( &#13;
        function: Callable[[SrcT], bool], &#13;
        source: Iterable[SrcT] &#13;
) -&gt; Iterator[SrcT]: &#13;
    i1, i2 = tee(source, 2) &#13;
    return compress(i1, map(function, i2))</code></pre>&#13;
<p>We cloned the iterable using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> function. We’ll look at this function in detail later. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function will generate results of applying the filter predicate function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">function()</code></span></span>, to each value in the iterable, yielding a sequence of <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> values. The sequence of Booleans is used to compress<span id="dx1-184046"/> the original sequence, passing only items associated with <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span>. This builds the features of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">compress()</code></span></span> function.</p>&#13;
<div id="tcolobox-200" class="packt_tip">&#13;
&#13;
&#13;
<p>The function’s hint can be broadened to <span class="obeylines-h"><span class="verb"><code class="inlineCode">Callable[[SrcT],</code><code class="inlineCode"> Any]</code></span></span>. This is because the <span class="obeylines-h"><span class="verb"><code class="inlineCode">compress()</code></span></span> function will make use of the truthiness or falsiness of the values returned. It seems helpful to emphasize that the values will be understood as Booleans, hence the use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">bool</code></span></span> in the type hint, not <span class="obeylines-h"><span class="verb"><code class="inlineCode">Any</code></span></span>.</p>&#13;
&#13;
</div>&#13;
<p><span id="x1-184047r191"/></p>&#13;
</section>&#13;
<section id="picking-subsets-with-islice" class="level4 subsectionHead" data-number="0.12.2.8">&#13;
<h4 class="subsectionHead" data-number="0.12.2.8"><span class="titlemark">8.2.8 </span> <span id="x1-1850008"/>Picking subsets with islice()</h4>&#13;
<p>In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, we looked at slice<span id="dx1-185001"/> notation to select subsets from a collection. Our example<span id="dx1-185002"/> was to pair up items sliced from a list object. The following is a simple list:</p>&#13;
<div id="tcolobox-201" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from Chapter04.ch04_ex5 import parse_g &#13;
 &#13;
&gt;&gt;&gt; with open("1000.txt") as source: &#13;
...    flat = list(parse_g(source)) &#13;
 &#13;
&gt;&gt;&gt; flat[:10] &#13;
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] &#13;
 &#13;
&gt;&gt;&gt; flat[-10:] &#13;
[7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919]</code></pre>&#13;
&#13;
</div>&#13;
<p>We can create pairs using list slices as follows:</p>&#13;
<div id="tcolobox-202" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; list(zip(flat[0::2], flat[1::2])) &#13;
[(2, 3), (5, 7), (11, 13), ...]</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> function gives<span id="dx1-185017"/> us similar capabilities without the overhead of materializing a list object. This will work with an iterable of any size. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> function accepts an <span class="obeylines-h"><span class="verb"><code class="inlineCode">Iterable</code></span></span> source, and the three parameters<span id="dx1-185018"/> that define a slice: the start, stop, and step values. This means <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice(source,</code><code class="inlineCode"> 1,</code><code class="inlineCode"> None,</code><code class="inlineCode"> 2)</code></span></span> is similar to <span class="obeylines-h"><span class="verb"><code class="inlineCode">source[1::2]</code></span></span>. Instead of the slice-like shorthand using <span class="obeylines-h"><span class="verb"><code class="inlineCode">:</code></span></span>, optional parameter values are used; the rules match the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">range()</code></span></span> function. The important difference is that <span class="obeylines-h"><span class="verb"><code class="inlineCode">source[1::2]</code></span></span> only works for a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Sequence</code></span></span> object like a list or tuple. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice(source,</code><code class="inlineCode"> 1,</code><code class="inlineCode"> None,</code><code class="inlineCode"> 2)</code></span></span> function works for any iterable, including an iterator object, or a generator expression.</p>&#13;
<p>The following example will create pairs of values of an iterable using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> function:</p>&#13;
<pre>&gt;&gt;&gt; flat_iter_1 = iter(flat)&#13;
&gt;&gt;&gt; flat_iter_2 = iter(flat)&#13;
&gt;&gt;&gt; pairs = list(zip(&#13;
... islice(flat_iter_1, 0, None, 2),&#13;
... islice(flat_iter_2, 1, None, 2)&#13;
... ))&#13;
&gt;&gt;&gt; len(pairs)&#13;
500&#13;
&gt;&gt;&gt; pairs[:3]&#13;
[(2, 3), (5, 7), (11, 13)]&#13;
&gt;&gt;&gt; pairs[-3:]&#13;
[(7877, 7879), (7883, 7901), (7907, 7919)]&#13;
</pre>&#13;
<p>We created two independent iterators over a collection of data points in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">flat</code></span></span> variable. These could be two separate iterators over an open file or a database result set. The two iterators need to be independent to ensure a change in one <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> source doesn’t interfere with the other <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> source.</p>&#13;
<p>This will produce a sequence of two-tuples from the original sequence:</p>&#13;
<div id="tcolobox-203" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>[(2, 3), (5, 7), (11, 13), (17, 19), (23, 29), &#13;
... &#13;
(7883, 7901), (7907, 7919)]</code></pre>&#13;
&#13;
</div>&#13;
<p>Since <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> works<span id="dx1-185036"/> with an iterable, this kind of design can work with extremely large sets of data. We can use this to pick a subset<span id="dx1-185037"/> out of a larger set of data. In addition to using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">compress()</code></span></span> functions, we can also use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice(source,</code><code class="inlineCode"> 0,</code><code class="inlineCode"> None,</code><code class="inlineCode"> c)</code></span></span> method to pick a <img src="../Images/file78.jpg" alt="1c"/>-sized subset from a larger set of data. <span id="x1-185038r192"/></p>&#13;
</section>&#13;
<section id="stateful-filtering-with-dropwhile-and-takewhile" class="level4 subsectionHead" data-number="0.12.2.9">&#13;
<h4 class="subsectionHead" data-number="0.12.2.9"><span class="titlemark">8.2.9 </span> <span id="x1-1860009"/>Stateful filtering with dropwhile() and takewhile()</h4>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">dropwhile()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> functions are stateful filter functions. They start in one mode; the given predicate function<span id="dx1-186001"/> is a kind of flip-flop that switches the mode. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">dropwhile()</code></span></span> function<span id="dx1-186002"/> starts in reject mode; when the function becomes <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span>, it switches to pass mode. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> function starts in pass mode; when the given function becomes <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span>, it switches to reject mode. Since these are filters, they will consume the entire iterable argument value.</p>&#13;
<p>We can use these to skip header or footer lines in an input file. We use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">dropwhile()</code></span></span> function to reject header rows and pass the remaining data. We use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span> function to pass data and reject trailer rows. We’ll return to the simple GPL file format shown in <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 3</span></a>, <a href="Chapter_03.xhtml#x1-510003"><span class="cmti-10x-x-109">Functions, Iterators, and Generators</span></a>. The file has a header that looks as follows:</p>&#13;
<pre id="listing-194" class="lstlisting"><code>GIMP Palette &#13;
Name: Crayola &#13;
Columns: 16 &#13;
#</code></pre>&#13;
<p>This is followed by rows that look like the following example data:</p>&#13;
<pre id="listing-195" class="lstlisting"><code>255 73 108 Radical Red</code></pre>&#13;
<p>Note that there’s an invisible tab character, <span class="obeylines-h"><span class="verb"><code class="inlineCode">\t</code></span></span>, between the RGB color triple and the color name. To make it more visible, we can typeset the example like this:</p>&#13;
<pre id="listing-196" class="lstlisting"><code>255 73 108\tRadical Red</code></pre>&#13;
<p>This little typesetting<span id="dx1-186009"/> technique seems a little misleading, since it doesn’t look like that in most programming<span id="dx1-186010"/> editors.</p>&#13;
<p>We can locate the final line of the headers—the # line—using a parser based on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">dropwhile()</code></span></span> function, as follows:</p>&#13;
<div id="tcolobox-204" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; import csv &#13;
&gt;&gt;&gt; from pathlib import Path &#13;
 &#13;
&gt;&gt;&gt; source_path = Path("crayola.gpl") &#13;
&gt;&gt;&gt; with source_path.open() as source: &#13;
...     rdr = csv.reader(source, delimiter=’\\t’) &#13;
...     row_iter = dropwhile( &#13;
...         lambda row: row[0] != ’#’, rdr &#13;
...     ) &#13;
...     color_rows = islice(row_iter, 1, None) &#13;
...     colors = list( &#13;
...         (color.split(), name) for color, name in color_rows &#13;
...     )</code></pre>&#13;
&#13;
</div>&#13;
<p>We created a CSV reader to parse the lines based on tab characters. This will neatly separate the <span class="obeylines-h"><span class="verb"><code class="inlineCode">color</code></span></span> three-tuple from the name. The three-tuple will need further parsing. This will produce an iterator that starts with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">#</code></span></span> line and continues with the rest of the file.</p>&#13;
<p>We can use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> function to discard the first item of an iterable. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice(rows,</code><code class="inlineCode"> 1,</code><code class="inlineCode"> None)</code></span></span> expression is similar to asking for a <span class="obeylines-h"><span class="verb"><code class="inlineCode">rows[1:]</code></span></span> slice: the first item is quietly discarded. Once the last of the heading rows have been discarded, we can parse the color tuples and return more useful color objects.</p>&#13;
<p>For this particular<span id="dx1-186025"/> file, we can also use the number<span id="dx1-186026"/> of columns located by the CSV <span class="obeylines-h"><span class="verb"><code class="inlineCode">reader()</code></span></span> function. Header rows only have a single column, allowing the use of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">dropwhile(lambda</code><code class="inlineCode"> row:</code><code class="inlineCode"> len(row)</code><code class="inlineCode"> ==</code><code class="inlineCode"> 1,</code><code class="inlineCode"> rdr)</code></span></span> expression to discard header rows. This isn’t a good approach in general, because locating the last line of the headers is often easier than trying to define some general pattern that distinguishes all header (or trailer) lines from the meaningful file content. In this case, the header rows were distinguishable by the number of columns; this is a rarity. <span id="x1-186027r193"/></p>&#13;
</section>&#13;
<section id="two-approaches-to-filtering-with-filterfalse-and-filter" class="level4 subsectionHead" data-number="0.12.2.10">&#13;
<h4 class="subsectionHead" data-number="0.12.2.10"><span class="titlemark">8.2.10 </span> <span id="x1-18700010"/>Two approaches to filtering with filterfalse() and filter()</h4>&#13;
<p>In <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 5</span></a>, <a href="Chapter_05.xhtml#x1-1000005"><span class="cmti-10x-x-109">Higher-Order Functions</span></a>, we looked<span id="dx1-187001"/> at the built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">filterfalse()</code></span></span> function from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module could be defined from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function, as follows:</p>&#13;
<pre id="listing-197" class="lstlisting"><code>filterfalse_concept = ( &#13;
    lambda pred, iterable: &#13;
    filter(lambda x: not pred(x), iterable) &#13;
)</code></pre>&#13;
<p>As with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span> function, the predicate function<span id="dx1-187006"/> can be the <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> value. The value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter(None,</code><code class="inlineCode"> iterable)</code></span></span> method is all the <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> values in the iterable. The value of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filterfalse(None,</code><code class="inlineCode"> iterable)</code></span></span> method is all the <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> values from the iterable:</p>&#13;
<div id="tcolobox-205" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from itertools import filterfalse &#13;
 &#13;
&gt;&gt;&gt; source = [0, False, 1, 2] &#13;
&gt;&gt;&gt; list(filter(None, source)) &#13;
[1, 2] &#13;
 &#13;
&gt;&gt;&gt; filterfalse(None, source) &#13;
&lt;itertools.filterfalse object at ...&gt; &#13;
&gt;&gt;&gt; list(_) &#13;
[0, False]</code></pre>&#13;
&#13;
</div>&#13;
<p>The point of having the <span class="obeylines-h"><span class="verb"><code class="inlineCode">filterfalse()</code></span></span> function is to promote reuse. If we have a succinct function that makes a filter decision, we should be able to use that function to partition input to pass as well as reject groups without<span id="dx1-187018"/> having to fiddle around<span id="dx1-187019"/> with logical negation.</p>&#13;
<p>The idea is to execute the following commands:</p>&#13;
<div id="tcolobox-206" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; iter_1, iter_2 = tee(iter(raw_samples), 2) &#13;
 &#13;
&gt;&gt;&gt; rule_subset_iter = filter(rule, iter_1) &#13;
&gt;&gt;&gt; not_rule_subset_iter = filterfalse(rule, iter_2)</code></pre>&#13;
&#13;
</div>&#13;
<p>This kind of processing into two subsets will include all items from the source. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">rule()</code></span></span> function is unchanged, and we can’t introduce a subtle logic bug through improper negation of this function. <span id="x1-187025r194"/></p>&#13;
</section>&#13;
<section id="applying-a-function-to-data-via-starmap-and-map" class="level4 subsectionHead" data-number="0.12.2.11">&#13;
<h4 class="subsectionHead" data-number="0.12.2.11"><span class="titlemark">8.2.11 </span> <span id="x1-18800011"/>Applying a function to data via starmap() and map()</h4>&#13;
<p>The built-in <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function is a higher-order function<span id="dx1-188001"/> that applies a function to items from an iterable. We can think of the simple version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function as follows:</p>&#13;
<pre id="listing-198" class="lstlisting"><code>map_concept = ( &#13;
    lambda function, arg_iter: &#13;
    (function(a) for a in arg_iter) &#13;
)</code></pre>&#13;
<p>This works well when the <span class="obeylines-h"><span class="verb"><code class="inlineCode">arg_iter</code></span></span> parameter is an iterable that provides individual values. The actual <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function<span id="dx1-188006"/> is quite a bit more sophisticated than this, and can also work with a number of iterables.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module is the <span class="obeylines-h"><span class="verb"><code class="inlineCode">*args</code></span></span> version of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function. We can imagine the definition as follows:</p>&#13;
<pre id="listing-199" class="lstlisting"><code>starmap_concept = ( &#13;
    lambda function, arg_iter: &#13;
    (function(*a) for a in arg_iter) &#13;
             #^-- Adds this * to decompose tuples &#13;
)</code></pre>&#13;
<p>This reflects a small shift in the semantics<span id="dx1-188012"/> of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function to properly handle an iterable-of-tuples structure. Each tuple is decomposed and applied to the various positional parameters.</p>&#13;
<p>When we look at the trip data, from the preceding<span id="dx1-188013"/> commands, we can redefine the construction of a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> object based on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function.</p>&#13;
<p>We could use the <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function to assemble the <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> objects, as follows:</p>&#13;
<pre id="listing-200" class="lstlisting"><code>from Chapter04.ch04_ex1 import legs, haversine &#13;
from Chapter06.ch06_ex3 import row_iter_kml &#13;
from Chapter07.ch07_ex1 import float_lat_lon, LegNT, PointNT &#13;
import urllib.request &#13;
from collections.abc import Callable &#13;
 &#13;
def get_trip_starmap(url: str) -&gt; List[LegNT]: &#13;
    make_leg: Callable[[PointNT, PointNT], LegNT] = ( &#13;
        lambda start, end: &#13;
        LegNT(start, end, haversine(start, end)) &#13;
    ) &#13;
    with urllib.request.urlopen(url) as source: &#13;
        path_iter = float_lat_lon( &#13;
            row_iter_kml(source) &#13;
        ) &#13;
        pair_iter = legs(path_iter) &#13;
        trip = list(starmap(make_leg, pair_iter)) &#13;
                   #-------- Used here &#13;
    return trip</code></pre>&#13;
<p>Here’s how it looks when we apply this <span class="obeylines-h"><span class="verb"><code class="inlineCode">get_trip_starmap()</code></span></span> function to read source data and iterate over the created <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> objects:</p>&#13;
<div id="tcolobox-207" class="tcolorbox tcolorbox">&#13;
&#13;
&#13;
<pre class="lstinputlisting"><code>&gt;&gt;&gt; from pprint import pprint &#13;
&gt;&gt;&gt; source_url = "file:./Winter%202012-2013.kml" &#13;
&gt;&gt;&gt; trip = get_trip_starmap(source_url) &#13;
&gt;&gt;&gt; len(trip) &#13;
73 &#13;
&gt;&gt;&gt; pprint(trip[0]) &#13;
LegNT(start=PointNT(latitude=37.54901619777347, longitude=-76.33029518659048), end=PointNT(latitude=37.840832, longitude=-76.273834), distance=17.724564798884984) &#13;
 &#13;
&gt;&gt;&gt; pprint(trip[-1]) &#13;
LegNT(start=PointNT(latitude=38.330166, longitude=-76.458504), end=PointNT(latitude=38.976334, longitude=-76.473503), distance=38.801864781785845)</code></pre>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">make_leg()</code></span></span> function accepts a pair of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> objects, and returns a <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> object with the start point, end point, and distance between the two points. The <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function from <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, creates pairs of <span class="obeylines-h"><span class="verb"><code class="inlineCode">Point</code></span></span> objects that reflect the start and end of a leg of the voyage. The pairs created by <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> are provided as input to <span class="obeylines-h"><span class="verb"><code class="inlineCode">make_leg()</code></span></span> to create proper <span class="obeylines-h"><span class="verb"><code class="inlineCode">Leg</code></span></span> objects.</p>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> function can also accept<span id="dx1-188044"/> multiple iterables. When we use <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(f,</code><code class="inlineCode"> iter1,</code><code class="inlineCode"> iter2,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">...)</code></span></span>, it behaves as if the iterators<span id="dx1-188045"/> are zipped together, and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span> function is applied.</p>&#13;
<p>We can think of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(function,</code><code class="inlineCode"> iter1,</code><code class="inlineCode"> iter2,</code><code class="inlineCode"> iter3)</code></span></span> function as if it were <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap(function,</code><code class="inlineCode"> zip(iter1,</code><code class="inlineCode"> iter2,</code><code class="inlineCode"> iter3))</code></span></span>.</p>&#13;
<p>The benefit of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap(function,</code><code class="inlineCode"> some_list)</code></span></span> method is to replace a potentially wordy <span class="obeylines-h"><span class="verb"><code class="inlineCode">(function(*args)</code><code class="inlineCode"> for</code><code class="inlineCode"> args</code><code class="inlineCode"> in</code><code class="inlineCode"> some_list)</code></span></span> generator expression with something that avoids the potentially overlooked <span class="obeylines-h"><span class="verb"><code class="inlineCode">*</code></span></span> operator applied to the function argument values. <span id="x1-188046r184"/></p>&#13;
</section>&#13;
</section>&#13;
<section id="cloning-iterators-with-tee" class="level3 sectionHead" data-number="0.12.3">&#13;
<h3 class="sectionHead" data-number="0.12.3"><span class="titlemark">8.3 </span> <span id="x1-1890003"/>Cloning iterators with tee()</h3>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> function<span id="dx1-189001"/> gives us a way to circumvent<span id="dx1-189002"/> one of the important Python rules for working with iterables. The rule is so important, we’ll repeat it here:</p>&#13;
<div id="tcolobox-208" class="packt_tip">&#13;
&#13;
&#13;
<p>Iterators can be used only once.</p>&#13;
&#13;
</div>&#13;
<p>The <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> function allows us to clone an iterator. This seems to free us from having to materialize a sequence so that we can make multiple passes over the data. Because <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> can use a lot of memory, it is sometimes better to materialize a list and process it multiple times, rather than trying to use the potential simplification of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> function.</p>&#13;
<p>For example, a simple average for an immense dataset could be written in the following way:</p>&#13;
<pre id="listing-201" class="lstlisting"><code>from collections.abc import Iterable &#13;
 &#13;
def mean_t(source: Iterable[float]) -&gt; float: &#13;
    it_0, it_1 = tee(iter(source), 2) &#13;
    N = sum(1 for x in it_0) &#13;
    sum_x = sum(x for x in it_1) &#13;
    return sum_x/N</code></pre>&#13;
<p>This would compute an average without appearing to materialize the entire dataset in memory. Note that the type hint of <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> doesn’t preclude integers. The <span class="keyWord">mypy </span>program is aware of the numeric processing rules, and this definition provides a flexible way to specify that either <span class="obeylines-h"><span class="verb"><code class="inlineCode">int</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">float</code></span></span> will work. <span id="x1-189010r196"/></p>&#13;
</section>&#13;
<section id="the-itertools-recipes" class="level3 sectionHead" data-number="0.12.4">&#13;
<h3 class="sectionHead" data-number="0.12.4"><span class="titlemark">8.4 </span> <span id="x1-1900004"/>The itertools recipes</h3>&#13;
<p>Within the <span class="cmti-10x-x-109">itertools </span>chapter of the Python library documentation, there’s a subsection called <span class="cmti-10x-x-109">Itertools Recipes</span>, which contains<span id="dx1-190001"/> outstanding examples of ways to use the various <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> functions. Since there’s no reason to reproduce these, we’ll reference them here. They should be considered as required reading on functional programming in Python.</p>&#13;
<p>For more information, visit <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes">https://docs.python.org/3/library/itertools.html#itertools-recipes</a>.</p>&#13;
<p>It’s important<span id="dx1-190002"/> to note that these aren’t importable functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> modules. A recipe needs to be read and understood and then, perhaps, copied or modified before it’s included in an application.</p>&#13;
<p>Some of the recipes involve some of the more advanced techniques shown in the next chapter; they’re not in the following table. We’ve preserved the ordering of items in the Python documentation, which is not alphabetical. The following table summarizes some of the recipes that show functional programming design patterns built from the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> basics: <span id="x1-190003r1"/></p>&#13;
<div class="longtable">&#13;
<table id="TBL-3" class="longtable">&#13;
<tbody>&#13;
<tr id="TBL-3-1-" class="odd" style="vertical-align:baseline;">&#13;
<td colspan="3" id="TBL-3-1-1" class="td11" style="text-align: left; white-space: normal;"><span class="cmidrule"/></td>&#13;
</tr>&#13;
<tr id="TBL-3-2-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-2-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="keyWord">Function</span> <span class="keyWord">Name</span></p>&#13;
</td>&#13;
<td id="TBL-3-2-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="keyWord">Arguments</span></p>&#13;
</td>&#13;
<td id="TBL-3-2-3" class="td11" style="text-align: left; white-space: normal;"><p><span class="keyWord">Results</span></p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-3-" class="odd" style="vertical-align:baseline;">&#13;
<td colspan="3" id="TBL-3-3-1" class="td11" style="text-align: left; white-space: normal;"><span class="cmidrule"/></td>&#13;
</tr>&#13;
<tr id="TBL-3-4-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-4-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-3-5-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-5-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td id="TBL-3-5-2" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td id="TBL-3-5-3" class="td11" style="text-align: left; white-space: normal;"/>&#13;
</tr>&#13;
<tr id="TBL-3-6-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-6-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">take</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-6-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(n,</code><code class="inlineCode"> iterable)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-6-3" class="td11" style="text-align: left; white-space: normal;"><p>Yields the first <span class="cmti-10x-x-109">n </span>items of the iterable as a list. This wraps a use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> in a simple name.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-7-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-7-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">tabulate</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-7-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(function,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">start=0)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-7-3" class="td11" style="text-align: left; white-space: normal;"><p>Yields <span class="obeylines-h"><span class="verb"><code class="inlineCode">function(0)</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">function(1)</code></span></span>, and so on. This is based on a <span class="obeylines-h"><span class="verb"><code class="inlineCode">map(function,</code><code class="inlineCode"> count())</code></span></span>.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-8-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-8-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">consume</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-8-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterator,</code><code class="inlineCode"> n)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-8-3" class="td11" style="text-align: left; white-space: normal;"><p>Advance the iterator <span class="cmti-10x-x-109">n </span>steps ahead. If <span class="cmti-10x-x-109">n </span>is <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span>, it consumes all of the values from the iterator.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-9-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-9-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">nth</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-9-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable,</code><code class="inlineCode"> n,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">default=None)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-9-3" class="td11" style="text-align: left; white-space: normal;"><p>Return only the <span class="cmti-10x-x-109">n</span>th item or a default value. This wraps the use of <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span> in a simple name.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-10-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-10-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">quantify</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-10-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">pred=bool)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-10-3" class="td11" style="text-align: left; white-space: normal;"><p>Returns the count of how many times the predicate is true. This uses <span class="obeylines-h"><span class="verb"><code class="inlineCode">sum()</code></span></span> and <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span> and relies on the way a Boolean predicate is effectively 1 when converted to an integer value.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-11-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-11-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">padnone</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-11-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-11-3" class="td11" style="text-align: left; white-space: normal;"><p>Yields the iterable’s elements and then yields <span class="obeylines-h"><span class="verb"><code class="inlineCode">None</code></span></span> indefinitely. This can create functions that behave like <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_longest()</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span>.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-12-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-12-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">ncycles</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-12-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable,</code><code class="inlineCode"> n)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-12-3" class="td11" style="text-align: left; white-space: normal;"><p>Yields the sequence elements <span class="cmti-10x-x-109">n</span> times.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-13-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-13-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">dotproduct</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-13-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(vec1,</code><code class="inlineCode"> vec2)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-13-3" class="td11" style="text-align: left; white-space: normal;"><p>A dot product multiplies two vector’s values and finds the sum of the result.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-14-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-14-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">flatten</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-14-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(listOfLists)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-14-3" class="td11" style="text-align: left; white-space: normal;"><p>This function flattens one level of nesting. This chains the various lists together into a single list.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-15-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-15-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">repeatfunc</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-15-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(func,</code><code class="inlineCode"> times=</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">None,</code><code class="inlineCode"> *args)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-15-3" class="td11" style="text-align: left; white-space: normal;"><p>This calls the given function, <span class="obeylines-h"><span class="verb"><code class="inlineCode">func</code></span></span>, repeatedly with specified arguments.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-16-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-16-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">grouper</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-16-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable,</code><code class="inlineCode"> n,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">fillvalue=None)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-16-3" class="td11" style="text-align: left; white-space: normal;"><p>Yields the iterable’s elements as a sequence of fixed-length chunks or blocks.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-17-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-17-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">roundrobin</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-17-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(*iterables)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-17-3" class="td11" style="text-align: left; white-space: normal;"><p>Yields values taken from each of the iterables. For example, <span class="obeylines-h"><span class="verb"><code class="inlineCode">roundrobin(’ABC’,</code><code class="inlineCode"> ’D’,</code><code class="inlineCode"> ’EF’)</code></span></span> is <span class="obeylines-h"><span class="verb"><code class="inlineCode">’A’,</code><code class="inlineCode"> ’D’,</code><code class="inlineCode"> ’E’,</code><code class="inlineCode"> ’B’,</code><code class="inlineCode"> ’F’,</code><code class="inlineCode"> ’C’</code></span></span>.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-18-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-18-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">partition</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-18-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(pred,</code><code class="inlineCode"> iterable)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-18-3" class="td11" style="text-align: left; white-space: normal;"><p>This uses a predicate to partition entries into <span class="obeylines-h"><span class="verb"><code class="inlineCode">False</code></span></span> entries and <span class="obeylines-h"><span class="verb"><code class="inlineCode">True</code></span></span> entries. The return value is a pair of iterators.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-19-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-19-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">unique_everseen</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-19-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=None)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-19-3" class="td11" style="text-align: left; white-space: normal;"><p>Yields the unique elements of the source iterable, preserving order. It also remembers all elements ever seen.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-20-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-20-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">unique_justseen</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-20-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(iterable,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">key=None)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-20-3" class="td11" style="text-align: left; white-space: normal;"><p>Yields unique elements, preserving order. It remembers only the element most recently seen. This is useful for deduplicating or grouping a sorted sequence.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-21-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-21-1" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">iter_except</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-21-2" class="td11" style="text-align: left; white-space: normal;"><p><span class="obeylines-h"><span class="verb"><code class="inlineCode">(func,</code><code class="inlineCode"> exception,</code></span></span> <span class="obeylines-h"><span class="verb"><code class="inlineCode">first=None)</code></span></span></p>&#13;
</td>&#13;
<td id="TBL-3-21-3" class="td11" style="text-align: left; white-space: normal;"><p>Yields results of calling a function repeatedly until an exception is raised. The exception is silenced. This can be used to iterate until <span class="obeylines-h"><span class="verb"><code class="inlineCode">KeyError</code></span></span> or <span class="obeylines-h"><span class="verb"><code class="inlineCode">IndexError</code></span></span>.</p>&#13;
</td>&#13;
</tr>&#13;
<tr id="TBL-3-22-" class="even" style="vertical-align:baseline;">&#13;
<td colspan="3" id="TBL-3-22-1" class="td11" style="text-align: left; white-space: normal;"><span class="cmidrule"/></td>&#13;
</tr>&#13;
<tr id="TBL-3-23-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-23-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-3-24-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-24-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-3-25-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-25-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-3-26-" class="even" style="vertical-align:baseline;">&#13;
<td id="TBL-3-26-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
<tr id="TBL-3-27-" class="odd" style="vertical-align:baseline;">&#13;
<td id="TBL-3-27-1" class="td11" style="text-align: left; white-space: normal;"/>&#13;
<td style="text-align: left;"/>&#13;
<td style="text-align: left;"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<p><span id="x1-190004r197"/></p>&#13;
</section>&#13;
<section id="summary-7" class="level3 sectionHead" data-number="0.12.5">&#13;
<h3 class="sectionHead" data-number="0.12.5"><span class="titlemark">8.5 </span> <span id="x1-1910005"/>Summary</h3>&#13;
<p>In this chapter, we’ve looked at a number of functions in the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module. This library module helps us to work with iterators in sophisticated ways.</p>&#13;
<p>We’ve looked at the infinite iterators; they repeat without terminating. They include the <span class="obeylines-h"><span class="verb"><code class="inlineCode">count()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">cycle()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">repeat()</code></span></span> functions. Since they don’t terminate, the consuming function must determine when to stop accepting values.</p>&#13;
<p>We’ve also looked at a number of finite iterators. Some of them are built-in, and some of them are a part of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module. They work with a source iterable, so they terminate when that iterable is exhausted. These functions include <span class="obeylines-h"><span class="verb"><code class="inlineCode">enumerate()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">accumulate()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">chain()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip_longest()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">zip()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">pairwise()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">compress()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">islice()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">dropwhile()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">takewhile()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">filterfalse()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">filter()</code></span></span>, <span class="obeylines-h"><span class="verb"><code class="inlineCode">starmap()</code></span></span>, and <span class="obeylines-h"><span class="verb"><code class="inlineCode">map()</code></span></span>. These functions allow us to replace possibly complex generator expressions with simpler-looking functions.</p>&#13;
<p>We’ve noted that functions like the <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> function are available, and can create a helpful simplification. It has the potential cost of using a great deal of memory, and needs to be considered carefully. In some cases, materializing a list may be more efficient than applying the <span class="obeylines-h"><span class="verb"><code class="inlineCode">tee()</code></span></span> function.</p>&#13;
<p>Additionally, we looked at the recipes from the documentation, which provide yet more functions we can study and copy for our own applications. The recipes list shows a wealth of common design patterns.</p>&#13;
<p>In <a href="Chapter_09.xhtml#x1-1990009"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 9</span></a>, <a href="Chapter_09.xhtml#x1-1990009"><span class="cmti-10x-x-109">Itertools for Combinatorics – Permutations and Combinations</span></a>, we’ll continue our study of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> module, focusing on permutations and combinations. These operations can produce voluminous results. For example, enumerating all possible 5-card hands from a deck of 52 cards will yield over 3<span class="italic">.</span>12 <span class="cmsy-10x-x-109">× </span>10<sup><span class="cmr-8">8</span></sup> permutations. For small domains, however, it can be helpful to examine all possible orderings to understand how well observed samples match the domain of possible values. <span id="x1-191001r198"/></p>&#13;
</section>&#13;
<section id="exercises-7" class="level3 sectionHead" data-number="0.12.6">&#13;
<h3 class="sectionHead" data-number="0.12.6"><span class="titlemark">8.6 </span> <span id="x1-1920006"/>Exercises</h3>&#13;
<p>This chapter’s exercises are based on code available from Packt Publishing on GitHub. See <a href="https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition" class="url">https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition</a>.</p>&#13;
<p>In some cases, the reader will notice that the code provided on GitHub includes partial solutions to some of the exercises. They serve as hints, allowing the reader to explore alternative solutions.</p>&#13;
<p>In many cases, exercises will need unit test cases to confirm they actually solve the problem. These are often identical to the unit test cases already provided in the GitHub repository. The reader should replace the book’s example function name with their own solution to confirm that it works. <span id="x1-192001r195"/></p>&#13;
<section id="optimize-the-find_first-function" class="level4 subsectionHead" data-number="0.12.6.1">&#13;
<h4 class="subsectionHead" data-number="0.12.6.1"><span class="titlemark">8.6.1 </span> <span id="x1-1930001"/>Optimize the find_first() function</h4>&#13;
<p>In <a href="#x1-1730002"><span class="cmti-10x-x-109">Counting with float arguments</span></a>, we defined a <span class="obeylines-h"><span class="verb"><code class="inlineCode">find_first()</code></span></span> function to locate the first pair of an iterator that passed a given test criteria. In most of the examples, the test was a comparison between values to see if the difference between the values was larger than 10<sup><span class="cmsy-8">−</span><span class="cmr-8">12</span></sup>.</p>&#13;
<p>The definition of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">find_first()</code></span></span> function used a simpler recursion. This limits the size of the iterable that can be examined: only about 1,000 values can be consumed before hitting the stack size limitation.</p>&#13;
<p>First, create a comparison function that will consume enough values to fail with a recursion limit exception.</p>&#13;
<p>Then, rewrite the <span class="obeylines-h"><span class="verb"><code class="inlineCode">find_first()</code></span></span> function to replace the tail call with iteration using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">for</code></span></span> statement.</p>&#13;
<p>Using the comparison function found earlier, demonstrate that the revised function will readily pass 1,000 elements, looking for the first that matches the revised criteria. <span id="x1-193001r200"/></p>&#13;
</section>&#13;
<section id="compare-chapter-4-with-the-itertools.pairwise-recipe" class="level4 subsectionHead" data-number="0.12.6.2">&#13;
<h4 class="subsectionHead" data-number="0.12.6.2"><span class="titlemark">8.6.2 </span> <span id="x1-1940002"/>Compare Chapter 4 with the itertools.pairwise() recipe</h4>&#13;
<p>In <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working with Collections</span></a>, the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function created overlapping pairs from a source iterable. Compare the implementation provided in this book with the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pairwise()</code></span></span> function.</p>&#13;
<p>Create a very, very large iterable and compare the performance of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">legs()</code></span></span> function and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">pairwise()</code></span></span> function. Which is faster? <span id="x1-194001r201"/></p>&#13;
</section>&#13;
<section id="compare-chapter-4-with-itertools.tee-recipe" class="level4 subsectionHead" data-number="0.12.6.3">&#13;
<h4 class="subsectionHead" data-number="0.12.6.3"><span class="titlemark">8.6.3 </span> <span id="x1-1950003"/>Compare Chapter 4 with itertools.tee() recipe</h4>&#13;
<p>In the <a href="Chapter_04.xhtml#x1-850001"><span class="cmti-10x-x-109">Using sums and counts for statistics</span></a> section of <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 4</span></a>, <a href="Chapter_04.xhtml#x1-740004"><span class="cmti-10x-x-109">Working</span> <span class="cmti-10x-x-109">with Collections</span></a>, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean()</code></span></span> function was defined that had a limitation of only working with sequences. If <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.tee()</code></span></span> is used, a <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean()</code></span></span> function can be written that will apply to iterators in general, without being limited to collection objects that can produce multiple iterators. Define a <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean_i()</code></span></span> function based on the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.tee()</code></span></span> function that works with any iterator. Which variant of mean computations is easier to understand?</p>&#13;
<p>Create a very, very large iterable and compare the performance of the <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean_i()</code></span></span> function and the <span class="obeylines-h"><span class="verb"><code class="inlineCode">mean()</code></span></span> function shown in the text. Which is faster? It takes some time to explore, but locating a collection that breaks the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.tee()</code></span></span> function while still working with a materialized list object is an interesting thing to find. <span id="x1-195001r202"/></p>&#13;
</section>&#13;
<section id="splitting-a-dataset-for-training-and-testing-purposes" class="level4 subsectionHead" data-number="0.12.6.4">&#13;
<h4 class="subsectionHead" data-number="0.12.6.4"><span class="titlemark">8.6.4 </span> <span id="x1-1960004"/>Splitting a dataset for training and testing purposes</h4>&#13;
<p>Given a pool of samples, it’s sometimes necessary to partition the data into a subset used for building (or “training”) a model, and a separate subset used to test the model’s predictive ability. It’s common practice to use subsets of 20%, 25%, or even 33% of the source data for testing. Develop a set of functions to partition the data into subsets with ratios of 1 : 3, 1 : 4, or 1 : 5 for test <span class="cmti-10x-x-109">vs.</span> training data. <span id="x1-196001r203"/></p>&#13;
</section>&#13;
<section id="rank-ordering" class="level4 subsectionHead" data-number="0.12.6.5">&#13;
<h4 class="subsectionHead" data-number="0.12.6.5"><span class="titlemark">8.6.5 </span> <span id="x1-1970005"/>Rank ordering</h4>&#13;
<p>In <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex Stateless Objects</span></a>, we looked at ranking items in a set of data. The approach shown in that chapter was to build a dictionary of items with the same key value. This made it possible to create a rank that was the mean of the various items. For example, the sequence <span class="obeylines-h"><span class="verb"><code class="inlineCode">[0.8,</code><code class="inlineCode"> 1.2,</code><code class="inlineCode"> 1.2,</code><code class="inlineCode"> 2.3,</code><code class="inlineCode"> 18]</code></span></span> should have rank values of 1, 2.5, 2.5, 4, 5. The two matching key values in positions 1 and 2 of the sequence should have the midpoint value of 2.5 as their common rank.</p>&#13;
<p>This can be computed using <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.groupby()</code></span></span>. Each group will have some number of members, provided by the <span class="obeylines-h"><span class="verb"><code class="inlineCode">groupby()</code></span></span> function. The sequence of rank values for a group of <span class="italic">n </span>items with matching keys is <span class="italic">r</span><sub><span class="cmr-8">0</span></sub><span class="italic">,r</span><sub><span class="cmr-8">0</span></sub> + 1<span class="italic">,r</span><sub><span class="cmr-8">0</span></sub> + 2<span class="italic">,...,r</span><sub><span class="cmr-8">0</span></sub> + <span class="italic">n</span>. The value of <span class="italic">r</span><sub><span class="cmr-8">0</span></sub> is the starting rank for the group. The mean of this sequence is <span class="italic">r</span><sub><span class="cmr-8">0</span></sub> + <img src="../Images/file79.jpg" class="frac" data-align="middle" alt="n 2"/>. This processing requires creating a temporary sequence of values in order to emit each item from the group of values with the same key with their matching ranks.</p>&#13;
<p>Write this <span class="obeylines-h"><span class="verb"><code class="inlineCode">rank()</code></span></span> function, using the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools.groupby()</code></span></span> function. Compare the code with the examples in <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Chapter</span><span class="cmti-10x-x-109"> 7</span></a>, <a href="Chapter_07.xhtml#x1-1530007"><span class="cmti-10x-x-109">Complex Stateless Objects</span></a>. What advantages does the <span class="obeylines-h"><span class="verb"><code class="inlineCode">itertools</code></span></span> variant offer?</p>&#13;
</section>&#13;
</section>&#13;
<section id="join-our-community-discord-space-8" class="level3 likesectionHead" data-number="0.12.7">&#13;
<h3 class="likesectionHead" data-number="0.12.7"><span id="x1-1980005"/>Join our community Discord space</h3>&#13;
<p>Join our Python Discord workspace to discuss and know more about the book: <a href="https://packt.link/dHrHU">https://packt.link/dHrHU</a></p>&#13;
<p><img src="../Images/file1.png" alt="PIC" width="85" height="85"/> <span id="x1-198001r177"/></p>&#13;
</section>&#13;
</section>&#13;
</body></html>