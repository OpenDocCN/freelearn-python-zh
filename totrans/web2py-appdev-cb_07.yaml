- en: Chapter 7. Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a web2py JSON service with jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming a JSON-RPC service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-RPC from JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making amf3 RPC calls from Flex using pyamf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PayPal integration in web2py
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PayPal web payments standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Flickr photos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending e-mails with Boto through **Amazon Web Services** (AWS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making GIS maps using mapscript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google groups and Google code feeds reader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating SOAP web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is not about creating web services (that subject is discussed in
    the official web2py manual); it's about consuming web services. The most common
    web services use protocols, such as JSON, JSON-RPC, XML, XMLRPC, and/or SOAP.
    web2py supports them all, but the integration can be quite tricky. Here, we provide
    examples of integration with Flex, Paypal, Flickr, and GIS.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a web2py JSON service with jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a simple example of how to retrieve JSON data from the server, and consume
    it with jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to return JSON form web2py, but here we consider the case
    of a JSON service, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here the function `consumer` doesn't really do anything; it just returns an
    empty dictionary to render the view, which will consume the service. `get_days`
    defines the service, and the function call exposes all registered services. `get_days`
    does not need to be in the controller, and can be in a model. `call` is always
    in the `default.py` scaffolding controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we create a view for the consumer actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first argument of `jQuery.getJSON` is the URL of the following service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:8000/app/default/call/json/get_days`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This always follows the pattern: `http://<domain>/<app>/<controller>/call/<type>/<service>`'
  prefs: []
  type: TYPE_NORMAL
- en: The URL is in between `{{...}}`, because it is resolved at the server-side,
    while everything else is executed at the client-side.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument of `jQuery.getJSON` is a callback, which will be passed
    the JSON response. In our case, the callback loops over each item in the response
    (a list of week days as strings), and appends each string, followed by a`<br/>`
    to the`<div id="target">`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enable generic URLs, you can implement `json` services as a regular action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you do not need to use the `call` action, and you can rewrite
    the view for the consumer action as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, the URL is shorter. So, why use the `@service.json` instead of
    the latter method? There are two reasons. The first is that in the former case,
    you can expose the same function suing also JSON-RPC, XMLRPC, SOAP, and AMF services,
    using the corresponding decorators. While in the latter case, this would be more
    complex. The second reason is that, using `@service.json, GET` variables are automatically
    parsed and passed as variables to the service function. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be called equivalently with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:8000/app/default/call/json/concat?a=hello&b=world`'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:8000/app/default/call/json/concat/hello/world`'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:8000/app/default/call/json/concat/hello?b=world`'
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a JSON-RPC service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While, before, we considered the case of a JSON service, we are now interested
    in a **JSON-RPC** service. This is more complex, because the variables ( `request`
    and `response)` have a more strict format dictated by the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a JSON-RPC service in pure web2py, but it''s more likely that
    we will consume it from a different Python program. For this purpose, we will
    assume a standard `jsonrpc` library, which can be found at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/bmjames/python-jsonrpc](http://https://github.com/bmjames/python-jsonrpc)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How do do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to create the `service`. We will consider the same example
    that we used before, but we change its decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to call it, we need a JSON-RPC client library from a separate (non web2py)
    Python program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are other JSON-RPC libraries out there, for example [http://json-rpc.org/wiki/python-json-rpc](http://json-rpc.org/wiki/python-json-rpc),
    which uses the following syntax closer to the `xmlrpclib` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in this latter case, the method name becomes an attribute. The two
    libraries are incompatible, but have the same name. Make sure you know which one
    you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'web2py includes its own JSON-RPC client library in `gluon/contrib/simplejsonrpc.py`,
    and its API is compatible with the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: JSON-RPC from JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many good reasons you'd want to use JSON-RPC as transport protocol
    in your web applications between the client and the server. This is particularly
    useful to create a rich client interface, as JSON-RPC is faster than XML-RPC,
    because it is less verbose and is easier to parse by the JavaScript code. JSON-RPC
    is better than just JSON, because it is an RPC protocol, which means that it will
    handle error propagation for you.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we provide an example of how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: You can read an article for the same at the following URL, which is written
    by *Luke Kenneth Casson Leighton*, author of the excellent *Pyjamas library:*
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.advogato.org/article/993.html](http://www.advogato.org/article/993.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe is based on code posted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://otomotion.org/BasicJSONRPC/static/BasicJSONRPC-application.zip](http://otomotion.org/BasicJSONRPC/static/BasicJSONRPC-application.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is based on the `json-xml-rpc` library, which is available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://code.google.com/p/json-xml-rpc](http://code.google.com/p/json-xml-rpc)'
  prefs: []
  type: TYPE_NORMAL
- en: It is an RPC JavaScript client implementation used in this example to connect
    to web2py's actions, using its native JSON-RPC support.
  prefs: []
  type: TYPE_NORMAL
- en: It's not a perfect approach, but it supplies a level of decoupling between the
    server and the client that makes me want to look past its small defects. This
    enlightening article, by *Luke Kenneth Casson Leighton*, goes into more detail
    about the approach (see the section *Full-blown JavaScript-led Development)*.
    This is also the method used by frameworks such as **GWT** ([http://code.google.com/webtoolkit/](http://code.google.com/webtoolkit/))
    and **PyJamas** ([http://pyjs.org/](http://pyjs.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create two controllers and one view. The first controller will simply
    load the rich client interface defined in the view. The second controller defines
    the JSON-RPC methods. There's no real reason not to use a single controller for
    both purposes, but it is a better design to keep the two functionalities in separate
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first controller can be `default.py`, and we can use the usual trivial
    action:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `view views/default/index.html`, we are going to simply add the following
    code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BasicJSONRPC.py` controller contains nothing more than the reference to
    the view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BasicJSONRPCData.py` controller is where the real meets the live. We'll
    start simple.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `systemListMethods` action is required by the `json-xml-rpc` library. By
    default, the library actually calls `system.ListMethods`, which can't be supported
    by Python. We thus remove the period in the call inside the RPC library. The Python
    function just needs to return an array of strings of all the possible methods
    to call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have the controller ready, we can move on to the client portion.
    The URL to access the RPC methods is something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost/Application/Controller/call/jsonrpc`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using this URL and the `json-xml-rpc` library, we create a JavaScript `DataController`
    object, which we'll use for all future procedure calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, the `json-xml-rpc` library creates the `DataController` for asynchronous
    calls. Since you don''t want your JavaScript to be blocked during your requests,
    **asynchronous calls** is the desired behavior. If you''d, however, like to run
    a quick test of of your remote methods, you can run the following lines of JavaScript
    from the Firebug console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `json-xml-rpc` documentation, located at [http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript](http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript),
    gives the details of how to run asynchronous calls.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Dictionaries and arrays can be returned by your Python functions, as demonstrated
    by our `BiggerTest` function:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to update the `systemListMethods` function to include any new functions.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this step, you should be able to test remote calls and see the results using
    JavaScript (called synchronously in Firebug console):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Authentication works too, as cookies are posted with every request, and web2py
    is thus able to parse the session ID cookie for JSON-RPC calls. Security requirements
    can be added to your remote functions, by securing the call function (not the
    individual service function; that is important):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you were to also set `@auth.requires_login` on the main `BasicJSONRPC.py`
    controller, your users would log in when they first load the page, and all subsequent
    RPC calls will be correctly authenticated. The problem with this, comes with **timeouts**.
    If a user lets the page idle until timeout occurs, she or he can still trigger
    RPC calls to the server. Authentication will then fail and the default web2py
    value of `auth.settings.login_url, /default/user/login` will be called as a view.
    The problem is that since a view is not a valid JSON-RPC message, the `json-xml-rpc`
    library will discard it and fail. You can catch the error, but it's not easy to
    identify it. The simplest solution I've found, and I'm hoping that others will
    find a better one, is to set the value of `auth.settings.login_url` to an action
    in the RPC controller, which returns nothing but a simple string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `db.py`, set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Login` is a non JSON-RPC action (since we don''t want it to require authentication),
    which returns an easily recognizable string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then detect authentication failure from the client-side, by running
    a check whenever an RPC call fails. In the `onException` handler of the asynchronous
    call (see `RunSmallTest)`, replace with the following code to handle authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The obvious flaw in this approach is that we've lost the very practical login
    view for regular HTML views. Therefore, while authentication works for RPC calls,
    it breaks it for HTML views.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can now simplify our calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Although it''s not possible to really simplify the syntax used by the json-xml-rpc
    library to make an asynchronous call, it is, however, possible to somewhat automate
    many parts of it, for calls that simply get or update client-side data objects.
    This is especially useful if you''re trying to handle errors and authentication
    in a consistent way. We can use the following client wrapper function to make
    asynchronous calls:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function can be reused for any number of data objects. The requirements
    are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a `data object` variable that has the same name as the RPC function
    (for example: `UserList)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define another variable with its name followed by `Ready` (for example: `UserListReady)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Call the wrapper function, by passing the name of the RPC action as a string,
    and an array containing any required parameter values (for example: `LoadDataObject("UserList",
    ["admins",false])`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: During the call, the `ready` variable will be set to `false`, and the `data
    object` variable will be set to the string `Loading`. If an error occurs, the
    `ready` variable will remain `false`, and the `data object` variable will be set
    to the error object. You can poll the two variables if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `json-xml-rpc` library is a single JavaScript file, which can be obtained
    by downloading the **rpc-client-JavaScript** ZIP file from the following Google-hosted
    code site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://code.google.com/p/json-xml-rpc/downloads/list](http://code.google.com/p/json-xml-rpc/downloads/list)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It has excellent documentation, which is located at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript](http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript)'
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a bug in their code. In *revision 36*, we had to change *lines
    422* to *424:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We also had to remove the periods in the calls to `system.ListMethods` on *lines
    151* and *154*, so that a `systemListMethods` function could be supported by Python.
  prefs: []
  type: TYPE_NORMAL
- en: Making amf3 RPC calls from Flex using pyamf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the example in *The Official web2py Book*, in this recipe we show you
    how to communicate with an `mxml` Flex application as opposed to Flash.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, you must install **pyamf** and make it visible to web2py (which
    initially comes without pyamf). For this purpose, visit the pyamf download page,
    located at the following URL, and get a ZIP file of the latest stable release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pyamf.com/community/download.html](http://www.pyamf.com/community/download.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unzip and install it according to instructions in `INSTALL.txt`. I suggest
    using the following command, in order to avoid possible problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will place a `.egg` package (something like `PyAMF-0.5.1-py2.6.egg)` in
    Python's installation folder, under `\Lib\site-packages` (for example, `C:\Python26\Lib\site-packages)..egg`
    is basically a ZIP archive (such as `.jar` to Java), so open it and extract the
    `pyamf` folder. Go to the web2py installation folder, and find the `library.zip`
    archive. Add `pyamf` to this archive. That's it! Now, web2py will run `pyamf`
    transparently to you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Python code:** Let''s assume that you are developing an application called
    `app`, and the web2py server runs on the localhost (127.0.0.1:8000). Add a new
    controller called `rpc.py`, and add the following code to the controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that mydomain is important. You can use a different domain name, but
    you have to be consistent. Don't forget it!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Flex mxml/AS3 code:** Now, create a new **Flex** application, and replace
    its content with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`code_xml:` Pay attention to the definition of the `RemoteObject. Endpoint`
    is a service URL. It doesn''t include the RPC method name, which should be specified
    in the `name` attribute of the `mx:method` object. `/call/amfrpc3` is a standard
    URL suffix, and it shouldn''t be altered. It is important to specify the destination
    attribute it''s the same ID that appears in the controller in the `@service.amfrpc3(...)`
    decorator.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Setting** `crossdomain.xml:` Notice that in order for Flex to be able to
    invoke RPC services from a different domain, one needs to expose an appropriate
    `crossdomain.xml` file at the top-level of the server of that domain. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To do this, create `crossdomain.xml` inside the `static/` folder of the application
    (web2py doesn''t support public resources, so we will do some routing), and add
    an appropriate access policy. For example, **full access** (not desirable for
    security reasons):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now go to the web2py installation folder, and create a routes.py file with
    the following content:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file instructs the web2py server to redirect all requests in crossdomain.xml,
    to its location at the application's static resources. Don't forget to close and
    run the process of the server, in order for it to reload the routing information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PayPal integration in Web2py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is meant to be an introduction to **Paypal** integration in web2py.
    It by no means covers all the possible integrations with Paypal, and is mostly
    centered on what PayPal names **Standard Integration**. The examples given are
    proven at the time of writing this, but they should be taken only as a starting
    point rather than a reference. For that, please use both PayPal's and web2py's
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PayPal offers different levels of integration, which, depending on what you
    need to do, might be better suited for your needs. It is important that you get
    to know at least the basic integration concepts that PayPal provides before starting
    to program anything, so that you can plan in advance what is best suited to your
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: That said, let me try to give you a rough idea of the different levels involved,
    before going any further, so as to better understand the little area that this
    recipe covers. It is, however, an area which most of the small-sized and middle-sized
    projects may fall into.
  prefs: []
  type: TYPE_NORMAL
- en: 'In broad lines, there are three levels of integration that one can achieve
    with PayPal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Express checkout:** Within a seller account in PayPal, you can create buttons
    with information related to each item that you may be selling (name, description,
    item number, and pricing). You can have up to 1000 different buttons or items
    defined in this way. After that, it is a matter of setting the buttons on the
    HTML, to go along with the application. Regarding web2py, it is really simple
    to just copy the code that PayPal creates for each button in a text field in your
    product `db`, and then just present it on the screen whenever it''s needed. Using
    this method, one can opt for different purchase experiences including straight
    checkout or cart management (managed by PayPal), which would let you add or remove
    items from within the checkout screen in PayPal. I don''t like this method, unless
    you would be selling very, very few item codes, as it may get to be a pain to
    maintain your articles in PayPal. If you are selling a few services or whatever
    with a small set of prices, it might very well be worth it, as you don''t have
    to work much from the programming point of view, and it''s really simple to set
    up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard integration:** This is the one that we will be covering in this
    article. It basically lets you manage your own product database, and so on, and
    sends all the data to PayPal at the moment of payment, so that the whole checkout
    process is managed at PayPal. After the transaction has been completed, you can
    choose (as per configuration of your profile in your PayPal seller account) whether
    the customer is redirected back to your domain (you can set up a default URL to
    return to, or send that URL dynamically each time you send the data for the checkout,
    but the functionality needs to be activated in your seller account). The following
    two things need to be mentioned here, which I feel are part of the standard integration,
    although they are not required in order to have your basic site working:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payment Data Transfer (PDT):** This would be the process by which the customer
    is sent back to your domain, which lets you capture the transaction data (payment
    confirmation data from PayPal), and shows it in a confirmation screen in your
    own domain, with any further information you may want to show, or redirect the
    customer to continue his shopping. It is not completely safe, as nothing guarantees
    that the customer will be redirected; this may well happen, because in some cases,
    PayPal doesn''t execute the redirection, but forces the customer to click on an
    extra button to return to your domain, so as to give the opportunity to the customer
    to join PayPal. This happens whenever the customer pays by credit card and not
    using his PayPal account.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instant Payment Notification (IPN):** This is a messaging service that connects
    to your domain to send the information of each transaction processed at Paypal.
    It doesn''t stop sending the message until you acknowledge its reception (or four
    days pass without acknowledgement). This is the safest way to collect all the
    data from all the transactions processed at PayPal, and trigger any internal process
    that you may have. Usually, you will want to do the shipping of your products
    at this point.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detailed integration:** In here, I am really grouping a number of other methods
    ands APIs, that I will not be detailing; some of them for very specific uses.
    The only method that I would like to mention more specifically is **Name Value
    Pairs (NVP)** , as I feel that it gives you a very simple programing interface
    with which you can do very detailed processes controlling all your data, and all
    your transaction flow from your domain. Using NVP, you can, for example, capture
    all the data related to a payment in your domain, and only at that point, send
    all the information to PayPal to process the payment (as opposed to processing
    the checkout, which is what we are doing with the previous items). You have a
    good example as to how to implement this at [http://web2py.com/appliances/default/show/28](http://web2py.com/appliances/default/show/28),
    or go to the main web page, and find it under free applications, **PayPalEngine**,
    developed by *Matt Sellers*. You should, however, check the detailed documentation
    at PayPal, as the process involves many steps, in order to ensure the maximum
    security of your transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So basically, in express checkout, PayPal manages your cart (and master data),
    the checkout process, and of course, payments. With standard integration, PayPal
    manages checkout and payments, and with further detailed integration, you can
    make it so that it manages only the payments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before moving on, all the technical documentation regarding integration with
    PayPal can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/library_documentation](http://https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/library_documentation)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A link to this URL, in case this changes, can be found by clicking on the documentation
    link at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.paypal.com/](http://https://developer.paypal.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, moving on to how to use the standard integration, the first thing you should
    do is create yourself a sandbox account. You do this at `https://developer.paypal.com/`.
    Create yourself an account, and once logged in, create at least two test accounts:
    a `seller` and a `buyer` respectively. There is a good guide on all the necessary
    steps called **PP sandbox user guide**, which you can find at the documentation
    link provided before, or on an HTML version at [https://cms.paypal.com/us/cgi-bin/?
    cmd=_render-content&content_ID=developer/howto_testing_sandbox](http://https://cms.paypal.com/us/cgi-bin/?).
    Everything on how to set your account up and start running, is described there.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have that set up and running, you will have your seller ID and e-mail
    (you can use any of them to identify yourself to PayPal on the code below, although
    I prefer the ID, if only to avoid possible spam).
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so now, we can already create the **checkout button** that will take our
    customers to the PayPal site with all our cart data. Before moving further, you
    can find all documentation related to this point at the documentation link provided
    before, under the *Website Payments Standard Integration Guide*, or directly in
    an HTML format at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cms.paypal.com/us/cgi-bin/? cmd=_render-content&content_ID=developer/howto_html_wp_standard_overview](http://https://cms.paypal.com/us/cgi-bin/?)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the information about *Third-Party Shopping Carts*. Anyway, creating
    the button to send all the information is actually very simple. All that is needed
    is the following code in your checkout page view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A couple of comments regarding the listing `lst:CheckoutButton:`
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, to move from sandbox to production, the URL to use only needs
    to change from [https://www.sandbox.paypal.com](http://https://www.sandbox.paypal.com)
    to [https://www.paypal.com](http://https://www.paypal.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create the buttons using the `create new button` functionality at your
    seller account, and then re-use the code. It would let you to choose the language
    and the type of button to use. That way, you will get the correct link to the
    image to be used for your PayPal button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field `cmd` with `value _cart` is very important. Read the documentation
    to see the possible values of this field, depending on what you want to do. I
    am assuming a cart scenario on this example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fields `shopping_url, notify_url`, and `return` can be omitted, if you set
    up your seller account profile. If you set it up here, this takes precedence over
    the default values set up in your seller account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field `custom`, I think, is rather important, as it is one of the few fields
    that lets you introduce data not shown to the customer, that may allow you to
    track any extra information. It is per transaction (not per item). In this case,
    I choose to use an internal event code to track all purchases related to an event
    (special `promotion`, if you like or whatever).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, I created a loop with all the cart items to do the checkout,
    by passing a dictionary with all the product data. I have the information of the
    items purchased in the session. They get named and numbered following the PayPal
    rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the discount, even though you set the discounts per item, PayPal,
    only shows a discount total. I don't know if this is different in the Pro version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information, you should check the documentation named before, which
    includes a list of all the fields available to you (which include shipping charges,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkout confirmation/payment data transfer:** Once the customer finishes
    paying through PayPal, he will be redirected to your website, automatically, if
    it is set up in the account and he is already a PayPal user (otherwise he will
    have to click on a button to return to your site). This section shows you how
    to set your application so that it will receive the payment data confirmation
    from PayPal, and show a confirmation to your customer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read detailed documentation on this subject here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_html_paymentdatatransfer](http://https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_html_paymentdatatransfer)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see how to set it up in detail, so that you know where to get
    your token from, which you need to identify yourself to PayPal, to confirm and
    get the data. In any case, refer to the following figure representing a *Diagram
    of the Basic flow of a PDT transaction* (picture taken from PayPal docs), so as
    to give you a detailed view of the process flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5467OS_07_diag1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the listing `lst:generic-def`, I included a number of generic functions that
    I have used in setting up the interface. The `Connection` class definition is
    a modified version of a generic connection example that I found while surfing
    the web, but I cannot really recall where. The `add_to_cart, remove_from_cart,
    empty_cart`, and `checkout` that I included as an example of how to set up your
    cart, which are taken from **EStore**, can be found at [http://www.web2py.com/appliances/default/show/24](http://www.web2py.com/appliances/default/show/24).
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, please understand that the different methods are oversimplified here,
    to try to explain in a few lines the different possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Finally, confirm, at the listing `lst:confirm`, will process the information
    sent from PayPal, with the four step process described in the previous diagram
    of the basic flow of a PDT transaction, steps 2,3,4, and 5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Just for the sake of completeness, I am adding a very basic example of `confirm.html`,
    which you can see in the listing `lst:confirmhtml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Instant Payment Notification (IPN)** : As mentioned before, one cannot trust
    the PDT process to receive the information from all transactions, as a great number
    of things can happen. Thus, you need to implement an additional process, if you
    need to do additional processing of the information from your sales, or if you
    want to keep a local database of the actual sales processed.'
  prefs: []
  type: TYPE_NORMAL
- en: This is done with IPN. You can find all the related documentation at the documentation
    site URL given previously. You will need to turn on the IPN functionality at your
    seller account, as well as give a default URL to receive those messages, which
    should be equal to the view in which you process them. In the case of this example,
    it would be:[http://www.yourdomain.com/yourapp/default/ipn_handler](http://www.yourdomain.com/yourapp/default/ipn_handler)>.
  prefs: []
  type: TYPE_NORMAL
- en: The process is quite similar to that of PDT; even the variables are the same.
    The main difference is that IPNs are sent from PayPal, until you acknowledge them.
    The view for this function, `default/ipn_handler.html`, can very well be left
    blank. I am also including the table definition for logging the messages from
    PayPal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, you can find in the listing `lst:ipnhandler`, an example of how to
    set them up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The only thing missing would be to process the information received, and check
    for errors or possible fraud attempts. You can see an example function in the
    listing `lst:processipn`. Although this is probably something that would change
    quite a bit from one project to the next, I hope that it may serve you as a rough
    guide.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Hope that this section helped you to set up your PayPal site using web2py, or
    at least, helped you understand the basic concepts behind setting up one, and
    the different possibilities that you have available.
  prefs: []
  type: TYPE_NORMAL
- en: PayPal web payments standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows an implementation of the PayPal web payments standard, using
    both encrypted requests and IPN for a secure process workflow. Note that in this
    recipe, web2py version 1.77.3 is used. Hopefully, it still works in the latest
    web2py versions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement our integration with PayPal, I started with putting together the
    code that generates an encrypted form post to PayPal, for all of our cart actions.
    If you do this, and you configure PayPal to only accept signed requests, then
    the user cannot tamper with your form and change the price of an item. To do this,
    I installed the **M2Crypto** module on our system, and created a module that will
    do the signing of the PayPal forms. Note that this does not work on the Google
    App Engine, because M2Crypto does not run on GAE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I have yet to find a replacement for it that runs on the App Engine, so you
    cannot use this PayPal payments recipe in that environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The encryption module (`crypt.py`) uses the certificate to sign the data and
    then encrypts it, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we construct forms in our view, and encrypt them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the above code calls a method full_url(), which is defined as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, I need to be able to process our IPN responses from PayPal. The following
    code does just that. You''ll see that I only process purchase requests. I also
    left in the code that is specific to our database, about how I code product IDs,
    and then use that product ID to create records in our database. Based on the existence
    of those purchase records in our database, I allow the user to download the files
    that they purchased. So, the user cannot download their purchase until the IPN
    message is processed. This is usually 5 to 30 seconds after they submitted the
    order. Most of the time, the messages are received and processed before PayPal
    redirects the user back to our site. Our `paypal.py` controller will have a function
    to process the instant payment notification, as described in the following code
    section, (note that we have `openanything` in our modules directory. Visit[http://diveintopython.org/](http://diveintopython.org/)
    for the latest version):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's all, folks!
  prefs: []
  type: TYPE_NORMAL
- en: Getting Flickr photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be used to get a list of Flickr photos passing the photoset
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First you need to generate an **APIKEY**, which you can do on the Flickr developers
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.flickr.com/services/api/misc.api_keys.html](http://www.flickr.com/services/api/misc.api_keys.html)'
  prefs: []
  type: TYPE_NORMAL
- en: After that, you need to create a function to fetch the Flickr API. Generally,
    this is created in models, but you can do that in modules too.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a function in any of your model files. We will create one called `models/plugin_flickr.py`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can call that function from any controller or view. For example, in
    a controller action, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the associated `views/defaul/testflickr.html`, you can add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final product will look like the one shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/5467OS_07_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sending e-mails with Boto through Amazon Web Services (AWS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Amazon Simple Email Service** is a nice way to send e-mails without needing
    to operate your own mail server. This code utilizes the `Boto` library, which
    is a Python interface for AWS.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, you need to sign up for AWS at [http://aws.amazon.com](http://aws.amazon.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, enable Simple Email Service at [http://aws.amazon.com/ses/](http://aws.amazon.com/ses/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to obtain your Amazon `AWS-KEY` and `AWS-SECRET-KEY` from [https://aws-portal.amazon.com/gp/aws/developer/account/index.html](http://https://aws-portal.amazon.com/gp/aws/developer/account/index.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you need to install Boto in your `web2py/site-packages` folder, or
    anywhere in your path, so that web2py can find and import it. You can find Boto
    on GitHub: [https://github.com/boto/boto](http://https://github.com/boto/boto).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you get **production** access to Amazon's mail servers, you have to pre-register
    every sender's and recipient's e-mail address that you want to use (up to 100).
    This is OK for development and testing, but, of course, would not work in production.
    To register an e-mail address, execute the following code, replacing `AWS-KEY`
    and `AWS-SECRET-KEY` with your own keys, and `myemail@address.com` with the e-mail
    address that you want to register.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the web2py shell or any other Python shell, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming that everything is installed and configured, as explained before,
    sending e-mails is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Making GIS amps using mapscript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MapServer** is an open source platform for publishing spatial data and interactive
    mapping applications to the web. Originally developed in the mid-1990s at the
    University of Minnesota, MapServer is released under an MIT-style license, and
    runs on all major platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to publish geo-referenced maps using the MapServer
    web service, using a library called `mapscript`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, you need to install `mapscript` from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://pypi.python.org/pypi/mapscript/5.4.2.1](http://pypi.python.org/pypi/mapscript/5.4.2.1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do it by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also assume you have a map called `private/test2.map` in your application
    folder. A `.map` file looks in an `ascii` file that describes a map (coordinates,
    type, points with tags, and so on), and looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read more about map files here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mapserver.org/introduction.html](http://mapserver.org/introduction.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mapserver.org/mapfile/index.html#mapfile](http://mapserver.org/mapfile/index.html#mapfile)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GIS maps are exposed through WXS services. Here, we show you a simple action
    that provides a service to publish a map stored in the file `private/test2.map:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This service can be consumed by QGis ([http://www.qgis.org/](http://www.qgis.org/)),
    or any other Web MapService client ([http://en.wikipedia.org/wiki/Web_Map_Service](http://en.wikipedia.org/wiki/Web_Map_Service)),
    or a Web Feature Service client ([http://en.wikipedia.org/wiki/Web_Feature_Service](http://en.wikipedia.org/wiki/Web_Feature_Service)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL to pass to QGIS is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8000/mapas/default/wxs/test2.map`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `test2.map` points to our map file (stored in the file, `private/test2.map`,
    served by the `wxs` function as described before).
  prefs: []
  type: TYPE_NORMAL
- en: Google groups and Google code feeds reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will implement a simple feed reader to retrieve messages
    from Google Groups and Google Code using RSS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a file `models/plugin_feedreader.py`, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in any controller, you can embed the latest Google group information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Or read the latest Google code source updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Creating SOAP web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Simple Object Access Protocol (SOAP)** is a complex XML-based inter-process
    communication standard for web service implementation. It is widely used with
    legacy applications (especially JAVA and .NET languages), and supports type declaration
    and **Web Service Definition File (WSDL)** .'
  prefs: []
  type: TYPE_NORMAL
- en: web2py already supports a common infrastructure to expose web services in a
    simple way, using the **Service** tool (rss, json, jsonrpc, xmlrpc, jsonrpc, amfrpc,
    and amfrpc3).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PySimpleSOAP` library included in `gluon/contribs` (since version #1.82.1),
    aims to add SOAP support, extending the current philosophy.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Serving operations using SOAP is as easy as decorating a function using `@service.soap`,
    declaring the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exposed operation method (camel case by convention)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types are declared using a dictionary, mapping the parameter/result name with
    the standard Python conversion functions (str, **int, float, bool**, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, create an application (such as `webservices)`, and in a controller
    (sample.py), add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, web2py can dynamically generate help web pages (list of operations,
    xml message examples), and the WSDL XML:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List of operations: [http://127.0.0.1:8000/webservices/sample/call/soap](http://127.0.0.1:8000/webservices/sample/call/soap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Operation help (for the `SubIntegers` method, in this case): [http://127.0.0.1:8000/webservices/sample/call/soap?op=SubIntegers](http://127.0.0.1:8000/webservices/sample/call/soap?op=SubIntegers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service description (WSDL ): [http://127.0.0.1:8000/webservices/sample/call/soap?wsdl](http://127.0.0.1:8000/webservices/sample/call/soap?wsdl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sample operations list page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Sample operation help page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the web service exposed by web2py using this library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pysimplesoap** is included with recent releases of web2py, as it is being
    actively maintained. You can frequently check the version to find enhancements,
    to extend this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Although there are several python SOAP libraries, this one is designed to be
    as simple as possible, and is totally integrated with web2py.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, supported features, and platforms, have a look at the
    following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://code.google.com/p/pysimplesoap/wiki/Web2Py](http://code.google.com/p/pysimplesoap/wiki/Web2Py)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To view help pages for the latest web2py versions, you should create a view,
    sample/call.html, in this example, as in new versions of web2py, for security
    reasons, generic views are not exposed by default
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
