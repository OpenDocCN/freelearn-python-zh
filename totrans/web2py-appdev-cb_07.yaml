- en: Chapter 7. Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 网络服务
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下菜谱：
- en: Consuming a web2py JSON service with jQuery
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jQuery消费web2py JSON服务
- en: Consuming a JSON-RPC service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费JSON-RPC服务
- en: JSON-RPC from JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从JavaScript发起JSON-RPC
- en: Making amf3 RPC calls from Flex using pyamf
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pyamf从Flex发起amf3 RPC调用
- en: PayPal integration in web2py
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: web2py中的PayPal集成
- en: PayPal web payments standard
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PayPal网络支付标准
- en: Getting Flickr photos
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取Flickr照片
- en: Sending e-mails with Boto through **Amazon Web Services** (AWS)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**Amazon Web Services** (AWS)使用Boto发送电子邮件
- en: Making GIS maps using mapscript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用mapscript制作GIS地图
- en: Google groups and Google code feeds reader
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google群组和Google代码源代码阅读器
- en: Creating SOAP web services
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建SOAP网络服务
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is not about creating web services (that subject is discussed in
    the official web2py manual); it's about consuming web services. The most common
    web services use protocols, such as JSON, JSON-RPC, XML, XMLRPC, and/or SOAP.
    web2py supports them all, but the integration can be quite tricky. Here, we provide
    examples of integration with Flex, Paypal, Flickr, and GIS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不涉及创建网络服务（该主题在官方web2py手册中有讨论）；而是关于如何使用网络服务。最常用的网络服务使用协议，如JSON、JSON-RPC、XML、XMLRPC和/或SOAP。web2py支持所有这些协议，但集成可能相当复杂。在这里，我们提供了与Flex、Paypal、Flickr和GIS集成的示例。
- en: Consuming a web2py JSON service with jQuery
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery消费web2py JSON服务
- en: This is a simple example of how to retrieve JSON data from the server, and consume
    it with jQuery.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从服务器检索JSON数据并使用jQuery消费它的简单示例。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'There are many ways to return JSON form web2py, but here we consider the case
    of a JSON service, for example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从web2py返回JSON的方式有很多，但在这里我们考虑的是JSON服务的案例，例如：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here the function `consumer` doesn't really do anything; it just returns an
    empty dictionary to render the view, which will consume the service. `get_days`
    defines the service, and the function call exposes all registered services. `get_days`
    does not need to be in the controller, and can be in a model. `call` is always
    in the `default.py` scaffolding controller.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数`consumer`实际上并没有做什么；它只是返回一个空字典以渲染视图，该视图将使用服务。`get_days`定义了服务，函数调用暴露了所有已注册的服务。`get_days`不需要在控制器中，也可以在模型中。`call`始终在`default.py`脚手架控制器中。
- en: 'Now, we create a view for the consumer actions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为消费者操作创建一个视图：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first argument of `jQuery.getJSON` is the URL of the following service:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.getJSON`的第一个参数是以下服务的URL：'
- en: '`http://127.0.0.1:8000/app/default/call/json/get_days`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8000/app/default/call/json/get_days`'
- en: 'This always follows the pattern: `http://<domain>/<app>/<controller>/call/<type>/<service>`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这始终遵循以下模式：`http://<domain>/<app>/<controller>/call/<type>/<service>`
- en: The URL is in between `{{...}}`, because it is resolved at the server-side,
    while everything else is executed at the client-side.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: URL位于`{{...}}`之间，因为它在服务器端解析，而其他所有内容都在客户端执行。
- en: The second argument of `jQuery.getJSON` is a callback, which will be passed
    the JSON response. In our case, the callback loops over each item in the response
    (a list of week days as strings), and appends each string, followed by a`<br/>`
    to the`<div id="target">`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`jQuery.getJSON`的第二个参数是一个回调，它将传递JSON响应。在我们的例子中，回调遍历响应中的每个项目（字符串形式的周天列表），并将每个字符串，后跟一个`<br/>`，追加到`<div
    id="target">`中。'
- en: There's more...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you enable generic URLs, you can implement `json` services as a regular action.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启用了通用URL，你可以将`json`服务实现为一个常规操作。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, you do not need to use the `call` action, and you can rewrite
    the view for the consumer action as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你不需要使用`call`操作，你可以将消费者操作的视图重写如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this way, the URL is shorter. So, why use the `@service.json` instead of
    the latter method? There are two reasons. The first is that in the former case,
    you can expose the same function suing also JSON-RPC, XMLRPC, SOAP, and AMF services,
    using the corresponding decorators. While in the latter case, this would be more
    complex. The second reason is that, using `@service.json, GET` variables are automatically
    parsed and passed as variables to the service function. For example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的话，URL会更短。那么，为什么使用`@service.json`而不是后一种方法呢？有两个原因。第一个原因是，在前一种情况下，你可以使用相应的装饰器同时暴露相同的函数，用于JSON-RPC、XMLRPC、SOAP和AMF服务，而在后一种情况下，这会更复杂。第二个原因是，使用`@service.json`，GET变量会自动解析并作为变量传递给服务函数。例如：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This can be called equivalently with the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以等价地用以下方式调用：
- en: '`http://127.0.0.1:8000/app/default/call/json/concat?a=hello&b=world`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8000/app/default/call/json/concat?a=hello&b=world`'
- en: '`http://127.0.0.1:8000/app/default/call/json/concat/hello/world`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8000/app/default/call/json/concat/hello/world`'
- en: '`http://127.0.0.1:8000/app/default/call/json/concat/hello?b=world`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8000/app/default/call/json/concat/hello?b=world`'
- en: Consuming a JSON-RPC service
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费 JSON-RPC 服务
- en: While, before, we considered the case of a JSON service, we are now interested
    in a **JSON-RPC** service. This is more complex, because the variables ( `request`
    and `response)` have a more strict format dictated by the protocol.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，之前我们考虑的是 JSON 服务的情况，但现在我们感兴趣的是 **JSON-RPC** 服务。这更复杂，因为变量（`request` 和 `response`）有更严格的格式，由协议规定。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We can create a JSON-RPC service in pure web2py, but it''s more likely that
    we will consume it from a different Python program. For this purpose, we will
    assume a standard `jsonrpc` library, which can be found at the following URL:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在纯 web2py 中创建 JSON-RPC 服务，但更有可能的是我们会从不同的 Python 程序中消费它。为此，我们将假设一个标准的 `jsonrpc`
    库，它可以在以下 URL 中找到：
- en: '[https://github.com/bmjames/python-jsonrpc](http://https://github.com/bmjames/python-jsonrpc)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/bmjames/python-jsonrpc](http://https://github.com/bmjames/python-jsonrpc)'
- en: 'You can install it with the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令安装它：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How do do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First of all, we need to create the `service`. We will consider the same example
    that we used before, but we change its decorator:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建 `service`。我们将考虑之前使用的相同示例，但改变其装饰器：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, to call it, we need a JSON-RPC client library from a separate (non web2py)
    Python program:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要调用它，我们需要一个来自独立（非 web2py）Python 程序的 JSON-RPC 客户端库：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多...
- en: 'There are other JSON-RPC libraries out there, for example [http://json-rpc.org/wiki/python-json-rpc](http://json-rpc.org/wiki/python-json-rpc),
    which uses the following syntax closer to the `xmlrpclib` syntax:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在还有其他的 JSON-RPC 库，例如 [http://json-rpc.org/wiki/python-json-rpc](http://json-rpc.org/wiki/python-json-rpc)，它使用的语法更接近
    `xmlrpclib` 的语法：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that in this latter case, the method name becomes an attribute. The two
    libraries are incompatible, but have the same name. Make sure you know which one
    you are using.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，方法名变成了一个属性。这两个库不兼容，但名称相同。确保你知道你正在使用哪一个。
- en: 'web2py includes its own JSON-RPC client library in `gluon/contrib/simplejsonrpc.py`,
    and its API is compatible with the previous example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: web2py 在 `gluon/contrib/simplejsonrpc.py` 中包含了它自己的 JSON-RPC 客户端库，并且它的 API 与之前的示例兼容：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: JSON-RPC from JavaScript
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-RPC 从 JavaScript
- en: There are many good reasons you'd want to use JSON-RPC as transport protocol
    in your web applications between the client and the server. This is particularly
    useful to create a rich client interface, as JSON-RPC is faster than XML-RPC,
    because it is less verbose and is easier to parse by the JavaScript code. JSON-RPC
    is better than just JSON, because it is an RPC protocol, which means that it will
    handle error propagation for you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多理由你想在 Web 应用程序中，客户端和服务器之间使用 JSON-RPC 作为传输协议。这特别有用于创建丰富的客户端界面，因为 JSON-RPC
    比 XML-RPC 快，因为它更简洁，并且更容易被 JavaScript 代码解析。JSON-RPC 比单纯的 JSON 更好，因为它是一个 RPC 协议，这意味着它会为你处理错误传播。
- en: In this recipe, we provide an example of how to do it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们提供了一个如何做到这一点的示例。
- en: You can read an article for the same at the following URL, which is written
    by *Luke Kenneth Casson Leighton*, author of the excellent *Pyjamas library:*
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下 URL 上的文章中阅读更多关于此的信息，该文章由 *Luke Kenneth Casson Leighton* 撰写，他是出色的 *Pyjamas
    库* 的作者：
- en: '[http://www.advogato.org/article/993.html](http://www.advogato.org/article/993.html)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.advogato.org/article/993.html](http://www.advogato.org/article/993.html)'
- en: 'This recipe is based on code posted here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是基于这里发布的代码：
- en: '[http://otomotion.org/BasicJSONRPC/static/BasicJSONRPC-application.zip](http://otomotion.org/BasicJSONRPC/static/BasicJSONRPC-application.zip)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://otomotion.org/BasicJSONRPC/static/BasicJSONRPC-application.zip](http://otomotion.org/BasicJSONRPC/static/BasicJSONRPC-application.zip)'
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe is based on the `json-xml-rpc` library, which is available at:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是基于 `json-xml-rpc` 库，它可以在以下位置找到：
- en: '[http://code.google.com/p/json-xml-rpc](http://code.google.com/p/json-xml-rpc)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/json-xml-rpc](http://code.google.com/p/json-xml-rpc)'
- en: It is an RPC JavaScript client implementation used in this example to connect
    to web2py's actions, using its native JSON-RPC support.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于连接到 web2py 的动作的 RPC JavaScript 客户端实现，它使用其本地的 JSON-RPC 支持。
- en: It's not a perfect approach, but it supplies a level of decoupling between the
    server and the client that makes me want to look past its small defects. This
    enlightening article, by *Luke Kenneth Casson Leighton*, goes into more detail
    about the approach (see the section *Full-blown JavaScript-led Development)*.
    This is also the method used by frameworks such as **GWT** ([http://code.google.com/webtoolkit/](http://code.google.com/webtoolkit/))
    and **PyJamas** ([http://pyjs.org/](http://pyjs.org/)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完美的方法，但它提供了服务器和客户端之间的一定程度的解耦，使得我愿意忽略其小缺陷。这篇启发性的文章，由 *Luke Kenneth Casson
    Leighton* 撰写，更详细地介绍了这种方法（见 *Full-blown JavaScript-led Development* 部分）。这也是 GWT
    ([http://code.google.com/webtoolkit/](http://code.google.com/webtoolkit/)) 和 PyJamas
    ([http://pyjs.org/](http://pyjs.org/)) 等框架所使用的方法。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will create two controllers and one view. The first controller will simply
    load the rich client interface defined in the view. The second controller defines
    the JSON-RPC methods. There's no real reason not to use a single controller for
    both purposes, but it is a better design to keep the two functionalities in separate
    files.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建两个控制器和一个视图。第一个控制器将简单地加载视图中定义的丰富客户端界面。第二个控制器定义 JSON-RPC 方法。没有真正的理由不使用单个控制器来完成这两个目的，但将两个功能保持在不同文件中是一种更好的设计。
- en: 'The first controller can be `default.py`, and we can use the usual trivial
    action:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个控制器可以是 `default.py`，我们可以使用通常的简单操作：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `view views/default/index.html`, we are going to simply add the following
    code:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `view views/default/index.html` 中，我们将简单地添加以下代码：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `BasicJSONRPC.py` controller contains nothing more than the reference to
    the view.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BasicJSONRPC.py` 控制器除了对视图的引用外，没有其他内容。'
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `BasicJSONRPCData.py` controller is where the real meets the live. We'll
    start simple.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BasicJSONRPCData.py` 控制器是实际与生活交汇的地方。我们将从简单开始。'
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `systemListMethods` action is required by the `json-xml-rpc` library. By
    default, the library actually calls `system.ListMethods`, which can't be supported
    by Python. We thus remove the period in the call inside the RPC library. The Python
    function just needs to return an array of strings of all the possible methods
    to call.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`systemListMethods` 动作是 `json-xml-rpc` 库所必需的。默认情况下，该库实际上调用 `system.ListMethods`，这在
    Python 中无法支持。因此，我们在 RPC 库内部的调用中移除了点号。Python 函数只需返回一个包含所有可能调用方法的字符串数组。'
- en: 'Now that we have the controller ready, we can move on to the client portion.
    The URL to access the RPC methods is something like the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了控制器，我们可以继续到客户端部分。访问 RPC 方法的 URL 大概如下：
- en: '`http://localhost/Application/Controller/call/jsonrpc`'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost/Application/Controller/call/jsonrpc`'
- en: Using this URL and the `json-xml-rpc` library, we create a JavaScript `DataController`
    object, which we'll use for all future procedure calls.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此 URL 和 `json-xml-rpc` 库，我们创建一个 JavaScript `DataController` 对象，我们将使用它进行所有未来的过程调用。
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By default, the `json-xml-rpc` library creates the `DataController` for asynchronous
    calls. Since you don''t want your JavaScript to be blocked during your requests,
    **asynchronous calls** is the desired behavior. If you''d, however, like to run
    a quick test of of your remote methods, you can run the following lines of JavaScript
    from the Firebug console:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`json-xml-rpc` 库为异步调用创建 `DataController`。由于你不想在请求期间阻塞你的 JavaScript，**异步调用**是期望的行为。然而，如果你想要快速测试你的远程方法，你可以从
    Firebug 控制台中运行以下 JavaScript 代码：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `json-xml-rpc` documentation, located at [http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript](http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript),
    gives the details of how to run asynchronous calls.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json-xml-rpc` 文档位于 [http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript](http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript)，其中详细说明了如何运行异步调用。'
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Dictionaries and arrays can be returned by your Python functions, as demonstrated
    by our `BiggerTest` function:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 Python 函数可以返回字典和数组，正如我们的 `BiggerTest` 函数所展示的那样：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to update the `systemListMethods` function to include any new functions.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记更新 `systemListMethods` 函数以包含任何新函数。
- en: 'At this step, you should be able to test remote calls and see the results using
    JavaScript (called synchronously in Firebug console):'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，你应该能够使用 JavaScript（在 Firebug 控制台中同步调用）测试远程调用并查看结果：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Authentication works too, as cookies are posted with every request, and web2py
    is thus able to parse the session ID cookie for JSON-RPC calls. Security requirements
    can be added to your remote functions, by securing the call function (not the
    individual service function; that is important):'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证也有效，因为每次请求都会发送cookie，因此web2py能够解析JSON-RPC调用的会话ID cookie。可以通过确保调用函数（而不是单个服务函数；这很重要）来向远程函数添加安全要求：
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you were to also set `@auth.requires_login` on the main `BasicJSONRPC.py`
    controller, your users would log in when they first load the page, and all subsequent
    RPC calls will be correctly authenticated. The problem with this, comes with **timeouts**.
    If a user lets the page idle until timeout occurs, she or he can still trigger
    RPC calls to the server. Authentication will then fail and the default web2py
    value of `auth.settings.login_url, /default/user/login` will be called as a view.
    The problem is that since a view is not a valid JSON-RPC message, the `json-xml-rpc`
    library will discard it and fail. You can catch the error, but it's not easy to
    identify it. The simplest solution I've found, and I'm hoping that others will
    find a better one, is to set the value of `auth.settings.login_url` to an action
    in the RPC controller, which returns nothing but a simple string.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还在主`BasicJSONRPC.py`控制器上设置了`@auth.requires_login`，那么当用户首次加载页面时，他们将登录，并且所有后续的RPC调用都将得到正确认证。然而，这个问题与**超时**有关。如果用户让页面空闲直到超时发生，他们仍然可以触发对服务器的RPC调用。认证将失败，并且默认的web2py值`auth.settings.login_url,
    /default/user/login`将被作为视图调用。问题在于，由于视图不是一个有效的JSON-RPC消息，`json-xml-rpc`库将丢弃它并失败。你可以捕获错误，但很难识别它。我找到的最简单解决方案，并且我希望其他人能找到更好的解决方案，是将`auth.settings.login_url`的值设置为RPC控制器中的一个操作，该操作返回的只是一个简单的字符串。
- en: 'In `db.py`, set:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`db.py`中设置：
- en: '[PRE20]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Login` is a non JSON-RPC action (since we don''t want it to require authentication),
    which returns an easily recognizable string:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Login`是一个非JSON-RPC操作（因为我们不希望它需要认证），它返回一个容易识别的字符串：'
- en: '[PRE21]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can then detect authentication failure from the client-side, by running
    a check whenever an RPC call fails. In the `onException` handler of the asynchronous
    call (see `RunSmallTest)`, replace with the following code to handle authentication:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以随后通过在每次RPC调用失败时运行检查来从客户端检测认证失败。在异步调用的`onException`处理程序（见`RunSmallTest`）中，替换以下代码以处理认证：
- en: '[PRE22]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The obvious flaw in this approach is that we've lost the very practical login
    view for regular HTML views. Therefore, while authentication works for RPC calls,
    it breaks it for HTML views.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法的一个明显缺陷是我们失去了对常规HTML视图非常有用的登录视图。因此，虽然认证对RPC调用有效，但它破坏了HTML视图的认证。
- en: We can now simplify our calls.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以简化我们的调用。
- en: 'Although it''s not possible to really simplify the syntax used by the json-xml-rpc
    library to make an asynchronous call, it is, however, possible to somewhat automate
    many parts of it, for calls that simply get or update client-side data objects.
    This is especially useful if you''re trying to handle errors and authentication
    in a consistent way. We can use the following client wrapper function to make
    asynchronous calls:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然无法真正简化json-xml-rpc库用于异步调用的语法，但对于仅仅获取或更新客户端数据对象的调用，它确实可以在某种程度上自动化许多部分。如果你试图以一致的方式处理错误和认证，这特别有用。我们可以使用以下客户端包装函数来执行异步调用：
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The function can be reused for any number of data objects. The requirements
    are:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数可以用于任意数量的数据对象。要求如下：
- en: 'Define a `data object` variable that has the same name as the RPC function
    (for example: `UserList)`'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个与RPC函数同名的`data object`变量（例如：`UserList`）
- en: 'Define another variable with its name followed by `Ready` (for example: `UserListReady)`'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义另一个变量，其名称后跟`Ready`（例如：`UserListReady`）
- en: 'Call the wrapper function, by passing the name of the RPC action as a string,
    and an array containing any required parameter values (for example: `LoadDataObject("UserList",
    ["admins",false])`'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用包装函数，通过传递一个字符串形式的RPC操作名称和一个包含任何所需参数值的数组（例如：`LoadDataObject("UserList", ["admins",false])`）
- en: During the call, the `ready` variable will be set to `false`, and the `data
    object` variable will be set to the string `Loading`. If an error occurs, the
    `ready` variable will remain `false`, and the `data object` variable will be set
    to the error object. You can poll the two variables if necessary.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用过程中，`ready`变量将被设置为`false`，而`data object`变量将被设置为字符串`Loading`。如果发生错误，`ready`变量将保持`false`，而`data
    object`变量将被设置为错误对象。如果需要，你可以轮询这两个变量。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `json-xml-rpc` library is a single JavaScript file, which can be obtained
    by downloading the **rpc-client-JavaScript** ZIP file from the following Google-hosted
    code site:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`json-xml-rpc`库是一个单独的JavaScript文件，可以通过从以下Google托管代码站点下载**rpc-client-JavaScript**
    ZIP文件来获取：'
- en: '[http://code.google.com/p/json-xml-rpc/downloads/list](http://code.google.com/p/json-xml-rpc/downloads/list)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/json-xml-rpc/downloads/list](http://code.google.com/p/json-xml-rpc/downloads/list)'
- en: 'It has excellent documentation, which is located at the following URL:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它有优秀的文档，位于以下URL：
- en: '[http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript](http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript](http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript)'
- en: There is, however, a bug in their code. In *revision 36*, we had to change *lines
    422* to *424:*
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，他们的代码中有一个bug。在*修订版36*中，我们必须将*第422行*更改为*第424*：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To the following
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到以下
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We also had to remove the periods in the calls to `system.ListMethods` on *lines
    151* and *154*, so that a `systemListMethods` function could be supported by Python.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在`system.ListMethods`的调用中删除*第151行*和*第154行*中的点，以便支持Python中的`systemListMethods`函数。
- en: Making amf3 RPC calls from Flex using pyamf
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pyamf从Flex调用amf3 RPC
- en: Unlike the example in *The Official web2py Book*, in this recipe we show you
    how to communicate with an `mxml` Flex application as opposed to Flash.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与*《官方web2py书籍》*中的示例不同，在这个菜谱中，我们向您展示如何与`mxml` Flex应用程序通信，而不是与Flash通信。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First of all, you must install **pyamf** and make it visible to web2py (which
    initially comes without pyamf). For this purpose, visit the pyamf download page,
    located at the following URL, and get a ZIP file of the latest stable release:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须安装**pyamf**并将其对web2py可见（web2py最初不包含pyamf）。为此，访问以下URL的pyamf下载页面，并获取最新稳定版本的ZIP文件：
- en: '[http://www.pyamf.com/community/download.html](http://www.pyamf.com/community/download.html)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pyamf.com/community/download.html](http://www.pyamf.com/community/download.html)'
- en: 'Unzip and install it according to instructions in `INSTALL.txt`. I suggest
    using the following command, in order to avoid possible problems:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 解压并根据`INSTALL.txt`中的说明进行安装。我建议使用以下命令，以避免可能的问题：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will place a `.egg` package (something like `PyAMF-0.5.1-py2.6.egg)` in
    Python's installation folder, under `\Lib\site-packages` (for example, `C:\Python26\Lib\site-packages)..egg`
    is basically a ZIP archive (such as `.jar` to Java), so open it and extract the
    `pyamf` folder. Go to the web2py installation folder, and find the `library.zip`
    archive. Add `pyamf` to this archive. That's it! Now, web2py will run `pyamf`
    transparently to you.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Python的安装文件夹中放置一个`.egg`包（例如`PyAMF-0.5.1-py2.6.egg`），位于`\Lib\site-packages`下（例如，`C:\Python26\Lib\site-packages`）。`.egg`基本上是一个ZIP存档（如`.jar`到Java），所以打开它并提取`pyamf`文件夹。转到web2py安装文件夹，找到`library.zip`存档。将`pyamf`添加到这个存档中。就是这样！现在，web2py将透明地运行`pyamf`。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '**Python code:** Let''s assume that you are developing an application called
    `app`, and the web2py server runs on the localhost (127.0.0.1:8000). Add a new
    controller called `rpc.py`, and add the following code to the controller:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Python代码：**假设你正在开发一个名为`app`的应用程序，web2py服务器运行在本机（127.0.0.1:8000）。添加一个名为`rpc.py`的新控制器，并将以下代码添加到控制器中：'
- en: '[PRE27]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that mydomain is important. You can use a different domain name, but
    you have to be consistent. Don't forget it!
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，mydomain非常重要。你可以使用不同的域名，但必须保持一致。不要忘记它！
- en: '**Flex mxml/AS3 code:** Now, create a new **Flex** application, and replace
    its content with the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Flex mxml/AS3代码：**现在，创建一个新的**Flex**应用程序，并用以下代码替换其内容：'
- en: '[PRE28]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`code_xml:` Pay attention to the definition of the `RemoteObject. Endpoint`
    is a service URL. It doesn''t include the RPC method name, which should be specified
    in the `name` attribute of the `mx:method` object. `/call/amfrpc3` is a standard
    URL suffix, and it shouldn''t be altered. It is important to specify the destination
    attribute it''s the same ID that appears in the controller in the `@service.amfrpc3(...)`
    decorator.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`code_xml:`请注意`RemoteObject. Endpoint`的定义是一个服务URL。它不包括RPC方法名称，该名称应在`mx:method`对象的`name`属性中指定。`/call/amfrpc3`是一个标准URL后缀，不应更改。指定目标属性很重要，它是`@service.amfrpc3(...)`装饰器中控制器中出现的相同ID。'
- en: '**Setting** `crossdomain.xml:` Notice that in order for Flex to be able to
    invoke RPC services from a different domain, one needs to expose an appropriate
    `crossdomain.xml` file at the top-level of the server of that domain. For example:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置** `crossdomain.xml:` 注意，为了让 Flex 能够从不同的域调用 RPC 服务，需要在那个域的服务器顶级目录下暴露一个适当的
    `crossdomain.xml` 文件。例如：'
- en: '[PRE29]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To do this, create `crossdomain.xml` inside the `static/` folder of the application
    (web2py doesn''t support public resources, so we will do some routing), and add
    an appropriate access policy. For example, **full access** (not desirable for
    security reasons):'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要做到这一点，在应用程序的 `static/` 文件夹内创建 `crossdomain.xml` 文件（web2py 不支持公共资源，因此我们将进行一些路由），并添加适当的访问策略。例如，**完全访问**（出于安全原因不推荐）：
- en: '[PRE30]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now go to the web2py installation folder, and create a routes.py file with
    the following content:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在转到 web2py 安装文件夹，创建一个名为 routes.py 的文件，并包含以下内容：
- en: '[PRE31]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This file instructs the web2py server to redirect all requests in crossdomain.xml,
    to its location at the application's static resources. Don't forget to close and
    run the process of the server, in order for it to reload the routing information.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件指示 web2py 服务器将 crossdomain.xml 中的所有请求重定向到应用程序静态资源的位置。不要忘记关闭并运行服务器进程，以便它重新加载路由信息。
- en: PayPal integration in Web2py
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web2py 中的 PayPal 集成
- en: This recipe is meant to be an introduction to **Paypal** integration in web2py.
    It by no means covers all the possible integrations with Paypal, and is mostly
    centered on what PayPal names **Standard Integration**. The examples given are
    proven at the time of writing this, but they should be taken only as a starting
    point rather than a reference. For that, please use both PayPal's and web2py's
    documentation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱旨在介绍 web2py 中的 **Paypal** 集成。它绝对没有涵盖所有可能的 PayPal 集成，主要关注 PayPal 命名的 **标准集成**。给出的示例在撰写本文时已被验证，但它们只能作为起点，而不是参考。为此，请使用
    PayPal 和 web2py 的文档。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PayPal offers different levels of integration, which, depending on what you
    need to do, might be better suited for your needs. It is important that you get
    to know at least the basic integration concepts that PayPal provides before starting
    to program anything, so that you can plan in advance what is best suited to your
    needs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PayPal 提供了不同层次的集成，这取决于你需要做什么，可能更适合你的需求。在开始编程之前，了解 PayPal 提供的基本集成概念是很重要的，这样你可以提前规划最适合你需求的内容。
- en: That said, let me try to give you a rough idea of the different levels involved,
    before going any further, so as to better understand the little area that this
    recipe covers. It is, however, an area which most of the small-sized and middle-sized
    projects may fall into.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在进一步讨论之前，让我尝试给你一个不同层次的大致概念，以便更好地理解这个食谱涵盖的小领域。然而，这是一个大多数小型和中型项目可能会遇到的领域。
- en: 'In broad lines, there are three levels of integration that one can achieve
    with PayPal:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在大体上，使用 PayPal 可以实现三个层次的集成：
- en: '**Express checkout:** Within a seller account in PayPal, you can create buttons
    with information related to each item that you may be selling (name, description,
    item number, and pricing). You can have up to 1000 different buttons or items
    defined in this way. After that, it is a matter of setting the buttons on the
    HTML, to go along with the application. Regarding web2py, it is really simple
    to just copy the code that PayPal creates for each button in a text field in your
    product `db`, and then just present it on the screen whenever it''s needed. Using
    this method, one can opt for different purchase experiences including straight
    checkout or cart management (managed by PayPal), which would let you add or remove
    items from within the checkout screen in PayPal. I don''t like this method, unless
    you would be selling very, very few item codes, as it may get to be a pain to
    maintain your articles in PayPal. If you are selling a few services or whatever
    with a small set of prices, it might very well be worth it, as you don''t have
    to work much from the programming point of view, and it''s really simple to set
    up.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速结账:** 在 PayPal 的卖家账户中，您可以创建与您可能销售的每个项目相关的按钮信息（名称、描述、项目编号和定价）。您可以以这种方式定义多达
    1000 个不同的按钮或项目。之后，只需将按钮设置在 HTML 中，与应用程序一起使用即可。关于 web2py，只需将 PayPal 为每个按钮创建的代码复制到您的产品
    `db` 中的文本字段，然后在需要时将其显示在屏幕上，这实际上非常简单。使用这种方法，可以选择不同的购买体验，包括直接结账或购物车管理（由 PayPal 管理），这可以让您在
    PayPal 的结账屏幕中添加或删除项目。我不喜欢这种方法，除非您要销售非常非常少的商品代码，因为这可能会使您在 PayPal 上维护文章变得痛苦。如果您销售少量服务或具有小价格组合的商品，这可能会非常有价值，因为您不需要从编程角度做太多工作，而且设置起来非常简单。'
- en: '**Standard integration:** This is the one that we will be covering in this
    article. It basically lets you manage your own product database, and so on, and
    sends all the data to PayPal at the moment of payment, so that the whole checkout
    process is managed at PayPal. After the transaction has been completed, you can
    choose (as per configuration of your profile in your PayPal seller account) whether
    the customer is redirected back to your domain (you can set up a default URL to
    return to, or send that URL dynamically each time you send the data for the checkout,
    but the functionality needs to be activated in your seller account). The following
    two things need to be mentioned here, which I feel are part of the standard integration,
    although they are not required in order to have your basic site working:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准集成:** 这是我们将在本文中介绍的内容。它基本上允许您管理自己的产品数据库等，并在支付时将所有数据发送到 PayPal，以便整个结账过程在
    PayPal 上管理。交易完成后，您可以选择（根据您在 PayPal 卖家账户中的个人资料配置）是否将客户重定向回您的域名（您可以设置一个默认 URL 返回，或者每次发送结账数据时动态发送该
    URL，但此功能需要在您的卖家账户中激活）。以下两点需要在此处提及，我认为它们是标准集成的一部分，尽管它们不是使您的网站基本功能正常工作的必需品：'
- en: '**Payment Data Transfer (PDT):** This would be the process by which the customer
    is sent back to your domain, which lets you capture the transaction data (payment
    confirmation data from PayPal), and shows it in a confirmation screen in your
    own domain, with any further information you may want to show, or redirect the
    customer to continue his shopping. It is not completely safe, as nothing guarantees
    that the customer will be redirected; this may well happen, because in some cases,
    PayPal doesn''t execute the redirection, but forces the customer to click on an
    extra button to return to your domain, so as to give the opportunity to the customer
    to join PayPal. This happens whenever the customer pays by credit card and not
    using his PayPal account.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付数据传输 (PDT):** 这将是一个将客户送回您域名的流程，让您能够捕获交易数据（来自 PayPal 的支付确认数据），并在您自己的域名中的确认屏幕上显示，同时可以显示您可能想要显示的任何其他信息，或者将客户重定向以继续购物。这并不完全安全，因为没有什么是保证客户会被重定向的；这种情况可能发生，因为在某些情况下，PayPal
    不会执行重定向，而是强制客户点击一个额外的按钮返回您的域名，以便给客户加入 PayPal 的机会。当客户使用信用卡支付而不是使用他的 PayPal 账户时，这种情况就会发生。'
- en: '**Instant Payment Notification (IPN):** This is a messaging service that connects
    to your domain to send the information of each transaction processed at Paypal.
    It doesn''t stop sending the message until you acknowledge its reception (or four
    days pass without acknowledgement). This is the safest way to collect all the
    data from all the transactions processed at PayPal, and trigger any internal process
    that you may have. Usually, you will want to do the shipping of your products
    at this point.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时支付通知 (IPN):** 这是一个消息服务，它连接到您的域名，以发送在PayPal上处理的每笔交易的信息。它会在您确认接收（或四天未确认）之前不断发送消息。这是收集PayPal上所有交易数据的最佳方式，并触发您可能有的任何内部流程。通常，您会在此时进行产品的发货。'
- en: '**Detailed integration:** In here, I am really grouping a number of other methods
    ands APIs, that I will not be detailing; some of them for very specific uses.
    The only method that I would like to mention more specifically is **Name Value
    Pairs (NVP)** , as I feel that it gives you a very simple programing interface
    with which you can do very detailed processes controlling all your data, and all
    your transaction flow from your domain. Using NVP, you can, for example, capture
    all the data related to a payment in your domain, and only at that point, send
    all the information to PayPal to process the payment (as opposed to processing
    the checkout, which is what we are doing with the previous items). You have a
    good example as to how to implement this at [http://web2py.com/appliances/default/show/28](http://web2py.com/appliances/default/show/28),
    or go to the main web page, and find it under free applications, **PayPalEngine**,
    developed by *Matt Sellers*. You should, however, check the detailed documentation
    at PayPal, as the process involves many steps, in order to ensure the maximum
    security of your transactions.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细集成:** 在这里，我实际上是在汇总许多其他方法和API，我将不会详细说明；其中一些用于非常特定的用途。我想特别提到的唯一方法是**名称值对
    (NVP)**，因为它提供了一个非常简单的编程接口，您可以使用它进行非常详细的过程控制，管理所有数据以及从您的域名到所有交易流程。使用NVP，例如，您可以在您的域名中捕获与支付相关的所有数据，然后仅在这一点上，将所有信息发送到PayPal进行处理（与处理结账相反，这是我们之前所做的事情）。您可以在[http://web2py.com/appliances/default/show/28](http://web2py.com/appliances/default/show/28)找到一个很好的实现示例，或者访问主网页，在免费应用程序下找到它，**PayPalEngine**，由*Matt
    Sellers*开发。然而，您应该检查PayPal的详细文档，因为该过程涉及许多步骤，以确保交易的最大安全性。'
- en: So basically, in express checkout, PayPal manages your cart (and master data),
    the checkout process, and of course, payments. With standard integration, PayPal
    manages checkout and payments, and with further detailed integration, you can
    make it so that it manages only the payments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，在快速结账过程中，PayPal管理您的购物车（和主数据）、结账流程，当然，还有支付。使用标准集成，PayPal管理结账和支付，而使用更详细的集成，您可以使其仅管理支付。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Before moving on, all the technical documentation regarding integration with
    PayPal can be found at:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有关与PayPal集成的所有技术文档可以在以下位置找到：
- en: '[https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/library_documentation](http://https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/library_documentation)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/library_documentation](http://https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/library_documentation)'
- en: 'A link to this URL, in case this changes, can be found by clicking on the documentation
    link at:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此链接发生变化，可以通过点击以下文档链接找到该链接：
- en: '[https://developer.paypal.com/](http://https://developer.paypal.com/)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.paypal.com/](http://https://developer.paypal.com/)'
- en: 'So, moving on to how to use the standard integration, the first thing you should
    do is create yourself a sandbox account. You do this at `https://developer.paypal.com/`.
    Create yourself an account, and once logged in, create at least two test accounts:
    a `seller` and a `buyer` respectively. There is a good guide on all the necessary
    steps called **PP sandbox user guide**, which you can find at the documentation
    link provided before, or on an HTML version at [https://cms.paypal.com/us/cgi-bin/?
    cmd=_render-content&content_ID=developer/howto_testing_sandbox](http://https://cms.paypal.com/us/cgi-bin/?).
    Everything on how to set your account up and start running, is described there.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，关于如何使用标准集成，您应该做的第一件事是为自己创建一个沙盒账户。您可以在`https://developer.paypal.com/`上完成此操作。创建自己的账户，登录后，创建至少两个测试账户：一个`seller`和一个`buyer`。有一个很好的指南，称为**PP沙盒用户指南**，您可以在之前提供的文档链接中找到，或者在一个HTML版本中查看[https://cms.paypal.com/us/cgi-bin/?
    cmd=_render-content&content_ID=developer/howto_testing_sandbox](http://https://cms.paypal.com/us/cgi-bin/?)。如何设置您的账户并开始运行的所有信息都在那里描述。
- en: Once you have that set up and running, you will have your seller ID and e-mail
    (you can use any of them to identify yourself to PayPal on the code below, although
    I prefer the ID, if only to avoid possible spam).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置并运行，您将拥有您的卖家ID和电子邮件（您可以使用它们中的任何一个在下面的代码中向PayPal进行身份验证，尽管我更喜欢ID，以避免可能的垃圾邮件）。
- en: 'OK, so now, we can already create the **checkout button** that will take our
    customers to the PayPal site with all our cart data. Before moving further, you
    can find all documentation related to this point at the documentation link provided
    before, under the *Website Payments Standard Integration Guide*, or directly in
    an HTML format at:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么现在，我们已经可以创建一个**结账按钮**，该按钮将带我们的客户访问包含所有购物车数据的PayPal网站。在继续之前，您可以在之前提供的文档链接下找到与此点相关的所有文档，在*网站支付标准集成指南*中，或者直接在HTML格式中查看：
- en: '[https://cms.paypal.com/us/cgi-bin/? cmd=_render-content&content_ID=developer/howto_html_wp_standard_overview](http://https://cms.paypal.com/us/cgi-bin/?)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cms.paypal.com/us/cgi-bin/? cmd=_render-content&content_ID=developer/howto_html_wp_standard_overview](http://https://cms.paypal.com/us/cgi-bin/?)'
- en: 'Check the information about *Third-Party Shopping Carts*. Anyway, creating
    the button to send all the information is actually very simple. All that is needed
    is the following code in your checkout page view:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 检查有关*第三方购物车*的信息。无论如何，创建发送所有信息的按钮实际上非常简单。您只需要在结账页面视图中添加以下代码：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A couple of comments regarding the listing `lst:CheckoutButton:`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于列表`lst:CheckoutButton:`的一些评论
- en: In all cases, to move from sandbox to production, the URL to use only needs
    to change from [https://www.sandbox.paypal.com](http://https://www.sandbox.paypal.com)
    to [https://www.paypal.com](http://https://www.paypal.com).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有情况下，要从沙盒环境迁移到生产环境，只需将使用的URL从[https://www.sandbox.paypal.com](http://https://www.sandbox.paypal.com)更改为[https://www.paypal.com](http://https://www.paypal.com)即可。
- en: You can create the buttons using the `create new button` functionality at your
    seller account, and then re-use the code. It would let you to choose the language
    and the type of button to use. That way, you will get the correct link to the
    image to be used for your PayPal button.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用卖家账户中的“创建新按钮”功能来创建按钮，然后重用该代码。这将让您选择要使用的语言和按钮类型。这样，您将获得用于您的PayPal按钮的正确图片链接。
- en: The field `cmd` with `value _cart` is very important. Read the documentation
    to see the possible values of this field, depending on what you want to do. I
    am assuming a cart scenario on this example.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段`cmd`的`value _cart`非常重要。阅读文档以查看此字段的可能值，具体取决于您想做什么。在这个例子中，我假设了一个购物车场景。
- en: The fields `shopping_url, notify_url`, and `return` can be omitted, if you set
    up your seller account profile. If you set it up here, this takes precedence over
    the default values set up in your seller account.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您设置了卖家账户配置文件，则可以省略字段`shopping_url, notify_url`和`return`。如果在这里设置，则它将优先于在您的卖家账户中设置的默认值。
- en: The field `custom`, I think, is rather important, as it is one of the few fields
    that lets you introduce data not shown to the customer, that may allow you to
    track any extra information. It is per transaction (not per item). In this case,
    I choose to use an internal event code to track all purchases related to an event
    (special `promotion`, if you like or whatever).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段`custom`我认为相当重要，因为它是少数几个允许您引入不向客户显示的数据的字段之一，这可能允许您跟踪任何额外信息。它是按交易（而不是按项目）计算的。在这种情况下，我选择使用内部事件代码来跟踪与某个事件（如特殊的`promotion`或任何其他）相关的所有购买。
- en: As you can see, I created a loop with all the cart items to do the checkout,
    by passing a dictionary with all the product data. I have the information of the
    items purchased in the session. They get named and numbered following the PayPal
    rules.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所见，我创建了一个循环，包含所有购物车项目以进行结账，通过传递包含所有产品数据的字典。我在会话中拥有已购买商品的信息。它们按照PayPal规则命名和编号。
- en: Regarding the discount, even though you set the discounts per item, PayPal,
    only shows a discount total. I don't know if this is different in the Pro version.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于折扣，尽管您为每个商品设置了折扣，但PayPal只显示折扣总额。我不知道这是否在Pro版本中有所不同。
- en: For more information, you should check the documentation named before, which
    includes a list of all the fields available to you (which include shipping charges,
    and so on).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，您应查阅之前提到的文档，其中包含您可用的所有字段列表（包括运费等）。
- en: '**Checkout confirmation/payment data transfer:** Once the customer finishes
    paying through PayPal, he will be redirected to your website, automatically, if
    it is set up in the account and he is already a PayPal user (otherwise he will
    have to click on a button to return to your site). This section shows you how
    to set your application so that it will receive the payment data confirmation
    from PayPal, and show a confirmation to your customer.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**结账确认/支付数据传输：**一旦客户通过PayPal完成支付，如果账户中已设置并他是PayPal用户（否则他需要点击按钮返回您的网站），他将被自动重定向到您的网站。本节向您展示如何设置您的应用程序，以便它将从PayPal接收支付数据确认，并向客户显示确认信息。'
- en: 'You can read detailed documentation on this subject here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处阅读有关此主题的详细文档：
- en: '[https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_html_paymentdatatransfer](http://https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_html_paymentdatatransfer)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_html_paymentdatatransfer](https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&content_ID=developer/howto_html_paymentdatatransfer)'
- en: 'Here, you can see how to set it up in detail, so that you know where to get
    your token from, which you need to identify yourself to PayPal, to confirm and
    get the data. In any case, refer to the following figure representing a *Diagram
    of the Basic flow of a PDT transaction* (picture taken from PayPal docs), so as
    to give you a detailed view of the process flow:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以详细了解如何设置，以便您知道从哪里获取您的令牌，这是您需要用来向PayPal确认并获取数据的。在任何情况下，请参考以下表示*基本PDT交易流程图*的图（来自PayPal文档），以便给您一个详细的过程流程视图：
- en: '![How to do it...](img/5467OS_07_diag1.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/5467OS_07_diag1.jpg)'
- en: In the listing `lst:generic-def`, I included a number of generic functions that
    I have used in setting up the interface. The `Connection` class definition is
    a modified version of a generic connection example that I found while surfing
    the web, but I cannot really recall where. The `add_to_cart, remove_from_cart,
    empty_cart`, and `checkout` that I included as an example of how to set up your
    cart, which are taken from **EStore**, can be found at [http://www.web2py.com/appliances/default/show/24](http://www.web2py.com/appliances/default/show/24).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lst:generic-def`列表中，我包含了一些我在设置界面时使用的通用函数。`Connection`类定义是我在网上冲浪时找到的一个通用连接示例的修改版本，但我真的不记得具体在哪里找到了。我包含的`add_to_cart`、`remove_from_cart`、`empty_cart`和`checkout`作为如何设置购物车的示例，这些是从**EStore**中提取的，可以在[http://www.web2py.com/appliances/default/show/24](http://www.web2py.com/appliances/default/show/24)找到。
- en: 'Again, please understand that the different methods are oversimplified here,
    to try to explain in a few lines the different possibilities:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里的不同方法被过度简化了，试图用几行文字解释不同的可能性：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, confirm, at the listing `lst:confirm`, will process the information
    sent from PayPal, with the four step process described in the previous diagram
    of the basic flow of a PDT transaction, steps 2,3,4, and 5.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`lst:confirm`列表中确认，将处理从PayPal发送的信息，按照之前基本PDT交易流程图中的四个步骤进行，步骤2、3、4和5。
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Just for the sake of completeness, I am adding a very basic example of `confirm.html`,
    which you can see in the listing `lst:confirmhtml`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了完整性，我添加了一个非常基础的`confirm.html`示例，您可以在`lst:confirmhtml`列表中看到。
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Instant Payment Notification (IPN)** : As mentioned before, one cannot trust
    the PDT process to receive the information from all transactions, as a great number
    of things can happen. Thus, you need to implement an additional process, if you
    need to do additional processing of the information from your sales, or if you
    want to keep a local database of the actual sales processed.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**即时支付通知（IPN）**：如前所述，不能完全信任PDT过程来接收所有交易的信息，因为可能会发生许多事情。因此，如果你需要对你的销售信息进行额外的处理，或者如果你想保留实际处理的销售的本地区域数据库，你需要实现一个额外的过程。'
- en: This is done with IPN. You can find all the related documentation at the documentation
    site URL given previously. You will need to turn on the IPN functionality at your
    seller account, as well as give a default URL to receive those messages, which
    should be equal to the view in which you process them. In the case of this example,
    it would be:[http://www.yourdomain.com/yourapp/default/ipn_handler](http://www.yourdomain.com/yourapp/default/ipn_handler)>.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过IPN完成的。你可以在之前给出的文档站点URL中找到所有相关文档。你需要在你的卖家账户中启用IPN功能，并给出一个默认URL来接收这些消息，这个URL应该等于你处理它们的视图。在这个例子中，它将是：[http://www.yourdomain.com/yourapp/default/ipn_handler](http://www.yourdomain.com/yourapp/default/ipn_handler)>。
- en: The process is quite similar to that of PDT; even the variables are the same.
    The main difference is that IPNs are sent from PayPal, until you acknowledge them.
    The view for this function, `default/ipn_handler.html`, can very well be left
    blank. I am also including the table definition for logging the messages from
    PayPal.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程与PDT的过程非常相似；甚至变量都是相同的。主要区别在于IPN是从PayPal发送的，直到你确认它们。这个功能的视图`default/ipn_handler.html`完全可以留空。我还包括了一个用于记录PayPal消息的表定义。
- en: 'Anyway, you can find in the listing `lst:ipnhandler`, an example of how to
    set them up:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你可以在列表`lst:ipnhandler`中找到一个如何设置的示例：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The only thing missing would be to process the information received, and check
    for errors or possible fraud attempts. You can see an example function in the
    listing `lst:processipn`. Although this is probably something that would change
    quite a bit from one project to the next, I hope that it may serve you as a rough
    guide.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺少的是处理接收到的信息，并检查错误或可能的欺诈尝试。你可以在列表`lst:processipn`中看到一个示例函数。尽管这可能是每个项目都会相当大的变化，但我希望它可能对你作为一个粗略的指南有所帮助。
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Hope that this section helped you to set up your PayPal site using web2py, or
    at least, helped you understand the basic concepts behind setting up one, and
    the different possibilities that you have available.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个部分能帮助你使用web2py设置PayPal网站，或者至少帮助你理解设置一个网站背后的基本概念，以及你拥有的不同可能性。
- en: PayPal web payments standard
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PayPal网络支付标准
- en: This recipe shows an implementation of the PayPal web payments standard, using
    both encrypted requests and IPN for a secure process workflow. Note that in this
    recipe, web2py version 1.77.3 is used. Hopefully, it still works in the latest
    web2py versions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了使用加密请求和IPN实现PayPal网络支付标准的示例，以确保流程的安全性。请注意，在这个配方中，使用了web2py版本1.77.3。希望它仍然在最新的web2py版本中工作。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To implement our integration with PayPal, I started with putting together the
    code that generates an encrypted form post to PayPal, for all of our cart actions.
    If you do this, and you configure PayPal to only accept signed requests, then
    the user cannot tamper with your form and change the price of an item. To do this,
    I installed the **M2Crypto** module on our system, and created a module that will
    do the signing of the PayPal forms. Note that this does not work on the Google
    App Engine, because M2Crypto does not run on GAE.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现我们与PayPal的集成，我首先开始编写生成加密表单提交到PayPal的代码，用于我们所有的购物车操作。如果你这样做，并且配置PayPal只接受签名请求，那么用户就不能篡改你的表单并更改商品的价格。为此，我在我们的系统上安装了**M2Crypto**模块，并创建了一个模块，用于对PayPal表单进行签名。请注意，这不能在Google
    App Engine上运行，因为M2Crypto不支持GAE。
- en: I have yet to find a replacement for it that runs on the App Engine, so you
    cannot use this PayPal payments recipe in that environment.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我还没有找到在App Engine上运行的替代品，所以你不能在那个环境中使用这个PayPal支付配方。
- en: 'The encryption module (`crypt.py`) uses the certificate to sign the data and
    then encrypts it, as shown in the following code:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加密模块（`crypt.py`）使用证书对数据进行签名，然后加密它，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we construct forms in our view, and encrypt them:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在视图中构建表单，并加密它们：
- en: '[PRE39]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note that the above code calls a method full_url(), which is defined as follows:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，上述代码调用了一个名为full_url()的方法，其定义如下：
- en: '[PRE40]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, I need to be able to process our IPN responses from PayPal. The following
    code does just that. You''ll see that I only process purchase requests. I also
    left in the code that is specific to our database, about how I code product IDs,
    and then use that product ID to create records in our database. Based on the existence
    of those purchase records in our database, I allow the user to download the files
    that they purchased. So, the user cannot download their purchase until the IPN
    message is processed. This is usually 5 to 30 seconds after they submitted the
    order. Most of the time, the messages are received and processed before PayPal
    redirects the user back to our site. Our `paypal.py` controller will have a function
    to process the instant payment notification, as described in the following code
    section, (note that we have `openanything` in our modules directory. Visit[http://diveintopython.org/](http://diveintopython.org/)
    for the latest version):'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我需要能够处理我们的PayPal IPN响应。以下代码正是这样做的。你会看到我只处理购买请求。我还保留了特定于我们数据库的代码，关于如何编码产品ID，然后使用该产品ID在我们的数据库中创建记录。根据我们数据库中这些购买记录的存在，我允许用户下载他们购买的内容。因此，用户必须在IPN消息处理完毕后才能下载他们的购买内容。这通常在他们提交订单后的5到30秒内完成。大多数情况下，消息在PayPal将用户重定向回我们的网站之前就已经被接收和处理。我们的`paypal.py`控制器将有一个处理即时支付通知的函数，如以下代码部分所述（注意我们在模块目录中有`openanything`。访问[http://diveintopython.org/](http://diveintopython.org/)获取最新版本）：
- en: '[PRE41]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That's all, folks!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了，朋友们！
- en: Getting Flickr photos
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取Flickr照片
- en: This recipe can be used to get a list of Flickr photos passing the photoset
    ID.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱可以用来获取通过照片集ID过滤的Flickr照片列表。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First you need to generate an **APIKEY**, which you can do on the Flickr developers
    page:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要生成一个**APIKEY**，你可以在Flickr开发者页面上完成：
- en: '[http://www.flickr.com/services/api/misc.api_keys.html](http://www.flickr.com/services/api/misc.api_keys.html)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.flickr.com/services/api/misc.api_keys.html](http://www.flickr.com/services/api/misc.api_keys.html)'
- en: After that, you need to create a function to fetch the Flickr API. Generally,
    this is created in models, but you can do that in modules too.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你需要创建一个函数来获取Flickr API。通常，这会在模型中创建，但你也可以在模块中完成。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a function in any of your model files. We will create one called `models/plugin_flickr.py`,
    as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的模型文件中的任何一个创建一个函数。我们将创建一个名为`models/plugin_flickr.py`的函数，如下所示：
- en: '[PRE42]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now you can call that function from any controller or view. For example, in
    a controller action, as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在任何控制器或视图中调用该函数。例如，在一个控制器操作中，如下所示：
- en: '[PRE43]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the associated `views/defaul/testflickr.html`, you can add the following:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关联的`views/default/testflickr.html`中，你可以添加以下内容：
- en: '[PRE44]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The final product will look like the one shown in the following screenshot:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终产品将类似于以下截图所示：
- en: '![How to do it...](img/5467OS_07_40.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/5467OS_07_40.jpg)'
- en: Sending e-mails with Boto through Amazon Web Services (AWS)
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过亚马逊网络服务（AWS）使用Boto发送电子邮件
- en: '**Amazon Simple Email Service** is a nice way to send e-mails without needing
    to operate your own mail server. This code utilizes the `Boto` library, which
    is a Python interface for AWS.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊简单电子邮件服务**是一种无需操作自己的邮件服务器即可发送电子邮件的好方法。此代码利用了`Boto`库，它是AWS的Python接口。'
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First of all, you need to sign up for AWS at [http://aws.amazon.com](http://aws.amazon.com).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要在[http://aws.amazon.com](http://aws.amazon.com)注册AWS。
- en: Then, enable Simple Email Service at [http://aws.amazon.com/ses/](http://aws.amazon.com/ses/).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在[http://aws.amazon.com/ses/](http://aws.amazon.com/ses/)启用简单电子邮件服务。
- en: You need to obtain your Amazon `AWS-KEY` and `AWS-SECRET-KEY` from [https://aws-portal.amazon.com/gp/aws/developer/account/index.html](http://https://aws-portal.amazon.com/gp/aws/developer/account/index.html).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要从[https://aws-portal.amazon.com/gp/aws/developer/account/index.html](http://https://aws-portal.amazon.com/gp/aws/developer/account/index.html)获取你的亚马逊`AWS-KEY`和`AWS-SECRET-KEY`。
- en: 'Finally, you need to install Boto in your `web2py/site-packages` folder, or
    anywhere in your path, so that web2py can find and import it. You can find Boto
    on GitHub: [https://github.com/boto/boto](http://https://github.com/boto/boto).'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要在你的`web2py/site-packages`文件夹中安装Boto，或者在任何路径下，以便web2py可以找到并导入它。你可以在GitHub上找到Boto：[https://github.com/boto/boto](http://https://github.com/boto/boto)。
- en: Before you get **production** access to Amazon's mail servers, you have to pre-register
    every sender's and recipient's e-mail address that you want to use (up to 100).
    This is OK for development and testing, but, of course, would not work in production.
    To register an e-mail address, execute the following code, replacing `AWS-KEY`
    and `AWS-SECRET-KEY` with your own keys, and `myemail@address.com` with the e-mail
    address that you want to register.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在您获得亚马逊邮件服务器的**生产**访问权限之前，您必须预先注册您想要使用的每个发送者和接收者的电子邮件地址（最多100个）。这对于开发和测试来说是可行的，但在生产环境中当然是不行的。要注册电子邮件地址，请执行以下代码，将
    `AWS-KEY` 和 `AWS-SECRET-KEY` 替换为您自己的密钥，并将 `myemail@address.com` 替换为您想要注册的电子邮件地址。
- en: 'From the web2py shell or any other Python shell, run the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从 web2py shell 或任何其他 Python shell 中，运行以下命令：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Assuming that everything is installed and configured, as explained before,
    sending e-mails is easy:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切已按之前所述安装和配置，发送电子邮件很容易：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Making GIS amps using mapscript
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 mapscript 制作 GIS 图表
- en: '**MapServer** is an open source platform for publishing spatial data and interactive
    mapping applications to the web. Originally developed in the mid-1990s at the
    University of Minnesota, MapServer is released under an MIT-style license, and
    runs on all major platforms.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**MapServer** 是一个开源平台，用于将空间数据和交互式地图应用程序发布到网络。最初于1990年代中期在明尼苏达大学开发，MapServer
    采用 MIT 风格许可发布，并在所有主要平台上运行。'
- en: This recipe will show you how to publish geo-referenced maps using the MapServer
    web service, using a library called `mapscript`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向您展示如何使用 MapServer 网络服务通过 `mapscript` 库发布地理参考地图。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, you need to install `mapscript` from:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要从以下地址安装 `mapscript`：
- en: '[http://pypi.python.org/pypi/mapscript/5.4.2.1](http://pypi.python.org/pypi/mapscript/5.4.2.1).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://pypi.python.org/pypi/mapscript/5.4.2.1](http://pypi.python.org/pypi/mapscript/5.4.2.1).'
- en: 'You can do it by typing the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入以下命令来完成：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will also assume you have a map called `private/test2.map` in your application
    folder. A `.map` file looks in an `ascii` file that describes a map (coordinates,
    type, points with tags, and so on), and looks like the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将假设您在应用程序文件夹中有一个名为 `private/test2.map` 的地图。一个 `.map` 文件看起来像是一个 `ascii` 文件，它描述了一个地图（坐标、类型、带标签的点等），如下所示：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can read more about map files here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于地图文件的信息：
- en: '[http://mapserver.org/introduction.html](http://mapserver.org/introduction.html)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mapserver.org/introduction.html](http://mapserver.org/introduction.html)'
- en: '[http://mapserver.org/mapfile/index.html#mapfile](http://mapserver.org/mapfile/index.html#mapfile)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mapserver.org/mapfile/index.html#mapfile](http://mapserver.org/mapfile/index.html#mapfile)'
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: GIS maps are exposed through WXS services. Here, we show you a simple action
    that provides a service to publish a map stored in the file `private/test2.map:`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: GIS 地图通过 WXS 服务公开。在这里，我们向您展示一个简单的操作，该操作提供了一种服务，用于发布存储在文件 `private/test2.map`
    中的地图：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This service can be consumed by QGis ([http://www.qgis.org/](http://www.qgis.org/)),
    or any other Web MapService client ([http://en.wikipedia.org/wiki/Web_Map_Service](http://en.wikipedia.org/wiki/Web_Map_Service)),
    or a Web Feature Service client ([http://en.wikipedia.org/wiki/Web_Feature_Service](http://en.wikipedia.org/wiki/Web_Feature_Service)).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务可以通过 QGis ([http://www.qgis.org/](http://www.qgis.org/)) 或任何其他 Web MapService
    客户端 ([http://en.wikipedia.org/wiki/Web_Map_Service](http://en.wikipedia.org/wiki/Web_Map_Service))，或
    Web Feature Service 客户端 ([http://en.wikipedia.org/wiki/Web_Feature_Service](http://en.wikipedia.org/wiki/Web_Feature_Service))
    来消费。
- en: 'The URL to pass to QGIS is:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 QGIS 的 URL 是：
- en: '`http://localhost:8000/mapas/default/wxs/test2.map`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/mapas/default/wxs/test2.map`'
- en: Here, `test2.map` points to our map file (stored in the file, `private/test2.map`,
    served by the `wxs` function as described before).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`test2.map` 指向我们的地图文件（存储在文件 `private/test2.map` 中，由之前描述的 `wxs` 函数提供服务）。
- en: Google groups and Google code feeds reader
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google 群组和 Google 代码源代码订阅者
- en: In this recipe, we will implement a simple feed reader to retrieve messages
    from Google Groups and Google Code using RSS.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现一个简单的源代码阅读器，使用 RSS 从 Google 群组和 Google 代码检索消息。
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create a file `models/plugin_feedreader.py`, with the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `models/plugin_feedreader.py` 的文件，其中包含以下代码：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, in any controller, you can embed the latest Google group information:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在任何控制器中，您都可以嵌入最新的 Google 群组信息：
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Or read the latest Google code source updates:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 或者阅读最新的 Google 代码源代码更新：
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Creating SOAP web services
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SOAP 网络服务
- en: '**Simple Object Access Protocol (SOAP)** is a complex XML-based inter-process
    communication standard for web service implementation. It is widely used with
    legacy applications (especially JAVA and .NET languages), and supports type declaration
    and **Web Service Definition File (WSDL)** .'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单对象访问协议 (SOAP)** 是一种基于 XML 的复杂进程间通信标准，用于网络服务实现。它广泛用于遗留应用程序（尤其是 JAVA 和 .NET
    语言），并支持类型声明和 **Web 服务定义文件 (WSDL)** 。'
- en: web2py already supports a common infrastructure to expose web services in a
    simple way, using the **Service** tool (rss, json, jsonrpc, xmlrpc, jsonrpc, amfrpc,
    and amfrpc3).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: web2py 已经支持一种通用的基础设施，以简单的方式公开网络服务，使用 **Service** 工具（rss、json、jsonrpc、xmlrpc、jsonrpc、amfrpc
    和 amfrpc3）。
- en: 'The `PySimpleSOAP` library included in `gluon/contribs` (since version #1.82.1),
    aims to add SOAP support, extending the current philosophy.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '包含在 `gluon/contribs`（自版本 #1.82.1 以来）中的 `PySimpleSOAP` 库旨在添加 SOAP 支持，扩展当前的理念。'
- en: How to do it...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Serving operations using SOAP is as easy as decorating a function using `@service.soap`,
    declaring the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@service.soap` 装饰函数来提供操作服务，声明以下内容：
- en: Exposed operation method (camel case by convention)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开的操作方法（按惯例使用驼峰式命名）
- en: Return types
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型
- en: Parameters types
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型
- en: Types are declared using a dictionary, mapping the parameter/result name with
    the standard Python conversion functions (str, **int, float, bool**, and so on).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 类型使用字典声明，将参数/结果名称映射到标准的 Python 转换函数（str、**int、float、bool** 等）。
- en: 'For example, create an application (such as `webservices)`, and in a controller
    (sample.py), add the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建一个应用程序（例如 `webservices`），在一个控制器（sample.py）中添加以下代码：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Additionally, web2py can dynamically generate help web pages (list of operations,
    xml message examples), and the WSDL XML:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，web2py 可以动态生成帮助网页（操作列表、xml 消息示例）和 WSDL XML：
- en: 'List of operations: [http://127.0.0.1:8000/webservices/sample/call/soap](http://127.0.0.1:8000/webservices/sample/call/soap)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作列表：[http://127.0.0.1:8000/webservices/sample/call/soap](http://127.0.0.1:8000/webservices/sample/call/soap)
- en: 'Operation help (for the `SubIntegers` method, in this case): [http://127.0.0.1:8000/webservices/sample/call/soap?op=SubIntegers](http://127.0.0.1:8000/webservices/sample/call/soap?op=SubIntegers)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作帮助（对于 `SubIntegers` 方法，在这种情况下）：[http://127.0.0.1:8000/webservices/sample/call/soap?op=SubIntegers](http://127.0.0.1:8000/webservices/sample/call/soap?op=SubIntegers)
- en: 'Service description (WSDL ): [http://127.0.0.1:8000/webservices/sample/call/soap?wsdl](http://127.0.0.1:8000/webservices/sample/call/soap?wsdl)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务描述（WSDL）：[http://127.0.0.1:8000/webservices/sample/call/soap?wsdl](http://127.0.0.1:8000/webservices/sample/call/soap?wsdl)
- en: 'Sample operations list page:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 样本操作列表页面：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Sample operation help page:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 样本操作帮助页面：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can test the web service exposed by web2py using this library:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此库测试 web2py 公开的网络服务：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There's more...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**pysimplesoap** is included with recent releases of web2py, as it is being
    actively maintained. You can frequently check the version to find enhancements,
    to extend this recipe.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**pysimplesoap** 包含在 web2py 的最新版本中，因为它正在积极维护。您可以经常检查版本以查找增强功能，以扩展此食谱。'
- en: Although there are several python SOAP libraries, this one is designed to be
    as simple as possible, and is totally integrated with web2py.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几个 Python SOAP 库，但这个库被设计得尽可能简单，并且完全与 web2py 集成。
- en: 'For more information, supported features, and platforms, have a look at the
    following link:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息、支持的功能和平台，请查看以下链接：
- en: '[http://code.google.com/p/pysimplesoap/wiki/Web2Py](http://code.google.com/p/pysimplesoap/wiki/Web2Py)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/pysimplesoap/wiki/Web2Py](http://code.google.com/p/pysimplesoap/wiki/Web2Py)'
- en: Note
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To view help pages for the latest web2py versions, you should create a view,
    sample/call.html, in this example, as in new versions of web2py, for security
    reasons, generic views are not exposed by default
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看最新 web2py 版本的帮助页面，您应该在示例中创建一个视图，sample/call.html，在新版本的 web2py 中，出于安全原因，默认不公开通用视图
- en: '[PRE57]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
