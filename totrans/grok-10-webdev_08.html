<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 7. Security"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Security</h1></div></div></div><p>As it stands, our to-do list manager application can be accessed by anyone. Whoever can get to the 8080 port on the Grok server will be able to create, update, and delete projects and tasks.</p><p>If we think about what we want the application to do, it would be nice if only authenticated users are able to access it in the first place. For example, it should be possible to install the application inside a company and have only a single department there as the application's users. Users with the correct permissions could create projects and assign tasks to team members.</p><p>Grok includes the necessary tools to accomplish this, as we will see in this chapter. Here are the key concepts that we will learn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Authentication and authorization</li><li class="listitem" style="list-style-type: disc">Principals, permissions, and roles</li><li class="listitem" style="list-style-type: disc">What the default security policy is and how it is defined in the<code class="literal"> site.zcml</code> configuration file</li><li class="listitem" style="list-style-type: disc">Setting up authentication using<code class="literal"> site.zcml</code> declarations</li><li class="listitem" style="list-style-type: disc">Setting up a custom security policy</li><li class="listitem" style="list-style-type: disc">Adding and managing users</li></ul></div><div class="section" title="Authentication and authorization"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec01"/>Authentication and authorization</h1></div></div></div><p>When speaking about web application security, there are two important concepts to get right before beginning:<span class="strong"><strong> authentication</strong></span> and<span class="strong"><strong> authorization</strong></span>.</p><p>In a given application, we might have a number of users who are allowed to log in. To do so, they usually would provide a username and a password. If the username and the password match, the user has been authenticated, so the system assumes he is who he says he is. In this chapter, we will learn how to perform authentication in Grok by using plugins.</p><p>Once a user is logged in, he may want to perform a number of actions, from just viewing the application to managing it. The user is authorized to perform some or all of the available actions by giving him specific permissions to carry them out.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Principals, permissions, and roles"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec02"/>Principals, permissions, and roles</h1></div></div></div><p>In Grok, users are known by the term 'principals'. A<span class="strong"><strong> principal</strong></span> represents any entity that interacts with the application, be it a user or any kind of agent, such as a remote client program. A<span class="strong"><strong> group</strong></span> is a special kind of principal that can contain other principals. In the rest of the chapter, we will mostly use the more familiar term 'user' when talking about principals.<a id="id194" class="indexterm"/>
</p><p>Views in Grok can be protected by permissions, so that only users with the correct permission can access each view. By default, however, Grok allows everybody including authenticated users, to have unrestricted access to all of the views.</p><p>Instead of assigning and keeping track of permissions to individual users, it's more efficient to group related permissions together and assign this group to a user. That's what roles do in Grok. For example, the admin user that we have been using for accessing the Grok administration UI has the role<code class="literal"> zope.Manager</code> that grants all existing permissions to this user.</p><p>We'll learn about permissions and roles after we introduce security policies in the<span class="emphasis"><em> Setting up a custom security policy</em></span> section of this chapter.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Security policies"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec03"/>Security policies</h1></div></div></div><p>A Grok application will thus have a number of principals, permissions, and roles. The collection of these is called a<span class="strong"><strong> security policy</strong></span> and represents the global security decisions for a specific application.<a id="id195" class="indexterm"/>
</p><p>As we mentioned before, Grok applications have a default security policy that gives view permission to everybody. It also defines authenticated and unauthenticated user groups.</p><div class="section" title="Default Grok security policy definition"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec01"/>Default Grok security policy definition</h2></div></div></div><p>The security policy that Grok uses by default is defined in the<code class="literal"> site.zcml</code> file, which is inside the<code class="literal"> etc</code> directory. There are several declarations in this file which we will discuss individually.<a id="id196" class="indexterm"/>
</p><p>The following statement is the user representation for unauthenticated users in the system:</p><div class="informalexample"><pre class="programlisting">&lt;unauthenticatedPrincipal id="zope.anybody" title="Unauthenticated User" /&gt;
</pre></div><p>All of the users who visit the application without authenticating will share this same ID.</p><p>The unauthenticated group is assigned to unauthenticated principals:</p><div class="informalexample"><pre class="programlisting">&lt;unauthenticatedGroup id="zope.Anybody" title="Unauthenticated Users" /&gt;
</pre></div><p>It is useful to have this defined for group operations.</p><p>Next, we have a dynamic group that includes all of the authenticated users, irrespective of their permissions or roles:</p><div class="informalexample"><pre class="programlisting">&lt;authenticatedGroup id="zope.Authenticated" title="Authenticated Users" /&gt;
</pre></div><p>Finally, there is a group that includes all users, authenticated or not:</p><div class="informalexample"><pre class="programlisting">&lt;everybodyGroup id="zope.Everybody" title="All Users" /&gt;
</pre></div><p>We now come to the part where users are defined. In this case, there is only one user, the "site manager", with the login "admin":</p><div class="informalexample"><pre class="programlisting">&lt;principal id="zope.manager"
title="Manager"
login="admin"
password_manager="Plain Text"
password="admin"
/&gt;
</pre></div><p>As you can see, the password is assigned to this manager using plain text. You may recall that the title defined here is what we show in the creator column when listing the projects in the dashboard.</p><p>The next two declarations grant the permissions for viewing to the<code class="literal"> zope</code>. Anybody user that represents the unauthenticated principal defined earlier.</p><div class="informalexample"><pre class="programlisting">&lt;grant permission="zope.View"
principal="zope.Anybody" /&gt;
&lt;grant permission="zope.app.dublincore.view"
principal="zope.Anybody" /&gt;
</pre></div><p>Note that in this case there is no separate definition for permission, because a permission is just a name. These declarations allow all unauthenticated users to view, so by default, an application is wide open for viewing.</p><p>Next comes the role definitions:</p><div class="informalexample"><pre class="programlisting">&lt;role id="zope.Manager" title="Site Manager" /&gt;
&lt;role id="zope.Member" title="Site Member" /&gt;
</pre></div><p>A "site manager" role is defined for managing the site. Then, a "site member" role is defined for regular site users, although this role is unused in the default configuration.</p><p>Finally, all of the permissions are granted to the<code class="literal"> zope.Manager</code> role by using<code class="literal"> grantAll</code>.</p><div class="informalexample"><pre class="programlisting">&lt;grantAll role="zope.Manager" /&gt;
&lt;grant role="zope.Manager"
principal="zope.manager" /&gt;
</pre></div><p>This means that users with the manager role will get all defined permissions. The role is then assigned to the user we defined earlier in the<span class="emphasis"><em> Principals, permissions, and roles</em></span> section.</p><p>To recap, a security policy consists of:<a id="id197" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A number of users who can log into the application.</li><li class="listitem" style="list-style-type: disc">Groups of users, which can contain any number of users. A user can also belong to several groups.</li><li class="listitem" style="list-style-type: disc">Specific permissions for allowing these users to work with parts of the application.</li><li class="listitem" style="list-style-type: disc">Roles that can be assigned multiple permissions, so that a user or group can be assigned a role that includes all related permissions for a task. This greatly simplifies permission administration.</li></ul></div></div><div class="section" title="Modifying the security policy"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec02"/>Modifying the security policy</h2></div></div></div><p>So far, we have been accessing the application by using the "manager" user that is defined in the<span class="emphasis"><em> Default Grok security policy definition</em></span> section. Now, close all of the browser windows, reopen the browser, and go to the<code class="literal"> todo</code> application URL directly, without logging in. You are unauthenticated, yet no login window will be shown. Add a project or make some other change and see how the application does it obediently.<a id="id198" class="indexterm"/>
</p><div class="mediaobject"><img src="images/7481_07_01.jpg" alt="Modifying the security policy"/></div><p>Wait a minute, didn't we say that only the view permission was assigned to the unauthenticated user? Why did Grok allow us to make changes to the projects then?</p><p>Well, the thing is, views need to be specifically protected with permissions, if we want to protect them. Until we do so it doesn't matter whether the user is authenticated or not, much less, if he holds the required permissions. Again, all of this is intended by the very open default security policy for Grok applications.<a id="id199" class="indexterm"/>
</p><div class="section" title="Modifying the default view permissions"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec01"/>Modifying the default view permissions</h3></div></div></div><p>Let's change the default security policy a bit to see how it works. In the specific case of the to-do list manager, we would like to keep unauthenticated users away, so let's begin by changing the<code class="literal"> grant permission</code> declarations to look like the following code:<a id="id200" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;grant permission="zope.View"
principal="zope.Authenticated" /&gt;
&lt;grant permission="zope.app.dublincore.view"
principal="zope.Authenticated" /&gt;
</pre></div><p>Instead of granting view permissions to everybody, we grant them to the<code class="literal"> zope.Authenticated</code> group that we defined earlier, so that only authenticated users are allowed to access the application.<a id="id201" class="indexterm"/>
</p></div><div class="section" title="Adding a new user"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec02"/>Adding a new user</h3></div></div></div><p>To test these declarations, we need to add another user to the site, because the "manager" user will get the view permission anyway. Add the following lines to<code class="literal"> site.zcml</code>, after the manager definition:<a id="id202" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;principal id="todo.user"
title="User"
login="user"
password_manager="Plain Text"
password="user"
/&gt;
</pre></div><p>We now have a<code class="literal"> todo.user</code> with "user" as the username and password. Save the file and restart Grok. It is necessary to delete and create the application again, as security policies are applied at the moment of application creation.</p><p>Now it should be possible to log in as<code class="literal"> todo.user</code>. Try it: Go to the root of the site to get the login window, and then enter the new user's login and password. You will see an error message because the new user does not have permission to manage Grok applications. Ignore the error and go to the application URL. The project dashboard will appear in the browser.</p><p>Of course, our new user can create and delete projects and tasks, as the views are not protected. Not only that, but unauthenticated users can still view and edit everything.<a id="id203" class="indexterm"/>
</p></div><div class="section" title="Protecting a view"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec03"/>Protecting a view</h3></div></div></div><p>It's time to protect a view and keep unauthenticated users away from it, as intended. Just change the dashboard view to the following:<a id="id204" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class DashBoard(grok.View):
grok.context(Todo)
grok.name('index')
grok.require('zope.View')
</pre></div><p>To protect a view with a permission, we use the<code class="literal"> grok.require</code> class annotation. Notice how we passed the permission name to it as defined in the<code class="literal"> site.zcml</code> configuration file. Restart the application (no need to re-create it this time), and then close and open the browser to lose the current authentication information. Try to access the application URL without logging in and you should get the login window. Unauthenticated users can't view the dashboard anymore. Enter the<code class="literal"> todo.user</code> credentials, and the dashboard will appear again.<a id="id205" class="indexterm"/>
</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Setting up a custom security policy"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec04"/>Setting up a custom security policy</h1></div></div></div><p>Now that we have seen how the security machinery works, we are ready to add our own security policy to the application. Let's begin by creating some permissions, and attaching them to our views.<a id="id206" class="indexterm"/>
</p><div class="section" title="Creating permissions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec03"/>Creating permissions</h2></div></div></div><p>Grok offers a very easy mechanism for defining permissions and restricting access. A permission can be defined simply by subclassing from the<code class="literal"> grok.Permission</code> class and adding a name.<a id="id207" class="indexterm"/>
</p><p>To keep things simple, let's define only four permissions for our application a general permission to view, and specific permissions for adding projects and lists or modifying list items:<a id="id208" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class ViewTodos(grok.Permission):
grok.name('todo.view')
class AddProjects(grok.Permission):
grok.name('todo.addprojects')
class AddLists(grok.Permission):
grok.name('todo.addlists')
class ChangeItems(grok.Permission):
grok.name('todo.changeitems')
</pre></div><p>Permissions are applied to views by using the<code class="literal"> grok.require</code> directive, so to protect each of our views we need to go through our application code and add an appropriate<code class="literal"> grok.require</code> statement to each view. For example:</p><div class="informalexample"><pre class="programlisting">class DashBoard(grok.View):
grok.context(Todo)
grok.name('index')
grok.require('todo.view')
class ProjectIndex(grok.View):
grok.context(Project)
grok.name('index')
grok.require('todo.view')
class TodoAddList(grok.View):
grok.context(Project)
grok.name('addlist')
grok.require('todo.addlists')
class TodoDeleteProject(grok.View):
grok.context(Todo)
grok.name('deleteproject')
grok.require('todo.addprojects')
</pre></div><p>We protect the dashboard with our view permission, which means no anonymous users will be able to access it. The<code class="literal"> TodoAddList</code> view will require<code class="literal"> addlists</code> permission, and to delete a project, the<code class="literal"> addprojects</code> permission is necessary. In this way, we can protect all of our views with the permissions that we want.<a id="id209" class="indexterm"/>
</p></div><div class="section" title="Roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec04"/>Roles</h2></div></div></div><p>The views are protected with permissions, but assigning the permissions to actual users is best done by using roles. Let's define three simple roles for the application.<span class="emphasis"><em> Project members</em></span> will be able to view and change list items only.<span class="emphasis"><em> Project managers</em></span> can do all that and also create lists.<span class="emphasis"><em> Application managers</em></span> are the only ones who can create projects.<a id="id210" class="indexterm"/>
</p><p>The<code class="literal"> grok.Role</code> class is useful for defining these roles, as shown by the following code:</p><div class="informalexample"><pre class="programlisting">class ProjectMemberRole(grok.Role):
grok.name('todo.ProjectMember')
grok.permissions('todo.view','todo.changeitems')
class ProjectManagerRole(grok.Role):
grok.name('todo.ProjectManager')
grok.permissions('todo.view','todo.changeitems','todo.addlists')
class AppManagerRole(grok.Role):
grok.name('todo.AppManager')
grok.permissions('todo.view','todo.changeitems', 'todo.addlists','todo.addprojects')
</pre></div><p>Here, we have created four separate roles for different user levels in our application. Each role is assigned a name and one or more permissions by using the<code class="literal"> grok.name</code> and<code class="literal"> grok.permissions</code> declarations respectively.</p><p>As you can see, a<span class="strong"><strong> role</strong></span> is simply a collection of permissions with a name. The benefit of using such a collection instead of assigning each permission individually is that once a role is assigned to a user, it's possible to add or remove permissions from the role without having to grant or remove them from each user individually.<a id="id211" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Adding authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec05"/>Adding authentication</h1></div></div></div><p>We now have all of our views protected, but so far there are no users, so nobody can be assigned the roles that we created. We need to add a mechanism for creating and managing users, as well as a way to authenticate them and assign roles to them, so that they can use the different views.<a id="id212" class="indexterm"/>
</p><div class="section" title="The Pluggable Authentication Utility"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec05"/>The Pluggable Authentication Utility</h2></div></div></div><p>The<span class="strong"><strong> Pluggable Authentication Utility</strong></span> (<span class="strong"><strong>PAU</strong></span>) is a framework for authenticating users. It is a part of the Zope Toolkit and currently Grok offers no built-in mechanisms to work with it, but we'll see that it is not too complex.<a id="id213" class="indexterm"/>
</p><p>PAU uses plugins to do its work, so that it's possible to have plugins for different authentication sources, and easily substitute one for another, or even have them work together.</p><p>There are two types of plugins for PAU: "credentials" plugins extract credentials from a request (user and password, for example) and "authenticator" plugins check that these credentials are valid and generate a user for the application to work with, if they are.</p></div><div class="section" title="Registering PAU with our application"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec06"/>Registering PAU with our application</h2></div></div></div><p>To be able to use PAU in our application, we first need to register it as a local utility. A <span class="strong"><strong> utility</strong></span> is simply a service that an application can provide. Being local means that it can store information and configuration specific to each instance of the application.<a id="id214" class="indexterm"/>
</p><p>Here's how we can register PAU in our main<code class="literal"> todo</code> application definition. First, we import<code class="literal"> PluggableAuthentication</code>, which is a factory that will create the actual PAU object. We also import<code class="literal"> IAuthentication</code>, which is the interface that our PAU utility must provide in order to integrate with the authentication machinery.<a id="id215" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from zope.app.authentication.authentication import PluggableAuthentication
from zope.app.security.interfaces import IAuthentication
from auth import setup_authentication
</pre></div><p>When we register a PAU utility, we need to configure it to use the appropriate plugins, which is the purpose of the<code class="literal"> setup_authentication import</code> statement in the preceding code.</p><p>Now we register the utility by using the<code class="literal"> grok.local_utility</code> directive and passing to the directive the<code class="literal"> PluggableAuthentication</code> factory, the interface that it's going to provide, and the<code class="literal"> setup</code> function. Keep in mind that this directive is in no way exclusive to PAU­ any kind of service can be registered like this:</p><div class="informalexample"><pre class="programlisting">class Todo(grok.Application, grok.Container):
grok.implements(ITodo)
grok.local_utility(
PluggableAuthentication, provides=IAuthentication,
setup=setup_authentication,
)
</pre></div><p>That's all we need to do for now in the main<code class="literal"> app.py</code> file. Let's add the<code class="literal"> setup_authentication</code> method, and all of the other security classes and views, in another module. Create the<code class="literal"> auth.py</code> file and add the following lines to it:<a id="id216" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">def setup_authentication(pau):
pau.credentialsPlugins = ['credentials']
pau.authenticatorPlugins = ['users']
</pre></div><p>This is a very simple method that just assigns a plugin named<code class="literal"> credentials</code> to the<code class="literal"> credentialsPlugins</code> of our PAU, and assigns another plugin named<code class="literal"> users</code> to the<code class="literal"> authenticatorPlugins</code>. The first will take care of extracting the user's credentials from the browser request and making them available to the application. The<code class="literal"> users</code> plugin will be used for authentication. Of course, these plugins do not exist yet; we need to create them.</p></div><div class="section" title="Adding a credentials plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec07"/>Adding a credentials plugin</h2></div></div></div><p>For the credential extraction service, we are going to use a plugin called<code class="literal"> SessionCredentialsPlugin</code>, which comes with the Zope Toolkit. As its name implies, this plugin stores the credentials extracted by requesting the session, so that the application can easily use this information. As we don't need to store any application-specific information inside the plugin, let's use a global utility this time.<a id="id217" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from zope.app.authentication.session import SessionCredentialsPlugin
from zope.app.authentication.interfaces import ICredentialsPlugin
class MySessionCredentialsPlugin(grok.GlobalUtility, SessionCredentialsPlugin):
grok.provides(ICredentialsPlugin)
grok.name('credentials')
loginpagename = 'login'
loginfield = 'login'
passwordfield = 'password'
</pre></div><p>A<span class="strong"><strong> global utility</strong></span> is simply a service that is not stored in the application data, but resides in a registry that's available to all application instances in Grok. We will explain utilities in more detail in Chapter 11.</p><p>Notice how we inherit from both<code class="literal"> grok.GlobalUtility</code> and the<code class="literal"> SessionCredentialsPlugin</code> that we mentioned earlier. The<code class="literal"> grok.name</code> directive is very important here because it assigns a name to the plugin that we configured earlier in the<code class="literal"> setup_authentication</code> method for our PAU.<a id="id218" class="indexterm"/>
</p><p>After that comes a few class variables that are used to configure how the plugin works.<code class="literal"> loginpagename</code> is the name of the view that will be shown whenever a user attempts to access a protected page. Typically, this points to a login form.<code class="literal"> loginfield</code> and<code class="literal"> passwordfield</code> are the names of the fields within this form that will contain the credentials of the user. They will be used by the authenticator plugin to authenticate the user with the application.</p><div class="section" title="The login form"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec04"/>The login form</h3></div></div></div><p>Now that we have configured the credentials plugin, to look for the login form when a user wants to access a protected view, we might as well create the form immediately.<a id="id219" class="indexterm"/>
</p><p>First, we define a form schema by using an interface. The<code class="literal"> login</code> and<code class="literal"> password</code> fields should have the exact same names that we configured in the credentials plugin. We added a<code class="literal"> camefrom</code> parameter that will be used to redirect the user to the page he wanted to view before he logged in.</p><div class="informalexample"><pre class="programlisting">class ILoginForm(Interface):
login = schema.BytesLine(title=u'Username', required=True)
camefrom = schema.BytesLine(title=u'', required=False)
password = schema.Password(title=u'Password', required=True)
</pre></div><p>The<code class="literal"> SessionCredentialsPlugin</code> automatically adds this variable to the request when it redirects the user to the login form, so the name has to be the same. That's why we assign an empty string to the form field<code class="literal"> prefix</code> in the following code to keep the name intact.<a id="id220" class="indexterm"/>
</p><p>Notice that we use the<code class="literal"> grok.require</code> declaration to assign the permission<code class="literal"> zope.Public</code> to the view. This permission is defined in the Zope Toolkit that powers Grok and is assigned to the views that everyone can see. We use this permission to make it explicit that every visitor to our application can get to the login form.</p><div class="informalexample"><pre class="programlisting">class Login(grok.Form):
grok.context(Interface)
grok.require('zope.Public')
label = "Login"
template = grok.PageTemplateFile('custom_edit_form.pt')
prefix = ''
form_fields = grok.Fields(ILoginForm)
</pre></div><p>We need a<code class="literal"> setUpWidgets</code> method inside this class, so that we can make sure that the<code class="literal"> camefrom</code> field is not displayed on the form, which uses the custom template we created back in Chapter 5. This is done so that it looks integrated with the design that we are using.</p><div class="informalexample"><pre class="programlisting">def setUpWidgets(self, ignore_request=False):
super(Login,self).setUpWidgets(ignore_request)
self.widgets['camefrom'].type = 'hidden'
</pre></div><p>Finally, the<code class="literal"> handle_login</code> action redirects the user to the<code class="literal"> camefrom</code> URL, or to the site root if<code class="literal"> camefrom</code> is not available. If the user enters invalid credentials, the login form will be displayed again.</p><div class="informalexample"><pre class="programlisting">@grok.action('login')
def handle_login(self, **data):
self.redirect(self.request.form.get('camefrom', self.url(grok.getSite())))
</pre></div><p>That's it. Look at the form in action, in the next screenshot:<a id="id221" class="indexterm"/>
</p><div class="mediaobject"><img src="images/7481_07_02.jpg" alt="The login form"/></div></div><div class="section" title="The logout view"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec05"/>The logout view</h3></div></div></div><p>We have a login mechanism, so we need a way to finish a session and maybe log in as a different user. We will add a logout view to take care of this requirement:<a id="id222" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from zope.app.security.interfaces import IAuthentication, IUnauthenticatedPrincipal, ILogout
class Logout(grok.View):
grok.context(Interface)
grok.require('zope.Public')
def update(self):
if not IUnauthenticatedPrincipal.providedBy( self.request.principal):
auth = component.getUtility(IAuthentication)
Ilogout(auth).logout(self.request)
</pre></div><p>First, we need to determine if the current user is logged in, which we do by getting this information from the request by using<code class="literal"> self.request.principal</code> and checking to see if it provides the<code class="literal"> IUnauthenticatedPrincipal</code> interface. If it does, then we'll know that this user is not authenticated. If it turns out that he is authenticated, we look for our PAU by using<code class="literal"> component.getUtility</code> and calling the<code class="literal"> logout</code> method.</p><p>This view needs a template, which we will keep pretty simple for now. Take a look at the next screenshot to see this view in action.<a id="id223" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Logged out&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;You are now logged out.&lt;/p&gt;
&lt;p&gt;&lt;a tal:attributes="href python:view.url(context)"&gt; Log in again&lt;/a&gt;.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div><div class="mediaobject"><img src="images/7481_07_03.jpg" alt="The logout view"/></div></div></div><div class="section" title="The UserAuthenticator plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec08"/>The UserAuthenticator plugin</h2></div></div></div><p>For the authentication part, we are going to need another local utility because we need to store user information in there. We register the utility in a similar way to the PAU utility, by using the<code class="literal"> grok.local_utility</code> directive. In fact, this code goes just below the PAU declaration in our main application file,<code class="literal"> app.py:</code>
<a id="id224" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from auth import UserAuthenticatorPlugin
grok.local_utility(
UserAuthenticatorPlugin, provides=IAuthenticatorPlugin,
name='users',
)
</pre></div><p>The only difference here is that we pass a<code class="literal"> name</code> parameter that has to correspond to the name that we used for the plugin in the<code class="literal"> setup_authentication</code> method.</p><p>We are going to create a Grok container in order to store the user accounts there, so our plugin will know how to create a new user, and to decide if a login attempt has valid credentials for an existing one. Let's look at the authenticator plugin code step-by-step.</p><p>First, we need to make some imports, and then comes the plugin definition:</p><div class="informalexample"><pre class="programlisting">from zope.app.authentication.session import SessionCredentialsPlugin
from zope.app.authentication.interfaces import ICredentialsPlugin
from zope.app.authentication.interfaces import IAuthenticatorPlugin
from zope.app.authentication.interfaces import IprincipalInfo
class UserAuthenticatorPlugin(grok.LocalUtility):
grok.implements(IAuthenticatorPlugin)
grok.name('users')
def __init__(self):
self.user_folder = UserFolder()
</pre></div><p>Notice how we inherit from<code class="literal"> grok.LocalUtility</code> and implement the<code class="literal"> IAuthenticatorPlugin</code> interface. When the utility is initialized (the<code class="literal"> __init__</code> method), we create a user folder and store it there. The user folder is a simple Grok container:</p><div class="informalexample"><pre class="programlisting">class UserFolder(grok.Container):
pass
</pre></div><p>Now we come to the methods of the plugin itself. The<code class="literal"> authenticateCredentials</code> method is called whenever a login attempt is made. It receives the credentials that the credentials plugin extracted from the request, and then uses the<code class="literal"> getAccount</code> method to try to get a valid account. Next, it calls the account's<code class="literal"> checkPassword</code> method to verify the password against the one from the user's credentials.</p><div class="informalexample"><pre class="programlisting">def authenticateCredentials(self, credentials):
if not isinstance(credentials, dict):
return None
if not ('login' in credentials and 'password' in credentials):
return None
account = self.getAccount(credentials['login'])
if account is None:
return None
if not account.checkPassword(credentials['password']):
return None
return PrincipalInfo(id=account.name,
title=account.real_name,
description=account.real_name)
</pre></div><p>Notice that the<code class="literal"> authenticateCredentials</code> method returns a<code class="literal"> PrincipalInfo</code> object that contains the account name, the title or display name, and the description for the user. This object implements the<code class="literal"> IPrincipalInfo</code> interface that was imported at the top of the code, which means that you can expect to find similar behavior in other authenticator plugins.<a id="id225" class="indexterm"/>
</p><p>Here's the<code class="literal"> PrincipalInfo</code> class code that is used in this plugin. In addition to the principal information, it holds the credentials and authenticator plugins used to authorize the user.</p><div class="informalexample"><pre class="programlisting">class PrincipalInfo(object):
grok.implements(IPrincipalInfo)
def __init__(self, id, title, description):
self.id = id
self.title = title
self.description = description
self.credentialsPlugin = None
self.authenticatorPlugin = None
</pre></div><p>The<code class="literal"> IAuthenticatorPlugin</code> interface that we are implementing in this plugin needs to have a<code class="literal"> principalInfo</code> method, which should return the<code class="literal"> PrincipalInfo</code> object that we just defined:</p><div class="informalexample"><pre class="programlisting">def principalInfo(self, id):
account = self.getAccount(id)
if account is None:
return None
return PrincipalInfo(id=account.name,
title=account.real_name,
description=account.real_name)
</pre></div><p>The plugin's most important method is<code class="literal"> getAccount</code>, which tries to find a given user account inside the<code class="literal"> user_folder</code>, and returns that, or<code class="literal"> None</code>, if the user is not found. Right now we are using the Grok ZODB to store the users, but we could easily access a relational database, or an external authentication system instead, by modifying this method.<a id="id226" class="indexterm"/>
</p><p>The implementation is fairly straightforward. We use a Boolean expression to check if the login that was passed into the method is in our<code class="literal"> user</code> folder and if so, return the user object that's inside. Otherwise, we return<code class="literal"> None:</code>
</p><div class="informalexample"><pre class="programlisting">def getAccount(self, login):
return login in self.user_folder and self.user_folder[login] or None
</pre></div><div class="section" title="Adding users"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec06"/>Adding users</h3></div></div></div><p>The other important method of our authenticator plugin is<code class="literal"> addUser</code>. This creates an account object with a given username, and then uses this name to assign a role to the user.<a id="id227" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">def addUser(self, username, password, real_name, role):
if username not in self.user_folder:
user = Account(username, password, real_name, role)
self.user_folder[username] = user
role_manager = IPrincipalRoleManager(grok.getSite())
if role==u'Project Manager':
role_manager.assignRoleToPrincipal ('todo.ProjectManager',username)
elif role==u'Application Manager':
role_manager.assignRoleToPrincipal ('todo.AppManager',username)
else:
role_manager.assignRoleToPrincipal ('todo.ProjectMember',username)
</pre></div><p>After creating a user account inside our<code class="literal"> user</code> folder, the most important bit in this method is the part where we take the role that is passed from the<code class="literal"> addUser</code> form and assign the appropriate role to the new user accordingly.</p><p>Observe how we first get the<code class="literal"> RoleManager</code> for the site, as follows:</p><div class="informalexample"><pre class="programlisting">role_manager = IprincipalRoleManager(grok.getSite())
</pre></div><p>Then, when we know what role to apply, we use its<code class="literal"> assignRoleToPrincipal</code> method:</p><div class="informalexample"><pre class="programlisting">role_manager.assignRoleToPrincipal('todo.ProjectMember',username)
</pre></div><p>Here is the account class that we use:<a id="id228" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">from zope.app.authentication.interfaces import IpasswordManager
class Account(grok.Model):
def __init__(self, name, password, real_name, role):
self.name = name
self.real_name = real_name
self.role = role
self.setPassword(password)
def setPassword(self, password):
passwordmanager = component.getUtility(IPasswordManager, 'SHA1')
self.password = passwordmanager.encodePassword(password)
def checkPassword(self, password):
passwordmanager = component.getUtility(IPasswordManager, 'SHA1')
return passwordmanager.checkPassword(self.password, password)
</pre></div><p>Account objects need to include the<code class="literal"> checkPassword</code> and<code class="literal"> setPassword</code> methods, which are used together with a password manager utility. The utility does all of the heavy work, as the<code class="literal"> checkPassword</code> method simply gets the account password and passes it, together with the password that the user entered, to the<code class="literal"> checkPassword</code> method of the<code class="literal"> passwordManager</code>.</p><p>The<code class="literal"> setPassword</code> method uses the<code class="literal"> encodePassword</code> method of the<code class="literal"> passwordManager</code> utility to set the password. You may recall that we saw a 'plain-text' password manager when we worked with the<code class="literal"> site.zcml</code> declarations at the beginning of this chapter. In this case, we use a<code class="literal"> SHAI</code> password manager, to be able to store encrypted passwords.<a id="id229" class="indexterm"/>
</p></div><div class="section" title="Basic user management"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec07"/>Basic user management</h3></div></div></div><p>Of course, we need a way to add users to our application. The<code class="literal"> addUser</code> method of the<code class="literal"> UserAuthenticator</code> is exclusively called by a form that we define using the interface and schema mechanism for automatic form presentation that were discussed in Chapter 5. First, we define an interface for the form fields:<a id="id230" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class IAddUserForm(Interface):
login = schema.BytesLine(title=u'Username', required=True)
password = schema.Password(title=u'Password', required=True)
confirm_password = schema.Password(title=u'Confirm password', required=True)
real_name = schema.BytesLine(title=u'Real name', required=True)
role = schema.Choice(title=u'User role', values=[u'Project Member', u'Project Manager', u'Application Manager'], required=True)
</pre></div><p>Then we define the actual<code class="literal"> AddUser</code> form, which uses the fields from the previously defined interface to construct the form. The<code class="literal"> handle_add</code> method uses the Grok<code class="literal"> action</code> decorator to add a button to the form that will call the<code class="literal"> addUser</code> method from the authenticator plugin:</p><div class="informalexample"><pre class="programlisting">class AddUser(grok.Form):
grok.context(Interface)
grok.require('zope.ManageApplication')
label = "Add user"
template = grok.PageTemplateFile('custom_edit_form.pt')
form_fields = grok.Fields(IAddUserForm)
@grok.action('add')
def handle_add(self, **data):
users = component.getUtility(IAuthenticatorPlugin,'users')
users.addUser(data['login'],data['password'], data['real_name'],data['role'])
self.redirect(self.url(grok.getSite(),'userlist'))
</pre></div><p>Notice how we add a role field that allows the manager to assign one of our defined roles to each user. It's very important to note that this user management view is protected with the<code class="literal"> zope.ManageApplication</code> permission, which is assigned to Zope managers only. If we used one of our own permissions, we would never be able to create a user in the first place. The finished form can be seen in the following screenshot:<a id="id231" class="indexterm"/>
</p><div class="mediaobject"><img src="images/7481_07_04.jpg" alt="Basic user management"/></div><p>A simple user list view completes the user interface for our user management application:</p><div class="informalexample"><pre class="programlisting">class UserList(grok.View):
grok.context(Interface)
grok.require('zope.ManageApplication')
def update(self):
users = component.getUtility(IAuthenticatorPlugin,'users')
self.users = users.listUsers()
</pre></div><p>Nothing new here. We just get the list of users from the<code class="literal"> UserAuthenticator</code> plugin and pass it on to the view template, which simply lists the users in a table. You should now be familiar with some of this code. First, we insert our stylesheet definition using the static view, to correctly show the URL in the template:<a id="id232" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;title tal:content="context/title"&gt;To-Do list manager&lt;/title&gt;
&lt;link rel="stylesheet" type="text/css" tal:attributes="href static/styles.css" /&gt;
&lt;/head&gt;
</pre></div><p>In the main body of the template, we have the site search form that is a part of the header, and contains the application's title. Then we have a link to add a new user, which points to the form that we just defined.</p><div class="informalexample"><pre class="programlisting">&lt;body&gt;
&lt;div id="appheader"&gt;
&lt;form id="search" tal:attributes="action python:view.url('search')"&gt;
&lt;input type="text" name="query" /&gt;
&lt;input class="new_button" type="submit" value="search" /&gt;
&lt;/form&gt;
&lt;h1 id="apptitle" tal:content="context/title"&gt; To-Do list manager&lt;/h1&gt;
&lt;/div&gt;
&lt;p class="create"&gt;&lt;a href="adduser"&gt;Add a new user&lt;/a&gt;&lt;/p&gt;
</pre></div><p>The user listing is shown only if there are any users, and consists of a table that iterates through the user listing defined in the<code class="literal"> UserList</code> view (view/users).<a id="id233" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;h2 tal:condition="view/users"&gt;These are the existing users&lt;/h2&gt;
&lt;div class="projects"&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;Login&lt;/th&gt;
&lt;th&gt;Real name&lt;/th&gt;
&lt;th&gt;Role&lt;/th&gt;
&lt;/tr&gt;
&lt;tr tal:repeat="user view/users"&gt;
&lt;td tal:content="user/name"&gt;type&lt;/td&gt;
&lt;td tal:content="user/real_name"&gt;type&lt;/td&gt;
&lt;td tal:content="user/role"&gt;type&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>That's it. We can now have multiple users with different profiles in our application, as shown in the next screenshot. Create some users and test the permissions and roles to see how it works together.<a id="id234" class="indexterm"/>
</p><div class="mediaobject"><img src="images/7481_07_05.jpg" alt="Basic user management"/></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec06"/>Summary</h1></div></div></div><p>In this chapter, we learned about Grok's security features, and added authentication and authorization to our application.</p></div></div>
</body></html>