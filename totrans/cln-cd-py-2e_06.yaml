- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting More Out of Our Objects with Descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces a new concept that is more advanced in Python development
    since it features descriptors. Moreover, descriptors are not something programmers
    of other languages are familiar with, so there are no easy analogies or parallelisms
    to make.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptors are another distinctive feature of Python that take object-oriented
    programming to another level, and their potential allows users to build more powerful
    and reusable abstractions. Most of the time, the full potential of descriptors
    is observed in libraries or frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will achieve the following goals that relate to descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand what descriptors are, how they work, and how to implement them effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze the two types of descriptors (data and non-data descriptors) in terms
    of their conceptual differences and implementation details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse code effectively through descriptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze examples of good uses of descriptors, and how to take advantage of them
    for our API libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A first look at descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will explore the main idea behind descriptors to understand their
    mechanics and internal workings. Once this is clear, it will be easier to assimilate
    how the different types of descriptors work, which we will explore in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a general understanding of the idea behind descriptors, we will
    look at an example where their use gives us a cleaner and more Pythonic implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The machinery behind descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way descriptors work is not all that complicated, but the problem with them
    is that there are a lot of caveats to take into consideration, so the implementation
    details are of the utmost importance here.
  prefs: []
  type: TYPE_NORMAL
- en: To implement descriptors, we need at least two classes. For this generic example,
    the `client` class will take advantage of the functionality we want to implement
    in the `descriptor` (this is generally just a domain model class, a regular abstraction
    we create for our solution), and the `descriptor` class will implement the logic
    of the descriptor itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'A descriptor is, therefore, just an object that is an instance of a class that
    implements the descriptor protocol. This means that the interface of this class
    must contain at least one of the following magic methods (part of the descriptor
    protocol as of Python 3.6+):'
  prefs: []
  type: TYPE_NORMAL
- en: '`__get__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__set__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__delete__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__set_name__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the purposes of this initial high-level introduction, the following naming
    conventions will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `ClientClass` | The domain-level abstraction that will take advantage of
    the functionality to be implemented by the descriptor. This class is said to be
    a client of the descriptor.This class contains a class attribute (named `descriptor`
    by this convention), which is an instance of `DescriptorClass`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DescriptorClass` | The class that implements the `descriptor` itself. This
    class should implement some of the aforementioned magic methods that entail the
    descriptor protocol. |'
  prefs: []
  type: TYPE_TB
- en: '| `client` | An instance of `ClientClass`.`client = ClientClass()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `descriptor` | An instance of `DescriptorClass`.`descriptor = DescriptorClass()`.This
    object is a class attribute that is placed in `ClientClass`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: Descriptor naming conventions used in this chapter'
  prefs: []
  type: TYPE_NORMAL
- en: 'This relationship is illustrated in *Figure 6.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 1](img/16567_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The relationship between ClientClass and DescriptorClass'
  prefs: []
  type: TYPE_NORMAL
- en: A very important observation to keep in mind is that for this protocol to work,
    the `descriptor` object has to be defined as a `class` attribute. Creating this
    object as an instance attribute will not work, so it must be in the body of the
    class, and not in the `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: Always place the `descriptor` object as a class attribute!
  prefs: []
  type: TYPE_NORMAL
- en: On a slightly more critical note, readers can also note that it is possible
    to implement the descriptor protocol partially—not all methods must always be
    defined; instead, we can implement only those we need, as we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have the structure in place—we know what elements are set and how
    they interact. We need a class for the `descriptor`, another class that will consume
    the logic of the `descriptor`, which, in turn, will have a `descriptor` object
    (an instance of `DescriptorClass`) as a class attribute, and instances of `ClientClass`
    that will follow the descriptor protocol when we call for the attribute named
    `descriptor`. But now what? How does all of this fit into place at runtime?
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, when we have a regular class and we access its attributes, we simply
    obtain the objects as we expect them, and even their properties, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But, in the case of descriptors, something different happens. When an object
    is defined as a `class` attribute (and this one is a `descriptor`), when a `client`
    requests this attribute, instead of getting the object itself (as we would expect
    from the previous example), we get the result of having called the `__get__` magic
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some simple code that only logs information about the context,
    and returns the same `client` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this code, and requesting the `descriptor` attribute of an instance
    of `ClientClass`, we will discover that we are, in fact, not getting an instance
    of `DescriptorClass`, but whatever its `__get__()` method returns instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the logging line, placed under the `__get__` method, was called instead
    of just returning the object we created. In this case, we made that method return
    the `client` itself, hence making a true comparison of the last statement. The
    parameters of this method are explained in more detail in the following subsections,
    so don't worry about them for now. The crux of this example is to understand that
    the lookup of attributes behaves differently when one of those attributes is a
    descriptor (in this case, because it has a `__get__` method).
  prefs: []
  type: TYPE_NORMAL
- en: Starting from this simple, yet demonstrative, example, we can start creating
    more complex abstractions and better decorators because the important note here
    is that we have a new (powerful) tool to work with. Notice how this changes the
    control flow of the program in a completely different way. With this tool, we
    can abstract all sorts of logic behind the `__get__` method, and make the `descriptor`
    transparently run all sorts of transformations without clients even noticing.
    This takes encapsulation to a new level.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring each method of the descriptor protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we have seen quite a few examples of descriptors in action, and
    we got the idea of how they work. These examples gave us a first glimpse of the
    power of descriptors, but you might be wondering about some implementation details
    and idioms whose explanations we failed to address.
  prefs: []
  type: TYPE_NORMAL
- en: Since descriptors are just objects, these methods take `self` as the first parameter.
    For all of them, this just means the `descriptor` object itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore each method of the descriptor protocol in full
    detail, explaining what each parameter signifies, and how they are intended to
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: The get method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The signature of this magic method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `instance`, refers to the object from which the `descriptor`
    is being called. In our first example, this would mean the `client` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `owner` parameter is a reference to the class of that object, which, following
    our example (from *Figure 6.1*), would be `ClientClass`.
  prefs: []
  type: TYPE_NORMAL
- en: From the previous paragraph, we can conclude that the parameter named `instance`
    in the signature of `__get__` is the object over which the descriptor is taking
    action, and `owner` is the class of `instance`. The astute reader might be wondering
    why the signature is defined like this. After all, the class can be taken from
    `instance` directly (`owner = instance.__class__`). There is an edge case—when
    the `descriptor` is called from the class (`ClientClass`), and not from the instance
    (`client`), then the value of `instance` is `None`, but we might still want to
    do some processing in that case. That's why Python chooses to pass the class as
    a different parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following simple code, we can demonstrate the difference between a
    `descriptor` being called from the `class` or from an `instance`. In this case,
    the `__get__` method is doing two separate things for each case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call it from `ClientClass` directly, it will do one thing, which is
    composing a namespace with the names of the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And then if we call it from an object we have created, it will return the other
    message instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In general, unless we really need to do something with the `owner` parameter,
    the most common idiom is to just return the descriptor itself when `instance`
    is `None`. This is because when users are calling the descriptor from the class,
    they're probably expecting to get the descriptor itself, so it makes sense. But
    of course, it really depends on the example (later in the chapter, we'll see different
    usages with their explanations).
  prefs: []
  type: TYPE_NORMAL
- en: The set method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The signature of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is called when we try to assign something to a `descriptor`. It
    is activated with statements such as the following, in which a `descriptor` is
    an object that implements `__set__ ()`. The `instance` parameter, in this case,
    would be `client`, and the `value` would be the `"value"` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can note some similarity between this behavior and the `@property.setter`
    decorator from previous chapters, on which the argument of the setter function
    was the right-hand-side value of the statement (in this case the string `"value"`).
    We'll revisit this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If `client.descriptor` doesn't implement `__set__()`, then `"value"` (any object
    on the right-hand side of the statement) will override the descriptor entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when assigning a value to an attribute that is a `descriptor`. Make
    sure it implements the `__set__` method, and that we are not causing an undesired
    side effect.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the most common use of this method is just to store data in an object.
    Nevertheless, we have seen how powerful descriptors are so far, and that we can
    take advantage of them, for example, if we were to create generic validation objects
    that can be applied multiple times (again, this is something that if we don't
    abstract, we might end up repeating multiple times in setter methods of properties).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing illustrates how we can take advantage of this method
    in order to create generic `validation` objects for attributes, which can be created
    dynamically with functions to validate on the values before assigning them to
    the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this object in action in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that something that we would normally place in a property can be
    abstracted away into a `descriptor`, and be reused multiple times. In this case,
    the `__set__()` method would be doing what the `@property.setter` would have been
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: This is a more generic mechanism than using properties, because, as we'll see
    later, properties are a particular case of descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: The delete method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The signature for the `delete` method is simpler, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is called upon with the following statement, in which `self` would
    be the `descriptor` attribute, and `instance` would be the `client` object in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we use this method to create a `descriptor` with
    the goal of preventing you from removing attributes from an object without the
    required administrative privileges. Notice how, in this case, the `descriptor`
    has logic that is used to predicate with the values of the object that is using
    it, instead of different related objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Before seeing examples of how this object works, it's important to remark on
    some of the criteria of this descriptor. Notice the `User` class requires the
    `username` and `email` as mandatory parameters. According to its `__init__` method,
    it cannot be a user if it doesn't have an `email` attribute. If we were to delete
    that attribute and extract it from the object entirely, we would be creating an
    inconsistent object, with some invalid intermediate state that does not correspond
    to the interface defined by the class `User`. Details like this one are really
    important, in order to avoid issues. Some other object is expecting to work with
    this `User`, and it also expects that it has an `email` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it was decided that the "deletion" of an email will just simply
    set it to `None`, and that is the part of the code listing that is in bold. For
    the same reason, we must forbid someone from trying to set a `None` value to it,
    because that would bypass the mechanism we placed in the `__delete__` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see it in action, assuming a case where only users with "`admin`"
    privileges can remove their email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, in this simple `descriptor`, we see that we can delete the email from
    users that contain the "`admin`" permission only. As for the rest, when we try
    to call `del` on that attribute, we will get a `ValueError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: In general, this method of the `descriptor` is not as commonly used as the two
    previous ones, but it is shown here for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: The set name method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a relatively new method that was added in Python 3.6, and has this
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When we create the `descriptor` object in the class that is going to use it,
    we generally need the `descriptor` to know the name of the attribute it is going
    to be handling.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute name is the one we use to read from and write to `__dict__` in
    the `__get__` and `__set__` methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Before Python 3.6, the `descriptor` couldn't take this name automatically, so
    the most general approach was to just pass it explicitly when initializing the
    object. This works fine, but it has an issue in that it requires that we duplicate
    the name every time we want to use the `descriptor` for a new attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a typical `descriptor` would look like if we didn''t have this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how the `descriptor` uses this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we wanted to avoid writing the name of the attribute twice (once for
    the variable assigned inside the class, and once again as the name of the first
    parameter of the `descriptor`), we'd have to resort to a few tricks, like using
    a class decorator, or (even worse) using a meta-class.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.6, the new method `__set_name__` was added, and it receives the
    class where that descriptor is being created, and the name that is being given
    to that `descriptor`. The most common idiom is to use this method for the `descriptor`
    so that it can store the required name in this method.
  prefs: []
  type: TYPE_NORMAL
- en: For compatibility, it is generally a good idea to keep a default value in the
    `__init__` method but still take advantage of `__set_name__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this method, we can rewrite the previous `descriptor` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`__set_name__` is useful to get the name of the attribute the descriptor was
    assigned, but if we wanted to override the value, the `__init__` method would
    still take precedence, so we retain flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though we're free to name our descriptors however we like, we generally
    use the name of the descriptor (the attribute name) as a key of the `__dict__`
    of the client object, which means it'll be interpreted as an attribute. For this
    reason, try to name the descriptors you use as valid Python identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: If you're setting a bespoke name for your descriptor, use a valid Python identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Types of descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the methods we have just explored, we can make an important distinction
    among descriptors in terms of how they work. Understanding this distinction plays
    an important role in working effectively with descriptors and will also help to
    avoid caveats or common errors at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: If a descriptor implements the `__set__` or `__delete__` methods, it is called
    a **data descriptor**. Otherwise, a descriptor that solely implements `__get__`
    is a **non-data descriptor**. Notice that `__set_name__` does not affect this
    classification at all.
  prefs: []
  type: TYPE_NORMAL
- en: When trying to resolve an attribute of an object, a data descriptor will always
    take precedence over the dictionary of the object, whereas a non-data descriptor
    will not. That means that in a non-data descriptor if the object has a key on
    its dictionary with the same name as the descriptor, then that will always be
    called, and the descriptor itself will never run.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, in a data descriptor, even if there is a key in the dictionary with
    the same name as the descriptor, this one will never be used since the descriptor
    itself will always end up being called.
  prefs: []
  type: TYPE_NORMAL
- en: The following two sections explain this in more detail, with examples, to get
    a deeper idea of what to expect from each type of descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Non-data descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with a `descriptor` that only implements the `__get__` method,
    and see how it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, if we ask for the `descriptor`, we get the result of its `__get__`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we change the `descriptor` attribute to something else, we lose access
    to this value, and get what was assigned to it instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we delete the `descriptor` and ask for it again, let''s see what we
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewind what just happened. When we first created the `client` object,
    the `descriptor` attribute lay in the class, not the instance, so if we ask for
    the dictionary of the `client` object, it will be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And then, when we request the `.descriptor` attribute, it doesn't find any key
    in `client.__dict__` named `"descriptor"`, so it goes to the class, where it will
    find it ... but only as a descriptor, hence why it returns the result of the `__get__`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'But then, we change the value of the `.descriptor` attribute to something else,
    and what this does is sets the value `99` into the dictionary of the `instance`,
    meaning that this time it won''t be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So, when we ask for the `.descriptor` attribute here, it will look for it in
    the object (and this time it will find it because there is a key named `descriptor`
    in the `__dict__` attribute of the object, as the `vars` result shows us), and
    return it without having to look for it in the class. For this reason, the `descriptor`
    protocol is never invoked, and the next time we ask for this attribute, it will
    instead return the value we have overridden it with (`99`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, we delete this attribute by calling `del`, and what this does is
    to remove the key named `"descriptor"` from the dictionary of the object, leaving
    us back in the first scenario, where it''s going to default to the class where
    the descriptor protocol will be triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This means that if we set the attribute of the `descriptor` to something else,
    we might accidentally break it. Why? Because the `descriptor` doesn't handle the
    delete action (some of them don't need to).
  prefs: []
  type: TYPE_NORMAL
- en: This is called a non-data descriptor because it doesn't implement the `__set__`
    magic method, as we will see in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Data descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s look at the difference in using a data descriptor. For this, we
    are going to create another simple `descriptor` that does implement the `__set__`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the value of the `descriptor` returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to change this value to something else, and see what it returns
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The value returned by the `descriptor` didn''t change. But when we assign a
    different value to it, it must be set to the dictionary of the object (as it was
    previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, the `__set__()` method was called, and indeed it did set the value to the
    dictionary of the object, only this time, when we request this attribute, instead
    of using the `__dict__` attribute of the dictionary, the `descriptor` takes precedence
    (because it's an overriding descriptor).
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing—deleting the attribute will not work anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The reason is as follows—given that now the `descriptor` always takes precedence,
    calling `del` on an object doesn't try to delete the attribute from its dictionary
    (`__dict__`), but instead it tries to call the `__delete__()` method of the `descriptor`
    (which is not implemented in this example, hence the attribute error).
  prefs: []
  type: TYPE_NORMAL
- en: This is the difference between data and non-data descriptors. If the descriptor
    implements `__set__()`, then it will always take precedence, no matter what attributes
    are present in the dictionary of the object. If this method is not implemented,
    then the dictionary will be looked up first, and then the descriptor will run.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting observation you might have noticed is this line on the `set`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of things to question about that line, but let's break it down
    into parts.
  prefs: []
  type: TYPE_NORMAL
- en: First, why is it altering just the name of a `"descriptor"` attribute? This
    is just a simplification for this example, but, as it happens, the descriptor
    doesn't know at this point the name of the attribute it was assigned to, so we
    just used the one from the example, knowing that it was going to be `"descriptor"`.
    This is a simplification to make the example use less code, but it could be easily
    resolved by using the `__set_name__` method we studied in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: In a real example, you would do one of two things—either receive the name as
    a parameter and store it internally in the `init` method, so that this one will
    just use the internal attribute, or, even better, use the `__set_name__` method.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it accessing the `__dict__` attribute of the instance directly? Another
    good question, which also has at least two explanations. First, you might be thinking
    why not just do the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Remember that this method `(__set__`) is called when we try to assign something
    to the attribute that is a `descriptor`. So, using `setattr()` will call this
    `descriptor` again, which, in turn, will call it again, and so on and so forth.
    This will end up in an infinite recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use `setattr()` or the assignment expression directly on the descriptor
    inside the `__set__` method because that will trigger an infinite recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Why, then, is the descriptor not able to book-keep the values of the properties
    for all of its objects?
  prefs: []
  type: TYPE_NORMAL
- en: The `client` class already has a reference to the descriptor. If we add a reference
    from the descriptor back to the `client` object, we are creating circular dependencies,
    and these objects will never be garbage-collected. Since they are pointing at
    each other, their reference counts will never drop below the threshold for removal,
    and that will cause memory leaks in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Watch out for potential memory leaks when working with descriptors (or objects
    in general). Make sure you don't create circular dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: A possible alternative here is to use weak references, with the `weakref` module,
    and create a weak reference key dictionary if we want to do that. This implementation
    is explained later on in this chapter, but for the implementations within this
    book, we prefer to use this idiom (and not `weakref`), since it is fairly common
    and accepted when writing descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of now, we have studied the different kinds of descriptors, what they are,
    and how they work, and we even got a first idea of how we can use them to our
    advantage. The next section emphasizes precisely that last point: we''ll see descriptors
    in action. From now on, we''ll take a more practical approach, and see how we
    can use descriptors to achieve better code. After that, we''ll even explore examples
    of good descriptors.'
  prefs: []
  type: TYPE_NORMAL
- en: Descriptors in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen what descriptors are, how they work, and what the main
    ideas behind them are, we can see them in action. In this section, we will be
    exploring some situations that can be elegantly addressed through descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will look at some examples of working with descriptors, and we will
    also cover implementation considerations for them (different ways of creating
    them, with their pros and cons), and finally, we will discuss what the most suitable
    scenarios for descriptors are.
  prefs: []
  type: TYPE_NORMAL
- en: An application of descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with a simple example that works but will lead to some code duplication.
    Later on, we will devise a way of abstracting the repeated logic into a descriptor,
    which will address the duplication problem, and we will observe that the code
    on our client classes will reduce drastically.
  prefs: []
  type: TYPE_NORMAL
- en: A first attempt without using descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem we want to solve now is that we have a regular class with some attributes,
    but we wish to track all of the different values a particular attribute has over
    time, for example, in a `list`. The first solution that comes to mind is to use
    a property, and every time a value is changed for that attribute in the setter
    method of the property, we add it to an internal list that will keep this trace
    as we want it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that our class represents a traveler in our application that has a
    current city, and we want to keep track of all the cities that user has visited
    throughout the running of the program. The following code is a possible implementation
    that addresses these requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily check that this code works according to our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So far, this is all we need and nothing else has to be implemented. For the
    purposes of this problem, the property would be more than enough. What happens
    if we need the exact same logic in multiple places of the application? This would
    mean that this is actually an instance of a more generic problem—tracing all the
    values of an attribute in another one. What would happen if we want to do the
    same with other attributes, such as keeping track of all the tickets Alice bought,
    or all the countries she has been to? We would have to repeat the logic in all
    of these places.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, what would happen if we need this same behavior in different classes?
    We would have to repeat the code or come up with a generic solution (maybe a decorator,
    a property builder, or a descriptor). Since property builders are a particular
    (and more convoluted) case of descriptors, they are beyond the scope of this book,
    and instead, descriptors are suggested as a cleaner way of proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another solution to this problem, we can use the `__setattr__` magic method
    that was introduced in *Chapter 2*, *Pythonic Code*. We have already seen solutions
    of this kind in the previous chapter when we discussed class decorators as an
    alternative to using `__getattr__`. The considerations of these solutions are
    analogous: we would need to create a new base class that implements this generic
    method, then define some class attributes to signal the attributes that need to
    be traced, and finally implement this logic in the method. This class would be
    a mixin that could be added to the hierarchy of the classes, but that also has
    the same problems that were previously discussed (a stronger coupling and potential
    problems with a hierarchy that is not conceptually right).'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous chapter, we analyzed the differences, and we saw how
    a class decorator was better than using this magic method in a base class; here,
    I also assume descriptors will provide a cleaner solution, so the magic method
    will be avoided, and we'll explore how to solve this problem with descriptors
    in the next section. That said, the reader is more than welcome to implement the
    solution that uses `__setattr__` to compare and a similar analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The idiomatic implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now look at how to address the questions of the previous section by
    using a descriptor that is generic enough to be applied in any class. Again, this
    example is not really needed because the requirements do not specify such generic
    behavior (we haven't even followed the rule of three instances of the similar
    pattern previously creating the abstraction), but it is shown with the goal of
    portraying descriptors in action.
  prefs: []
  type: TYPE_NORMAL
- en: Do not implement a descriptor unless there is actual evidence of the repetition
    we are trying to solve, and the complexity is proven to have paid off.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a generic descriptor that, given a name for the attribute
    to hold the traces of another one, will store the different values of the attribute
    in a list.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, the code is more than what we need for the problem,
    but its intention is just to show how a descriptor would help us in this case.
    Given the generic nature of descriptors, the reader will notice that the logic
    on it (the name of their method and attributes) does not relate to the domain
    problem at hand (a Traveler object). This is because the idea of the descriptor
    is to be able to use it in any type of class, probably in different projects,
    with the same outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to address this gap, some parts of the code are annotated, and the
    respective explanation for each section (what it does, and how it relates to the
    original problem) is described in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The idea behind the descriptor is that it will create a new attribute that is
    in charge of keeping track of the changes that have been happening to some other
    attribute. For the purposes of this explanation, we can call them tracer and traced
    attributes, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some annotations and comments on the code are as follows (the numbers in the
    list correspond to the number annotations in the previous listing):'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the attribute is one of the variables assigned to the `descriptor`,
    in this case, `current_city` (the traced attribute). We pass to the `descriptor`
    the name of the variable in which it will store the trace for the variable of
    the `descriptor`. In this example, we are telling our object to keep track of
    all the values that `current_city` has had in the attribute named `cities_visited`
    (the tracer).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first time we call the descriptor, in `__init__`, the attribute for tracing
    values will not exist, in which case we initialize it to an empty list to later
    append values to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `__ init__` method, the name of the attribute `current_city` will not
    exist either, so we want to keep track of this change as well. This is the equivalent
    of initializing the list with the first value in the previous example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only track changes when the new value is different from the one that is currently
    set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `__init__` method, the `descriptor` already exists, and this assignment
    instruction triggers the actions from *step 2* (create the empty list to start
    tracking values for it), and *step 3* (append the value to this `list`, and set
    it to the key in the object for retrieval later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `setdefault` method in a dictionary is used to avoid a `KeyError`. In this
    case, an empty list will be returned for those attributes that aren't still available
    (see [https://docs.python.org/3/library/stdtypes.html#dict.setdefault](https://docs.python.org/3/library/stdtypes.html#dict.setdefault)
    for reference).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is true that the code in the `descriptor` is rather complex. On the other
    hand, the code in the `client` class is considerably simpler. Of course, this
    balance only pays off if we are going to use this `descriptor` multiple times,
    which is a concern we have already covered.
  prefs: []
  type: TYPE_NORMAL
- en: What might not be so clear at this point is that the descriptor is indeed completely
    independent from the `client` class. Nothing in it suggests anything about the
    business logic. That makes it perfectly suitable to apply it in any other class;
    even if it does something completely different, the descriptor will have the same
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: That is the true Pythonic nature of descriptors. They are more appropriate for
    defining libraries, frameworks, and internal APIs, but less so for business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen some first descriptors implemented, we can take a look
    at different ways of writing descriptors. So far, the examples have used a single
    form, but as anticipated earlier in the chapter, there are different ways in which
    we can implement descriptors, as we shall see.
  prefs: []
  type: TYPE_NORMAL
- en: Different forms of implementing descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to first understand a common issue that's specific to the nature of
    descriptors before thinking of ways of implementing them. First, we will discuss
    the problem of a global shared state, and afterward, we will move on and look
    at different ways descriptors can be implemented while taking this into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: The issue of shared state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have already mentioned, descriptors need to be set as class attributes
    in order to work. This should not be a problem most of the time, but it does come
    with some warnings that need to be taken into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with class attributes is that they are shared across all instances
    of that class. Descriptors are not an exception here, so if we try to keep data
    in a `descriptor` object, keep in mind that all of them will have access to the
    same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we incorrectly define a `descriptor` that keeps
    the data itself, instead of storing it in each object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `descriptor` object stores the data itself. This carries
    with it the inconvenience that when we modify the value for an `instance`, all
    other instances of the same classes are also modified with this value as well.
    The following code listing puts that theory into action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we change one object, and suddenly all of them are from the same
    class, and we can see that this value is reflected. This is because `ClientClass.descriptor`
    is unique; it's the same object for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, this might be what we actually want (for instance, if we were
    to create a sort of Borg pattern implementation, on which we want to share state
    across all objects from a class), but in general, that is not the case, and we
    need to differentiate between objects. Such a pattern is discussed in more detail
    in *Chapter 9*, *Common Design Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, the descriptor needs to know the value for each `instance`
    and return it accordingly. That is the reason we have been operating with the
    dictionary (`__dict__`) of each `instance` and setting and retrieving the values
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most common approach. We have already covered why we cannot use
    `getattr()` and `setattr()` on those methods, so modifying the `__dict__` attribute
    is the last standing option, and, in this case, is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the dictionary of the object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way we implement descriptors throughout this book is making the `descriptor`
    object store the values in the dictionary of the object, `__dict__`, and retrieve
    the parameters from there as well.
  prefs: []
  type: TYPE_NORMAL
- en: Always store and return the data from the `__dict__` attribute of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples we have seen so far use this approach, but in the following
    section, we will take a look at some alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Using weak references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another alternative (if we don't want to use `__dict__`) is to make the `descriptor`
    object keep track of the values for each instance itself, in an internal mapping,
    and return values from this mapping as well.
  prefs: []
  type: TYPE_NORMAL
- en: There is a caveat, though. This mapping cannot just be any dictionary. Since
    the `client` class has a reference to the descriptor, and now the descriptor will
    keep references to the objects that use it, this will create circular dependencies,
    and, as a result, these objects will never be garbage-collected because they are
    pointing at each other.
  prefs: []
  type: TYPE_NORMAL
- en: In order to address this, the dictionary has to be a weak key one, as defined
    in the `weakref (WEAKREF 01)` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the code for the `descriptor` might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This addresses the issues, but it does come with some considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: The objects no longer hold their attributes—the descriptor does instead. This
    is somewhat controversial, and it might not be entirely accurate from a conceptual
    point of view. If we forget this detail, we might ask the object, by inspecting
    its dictionary, to find things that just aren't there (for example, calling `vars(client)`
    will not return the complete data,).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It poses the requirement that the objects need to be hashable. If they aren't,
    they can't be part of the mapping. This might be too demanding a requirement for
    some applications (or it might force us to implement custom `__hash__` and `__eq__`
    magic methods).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, we prefer the implementation that has been shown so far in
    this book, which uses the dictionary of each instance. However, for completeness,
    we have shown this alternative as well.
  prefs: []
  type: TYPE_NORMAL
- en: More considerations about descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will discuss general considerations about descriptors in terms of what
    we can do with them, when it is a good idea to use them, and also how things that
    we might have initially conceived as having been resolved by means of another
    approach can be improved through descriptors. We will then analyze the pros and
    cons of the original implementation versus the one after descriptors have been
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Descriptors are a generic tool and a powerful abstraction that we can use to
    avoid code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: A good scenario where descriptors might be useful is if we find ourselves in
    a situation where we need to write properties (as in a method decorated with `@property
    @<property>.setter` or `@<property>.deleter`), but we need to do the same property
    logic multiple times. That is, if we needed something like a generic property,
    or else we'll find ourselves writing multiple properties with the same logic and
    repeating boilerplate. Properties are just a particular case of descriptors (the
    `@property` decorator is a descriptor that implements the full descriptor protocol
    to define its `get`, `set`, and `delete` actions), which means that we can even
    use descriptors to accomplish far more complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Another powerful type we have seen for reusing code was decorators, as explained
    in *Chapter 5*, *Using Decorators to Improve Our Code*. Descriptors can help us
    create better decorators by making sure that they will be able to work correctly
    for class methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to decorators, we could say that it is safe to always implement
    the `__get__()` method on them, and also make it a descriptor. When trying to
    decide whether the decorator is worth creating, consider the three-problems rule
    we stated in *Chapter 5*, *Using Decorators to Improve Our Code*, but note that
    there are no extra considerations toward descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: As for generic descriptors, besides the aforementioned three-instances rule
    that applies to decorators (and, in general, any reusable component), it is advisable
    to also keep in mind that you should use descriptors for cases where you want
    to define an internal API, which is some code that will have clients consuming
    it. This is a feature oriented more towards designing libraries and frameworks,
    rather than one-time solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Unless there is a very good reason to, or the code will look significantly better,
    we should avoid putting business logic in a descriptor. Instead, the code of a
    descriptor will contain more implementational code rather than business code.
    It is more similar to defining a new data structure or object that another part
    of our business logic will use as a tool.
  prefs: []
  type: TYPE_NORMAL
- en: In general, descriptors will contain implementation logic, and not so much business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to class decorators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we recall the class decorator we used in *Chapter 5*, *Using Decorators
    to Improve Our Code*, to determine how an event object is going to be serialized,
    we ended up with an implementation that (for Python 3.7+) relied on two class
    decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first one takes the attributes from the annotations to declare the variables,
    whereas the second one defines how to treat each file. Let's see whether we can
    change these two decorators for descriptors instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to create a descriptor that will apply the transformation over
    the values of each attribute, returning the modified version according to our
    requirements (for example, hiding sensitive information, and formatting dates
    correctly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This `descriptor` is interesting. It was created with a function that takes
    one argument and returns one value. This function will be the transformation we
    want to apply to the field. From the base definition that defines generically
    how it is going to work, the rest of the `descriptor` classes are defined, simply
    by changing the particular function each one needs.
  prefs: []
  type: TYPE_NORMAL
- en: The example uses `functools.partial` ([https://docs.python.org/3/library/functools.html#functools.partial](https://docs.python.org/3/library/functools.html#functools.partial))
    as a way of simulating sub-classes, by applying a partial application of the transformation
    function for that class, leaving a new callable that can be instantiated directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep the example simple, we will implement the `__init__()` and
    `serialize()` methods, although they could be abstracted away as well. Under these
    considerations, the class for the event will now be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see how the object behaves at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There are some differences with respect to the previous implementation that
    used a decorator. This example added the `serialize()` method and hid the fields
    before presenting them to its resulting dictionary, but if we asked for any of
    these attributes from an instance of the event in memory at any point, it would
    still give us the original value, without any transformation applied to it (we
    could have chosen to apply the transformation when setting the value, and return
    it directly on `__get__()`, as well).
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the sensitivity of the application, this may or may not be acceptable,
    but in this case, when we ask the object for its `public` attributes, the descriptor
    will apply the transformation before presenting the results. It is still possible
    to access the original values by asking for the dictionary of the object (by accessing
    `__dict__`), but when we ask for the value, by default, it will return it converted.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, all descriptors follow a common logic, which is defined in
    the base class. The descriptor should store the value in the object and then ask
    for it, applying the transformation it defines. We could create a hierarchy of
    classes, each one defining its own conversion function, in a way that the template
    method design pattern works. In this case, since the changes in the derived classes
    are relatively small (just one function), we opted for creating the derived classes
    as partial applications of the base class. Creating any new transformation field
    should be as simple as defining a new class that will be the base class, which
    is partially applied with the function we need. This can even be done ad hoc,
    so there might be no need to set a name for it.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of this implementation, the point is that since descriptors are objects,
    we can create models, and apply all rules of object-oriented programming to them.
    Design patterns also apply to descriptors. We could define our hierarchy, set
    the custom behavior, and so on. This example follows the **Open/Closed Principle**
    (**OCP**), which we introduced in *Chapter 4*, *The SOLID Principles*, because
    adding a new type of conversion method would just be about creating a new class,
    derived from the base one with the function it needs, without having to modify
    the base class itself (to be fair, the previous implementation with decorators
    was also OCP-compliant, but there were no classes involved for each transformation
    mechanism).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example where we create a base class that implements the `__init__()`
    and `serialize()` methods so that we can define the `LoginEvent` class simply
    by deriving from it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Once we achieve this code, the class looks cleaner. It only defines the attributes
    it needs, and its logic can be quickly analyzed by looking at the class for each
    attribute. The base class will abstract only the common methods, and the class
    of each event will look simpler and more compact.
  prefs: []
  type: TYPE_NORMAL
- en: Not only do the classes for each event look simpler, but the descriptor itself
    is very compact and a lot simpler than the class decorators. The original implementation
    with class decorators was good, but descriptors made it even better.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how descriptors work so far and explored some interesting situations
    in which they contribute to clean design by simplifying their logic and leveraging
    more compact classes.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we know that by using descriptors, we can achieve cleaner
    code, abstracting away repeated logic and implementation details. But how do we
    know our implementation of the descriptors is clean and correct? What makes a
    good descriptor? Are we using this tool properly or over-engineering with it?
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will analyze descriptors in order to answer these questions.
  prefs: []
  type: TYPE_NORMAL
- en: How Python uses descriptors internally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*What makes a good descriptor?* A simple answer would be that a good descriptor
    is pretty much like any other good Python object. It is consistent with Python
    itself. The idea that follows this premise is that analyzing how Python uses descriptors
    will give us a good idea of good implementations so that we know what to expect
    from the descriptors we write.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see the most common scenarios where Python itself uses descriptors to
    solve parts of its internal logic, and we will also discover elegant descriptors
    and that have been there in plain sight all along.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most resonating case of an object that is a descriptor is probably a function.
    Functions implement the `__get__` method, so they can work as methods when defined
    inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, methods are just regular functions, only they take an extra argument.
    By convention, the first argument of a method is named `self`, and it represents
    an instance of the class that the method is being defined in. Then, whatever the
    method does with `self` would be the same as any other function receiving the
    object and applying modifications to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order words, when we define something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'It is actually the same as if we define this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So, it is just another function, modifying the object, only it's defined inside
    the class, and it is said to be bound to the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call something in the form of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Python is, in fact, doing something equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is just a syntax conversion that is handled internally by Python.
    The way this works is by means of descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since functions implement the descriptor protocol (see the following listing)
    before calling the method, the `__get__()` method is invoked first (as we saw
    at the beginning of the chapter, this is part of the descriptor protocol: when
    the object being retrieved implements `__set__`, this is invoked and its result
    is returned instead). Then within this `__get__` method, some transformations
    happen before running the code on the internal callable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the `instance.method(...)` statement, before processing all the arguments
    of the callable inside the parentheses, the `"instance.method"` part is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Since `method` is an object defined as a class attribute, and it has a `__get__`
    method, this is called. What this does is convert the function into a method,
    which means binding the callable to the instance of the object it is going to
    work with.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see this with an example so that we can get an idea of what Python might
    be doing internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define a callable object inside a class that will act as a sort of
    function or method that we want to define to be invoked externally. An instance
    of the `Method` class is supposed to be a function or method to be used inside
    a different class. This function will just print its three parameters—the `instance`
    that it received (which would be the `self` parameter on the class it''s being
    defined in), and two more arguments. In the `__call__()` method, the `self` parameter
    does not represent an instance of `MyClass`, but instead an instance of `Method`.
    The parameter named `instance` is meant to be a `MyClass` type of object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Under these considerations and, after creating the object, the following two
    calls should be equivalent, based on the preceding definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'However, only the first one works as expected, as the second one gives an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We are seeing the same error we faced with a decorator in *Chapter 5*, *Using
    Decorators to Improve Our Code*. The arguments are being shifted to the left by
    one: `instance` is taking the place of `self`, `"first"` is being passed in the
    place of `instance`, and `"second"` in the place of `arg1`. There is nothing to
    provide for `arg2`.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to fix this, we need to make `Method` a descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, when we call `instance.method` first, we are going to call its `__get__()`,
    on which we bind this callable to the object accordingly (bypassing the object
    as the first parameter), and then proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, both calls work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: What we did is convert the `function` (actually the callable object we defined
    instead) into a method by using `MethodType` from the `types` module. The first
    parameter of this class should be a callable (`self`, in this case, is one by
    definition because it implements `__call__`), and the second one is the object
    to bind this function to.
  prefs: []
  type: TYPE_NORMAL
- en: Something similar to this is what function objects use in Python so they can
    work as methods when they are defined inside a class. In this example, the `MyClass`
    abstraction was trying to simulate a function object because in the actual interpreter,
    this is implemented in C, so it would be harder to experiment with, but with this
    illustration, we can get an idea of what Python is internally doing when calling
    methods of our objects.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a very elegant solution, it's worth exploring it to keep it in
    mind as a Pythonic approach when defining our own objects. For instance, if we
    were to define our own callable, it would be a good idea to also make it a descriptor
    so that we can use it in classes as class attributes as well.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in decorators for methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you might have known from looking at the official documentation (PYDESCR-02),
    all `@property`, `@classmethod`, and `@staticmethod` decorators are descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have mentioned several times that the idiom makes the descriptor return
    itself when it''s being called from a class directly. Since properties are actually
    descriptors, that is the reason why, when we ask it from the class, we don''t
    get the result of computing the property, but the entire `property` object instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For class methods, the `__get__` function in the descriptor will make sure that
    the class is the first parameter to be passed to the function being decorated,
    regardless of whether it's called from the class directly or from an instance.
    For static methods, it will make sure that no parameters are bound other than
    those defined by the function, namely undoing the binding done by `__get__()`
    on functions that make `self` the first parameter of that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example; we create a `@classproperty` decorator that works like
    the regular `@property` decorator, but for classes instead. With a decorator like
    this one, the following code should be able to solve our use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for making this work is compact and relatively straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in the previous chapter, the initialization method takes the function
    that is going to be decorated when the decorator syntax is used. The interesting
    bit here is that we take advantage of the `__get__` magic method to call that
    function with the class as a parameter when it's being called.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can appreciate how this example is different from the general boilerplate
    of the `__get__` method when called from a class: in these cases, most of the
    time, we ask if `instance` is `None`, and return `self`, but not here. In this
    case, we actually expect the instance to be `None` (because it''s being called
    from a class and not an object), so we do need the owner parameter (namely the
    class being acted upon).'
  prefs: []
  type: TYPE_NORMAL
- en: Slots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`__slots__` is a class attribute to define a fixed set of fields an object
    of that class can have.'
  prefs: []
  type: TYPE_NORMAL
- en: From the examples that have been given so far, the reader might have already
    noticed that in Python the internal representation for objects is done with dictionaries.
    This is why the attributes of an object are stored as strings in its `__dict__`
    attribute. This is the reason why we can dynamically add new attributes to an
    object or remove current ones. There is no such thing as a `"frozen"` definition
    of attributes to be declared for objects. We can also inject methods dynamically
    (and we have done so in previous examples).
  prefs: []
  type: TYPE_NORMAL
- en: All of this changes with the `__slots__` class attribute. In this attribute,
    we define as a string what the names of the attributes that are allowed in a class
    are. And from that moment on, we will not be able to dynamically add any new attributes
    to instances of this class. Trying to add extra attributes dynamically to a class
    that defines `__slots__` will result in an `AttributeError`. By defining this
    attribute, the class becomes static, so it will not have a `__dict__` attribute
    where you can add more objects dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'How, then, are its attributes retrieved if not from the dictionary of the object?
    By using descriptors. Each name defined in a slot will have its own descriptor
    that will store the value for retrieval later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: With the use of `__slots__`, Python will only reserve enough memory for the
    attributes defined on it on the new objects as they're created. This will make
    the objects not have a `__dict__` attribute, so they can't be changed dynamically,
    and any attempt to use its dictionary (for example, by using the `function vars(...)`)
    would result in a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: And because there is no `__dict__` attribute to store the values of the instance
    variables, what Python does instead is to create a descriptor for each slot and
    store the value there. This has the side effect that we cannot mix class attributes
    with instance ones (for example, if a common idiom for us would be to use a class
    attribute as a default value for an instance attribute, with this approach we
    would not be able to, because values would get overridden).
  prefs: []
  type: TYPE_NORMAL
- en: While this is an interesting feature, it has to be used with caution because
    it takes away the dynamic nature of Python. In general, this ought to be reserved
    only for objects that we know are static, and if we are absolutely sure we are
    not adding any attributes to them dynamically in other parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: As an upside of this, objects defined with slots use less memory, since they
    only need a fixed set of fields to hold values and not an entire dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing descriptors in decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now understand how Python uses descriptors in functions to make them work
    as methods when they are defined inside a class. We have also seen examples of
    cases where we can make decorators work by making them comply with the descriptor
    protocol by using the `__get__()` method of the interface to adapt the decorator
    to the object it is being called with. This solves the problem for our decorators
    in the same way that Python solves the issue of functions as methods in objects.
  prefs: []
  type: TYPE_NORMAL
- en: The general recipe for adapting a decorator in such a way is to implement the
    `__get__()` method on it and use `types.MethodType` to convert the callable (the
    decorator itself) into a method bound to the object it is receiving (the `instance`
    parameter received by `__get__`).
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, we will have to implement the decorator as an object, because
    otherwise, if we are using a function, it will already have a `__get__()` method,
    which will be doing something different that will not work unless we adapt it.
    The cleaner way to proceed is to define a class for the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Use a decorator class when defining a decorator that we want to apply to class
    methods, and implement the `__get__()` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: Final remarks about descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To wrap up our analysis on descriptors, I would like to share some thoughts
    in terms of clean code and good practices or recommendations from experience.
  prefs: []
  type: TYPE_NORMAL
- en: Interface of descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we revisited the interface segregation principle in *Chapter 4*, *The SOLID
    Principles* (the "I" in SOLID), we said that it's good practice to keep the interfaces
    small, and for that reason, we might want to separate them into smaller ones.
  prefs: []
  type: TYPE_NORMAL
- en: This idea appears here once again, not in the sense of an interface as in an
    abstract base class, but as the interface that the descriptor itself will present.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, the descriptor protocol entails four methods, but partial
    implementation is allowed. That means you don't need to implement all of them
    all the time. In fact, if you only implement the minimal required methods, that
    would be better.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you'll find that you can address your requirements by only
    implementing the `__get__` method.
  prefs: []
  type: TYPE_NORMAL
- en: Do not implement more methods than are necessary. The fewer methods you can
    implement of the descriptor protocol, the better.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you'll find that the `__delete__` method is seldom required.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design of the descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this concept, I don't mean that we can improve our object-oriented design
    capabilities by merely using descriptors (we have already covered that). But since
    descriptors are just regular objects, the rules of object-oriented design apply
    to them as well. For example, we can have base classes of descriptors, make use
    of inheritance to create more specific ones, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that all the rules and recommendations of good practices apply
    as well. For example, if you have a base class for a descriptor that only implements
    the `__get__` method, then it wouldn't be a good idea to create a sub-class of
    it that also implements the `__set__` method, as it wouldn't comply with Liskov's
    substitution principle (because we'd have a more specific type that implements
    an enhanced interface that the parent doesn't provide).
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations on descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applying type annotations on descriptors might be complicated most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: There could be issues with circular dependencies (meaning the Python file that
    contains the definition for the descriptor will have to read from the file of
    the consumer in order to get the types, but then the client needs to read the
    file with the definition of the descriptor object to use it). Even if you surmount
    these issues with the use of strings instead of the actual types, there's another
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know the exact type to annotate the descriptor methods, that means the
    descriptor is probably only useful for one type of class. And that generally defeats
    the purpose of a descriptor: the recommendation of this book is to use descriptors
    for scenarios in which we know we can benefit from a generalization, and reuse
    a lot of code. If we''re not reusing code, the complexity of having descriptors
    is not worth it.'
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, and even though it is generally good practice to always add
    annotations to our definitions, for the case of descriptors, it might be simpler
    just not to. Instead, think of it as a good opportunity for writing useful docstrings
    that accurately document the behavior of the descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Descriptors are a more advanced feature in Python that push the boundaries closer
    to metaprogramming. One of their most interesting aspects is how they make crystal
    clear that classes in Python are just regular objects, and, as such, they have
    properties that we can interact with. Descriptors are, in this sense, the most
    interesting type of attribute a class can have because their protocol facilitates
    more advanced, object-oriented possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the mechanics of descriptors, their methods, and how all of this
    fits together, making a more interesting picture of object-oriented software design.
    By understanding descriptors, we were able to create powerful abstractions that
    yield clean and compact classes. We have seen how to fix decorators that we want
    to apply to functions and methods, and we have understood a lot more about how
    Python works internally, and how descriptors play such a core and critical role
    in the implementation of the language.
  prefs: []
  type: TYPE_NORMAL
- en: This study of how descriptors are used internally in Python should work as a
    reference to identify good uses of descriptors in our own code, with the goal
    of achieving idiomatic solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Despite all of the powerful options that descriptors represent to our advantage,
    we have to keep in mind when to properly make use of them without over-engineering.
    In this line, we have suggested that we should reserve the functionality of descriptors
    for truly generic cases, such as the design of internal development APIs, libraries,
    or frameworks. Another important consideration along these lines is that, in general,
    we should not place business logic in descriptors, but rather logic that implements
    technical functionality to be used by other components that do contain business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of advanced functionality, the next chapter also covers an interesting
    and in-depth topic: generators. On the surface, generators are rather simple (and
    most readers are probably already familiar with them), but what they have in common
    with descriptors is that they can also be complex, yield a more advanced and elegant
    design, and make Python a unique language to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of a few things you can reference for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s official documentation on descriptors: [https://docs.python.org/3/reference/datamodel.html#implementing-descriptors](https://docs.python.org/3/reference/datamodel.html#implementing-descriptors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WEAKREF 01: Python''s weakref module* ([https://docs.python.org/3/library/weakref.html](https://docs.python.org/3/library/weakref.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PYDESCR-02: Built-in decorators as descriptors* ([https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods](https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
