- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Getting More Out of Our Objects with Descriptors
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过描述符让我们的对象更有价值。
- en: This chapter introduces a new concept that is more advanced in Python development
    since it features descriptors. Moreover, descriptors are not something programmers
    of other languages are familiar with, so there are no easy analogies or parallelisms
    to make.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一个在Python开发中更高级的新概念，因为它具有描述符功能。此外，描述符不是其他语言的程序员熟悉的东西，因此没有简单的类比或平行关系可以做出。
- en: Descriptors are another distinctive feature of Python that take object-oriented
    programming to another level, and their potential allows users to build more powerful
    and reusable abstractions. Most of the time, the full potential of descriptors
    is observed in libraries or frameworks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是Python的另一个独特特性，它将面向对象编程提升到了另一个层次，它们的潜力允许用户构建更强大、更可重用的抽象。大多数情况下，描述符的完整潜力在库或框架中观察到。
- en: 'In this chapter, we will achieve the following goals that relate to descriptors:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现与描述符相关的一些目标：
- en: Understand what descriptors are, how they work, and how to implement them effectively
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解描述符是什么，它们是如何工作的，以及如何有效地实现它们。
- en: Analyze the two types of descriptors (data and non-data descriptors) in terms
    of their conceptual differences and implementation details
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从概念差异和实现细节分析两种类型的描述符（数据描述符和非数据描述符）。
- en: Reuse code effectively through descriptors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过描述符有效地重用代码。
- en: Analyze examples of good uses of descriptors, and how to take advantage of them
    for our API libraries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析描述符的良好使用示例，以及如何利用它们为我们自己的API库提供更多价值。
- en: A first look at descriptors
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符的第一眼观察。
- en: First, we will explore the main idea behind descriptors to understand their
    mechanics and internal workings. Once this is clear, it will be easier to assimilate
    how the different types of descriptors work, which we will explore in the next
    section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探索描述符背后的主要思想，以了解它们的机制和内部工作原理。一旦这一点清楚，就会更容易吸收不同类型描述符的工作方式，我们将在下一节中探讨。
- en: Once we have a general understanding of the idea behind descriptors, we will
    look at an example where their use gives us a cleaner and more Pythonic implementation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了描述符背后的概念，我们就会看看一个例子，其中描述符的使用给我们带来了更干净、更Pythonic的实现。
- en: The machinery behind descriptors
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符背后的机制。
- en: The way descriptors work is not all that complicated, but the problem with them
    is that there are a lot of caveats to take into consideration, so the implementation
    details are of the utmost importance here.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符的工作方式并不复杂，但问题在于它们有很多需要注意的注意事项，因此实现细节在这里至关重要。
- en: To implement descriptors, we need at least two classes. For this generic example,
    the `client` class will take advantage of the functionality we want to implement
    in the `descriptor` (this is generally just a domain model class, a regular abstraction
    we create for our solution), and the `descriptor` class will implement the logic
    of the descriptor itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现描述符，我们需要至少两个类。在这个通用示例中，`client`类将利用我们想在`descriptor`中实现的功能（这通常只是一个领域模型类，我们为解决方案创建的常规抽象），而`descriptor`类将实现描述符本身的逻辑。
- en: 'A descriptor is, therefore, just an object that is an instance of a class that
    implements the descriptor protocol. This means that the interface of this class
    must contain at least one of the following magic methods (part of the descriptor
    protocol as of Python 3.6+):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，描述符只是一个实现了描述符协议的类的实例。这意味着这个类的接口必须包含以下至少一种魔法方法（Python 3.6+描述符协议的一部分）：
- en: '`__get__`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__get__`'
- en: '`__set__`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__set__`'
- en: '`__delete__`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delete__`'
- en: '`__set_name__`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__set_name__`'
- en: 'For the purposes of this initial high-level introduction, the following naming
    conventions will be used:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个初始的高级介绍，将使用以下命名约定：
- en: '| Name | Meaning |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 含义 |'
- en: '| `ClientClass` | The domain-level abstraction that will take advantage of
    the functionality to be implemented by the descriptor. This class is said to be
    a client of the descriptor.This class contains a class attribute (named `descriptor`
    by this convention), which is an instance of `DescriptorClass`. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `ClientClass` | 将利用描述符要实现的功能的领域级抽象。这个类被称为描述符的客户。这个类包含一个类属性（按照惯例命名为`descriptor`），它是`DescriptorClass`的一个实例。|'
- en: '| `DescriptorClass` | The class that implements the `descriptor` itself. This
    class should implement some of the aforementioned magic methods that entail the
    descriptor protocol. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `DescriptorClass` | 实现描述符本身的类。此类应实现一些上述涉及描述符协议的魔法方法。|'
- en: '| `client` | An instance of `ClientClass`.`client = ClientClass()`. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `client` | `ClientClass`的实例。`client = ClientClass()`。|'
- en: '| `descriptor` | An instance of `DescriptorClass`.`descriptor = DescriptorClass()`.This
    object is a class attribute that is placed in `ClientClass`. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `descriptor` | `DescriptorClass`的实例。`descriptor = DescriptorClass()`。此对象是一个放置在`ClientClass`中的类属性。|'
- en: 'Table 6.1: Descriptor naming conventions used in this chapter'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1：本章中使用的描述符命名约定
- en: 'This relationship is illustrated in *Figure 6.1*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系在*图 6.1*中得到了说明：
- en: '![Picture 1](img/16567_06_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1](img/16567_06_01.png)'
- en: 'Figure 6.1: The relationship between ClientClass and DescriptorClass'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：ClientClass 和 DescriptorClass 之间的关系
- en: A very important observation to keep in mind is that for this protocol to work,
    the `descriptor` object has to be defined as a `class` attribute. Creating this
    object as an instance attribute will not work, so it must be in the body of the
    class, and not in the `__init__` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个非常重要的观察结果是，为了使此协议正常工作，`descriptor`对象必须被定义为`class`属性。将其作为实例属性创建将不起作用，因此它必须位于类的主体中，而不是在`__init__`方法中。
- en: Always place the `descriptor` object as a class attribute!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总是将`descriptor`对象作为类属性放置！
- en: On a slightly more critical note, readers can also note that it is possible
    to implement the descriptor protocol partially—not all methods must always be
    defined; instead, we can implement only those we need, as we will see shortly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个稍微更关键的观点上，读者还可以注意到，可以部分实现描述符协议——不是所有方法都必须始终定义；相反，我们可以只实现我们需要的那些，正如我们很快将看到的。
- en: So, now we have the structure in place—we know what elements are set and how
    they interact. We need a class for the `descriptor`, another class that will consume
    the logic of the `descriptor`, which, in turn, will have a `descriptor` object
    (an instance of `DescriptorClass`) as a class attribute, and instances of `ClientClass`
    that will follow the descriptor protocol when we call for the attribute named
    `descriptor`. But now what? How does all of this fit into place at runtime?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经建立了结构——我们知道哪些元素被设置以及它们如何交互。我们需要一个用于`descriptor`的类，另一个将消费`descriptor`逻辑的类，这个类反过来将有一个`descriptor`对象（`DescriptorClass`的实例）作为类属性，以及当调用名为`descriptor`的属性时将遵循描述符协议的`ClientClass`的实例。但现在是怎样的情况？所有这些如何在运行时结合起来？
- en: 'Normally, when we have a regular class and we access its attributes, we simply
    obtain the objects as we expect them, and even their properties, as in the following
    example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们有一个常规类并访问其属性时，我们简单地获得我们期望的对象，甚至它们的属性，如下面的例子所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But, in the case of descriptors, something different happens. When an object
    is defined as a `class` attribute (and this one is a `descriptor`), when a `client`
    requests this attribute, instead of getting the object itself (as we would expect
    from the previous example), we get the result of having called the `__get__` magic
    method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在描述符的情况下，发生了一些不同的事情。当一个对象被定义为`class`属性（并且这个是一个描述符），当`client`请求这个属性时，而不是得到对象本身（正如我们从前面的例子中期望的那样），我们得到调用`__get__`魔法方法的结果。
- en: 'Let''s start with some simple code that only logs information about the context,
    and returns the same `client` object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些简单的代码开始，这些代码只记录关于上下文的信息，并返回相同的`client`对象：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When running this code, and requesting the `descriptor` attribute of an instance
    of `ClientClass`, we will discover that we are, in fact, not getting an instance
    of `DescriptorClass`, but whatever its `__get__()` method returns instead:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码并请求`ClientClass`实例的`descriptor`属性时，我们将发现，实际上我们并没有得到`DescriptorClass`的实例，而是得到了其`__get__()`方法返回的内容：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the logging line, placed under the `__get__` method, was called instead
    of just returning the object we created. In this case, we made that method return
    the `client` itself, hence making a true comparison of the last statement. The
    parameters of this method are explained in more detail in the following subsections,
    so don't worry about them for now. The crux of this example is to understand that
    the lookup of attributes behaves differently when one of those attributes is a
    descriptor (in this case, because it has a `__get__` method).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到放置在`__get__`方法下的日志行被调用了，而不是仅仅返回我们创建的对象。在这种情况下，我们使该方法返回`client`本身，从而真正比较了最后一条语句。这个方法的参数将在以下子节中更详细地解释，所以现在不用担心它们。这个例子关键是要理解，当其中一个属性是描述符（在这种情况下，因为它有`__get__`方法）时，属性查找的行为会有所不同。
- en: Starting from this simple, yet demonstrative, example, we can start creating
    more complex abstractions and better decorators because the important note here
    is that we have a new (powerful) tool to work with. Notice how this changes the
    control flow of the program in a completely different way. With this tool, we
    can abstract all sorts of logic behind the `__get__` method, and make the `descriptor`
    transparently run all sorts of transformations without clients even noticing.
    This takes encapsulation to a new level.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单但具有说明性的例子开始，我们可以开始创建更复杂的抽象和更好的装饰器，因为这里的重要提示是我们有一个新的（强大的）工具可以用来工作。注意这种方式如何完全不同地改变程序的流程控制。有了这个工具，我们可以将所有各种逻辑抽象到`__get__`方法之后，并使`descriptor`透明地执行各种转换，而客户端甚至都没有察觉。这把封装提升到了一个新的水平。
- en: Exploring each method of the descriptor protocol
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索描述符协议的每个方法
- en: Up until now, we have seen quite a few examples of descriptors in action, and
    we got the idea of how they work. These examples gave us a first glimpse of the
    power of descriptors, but you might be wondering about some implementation details
    and idioms whose explanations we failed to address.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了许多描述符在实际应用中的例子，并了解了它们是如何工作的。这些例子让我们首次领略了描述符的强大之处，但你可能还在思考一些实现细节和惯用法，这些细节我们未能详细解释。
- en: Since descriptors are just objects, these methods take `self` as the first parameter.
    For all of them, this just means the `descriptor` object itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于描述符只是对象，这些方法将`self`作为第一个参数。对于所有这些方法，这仅仅意味着`descriptor`对象本身。
- en: In this section, we will explore each method of the descriptor protocol in full
    detail, explaining what each parameter signifies, and how they are intended to
    be used.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细探讨描述符协议的每个方法，解释每个参数的含义以及它们的使用意图。
- en: The get method
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取方法
- en: 'The signature of this magic method is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个魔法方法的签名如下：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first parameter, `instance`, refers to the object from which the `descriptor`
    is being called. In our first example, this would mean the `client` object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`instance`指的是调用`descriptor`的对象。在我们的第一个例子中，这意味着`client`对象。
- en: The `owner` parameter is a reference to the class of that object, which, following
    our example (from *Figure 6.1*), would be `ClientClass`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner`参数是指该对象的类，根据我们的例子（来自*图6.1*），这将是指`ClientClass`。'
- en: From the previous paragraph, we can conclude that the parameter named `instance`
    in the signature of `__get__` is the object over which the descriptor is taking
    action, and `owner` is the class of `instance`. The astute reader might be wondering
    why the signature is defined like this. After all, the class can be taken from
    `instance` directly (`owner = instance.__class__`). There is an edge case—when
    the `descriptor` is called from the class (`ClientClass`), and not from the instance
    (`client`), then the value of `instance` is `None`, but we might still want to
    do some processing in that case. That's why Python chooses to pass the class as
    a different parameter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一段中，我们可以得出结论，`__get__`方法签名中的参数`instance`是指`descriptor`正在对其采取行动的对象，而`owner`是`instance`的类。敏锐的读者可能会想知道为什么签名是这样定义的。毕竟，类可以直接从`instance`中获取（`owner
    = instance.__class__`）。存在一个边缘情况——当`descriptor`是从类（`ClientClass`）而不是从实例（`client`）调用时，`instance`的值是`None`，但我们在那种情况下可能仍然想做一些处理。这就是为什么Python选择将类作为不同的参数传递。
- en: 'With the following simple code, we can demonstrate the difference between a
    `descriptor` being called from the `class` or from an `instance`. In this case,
    the `__get__` method is doing two separate things for each case:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下简单的代码，我们可以展示从`class`或`instance`调用`descriptor`之间的区别。在这种情况下，`__get__`方法为每种情况执行两个不同的操作：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we call it from `ClientClass` directly, it will do one thing, which is
    composing a namespace with the names of the classes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 `ClientClass` 直接调用它时，它将执行一项操作，即组合类的名称空间：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And then if we call it from an object we have created, it will return the other
    message instead:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们从一个我们创建的对象中调用它，它将返回其他消息：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In general, unless we really need to do something with the `owner` parameter,
    the most common idiom is to just return the descriptor itself when `instance`
    is `None`. This is because when users are calling the descriptor from the class,
    they're probably expecting to get the descriptor itself, so it makes sense. But
    of course, it really depends on the example (later in the chapter, we'll see different
    usages with their explanations).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，除非我们真的需要使用 `owner` 参数，否则最常见的习惯用法是在 `instance` 为 `None` 时只返回描述符本身。这是因为当用户从类中调用描述符时，他们可能期望得到描述符本身，所以这样做是有意义的。但当然，这完全取决于示例（在本章后面的示例中，我们将看到不同的用法及其解释）。
- en: The set method
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置方法
- en: 'The signature of this method is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的签名如下：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This method is called when we try to assign something to a `descriptor`. It
    is activated with statements such as the following, in which a `descriptor` is
    an object that implements `__set__ ()`. The `instance` parameter, in this case,
    would be `client`, and the `value` would be the `"value"` string:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将某个值赋给 `descriptor` 时，会调用此方法。它通过以下语句激活，其中 `descriptor` 是实现了 `__set__ ()`
    的对象。在这种情况下，`instance` 参数将是 `client`，而 `value` 将是 `"value"` 字符串：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can note some similarity between this behavior and the `@property.setter`
    decorator from previous chapters, on which the argument of the setter function
    was the right-hand-side value of the statement (in this case the string `"value"`).
    We'll revisit this later in the chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到这种行为与之前章节中的 `@property.setter` 装饰器之间的一些相似性，其中设置函数的参数是语句右侧的值（在这种情况下是字符串
    `"value"`）。我们将在本章后面重新讨论这个问题。
- en: If `client.descriptor` doesn't implement `__set__()`, then `"value"` (any object
    on the right-hand side of the statement) will override the descriptor entirely.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `client.descriptor` 没有实现 `__set__()`，那么 `"value"`（语句右侧的任何对象）将完全覆盖描述符。
- en: Be careful when assigning a value to an attribute that is a `descriptor`. Make
    sure it implements the `__set__` method, and that we are not causing an undesired
    side effect.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在将值赋给属性时，请小心。确保它实现了 `__set__` 方法，并且我们没有引起不期望的副作用。
- en: By default, the most common use of this method is just to store data in an object.
    Nevertheless, we have seen how powerful descriptors are so far, and that we can
    take advantage of them, for example, if we were to create generic validation objects
    that can be applied multiple times (again, this is something that if we don't
    abstract, we might end up repeating multiple times in setter methods of properties).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此方法最常见的用途只是将数据存储在对象中。尽管如此，我们迄今为止已经看到了描述符是多么强大，我们可以利用它们，例如，如果我们创建通用的验证对象，这些对象可以多次应用（再次强调，如果我们不进行抽象，我们可能会在属性的设置方法中多次重复）。
- en: 'The following listing illustrates how we can take advantage of this method
    in order to create generic `validation` objects for attributes, which can be created
    dynamically with functions to validate on the values before assigning them to
    the object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了我们如何利用此方法来创建用于属性的通用 `validation` 对象，这些对象可以通过验证函数动态创建，并在将它们赋给对象之前进行验证：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can see this object in action in the following listing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下列表中看到此对象的作用：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The idea is that something that we would normally place in a property can be
    abstracted away into a `descriptor`, and be reused multiple times. In this case,
    the `__set__()` method would be doing what the `@property.setter` would have been
    doing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，我们通常放在属性中的内容可以被抽象成 `descriptor`，并且可以多次重用。在这种情况下，`__set__()` 方法将执行 `@property.setter`
    会执行的操作。
- en: This is a more generic mechanism than using properties, because, as we'll see
    later, properties are a particular case of descriptors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这比使用属性更通用，因为，正如我们稍后将看到的，属性是描述符的一个特例。
- en: The delete method
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除方法
- en: 'The signature for the `delete` method is simpler, and it looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 方法的签名更简单，如下所示：'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This method is called upon with the following statement, in which `self` would
    be the `descriptor` attribute, and `instance` would be the `client` object in
    this example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是通过以下语句调用的，其中`self`将是`descriptor`属性，而`instance`将是本例中的`client`对象：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the following example, we use this method to create a `descriptor` with
    the goal of preventing you from removing attributes from an object without the
    required administrative privileges. Notice how, in this case, the `descriptor`
    has logic that is used to predicate with the values of the object that is using
    it, instead of different related objects:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用这个方法创建一个`descriptor`，目的是防止您在没有必要的行政权限的情况下从对象中删除属性。注意，在这种情况下，`descriptor`具有用于与使用它的对象的值进行预测的逻辑，而不是与不同相关对象：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Before seeing examples of how this object works, it's important to remark on
    some of the criteria of this descriptor. Notice the `User` class requires the
    `username` and `email` as mandatory parameters. According to its `__init__` method,
    it cannot be a user if it doesn't have an `email` attribute. If we were to delete
    that attribute and extract it from the object entirely, we would be creating an
    inconsistent object, with some invalid intermediate state that does not correspond
    to the interface defined by the class `User`. Details like this one are really
    important, in order to avoid issues. Some other object is expecting to work with
    this `User`, and it also expects that it has an `email` attribute.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到这个对象的工作示例之前，重要的是要强调这个`descriptor`的一些标准。注意`User`类需要`username`和`email`作为强制参数。根据其`__init__`方法，如果没有`email`属性，它就不能成为用户。如果我们删除该属性并从对象中完全提取它，我们将创建一个不一致的对象，它具有与`User`类定义的接口不对应的某些无效中间状态。这样的细节非常重要，以避免问题。其他对象期望与这个`User`一起工作，并且它也期望它有一个`email`属性。
- en: For this reason, it was decided that the "deletion" of an email will just simply
    set it to `None`, and that is the part of the code listing that is in bold. For
    the same reason, we must forbid someone from trying to set a `None` value to it,
    because that would bypass the mechanism we placed in the `__delete__` method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定将“删除”电子邮件的操作简单地设置为`None`，这正是代码列表中加粗的部分。同样地，我们必须禁止有人尝试将`None`值设置给它，因为这会绕过我们在`__delete__`方法中设置的机制。
- en: 'Here, we can see it in action, assuming a case where only users with "`admin`"
    privileges can remove their email address:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到它的实际应用，假设只有具有"`admin`"权限的用户可以删除他们的电子邮件地址：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, in this simple `descriptor`, we see that we can delete the email from
    users that contain the "`admin`" permission only. As for the rest, when we try
    to call `del` on that attribute, we will get a `ValueError` exception.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的`descriptor`中，我们可以看到我们可以从只有具有"`admin`"权限的用户那里删除电子邮件。至于其他情况，当我们尝试在该属性上调用`del`时，我们将得到一个`ValueError`异常。
- en: In general, this method of the `descriptor` is not as commonly used as the two
    previous ones, but it is shown here for completeness.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个`descriptor`的方法不像前两个那样常用，但在这里展示它是为了完整性。
- en: The set name method
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合名称方法
- en: 'This is a relatively new method that was added in Python 3.6, and has this
    structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较新的方法，它在Python 3.6中被添加，具有以下结构：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we create the `descriptor` object in the class that is going to use it,
    we generally need the `descriptor` to know the name of the attribute it is going
    to be handling.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在将要使用它的类中创建`descriptor`对象时，我们通常需要`descriptor`知道它将要处理的属性名称。
- en: This attribute name is the one we use to read from and write to `__dict__` in
    the `__get__` and `__set__` methods, respectively.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性名称是我们用于在`__get__`和`__set__`方法中从`__dict__`中读取和写入的。
- en: Before Python 3.6, the `descriptor` couldn't take this name automatically, so
    the most general approach was to just pass it explicitly when initializing the
    object. This works fine, but it has an issue in that it requires that we duplicate
    the name every time we want to use the `descriptor` for a new attribute.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.6之前，`descriptor`不能自动获取这个名称，所以最通用的方法是在初始化对象时明确传递它。这没问题，但它有一个问题，即每次我们想要为新属性使用`descriptor`时，都需要重复名称。
- en: 'This is what a typical `descriptor` would look like if we didn''t have this
    method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有这个方法，一个典型的`descriptor`将看起来像这样：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can see how the `descriptor` uses this value:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`descriptor`是如何使用这个值的：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, if we wanted to avoid writing the name of the attribute twice (once for
    the variable assigned inside the class, and once again as the name of the first
    parameter of the `descriptor`), we'd have to resort to a few tricks, like using
    a class decorator, or (even worse) using a meta-class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想避免将属性名称写两次（一次是在类内部分配的变量，一次是作为`descriptor`的第一个参数的名称），我们就必须求助于一些技巧，比如使用类装饰器，或者（更糟糕的是）使用元类。
- en: In Python 3.6, the new method `__set_name__` was added, and it receives the
    class where that descriptor is being created, and the name that is being given
    to that `descriptor`. The most common idiom is to use this method for the `descriptor`
    so that it can store the required name in this method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.6中，添加了新的方法`__set_name__`，它接收创建该描述符的类以及分配给该`descriptor`的名称。最常用的习惯用法是使用这个方法来存储所需的名称。
- en: For compatibility, it is generally a good idea to keep a default value in the
    `__init__` method but still take advantage of `__set_name__`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了兼容性，通常在`__init__`方法中保留一个默认值是一个好主意，但仍然要利用`__set_name__`。
- en: 'With this method, we can rewrite the previous `descriptor` as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以将之前的`descriptor`重写如下：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`__set_name__` is useful to get the name of the attribute the descriptor was
    assigned, but if we wanted to override the value, the `__init__` method would
    still take precedence, so we retain flexibility.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`__set_name__`对于获取`descriptor`被分配的属性名称很有用，但如果我们要覆盖值，`__init__`方法仍然会优先考虑，因此我们保留了灵活性。'
- en: Even though we're free to name our descriptors however we like, we generally
    use the name of the descriptor (the attribute name) as a key of the `__dict__`
    of the client object, which means it'll be interpreted as an attribute. For this
    reason, try to name the descriptors you use as valid Python identifiers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以自由地命名我们的描述符，但我们通常使用描述符的名称（属性名称）作为客户端对象`__dict__`的键，这意味着它将被解释为属性。因此，请尽量使用有效的Python标识符来命名你使用的描述符。
- en: If you're setting a bespoke name for your descriptor, use a valid Python identifier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为你的`descriptor`设置了一个特定的名称，请使用有效的Python标识符。
- en: Types of descriptors
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符类型
- en: Based on the methods we have just explored, we can make an important distinction
    among descriptors in terms of how they work. Understanding this distinction plays
    an important role in working effectively with descriptors and will also help to
    avoid caveats or common errors at runtime.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们刚刚探索的方法，我们可以在`descriptor`的工作方式上做出一个重要的区分。理解这个区分对于有效地使用`descriptor`以及避免运行时常见的陷阱或错误都起着重要作用。
- en: If a descriptor implements the `__set__` or `__delete__` methods, it is called
    a **data descriptor**. Otherwise, a descriptor that solely implements `__get__`
    is a **non-data descriptor**. Notice that `__set_name__` does not affect this
    classification at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个描述符实现了`__set__`或`__delete__`方法，它被称为**数据描述符**。否则，仅实现`__get__`的描述符是**非数据描述符**。请注意，`__set_name__`根本不影响这种分类。
- en: When trying to resolve an attribute of an object, a data descriptor will always
    take precedence over the dictionary of the object, whereas a non-data descriptor
    will not. That means that in a non-data descriptor if the object has a key on
    its dictionary with the same name as the descriptor, then that will always be
    called, and the descriptor itself will never run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试解析对象的属性时，数据描述符将始终优先于对象的字典，而非数据描述符则不会。这意味着在非数据描述符中，如果对象在其字典中有一个与描述符相同的键，那么它将始终被调用，而描述符本身将永远不会运行。
- en: Conversely, in a data descriptor, even if there is a key in the dictionary with
    the same name as the descriptor, this one will never be used since the descriptor
    itself will always end up being called.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在数据描述符中，即使字典中有一个与描述符相同的键，这个键也永远不会被使用，因为描述符本身总是会最终被调用。
- en: The following two sections explain this in more detail, with examples, to get
    a deeper idea of what to expect from each type of descriptor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个部分将更详细地解释这一点，包括示例，以获得对每种类型`descriptor`的期望有更深入的了解。
- en: Non-data descriptors
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非数据描述符
- en: 'We will start with a `descriptor` that only implements the `__get__` method,
    and see how it is used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从只实现`__get__`方法的`descriptor`开始，看看它是如何被使用的：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As usual, if we ask for the `descriptor`, we get the result of its `__get__`
    method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，如果我们请求`descriptor`，我们得到的是其`__get__`方法的结果：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But if we change the `descriptor` attribute to something else, we lose access
    to this value, and get what was assigned to it instead:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们更改 `descriptor` 属性，我们将失去对这个值的访问，并得到分配给它的值：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we delete the `descriptor` and ask for it again, let''s see what we
    get:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们删除 `descriptor` 并再次请求它，让我们看看我们会得到什么：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s rewind what just happened. When we first created the `client` object,
    the `descriptor` attribute lay in the class, not the instance, so if we ask for
    the dictionary of the `client` object, it will be empty:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下刚才发生的事情。当我们最初创建 `client` 对象时，`descriptor` 属性位于类中，而不是实例中，所以如果我们请求 `client`
    对象的字典，它将是空的：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And then, when we request the `.descriptor` attribute, it doesn't find any key
    in `client.__dict__` named `"descriptor"`, so it goes to the class, where it will
    find it ... but only as a descriptor, hence why it returns the result of the `__get__`
    method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们请求 `.descriptor` 属性时，它没有在 `client.__dict__` 中找到任何名为 `"descriptor"` 的键，所以它转到类中，在那里它会找到它……但只作为描述符，这就是为什么它返回
    `__get__` 方法的结果。
- en: 'But then, we change the value of the `.descriptor` attribute to something else,
    and what this does is sets the value `99` into the dictionary of the `instance`,
    meaning that this time it won''t be empty:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `.descriptor` 属性的值更改为其他值，这样做的作用是将值 `99` 设置到 `instance` 的字典中，这意味着这次它不会为空：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, when we ask for the `.descriptor` attribute here, it will look for it in
    the object (and this time it will find it because there is a key named `descriptor`
    in the `__dict__` attribute of the object, as the `vars` result shows us), and
    return it without having to look for it in the class. For this reason, the `descriptor`
    protocol is never invoked, and the next time we ask for this attribute, it will
    instead return the value we have overridden it with (`99`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们在这里请求 `.descriptor` 属性时，它将在对象中查找它（这次它会找到，因为对象的 `__dict__` 属性中有一个名为 `descriptor`
    的键，正如 `vars` 的结果所显示的），并且不需要在类中查找就返回它。因此，描述符协议永远不会被调用，下次我们请求这个属性时，它将返回我们覆盖的值（`99`）。
- en: 'Afterward, we delete this attribute by calling `del`, and what this does is
    to remove the key named `"descriptor"` from the dictionary of the object, leaving
    us back in the first scenario, where it''s going to default to the class where
    the descriptor protocol will be triggered:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过调用 `del` 来删除这个属性，这样做的作用是从对象的字典中移除名为 `"descriptor"` 的键，使我们回到第一个场景，其中它将默认到触发描述符协议的类：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This means that if we set the attribute of the `descriptor` to something else,
    we might accidentally break it. Why? Because the `descriptor` doesn't handle the
    delete action (some of them don't need to).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们将 `descriptor` 的属性设置为其他值，我们可能会意外地破坏它。为什么？因为 `descriptor` 不处理删除操作（其中一些不需要）。
- en: This is called a non-data descriptor because it doesn't implement the `__set__`
    magic method, as we will see in the next example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为非数据描述符，因为它没有实现 `__set__` 魔法方法，正如我们将在下一个示例中看到的那样。
- en: Data descriptors
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据描述符
- en: 'Now, let''s look at the difference in using a data descriptor. For this, we
    are going to create another simple `descriptor` that does implement the `__set__`
    method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用数据描述符的差异。为此，我们将创建另一个简单的 `descriptor`，它实现了 `__set__` 方法：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s see what the value of the `descriptor` returns:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `descriptor` 的值返回什么：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s try to change this value to something else, and see what it returns
    instead:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将这个值更改为其他值，看看它返回什么：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The value returned by the `descriptor` didn''t change. But when we assign a
    different value to it, it must be set to the dictionary of the object (as it was
    previously):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`descriptor` 返回的值没有改变。但是当我们给它赋一个不同的值时，它必须设置为对象的字典（就像之前一样）：'
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, the `__set__()` method was called, and indeed it did set the value to the
    dictionary of the object, only this time, when we request this attribute, instead
    of using the `__dict__` attribute of the dictionary, the `descriptor` takes precedence
    (because it's an overriding descriptor).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，调用了 `__set__()` 方法，并且确实将值设置到了对象的字典中，只是这次，当我们请求这个属性时，不是使用字典的 `__dict__` 属性，而是
    `descriptor` 优先（因为它是一个覆盖描述符）。
- en: 'One more thing—deleting the attribute will not work anymore:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事——删除属性将不再起作用：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The reason is as follows—given that now the `descriptor` always takes precedence,
    calling `del` on an object doesn't try to delete the attribute from its dictionary
    (`__dict__`), but instead it tries to call the `__delete__()` method of the `descriptor`
    (which is not implemented in this example, hence the attribute error).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 原因如下——鉴于现在`descriptor`总是优先，对对象调用`del`时不会尝试从其字典（`__dict__`）中删除属性，而是尝试调用`descriptor`的`__delete__()`方法（在这个例子中没有实现，因此引发了属性错误）。
- en: This is the difference between data and non-data descriptors. If the descriptor
    implements `__set__()`, then it will always take precedence, no matter what attributes
    are present in the dictionary of the object. If this method is not implemented,
    then the dictionary will be looked up first, and then the descriptor will run.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是数据和非数据描述符之间的区别。如果描述符实现了`__set__()`，那么它将始终优先，无论对象字典中存在哪些属性。如果没有实现此方法，则首先查找字典，然后运行描述符。
- en: 'An interesting observation you might have noticed is this line on the `set`
    method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到的有趣观察是`set`方法中的这一行：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There are a lot of things to question about that line, but let's break it down
    into parts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情值得质疑，但让我们将其分解成几个部分。
- en: First, why is it altering just the name of a `"descriptor"` attribute? This
    is just a simplification for this example, but, as it happens, the descriptor
    doesn't know at this point the name of the attribute it was assigned to, so we
    just used the one from the example, knowing that it was going to be `"descriptor"`.
    This is a simplification to make the example use less code, but it could be easily
    resolved by using the `__set_name__` method we studied in the previous section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为什么它只修改了`"descriptor"`属性的名称？这只是这个例子中的一个简化，但事实上，描述符此时并不知道它被分配的属性名称，所以我们只是使用了例子中的名称，知道它将是`"descriptor"`。这是一个简化，使得示例使用更少的代码，但可以通过使用我们在上一节中学习的`__set_name__`方法轻松解决。
- en: In a real example, you would do one of two things—either receive the name as
    a parameter and store it internally in the `init` method, so that this one will
    just use the internal attribute, or, even better, use the `__set_name__` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际例子中，你会做两件事之一——要么将名称作为参数接收并在`init`方法中内部存储，这样这个方法就会只使用内部属性，或者，更好的是，使用`__set_name__`方法。
- en: Why is it accessing the `__dict__` attribute of the instance directly? Another
    good question, which also has at least two explanations. First, you might be thinking
    why not just do the following?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它会直接访问实例的`__dict__`属性？另一个很好的问题是，这至少有两个解释。首先，你可能想知道为什么不直接这样做？
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Remember that this method `(__set__`) is called when we try to assign something
    to the attribute that is a `descriptor`. So, using `setattr()` will call this
    `descriptor` again, which, in turn, will call it again, and so on and so forth.
    This will end up in an infinite recursion.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们尝试将某个值赋给属性且该属性是`descriptor`时，会调用这个方法`(__set__)`。所以，使用`setattr()`会再次调用这个`descriptor`，然后它又会再次调用，如此循环。这最终会导致无限递归。
- en: Do not use `setattr()` or the assignment expression directly on the descriptor
    inside the `__set__` method because that will trigger an infinite recursion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在`__set__`方法中直接使用`setattr()`或赋值表达式在`descriptor`内部，因为这会触发无限递归。
- en: Why, then, is the descriptor not able to book-keep the values of the properties
    for all of its objects?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么描述符不能为所有对象记录属性的值呢？
- en: The `client` class already has a reference to the descriptor. If we add a reference
    from the descriptor back to the `client` object, we are creating circular dependencies,
    and these objects will never be garbage-collected. Since they are pointing at
    each other, their reference counts will never drop below the threshold for removal,
    and that will cause memory leaks in our program.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`client`类已经有一个对`descriptor`的引用。如果我们从`descriptor`反向引用到`client`对象，我们就会创建循环依赖，这些对象将永远不会被垃圾回收。由于它们相互指向，它们的引用计数将永远不会低于移除的阈值，这将在我们的程序中造成内存泄漏。'
- en: Watch out for potential memory leaks when working with descriptors (or objects
    in general). Make sure you don't create circular dependencies.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理描述符（或一般对象）时，要小心潜在的内存泄漏。确保你没有创建循环依赖。
- en: A possible alternative here is to use weak references, with the `weakref` module,
    and create a weak reference key dictionary if we want to do that. This implementation
    is explained later on in this chapter, but for the implementations within this
    book, we prefer to use this idiom (and not `weakref`), since it is fairly common
    and accepted when writing descriptors.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个可能的替代方案是使用弱引用，通过`weakref`模块，如果我们想那样做，可以创建一个弱引用键字典。这种实现将在本章稍后解释，但就本书中的实现而言，我们更喜欢使用这种惯用（而不是`weakref`）方法，因为它在编写描述符时相当常见且被接受。
- en: 'As of now, we have studied the different kinds of descriptors, what they are,
    and how they work, and we even got a first idea of how we can use them to our
    advantage. The next section emphasizes precisely that last point: we''ll see descriptors
    in action. From now on, we''ll take a more practical approach, and see how we
    can use descriptors to achieve better code. After that, we''ll even explore examples
    of good descriptors.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经研究了不同类型的描述符，它们是什么，以及它们是如何工作的，我们甚至对如何利用它们有了初步的了解。下一节将重点介绍最后一点：我们将看到描述符的实际应用。从现在开始，我们将采取更实际的方法，看看我们如何使用描述符来编写更好的代码。之后，我们甚至将探索优秀描述符的示例。
- en: Descriptors in action
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符的实际应用
- en: Now that we have seen what descriptors are, how they work, and what the main
    ideas behind them are, we can see them in action. In this section, we will be
    exploring some situations that can be elegantly addressed through descriptors.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了描述符是什么，它们是如何工作的，以及它们背后的主要思想，我们可以看到它们在实际中的应用。在本节中，我们将探讨一些可以通过描述符优雅解决的问题。
- en: Here, we will look at some examples of working with descriptors, and we will
    also cover implementation considerations for them (different ways of creating
    them, with their pros and cons), and finally, we will discuss what the most suitable
    scenarios for descriptors are.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将查看一些使用描述符的示例，我们还将涵盖它们的实现考虑因素（创建它们的不同方式，以及它们的优缺点），最后，我们将讨论描述符最合适的场景是什么。
- en: An application of descriptors
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符的应用
- en: We will start with a simple example that works but will lead to some code duplication.
    Later on, we will devise a way of abstracting the repeated logic into a descriptor,
    which will address the duplication problem, and we will observe that the code
    on our client classes will reduce drastically.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个非常简单的例子开始，这个例子可以工作，但会导致一些代码重复。稍后，我们将设计一种方法将重复的逻辑抽象成一个描述符，这将解决重复问题，我们还将观察到我们的客户端类上的代码将大大减少。
- en: A first attempt without using descriptors
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不使用描述符的第一次尝试
- en: The problem we want to solve now is that we have a regular class with some attributes,
    but we wish to track all of the different values a particular attribute has over
    time, for example, in a `list`. The first solution that comes to mind is to use
    a property, and every time a value is changed for that attribute in the setter
    method of the property, we add it to an internal list that will keep this trace
    as we want it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要解决的问题是我们有一个具有一些属性的常规类，但我们希望跟踪特定属性随时间变化的所有不同值，例如，在一个`列表`中。首先想到的解决方案是使用一个属性，并且每次在属性的setter方法中更改该属性的值时，我们都会将其添加到一个内部列表中，这样我们就可以按照我们想要的方式保留这个跟踪。
- en: 'Imagine that our class represents a traveler in our application that has a
    current city, and we want to keep track of all the cities that user has visited
    throughout the running of the program. The following code is a possible implementation
    that addresses these requirements:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的类代表应用程序中的一个旅行者，该旅行者有一个当前城市，并且我们希望在程序运行期间跟踪用户访问过的所有城市。以下是一个可能的实现，它解决了这些要求：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can easily check that this code works according to our requirements:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地检查这段代码是否符合我们的要求：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So far, this is all we need and nothing else has to be implemented. For the
    purposes of this problem, the property would be more than enough. What happens
    if we need the exact same logic in multiple places of the application? This would
    mean that this is actually an instance of a more generic problem—tracing all the
    values of an attribute in another one. What would happen if we want to do the
    same with other attributes, such as keeping track of all the tickets Alice bought,
    or all the countries she has been to? We would have to repeat the logic in all
    of these places.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这就是我们所需要的，不需要实现其他任何内容。对于这个问题的目的，属性将绰绰有余。如果我们需要在应用程序的多个地方实现完全相同的逻辑会发生什么？这意味着这实际上是一个更通用问题的实例——追踪另一个属性的所有值。如果我们想对其他属性做同样的事情，比如跟踪爱丽丝买过的所有票，或者她访问过的所有国家，会发生什么？我们就需要在所有这些地方重复逻辑。
- en: Moreover, what would happen if we need this same behavior in different classes?
    We would have to repeat the code or come up with a generic solution (maybe a decorator,
    a property builder, or a descriptor). Since property builders are a particular
    (and more convoluted) case of descriptors, they are beyond the scope of this book,
    and instead, descriptors are suggested as a cleaner way of proceeding.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们需要在不同的类中实现相同的行为会发生什么？我们可能需要重复代码或者想出一个通用解决方案（可能是一个装饰器、属性构建器或描述符）。由于属性构建器是描述符的一个特定（且更复杂）的情况，它们超出了本书的范围，因此建议使用描述符作为更干净的处理方式。
- en: 'As another solution to this problem, we can use the `__setattr__` magic method
    that was introduced in *Chapter 2*, *Pythonic Code*. We have already seen solutions
    of this kind in the previous chapter when we discussed class decorators as an
    alternative to using `__getattr__`. The considerations of these solutions are
    analogous: we would need to create a new base class that implements this generic
    method, then define some class attributes to signal the attributes that need to
    be traced, and finally implement this logic in the method. This class would be
    a mixin that could be added to the hierarchy of the classes, but that also has
    the same problems that were previously discussed (a stronger coupling and potential
    problems with a hierarchy that is not conceptually right).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决这个问题的一个另一种方案，我们可以使用在*第二章*，*Pythonic Code*中引入的`__setattr__`魔法方法。在上一章讨论将`__getattr__`作为替代方案时，我们已经看到了这类解决方案。这些解决方案的考虑因素是相似的：我们需要创建一个新的基类来实现这个通用方法，然后定义一些类属性来指示需要追踪的属性，最后在方法中实现这个逻辑。这个类将是一个混入类，可以被添加到类的层次结构中，但它也具有之前讨论过的问题（更强的耦合和概念上不正确的层次结构问题）。
- en: As we saw in the previous chapter, we analyzed the differences, and we saw how
    a class decorator was better than using this magic method in a base class; here,
    I also assume descriptors will provide a cleaner solution, so the magic method
    will be avoided, and we'll explore how to solve this problem with descriptors
    in the next section. That said, the reader is more than welcome to implement the
    solution that uses `__setattr__` to compare and a similar analysis.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所看到的，我们分析了差异，并看到了类装饰器在基类中使用这个魔法方法时的优越性；在这里，我也假设描述符将提供一个更干净的解决方案，因此我们将避免使用魔法方法，并在下一节中探讨如何使用描述符解决这个问题。话虽如此，读者完全欢迎实现使用`__setattr__`的解决方案，并进行类似的比较分析。
- en: The idiomatic implementation
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习惯性实现
- en: We will now look at how to address the questions of the previous section by
    using a descriptor that is generic enough to be applied in any class. Again, this
    example is not really needed because the requirements do not specify such generic
    behavior (we haven't even followed the rule of three instances of the similar
    pattern previously creating the abstraction), but it is shown with the goal of
    portraying descriptors in action.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过使用足够通用的描述符来解决上一节提出的问题，这个描述符可以应用于任何类。再次强调，这个例子实际上并不是必需的，因为要求并没有指定这种通用行为（我们甚至没有遵循创建抽象的类似模式的三实例规则），但它被展示出来是为了展示描述符的实际应用。
- en: Do not implement a descriptor unless there is actual evidence of the repetition
    we are trying to solve, and the complexity is proven to have paid off.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有实际证据表明我们正在尝试解决的问题存在重复，并且复杂性已被证明是值得的，否则不要实现描述符。
- en: Now, we will create a generic descriptor that, given a name for the attribute
    to hold the traces of another one, will store the different values of the attribute
    in a list.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个通用的描述符，给定一个用于存储另一个属性跟踪的名称，它将在列表中存储该属性的不同值。
- en: As we mentioned previously, the code is more than what we need for the problem,
    but its intention is just to show how a descriptor would help us in this case.
    Given the generic nature of descriptors, the reader will notice that the logic
    on it (the name of their method and attributes) does not relate to the domain
    problem at hand (a Traveler object). This is because the idea of the descriptor
    is to be able to use it in any type of class, probably in different projects,
    with the same outcomes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，代码超出了我们解决问题的需要，但其意图只是展示描述符如何帮助我们在这个案例中。鉴于描述符的通用性，读者会注意到其上的逻辑（方法名称和属性）与当前的实际问题（旅行者对象）无关。这是因为描述符的理念是能够在任何类型的类中使用，可能在不同的项目中，以相同的结果。
- en: 'In order to address this gap, some parts of the code are annotated, and the
    respective explanation for each section (what it does, and how it relates to the
    original problem) is described in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，代码的一些部分被注释，每个部分（它做什么，以及它与原始问题的关系）的相应解释将在以下代码中描述：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The idea behind the descriptor is that it will create a new attribute that is
    in charge of keeping track of the changes that have been happening to some other
    attribute. For the purposes of this explanation, we can call them tracer and traced
    attributes, respectively.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符背后的理念是它将创建一个新的属性，负责跟踪某些其他属性所发生的变化。为了解释的目的，我们可以分别称它们为跟踪属性和被跟踪属性。
- en: 'Some annotations and comments on the code are as follows (the numbers in the
    list correspond to the number annotations in the previous listing):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码的一些注释和说明（列表中的数字对应于先前列表中的注释编号）：
- en: The name of the attribute is one of the variables assigned to the `descriptor`,
    in this case, `current_city` (the traced attribute). We pass to the `descriptor`
    the name of the variable in which it will store the trace for the variable of
    the `descriptor`. In this example, we are telling our object to keep track of
    all the values that `current_city` has had in the attribute named `cities_visited`
    (the tracer).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性的名称是分配给`descriptor`的变量之一，在这种情况下，`current_city`（被跟踪的属性）。我们向`descriptor`传递它将存储跟踪变量的变量的名称。在这个例子中，我们告诉我们的对象跟踪所有`current_city`在名为`cities_visited`（跟踪器）的属性中曾经有的值。
- en: The first time we call the descriptor, in `__init__`, the attribute for tracing
    values will not exist, in which case we initialize it to an empty list to later
    append values to it.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次调用描述符时，在`__init__`中，用于跟踪值的属性将不存在，在这种情况下，我们将其初始化为空列表，以便稍后追加值。
- en: In the `__ init__` method, the name of the attribute `current_city` will not
    exist either, so we want to keep track of this change as well. This is the equivalent
    of initializing the list with the first value in the previous example.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__`方法中，属性`current_city`的名称也不存在，因此我们希望跟踪这种变化。这相当于在先前的例子中用第一个值初始化列表。
- en: Only track changes when the new value is different from the one that is currently
    set.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当新值与当前设置的值不同时，才跟踪变化。
- en: In the `__init__` method, the `descriptor` already exists, and this assignment
    instruction triggers the actions from *step 2* (create the empty list to start
    tracking values for it), and *step 3* (append the value to this `list`, and set
    it to the key in the object for retrieval later).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__`方法中，`descriptor`已经存在，这个赋值指令触发了从*步骤2*（创建空列表以开始跟踪其值）到*步骤3*（将值追加到这个列表中，并将其设置为对象的键以供以后检索）的动作。
- en: The `setdefault` method in a dictionary is used to avoid a `KeyError`. In this
    case, an empty list will be returned for those attributes that aren't still available
    (see [https://docs.python.org/3/library/stdtypes.html#dict.setdefault](https://docs.python.org/3/library/stdtypes.html#dict.setdefault)
    for reference).
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字典中的`setdefault`方法用于避免`KeyError`。在这种情况下，对于尚未可用的属性，将返回空列表（参见[https://docs.python.org/3/library/stdtypes.html#dict.setdefault](https://docs.python.org/3/library/stdtypes.html#dict.setdefault)以获取参考）。
- en: It is true that the code in the `descriptor` is rather complex. On the other
    hand, the code in the `client` class is considerably simpler. Of course, this
    balance only pays off if we are going to use this `descriptor` multiple times,
    which is a concern we have already covered.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，`descriptor` 中的代码相当复杂。另一方面，`client` 类中的代码相对简单。当然，这种平衡只有在我们将多次使用这个 `descriptor`
    时才会得到回报，这是我们之前已经讨论过的问题。
- en: What might not be so clear at this point is that the descriptor is indeed completely
    independent from the `client` class. Nothing in it suggests anything about the
    business logic. That makes it perfectly suitable to apply it in any other class;
    even if it does something completely different, the descriptor will have the same
    effect.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上可能还不那么清楚的是，描述符确实完全独立于 `client` 类。其中没有任何内容暗示任何关于业务逻辑的信息。这使得它在任何其他类中应用都是完美的；即使它做的是完全不同的事情，描述符也会产生相同的效果。
- en: That is the true Pythonic nature of descriptors. They are more appropriate for
    defining libraries, frameworks, and internal APIs, but less so for business logic.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是描述符的真正Python特性。它们更适合定义库、框架和内部API，但不太适合业务逻辑。
- en: Now that we have seen some first descriptors implemented, we can take a look
    at different ways of writing descriptors. So far, the examples have used a single
    form, but as anticipated earlier in the chapter, there are different ways in which
    we can implement descriptors, as we shall see.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些描述符的实现，我们可以看看不同的编写描述符的方法。到目前为止，示例使用了单一的形式，但正如我们在本章前面所预料的，我们可以以不同的方式实现描述符，正如我们将要看到的。
- en: Different forms of implementing descriptors
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符的不同实现形式
- en: We have to first understand a common issue that's specific to the nature of
    descriptors before thinking of ways of implementing them. First, we will discuss
    the problem of a global shared state, and afterward, we will move on and look
    at different ways descriptors can be implemented while taking this into consideration.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑实现它们的方法之前，我们必须首先理解一个与描述符本质相关的问题。首先，我们将讨论全局共享状态的问题，然后我们将继续探讨在考虑这一点的情况下，描述符可以以不同的方式实现。
- en: The issue of shared state
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享状态的问题
- en: As we have already mentioned, descriptors need to be set as class attributes
    in order to work. This should not be a problem most of the time, but it does come
    with some warnings that need to be taken into consideration.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，描述符需要被设置为类属性才能工作。这通常不会成为问题，但它确实带来了一些需要考虑的警告。
- en: The problem with class attributes is that they are shared across all instances
    of that class. Descriptors are not an exception here, so if we try to keep data
    in a `descriptor` object, keep in mind that all of them will have access to the
    same value.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性的问题在于它们在类的所有实例之间是共享的。描述符在这里也不例外，所以如果我们试图在 `descriptor` 对象中保持数据，请记住，所有这些都将能够访问相同的值。
- en: 'Let''s see what happens when we incorrectly define a `descriptor` that keeps
    the data itself, instead of storing it in each object:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们错误地定义一个将数据本身保留下来而不是在每个对象中存储的 `descriptor` 时会发生什么：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example, the `descriptor` object stores the data itself. This carries
    with it the inconvenience that when we modify the value for an `instance`, all
    other instances of the same classes are also modified with this value as well.
    The following code listing puts that theory into action:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`descriptor` 对象存储了数据本身。这带来了不便，因为当我们修改一个 `instance` 的值时，同一类的所有其他实例也会使用这个值进行修改。下面的代码示例将这个理论付诸实践：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how we change one object, and suddenly all of them are from the same
    class, and we can see that this value is reflected. This is because `ClientClass.descriptor`
    is unique; it's the same object for all of them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何改变一个对象，突然之间所有对象都来自同一个类，并且我们可以看到这个值是如何反映出来的。这是因为 `ClientClass.descriptor`
    是唯一的；对于所有这些对象来说，它都是同一个对象。
- en: In some cases, this might be what we actually want (for instance, if we were
    to create a sort of Borg pattern implementation, on which we want to share state
    across all objects from a class), but in general, that is not the case, and we
    need to differentiate between objects. Such a pattern is discussed in more detail
    in *Chapter 9*, *Common Design Patterns*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这可能是我们真正想要的（例如，如果我们想要创建一种类似博格模式（Borg pattern）的实现，我们希望在类的所有对象之间共享状态），但通常情况下并非如此，我们需要区分对象。这种模式在
    *第9章*，*常见设计模式* 中有更详细的讨论。
- en: To achieve this, the descriptor needs to know the value for each `instance`
    and return it accordingly. That is the reason we have been operating with the
    dictionary (`__dict__`) of each `instance` and setting and retrieving the values
    from there.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，描述符需要知道每个 `instance` 的值并相应地返回它。这就是为什么我们一直在操作每个 `instance` 的字典，并从那里设置和检索值。
- en: This is the most common approach. We have already covered why we cannot use
    `getattr()` and `setattr()` on those methods, so modifying the `__dict__` attribute
    is the last standing option, and, in this case, is acceptable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的方法。我们已经解释了为什么不能在那些方法上使用 `getattr()` 和 `setattr()`，所以修改 `__dict__` 属性是最后一个可行的选项，在这种情况下是可接受的。
- en: Accessing the dictionary of the object
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问对象字典
- en: The way we implement descriptors throughout this book is making the `descriptor`
    object store the values in the dictionary of the object, `__dict__`, and retrieve
    the parameters from there as well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中实现描述符的方式是让 `descriptor` 对象存储在对象的字典 `__dict__` 中，并从那里检索参数。
- en: Always store and return the data from the `__dict__` attribute of the instance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总是存储和从实例的 `__dict__` 属性返回数据。
- en: All of the examples we have seen so far use this approach, but in the following
    section, we will take a look at some alternatives.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的所有示例都使用了这种方法，但在下一节中，我们将探讨一些替代方案。
- en: Using weak references
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用弱引用
- en: Another alternative (if we don't want to use `__dict__`) is to make the `descriptor`
    object keep track of the values for each instance itself, in an internal mapping,
    and return values from this mapping as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代方案（如果我们不想使用 `__dict__`）是让 `descriptor` 对象跟踪每个实例自身的值，在一个内部映射中，并从这个映射中返回值。
- en: There is a caveat, though. This mapping cannot just be any dictionary. Since
    the `client` class has a reference to the descriptor, and now the descriptor will
    keep references to the objects that use it, this will create circular dependencies,
    and, as a result, these objects will never be garbage-collected because they are
    pointing at each other.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个注意事项。这个映射不能是任何字典。由于 `client` 类有一个对描述符的引用，而现在描述符将保持对使用它的对象的引用，这将创建循环依赖，结果，这些对象将永远不会被垃圾回收，因为它们正在互相指向。
- en: In order to address this, the dictionary has to be a weak key one, as defined
    in the `weakref (WEAKREF 01)` module.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，字典必须是弱键字典，如 `weakref`（WEAKREF 01）模块中定义的那样。
- en: 'In this case, the code for the `descriptor` might look like the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`descriptor` 的代码可能看起来像以下这样：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This addresses the issues, but it does come with some considerations:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了问题，但也带来了一些考虑：
- en: The objects no longer hold their attributes—the descriptor does instead. This
    is somewhat controversial, and it might not be entirely accurate from a conceptual
    point of view. If we forget this detail, we might ask the object, by inspecting
    its dictionary, to find things that just aren't there (for example, calling `vars(client)`
    will not return the complete data,).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象不再持有它们的属性——而是由描述符来持有。这在某种程度上是有争议的，并且从概念上讲可能并不完全准确。如果我们忘记这个细节，我们可能会通过检查对象的字典来寻找根本不存在的东西（例如，调用
    `vars(client)` 不会返回完整的数据）。
- en: It poses the requirement that the objects need to be hashable. If they aren't,
    they can't be part of the mapping. This might be too demanding a requirement for
    some applications (or it might force us to implement custom `__hash__` and `__eq__`
    magic methods).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提出了一个要求，即对象必须是可哈希的。如果不是，它们就不能成为映射的一部分。这可能对某些应用程序来说要求过于苛刻（或者可能迫使我们实现自定义的 `__hash__`
    和 `__eq__` 魔法方法）。
- en: For these reasons, we prefer the implementation that has been shown so far in
    this book, which uses the dictionary of each instance. However, for completeness,
    we have shown this alternative as well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们更喜欢这本书中已经展示的实现方式，它使用每个实例的字典。然而，为了完整性，我们也展示了这个替代方案。
- en: More considerations about descriptors
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于描述符的更多考虑
- en: Here, we will discuss general considerations about descriptors in terms of what
    we can do with them, when it is a good idea to use them, and also how things that
    we might have initially conceived as having been resolved by means of another
    approach can be improved through descriptors. We will then analyze the pros and
    cons of the original implementation versus the one after descriptors have been
    used.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论关于描述符的一般性考虑，包括我们可以如何使用它们，何时使用它们是明智的，以及我们最初可能认为通过另一种方法解决的问题如何通过描述符得到改进。然后，我们将分析原始实现与使用描述符后的实现的优缺点。
- en: Reusing code
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码重用
- en: Descriptors are a generic tool and a powerful abstraction that we can use to
    avoid code duplication.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是一个通用的工具，也是一个强大的抽象，我们可以用它来避免代码重复。
- en: A good scenario where descriptors might be useful is if we find ourselves in
    a situation where we need to write properties (as in a method decorated with `@property
    @<property>.setter` or `@<property>.deleter`), but we need to do the same property
    logic multiple times. That is, if we needed something like a generic property,
    or else we'll find ourselves writing multiple properties with the same logic and
    repeating boilerplate. Properties are just a particular case of descriptors (the
    `@property` decorator is a descriptor that implements the full descriptor protocol
    to define its `get`, `set`, and `delete` actions), which means that we can even
    use descriptors to accomplish far more complex tasks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符可能有用的情况之一是，如果我们发现自己处于需要编写属性（如在用`@property @<property>.setter`或`@<property>.deleter`装饰的方法中）但需要多次执行相同的属性逻辑的情况下。也就是说，如果我们需要像泛型属性这样的东西，否则我们会发现自己正在编写具有相同逻辑的多个属性，并重复样板代码。属性只是描述符的一个特例（`@property`装饰器是一个实现了完整描述符协议的描述符，用于定义其`get`、`set`和`delete`操作），这意味着我们甚至可以使用描述符来完成更复杂的任务。
- en: Another powerful type we have seen for reusing code was decorators, as explained
    in *Chapter 5*, *Using Decorators to Improve Our Code*. Descriptors can help us
    create better decorators by making sure that they will be able to work correctly
    for class methods as well.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第5章*，*使用装饰器改进我们的代码*中解释了另一种强大的代码重用类型，即装饰器。描述符可以帮助我们创建更好的装饰器，确保它们能够正确地为类方法工作。
- en: When it comes to decorators, we could say that it is safe to always implement
    the `__get__()` method on them, and also make it a descriptor. When trying to
    decide whether the decorator is worth creating, consider the three-problems rule
    we stated in *Chapter 5*, *Using Decorators to Improve Our Code*, but note that
    there are no extra considerations toward descriptors.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到装饰器时，我们可以说，始终在它们上实现`__get__()`方法是安全的，并且也可以将其作为描述符。在尝试决定是否创建装饰器时，考虑我们在*第5章*，*使用装饰器改进我们的代码*中提出的三个问题规则，但请注意，对于描述符没有额外的考虑。
- en: As for generic descriptors, besides the aforementioned three-instances rule
    that applies to decorators (and, in general, any reusable component), it is advisable
    to also keep in mind that you should use descriptors for cases where you want
    to define an internal API, which is some code that will have clients consuming
    it. This is a feature oriented more towards designing libraries and frameworks,
    rather than one-time solutions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于泛型描述符而言，除了适用于装饰器（以及一般可重用组件）的上述三个实例规则外，还建议记住，你应该在需要定义内部API的情况下使用描述符，即一些将被客户端消费的代码。这个特性更多地面向设计库和框架，而不是一次性解决方案。
- en: Unless there is a very good reason to, or the code will look significantly better,
    we should avoid putting business logic in a descriptor. Instead, the code of a
    descriptor will contain more implementational code rather than business code.
    It is more similar to defining a new data structure or object that another part
    of our business logic will use as a tool.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有非常好的理由，或者代码看起来会显著更好，否则我们应该避免在描述符中放置业务逻辑。相反，描述符的代码将包含更多实现代码而不是业务代码。它更类似于定义一个新的数据结构或对象，其他部分的业务逻辑将使用它作为工具。
- en: In general, descriptors will contain implementation logic, and not so much business
    logic.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，描述符将包含实现逻辑，而不是业务逻辑。
- en: An alternative to class decorators
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类装饰器的替代方案
- en: 'If we recall the class decorator we used in *Chapter 5*, *Using Decorators
    to Improve Our Code*, to determine how an event object is going to be serialized,
    we ended up with an implementation that (for Python 3.7+) relied on two class
    decorators:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回忆一下在*第5章*中使用的类装饰器，*使用装饰器改进我们的代码*，以确定事件对象将被如何序列化，我们最终得到一个实现，该实现（对于Python
    3.7+）依赖于两个类装饰器：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first one takes the attributes from the annotations to declare the variables,
    whereas the second one defines how to treat each file. Let's see whether we can
    change these two decorators for descriptors instead.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个装饰器从注解中获取属性以声明变量，而第二个装饰器定义了如何处理每个文件。让我们看看我们是否可以将这两个装饰器改为描述符。
- en: 'The idea is to create a descriptor that will apply the transformation over
    the values of each attribute, returning the modified version according to our
    requirements (for example, hiding sensitive information, and formatting dates
    correctly):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是创建一个描述符，它将对每个属性的值应用转换，根据我们的要求返回修改后的版本（例如，隐藏敏感信息，并正确格式化日期）：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This `descriptor` is interesting. It was created with a function that takes
    one argument and returns one value. This function will be the transformation we
    want to apply to the field. From the base definition that defines generically
    how it is going to work, the rest of the `descriptor` classes are defined, simply
    by changing the particular function each one needs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`descriptor`很有趣。它是通过一个接受一个参数并返回一个值的函数创建的。这个函数将是我们要应用到字段上的转换。从定义其将如何通用的基本定义，其他`descriptor`类通过简单地更改每个类需要的特定函数来定义。
- en: The example uses `functools.partial` ([https://docs.python.org/3/library/functools.html#functools.partial](https://docs.python.org/3/library/functools.html#functools.partial))
    as a way of simulating sub-classes, by applying a partial application of the transformation
    function for that class, leaving a new callable that can be instantiated directly.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用`functools.partial` ([https://docs.python.org/3/library/functools.html#functools.partial](https://docs.python.org/3/library/functools.html#functools.partial))
    作为模拟子类的一种方式，通过对该类转换函数的部分应用，留下一个可以直接实例化的新可调用对象。
- en: 'In order to keep the example simple, we will implement the `__init__()` and
    `serialize()` methods, although they could be abstracted away as well. Under these
    considerations, the class for the event will now be defined as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例简单，我们将实现`__init__()`和`serialize()`方法，尽管它们也可以被抽象化。在这些考虑下，事件类现在将定义如下：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can see how the object behaves at runtime:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到对象在运行时的行为：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are some differences with respect to the previous implementation that
    used a decorator. This example added the `serialize()` method and hid the fields
    before presenting them to its resulting dictionary, but if we asked for any of
    these attributes from an instance of the event in memory at any point, it would
    still give us the original value, without any transformation applied to it (we
    could have chosen to apply the transformation when setting the value, and return
    it directly on `__get__()`, as well).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前使用装饰器的实现相比，有一些不同。此示例添加了`serialize()`方法，并在将其呈现给结果字典之前隐藏了字段，但如果在任何时候从内存中的事件实例请求这些属性中的任何一个，它仍然会给我们原始值，而没有任何转换应用到它上面（我们本可以选择在设置值时应用转换，并在`__get__()`上直接返回它）。
- en: Depending on the sensitivity of the application, this may or may not be acceptable,
    but in this case, when we ask the object for its `public` attributes, the descriptor
    will apply the transformation before presenting the results. It is still possible
    to access the original values by asking for the dictionary of the object (by accessing
    `__dict__`), but when we ask for the value, by default, it will return it converted.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的敏感性，这可能或可能不被接受，但在这个情况下，当我们要求对象提供其`public`属性时，描述符会在呈现结果之前应用转换。仍然可以通过请求对象的字典（通过访问`__dict__`）来访问原始值，但当我们请求值时，默认情况下，它将返回转换后的值。
- en: In this example, all descriptors follow a common logic, which is defined in
    the base class. The descriptor should store the value in the object and then ask
    for it, applying the transformation it defines. We could create a hierarchy of
    classes, each one defining its own conversion function, in a way that the template
    method design pattern works. In this case, since the changes in the derived classes
    are relatively small (just one function), we opted for creating the derived classes
    as partial applications of the base class. Creating any new transformation field
    should be as simple as defining a new class that will be the base class, which
    is partially applied with the function we need. This can even be done ad hoc,
    so there might be no need to set a name for it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有描述符都遵循一个共同的逻辑，该逻辑在基类中定义。描述符应该将值存储在对象中，然后请求它，应用它定义的转换。我们可以创建一个类的层次结构，每个类定义自己的转换函数，这样模板方法设计模式就可以工作。在这种情况下，由于派生类的变化相对较小（只有一个函数），我们选择将派生类作为基类的部分应用来创建。创建任何新的转换字段应该像定义一个新的类一样简单，该类将成为基类，并部分应用所需的功能。这甚至可以临时完成，因此可能不需要为它设置名称。
- en: Regardless of this implementation, the point is that since descriptors are objects,
    we can create models, and apply all rules of object-oriented programming to them.
    Design patterns also apply to descriptors. We could define our hierarchy, set
    the custom behavior, and so on. This example follows the **Open/Closed Principle**
    (**OCP**), which we introduced in *Chapter 4*, *The SOLID Principles*, because
    adding a new type of conversion method would just be about creating a new class,
    derived from the base one with the function it needs, without having to modify
    the base class itself (to be fair, the previous implementation with decorators
    was also OCP-compliant, but there were no classes involved for each transformation
    mechanism).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这种实现如何，关键点是，由于描述符是对象，我们可以创建模型，并将面向对象编程的所有规则应用于它们。设计模式也适用于描述符。我们可以定义我们的层次结构，设置自定义行为，等等。这个例子遵循了我们在*第4章*，*SOLID原则*中介绍的**开放/封闭原则**（**OCP**），因为添加新的转换方法只需创建一个新的类，该类从基类派生，并具有所需的功能，而不需要修改基类本身（公平地说，之前的用装饰器的实现也符合OCP，但没有涉及每个转换机制的类）。
- en: 'Let''s take an example where we create a base class that implements the `__init__()`
    and `serialize()` methods so that we can define the `LoginEvent` class simply
    by deriving from it, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个例子来说明，我们创建一个基类，该基类实现了`__init__()`和`serialize()`方法，这样我们就可以通过从它派生来简单地定义`LoginEvent`类，如下所示：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once we achieve this code, the class looks cleaner. It only defines the attributes
    it needs, and its logic can be quickly analyzed by looking at the class for each
    attribute. The base class will abstract only the common methods, and the class
    of each event will look simpler and more compact.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现了这段代码，类看起来更简洁。它只定义了它需要的属性，并且可以通过查看每个属性的类来快速分析其逻辑。基类将只抽象出公共方法，每个事件的类看起来会更简单、更紧凑。
- en: Not only do the classes for each event look simpler, but the descriptor itself
    is very compact and a lot simpler than the class decorators. The original implementation
    with class decorators was good, but descriptors made it even better.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅每个事件的类看起来更简单，而且描述符本身也非常紧凑，比类装饰器简单得多。原始的用类装饰器的实现是好的，但描述符使它变得更好。
- en: Analysis of descriptors
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符分析
- en: We have seen how descriptors work so far and explored some interesting situations
    in which they contribute to clean design by simplifying their logic and leveraging
    more compact classes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了描述符是如何工作的，并探索了一些有趣的场景，在这些场景中，它们通过简化逻辑和利用更紧凑的类来促进清洁的设计。
- en: Up to this point, we know that by using descriptors, we can achieve cleaner
    code, abstracting away repeated logic and implementation details. But how do we
    know our implementation of the descriptors is clean and correct? What makes a
    good descriptor? Are we using this tool properly or over-engineering with it?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道通过使用描述符，我们可以实现更干净的代码，抽象出重复的逻辑和实现细节。但我们如何知道我们的描述符实现是干净和正确的？什么使一个好的描述符？我们是否正确地使用了这个工具，或者是否过度设计？
- en: In this section, we will analyze descriptors in order to answer these questions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析描述符以回答这些问题。
- en: How Python uses descriptors internally
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python如何内部使用描述符
- en: '*What makes a good descriptor?* A simple answer would be that a good descriptor
    is pretty much like any other good Python object. It is consistent with Python
    itself. The idea that follows this premise is that analyzing how Python uses descriptors
    will give us a good idea of good implementations so that we know what to expect
    from the descriptors we write.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么使一个好的描述符？* 一个简单的答案可能是，一个好的描述符几乎就像任何其他好的Python对象一样。它与Python本身保持一致。遵循这个前提的想法是，分析Python如何使用描述符将给我们一个很好的想法，了解良好的实现，以便我们知道我们编写的描述符可以期待什么。'
- en: We will see the most common scenarios where Python itself uses descriptors to
    solve parts of its internal logic, and we will also discover elegant descriptors
    and that have been there in plain sight all along.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到Python自身使用描述符来解决其内部逻辑的常见场景，我们还将发现那些一直就在我们眼前的优雅描述符。
- en: Functions and methods
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数和方法
- en: The most resonating case of an object that is a descriptor is probably a function.
    Functions implement the `__get__` method, so they can work as methods when defined
    inside a class.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符对象最引人注目的例子可能是函数。函数实现了 `__get__` 方法，因此当在类内部定义时，它们可以作为方法工作。
- en: In Python, methods are just regular functions, only they take an extra argument.
    By convention, the first argument of a method is named `self`, and it represents
    an instance of the class that the method is being defined in. Then, whatever the
    method does with `self` would be the same as any other function receiving the
    object and applying modifications to it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，方法只是常规函数，只是它们多了一个额外的参数。按照惯例，方法的第一个参数被命名为 `self`，它代表定义该方法的类的一个实例。然后，方法对
    `self` 所做的任何操作都与其他接收对象并对其应用修改的函数相同。
- en: 'In order words, when we define something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我们定义如下内容时：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It is actually the same as if we define this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就像我们定义了这个：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, it is just another function, modifying the object, only it's defined inside
    the class, and it is said to be bound to the object.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它只是一个修改对象的函数，只是它是在类内部定义的，并且说它是绑定到对象的。
- en: 'When we call something in the form of this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种形式调用某个东西时：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Python is, in fact, doing something equivalent to this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Python 正在执行与此等效的操作：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that this is just a syntax conversion that is handled internally by Python.
    The way this works is by means of descriptors.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只是Python内部处理的语法转换。它是通过描述符来实现的。
- en: 'Since functions implement the descriptor protocol (see the following listing)
    before calling the method, the `__get__()` method is invoked first (as we saw
    at the beginning of the chapter, this is part of the descriptor protocol: when
    the object being retrieved implements `__set__`, this is invoked and its result
    is returned instead). Then within this `__get__` method, some transformations
    happen before running the code on the internal callable:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数在调用方法之前实现了描述符协议（参见以下列表），因此首先调用 `__get__()` 方法（正如我们在本章开头所看到的，这是描述符协议的一部分：当被检索的对象实现了
    `__set__`，则调用它并返回其结果）。然后在这个 `__get__` 方法中，在运行内部可调用对象的代码之前，会发生一些转换：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the `instance.method(...)` statement, before processing all the arguments
    of the callable inside the parentheses, the `"instance.method"` part is evaluated.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `instance.method(...)` 语句中，在处理括号内可调用对象的全部参数之前，会评估 `"instance.method"` 部分。
- en: Since `method` is an object defined as a class attribute, and it has a `__get__`
    method, this is called. What this does is convert the function into a method,
    which means binding the callable to the instance of the object it is going to
    work with.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `method` 是作为类属性定义的对象，并且它有一个 `__get__` 方法，因此会调用这个方法。这个方法所做的就是将函数转换为方法，这意味着将可调用对象绑定到它将要与之一起工作的对象实例。
- en: Let's see this with an example so that we can get an idea of what Python might
    be doing internally.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看，这样我们就可以了解Python可能在内部做什么。
- en: 'We will define a callable object inside a class that will act as a sort of
    function or method that we want to define to be invoked externally. An instance
    of the `Method` class is supposed to be a function or method to be used inside
    a different class. This function will just print its three parameters—the `instance`
    that it received (which would be the `self` parameter on the class it''s being
    defined in), and two more arguments. In the `__call__()` method, the `self` parameter
    does not represent an instance of `MyClass`, but instead an instance of `Method`.
    The parameter named `instance` is meant to be a `MyClass` type of object:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在类内部定义一个可调用对象，它将充当一种函数或方法，我们希望定义并从外部调用。`Method` 类的一个实例应该是一个函数或方法，用于在另一个类内部使用。这个函数将只打印它的三个参数——它接收到的
    `instance`（这将是定义在其中的类的 `self` 参数），以及另外两个参数。在 `__call__()` 方法中，`self` 参数并不代表 `MyClass`
    的一个实例，而是一个 `Method` 的实例。名为 `instance` 的参数意味着它应该是一个 `MyClass` 类型的对象：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Under these considerations and, after creating the object, the following two
    calls should be equivalent, based on the preceding definition:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些考虑因素下，创建对象之后，根据前面的定义，以下两个调用应该是等效的：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, only the first one works as expected, as the second one gives an error:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有第一个按预期工作，因为第二个会引发错误：
- en: '[PRE51]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We are seeing the same error we faced with a decorator in *Chapter 5*, *Using
    Decorators to Improve Our Code*. The arguments are being shifted to the left by
    one: `instance` is taking the place of `self`, `"first"` is being passed in the
    place of `instance`, and `"second"` in the place of `arg1`. There is nothing to
    provide for `arg2`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了与第 5 章 *使用装饰器改进我们的代码* 中遇到的相同错误。参数被向左移动了一个位置：`instance` 取代了 `self` 的位置，`"first"`
    被传递到 `instance` 的位置，而 `"second"` 被传递到 `arg1` 的位置。没有为 `arg2` 提供任何内容。
- en: In order to fix this, we need to make `Method` a descriptor.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要将 `Method` 定义为一个描述符。
- en: 'This way, when we call `instance.method` first, we are going to call its `__get__()`,
    on which we bind this callable to the object accordingly (bypassing the object
    as the first parameter), and then proceed:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们首先调用 `instance.method` 时，我们将调用它的 `__get__()`，我们将这个可调用对象绑定到对象上（绕过对象作为第一个参数），然后继续：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, both calls work as expected:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这两个调用都按预期工作：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What we did is convert the `function` (actually the callable object we defined
    instead) into a method by using `MethodType` from the `types` module. The first
    parameter of this class should be a callable (`self`, in this case, is one by
    definition because it implements `__call__`), and the second one is the object
    to bind this function to.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是使用 `types` 模块中的 `MethodType` 将 `function`（实际上是定义的可调用对象）转换为一个方法。这个类的第一个参数应该是一个可调用对象（在这个例子中，`self`
    是一个可调用对象，因为根据定义它实现了 `__call__`），第二个参数是将此函数绑定到的对象。
- en: Something similar to this is what function objects use in Python so they can
    work as methods when they are defined inside a class. In this example, the `MyClass`
    abstraction was trying to simulate a function object because in the actual interpreter,
    this is implemented in C, so it would be harder to experiment with, but with this
    illustration, we can get an idea of what Python is internally doing when calling
    methods of our objects.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于此的是 Python 中函数对象使用的，这样它们可以在类内部定义时作为方法工作。在这个例子中，`MyClass` 抽象试图模拟一个函数对象，因为在实际的解释器中，这是用
    C 实现的，所以实验起来会更困难，但通过这个说明，我们可以了解 Python 在调用我们的对象的方法时内部做了什么。
- en: Since this is a very elegant solution, it's worth exploring it to keep it in
    mind as a Pythonic approach when defining our own objects. For instance, if we
    were to define our own callable, it would be a good idea to also make it a descriptor
    so that we can use it in classes as class attributes as well.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个非常优雅的解决方案，值得探索并记住，当定义我们自己的对象时，这是一个 Pythonic 的方法。例如，如果我们定义自己的可调用对象，那么将其也定义为一个描述符是一个好主意，这样我们就可以将其用作类属性。
- en: Built-in decorators for methods
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法的内置装饰器
- en: As you might have known from looking at the official documentation (PYDESCR-02),
    all `@property`, `@classmethod`, and `@staticmethod` decorators are descriptors.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从查看官方文档（PYDESCR-02）中可能已经知道的那样，所有 `@property`、`@classmethod` 和 `@staticmethod`
    装饰器都是描述符。
- en: 'We have mentioned several times that the idiom makes the descriptor return
    itself when it''s being called from a class directly. Since properties are actually
    descriptors, that is the reason why, when we ask it from the class, we don''t
    get the result of computing the property, but the entire `property` object instead:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到，这种习惯用法使得描述符在直接从类中调用时返回自身。由于属性实际上是描述符，这就是为什么当我们从类中请求它时，我们不会得到计算属性的结果，而是整个`property`对象：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For class methods, the `__get__` function in the descriptor will make sure that
    the class is the first parameter to be passed to the function being decorated,
    regardless of whether it's called from the class directly or from an instance.
    For static methods, it will make sure that no parameters are bound other than
    those defined by the function, namely undoing the binding done by `__get__()`
    on functions that make `self` the first parameter of that function.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类方法，描述符中的`__get__`函数将确保类是传递给被装饰函数的第一个参数，无论它是直接从类中调用还是从实例中调用。对于静态方法，它将确保除了函数定义的参数之外没有其他参数被绑定，即取消由`__get__()`在将`self`作为该函数的第一个参数的函数上所做的绑定。
- en: 'Let''s take an example; we create a `@classproperty` decorator that works like
    the regular `@property` decorator, but for classes instead. With a decorator like
    this one, the following code should be able to solve our use case:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子；我们创建一个`@classproperty`装饰器，它就像常规的`@property`装饰器一样工作，但用于类。使用这样的装饰器，以下代码应该能够解决我们的用例：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The code for making this work is compact and relatively straightforward:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使其工作的代码紧凑且相对简单：
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As we saw in the previous chapter, the initialization method takes the function
    that is going to be decorated when the decorator syntax is used. The interesting
    bit here is that we take advantage of the `__get__` magic method to call that
    function with the class as a parameter when it's being called.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，初始化方法在装饰器语法中使用时，会接受将要被装饰的函数。这里有趣的是，我们利用`__get__`魔法方法在它被调用时以类作为参数来调用该函数。
- en: 'You can appreciate how this example is different from the general boilerplate
    of the `__get__` method when called from a class: in these cases, most of the
    time, we ask if `instance` is `None`, and return `self`, but not here. In this
    case, we actually expect the instance to be `None` (because it''s being called
    from a class and not an object), so we do need the owner parameter (namely the
    class being acted upon).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以欣赏这个例子与从类中调用`__get__`方法的一般样板代码的不同之处：在这些情况下，大多数时候，我们会询问`instance`是否为`None`，并返回`self`，但这里不是这样。在这种情况下，我们实际上期望实例为`None`（因为它是从类中而不是从对象中调用的），所以我们确实需要所有者参数（即被操作的类）。
- en: Slots
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插槽
- en: '`__slots__` is a class attribute to define a fixed set of fields an object
    of that class can have.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`__slots__`是一个类属性，用于定义该类对象可以拥有的固定字段集。'
- en: From the examples that have been given so far, the reader might have already
    noticed that in Python the internal representation for objects is done with dictionaries.
    This is why the attributes of an object are stored as strings in its `__dict__`
    attribute. This is the reason why we can dynamically add new attributes to an
    object or remove current ones. There is no such thing as a `"frozen"` definition
    of attributes to be declared for objects. We can also inject methods dynamically
    (and we have done so in previous examples).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 从到目前为止给出的例子中，读者可能已经注意到，在Python中，对象的内部表示是通过字典来完成的。这就是为什么对象的属性存储在其`__dict__`属性中的字符串形式。这也是为什么我们可以动态地向对象添加新属性或删除现有属性的原因。对于对象要声明的属性，没有所谓的“冻结”定义。我们还可以动态地注入方法（我们已经在之前的例子中这样做过）。
- en: All of this changes with the `__slots__` class attribute. In this attribute,
    we define as a string what the names of the attributes that are allowed in a class
    are. And from that moment on, we will not be able to dynamically add any new attributes
    to instances of this class. Trying to add extra attributes dynamically to a class
    that defines `__slots__` will result in an `AttributeError`. By defining this
    attribute, the class becomes static, so it will not have a `__dict__` attribute
    where you can add more objects dynamically.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都随着`__slots__`类属性的改变而改变。在这个属性中，我们定义了一个字符串，表示允许在类中使用的属性名称。从那时起，我们将无法动态地向这个类的实例添加任何新属性。尝试向定义了`__slots__`的类动态添加额外属性将导致`AttributeError`。通过定义这个属性，类变成了静态的，因此它将没有`__dict__`属性，你可以在其中动态添加更多对象。
- en: 'How, then, are its attributes retrieved if not from the dictionary of the object?
    By using descriptors. Each name defined in a slot will have its own descriptor
    that will store the value for retrieval later:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果不从对象的字典中检索，它的属性是如何被检索的呢？通过使用描述符。在槽中定义的每个名称都将有自己的描述符，它将存储用于以后检索的值：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: With the use of `__slots__`, Python will only reserve enough memory for the
    attributes defined on it on the new objects as they're created. This will make
    the objects not have a `__dict__` attribute, so they can't be changed dynamically,
    and any attempt to use its dictionary (for example, by using the `function vars(...)`)
    would result in a `TypeError`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__slots__`，Python将只为在创建新对象时定义的属性保留足够的内存。这将使对象没有`__dict__`属性，因此它们不能被动态更改，并且任何尝试使用其字典（例如，通过使用`function
    vars(...)`）的操作都将导致`TypeError`。
- en: And because there is no `__dict__` attribute to store the values of the instance
    variables, what Python does instead is to create a descriptor for each slot and
    store the value there. This has the side effect that we cannot mix class attributes
    with instance ones (for example, if a common idiom for us would be to use a class
    attribute as a default value for an instance attribute, with this approach we
    would not be able to, because values would get overridden).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有`__dict__`属性来存储实例变量的值，Python取而代之的是为每个槽创建一个描述符，并将值存储在那里。这有一个副作用，即我们无法将类属性与实例属性混合（例如，如果我们常用的惯用用法是将类属性用作实例属性的默认值，则使用这种方法，我们将无法这样做，因为值将被覆盖）。
- en: While this is an interesting feature, it has to be used with caution because
    it takes away the dynamic nature of Python. In general, this ought to be reserved
    only for objects that we know are static, and if we are absolutely sure we are
    not adding any attributes to them dynamically in other parts of the code.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个有趣的功能，但必须谨慎使用，因为它会剥夺Python的动态特性。一般来说，这应该仅限于我们知道是静态的对象，并且如果我们绝对确信我们不会在其他代码部分动态地向它们添加任何属性。
- en: As an upside of this, objects defined with slots use less memory, since they
    only need a fixed set of fields to hold values and not an entire dictionary.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种方法的优点之一，使用槽定义的对象占用的内存更少，因为它们只需要一组固定的字段来存储值，而不是整个字典。
- en: Implementing descriptors in decorators
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在装饰器中实现描述符
- en: We now understand how Python uses descriptors in functions to make them work
    as methods when they are defined inside a class. We have also seen examples of
    cases where we can make decorators work by making them comply with the descriptor
    protocol by using the `__get__()` method of the interface to adapt the decorator
    to the object it is being called with. This solves the problem for our decorators
    in the same way that Python solves the issue of functions as methods in objects.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了Python如何在函数中使用描述符，使其在类内部定义时作为方法工作。我们还看到了一些例子，说明我们可以通过使用接口的`__get__()`方法使装饰器符合描述符协议，从而使其工作。这以与Python解决对象中函数作为方法的问题相同的方式解决了我们装饰器的问题。
- en: The general recipe for adapting a decorator in such a way is to implement the
    `__get__()` method on it and use `types.MethodType` to convert the callable (the
    decorator itself) into a method bound to the object it is receiving (the `instance`
    parameter received by `__get__`).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式适应装饰器的一般方法是在其上实现`__get__()`方法，并使用`types.MethodType`将可调用对象（装饰器本身）转换为绑定到接收到的对象（`__get__`接收到的`instance`参数）的方法。
- en: For this to work, we will have to implement the decorator as an object, because
    otherwise, if we are using a function, it will already have a `__get__()` method,
    which will be doing something different that will not work unless we adapt it.
    The cleaner way to proceed is to define a class for the decorator.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这起作用，我们必须将装饰器实现为一个对象，因为否则，如果我们使用一个函数，它已经有一个`__get__()`方法，这将执行不同的操作，除非我们对其进行适配，否则将不起作用。更干净的方法是定义一个装饰器类。
- en: Use a decorator class when defining a decorator that we want to apply to class
    methods, and implement the `__get__()` method on it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将装饰器应用于类方法时，使用装饰器类，并在其上实现`__get__()`方法。
- en: Final remarks about descriptors
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于描述符的最终评论
- en: To wrap up our analysis on descriptors, I would like to share some thoughts
    in terms of clean code and good practices or recommendations from experience.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们对描述符的分析，我想分享一些关于干净代码和良好实践或经验建议的想法。
- en: Interface of descriptors
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符接口
- en: When we revisited the interface segregation principle in *Chapter 4*, *The SOLID
    Principles* (the "I" in SOLID), we said that it's good practice to keep the interfaces
    small, and for that reason, we might want to separate them into smaller ones.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*第4章*中回顾接口隔离原则时，*SOLID原则*（SOLID中的"I”），我们说保持接口小是一个好的实践，因此我们可能想要将它们分成更小的部分。
- en: This idea appears here once again, not in the sense of an interface as in an
    abstract base class, but as the interface that the descriptor itself will present.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法再次出现，不是指作为抽象基类中的接口，而是指描述符本身将呈现的接口。
- en: As already mentioned, the descriptor protocol entails four methods, but partial
    implementation is allowed. That means you don't need to implement all of them
    all the time. In fact, if you only implement the minimal required methods, that
    would be better.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，描述符协议包含四种方法，但允许部分实现。这意味着你不必总是实现所有方法。实际上，如果你只实现所需的最小方法，那会更好。
- en: Most of the time, you'll find that you can address your requirements by only
    implementing the `__get__` method.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你会发现你只需实现`__get__`方法就能满足你的需求。
- en: Do not implement more methods than are necessary. The fewer methods you can
    implement of the descriptor protocol, the better.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 不要实现比必要的更多方法。你可以实现的描述符协议方法越少，越好。
- en: Moreover, you'll find that the `__delete__` method is seldom required.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你会发现`__delete__`方法很少需要。
- en: Object-oriented design of the descriptors
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符的面向对象设计
- en: With this concept, I don't mean that we can improve our object-oriented design
    capabilities by merely using descriptors (we have already covered that). But since
    descriptors are just regular objects, the rules of object-oriented design apply
    to them as well. For example, we can have base classes of descriptors, make use
    of inheritance to create more specific ones, etc.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说我们仅仅通过使用描述符就能提高我们的面向对象设计能力（我们已经讨论过这一点）。但既然描述符只是普通对象，面向对象设计的规则也适用于它们。例如，我们可以有描述符的基类，利用继承来创建更具体的类等。
- en: Keep in mind that all the rules and recommendations of good practices apply
    as well. For example, if you have a base class for a descriptor that only implements
    the `__get__` method, then it wouldn't be a good idea to create a sub-class of
    it that also implements the `__set__` method, as it wouldn't comply with Liskov's
    substitution principle (because we'd have a more specific type that implements
    an enhanced interface that the parent doesn't provide).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有良好的规则和实践建议也适用。例如，如果你有一个只实现`__get__`方法的描述符基类，那么创建一个也实现`__set__`方法的子类可能不是个好主意，因为它不会符合Liskov替换原则（因为我们会有一个更具体的类型，它实现了父类没有提供的一个增强接口）。
- en: Type annotations on descriptors
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符上的类型注释
- en: Applying type annotations on descriptors might be complicated most of the time.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述符上应用类型注释可能大多数时候都很复杂。
- en: There could be issues with circular dependencies (meaning the Python file that
    contains the definition for the descriptor will have to read from the file of
    the consumer in order to get the types, but then the client needs to read the
    file with the definition of the descriptor object to use it). Even if you surmount
    these issues with the use of strings instead of the actual types, there's another
    problem.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在循环依赖问题（这意味着包含描述符定义的Python文件将不得不读取消费者的文件以获取类型，但随后客户端需要读取包含描述符对象定义的文件来使用它）。即使你通过使用字符串而不是实际类型来克服这些问题，还有一个问题。
- en: 'If you know the exact type to annotate the descriptor methods, that means the
    descriptor is probably only useful for one type of class. And that generally defeats
    the purpose of a descriptor: the recommendation of this book is to use descriptors
    for scenarios in which we know we can benefit from a generalization, and reuse
    a lot of code. If we''re not reusing code, the complexity of having descriptors
    is not worth it.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道确切类型来注释描述符方法，这意味着描述符可能只对一种类型的类有用。这通常违背了描述符的目的：本书的建议是使用描述符来处理我们知道可以从中受益于泛化和大量代码重用的场景。如果我们不重用代码，拥有描述符的复杂性就不再值得了。
- en: For this reason, and even though it is generally good practice to always add
    annotations to our definitions, for the case of descriptors, it might be simpler
    just not to. Instead, think of it as a good opportunity for writing useful docstrings
    that accurately document the behavior of the descriptor.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，尽管始终添加注释到我们的定义通常是一个好的实践，但对于描述符的情况，可能简单地不添加注释会更简单。相反，将其视为编写有用文档字符串的好机会，这些文档字符串准确地记录了描述符的行为。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Descriptors are a more advanced feature in Python that push the boundaries closer
    to metaprogramming. One of their most interesting aspects is how they make crystal
    clear that classes in Python are just regular objects, and, as such, they have
    properties that we can interact with. Descriptors are, in this sense, the most
    interesting type of attribute a class can have because their protocol facilitates
    more advanced, object-oriented possibilities.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是Python中一个更高级的特性，它将元编程的边界推向了更近的地方。它们最有趣的一个方面是它们清楚地表明Python中的类只是普通的对象，并且作为这样的对象，它们具有我们可以与之交互的属性。在这个意义上，描述符是类可以拥有的最有趣的属性类型，因为它们的协议促进了更高级、面向对象的可能性。
- en: We have seen the mechanics of descriptors, their methods, and how all of this
    fits together, making a more interesting picture of object-oriented software design.
    By understanding descriptors, we were able to create powerful abstractions that
    yield clean and compact classes. We have seen how to fix decorators that we want
    to apply to functions and methods, and we have understood a lot more about how
    Python works internally, and how descriptors play such a core and critical role
    in the implementation of the language.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了描述符的机制、它们的方法以及所有这些是如何结合在一起，从而形成一个更有趣的对象式软件设计图景。通过理解描述符，我们能够创建出强大且简洁的抽象类。我们看到了如何修复我们想要应用于函数和方法的装饰器，并且我们对Python的内部工作原理以及描述符在语言实现中扮演的核心和关键角色有了更深入的了解。
- en: This study of how descriptors are used internally in Python should work as a
    reference to identify good uses of descriptors in our own code, with the goal
    of achieving idiomatic solutions.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这项研究如何在内部使用描述符的Python方法应该作为一个参考，以识别我们自己的代码中描述符的良好使用，目标是实现惯用的解决方案。
- en: Despite all of the powerful options that descriptors represent to our advantage,
    we have to keep in mind when to properly make use of them without over-engineering.
    In this line, we have suggested that we should reserve the functionality of descriptors
    for truly generic cases, such as the design of internal development APIs, libraries,
    or frameworks. Another important consideration along these lines is that, in general,
    we should not place business logic in descriptors, but rather logic that implements
    technical functionality to be used by other components that do contain business
    logic.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管描述符为我们提供了强大的选项，但我们必须记住何时恰当地使用它们，避免过度设计。在这方面，我们建议我们应该只为真正通用的情况保留描述符的功能，例如内部开发API、库或框架的设计。与此相关的一个重要考虑是，通常我们不应该在描述符中放置业务逻辑，而应该放置实现技术功能以供包含业务逻辑的其他组件使用的逻辑。
- en: 'Speaking of advanced functionality, the next chapter also covers an interesting
    and in-depth topic: generators. On the surface, generators are rather simple (and
    most readers are probably already familiar with them), but what they have in common
    with descriptors is that they can also be complex, yield a more advanced and elegant
    design, and make Python a unique language to work with.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到高级功能，下一章也涵盖了一个有趣且深入的主题：生成器。表面上，生成器相当简单（而且大多数读者可能已经熟悉它们），但它们与描述符的共同之处在于它们也可以很复杂，产生更高级和优雅的设计，并使Python成为一个独特的编程语言。
- en: References
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Here is a list of a few things you can reference for more information:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以参考以获取更多信息的事项：
- en: 'Python''s official documentation on descriptors: [https://docs.python.org/3/reference/datamodel.html#implementing-descriptors](https://docs.python.org/3/reference/datamodel.html#implementing-descriptors)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python官方文档关于描述符的说明：[https://docs.python.org/3/reference/datamodel.html#implementing-descriptors](https://docs.python.org/3/reference/datamodel.html#implementing-descriptors)
- en: '*WEAKREF 01: Python''s weakref module* ([https://docs.python.org/3/library/weakref.html](https://docs.python.org/3/library/weakref.html))'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WEAKREF 01: Python的weakref模块* ([https://docs.python.org/3/library/weakref.html](https://docs.python.org/3/library/weakref.html))'
- en: '*PYDESCR-02: Built-in decorators as descriptors* ([https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods](https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods))'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PYDESCR-02: 作为描述符的内置装饰器* ([https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods](https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods))'
