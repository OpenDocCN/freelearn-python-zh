- en: Chapter 1. Building a Clock App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 构建时钟应用
- en: This book will walk you through the creation of nine little Kivy programs, each
    resembling a real-world use case for the Kivy framework. On many occasions, the
    framework will be utilized together with other Python modules fitting for the
    task at hand. We will see that Kivy provides a great deal of flexibility, allowing
    us to solve vastly different problems in a clean, concise manner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将引导你创建九个小Kivy程序，每个程序都类似于Kivy框架在现实世界中的实际应用案例。在许多情况下，框架将与适合当前任务的Python模块一起使用。我们将看到Kivy提供了大量的灵活性，使我们能够以干净、简洁的方式解决各种不同的问题。
- en: Let's start small. In this chapter, we will build a simple Clock app, similar
    in concept to the built-in application found in both iOS and Android. In the first
    part of the chapter, we will create a non-interactive digital clock display and
    style it, giving our program an Android-ish flat look. We will also briefly discuss
    the event-driven program flow and a Kivy main loop, introducing timers used to
    perform recurring tasks, such as updating the screen every frame.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单开始。在本章中，我们将构建一个简单的时钟应用，其概念类似于iOS和Android中内置的应用程序。在本章的第一部分，我们将创建一个非交互式的数字时钟显示并对其进行样式设计，使我们的程序具有类似Android的扁平外观。我们还将简要讨论事件驱动的程序流程和Kivy主循环，介绍用于执行重复任务的计时器，例如每帧更新屏幕。
- en: In the second part of this chapter, we will add a stopwatch display and controls,
    creating a fluid layout suitable for any screen size and orientation. A stopwatch,
    naturally, needs user interaction, which we are going to implement last.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们将添加计时器显示和控制功能，创建一个适合任何屏幕尺寸和方向的流畅布局。计时器自然需要用户交互，我们将最后实现它。
- en: 'The important topics introduced in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的重要主题如下：
- en: The basics of the Kivy language, a built-in **domain-specific language** (**DSL**)
    used to lay out widgets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kivy语言的基礎，这是一个用于布局小部件的内置**领域特定语言**（**DSL**）
- en: Styling (and eventually subclassing) built-in Kivy components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式（以及最终子类化）内置的Kivy组件
- en: Loading custom fonts and formatting text
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载自定义字体和格式化文本
- en: Scheduling and listening to events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度和监听事件
- en: Our finished program, depicted in the following screenshot, will only be about
    60 lines long, split equally between a Python source code and a Kivy language
    (`.kv`) interface definition file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成的程序，如以下截图所示，将只有大约60行长，Python源代码和Kivy语言（`.kv`）界面定义文件各占一半。
- en: '![Building a Clock App](img/7849OS_01_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![构建时钟应用](img/7849OS_01_01.jpg)'
- en: The final look of the Clock app we're going to build.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的时钟应用最终外观。
- en: The starting point
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 起始点
- en: Our "Hello, Kivy" example from the preface is a suitable starting point for
    this app. We just need to add a layout container, `BoxLayout`, so that we can
    fit more than one widget on the screen later.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在序言中的“Hello, Kivy”示例是本应用的合适起点。我们只需要添加一个布局容器，`BoxLayout`，这样我们就可以在屏幕上放置多个小部件。
- en: 'This is the full source code at this point:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是完整的源代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Right now, it looks and behaves exactly like the previously seen "Hello, world"
    app. A `BoxLayout` container allows two or more child widgets to coexist side
    by side, stacking either vertically or horizontally. Given just one nested widget,
    as in the preceding code, `BoxLayout` fills up all the available screen space
    with it and thus becomes practically unnoticeable (it's as if `Label` was a root
    widget instead, taking over the application window). We will review layouts in
    more detail later on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它的外观和行为与之前看到的“Hello, world”应用完全一样。`BoxLayout`容器允许两个或更多子小部件并排存在，垂直或水平堆叠。给定一个嵌套小部件，如前面的代码所示，`BoxLayout`将所有可用的屏幕空间填充为它，因此实际上几乎看不见（就像`Label`是根小部件一样，接管了应用程序窗口）。我们将在稍后更详细地回顾布局。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that while we may call the `main.py` file anything we want, the `clock.kv`
    file is autoloaded by Kivy, and therefore, has to be named after the application
    class. For example, if our app class is called `FooBarApp`, a corresponding `.kv`
    file should be named `foobar.kv` (the class name converted to lowercase and without
    the `-app` suffix). Closely following this naming convention allows us to avoid
    loading Kivy language files manually, which is unequivocally a good thing—less
    lines of code leading to the same result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们可以将`main.py`文件命名为任何我们想要的名称，但`clock.kv`文件是由Kivy自动加载的，因此必须以应用程序类的名称命名。例如，如果我们的应用程序类名为`FooBarApp`，相应的`.kv`文件应命名为`foobar.kv`（类名转换为小写且不带`-app`后缀）。严格遵循此命名约定可以让我们避免手动加载Kivy语言文件，这无疑是件好事——更少的代码行数就能达到相同的结果。
- en: Modern UI
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代用户界面
- en: At the time of writing this, the flat design paradigm is trending in the interface
    design field, systematically taking over every platform, be it Web, mobile, or
    desktop. Prominent examples of this paradigm shift in the wild are iOS 7 and later
    and Windows 8 and later. Internet companies followed suit with the "Material design
    principles" presented at Google I/O 2014 conference, along with many other HTML5
    frameworks, including the well-established ones, for example, Bootstrap.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，扁平化设计范式在界面设计领域正流行，系统地接管了每一个平台，无论是Web、移动还是桌面。这种范式转变的突出例子包括iOS 7及其后续版本和Windows
    8及其后续版本。互联网公司随后效仿，在2014年Google I/O大会上提出了“材料设计原则”，以及许多其他HTML5框架，包括那些已经建立起来的，例如Bootstrap。
- en: Conveniently, the flat design emphasizes content over presentation, omitting
    photo-realistic shadows and detailed textures in favor of plain colors and simple
    geometry. It is by all means simpler to create programmatically than the "old
    school" skeuomorphic design that tends to be visually rich and artistic.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，扁平化设计强调内容而非展示，省略了照片般的阴影和详细的纹理，转而使用纯色和简单的几何形状。这种设计在程序上创建起来比“老式”的拟物化设计要简单得多，后者往往视觉丰富且富有艺术性。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Skeuomorphism** is a common approach to user interface design. It is characterized
    by applications visually imitating their real-world counterparts, for example,
    a Calculator app with the same button layout and look and feel as a cheap physical
    calculator. This may or may not help user experience (depending on who you ask).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**拟物主义**是用户界面设计的一种常见方法。其特点是应用程序在视觉上模仿其现实世界的对应物，例如，一个计算器应用程序具有与廉价物理计算器相同的按钮布局和外观感觉。这可能有助于或可能不助于用户体验（取决于你问谁）。'
- en: Giving up visual details in favor of a simpler, more streamlined interface seems
    to be the direction everyone is going in today. On the other hand, it's naturally
    challenging to build a distinctive, memorable interface just from colored rectangles
    and such. This is why the flat design is typically synonymous with good typography;
    depending on the application, text is almost always a significant part of the
    UI, so we want it to look great.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更简单、更流畅的界面而放弃视觉细节，这似乎是今天每个人都正在走的方向。另一方面，仅从彩色矩形等元素中构建一个独特、令人难忘的界面自然具有挑战性。这就是为什么扁平化设计通常与良好的排版同义；根据应用的不同，文本几乎总是UI的一个重要部分，因此我们希望它看起来很棒。
- en: Design inspiration
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计灵感
- en: 'Imitation is the sincerest form of flattery, and we will imitate the clock
    design from Android 4.1 Jelly Bean. The distinctive feature of this design is
    the font weight contrast. Until it was changed in version 4.4 KitKat, the default
    clock used to look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 仿效是最高形式的恭维，我们将仿效来自Android 4.1姜饼的时钟设计。这种设计的独特之处在于字体粗细对比。直到4.4 KitKat版本中进行了更改，默认时钟曾经看起来是这样的：
- en: '![Design inspiration](img/7849OS_01_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![设计灵感](img/7849OS_01_02.jpg)'
- en: Clock in Jelly Bean flavor of Android, as seen on the lock screen.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android姜饼版锁屏上看到的时钟。
- en: The font used is Roboto, Google's Android font that superseded the Droid font
    family in Android 4.0 Ice Cream Sandwich.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的字体是Roboto，这是Google在Android 4.0冰激凌三明治中取代Droid字体家族的Android字体。
- en: Roboto is free for commercial use and available under the permissive Apache
    License. It can be downloaded from Google Fonts or from the excellent Font Squirrel
    library at [http://www.fontsquirrel.com/fonts/roboto](http://www.fontsquirrel.com/fonts/roboto).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Roboto可用于商业用途，并受Apache许可的宽松许可。可以从Google Fonts或来自出色的Font Squirrel库[http://www.fontsquirrel.com/fonts/roboto](http://www.fontsquirrel.com/fonts/roboto)下载。
- en: Loading custom fonts
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载自定义字体
- en: When it comes to the typography, Kivy defaults to Droid Sans—Google's earlier
    font. It's easy to replace Droid with a custom font, as Kivy allows us to specify
    the `font_name` property for textual widgets (in this case, `Label`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到排版时，Kivy默认使用Droid Sans——谷歌早期的字体。用自定义字体替换Droid很容易，因为Kivy允许我们为文本小部件（在这种情况下，`Label`）指定`font_name`属性。
- en: 'In the simplest case when we have just one font variant, it is possible to
    assign a `.ttf` filename directly in the definition of a widget:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，当我们只有一种字体变体时，我们可以在小部件的定义中直接分配`.ttf`文件名：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the aforementioned design, however, we want different font weights, so this
    approach won't cut it. The reason being, every variation of a font (for example,
    bold or italic) commonly lives in a separate file, and we can only assign one
    filename to the `font_name` property.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于上述设计，我们希望有不同的字体重量，所以这种方法行不通。原因是字体的每个变体（例如，粗体或斜体）通常都生活在单独的文件中，而我们只能将一个文件名分配给`font_name`属性。
- en: 'Our use case, involving more than one `.ttf` file, is better covered by a `LabelBase.register`
    static method. It accepts the following arguments (all optional), exemplified
    by the Roboto font family:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，涉及到多个`.ttf`文件，`LabelBase.register`静态方法提供了更好的解决方案。它接受以下参数（所有参数都是可选的），以Roboto字体家族为例：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After this invocation, it becomes possible to set the `font_name` property of
    a widget to the name of the previously registered font family, `Roboto` in this
    case.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用此方法后，可以设置小部件的`font_name`属性为之前注册的字体家族名称，在这种情况下是`Roboto`。
- en: 'This approach has two limitations to be aware of:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个限制需要注意：
- en: Kivy only accepts TrueType `.ttf` font files. If the fonts are packaged as OpenType
    `.otf` or a web font format such as `.woff`, you may need to convert them first.
    This can be easily done using the FontForge editor, which can be found at [http://fontforge.org/](http://fontforge.org/).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kivy只接受TrueType `.ttf`字体文件。如果字体打包为OpenType `.otf`或`.woff`这样的网络字体格式，您可能需要先进行转换。这可以通过FontForge编辑器轻松完成，该编辑器可以在[http://fontforge.org/](http://fontforge.org/)找到。
- en: 'There is a maximum of four possible styles per font: normal, italic, bold,
    and bold italic. It''s fine for older font families, such as Droid Sans, but many
    modern fonts include anywhere from 4 to over 20 styles with varying font weight
    and other features. Roboto, which we''re going to use shortly, is available in
    at least 12 styles.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种字体最多有四种可能的样式：正常、斜体、粗体和粗斜体。对于像Droid Sans这样的旧字体家族来说，这没问题，但许多现代字体包括从4种到20种以上的样式，具有不同的字体重量和其他功能。我们即将使用的Roboto至少有12种样式。
- en: '![Loading custom fonts](img/7849OS_01_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![加载自定义字体](img/7849OS_01_03.jpg)'
- en: The six font weights of Roboto font
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Roboto字体的六种字体重量
- en: The second point forces us to choose which font styles we will use in our application
    as we can't just throw in all 12, which is a bad idea anyway as it would lead
    to a hefty increase in file size, up to 1.7 megabytes in the case of Roboto family.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点强制我们选择在应用程序中使用的字体样式，因为我们不能随意使用所有12种，这本身就是一个糟糕的想法，因为它会导致文件大小大幅增加，例如在Roboto字体家族中，可能增加到1.7兆字节。
- en: 'For this particular app, we only need two styles: a lighter one (`Roboto-Thin.ttf`)
    and a heavier one (`Roboto-Medium.ttf`), which we assign to `fn_regular` and `fn_bold`
    respectively:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的应用程序，我们只需要两种样式：一种较轻的样式（`Roboto-Thin.ttf`）和一种较重的样式（`Roboto-Medium.ttf`），我们分别将它们分配给`fn_regular`和`fn_bold`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code should be placed right after the `__name__ == '__main__'` line in
    `main.py`, as it needs to run before the interface is created from the Kivy language
    definition. By the time the app class is instantiated, it might already be too
    late to perform basic initialization like this. This is why we have to do it in
    advance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该放在`main.py`中的`__name__ == '__main__'`行之后，因为它需要在从Kivy语言定义创建界面之前运行。当应用程序类被实例化时，可能已经太晚执行这种基本初始化了。这就是为什么我们必须提前这样做。
- en: 'Now that we have a custom font in place, all that''s left is to assign it to
    our `Label` widget. This can be done with the help of the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了自定义字体，接下来要做的就是将其分配给我们的`Label`小部件。这可以通过以下代码完成：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Formatting text
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本格式化
- en: The most popular and universally used markup language out there is undoubtedly
    HTML. Kivy, on the other hand, implements a variant of BBCode, a markup language
    once used to format posts on many message boards. Visible distinction from HTML
    is that BBCode uses square brackets as tag delimiters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最流行且普遍使用的标记语言无疑是HTML。另一方面，Kivy实现了一种BBCode的变体，这是一种曾经用于在许多论坛上格式化帖子的标记语言。与HTML的明显区别是BBCode使用方括号作为标签分隔符。
- en: 'The following tags are available in Kivy:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标签在 Kivy 中可用：
- en: '| BBCode tag | Effect on text |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| BBCode 标签 | 文本效果 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `[b]...[/b]` | **Bold** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `[b]...[/b]` | **加粗** |'
- en: '| `[i]...[/i]` | *Italic* |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `[i]...[/i]` | *斜体* |'
- en: '| `[font=Lobster]...[/font]` | Change font |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `[font=Lobster]...[/font]` | 更改字体 |'
- en: '| `[color=#FF0000]...[/color]` | Set color with CSS-like syntax |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `[color=#FF0000]...[/color]` | 使用 CSS 类似的语法设置颜色 |'
- en: '| `[sub]...[/sub]` | Subscript (text below the line) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `[sub]...[/sub]` | 下标（位于行下方的文本）|'
- en: '| `[sup]...[/sup]` | Superscript (text above the line) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `[sup]...[/sup]` | 上标（位于行上方的文本）|'
- en: '| `[ref=name]...[/ref]` | Clickable zone, `<a href="…">` in HTML |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `[ref=name]...[/ref]` | 可点击区域，HTML 中的 `<a href="…">` |'
- en: '| `[anchor=name]` | Named location, `<a name="…">` in HTML |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `[anchor=name]` | 命名位置，HTML 中的 `<a name="…">` |'
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is by no means an exhaustive reference because Kivy is under active development
    and has probably undergone a number of releases since this text was written, adding
    new features and refining the existing functionality. Please refer to the Kivy
    documentation found on the official website ([http://kivy.org](http://kivy.org))
    for an up-to-date reference manual.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一份详尽的参考，因为 Kivy 正在积极开发，自本文编写以来可能已经发布了多个版本，增加了新功能并改进了现有功能。请参考官方网站（[http://kivy.org](http://kivy.org)）上找到的
    Kivy 文档，以获取最新的参考手册。
- en: 'Let''s return to our project. To achieve the desired formatting (hours in bold
    and the rest of the text in `fn_regular` thin font), we can use the following
    code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的项目。为了达到所需的格式（小时加粗，其余文本使用 `fn_regular` 轻细字体），我们可以使用以下代码：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Kivy's BBCode flavor works only if we also set the `markup` property of a widget
    to `True`, as shown in the preceding code. Otherwise, you will literally see the
    string `[b]…[/b]` displayed on the screen, and that's clearly not desired.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 的 BBCode 风味只有在我们也设置了小部件的 `markup` 属性为 `True` 时才有效，如前述代码所示。否则，你将直接在屏幕上看到字符串
    `[b]…[/b]` 被显示出来，这显然不是我们想要的。
- en: Note that if we wanted to make the whole text bold, there is no need to enclose
    everything in `[b]…[/b]` tags; we could just set the `bold` property of the widget
    to `True`. The same applies to italic, color, font name, and size—pretty much
    everything can be configured globally to affect the whole widget without touching
    markup.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们想使整个文本加粗，没有必要将所有内容都放在 `[b]…[/b]` 标签内；我们只需将小部件的 `bold` 属性设置为 `True`。同样的方法也适用于斜体、颜色、字体名称和大小——几乎所有的配置都可以全局设置，从而影响整个小部件，而不需要修改标记。
- en: Changing the background color
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改背景颜色
- en: 'In this section, we will adjust the window background color. Window background
    (the "clear color" of OpenGL renderer) is a property of a global `Window` object.
    In order to change it, we add this code right after the `__name__ == ''__main__''`
    line in `main.py`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将调整窗口的背景颜色。窗口背景（OpenGL 渲染器的“清除颜色”）是全局 `Window` 对象的一个属性。为了更改它，我们在 `main.py`
    中的 `__name__ == '__main__'` 行之后添加此代码：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `get_color_from_hex` function is not strictly required, but it''s nice
    as it allows us to use CSS-style (`#RRGGBB`) colors instead of `(R, G, B)` tuples
    throughout our code. And using CSS colors is preferable for at least the following
    two reasons:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_color_from_hex` 函数并非严格必需，但使用起来很方便，因为它允许我们使用 CSS 风格的 (`#RRGGBB`) 颜色代替 `(R,
    G, B)` 元组来编写代码。而且使用 CSS 颜色至少有以下两个优点：'
- en: '**Less cognitive overhead when reading**: The `#FF0080` value is immediately
    recognized as a color when you''re familiar with this notation, while (255, 0,
    128) is just a bunch of numbers that may be used differently depending on the
    context. The floating-point variant of `#FF0080`, (1.0, 0.0, 0.50196) is even
    worse.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阅读时的认知负担更小**：当你熟悉这种表示法时，`#FF0080` 值会立即被识别为颜色，而 (255, 0, 128) 只是一组数字，其用途可能因上下文而异。`#FF0080`
    的浮点变体 (1.0, 0.0, 0.50196) 甚至更糟。'
- en: '**Simple and unambiguous searching**: A tuple can be arbitrarily formatted,
    while a CSS-like color notation is uniform, albeit case-insensitive. Performing
    a case-insensitive search in most text editors is very simple, as opposed to locating
    all instances of a given tuple inside a lengthy Python listing. The latter task
    can prove challenging and involve regular expressions, among other things, because
    the formatting of tuples doesn''t have to be consistent.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单且明确的搜索**：元组可以任意格式化，而 CSS 类似的颜色表示法是统一的，尽管不区分大小写。在大多数文本编辑器中进行不区分大小写的搜索非常简单，相比之下，在漫长的
    Python 列表中定位给定元组的所有实例则可能更具挑战性，这可能需要正则表达式等工具，因为元组的格式不需要保持一致。'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information about the `#RRGGBB` color format can be found on Mozilla Developer
    Network at [https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Color](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Color).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `#RRGGBB` 颜色格式的更多信息可以在 Mozilla 开发者网络中找到：[https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Color](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Color)。
- en: We will talk more about design-related features of Kivy later on. Meanwhile,
    let's make our application actually show the time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论 Kivy 的设计相关特性。同时，让我们让我们的应用程序真正显示时间。
- en: Making the clock tick
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使时钟滴答
- en: UI frameworks are mostly event-driven, and Kivy is no exception. The distinction
    from the "usual" procedural code is simple—the event-driven code needs to return
    to the main loop often; otherwise, it will be unable to process events from a
    user (such as pointer movement, clicks, or window resize), and the interface will
    "freeze". If you're a longtime Microsoft Windows user, you are probably familiar
    with programs that are unresponsive and freeze very often. It is crucial to never
    let this happen in our apps.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: UI 框架大多是事件驱动的，Kivy 也不例外。与“常规”过程代码的区别很简单——事件驱动代码需要经常返回到主循环；否则，它将无法处理来自用户（如指针移动、点击或窗口调整大小）的事件，界面将“冻结”。如果你是长期使用
    Microsoft Windows 的用户，你可能熟悉那些经常无响应和冻结的程序。在我们的应用程序中绝对不能让这种情况发生。
- en: 'Practically, this means that we can''t just code an infinite loop like this
    in our program:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着我们无法在我们的程序中简单地编写一个无限循环：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Technically, it might work, but the application's UI will stay in the "not responding"
    state until the application gets killed (forcefully stopped) by the user or an
    operating system. Instead of taking this faulty approach, we need to keep in mind
    that there is a main loop running inside Kivy, and we need to take advantage of
    it by utilizing events and timers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这可能可行，但应用程序的 UI 将保持在“未响应”状态，直到用户或操作系统强制停止应用程序。与其采取这种错误的方法，我们应牢记 Kivy 内部有一个主循环正在运行，我们需要通过利用事件和计时器来利用它。
- en: Event-driven architecture also means that in many places, we will listen to
    events to respond to various conditions, be it user input, network events, or
    timeouts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构还意味着在许多地方，我们将监听事件以响应各种条件，无论是用户输入、网络事件还是超时。
- en: One of the common events that many programs listen to is `App.on_start`. A method
    with this name, if defined on the application class, will be called as soon as
    the app is fully initialized. Another good example of an event that we will find
    in many programs is `on_press`, which fires when the user clicks, taps, or otherwise
    interacts with a button.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序监听的一个常见事件是 `App.on_start`。如果在这个应用程序类中定义了具有此名称的方法，那么一旦应用程序完全初始化，该方法就会被调用。另一个在许多程序中都会找到的事件示例是
    `on_press`，当用户点击、轻触或以其他方式与按钮交互时，它会触发。
- en: 'Speaking of time and timers, we can easily schedule our code to run in the
    future using a built-in `Clock` class. It exposes the following static methods:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 说到时间和计时器，我们可以使用内置的 `Clock` 类轻松地安排我们的代码在未来运行。它公开以下静态方法：
- en: '`Clock.schedule_once`: Runs a function once after a timeout'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clock.schedule_once`：在超时后运行一次函数'
- en: '`Clock.schedule_interval`: Runs a function periodically'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clock.schedule_interval`：定期运行函数'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Anyone with a JavaScript background will easily recognize these two functions.
    They are exactly like `window.setTimeout` and `window.setInterval` in JS. Indeed,
    the Kivy programming model is very similar to JavaScript even if the API looks
    completely different.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有 JavaScript 背景的人都会很容易识别这两个函数。它们与 JS 中的 `window.setTimeout` 和 `window.setInterval`
    完全一样。实际上，尽管 API 完全不同，Kivy 的编程模型与 JavaScript 非常相似。
- en: It's important to understand that all timed events that originate from `Clock`
    run as a part of Kivy's main event loop. This approach is not synonymous to threading,
    and scheduling a blocking function like this may prevent other events from being
    invoked in a timely manner, or at all.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，所有源自 `Clock` 的定时事件都作为 Kivy 主事件循环的一部分运行。这种方法与线程不同，调度这种阻塞函数可能会阻止其他事件及时或根本无法被调用。
- en: Updating the time on the screen
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新屏幕上的时间
- en: To access the `Label` widget that holds time, we will give it a unique identifier
    (`id`). Later, we can easily look up widgets based on their `id` property—again,
    a concept which is very similar to web development.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问包含时间的 `Label` 小部件，我们将给它一个唯一的标识符（`id`）。稍后，我们可以根据它们的 `id` 属性轻松查找小部件——这又是一个与网络开发非常相似的概念。
- en: 'Modify `clock.kv` by adding the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下内容修改 `clock.kv`：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's it! Now we can access this `Label` widget from our code directly using
    the `root.ids.time` notation (`root` in our case is `BoxLayout`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！现在我们可以直接使用`root.ids.time`的表示法（在我们的例子中是`BoxLayout`）从我们的代码中访问这个`Label`小部件。
- en: 'Updates to the `ClockApp` class include the addition of a method to display
    time, `update_time`, which looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClockApp`类的更新包括添加一个显示时间的`update_time`方法，如下所示：'
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let''s schedule the update function to run once per second after the program
    starts:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们安排更新函数在程序启动后每秒运行一次：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we run the application right now, we'll see that the time displayed is being
    updated every second. To paraphrase Neil Armstrong, that is one small step for
    mankind, but a sizable leap for a Kivy beginner.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们会看到显示的时间每秒都在更新。用尼尔·阿姆斯特朗的话来说，这是人类迈出的一小步，但对于Kivy初学者来说是一大步。
- en: 'It''s worth noting how the argument to `strftime` combines Kivy''s BBCode-like
    tags described earlier with the function-specific C-style format directives. For
    the unfamiliar, here''s a quick and incomplete reference on `strftime` formatting
    essentials:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`strftime`函数的参数是如何将之前描述的Kivy的BBCode-like标签与特定函数的C样式格式指令结合起来的。对于不熟悉的人来说，这里有一个关于`strftime`格式化基本内容的快速且不完整的参考：
- en: '| Format string (case-sensitive) | Resulting output |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 格式字符串（区分大小写） | 结果输出 |'
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%S` | Second as two digits, typically `00` to `59` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `%S` | 秒，通常是`00`到`59` |'
- en: '| `%M` | Minute as two digits, `00` to `59` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `%M` | 分钟，从`00`到`59` |'
- en: '| `%H` | Hour as per 24-hour clock, `00` to `23` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `%H` | 按照24小时制的时，从`00`到`23` |'
- en: '| `%I` | Hour as per 12-hour clock, `01` to `12` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `%I` | 按照12小时制的时，从`01`到`12` |'
- en: '| `%d` | Day of the month, `01` to `31` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 月份中的天数，从`01`到`31` |'
- en: '| `%m` | Month (numeric), `01` to `12` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `%m` | 月份（数字），从`01`到`12` |'
- en: '| `%B` | Month (string), for example, `"October"` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `%B` | 月份（字符串），例如，“十月” |'
- en: '| `%Y` | Year as four digits, such as `2016` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `%Y` | 四位数的年份，例如`2016` |'
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For the most complete and up-to-date documentation on displaying time, please
    refer to the official reference manual—in this case, Python standard library reference,
    located at [https://docs.python.org/](https://docs.python.org/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于显示时间的最完整和最新的文档，请参阅官方参考手册——在这种情况下，Python标准库参考，位于[https://docs.python.org/](https://docs.python.org/)。
- en: Binding widgets using properties
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用属性绑定小部件
- en: Instead of hardcoding an ID for each widget that we need to access from Python
    code, we can also create a property and assign it in a Kivy language file. The
    motivation for doing so is mostly the **DRY** principle and cleaner naming, at
    a cost of a few more lines of code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以通过Python代码为每个需要访问的小部件硬编码一个ID，还可以在Kivy语言文件中创建一个属性并为其赋值。这样做的主要动机是**DRY**原则和更清晰的命名，代价是代码行数稍微多了些。
- en: 'Such a property can be defined as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的属性可以这样定义：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code fragment, we make a new root widget class for our application based
    on `BoxLayout`. It has a custom property, `time_prop`, which is going to reference
    `Label` we need to address from Python code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们基于`BoxLayout`为我们的应用程序创建一个新的根小部件类。它有一个自定义属性，`time_prop`，它将引用我们需要从Python代码中引用的`Label`。
- en: 'Additionally, in the Kivy language file, `clock.kv`, we have to bind this property
    to a corresponding `id`. Custom properties look and behave no different from the
    default ones and use exactly the same syntax:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Kivy语言文件`clock.kv`中，我们必须将这个属性绑定到一个相应的`id`上。自定义属性看起来和行为与默认属性没有区别，并且使用完全相同的语法：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code makes the `Label` widget accessible from the Python code without knowing
    the widget's ID, using the newly defined property, `root.time_prop.text = "demo"`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过使用新定义的属性`root.time_prop.text = "demo"`，使`Label`小部件从Python代码中可访问，而无需知道小部件的ID。
- en: The described approach is more portable than the previously shown one and it
    eliminates the need to keep widget identifiers from the Kivy language file in
    sync with the Python code, for example, when refactoring. Otherwise, the choice
    between relying on properties and accessing widgets from Python via `root.ids`
    is a matter of coding style.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的方法比之前展示的方法更便携，并且消除了在重构时需要保持Kivy语言文件中的小部件标识符与Python代码同步的需求。否则，选择依赖属性还是通过`root.ids`从Python访问小部件，这是一个编码风格的问题。
- en: Later in this book, we'll explore more advanced usage of Kivy properties, facilitating
    nearly effortless data binding.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将探讨Kivy属性的更高级用法，这有助于几乎无需费力地进行数据绑定。
- en: Layout basics
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局基础
- en: To arrange widgets on the screen, Kivy provides a number of `Layout` classes.
    `Layout`, a subclass of `Widget`, serves as a container for other widgets. Every
    layout affects the positioning and size of its children in a unique way.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上排列小部件，Kivy提供了一系列`Layout`类。`Layout`是`Widget`的子类，用作其他小部件的容器。每个布局都以独特的方式影响其子元素的位置和大小。
- en: 'For this application, we won''t need anything fancy, as the desired UI is pretty
    straightforward. This is what we''re aiming to achieve:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，我们不需要任何花哨的东西，因为所需的用户界面相当直观。这是我们想要实现的目标：
- en: '![Layout basics](img/7849OS_01_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![布局基础](img/7849OS_01_04.jpg)'
- en: A mockup layout of the finished Clock app interface.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 完成时钟应用程序界面的布局原型。
- en: To build this, we will use `BoxLayout`, which is basically a one-dimensional
    grid. We already have `BoxLayout` in our `clock.kv` file, but since it only has
    one child, it does not affect anything. A rectangular grid with one cell is really
    just that, a rectangle.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个，我们将使用`BoxLayout`，它基本上是一个一维网格。我们已经在`clock.kv`文件中有了`BoxLayout`，但由于它只有一个子元素，所以它不会影响任何事情。一个只有一个单元格的矩形网格实际上就是这样一个矩形。
- en: Kivy layouts almost always try to fill the screen, thus our application will
    adapt to any screen size and orientation changes automatically.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy布局几乎总是试图填满屏幕，因此我们的应用程序将自动适应任何屏幕大小和方向变化。
- en: 'If we add another label to `BoxLayout`, it will take half the screen space,
    depending on the orientation: a vertical box layout grows from top to bottom,
    and horizontal from left to right.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`BoxLayout`中添加另一个标签，它将占据一半的屏幕空间，具体取决于方向：垂直盒布局从上到下增长，水平布局从左到右。
- en: You might have guessed that in order to create a row of buttons inside a vertical
    layout, we can just embed another, horizontal box layout into the first one. Layouts
    are widgets, so they can be nested in arbitrary and creative ways to build complex
    interfaces.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，为了在垂直布局中创建一排按钮，我们只需将另一个水平盒布局嵌入到第一个布局中即可。布局是小部件，因此它们可以以任意和创造性的方式嵌套，以构建复杂的界面。
- en: Finalizing the layout
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成布局
- en: Stacking three widgets into `BoxLayout` normally makes every widget a third
    of the available size. Since we don't want buttons to be this big compared to
    clock displays, we can add a `height` property to the horizontal (inner) `BoxLayout`
    and set its vertical `size_hint` property to `None`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将三个小部件堆叠到`BoxLayout`中通常会使每个小部件占据可用大小的三分之一。由于我们不想让按钮与时钟显示相比这么大，我们可以向水平（内部）`BoxLayout`添加一个`height`属性，并将其垂直`size_hint`属性设置为`None`。
- en: The `size_hint` property is a tuple of two values, affecting the widget's width
    and height. We will discuss the impact that `size_hint` has on different layouts
    in the next few chapters; right now, let's just say that if we want to use absolute
    numbers for width or height, we have to set `size_hint` to `None` accordingly;
    otherwise, assigning size won't work as the widget will continue to compute its
    own size instead of using the values that we'll provide.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`size_hint`属性是一个包含两个值的元组，影响小部件的宽度和高度。我们将在下一章讨论`size_hint`对不同布局的影响；现在，我们只需说，如果我们想为宽度或高度使用绝对数字，我们必须相应地将`size_hint`设置为`None`；否则，分配大小将不起作用，因为小部件将继续计算它自己的大小而不是使用我们提供的值。'
- en: 'After updating the `clock.kv` file to account for stopwatch display and controls,
    it should look similar to the following (note the hierarchy of the layouts):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新`clock.kv`文件以考虑计时器显示和控制后，它应该看起来类似于以下内容（注意布局的层次结构）：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we run the code now, we'll notice that buttons don't fill all the available
    space inside `BoxLayout`. This effect is achieved using the `padding` and `spacing`
    properties of the layout. Padding acts very similar to CSS, pushing children (in
    our case, buttons) away from the edges of the layout, while spacing controls the
    distance between adjacent children. Both properties default to zero, aiming at
    maximum widget density.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行代码，我们会注意到按钮没有填满`BoxLayout`内部的所有可用空间。这种效果是通过使用布局的`padding`和`spacing`属性实现的。Padding与CSS非常相似，将子元素（在我们的例子中是按钮）从布局的边缘推开，而spacing控制相邻子元素之间的距离。这两个属性默认为零，旨在达到最大的小部件密度。
- en: Reducing repetition
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少重复
- en: 'This layout works but has one serious problem: the code is very repetitive.
    Every change we may want to make has to be done in a number of places throughout
    the file, and it''s very easy to miss one of them and thus introduce an inconsistent
    change.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布局是可行的，但有一个严重的问题：代码非常重复。我们可能想要做的每一个更改都必须在文件中的多个地方进行，很容易错过其中一个，从而引入不一致的更改。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To continue the analogy with the web platform, before **CSS** (**Cascading
    Style Sheets**) became universally available, style information was being written
    directly in tags that surround the text. It looked like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续与网络平台的类比，在 **CSS**（**层叠样式表**）成为普遍可用之前，样式信息是直接写入围绕文本的标签中的。它看起来像这样：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using this approach, changing any individual element's properties is easy, but
    adjusting the properties of the whole document's look requires an excessive amount
    of manual labor. If we wanted to change the font face to Times in the next version
    of the page, we would have to search and replace every occurrence of the word
    Helvetica while trying to make sure that we don't have this same word in the running
    text, as it may be occasionally replaced too.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，更改任何单个元素的属性很容易，但调整整个文档外观的属性则需要大量的手动劳动。如果我们想在下一版本的页面上更改字体为 Times，我们就必须搜索并替换Helvetica这个词的每个出现，同时确保运行文本中没有这个词，因为它可能偶尔也会被替换。
- en: 'With style sheets, on the other hand, we move all of the styling information
    to a CSS rule:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用样式表，我们将所有的样式信息移动到一个 CSS 规则中：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we have just one place to account for styling of every paragraph throughout
    the document; no more searching and replacing to change font or any other visual
    attribute, such as color or padding. Note that we still may slightly adjust a
    single element''s properties:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要一个地方来处理文档中每个段落的样式；不再需要搜索和替换来更改字体或任何其他视觉属性，如颜色或填充。请注意，我们仍然可以稍微调整单个元素的属性：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So we haven't lost anything by implementing CSS, and there is practically no
    tradeoff; this explains why the adaptation of style sheets on the Internet was
    very fast (especially considering the scale) and overwhelmingly successful. CSS
    is being widely used to this day with no conceptual changes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过实现 CSS，我们没有失去任何东西，实际上没有权衡；这解释了为什么在互联网上采用样式表非常快（特别是考虑到规模）并且非常成功。CSS 到今天仍在广泛使用，没有概念上的变化。
- en: 'In Kivy, there is no need to use a different file for our aggregate styles
    or class rules, like it''s usually done in web development. We just add to the
    `clock.kv` file a definition like the following, outside of `BoxLayout`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kivy 中，我们不需要为我们的聚合样式或类规则使用不同的文件，就像在网页开发中通常所做的那样。我们只需在 `BoxLayout` 外部向 `clock.kv`
    文件添加一个如下定义：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a class rule; it acts similar to a CSS selector described in the previous
    information box. Every `Label` derives all the properties from the `<Label>` class
    rule. (Note the angle brackets.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类规则；它的作用类似于之前信息框中描述的 CSS 选择器。每个 `Label` 都从 `<Label>` 类规则继承所有属性。（注意尖括号。）
- en: Now we can remove the `font_name`, `font_size`, and `markup` properties from
    each individual `Label`. As a general rule, always strive to move every repeated
    definition into a class. This is a well-known best practice called **don't repeat
    yourself** (**DRY**). Changes like the one shown in the previous code snippet
    may seem trivial in a toy project like this but will make our code much cleaner
    and more maintainable in a long run.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从每个单独的 `Label` 中移除 `font_name`、`font_size` 和 `markup` 属性。作为一个一般规则，总是努力将每个重复的定义移动到类中。这是一个众所周知的最佳实践，称为**不要重复自己**（**DRY**）。像前一个代码片段中所示的变化，在这样一个玩具项目中可能看起来微不足道，但最终会使我们的代码更加整洁和易于维护。
- en: If we want to override a property of one of the widgets, just add it as usual.
    Immediate properties take precedence over those inherited from the class definition.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想覆盖某个小部件的属性，只需像往常一样添加即可。立即属性比从类定义中继承的属性具有优先级。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that a class definition is completely different from a widget defined
    in the same `.kv` file. While the syntax is largely the same, the class is just
    an abstract definition; on its own, it does not create a new widget. Thus, adding
    a class definition will not introduce any changes to the app if we don't use it
    later.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，类定义与在同一个 `.kv` 文件中定义的小部件完全不同。虽然语法在很大程度上是相同的，但类只是一个抽象定义；它本身不会创建一个新的小部件。因此，如果我们以后不使用它，添加类定义不会对应用程序引入任何更改。
- en: Named classes
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名类
- en: One obvious problem with the straightforward approach to classes described earlier
    is that we can only have one class named `Label`. As soon as we need two different
    sets of properties applied to the same kind of widget, we have to define our own
    custom classes for them. Additionally, overwriting the framework's built-in classes,
    such as `Label` or `Button`, may have undesired consequences throughout the application,
    for example, if another component is using the widget we've altered under the
    hood.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的直接方法中存在的一个明显问题是，我们只能有一个名为`Label`的类。一旦我们需要将不同的属性集应用于同一种类型的控件，我们就必须为它们定义自己的自定义类。此外，覆盖框架的内置类，如`Label`或`Button`，可能会在整个应用程序中产生不希望的结果，例如，如果另一个组件正在使用我们底层更改的控件。
- en: 'Fortunately, this is very simple to solve. Let''s create a named class for
    buttons, `RobotoButton`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这很容易解决。让我们为按钮创建一个命名类，`RobotoButton`：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The part before the `@` symbol designates the new class name, followed by the
    widget type we''re extending (in Python, we would say `class RobotoButton(Button):`
    instead). The resulting class can be then used in the Kivy language instead of
    the generic `Button` class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`@`符号之前的部分指定了新的类名，后面跟着我们要扩展的控件类型（在Python中，我们会说`class RobotoButton(Button):`），然后可以使用这个结果类代替通用的`Button`类：'
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The use of class rules allows us to reduce the number of recurrent lines in
    the `clock.kv` file, and also provide a consistent way of tweaking similar widgets
    using class definitions. Next, let's use this feature to customize all the buttons.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类规则允许我们在`clock.kv`文件中减少重复行的数量，并提供一种一致的方式来使用类定义调整类似的控件。接下来，让我们使用这个功能来自定义所有按钮。
- en: Styling buttons
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮样式
- en: One of the darker corners of the flat UI paradigm is the look of clickable elements,
    like that of buttons; there is no universally accepted way of styling them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 平面UI范式的一个较暗的角落是可点击元素的外观，例如按钮；没有普遍接受的方式来设计它们。
- en: For example, the Modern UI style (previously called Metro, as seen in Windows
    8) is very radical, with clickable elements that look mostly like flat-colored
    rectangles with little or no distinctive graphical features. Other vendors, such
    as Apple, use vibrant gradients; there is a trend of also adding rounded corners,
    especially in web design since CSS3 provides a special-case syntax for just that.
    Subtle shadows, while considered heresy by some, aren't unheard of either.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现代UI风格（以前称为Metro，如Windows 8所示）非常激进，可点击元素看起来主要是单色矩形，几乎没有或没有明显的图形特征。其他供应商，如苹果，使用鲜艳的渐变；添加圆角的趋势也很明显，尤其是在网页设计中，因为CSS3提供了专门用于此的语法。微妙的阴影，虽然有些人认为这是异端，但也不是闻所未闻。
- en: Kivy is flexible in this regard. The framework does not impose any restrictions
    on visuals and provides a number of useful features to implement any design you
    like. One of the utilities that we will discuss next is 9-patch image scaling,
    which is used to style buttons and similar widgets that may have borders.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，Kivy非常灵活。该框架不对视觉施加任何限制，并提供了许多有用的功能来实现您喜欢的任何设计。我们接下来要讨论的一个实用功能是9-patch图像缩放，它用于设计可能具有边框的按钮和类似控件。
- en: 9-patch scaling
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9-patch 缩放
- en: 'The motivation for a good scaling algorithm is simple: it''s almost impossible
    to provide pixel-perfect graphics for every button, especially for the problematic
    ones that contain (varying amounts of) text. Scaling images uniformly is simple
    to implement but yields results that are mediocre at best, partly because of the
    aspect ratio distortion.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的缩放算法的动机很简单：几乎不可能为每个按钮提供像素完美的图形，尤其是对于包含（不同数量的）文本的问题按钮。均匀缩放图像很简单实现，但结果最多是平庸的，部分原因是由于长宽比失真。
- en: 'Non-uniform 9-patch scaling, on the other hand, produces uncompromising quality.
    The idea is to split the image into static and scalable parts. The following image
    is a hypothetical scalable button. The middle part (shown in yellow) is the working
    area, and everything else is a border:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，非均匀的9-patch缩放产生了无妥协的质量。想法是将图像分成静态和可缩放的部分。以下图像是一个假设的可缩放按钮。中间部分（以黄色显示）是工作区域，其余部分都是边框：
- en: '![9-patch scaling](img/7849OS_01_05.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![9-patch 缩放](img/7849OS_01_05.jpg)'
- en: 'The red zones can be stretched in one dimension, while the blue zones (corners)
    are always left intact. This is evident from the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 红色区域可以在一个维度上拉伸，而蓝色区域（角落）始终保持完整。这可以从以下屏幕截图中看出：
- en: '![9-patch scaling](img/7849OS_01_06.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![9-patch 缩放](img/7849OS_01_06.jpg)'
- en: Corners, shown in blue, are fully static and may contain virtually anything.
    Borders, shown in red, are scalable in one dimension (top and bottom sides can
    be stretched horizontally, and left and right sides can be stretched vertically).
    The only part of the image that will be uniformly resized is the inner rectangle,
    the working area, shown in yellow; it is therefore common to paint it with a flat
    color. It will also contain text that's assigned to the button, if any.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色显示的角是完全静态的，可能包含几乎所有内容。红色显示的边框在一维（顶部和底部边可以水平拉伸，左侧和右侧边可以垂直拉伸）上是可伸缩的。唯一将均匀缩放的图像部分是内矩形，即工作区域，黄色显示；因此，通常会用单色来绘制它。如果有的话，它还将包含分配给按钮的文本。
- en: Using 9-patch images
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 9-patch 图像
- en: 'For this tutorial, we will use a simple flat button with a 1-pixel border.
    We can reuse this texture for all buttons or choose a different one, for example,
    for the Reset button. A button texture for the normal state with flat color and
    1-pixel border is shown as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将使用一个简单的平面按钮，带有 1 像素的边框。我们可以为所有按钮重用这个纹理，或者选择不同的纹理，例如用于重置按钮。以下是一个正常状态下的按钮纹理，具有平面颜色和
    1 像素边框：
- en: '![Using 9-patch images](img/7849OS_01_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![使用 9-patch 图像](img/7849OS_01_07.jpg)'
- en: 'The corresponding texture for the pressed state—an inversion of the preceding
    image—is shown as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于按下状态的纹理——即前一个图像的反转——如下所示：
- en: '![Using 9-patch images](img/7849OS_01_08.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![使用 9-patch 图像](img/7849OS_01_08.jpg)'
- en: 'Now, to apply the 9-patch magic, we need to tell Kivy the size of borders that
    have limited scalability, as discussed previously (the image will be scaled uniformly
    by default). Let''s revisit the `clock.kv` file and add the following properties:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了应用 9-patch 魔法，我们需要告诉 Kivy 具有限制伸缩性的边框的大小，如前所述（默认情况下，图像将均匀缩放）。让我们回顾一下 `clock.kv`
    文件，并添加以下属性：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `border` property values are ordered just like in CSS: top, right, bottom,
    and left (that is, clockwise starting from the top). Unlike CSS, we can''t supply
    just one value for all sides; at least in the current Kivy version (1.8), the
    notation `border: 2` results in error.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`border` 属性的值排序与 CSS 中的顺序相同：上、右、下、左（即从上开始按顺时针方向）。与 CSS 不同，我们不能为所有边提供单个值；至少在当前
    Kivy 版本（1.8）中，`border: 2` 的表示法会导致错误。'
- en: Tip
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Probably the shortest way of setting all the borders to the same value is the
    Python syntax `border: [2] * 4`, which means take a list with a single element,
    `2`, and repeat it four times.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '将所有边框设置为相同值的最短方法是 Python 语法 `border: [2] * 4`，这意味着取一个包含单个元素 `2` 的列表，并重复四次。'
- en: 'Also note that while the visible border is just one pixel wide, we''re assigning
    the `border` property of customized buttons to `2`. This is due to the texture-stretching
    behavior of the renderer: if pixel colors from both sides of the "cut line" don''t
    match, the result will be a gradient, and we want solid color.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，虽然可见的边框只有一像素宽，但我们将自定义按钮的 `border` 属性分配为 `2`。这是由于渲染器的纹理拉伸行为：如果“切割线”两边的像素颜色不匹配，结果将是一个渐变，而我们希望是纯色。
- en: 'In the class rules overview, we mentioned that the property declared on an
    instance of a widget takes precedence over the class rule''s property with the
    same name. This can be used to selectively override `background_*`, `border` or
    any other attribute, for example, assigning another texture while reusing the
    border width definition:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在类规则概述中，我们提到在部件实例上声明的属性会优先于具有相同名称的类规则属性。这可以用来选择性地覆盖 `background_*`、`border`
    或任何其他属性，例如，在重用边框宽度定义的同时分配另一个纹理：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now our buttons are stylized, but they still don't do anything. The next step
    towards our goal is making the stopwatch work.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的按钮已经具有样式，但它们仍然没有任何功能。我们朝着目标迈出的下一步是使计时器工作。
- en: Counting time
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时
- en: Although both stopwatch and the regular clock ultimately just display time,
    they are completely different in terms of functionality. Wall clock is a strictly
    increasing monotonic function, while stopwatch time can be paused and reset, decreasing
    the counter. More practically, the difference is that the operating system readily
    exposes its internal wall clock to Python, both directly as a `datetime` object
    and transparently in the case of the `strftime()` function. The latter can be
    called without a `datetime` argument to format the current time, which is exactly
    what we need for a wall clock display.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然计时器和常规时钟最终都只是显示时间，但在功能上它们完全不同。墙钟是一个严格递增的单调函数，而计时器时间可以被暂停和重置，减少计数器。更实际地说，区别在于操作系统可以轻松地将其内部墙钟暴露给Python，无论是直接作为`datetime`对象，还是在`strftime()`函数的情况下透明地暴露。后者可以在没有`datetime`参数的情况下调用，以格式化当前时间，这正是我们需要用于墙钟显示的。
- en: 'For the task of creating a stopwatch, we will need to build our own, non-monotonic
    time counter first. This is easily achieved without using Python''s time functions
    altogether, thanks to Kivy''s `Clock.schedule_interval` event handler that accepts
    the time passed between calls as a parameter. This is just what the `nap` parameter
    does in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建计时器的任务，我们首先需要构建自己的非单调时间计数器。这很容易实现，因为我们不需要使用Python的时间函数，多亏了Kivy的`Clock.schedule_interval`事件处理器，它接受调用之间的时间差作为参数。这正是以下代码中`nap`参数的作用：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Time is measured in seconds, that is, if the app is running at 60 fps and calls
    our function every frame, the average nap will be *60*^(*−1*)*= 0.016(6)*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 时间以秒为单位，也就是说，如果应用程序以60 fps运行并且每帧调用我们的函数，平均睡眠时间将是*60*^(*−1*)* = 0.016(6)*。
- en: 'With this parameter in place, keeping track of the time passed is simple and
    can be achieved with a simple increment:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此参数后，跟踪经过的时间变得简单，可以通过简单的增量来实现：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This timer we just created isn't, by definition, a stopwatch since right now,
    there is no way for the user to actually stop it. However, let's update the display
    with the incrementing time first so that we can see the effect of controls immediately
    when implementing them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的这个计时器，按照定义并不是一个计时器，因为现在用户实际上无法停止它。然而，让我们首先更新显示以递增的时间，这样我们就可以在实现它们时立即看到控制的效果。
- en: Formatting the time for stopwatch
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化计时器的时间
- en: For the main time display, formatting is easy because the standard library function
    `strftime` provides us with a number of readily available primitives to convert
    a `datetime` object into a readable string representation, according to the provided
    format string.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主要的时间显示，格式化很简单，因为标准库函数`strftime`为我们提供了一系列现成的原语，可以将`datetime`对象转换为可读的字符串表示，根据提供的格式字符串。
- en: 'This function has a number of limitations:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有一些限制：
- en: It only accepts Python `datetime` objects (while for the stopwatch, we only
    have a floating-point number of seconds passed, `sw_seconds`)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只接受Python `datetime`对象（而计时器我们只有经过的浮点秒数`sw_seconds`）
- en: It has no formatting directive for a decimal fraction of seconds
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有为秒的小数部分提供格式化指令
- en: 'The former `datetime` limitation can be easily circumvented: we could cast
    our `sw_seconds` variable to `datetime`. But the latter deficiency makes this
    unnecessary, as we want to end our notation with fractions of a second (exact
    to 0.01 sec), so `strftime` formatting just won''t cut it. Hence, we implement
    our own time formatting.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`datetime`限制可以很容易地规避：我们可以将我们的`sw_seconds`变量转换为`datetime`。但后者的不足使得这变得不必要，因为我们希望我们的表示以秒的分数结束（精确到0.01秒），所以`strftime`格式化就不够了。因此，我们实现自己的时间格式化。
- en: Computing values
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算值
- en: 'First, we need to compute the necessary values: minutes, seconds, and fractions
    of a second. The math is easy; here''s the one-liner for minutes and seconds:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要计算必要的值：分钟、秒和秒的分数。数学很简单；以下是计算分钟和秒的一行代码：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note the use of the `divmod` function. This is a shorthand for the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`divmod`函数。这是一个简写，相当于以下内容：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While being more concise, the `divmod` version should also perform better on
    most Python interpreters, as it performs the division just once. On today's machines,
    the floating-point division is quite effective, but if we run a whole lot of such
    operations every frame, like in a video game or simulation, the CPU time will
    quickly add up.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然更简洁，但`divmod`版本在大多数Python解释器上也应该表现得更好，因为它只执行一次除法。在今天的机器上，浮点除法非常有效，但如果我们在每一帧运行大量此类操作，如视频游戏或模拟，CPU时间将迅速增加。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Generally, the author tends to disagree with the oft-chanted mantra about premature
    optimization being evil; many bad practices that lead to choppy and substandard
    performance can and should be easily avoided without compromising on code quality,
    and not doing so is by all means premature pessimization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，作者倾向于不同意关于过早优化是邪恶的常见格言；许多导致性能不佳和标准不高的不良做法可以并且应该很容易避免，而不会影响代码质量，不这样做无疑是过早的悲观化。
- en: 'Also note that both `minutes` and `seconds` values are still floating-point,
    so we will need to convert them to integers before we print them: `int(minutes)`
    and `int(seconds)`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`minutes` 和 `seconds` 的值仍然是浮点数，因此在我们打印之前需要将它们转换为整数：`int(minutes)` 和 `int(seconds)`。
- en: 'Now all that''s left is hundredths of seconds; we can compute them like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下百分之一秒；我们可以这样计算它们：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Putting a stopwatch in place
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 放置停表
- en: 'We have all the values; let''s join them together. Formatting strings in Python
    is quite a common task, and contrary to The Zen of Python commandment that reads,
    "There should be one—and preferably only one—obvious way to do it" ([https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/)),
    there are several common idioms for string formatting. We will use one of the
    simplest, operator %, which is somewhat similar to the `sprintf()` function commonly
    found in other programming languages:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了所有值；让我们将它们组合起来。在 Python 中格式化字符串是一项相当常见的任务，与 Python 的 Zen 命令“应该有一个——最好是只有一个——明显的做法来做这件事”([https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/))相反，存在几种常见的字符串格式化惯用法。我们将使用其中最简单的一种，即操作符
    %，它在某种程度上类似于在其他编程语言中常见的 `sprintf()` 函数：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since we have fractions of a second now, the refresh frequency of 1 fps that
    we used earlier isn''t sufficient anymore. Let''s set it to 0 instead so that
    our `update_time` function will be called for every frame:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了秒的分数，之前使用的 1 fps 刷新频率已经不再足够。让我们将其设置为 0，这样 `update_time` 函数就会在每一帧被调用：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Today, most displays run at a refresh rate of 60 fps, while our value is exact
    to 1/100 sec, that is, changes 100 times per second. While we could have attempted
    to run our function at exactly 100 fps, there is absolutely no reason to do it:
    for users, it isn''t possible to see the difference on commonly available hardware,
    as the display will still update no more than 60 times per second anyway.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，大多数显示器以 60 fps 的刷新率运行，而我们的值精确到 1/100 秒，即每秒变化 100 次。虽然我们可以尝试以正好 100 fps 的速度运行我们的函数，但完全没有必要这样做：对于用户来说，在常见的硬件上不可能看到差异，因为显示器的更新频率最多也只有每秒
    60 次。
- en: That said, most of the time your code should work independently of a frame rate,
    as it relies on the user's hardware, and there is no way to predict what machine
    your application will end up on. Even today's smartphones have wildly different
    system specs and performance, let alone laptops and desktop computers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，大多数时候你的代码应该独立于帧率工作，因为它依赖于用户的硬件，而且无法预测应用程序最终会运行在什么机器上。即使今天的智能手机也有截然不同的系统规格和性能，更不用说笔记本电脑和台式计算机了。
- en: And that's it; if we run the application now, we'll see an incrementing counter.
    It lacks interactivity yet, and this will be our next target.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；如果我们现在运行应用程序，我们会看到一个递增的计数器。它目前还没有交互性，这将是我们的下一个目标。
- en: Stopwatch controls
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停表控制
- en: 'Controlling the application by the means of button press events is very easy.
    All that we need to do for this to work is use the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按钮按下事件控制应用程序非常简单。我们只需要使用以下代码来实现这一点：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first event handler is for the **Start** and **Stop** buttons. It changes
    the state (`sw_started`) and the button caption. The second handler reverts everything
    to the initial state.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个事件处理程序是为 **开始** 和 **停止** 按钮的。它改变状态（`sw_started`）和按钮标题。第二个处理程序将一切恢复到初始状态。
- en: 'We also need to add the state property to keep track of whether the stopwatch
    is running or paused:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加状态属性来跟踪停表是正在运行还是暂停：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We change the `update_clock` function so that it increments `sw_seconds` only
    if the stopwatch is started, that is, `sw_started` is set to `True`. Initially,
    the stopwatch isn't started.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改 `update_clock` 函数，使其仅在停表开始时增加 `sw_seconds`，即 `sw_started` 被设置为 `True`。最初，停表没有开始。
- en: 'In the `clock.kv` file, we bind these new methods to `on_press` events:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `clock.kv` 文件中，我们将这些新方法绑定到 `on_press` 事件：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In Kivy language, we have several context-sensitive references at our disposal.
    They are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kivy 语言中，我们有几个上下文相关的引用可供使用。它们如下：
- en: '`self`: This always refers to the current widget;'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self`：这始终指当前小部件；'
- en: '`root`: This is the outermost widget of a given scope;'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`：这是给定作用域的最外层小部件；'
- en: '`app`: This is the application class instance.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`：这是应用程序类实例。'
- en: As you can see, implementing event handling for buttons isn't hard at all. At
    this point, our app provides interaction with the stopwatch, allowing the user
    to start, stop, and reset it. For the purposes of this tutorial, we're done.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实现按钮的事件处理并不困难。到目前为止，我们的应用程序提供了与计时器的交互，使用户能够启动、停止和重置它。为了本教程的目的，我们已经完成了。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a functional Kivy app, ready to be deployed to, for
    example, Google Play or another app store for public use. This requires a bit
    of extra work and the process of packaging is platform-specific, but the hardest
    part—programming—is over.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个功能性的Kivy应用程序，准备部署到例如Google Play或另一个应用商店供公众使用。这需要一些额外的工作，打包过程是平台特定的，但最困难的部分——编程——已经完成。
- en: With the Clock app, we managed to showcase many areas of the Kivy application's
    development cycle without making the code unnecessarily lengthy or convoluted.
    Keeping the code short and concise is a major feature of the framework because
    it allows us to experiment and iterate quickly. Being able to implement new bits
    of functionality with very little old code getting in the way is invaluable. Kivy
    surely lives up to its description as a library for rapid application development.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过时钟应用程序，我们成功地展示了Kivy应用程序开发周期的许多方面，而没有使代码变得不必要地冗长或复杂。保持代码简短和简洁是框架的一个主要特点，因为它使我们能够快速地进行实验和迭代。能够以极少的旧代码阻碍，实现新的功能部分是无价的。Kivy确实符合其作为快速应用程序开发库的描述。
- en: One general principle that we will encounter throughout the book (and Kivy development
    at large) is that neither our program nor Kivy exist in the void; we always have
    the whole platform at our disposal, consisting of a rich Python standard library,
    a lot of other libraries available from the Python *cheese shop*—the **Python
    Package Index** (**PyPI**) located at [http://pypi.python.org](http://pypi.python.org)—and
    elsewhere, and the underlying operating system services.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书（以及Kivy开发总体上）中，我们将遇到的一个普遍原则是，我们的程序和Kivy都不是孤立存在的；我们始终拥有整个平台可供使用，包括丰富的Python标准库，以及从Python“奶酪店”——位于[http://pypi.python.org](http://pypi.python.org)的**Python包索引**（**PyPI**）以及其他地方可用的许多其他库，以及底层的操作系统服务。
- en: We can also retool many web-development-oriented assets easily, reusing fonts,
    colors, and shapes from CSS frameworks, such as Bootstrap. And by all means take
    a look at Google's *Material design principles*—this isn't just a collection of
    design assets, but a complete field guide that allows us to achieve a consistent
    and good-looking UI without sacrificing the identity or "personality" of our application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以轻松地重新配置许多面向Web开发的资产，重用来自CSS框架（如Bootstrap）的字体、颜色和形状。并且无论如何，都应该看看谷歌的*材料设计原则*——这不仅仅是一组设计资产，而是一本完整的指南，它使我们能够在不牺牲应用程序的个性或“性格”的情况下，实现一致且美观的用户界面。
- en: This is, of course, only the beginning. Many features that were briefly discussed
    in this chapter will be explored more in-depth later in this book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这仅仅是开始。本书中本章简要讨论的许多功能将在后面的章节中更深入地探讨。
