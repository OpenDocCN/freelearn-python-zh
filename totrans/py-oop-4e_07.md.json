["```py\n>>> o = object()\n>>> o.x = 5\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'object' object has no attribute 'x' \n```", "```py\n>>> class MyObject: \n...     pass \n```", "```py\n>>> m = MyObject()\n>>> m.x = \"hello\"\n>>> m.x\n'hello' \n```", "```py\n>>> stock = \"AAPL\", 123.52, 53.15, 137.98\n>>> stock2 = (\"AAPL\", 123.52, 53.15, 137.98) \n```", "```py\n>>> import datetime\n>>> def middle(stock, date):\n...     symbol, current, high, low = stock\n...     return (((high + low) / 2), date)\n>>> middle((\"AAPL\", 123.52, 53.15, 137.98), datetime.date(2020, 12, 4))\n(95.565, datetime.date(2020, 12, 4)) \n```", "```py\n>>> a = 42,\n>>> a\n(42,) \n```", "```py\n>>> b = (42, 3.14), (2.718, 2.618), \n>>> b\n((42, 3.14), (2.718, 2.618)) \n```", "```py\n>>> s = \"AAPL\", 132.76, 134.80, 130.53\n>>> high = s[2]\n>>> high\n134.8 \n```", "```py\n>>> s[1:3]\n(132.76, 134.8) \n```", "```py\n>>> def high(stock):\n...     symbol, current, high, low = stock\n...     return high\n>>> high(s)\n134.8 \n```", "```py\n>>> from typing import NamedTuple\n>>> class Stock(NamedTuple):\n...     symbol: str\n...     current: float\n...     high: float\n...     low: float \n```", "```py\n>>> Stock(\"AAPL\", 123.52, 137.98, 53.15) \n```", "```py\n>>> s2 = Stock(\"AAPL\", 123.52, high=137.98, low=53.15) \n```", "```py\n>>> s.high\n137.98\n>>> s[2]\n137.98\n>>> symbol, current, high, low = s\n>>> current\n123.52 \n```", "```py\n>>> s.current = 122.25\nTraceback (most recent call last):\n  ...\n  File \"<doctest examples.md[27]>\", line 1, in <module>\n    s2.current = 122.25\nAttributeError: can't set attribute \n```", "```py\n>>> t = (\"Relayer\", [\"Gates of Delirium\", \"Sound Chaser\"])\n>>> t[1].append(\"To Be Over\")\n>>> t\n('Relayer', ['Gates of Delirium', 'Sound Chaser', 'To Be Over']) \n```", "```py\n>>> hash(t)\nTraceback (most recent call last):\n  ...\n  File \"<doctest examples.md[31]>\", line 1, in <module>\n    hash(t)\nTypeError: unhashable type: 'list' \n```", "```py\n>>> class Stock(NamedTuple):\n...     symbol: str\n...     current: float\n...     high: float\n...     low: float\n...     @property\n...     def middle(self) -> float:\n...         return (self.high + self.low)/2 \n```", "```py\n>>> s = Stock(\"AAPL\", 123.52, 137.98, 53.15)\n>>> s.middle\n95.565 \n```", "```py\n>>> from dataclasses import dataclass\n>>> @dataclass\n... class Stock:\n...     symbol: str\n...     current: float\n...     high: float\n...     low: float \n```", "```py\n>>> s = Stock(\"AAPL\", 123.52, 137.98, 53.15) \n```", "```py\n>>> s\nStock(symbol='AAPL', current=123.52, high=137.98, low=53.15)\n>>> s.current\n123.52\n>>> s.current = 122.25\n>>> s\nStock(symbol='AAPL', current=122.25, high=137.98, low=53.15) \n```", "```py\n>>> s.unexpected_attribute = 'allowed'\n>>> s.unexpected_attribute\n'allowed' \n```", "```py\n>>> class StockOrdinary:\n...     def __init__(self, name: str, current: float, high: float, low: ... float) -> None:\n...         self.name = name\n...         self.current = current\n...         self.high = high\n...         self.low = low\n>>> s_ord = StockOrdinary(\"AAPL\", 123.52, 137.98, 53.15) \n```", "```py\n>>> s_ord\n<__main__.StockOrdinary object at 0x7fb833c63f10>\n>>> s_ord_2 = StockOrdinary(\"AAPL\", 123.52, 137.98, 53.15)\n>>> s_ord == s_ord_2\nFalse \n```", "```py\n>>> stock2 = Stock(symbol='AAPL', current=122.25, high=137.98, low=53.15)\n>>> s == stock2\nTrue \n```", "```py\n@dataclass\nclass StockDefaults:\n    name: str\n    current: float = 0.0\n    high: float = 0.0\n    low: float = 0.0 \n```", "```py\n>>> StockDefaults(\"GOOG\")\nStockDefaults(name='GOOG', current=0.0, high=0.0, low=0.0)\n>>> StockDefaults(\"GOOG\", 1826.77, 1847.20, 1013.54)\nStockDefaults(name='GOOG', current=1826.77, high=1847.2, low=1013.54) \n```", "```py\n@dataclass(order=True)\nclass StockOrdered:\n    name: str\n    current: float = 0.0\n    high: float = 0.0\n    low: float = 0.0 \n```", "```py\n>>> stock_ordered1 = StockOrdered(\"GOOG\", 1826.77, 1847.20, 1013.54)\n>>> stock_ordered2 = StockOrdered(\"GOOG\")\n>>> stock_ordered3 = StockOrdered(\"GOOG\", 1728.28, high=1733.18, low=1666.33)\n>>> stock_ordered1 < stock_ordered2\nFalse\n>>> stock_ordered1 > stock_ordered2\nTrue\n>>> from pprint import pprint\n>>> pprint(sorted([stock_ordered1, stock_ordered2, stock_ordered3]))\n[StockOrdered(name='GOOG', current=0.0, high=0.0, low=0.0),\n StockOrdered(name='GOOG', current=1728.28, high=1733.18, low=1666.33),\n StockOrdered(name='GOOG', current=1826.77, high=1847.2, low=1013.54)] \n```", "```py\n>>> stocks = {\n...     \"GOOG\": (1235.20, 1242.54, 1231.06),\n...     \"MSFT\": (110.41, 110.45, 109.84),\n... } \n```", "```py\n>>> stocks[\"GOOG\"]\n(1235.2, 1242.54, 1231.06)\n>>> stocks[\"RIMM\"]\nTraceback (most recent call last):\n  ...\n  File \"<doctest examples.md[56]>\", line 1, in <module>\n    stocks.get(\"RIMM\", \"NOT FOUND\")\nKeyError: 'RIMM' \n```", "```py\n>>> print(stocks.get(\"RIMM\"))\nNone\n>>> stocks.get(\"RIMM\", \"NOT FOUND\")\n'NOT FOUND' \n```", "```py\n>>> stocks.setdefault(\"GOOG\", \"INVALID\")\n(1235.2, 1242.54, 1231.06)\n>>> stocks.setdefault(\"BB\", (10.87, 10.76, 10.90))\n(10.87, 10.76, 10.9)\n>>> stocks[\"BB\"]\n(10.87, 10.76, 10.9) \n```", "```py\n>>> for stock, values in stocks.items():\n...     print(f\"{stock} last value is {values[0]}\")\n...\nGOOG last value is 1235.2\nMSFT last value is 110.41\nBB last value is 10.87 \n```", "```py\n>>> stocks[\"GOOG\"] = (1245.21, 1252.64, 1245.18)\n>>> stocks['GOOG']\n(1245.21, 1252.64, 1245.18) \n```", "```py\n>>> random_keys = {} \n>>> random_keys[\"astring\"] = \"somestring\" \n>>> random_keys[5] = \"aninteger\" \n>>> random_keys[25.2] = \"floats work too\" \n>>> random_keys[(\"abc\", 123)] = \"so do tuples\" \n\n>>> class AnObject: \n...     def __init__(self, avalue): \n...         self.avalue = avalue \n>>> my_object = AnObject(14) \n>>> random_keys[my_object] = \"We can even store objects\" \n>>> my_object.avalue = 12\n>>> random_keys[[1,2,3]] = \"we can't use lists as keys\" \nTraceback (most recent call last):\n  ...\n  File \"<doctest examples.md[72]>\", line 1, in <module>\n    random_keys[[1,2,3]] = \"we can't use lists as keys\"\nTypeError: unhashable type: 'list' \n```", "```py\n>>> for key in random_keys: \n...     print(f\"{key!r} has value {random_keys[key]!r}\") \n'astring' has value 'somestring'\n5 has value 'aninteger'\n25.2 has value 'floats work too'\n('abc', 123) has value 'so do tuples'\n<__main__.AnObject object at ...> has value 'We can even store objects' \n```", "```py\n>>> x = 2020\n>>> y = 2305843009213695971\n>>> hash(x) == hash(y)\nTrue\n>>> x == y\nFalse \n```", "```py\nfrom __future__ import annotations\ndef letter_frequency(sentence: str) -> dict[str, int]:\n    frequencies: dict[str, int] = {}\n    for letter in sentence:\n        frequency = frequencies.setdefault(letter, 0)\n        frequencies[letter] = frequency + 1\n    return frequencies \n```", "```py\nfrom collections import defaultdict\ndef letter_frequency_2(sentence: str) -> defaultdict[str, int]:\n    frequencies: defaultdict[str, int] = defaultdict(int)\n    for letter in sentence:\n        frequencies[letter] += 1\n    return frequencies \n```", "```py\n>>> from dataclasses import dataclass\n>>> @dataclass\n... class Prices:\n...     current: float = 0.0\n...     high: float = 0.0\n...     low: float = 0.0\n...\n>>> Prices() \nPrices(current=0.0, high=0.0, low=0.0) \n```", "```py\n>>> portfolio = collections.defaultdict(Prices)\n>>> portfolio[\"GOOG\"]\nPrices(current=0.0, high=0.0, low=0.0)\n>>> portfolio[\"AAPL\"] = Prices(current=122.25, high=137.98, low=53.15) \n```", "```py\n>>> from pprint import pprint\n>>> pprint(portfolio)\ndefaultdict(<class 'dc_stocks.Prices'>,\n            {'AAPL': Prices(current=122.25, high=137.98, low=53.15),\n             'GOOG': Prices(current=0.0, high=0.0, low=0.0)}) \n```", "```py\n>>> def make_defaultdict():\n...     return collections.defaultdict(Prices) \n```", "```py\n>>> by_month = collections.defaultdict(\n...     lambda: collections.defaultdict(Prices)\n... ) \n```", "```py\n>>> by_month[\"APPL\"][\"Jan\"] = Prices(current=122.25, high=137.98, low=53.15) \n```", "```py\nfrom collections import Counter\ndef letter_frequency_3(sentence: str) -> Counter[str]:\n    return Counter(sentence) \n```", "```py\n>>> import collections\n>>> responses = [\n...     \"vanilla\", \n...     \"chocolate\", \n...     \"vanilla\", \n...     \"vanilla\", \n...     \"caramel\", \n...     \"strawberry\", \n...     \"vanilla\" \n... ]\n>>> favorites = collections.Counter(responses).most_common(1)\n>>> name, frequency = favorites[0]\n>>> name\n'vanilla' \n```", "```py\nfrom __future__ import annotations\nimport string\nCHARACTERS = list(string.ascii_letters) + [\" \"]\ndef letter_frequency(sentence: str) -> list[tuple[str, int]]:\n    frequencies = [(c, 0) for c in CHARACTERS]\n    for letter in sentence:\n        index = CHARACTERS.index(letter)\n        frequencies[index] = (letter, frequencies[index][1] + 1)\n    non_zero = [\n        (letter, count) \n        for letter, count in frequencies if count > 0\n    ]\n    return non_zero \n```", "```py\nfrom typing import Optional, cast, Any\nfrom dataclasses import dataclass\nimport datetime\n@dataclass(frozen=True)\nclass MultiItem:\n    data_source: str\n    timestamp: Optional[float]\n    creation_date: Optional[str]\n    name: str\n    owner_etc: str\n    def __lt__(self, other: Any) -> bool:\n        if self.data_source == \"Local\":\n            self_datetime = datetime.datetime.fromtimestamp(\n                cast(float, self.timestamp)\n            )\n        else:\n            self_datetime = datetime.datetime.fromisoformat(\n                cast(str, self.creation_date)\n            )\n        if other.data_source == \"Local\":\n            other_datetime = datetime.datetime.fromtimestamp(\n                cast(float, other.timestamp)\n            )\n        else:\n            other_datetime = datetime.datetime.fromisoformat(\n                cast(str, other.creation_date)\n            )\n        return self_datetime < other_datetime \n```", "```py\n>>> mi_0 = MultiItem(\"Local\", 1607280522.68012, None, \"Some File\", \"etc. 0\")\n>>> mi_1 = MultiItem(\"Remote\", None, \"2020-12-06T13:47:52.849153\", \"Another File\", \"etc. 1\")\n>>> mi_2 = MultiItem(\"Local\", 1579373292.452993, None, \"This File\", \"etc. 2\")\n>>> mi_3 = MultiItem(\"Remote\", None, \"2020-01-18T13:48:12.452993\", \"That File\", \"etc. 3\")\n>>> file_list = [mi_0, mi_1, mi_2, mi_3]\n>>> file_list.sort()\n>>> from pprint import pprint\n>>> pprint(file_list)\n[MultiItem(data_source='Local', timestamp=1579373292.452993, creation_date=None, name='This File', owner_etc='etc. 2'),\n MultiItem(data_source='Remote', timestamp=None, creation_date='2020-01-18T13:48:12.452993', name='That File', owner_etc='etc. 3'),\n MultiItem(data_source='Remote', timestamp=None, creation_date='2020-12-06T13:47:52.849153', name='Another File', owner_etc='etc. 1'),\n MultiItem(data_source='Local', timestamp=1607280522.68012, creation_date=None, name='Some File', owner_etc='etc. 0')] \n```", "```py\nfrom functools import total_ordering\nfrom dataclasses import dataclass\nfrom typing import Optional, cast\nimport datetime\n@total_ordering\n@dataclass(frozen=True)\nclass MultiItem:\n    data_source: str\n    timestamp: Optional[float]\n    creation_date: Optional[str]\n    name: str\n    owner_etc: str\n    def __lt__(self, other: \"MultiItem\") -> bool:\n        Exercise: rewrite this to follow the example of __eq__.\n    def __eq__(self, other: object) -> bool:\n        return self.datetime == cast(MultiItem, other).datetime\n    @property\n    def datetime(self) -> datetime.datetime:\n        if self.data_source == \"Local\":\n            return datetime.datetime.fromtimestamp(\n                cast(float, self.timestamp))\n        else:\n            return datetime.datetime.fromisoformat(\n                cast(str, self.creation_date)) \n```", "```py\n@dataclass(frozen=True)\nclass SimpleMultiItem:\n    data_source: str\n    timestamp: Optional[float]\n    creation_date: Optional[str]\n    name: str\n    owner_etc: str\ndef by_timestamp(item: SimpleMultiItem) -> datetime.datetime:\n    if item.data_source == \"Local\":\n        return datetime.datetime.fromtimestamp(\n            cast(float, item.timestamp))\n    elif item.data_source == \"Remote\":\n        return datetime.datetime.fromisoformat(\n            cast(str, item.creation_date))\n    else:\n        raise ValueError(f\"Unknown data_source in {item!r}\") \n```", "```py\n>>> file_list.sort(key=by_timestamp) \n```", "```py\n>>> file_list.sort(key=lambda item: item.name) \n```", "```py\n>>> import operator\n>>> file_list.sort(key=operator.attrgetter(\"name\")) \n```", "```py\n>>> song_library = [\n...     (\"Phantom Of The Opera\", \"Sarah Brightman\"),\n...     (\"Knocking On Heaven's Door\", \"Guns N' Roses\"),\n...     (\"Captain Nemo\", \"Sarah Brightman\"),\n...     (\"Patterns In The Ivy\", \"Opeth\"),\n...     (\"November Rain\", \"Guns N' Roses\"),\n...     (\"Beautiful\", \"Sarah Brightman\"),\n...     (\"Mal's Song\", \"Vixy and Tony\"),\n... ]\n>>> artists = set()\n>>> for song, artist in song_library:\n...     artists.add(artist) \n```", "```py\n{'Sarah Brightman', \"Guns N' Roses\", 'Vixy and Tony', 'Opeth'} \n```", "```py\n>>> \"Opeth\" in artists\nTrue\n>>> alphabetical = list(artists)\n>>> alphabetical.sort()\n>>> alphabetical\n[\"Guns N' Roses\", 'Opeth', 'Sarah Brightman', 'Vixy and Tony'] \n```", "```py\n>>> for artist in artists:\n...     print(f\"{artist} plays good music\")\n...\nSarah Brightman plays good music\nGuns N' Roses plays good music\nVixy and Tony play good music\nOpeth plays good music \n```", "```py\n>>> dusty_artists = {\n...     \"Sarah Brightman\",\n...     \"Guns N' Roses\",\n...     \"Opeth\",\n...     \"Vixy and Tony\",\n... }\n>>> steve_artists = {\"Yes\", \"Guns N' Roses\", \"Genesis\"} \n```", "```py\n>>> print(f\"All: {dusty_artists | steve_artists}\")\nAll: {'Genesis', \"Guns N' Roses\", 'Yes', 'Sarah Brightman', 'Opeth', 'Vixy and Tony'}\n>>> print(f\"Both: {dusty_artists.intersection(steve_artists)}\")\nBoth: {\"Guns N' Roses\"}\n>>> print(\n...    f\"Either but not both: {dusty_artists ^ steve_artists}\"\n... )\nEither but not both: {'Genesis', 'Sarah Brightman', 'Opeth', 'Yes', 'Vixy and Tony'} \n```", "```py\n>>> artists = {\"Guns N' Roses\", 'Vixy and Tony', 'Sarah Brightman', 'Opeth'}\n>>> bands = {\"Opeth\", \"Guns N' Roses\"}\n>>> artists.issuperset(bands)\nTrue\n>>> artists.issubset(bands)\nFalse\n>>> artists - bands\n{'Sarah Brightman', 'Vixy and Tony'}\n>>> bands.issuperset(artists)\nFalse\n>>> bands.issubset(artists)\nTrue\n>>> bands.difference(artists)\nset() \n```", "```py\nqueue starts empty\nAdd the base directory to the queue\nWhile the queue is not empty:\n    Pop the first item from the queue\n    If the item is a file:\n        Process the item\n    Else if the item is a directory:\n        For each sub-item in the directory:\n           Add this sub-item to the queue \n```", "```py\nclass ListQueue(List[Path]):\n    def put(self, item: Path) -> None:\n        self.append(item)\n    def get(self) -> Path:\n        return self.pop(0)\n    def empty(self) -> bool:\n        return len(self) == 0 \n```", "```py\nfrom typing import Deque\nclass DeQueue(Deque[Path]):\n    def put(self, item: Path) -> None:\n        self.append(item)\n    def get(self) -> Path:\n        return self.popleft()\n    def empty(self) -> bool:\n        return len(self) == 0 \n```", "```py\nimport queue\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    BaseQueue = queue.Queue[Path]  # for mypy.\nelse:\n    BaseQueue = queue.Queue  # used at runtime.\nclass ThreadQueue(BaseQueue):\n    pass \n```", "```py\nPathQueue = Union[ListQueue, DeQueue, ThreadQueue] \n```", "```py\nfrom dataclasses import dataclass, asdict\nfrom typing import Optional\n@dataclass\nclass Sample:\n    sepal_length: float\n    sepal_width: float\n    petal_length: float\n    petal_width: float \n```", "```py\n>>> from model import Sample\n>>> x = Sample(1, 2, 3, 4)\n>>> x\nSample(sepal_length=1, sepal_width=2, petal_length=3, petal_width=4) \n```", "```py\n@dataclass\nclass KnownSample(Sample):\n    species: str\n@dataclass\nclass TestingKnownSample(KnownSample):\n    classification: Optional[str] = None\n@dataclass\nclass TrainingKnownSample(KnownSample):\n    \"\"\"Note: no classification instance variable available.\"\"\"\n    pass \n```", "```py\n>>> from model import TrainingKnownSample\n>>> s1 = TrainingKnownSample(\n...     sepal_length=5.1, sepal_width=3.5, petal_length=1.4, \n...     petal_width=0.2, species=\"Iris-setosa\")\n>>> s1\nTrainingKnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa')\n# This is undesirable...\n>>> s1.classification = \"wrong\"\n>>> s1\nTrainingKnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa')\n>>> s1.classification\n'wrong' \n```", "```py\n@dataclass\nclass Hyperparameter:\n    \"\"\"A specific tuning parameter set with k and a distance algorithm\"\"\"\n    k: int\n    algorithm: Distance\n    data: weakref.ReferenceType[\"TrainingData\"]\n    def classify(self, sample: Sample) -> str:\n        \"\"\"The k-NN algorithm\"\"\"\n        ... \n```", "```py\n@dataclass(frozen=True)\nclass Sample:\n    sepal_length: float\n    sepal_width: float\n    petal_length: float\n    petal_width: float\n@dataclass(frozen=True)\nclass KnownSample(Sample):\n    species: str\n@dataclass\nclass TestingKnownSample:\n    sample: KnownSample\n    classification: Optional[str] = None\n@dataclass(frozen=True)\nclass TrainingKnownSample:\n    \"\"\"Cannot be classified.\"\"\"\n    sample: KnownSample \n```", "```py\n>>> from model_f import TrainingKnownSample, KnownSample\n>>> s1 = TrainingKnownSample(\n...     sample=KnownSample(\n...         sepal_length=5.1, sepal_width=3.5, \n...         petal_length=1.4, petal_width=0.2, species=\"Iris-setosa\"\n...     )\n... )\n>>> s1\nTrainingKnownSample(sample=KnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa')) \n```", "```py\n>>> s1.classification = \"wrong\"\nTraceback (most recent call last):\n... details omitted\ndataclasses.FrozenInstanceError: cannot assign to field 'classification' \n```", "```py\nclass Sample(NamedTuple):\n    sepal_length: float\n    sepal_width: float\n    petal_length: float\n    petal_width: float\nclass KnownSample(NamedTuple):\n    sample: Sample\n    species: str \n```", "```py\nclass TestingKnownSample:\n    def __init__(\n        self, sample: KnownSample, classification: Optional[str] = None\n    ) -> None:\n        self.sample = sample\n        self.classification = classification\n    def __repr__(self) -> str:\n        return (\n            f\"{self.__class__.__name__}(sample={self.sample!r},\" \n            f\"classification={self.classification!r})\"\n        )\nclass TrainingKnownSample(NamedTuple):\n    sample: KnownSample \n```", "```py\n>>> from model_t import TrainingKnownSample, KnownSample, Sample\n>>> s1 = TrainingKnownSample(\n...     sample=KnownSample(\n...         sample=Sample(sepal_length=5.1, sepal_width=3.5, \n...         petal_length=1.4, petal_width=0.2),\n...         species=\"Iris-setosa\"\n...     ),\n... )\n>>> s1\nTrainingKnownSample(sample=KnownSample(sample=Sample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2), species='Iris-setosa'))\n>>> s1.classification = \"wrong\"\nTraceback (most recent call last):\n...\nAttributeError: 'TrainingKnownSample' object has no attribute 'classification' \n```"]