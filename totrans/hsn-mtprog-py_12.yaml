- en: '*Chapter 9*: Understanding Code through Abstract Syntax Tree'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at what abstract syntax trees are and how to understand
    the syntax tree of each unit of the Python code we write.
  prefs: []
  type: TYPE_NORMAL
- en: Any programming language is designed with its own syntax, which is used by developers
    while coding in the language following specific syntax. The interpreter or compiler
    of a programming language interprets the syntax of the language and compiles or
    interprets the code and executes it to achieve the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, an `ast` that can be used to understand the abstract syntax of the
    code that we develop.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will look at understanding the syntax tree of some
    of the important code snippets that we developed in previous chapters, and we
    will also look at modifying or adding more information to the code through a few
    examples. We will be making use of abstract syntax trees throughout this chapter
    to perform an analysis of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be taking a look at the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the `ast` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting Python code with abstract syntax trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding abstract syntax trees with applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand the abstract syntax
    tree of Python code. You should also be able to inspect, parse, and modify the
    abstract syntax tree of source code through metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the ast library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the `ast` Python library, which can be imported
    from Python 3 to analyze the Python code written by developers. We can also use
    it to modify the code through its abstract syntax tree at a metaprogramming level
    rather than modifying the syntax of the code itself. This helps in understanding
    how the code is syntactically represented and how the syntax tree of the code
    can be used to modify its behavior without modifying the original source code.
    We will look at some of the important functions of the `ast` library, as those
    functions will be used throughout this chapter to understand the code from our
    core example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by importing the `ast` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we import the library, we can look at analyzing a piece of code using
    this library. We will now create a variable named `assignment` and assign a string
    format of the code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `assignment` variable appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be parsed into its corresponding nodes using the `parse`
    method of the `ast` library. We will now create a variable named `assign_tree`
    and store the parsed node of the lines of code stored under `assignment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the parsed node looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make use of another method called `dump` to print the tree structure
    of the node with each of its values and fields. This helps in debugging the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Example of an abstract syntax tree ](img/Figure_9.1_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Example of an abstract syntax tree
  prefs: []
  type: TYPE_NORMAL
- en: The `"product_name = 'Iphone X'"` code is broken down into multiple parts. The
    syntax of any code in Python is grammatically embedded into `Module` followed
    by `body`. We have assigned the `Iphone X` value to the `product_name` variable
    and so the code that performs a value assignment is identified by the `Assign`
    branch, which has attributes mapped with the corresponding ID, context, and value.
    This is an example of what a simple representation of a node would look like.
    For multiple lines of code with various other operations, the node will have multiple
    other branches in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start inspecting the Python code for a few examples of using abstract
    syntax trees in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Python code with abstract syntax trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review and understand the code for a simple arithmetic
    addition example, and we will also further look into parsing the code and modifying
    it using abstract syntax trees.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing simple code using ast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, let’s review simple code that adds two numbers, and let’s
    look at all the elements of the node, and also how the elements are organized
    in the tree. Let’s begin by writing code to assign two variables, `a` and `b`,
    with numerical values, and `c` as the sum of `a` and `b`. Finally, let’s print
    the `c` value. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now parse the preceding `addfunc` and store the node in another variable
    called `add_tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the parsed node is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The base element of the node is `Module`, and all the other lines of code are
    split into semantics that are stored within the module of the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the detailed tree representation in the following code by calling
    the `dump` method on the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The tree begins with `Module` as its base element, or the trunk followed by
    multiple branches. `Module` is followed by `body` as a list item that lists down
    all other elements of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `body`, there will be four list items that describe the operations of
    `addfunc`. The first one, which is also the first line of `addfunc`, is to assign
    the `Constant` value `1098` to a variable with a name whose id is `a` and the
    context of the value is `Store` since we are storing the value in the variable.
    Here is how it appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Code snippet output ](img/Figure_9.2_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the second line of `addfunc` is to store the `2032` value in the
    `b` variable, which is represented grammatically in the following list item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Code snippet output ](img/Figure_9.3_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'The third line of code in `addfunc` has the arithmetic operation of adding
    the two values stored in `a` and `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Code snippet output ](img/Figure_9.4_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code has an additional element, `BinOp`, followed by `left`, `op`,
    and `right` variables to indicate the left numerical value, addition operation,
    and right numerical value, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of the code in `addfunc` is the `Expr` expression element, which
    represents the printing of the `c` variable with a context value of `Load`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Code snippet output ](img/Figure_9.5_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute `addfunc`, we need to first compile the parsed tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Post-compilation, we should be able to execute the compiled tree, which results
    in the addition of `a` and `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we reviewed the abstract syntax tree of the simple arithmetic
    `add` function. In the following section, let’s look at modifying the code of
    the `add` function using metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying simple code using ast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let’s consider the example of `addfunc` from the preceding
    section and look at how to modify the code in the example through metaprogramming,
    without modifying the actual code. The operation performed by the code in `addfunc`
    is arithmetic addition. What if we want to perform arithmetic multiplication instead
    of addition and we don’t want the actual code to be modified? What if there are
    multiple locations where we want arithmetic addition to be replaced by arithmetic
    multiplication, and browsing through thousands of lines of code and modifying
    them is not a feasible option as it might impact or break something else in the
    code? In such scenarios, we can modify the node of the code using its syntax tree
    instead of modifying the actual code itself. To achieve this, let’s make use of
    the abstract syntax tree of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s reuse the `add_tree` parsed tree variable from the code in the preceding
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand which fields to modify, let’s look at the following representation
    of the node and look at each section of the node marked by an identifier. The
    elements of interest for this example are represented inside a box in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Parsed node of addfunc ](img/Figure_9.6_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Parsed node of addfunc
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify the add operation into a multiplication operation, the tree for this
    node traverses through `body` followed by its list item `2`, followed by the `value`
    field of the item, followed by the `op` field. The `Add()` operation of the `op`
    field will have to be modified into a multiplication operation to achieve our
    goal for this section. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code results in a change of the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The figure of the updated tree structure is represented as follows, with the
    `Add()` operation replaced by the `Mult()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Tree modified to perform multiplication ](img/Figure_9.7_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Tree modified to perform multiplication
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify whether the preceding modification on the tree node works, let’s
    compile the tree and execute it to check the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code should have ideally provided an output of `3130`,
    which is the addition of two numbers, `1098` and `2032`. But we have modified
    `ast` to perform multiplication instead and so it would result in the value, which
    is a product of the two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Thus the tree is now modified and can be compiled to achieve the desired result
    without modifying the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s proceed further to look at how to parse and understand
    the classes in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding abstract syntax trees with applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look into applying the concept of abstract syntax trees
    to our core example of *ABC Megamart* and explore how `ast` is defined in the
    classes, such as the `Branch` class and the `VegCounter` class of *ABC Megamart*.
    We will also look at modifying the behavior of these classes using `ast` at a
    metaprogramming level instead of modifying the actual source code of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ast of a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at understanding the abstract syntax tree of
    a class, which will help us in exploring how to modify the elements of a class
    through metaprogramming. We can try it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by creating a class with empty definitions and look at its abstract
    syntax tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s parse the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further look at the elements of the node and understand how the class
    is grammatically defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The structure of the node is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Code snippet output  ](img/Figure_9.8_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, we have `Module` followed by `body`, with `ClassDef`
    within the `body` element. This `ClassDef` has a `name` element followed by two
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s redefine this empty class definition with an attribute and a method along
    with a decorator and recheck the structure of the node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now parse `branch_code` in the following step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The structure of the `Branch` class in the form of an abstract syntax tree is
    as follows. We can see that the node starts with the `Module` element followed
    by `body`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `body`, we have a `ClassDef` element that contains the class name followed
    by its attributes, which include `branch_id` stored as a constant value followed
    by the `get_product` method with its arguments. Refer to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Code snippet output](img/Figure_9.9_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a `decorator` method loaded under `decorator_list` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Code snippet output ](img/Figure_9.10_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create an object for the class, the code for the object can also be parsed
    similarly to the preceding class example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The node of the object will have the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 Code snippet output ](img/Figure_9.11_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed the abstract syntax tree of a class to understand
    the various elements of its syntax. With this understanding, let’s look further
    into modifying the abstract syntax tree of a class from our core example, *ABC
    Megamart*.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the ast of a code block by parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let’s look at how to modify the attributes in the code of a
    class by using its abstract syntax tree instead of modifying the actual class
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider having developed a robust library with multiple classes and methods.
    A robust library definition may be too big to be disturbed or modified. Instead
    of modifying the source code, we can make changes to some specific attributes
    in the library without impacting the actual code, through metaprogramming. In
    such a scenario, modifying `ast` of the library would be a better way of making
    changes rather than impacting the source code of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will be following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be creating a `vegCounter` class and adding a `return_cart` method
    to return the items within the cart. We will also be creating an object for the
    class and calling the `return_cart` method on the object. Refer to the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s parse the code for `vegCounter` and look at the structure of the
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the node is as follows. There is a class definition followed
    by a function definition in `ast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Code snippet output](img/Figure_9.12_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output has the elements for the list item and the logic that
    reads items to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Code snippet output ](img/Figure_9.13_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output has the syntax for creating the object for the `VegCounter`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Code snippet output ](img/Figure_9.14_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output displays the elements that print the cart items by calling
    the `return_cart` method on a list of cart items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Code snippet output ](img/Figure_9.15_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Code snippet output
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now compile the abstract syntax tree and execute it to display the list
    of items added to the cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s navigate through the values in the cart items and look at the path
    of the second value in the `return_cart` method output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now change the second value of the cart item from `tomatoes` to `potatoes`
    by parsing through the node elements hierarchically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following output, let’s look at the updated value for the second item
    in the cart, which is modified without changing the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Modifying value within ast ](img/Figure_9.16_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Modifying value within ast
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now unparse the node using the `unparse` method in the `ast` library
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The modified source code now looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is one approach to modifying the Python source code using an abstract syntax
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s proceed with the next approach, where we will
    be transforming the nodes of the abstract syntax tree.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the ast of a code block by transforming nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at another approach to modifying the source code
    of a class by modifying the abstract syntax tree instead of changing the actual
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create the `VegCounter` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s create a variable named `cart` and add the function call on the
    object as a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parsing the preceding code provides the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – AST of the object variable ](img/Figure_9.17_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – AST of the object variable
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, instead of traversing through the structure of the node, we
    will be using `NodeTransformer` from the `ast` library to perform code transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The attributes of `NodeTransformer` are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Attributes of NodeTransformer ](img/Figure_9.18_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Attributes of NodeTransformer
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create a class named `ModifyVegCounter` inherited from the `NodeTransfomer`
    class. We will be redefining the `visit_Constant` method to modify the constant
    values of the cart items by adding a string prefix whenever the constant value
    occurs in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can make use of the `visit` method to visit the node and use the `dump`
    method to print the tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The transformed node looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Source code transformed with NodeTransformer ](img/Figure_9.19_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Source code transformed with NodeTransformer
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further unparse the code using the `ast` library’s `unparse` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the code is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is another example of how an abstract syntax tree can be used in metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the approach of transforming the nodes of an abstract
    syntax tree using the `NodeTransformer` method of the `ast` library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the concept of the abstract syntax tree
    by exploring the `ast` library in Python 3\. We also inspected Python code using
    abstract syntax trees. We understood the applications of abstract syntax trees
    by modifying the code at the node level using source code from our core example.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other chapters in this book, this chapter covered the concept of
    abstract syntax trees in metaprogramming. This also helps in understanding how
    to modify the behavior of Python objects externally without modifying the source
    code. Modifying the abstract syntax tree instead of the actual methods and attributes
    in the code helps migrate source code from different versions of Python or the
    application development platform conveniently without impacting the actual logic
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at the concept of **method resolution
    order** with some other interesting examples.
  prefs: []
  type: TYPE_NORMAL
