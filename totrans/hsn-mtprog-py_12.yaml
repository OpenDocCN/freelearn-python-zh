- en: '*Chapter 9*: Understanding Code through Abstract Syntax Tree'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：通过抽象语法树理解代码'
- en: In this chapter, we will look at what abstract syntax trees are and how to understand
    the syntax tree of each unit of the Python code we write.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨抽象语法树是什么，以及如何理解我们编写的 Python 代码中每个单元的语法树。
- en: Any programming language is designed with its own syntax, which is used by developers
    while coding in the language following specific syntax. The interpreter or compiler
    of a programming language interprets the syntax of the language and compiles or
    interprets the code and executes it to achieve the desired result.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言都是设计有其自己的语法，开发者在使用该语言编码时遵循特定的语法。编程语言的解释器或编译器解释语言的语法，编译或解释代码并执行它以实现预期的结果。
- en: In Python, an `ast` that can be used to understand the abstract syntax of the
    code that we develop.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`ast` 可以用来理解我们开发的代码的抽象语法。
- en: Throughout this chapter, we will look at understanding the syntax tree of some
    of the important code snippets that we developed in previous chapters, and we
    will also look at modifying or adding more information to the code through a few
    examples. We will be making use of abstract syntax trees throughout this chapter
    to perform an analysis of the code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨理解我们在前几章中开发的一些重要代码片段的语法树，同时我们还将通过几个示例来查看修改或添加更多信息的代码。我们将在本章中使用抽象语法树来对代码进行分析。
- en: 'In this chapter, we will be taking a look at the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主要主题：
- en: Exploring the `ast` library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 `ast` 库
- en: Inspecting Python code with abstract syntax trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象语法树检查 Python 代码
- en: Understanding abstract syntax trees with applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用理解抽象语法树
- en: By the end of this chapter, you should be able to understand the abstract syntax
    tree of Python code. You should also be able to inspect, parse, and modify the
    abstract syntax tree of source code through metaprogramming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够理解 Python 代码的抽象语法树。你还应该能够通过元编程检查、解析和修改源代码的抽象语法树。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在 GitHub 上找到，地址为：[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9)。
- en: Exploring the ast library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 `ast` 库
- en: In this section, we will explore the `ast` Python library, which can be imported
    from Python 3 to analyze the Python code written by developers. We can also use
    it to modify the code through its abstract syntax tree at a metaprogramming level
    rather than modifying the syntax of the code itself. This helps in understanding
    how the code is syntactically represented and how the syntax tree of the code
    can be used to modify its behavior without modifying the original source code.
    We will look at some of the important functions of the `ast` library, as those
    functions will be used throughout this chapter to understand the code from our
    core example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索 `ast` Python 库，该库可以从 Python 3 中导入以分析开发者编写的 Python 代码。我们还可以通过其抽象语法树在元编程级别上修改代码，而不是修改代码本身的语法。这有助于理解代码是如何在语法上表示的，以及代码的语法树如何被用来修改其行为而不修改原始源代码。我们将查看
    `ast` 库的一些重要功能，因为这些功能将在本章中用于理解我们的核心示例。
- en: 'Let’s start by importing the `ast` library:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入 `ast` 库开始：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we import the library, we can look at analyzing a piece of code using
    this library. We will now create a variable named `assignment` and assign a string
    format of the code to it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入库，我们就可以使用这个库来分析一段代码。现在我们将创建一个名为 `assignment` 的变量，并将代码的字符串格式赋值给它：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the `assignment` variable appears as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`assignment` 变量的输出如下所示：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code can be parsed into its corresponding nodes using the `parse`
    method of the `ast` library. We will now create a variable named `assign_tree`
    and store the parsed node of the lines of code stored under `assignment`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以使用 `ast` 库的 `parse` 方法解析为其对应的节点。现在我们将创建一个名为 `assign_tree` 的变量，并将存储在 `assignment`
    下的代码行的解析节点存储到它中：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the parsed node looks as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解析节点的输出如下所示：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can make use of another method called `dump` to print the tree structure
    of the node with each of its values and fields. This helps in debugging the code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the code is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Example of an abstract syntax tree ](img/Figure_9.1_B13426.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Example of an abstract syntax tree
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The `"product_name = 'Iphone X'"` code is broken down into multiple parts. The
    syntax of any code in Python is grammatically embedded into `Module` followed
    by `body`. We have assigned the `Iphone X` value to the `product_name` variable
    and so the code that performs a value assignment is identified by the `Assign`
    branch, which has attributes mapped with the corresponding ID, context, and value.
    This is an example of what a simple representation of a node would look like.
    For multiple lines of code with various other operations, the node will have multiple
    other branches in the tree.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start inspecting the Python code for a few examples of using abstract
    syntax trees in the following section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Python code with abstract syntax trees
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review and understand the code for a simple arithmetic
    addition example, and we will also further look into parsing the code and modifying
    it using abstract syntax trees.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing simple code using ast
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, let’s review simple code that adds two numbers, and let’s
    look at all the elements of the node, and also how the elements are organized
    in the tree. Let’s begin by writing code to assign two variables, `a` and `b`,
    with numerical values, and `c` as the sum of `a` and `b`. Finally, let’s print
    the `c` value. This is shown in the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will now parse the preceding `addfunc` and store the node in another variable
    called `add_tree`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the parsed node is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The base element of the node is `Module`, and all the other lines of code are
    split into semantics that are stored within the module of the node.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the detailed tree representation in the following code by calling
    the `dump` method on the tree:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The tree begins with `Module` as its base element, or the trunk followed by
    multiple branches. `Module` is followed by `body` as a list item that lists down
    all other elements of the code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `body`, there will be four list items that describe the operations of
    `addfunc`. The first one, which is also the first line of `addfunc`, is to assign
    the `Constant` value `1098` to a variable with a name whose id is `a` and the
    context of the value is `Store` since we are storing the value in the variable.
    Here is how it appears:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Code snippet output ](img/Figure_9.2_B13426.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Code snippet output
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the second line of `addfunc` is to store the `2032` value in the
    `b` variable, which is represented grammatically in the following list item:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Code snippet output ](img/Figure_9.3_B13426.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Code snippet output
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The third line of code in `addfunc` has the arithmetic operation of adding
    the two values stored in `a` and `b`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Code snippet output ](img/Figure_9.4_B13426.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Code snippet output
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code has an additional element, `BinOp`, followed by `left`, `op`,
    and `right` variables to indicate the left numerical value, addition operation,
    and right numerical value, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of the code in `addfunc` is the `Expr` expression element, which
    represents the printing of the `c` variable with a context value of `Load`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Code snippet output ](img/Figure_9.5_B13426.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Code snippet output
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute `addfunc`, we need to first compile the parsed tree as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Post-compilation, we should be able to execute the compiled tree, which results
    in the addition of `a` and `b`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output of the code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this section, we reviewed the abstract syntax tree of the simple arithmetic
    `add` function. In the following section, let’s look at modifying the code of
    the `add` function using metaprogramming.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Modifying simple code using ast
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let’s consider the example of `addfunc` from the preceding
    section and look at how to modify the code in the example through metaprogramming,
    without modifying the actual code. The operation performed by the code in `addfunc`
    is arithmetic addition. What if we want to perform arithmetic multiplication instead
    of addition and we don’t want the actual code to be modified? What if there are
    multiple locations where we want arithmetic addition to be replaced by arithmetic
    multiplication, and browsing through thousands of lines of code and modifying
    them is not a feasible option as it might impact or break something else in the
    code? In such scenarios, we can modify the node of the code using its syntax tree
    instead of modifying the actual code itself. To achieve this, let’s make use of
    the abstract syntax tree of the code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s reuse the `add_tree` parsed tree variable from the code in the preceding
    section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To understand which fields to modify, let’s look at the following representation
    of the node and look at each section of the node marked by an identifier. The
    elements of interest for this example are represented inside a box in the following
    figure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Parsed node of addfunc ](img/Figure_9.6_B13426.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Parsed node of addfunc
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify the add operation into a multiplication operation, the tree for this
    node traverses through `body` followed by its list item `2`, followed by the `value`
    field of the item, followed by the `op` field. The `Add()` operation of the `op`
    field will have to be modified into a multiplication operation to achieve our
    goal for this section. Here’s how:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Executing the preceding code results in a change of the tree:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The figure of the updated tree structure is represented as follows, with the
    `Add()` operation replaced by the `Mult()` operation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Tree modified to perform multiplication ](img/Figure_9.7_B13426.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Tree modified to perform multiplication
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify whether the preceding modification on the tree node works, let’s
    compile the tree and execute it to check the results:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Executing the preceding code should have ideally provided an output of `3130`,
    which is the addition of two numbers, `1098` and `2032`. But we have modified
    `ast` to perform multiplication instead and so it would result in the value, which
    is a product of the two numbers:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Thus the tree is now modified and can be compiled to achieve the desired result
    without modifying the actual code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s proceed further to look at how to parse and understand
    the classes in Python.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Understanding abstract syntax trees with applications
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look into applying the concept of abstract syntax trees
    to our core example of *ABC Megamart* and explore how `ast` is defined in the
    classes, such as the `Branch` class and the `VegCounter` class of *ABC Megamart*.
    We will also look at modifying the behavior of these classes using `ast` at a
    metaprogramming level instead of modifying the actual source code of the class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the ast of a class
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at understanding the abstract syntax tree of
    a class, which will help us in exploring how to modify the elements of a class
    through metaprogramming. We can try it as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by creating a class with empty definitions and look at its abstract
    syntax tree:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, let’s parse the code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s further look at the elements of the node and understand how the class
    is grammatically defined:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The structure of the node is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Code snippet output  ](img/Figure_9.8_B13426.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Code snippet output
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, we have `Module` followed by `body`, with `ClassDef`
    within the `body` element. This `ClassDef` has a `name` element followed by two
    expressions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s redefine this empty class definition with an attribute and a method along
    with a decorator and recheck the structure of the node:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will now parse `branch_code` in the following step:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The structure of the `Branch` class in the form of an abstract syntax tree is
    as follows. We can see that the node starts with the `Module` element followed
    by `body`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `body`, we have a `ClassDef` element that contains the class name followed
    by its attributes, which include `branch_id` stored as a constant value followed
    by the `get_product` method with its arguments. Refer to the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Code snippet output](img/Figure_9.9_B13426.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Code snippet output
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a `decorator` method loaded under `decorator_list` as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Code snippet output ](img/Figure_9.10_B13426.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Code snippet output
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create an object for the class, the code for the object can also be parsed
    similarly to the preceding class example:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The node of the object will have the following structure:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 Code snippet output ](img/Figure_9.11_B13426.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 Code snippet output
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed the abstract syntax tree of a class to understand
    the various elements of its syntax. With this understanding, let’s look further
    into modifying the abstract syntax tree of a class from our core example, *ABC
    Megamart*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the ast of a code block by parsing
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let’s look at how to modify the attributes in the code of a
    class by using its abstract syntax tree instead of modifying the actual class
    itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider having developed a robust library with multiple classes and methods.
    A robust library definition may be too big to be disturbed or modified. Instead
    of modifying the source code, we can make changes to some specific attributes
    in the library without impacting the actual code, through metaprogramming. In
    such a scenario, modifying `ast` of the library would be a better way of making
    changes rather than impacting the source code of the library.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will be following these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be creating a `vegCounter` class and adding a `return_cart` method
    to return the items within the cart. We will also be creating an object for the
    class and calling the `return_cart` method on the object. Refer to the following
    code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, let’s parse the code for `vegCounter` and look at the structure of the
    node:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the node is as follows. There is a class definition followed
    by a function definition in `ast`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Code snippet output](img/Figure_9.12_B13426.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Code snippet output
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output has the elements for the list item and the logic that
    reads items to the list:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Code snippet output ](img/Figure_9.13_B13426.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Code snippet output
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output has the syntax for creating the object for the `VegCounter`
    class:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Code snippet output ](img/Figure_9.14_B13426.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Code snippet output
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output displays the elements that print the cart items by calling
    the `return_cart` method on a list of cart items:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Code snippet output ](img/Figure_9.15_B13426.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Code snippet output
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now compile the abstract syntax tree and execute it to display the list
    of items added to the cart:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, let’s navigate through the values in the cart items and look at the path
    of the second value in the `return_cart` method output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s now change the second value of the cart item from `tomatoes` to `potatoes`
    by parsing through the node elements hierarchically:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the following output, let’s look at the updated value for the second item
    in the cart, which is modified without changing the source code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Modifying value within ast ](img/Figure_9.16_B13426.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Modifying value within ast
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now unparse the node using the `unparse` method in the `ast` library
    as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The modified source code now looks as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is one approach to modifying the Python source code using an abstract syntax
    tree.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s proceed with the next approach, where we will
    be transforming the nodes of the abstract syntax tree.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the ast of a code block by transforming nodes
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at another approach to modifying the source code
    of a class by modifying the abstract syntax tree instead of changing the actual
    code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create the `VegCounter` class as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, let’s create a variable named `cart` and add the function call on the
    object as a string:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Parsing the preceding code provides the following output:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – AST of the object variable ](img/Figure_9.17_B13426.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – AST of the object variable
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, instead of traversing through the structure of the node, we
    will be using `NodeTransformer` from the `ast` library to perform code transformation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The attributes of `NodeTransformer` are as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Attributes of NodeTransformer ](img/Figure_9.18_B13426.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Attributes of NodeTransformer
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create a class named `ModifyVegCounter` inherited from the `NodeTransfomer`
    class. We will be redefining the `visit_Constant` method to modify the constant
    values of the cart items by adding a string prefix whenever the constant value
    occurs in the code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can make use of the `visit` method to visit the node and use the `dump`
    method to print the tree:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The transformed node looks as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Source code transformed with NodeTransformer ](img/Figure_9.19_B13426.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Source code transformed with NodeTransformer
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further unparse the code using the `ast` library’s `unparse` method:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the code is represented as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is another example of how an abstract syntax tree can be used in metaprogramming.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the approach of transforming the nodes of an abstract
    syntax tree using the `NodeTransformer` method of the `ast` library.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the concept of the abstract syntax tree
    by exploring the `ast` library in Python 3\. We also inspected Python code using
    abstract syntax trees. We understood the applications of abstract syntax trees
    by modifying the code at the node level using source code from our core example.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Similar to other chapters in this book, this chapter covered the concept of
    abstract syntax trees in metaprogramming. This also helps in understanding how
    to modify the behavior of Python objects externally without modifying the source
    code. Modifying the abstract syntax tree instead of the actual methods and attributes
    in the code helps migrate source code from different versions of Python or the
    application development platform conveniently without impacting the actual logic
    of the code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at the concept of **method resolution
    order** with some other interesting examples.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨**方法解析顺序**的概念，并伴随一些有趣的示例。
