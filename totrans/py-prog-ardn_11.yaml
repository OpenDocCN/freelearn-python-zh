- en: Chapter 11. Tweet-a-PowerStrip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart power management units or strips are part of some of the most popular
    IoT subdomains, smart homes and smart grids. Nowadays, smart power strips are
    commercially available and provide a large number of features, such as remote
    access, smart power usage, and power management. In this project, we are going
    to create a smart DIY power strip that can be controlled remotely using status
    messages posted on Twitter, the popular social media website ([http://www.twitter.com](http://www.twitter.com)).
    These messages are also known as **tweets**. Basically, just like you can control
    sensors remotely using a web browser, you can control them by sending a tweet.
    We've already worked with low-power sensors in the previous project, so let's
    work with AC appliances in this project. We will be implementing the same project
    development methods that we utilized in the previous project. This chapter avoids
    additional explanations about the process and sticks only to the details associated
    with the project.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project requires the development of a smart power strip using Arduino and
    Python, while the control inputs to the strips are tweets. Although we are only
    enabling remote access to the power strip, there are a large number of additional
    features that can be implemented in future to elevate this DIY project to a commercial
    product.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major goals we want to achieve in this project are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user should be able to turn the individual power ports on and off using
    customized tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user should be able to check the status of the power ports using Twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the initial project requirements, derived from the goals:'
  prefs: []
  type: TYPE_NORMAL
- en: The system should have 110V (or 220V) AC power ports interfaced with relays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Arduino-based unit should be able to control these relays, ultimately controlling
    the appliance connected through the power ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system should be able to decode the tweets sent by the user and convert
    them into appropriate control messages for Arduino.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python-based program that processes the tweets should then publish these
    messages so that Arduino can complete those actions using the relays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To sum up, the relays should be controlled in a near real-time manner using
    the tweets sent by the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system should also understand keywords to check the status of the relays
    and automatically tweet the status. The system should process a tweet only once
    and should be able to remember the last tweet processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**110V versus 220V AC power**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Depending on the country, your AC power supply may have voltage ratings of
    110/120V or 220/240V. Although the circuit diagram used by this project mentions
    a 110V AC power supply, the same circuit should also work for a 220V power supply.
    If you are using a 220V supply, check out the following notes before moving forward:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that the appliances you are trying to operate, such as fans, lights,
    and so on, are rated for similar AC power
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to ensure that the relays used by the project are compatible with your
    AC power supply
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino works on a DC power supply, and it is not affected by any variation
    in AC power
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: System architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the preceding requirements, let's sketch the architecture of the Tweet-a-PowerStrip
    system. The system architecture tries to utilize the hardware components and software
    tools you learned in the previous chapters, while having a relay component as
    the only exceptional component. As you can see in the architecture in the following
    diagram, we are employing the relay to control various home appliances. These
    appliances are usually powered by a common 110V AC power supply available in each
    home. Instead of controlling a single appliance, we are implementing a four-channel
    relay to control at least four appliances, such as a lamp, a fan, a toaster, and
    a coffee machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![System architecture](img/5938OS_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The relay is controlled using the digital pins of the Arduino Uno board, which
    utilizes the Ethernet Shield to connect to your home network. A computation unit
    that may consist of a computer, a Raspberry Pi, or a server, uses Python and its
    supporting libraries to access tweets. The computation unit also deploys a Mosquitto
    broker. This broker handles the topics from the Python program and Arduino to
    control the relays. The user can post tweets containing keywords from any platform,
    such as a phone or a browser, and the tweets are ultimately captured by the computation
    unit.
  prefs: []
  type: TYPE_NORMAL
- en: Required hardware components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This project will require the following hardware components throughout the
    development and the deployment stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component | Amount | Website/note |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Uno | 1 | [https://www.sparkfun.com/products/11021](https://www.sparkfun.com/products/11021)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Ethernet Shield | 1 | [https://www.sparkfun.com/products/9026](https://www.sparkfun.com/products/9026)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Relay (four-channel, Arduino-compatible) | 1 | [http://www.amazon.com/JBtek-Channel-Module-Arduino-Raspberry/dp/B00KTEN3TM/](http://www.amazon.com/JBtek-Channel-Module-Arduino-Raspberry/dp/B00KTEN3TM/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| PowerSwitch Tail | 4 | [http://www.powerswitchtail.com/](http://www.powerswitchtail.com/)Alternative
    to relay |'
  prefs: []
  type: TYPE_TB
- en: '| Power strip | Optional |   |'
  prefs: []
  type: TYPE_TB
- en: '| Breadboard | 1 | For development stage |'
  prefs: []
  type: TYPE_TB
- en: '| USB cable for Arduino | 1 | For development stage |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino power supply | 1 | For deployment stage |'
  prefs: []
  type: TYPE_TB
- en: '| Electric tape | As per requirements |   |'
  prefs: []
  type: TYPE_TB
- en: '| Connection wires | As per requirements |   |'
  prefs: []
  type: TYPE_TB
- en: Relays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you can see in the following image, we are introducing a new hardware component
    that was not utilized in any of the previous chapters—a relay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relays](img/5938OS_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is an electromagnetic device that uses electricity to be operated as a
    switch. A typical relay contains three contacts on the high-power side, **normally
    connected** (**NC**), **common** (**C**), and **normally open** (**NO**). The
    other side (the control side) of the relay requires an activation voltage to toggle
    the connection from common-NC to common-NO. This action demonstrates the switch
    functionalities for the connection on the high-power side. We'll use Arduino-compatible
    relays from manufacturers such as Keyes or SainSmart. These relays are available
    in single-, two- or four-channel configurations. On the high-power side, the relays
    support up to 250V, 10A AC power or 30V, 10A DC power. The relays are controlled
    using 5V DC on the low-power side, which is provided using the digital I/O pins
    of the Arduino board.
  prefs: []
  type: TYPE_NORMAL
- en: PowerSwitch Tail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Working with AC power can be hazardous if you haven''t dealt with it previously
    or if you are not familiar with the necessary precautions and measurements. If
    you are not comfortable with working with open relays or connecting AC power to
    them, there is another device that you can use to replace the relay—the PowerSwitch
    Tail, a safely enclosed box that contains optically isolated solid-state relays
    and provides a convenient way to interface your AC appliance with the Arduino
    board. The following is an image of the PowerSwitch Tail, which can be obtained
    from its official website ([http://www.powerswitchtail.com/](http://www.powerswitchtail.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![PowerSwitch Tail](img/5938OS_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are dealing with a 220V/240V power supply, the PowerSwitch Tail website
    also provides an assembly kit for 200V to 240V power supply, at [http://www.powerswitchtail.com/Pages/PowerSwitchTail240vackit.aspx](http://www.powerswitchtail.com/Pages/PowerSwitchTail240vackit.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: It is really easy to assemble the kit from the guidelines provided at [http://www.powerswitchtail.com/Documents/PSSRTK%20Instructions.pdf](http://www.powerswitchtail.com/Documents/PSSRTK%20Instructions.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: For this project, you will need four of these devices to replace the four-channel
    relay that we are going to use. As you can see in the following diagram, one end
    of the Tail goes into the regular power port, while you need to connect your appliance
    to the other port. Meanwhile, you can use the three control inputs to control
    the relay. We are using one of the digital I/O pins of the Arduino board to send
    the control signal to the Tail. When going ahead with the Tails instead of the
    relays, make sure that you make necessary amendments to the upcoming hardware
    design.
  prefs: []
  type: TYPE_NORMAL
- en: '![PowerSwitch Tail](img/5938OS_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User experience flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the system architecture we have created, what should the **user experience**
    (**UX**) flow while working with the Tweet-a-PowerStrip be? We have divided the
    UX into two separate sections: controlling the power to the appliances, and checking
    the status of the power strip.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first UX flow design, as displayed in the following diagram, the user
    begins by sending a tweet containing the name of the appliance (#fan, #lamp, #toaster,
    or #coffee) and the control command (#on or #off). The system should be able to
    handle the tweet from the point of parsing until the appliance has behaved as
    asked for. The system should also provide a hassle-free experience for the user,
    where the user doesn''t have to perform any further actions than simply sending
    tweets.'
  prefs: []
  type: TYPE_NORMAL
- en: '![User experience flow](img/5938OS_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the user should be able to post **#status #check** tweets and simply
    obtain the status report posted back by the system. The system should handle checking
    the status of the power ports, publishing it to the computation unit, and posting
    a tweet with the message without any additional input from the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the UX flow for checking the system status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User experience flow](img/5938OS_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Development and deployment stages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the architecture, we require two main development stages to complete
    the project. The first stage, which interacts with the appliance through the relays,
    is developed using Arduino. This unit subscribes to the topics associated with
    the appliances, and once it receives an appropriate message, it executes the action
    on the relay level. In the second stage, we deal with the individual tweets, where
    we parse the tweets from the Twitter account, check for duplicates, decode actions
    from the messages, and also post tweets with status reports. During these development
    stages, we are going to use a breadboard and jumper wires to test the Arduino
    and Python programs. At this stage, the project is still not ready to deploy as
    a portable unit for daily usage.
  prefs: []
  type: TYPE_NORMAL
- en: The deployment stage contains tasks of creating a PCB for the breadboard connections
    and insulating wires to avoid any electric hazard. You can also buy or create
    an enclosure box to isolate the open hardware from physical contact. As the development
    stage contains everything that is required to convert the project into its working
    state, we are not going to dive deep into the deployment stage. You can perform
    addition deployment tasks according to your personal requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start from the hardware design stage and develop the physical section
    of the smart power strip using Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 1 – a smart power strip with Arduino and relays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hardware of Tweet-a-PowerStrip contains Arduino as the main controller unit
    that interfaces with the relays and the Ethernet Shield to communicate with the
    computation unit. The Arduino code implements the MQTT client, using the `PubSubClient`
    library to publish and subscribe to the topics. Although we are using some example
    appliances to control the use of the relay, you can select any other appliance
    you own. You can also use a commercial power strip instead of an individual power
    plug.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While assembling the hardware components, as displayed in the following diagram,
    make sure you are precise in connecting the appliances with the AC power plugs.
    One wire of the AC plug is directly connected to the appliance, while the other
    is connected between the C and NO ports of the relay. We have connected the control
    side of the relay to the digital pin of our Arduino. As we are using a four-channel
    relay, we will have to utilize four digital IO pins from the Arduino board. Complete
    the remaining connections as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hardware design](img/5938OS_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting the hardware unit is fairly simple, but requires a lot of precision
    because it involves high-power AC connections.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should cover the open 110V AC power cords going to the relay and the appliance
    with electric tape to avoid any type of electrical hazard. Keeping these live
    wires open can be really dangerous due to the large amount of current being carried
    by them. In the deployment stage, a plastic cover or a box around the relay unit
    can also be helpful in covering the live power wires.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are ready with the connections, connect the Arduino board to your
    computer using a USB port, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hardware design](img/5938OS_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Arduino code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Arduino sketch for this section is located in the folder containing the
    chapter code with the `Arduino_powerstrip.ino` filename. You can open the file
    in the Arduino IDE to explore the code. As usual, you will have to change the
    IP addresses of the device and the Mosquitto server to the appropriate IP addresses,
    while also changing the MAC address of the Ethernet Shield. The following code
    snippet shows the declaration of the Arduino pins and their roles in the main
    function, `setup()`. Make sure that you are using the same pin numbers that you
    have used to connect the relay. Alternatively, you can change the appliance name
    to that of the appliance you are using. Also, make sure whatever changes you make
    in the variable names should be reflected in the entire code to avoid any compilation
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `setup()` function, the code also subscribes to the appropriate MQTT
    channels so that it can receive messages from the Mosquitto broker as soon as
    they are available. As you can see, we are also subscribing to the `PowerStrip/statuscheck`
    channel to deal with the status report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `callback()` function, we use the `if` statement to match the topic
    with the appropriate `digitalWrite()` action. As you can see, we are setting up
    `HIGH` and `LOW` statuses for the digital pin when the program receives `on` and
    `off` messages, respectively (for that appliance). With this action, we are also
    changing the state of the Boolean variable associated with the appliance, which
    will be helpful in retrieving the status of the port. The same process is then
    repeated for all appliances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the system receives a `get` message that is associated with the status
    check, the program creates a message using the Boolean variables that we toggled
    earlier. The program then publishes the status to the `PowerStrip/statusreport`
    channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did in the previous project, you can set up the code to periodically
    send `keep alive` messages to avoid the termination of the connection with the
    Mosquitto broker. Once you are ready with the code, connect the Ethernet cable,
    compile the code, and then upload it to your Arduino. Your Arduino should be in
    receiving mode now, and it will wait for the message from the subscribed channels.
    As we discussed in the previous the project, you need to ensure that your Mosquitto
    broker is running on the server IP address you specified in the Arduino code.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 2 – the Python code to process tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the user is interacting with the system at the level of the Twitter application,
    we do not require a deployable computation or control unit for this project. Due
    to this, we can just use any computer capable of hosting Python and Mosquitto
    as the computation unit. You still need to ensure that the unit is always on and
    connected to the Internet, otherwise the system will not work as expected. For
    simplicity, you can deploy the system on the Raspberry-Pi-based control center
    that you developed in the previous project, or even on the Amazon AWS server.
    For the development stage, let's start with the regular computer that you have
    been using all along. We are assuming that this computer has the Mosquitto broker
    installed and running. Note down the IP address of this unit, as you will need
    it in the Arduino code that you developed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Python software flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python code deals with two services during execution, the Twitter API to
    get or post tweets and the Mosquitto broker to relay messages to the hardware
    unit. The program begins by parsing the latest tweet from the user account and
    checking whether it has been utilized in the previous action or not. This avoids
    any command duplication, as the frequency of new tweets is significantly lower
    than the frequency of the program loop. Once the code finds a new tweet with the
    appropriate keywords to perform operations on the appliance (or appliances), it
    publishes the message to the Mosquitto broker. If the tweet contains a message
    to check the status, the code requests the status from your Arduino and posts
    a new tweet with the status after receiving it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the detailed program flow of the computation unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python software flow](img/5938OS_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can change the program flow to accommodate any other feature you want to
    add at the Python level. The logic behind identifying and toggling the appliance
    can be improvised to accommodate more complex tweet text.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Twitter application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are assuming that you have a Twitter account by now. If you don''t, you
    can create a new account just for this project to avoid changes to your own profile.
    With the introduction of the latest APIs, Twitter requires you to authenticate
    using OAuth before accessing any information from your account. To do that, you
    will have to create a Twitter app using your account. Execute the following steps
    in order to create a new Twitter app for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your Twitter account and open the [https://apps.twitter.com](https://apps.twitter.com)
    address in your web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create New App** icon on the page, and you will be directed to
    a page asking for your application details, as displayed in the following screenshot:![Setting
    up the Twitter application](img/5938OS_11_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in all the required details (marked with red asterisks) and continue to
    the next page. Ensure that your application name is unique, as Twitter asks for
    a unique application name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your application is created, you can click on the **API Keys** tab and
    find the consumer key (**API key**) and consumer secret (**API secret**) for your
    app. Save this information in a safe place, as you will need them to authenticate
    with the Twitter API.![Setting up the Twitter application](img/5938OS_11_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the UX of the Tweet-a-PowerStrip project requires the system to automatically
    send the system status, we need read-and-write access to our application. Go to
    the **Permissions** tab, select the **Read and Write** option, and save it for
    the changes to take effect.![Setting up the Twitter application](img/5938OS_11_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you are done with setting up the permissions for the application, go back
    to the API keys tab and click on the **Create Access Token** icon to generate
    a new access token for this application. After a while, you should be able to
    see the access token on the same page, as displayed in this screenshot:![Setting
    up the Twitter application](img/5938OS_11_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the **Access token** and **Access token secret** information. Your application
    is now ready for use and can help you to authenticate with the Twitter API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's move on to the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you jump into the code, you are required to install the Twitter library
    for Python. Use the Setuptools or `pip` to install the library using the following
    command. We are assuming that you already have the latest `paho_mqtt` library
    installed on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Python code for this section is located in the code folder with the `PythonTweetAPowerStrip.py`
    filename. Open the code in your IDE and start exploring it. The code contains
    two parallel threads to handle the tweets and the Mosquitto library separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following code snippet, we are using the `Api` class
    from the `python-twitter` library to establish a connection with the Twitter API.
    We are using the `consumer key`, `consumer secret`, `access token key`, and `access
    token secret` values for this authentication. Once the authentication is established,
    the `Api` class can be used to get the latest status from the timeline using the
    `GetHomeTimeline()` function call, and to post the new status using the `PostUpdate()`
    function call. The `GetHomeTimeline()` function gives an array of statuses from
    the user; we need the latest status, which can be fetched using `statuses[0]`
    (the first element of the array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have retrieved the latest tweet, we need to make sure that we haven''t
    used that tweet already. So we save the latest tweet ID in a global variable,
    as well as in a file in case we need to run the code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We retrieve the ID of the previous tweet from the `lastTweetID.txt` file to
    match with the latest ID. If it doesn''t match, we update the `lastTweetID.txt`
    file with the latest ID for the next loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have identified the latest unique tweet, we use the Python string operation
    to decode the keywords for the appliance and power commands. As you can see in
    the following code snippet, the keyword we are looking for in the tweeted text
    to access the fan is `#fan`. Once we have identified that the message is directed
    to the fan, we check for action keywords such as `#on` and `#off`, and then take
    the associated action of publishing the message to the Mosquitto broker. We repeat
    this action for all the appliances connected to the system. Your Arduino takes
    an action using the published message, and completes the UX flow for the controlled
    appliances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when the code receives an update from the `PowerStrip/statusreport`
    topic, it obtains the status from the message payload and posts it as a new tweet
    to the user timeline of that Twitter account. This completes the UX flow for the
    status check using Twitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Testing and troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing can simply be performed by posting the `#fan #on` status to the Twitter
    account used in this project. You should be able to see the fan turning on by
    using the command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and troubleshooting](img/5938OS_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, send the `#fan #off` status to turn off the fan. You may find some
    lagging, as the loop used to retrieve the tweets is set with a delay of a minute.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and troubleshooting](img/5938OS_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To access the status of the system, post the `#status #get` status to the account,
    and you will be able to see the system status automatically posted by the computation
    unit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and troubleshooting](img/5938OS_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tweet shown in the following screenshot is generated using the Tweet-a-PowerStrip
    unit. It displays the status of all the connected appliances.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and troubleshooting](img/5938OS_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While working with the system, you will want to either avoid the following
    scenarios or troubleshoot them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''Twitter rate limit exceed'' error`: Twitter imposes a limit on the number
    of requests you can make to their public API. If you are requesting the API too
    often (this often occurs when you reduce the sleep time between consecutive queries),
    your application will exit with an exception. To avoid this, set a longer sleep
    time in the Python program loop before requesting the API again. There is a trade-off
    between the frequency of requests and the response time of your appliances. You
    can learn about this limitation at [http://dev.twitter.com/rest/public/rate-limiting](http://dev.twitter.com/rest/public/rate-limiting)
    and adjust your request interval accordingly. Once you have received this error,
    you will have to wait for some time (approximately 10 to 15 minutes) before making
    requests to the Twitter API again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''Read-only application cannot post'' error`: This error will only occur if
    you forgot to change the permissions on your application to **Read and Write**
    from **Read only**. Make sure that you have performed this change. Also, Twitter
    takes some time for the changes to take effect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the project with additional features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current system can be expanded to include multiple features:'
  prefs: []
  type: TYPE_NORMAL
- en: You can start saving the time duration in which a particular appliance was on
    or off, and then provide a detailed analysis to the user. You can also use this
    information to calculate the energy being expended by these appliances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can utilize the current measurement sensors to calculate the power load
    at each port. Combining it with the time the device was on, you can calculate
    very comprehensive power usage to further improve power management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the system clock with the motion sensor to intelligently turn off
    the appliance during nights and periods of no activity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tweet-a-PowerStrip project can be interfaced with the remote home monitoring
    system that we developed in the previous project, in order to obtain useful information
    from other sensors being used in the same house.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the modifications you can easily implement is to utilize Twitter's private
    messages instead of its tweets to control the appliances. This will extend the
    access permissions of your system to other trusted Twitter accounts. For security
    reasons, you should tighten the access level and only let approved people post
    such messages to your account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now successfully completed two different IoT projects using just two
    base technologies, Arduino and Python. With the current project, it is obvious
    that it is very easy to interface any other technology, tool, or API with Arduino
    and Python. The project development methodology we used in these two projects
    will also help you with your DIY projects and other future products. Happy prototyping!
    And happy coding!
  prefs: []
  type: TYPE_NORMAL
