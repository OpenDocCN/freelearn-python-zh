["```py\n$ pip instal aioredis ariande databases[postgresql] nextcord\n```", "```py\n    from sanic import Blueprint\n    from sanic.log import logger\n    from .channel import Channel\n    bp = Blueprint(\"Feed\", url_prefix=\"/feed\")\n    @bp.websocket(\"/<channel_name>\")\n    async def feed(request, ws, channel_name):\n        logger.info(\"Incoming WS request\")\n        channel, is_existing = await Channel.get(\n            request.app.ctx.pubsub, request.app.ctx.redis, channel_name\n        )\n        if not is_existing:\n            request.app.add_task(channel.receiver())\n        client = await channel.register(ws)\n        try:\n            await client.receiver()\n        finally:\n            await channel.unregister(client)\n    ```", "```py\n    from dataclasses import dataclass, field\n    from uuid import UUID, uuid4\n    from aioredis import Redis\n    from sanic.server.websockets.impl import WebsocketImplProtocol\n    @dataclass\n    class Client:\n        protocol: WebsocketImplProtocol\n        redis: Redis\n        channel_name: str\n        uid: UUID = field(default_factory=uuid4)\n        def __hash__(self) -> int:\n            return self.uid.int\n        async def receiver(self):\n            while True:\n                message = await self.protocol.recv()\n                if not message:\n                    break\n                await self.redis.publish(self.channel_name, message)\n        async def shutdown(self):\n            await self.protocol.close()\n    ```", "```py\n    class ChannelCache(dict):\n        ...\n    class Channel:\n        cache = ChannelCache()\n        def __init__(self, pubsub: PubSub, redis: Redis, name: str) -> None:\n            self.pubsub = pubsub\n            self.redis = redis\n            self.name = name\n            self.clients: Set[Client] = set()\n            self.lock = Lock()\n        @classmethod\n        async def get(cls, pubsub: PubSub, redis: Redis, name: str) -> Tuple[Channel, bool]:\n            is_existing = False\n            if name in cls.cache:\n                channel = cls.cache[name]\n                await channel.acquire_lock()\n                is_existing = True\n            else:\n                channel = cls(pubsub=pubsub, redis=redis, name=name)\n                await channel.acquire_lock()\n                cls.cache[name] = channel\n                await pubsub.subscribe(name)\n            return channel, is_existing\n    ```", "```py\n async def destroy(self) -> None:\n        if not self.lock.locked():\n            logger.debug(f\"Destroying Channel {self.name}\")\n            await self.pubsub.reset()\n            del self.__class__.cache[self.name]\n        else:\n            logger.debug(f\"Abort destroying Channel {self.name}. It is locked\")\n```", "```py\n async def register(self, protocol: WebsocketImplProtocol) -> Client:\n        client = Client(protocol=protocol, redis=self.redis, channel_name=self.name)\n        self.clients.add(client)\n        await self.publish(f\"Client {client.uid} has joined\")\n        return client\n```", "```py\n async def publish(self, message: str) -> None:\n        logger.debug(f\"Sending message: {message}\")\n        await self.redis.publish(self.name, message)\n```", "```py\n async def unregister(self, client: Client) -> None:\n        if client in self.clients:\n            await client.shutdown()\n            self.clients.remove(client)\n            await self.publish(f\"Client {client.uid} has left\")\n        if not self.clients:\n            self.lock.release()\n            await self.destroy()\n```", "```py\napp.static(\"/\", \"./public\")\n```", "```py\n$ pip install sanic[ext]\n```", "```py\n$ pip install sanic sanic-ext\n```", "```py\napp.config.CORS_ORIGINS = \"http://foobar.com,http://bar.com\"\n```", "```py\n    app = Sanic(\"MainApp\")\n    app.config.FRONTEND_DIR = Path(__file__).parent / \"my-svelte-project\"\n    app.static(\"/\", app.config.FRONTEND_DIR / \"public\")\n    ```", "```py\n    sanic server:app -d -p7777 -R ./my-svelte-project/src\n    ```", "```py\n    @app.signal(\"watchdog.file.reload\")\n    async def file_reloaded():\n    ...\n    ```", "```py\n    @app.before_server_start\n    async def check_reloads(app, _):\n        do_rebuild = False\n        if reloaded := app.config.get(\"RELOADED_FILES\"):\n            reloaded = reloaded.split(\",\")\n            do_rebuild = any(\n                ext in (\"svelte\", \"js\")\n                for filename in reloaded\n                if (ext := filename.rsplit(\".\", 1)[-1])\n            )\n    ```", "```py\n     if do_rebuild:\n            rebuild = await create_subprocess_shell(\n                \"yarn run build\",\n                stdout=PIPE,\n                stderr=PIPE,\n                cwd=app.config.FRONTEND_DIR,\n            )\n            while True:\n                message = await rebuild.stdout.readline()\n                if not message:\n                    break\n                output = message.decode(\"ascii\").rstrip()\n                logger.info(f\"[reload] {output}\")\n            await app.dispatch(\"watchdog.file.reload\")\n    ```", "```py\n    livereload = Sanic(\"livereload\")\n    livereload.static(\"/livereload.js\", app.config.FRONTEND_DIR / \"livereload.js\")\n    ```", "```py\n    INDEX_HTML = app.config.FRONTEND_DIR / \"public\" / \"index.html\"\n    HELLO = {\n        \"command\": \"hello\",\n        \"protocols\": [\n            \"http://livereload.com/protocols/official-7\",\n        ],\n        \"serverName\": app.name,\n    }\n    RELOAD = {\"command\": \"reload\", \"path\": str(INDEX_HTML)}\n    ```", "```py\n    @app.before_server_start\n    async def start(app, _):\n        app.ctx.livereload_server = await livereload.create_server(\n            port=35729, return_asyncio_server=True\n        )\n        app.add_task(runner(livereload, app.ctx.livereload_server))\n    @app.before_server_stop\n    async def stop(app, _):\n        await app.ctx.livereload_server.close()\n    ```", "```py\n    async def runner(app, app_server):\n        app.is_running = True\n        try:\n            app.signalize()\n            app.finalize()\n            await app_server.serve_forever()\n        finally:\n            app.is_running = False\n            app.is_stopping = True\n    ```", "```py\n    @livereload.websocket(\"/livereload\")\n    async def livereload_handler(request, ws):\n        global app\n        logger.info(\"Connected\")\n        msg = await ws.recv()\n        logger.info(msg)\n        await ws.send(ujson.dumps(HELLO))\n        while True:\n            await app.event(\"watchdog.file.reload\")\n            await ws.send(ujson.dumps(RELOAD))\n    ```", "```py\n{\n  countries (limit: 3, offset:2) {\n    name\n    region\n    continent\n    capital {\n      name\n      district\n    }\n    languages {\n      language\n      isofficial\n      percentage\n    }\n  }\n}\n```", "```py\n{\n  \"data\": {\n    \"countries\": [\n      {\n        \"name\": \"Netherlands Antilles\",\n        \"region\": \"Caribbean\",\n        \"continent\": \"North America\",\n        \"capital\": {\n          \"name\": \"Willemstad\",\n          \"district\": \"CuraÃ§ao\"\n        },\n        \"languages\": [\n          {\n            \"language\": \"Papiamento\",\n            \"isofficial\": true,\n            \"percentage\": 86.19999694824219\n          },\n          {\n            \"language\": \"English\",\n            \"isofficial\": false,\n            \"percentage\": 7.800000190734863\n          },\n          {\n            \"language\": \"Dutch\",\n            \"isofficial\": true,\n            \"percentage\": 0\n          }\n        ]\n      },\n      ...\n    ]\n  }\n}\n```", "```py\n    $ pip install ariadne\n    ```", "```py\n    from ariadne import QueryType, graphql, make_executable_schema\n    from ariadne.constants import PLAYGROUND_HTML\n    from graphql.type import GraphQLResolveInfo\n    from sanic import Request, Sanic, html, json\n    app = Sanic(__name__)\n    query = QueryType()\n    type_defs = \"\"\"\n        type Query {\n            hello: String!\n        }\n    \"\"\"\n    @query.field(\"hello\")\n    async def resolve_hello(_, info: GraphQLResolveInfo):\n        user_agent = info.context.headers.get(\"user-agent\", \"guest\")\n        return \"Hello, %s!\" % user_agent\n    @app.post(\"/graphql\")\n    async def graphql_handler(request: Request):\n        success, result = await graphql(\n            request.app.ctx.schema,\n            request.json,\n            context_value=request,\n            debug=app.debug,\n        )\n        status_code = 200 if success else 400\n        return json(result, status=status_code)\n    @app.get(\"/graphql\")\n    async def graphql_playground(request: Request):\n        return html(PLAYGROUND_HTML)\n    @app.before_server_start\n    async def setup_graphql(app, _):\n        app.ctx.schema = make_executable_schema(type_defs, query)\n    ```", "```py\n    from ariadne import QueryType\n    query = QueryType()\n    ```", "```py\n    from sanic import Blueprint, Request, html, json\n    from sanic.views import HTTPMethodView\n    from ariadne.constants import PLAYGROUND_HTML\n    bp = Blueprint(\"GraphQL\", url_prefix=\"/graphql\")\n    class GraphQLView(HTTPMethodView, attach=bp, uri=\"\"):\n        async def get(self, request: Request):\n            return html(PLAYGROUND_HTML)\n        async def post(self, request: Request):\n            success, result = await graphql(\n                request.app.ctx.schema,\n                request.json,\n                context_value=request,\n                debug=request.app.debug,\n            )\n            status_code = 200 if success else 400\n            return json(result, status=status_code)\n    ```", "```py\n    from ariadne import graphql, make_executable_schema\n    from world.common.dao.integrator import RootIntegrator\n    from world.blueprints.cities.integrator import CityIntegrator\n    from world.blueprints.countries.integrator import CountryIntegrator\n    from world.blueprints.languages.integrator import LanguageIntegrator\n    @bp.before_server_start\n    async def setup_graphql(app, _):\n        integrator = RootIntegrator.create(\n            CityIntegrator,\n            CountryIntegrator,\n            LanguageIntegrator,\n            query=query,\n        )\n        integrator.load()\n        integrator.attach_resolvers()\n        defs = integrator.generate_query_defs()\n        additional = integrator.generate_additional_schemas()\n        app.ctx.schema = make_executable_schema(defs, query, *additional)\n    ```", "```py\nfrom world.common.dao.integrator import BaseIntegrator\nclass LanguageIntegrator(BaseIntegrator):\n    name = \"language\"\n```", "```py\ntype Language {\n    countrycode: String\n    language: String\n    isofficial: Boolean\n    percentage: Float\n}\n```", "```py\n async def query_country(\n        self, _, info: GraphQLResolveInfo, *, name: str\n    ) -> Country:\n        executor = CountryExecutor(info.context.app.ctx.postgres)\n        return await executor.get_country_by_name(name=name)\n```", "```py\n{\n  country(name: \"Israel\") {\n    name\n    region\n    continent\n    capital {\n      name\n      district\n    }\n    languages {\n      language\n      isofficial\n      percentage\n    }\n  }\n}\n```", "```py\n{\n  \"data\": {\n    \"country\": {\n      \"name\": \"Israel\",\n      \"region\": \"Middle East\",\n      \"continent\": \"Asia\",\n      \"capital\": {\n        \"name\": \"Jerusalem\",\n        \"district\": \"Jerusalem\"\n      },\n      \"languages\": [\n        {\n          \"language\": \"Hebrew\",\n          \"isofficial\": true,\n          \"percentage\": 63.099998474121094\n        },\n        {\n          \"language\": \"Arabic\",\n          \"isofficial\": true,\n          \"percentage\": 18\n        },\n        {\n          \"language\": \"Russian\",\n          \"isofficial\": false,\n          \"percentage\": 8.899999618530273\n        }\n      ]\n    }\n  }\n}\n```", "```py\ntype Country {\n    code: String\n    name: String\n    continent: String\n    region: String\n    capital: City\n    languages: [Language]\n}\n```", "```py\nclass CountryIntegrator(BaseIntegrator):\n    name = \"country\"\n    async def resolve_capital(\n        self,\n        country: Country,\n        info: GraphQLResolveInfo\n    ) -> City:\n        executor = CityExecutor(info.context.app.ctx.postgres)\n        return await executor.get_city_by_id(country.capital)\n```", "```py\nimport nextcord\nclient = nextcord.Client()\n@client.event\nasync def on_ready():\n    print(f'We have logged in as {client.user}')\n@client.event\nasync def on_message(message):\n    if message.author == client.user:\n        return\n    if message.content.startswith('$hello'):\n        await message.channel.send('Hello!')\nclient.run('your token here')\n```", "```py\n$ python bot.py\n```", "```py\n    from sanic import Sanic, Request, json\n    app = Sanic(__name__)\n    @app.get(\"/\")\n    async def handler(request: Request):\n        await request.app.ctx.general.send(\"Someone sent a message\")\n        return json({\"foo\": \"bar\"})\n    @app.before_server_start\n    async def before_server_start(app, _):\n        await app.ctx.general.send(\"Wadsworth, reporting for duty\")\n    ```", "```py\n    from server import app\n    @client.event\n    async def on_ready():\n        app.config.GENERAL_CHANNEL_ID = 906651165649928245\n        app.ctx.wadsworth = client\n        app.ctx.general = client.get_channel(app.config.GENERAL_CHANNEL_ID)\n\n        if not app.is_running:\n            app_server = await app.create_server(port=9999, return_asyncio_server=True)\n            app.ctx.app_server = app_server\n            client.loop.create_task(runner(app_server))\n    ```", "```py\n    async def runner(app_server: AsyncioServer):\n        app.is_running = True\n        try:\n            await app_server.startup()\n            await app_server.before_start()\n            await app_server.after_start()\n            await app_server.serve_forever()\n        finally:\n            app.is_running = False\n            app.is_stopping = True\n            await app_server.before_stop()\n            await app_server.close()\n            for connection in app_server.connections:\n                connection.close_if_idle()\n            await app_server.after_stop()\n            app.is_stopping = False\n    ```", "```py\n    @app.before_server_start\n    async def startup_wadsworth(app, _):\n        app.ctx.wadsworth = client\n        app.add_task(client.start(app.config.DISCORD_TOKEN))\n        while True:\n            if client.is_ready():\n                app.ctx.general = client.get_channel(app.config.GENERAL_CHANNEL_ID)\n                await app.ctx.general.send(\"Wadsworth, reporting for duty\")\n                break\n            await asyncio.sleep(0.1)\n    ```", "```py\n    @app.before_server_stop\n    async def shutdown(app, _):\n        await client.close()\n    ```", "```py\n$ sanic server:app -p 7777 --debug --workers=2\n```", "```py\n    $ openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 365\n    ```", "```py\n    from sanic import Sanic\n    from wadsworth.blueprints.view import bp\n    from wadsworth.blueprints.info.view import bp as info_view\n    from wadsworth.applications.redirect import attach_redirect_app\n    def create_app():\n        app = Sanic(\"MainApp\")\n        app.config.SERVER_NAME = \"localhost:8443\"\n        app.blueprint(bp)\n        app.blueprint(info_view)\n        attach_redirect_app(app)\n        return app\n    ```", "```py\n    def attach_redirect_app(main_app: Sanic):\n        redirect_app = Sanic(\"RedirectApp\")\n        redirect_app.blueprint(info_view)\n        redirect_app.blueprint(redirect_view)\n        redirect_app.ctx.main_app = main_app\n    ```", "```py\n    def attach_redirect_app(main_app: Sanic):\n        ...\n        @main_app.before_server_start\n        async def startup_redirect_app(main: Sanic, _):\n            app_server = await redirect_app.create_server(\n                port=8080, return_asyncio_server=True\n            )\n            if not app_server:\n                raise ServerError(\"Failed to create redirect server\")\n            main_app.ctx.redirect = app_server\n            main_app.add_task(runner(redirect_app, app_server))\n    ```", "```py\n    def attach_redirect_app(main_app: Sanic):\n        ...\n        @main_app.after_server_stop\n        async def shutdown_redirect_app(main: Sanic, _):\n            await main.ctx.redirect.before_stop()\n            await main.ctx.redirect.close()\n            for connection in main.ctx.redirect.connections:\n                connection.close_if_idle()\n            await main.ctx.redirect.after_stop()\n            redirect_app.is_stopping = False\n    This includes all of the major elements you need for turning down Sanic. It is a little bit basic and if you are implementing this in the real world, you might want to take a look into how Sanic server performs a graceful shutdown to close out any existing requests.\n    We now turn to runner, the function that we passed off to be run in a background task to run the RedirectApp.\n    async def runner(app: Sanic, app_server: AsyncioServer):\n        app.is_running = True\n        try:\n            app.signalize()\n            app.finalize()\n            ErrorHandler.finalize(app.error_handler)\n            app_server.init = True\n            await app_server.before_start()\n            await app_server.after_start()\n            await app_server.serve_forever()\n        finally:\n            app.is_running = False\n            app.is_stopping = True\n    ```", "```py\n    from sanic import Blueprint, Request, response\n    from sanic.constants import HTTP_METHODS\n    bp = Blueprint(\"Redirect\")\n    @bp.route(\"/<path:path>\", methods=HTTP_METHODS)\n    async def proxy(request: Request, path: str):\n        return response.redirect(\n            request.app.url_for(\n                \"Redirect.proxy\",\n                path=path,\n                _server=request.app.ctx.main_app.config.SERVER_NAME,\n                _external=True,\n                _scheme=\"https\",\n            ),\n            status=301,\n        )\n    ```", "```py\n    f\"https://{request.app.ctx.main_app.config.SERVER_NAME}{request.path}\"\n    ```", "```py\n    $ sanic wadsworth.applications.server:create_app \\\n        --factory --workers=2 --port=8443 \\\n        --cert=./wadsworth/certs/cert.pem \\\n        --key=./wadsworth/certs/key.pem\n    ```", "```py\n    $ curl http://localhost:8080/info\n    {\"server\":\"RedirectApp\"}\n    That looks right.\n    $ curl -k https://localhost:8443/info   \n    {\"server\":\"MainApp\"}\n    ```", "```py\n    $ curl -kiL http://localhost:8080/v1/hello/Adam      \n    HTTP/1.1 301 Moved Permanently\n    Location: https://localhost:8443/v1/hello/Adam\n    content-length: 0\n    connection: keep-alive\n    content-type: text/html; charset=utf-8\n    HTTP/1.1 200 OK\n    content-length: 16\n    connection: keep-alive\n    content-type: application/json\n    {\"hello\":\"Adam\"}\n    ```"]