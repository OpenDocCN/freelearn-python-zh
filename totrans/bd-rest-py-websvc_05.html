<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0; Developing RESTful APIs with Flask"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5.  Developing RESTful APIs with Flask </h1></div></div></div><p>In this chapter, we will start working with Flask and its Flask-RESTful extension; we will also create a RESTful Web API that performs CRUD operations on a simple list. We will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Design a RESTful API that performs CRUD operations in Flask with the Flask-RESTful extension</li><li class="listitem" style="list-style-type: disc">Understand the tasks performed by each HTTP method</li><li class="listitem" style="list-style-type: disc">Set up the virtual environment with Flask and its Flask-RESTful extension</li><li class="listitem" style="list-style-type: disc">Declare status codes for the responses</li><li class="listitem" style="list-style-type: disc">Create the model to represent a resource</li><li class="listitem" style="list-style-type: disc">Use a dictionary as a repository</li><li class="listitem" style="list-style-type: disc">Configure output fields for serialized responses</li><li class="listitem" style="list-style-type: disc">Work with resourceful routing on top of Flask pluggable views</li><li class="listitem" style="list-style-type: disc">Configure resource routing and endpoints</li><li class="listitem" style="list-style-type: disc">Make HTTP requests to the Flask API</li><li class="listitem" style="list-style-type: disc">Work with command-line tools to interact with the Flask API</li><li class="listitem" style="list-style-type: disc">Work with GUI tools to interact with the Flask API</li></ul></div><div class="section" title="Designing a RESTful API to interact with a simple data source"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Designing a RESTful API to interact with a simple data source</h1></div></div></div><p>Imagine that we have to configure the messages to be displayed in an OLED display wired to an <span class="strong"><strong>IoT</strong></span> (<span class="strong"><strong>Internet of Things</strong></span>) device, the IoT device is capable of running Python 3.5, Flask, and other Python packages. There is a team that is writing code that retrieves string messages from a dictionary and displays them in the OLED display wired to the IoT device. We have to start working on a mobile app and a website that has to interact with a RESTful API to perform CRUD operations with string messages.</p><p>We don't need an ORM because we won't persist the string messages on a database. We will just work with an in-memory dictionary as our data source. It is one of the requirements for this RESTful API. In this case, the RESTful web service will be running on the IoT device, that is, we will run the Flask development server on the IoT device.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip39"/>Tip</h3><p>We will definitely lose scalability for our RESTful API because we have the in-memory data source in the server, and therefore, we cannot run the RESTful API in another IoT device. However, we will work with another example related to a more complex data source that will be able to scale in the RESTful way later. The first example is going to allow us to understand how Flask and Flask-RESTful work together with a very simple in-memory data source.</p></div></div><p>We have chosen Flask because it is more lightweight than Django, we don't need to configure an ORM and we want to start running the RESTful API on the IoT device, as soon as possible, to allow all the teams to interact with it. We will code the website with Flask too, and therefore, we want to use the same web micro-framework to power the website and the RESTful web service.</p><p>There are many extensions available for Flask that makes it easier to perform specific tasks with the Flask micro-framework. We will take advantage of Flask-RESTful, an extension that will allow us to encourage best practices while building our RESTful API. In this case, we will work with a Python dictionary as the data source. As previously explained, we will work with more complex data sources in the forthcoming examples.</p><p>First, we must specify the requirements for our main resource: a message. We need the following attributes or fields for a message:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An integer identifier</li><li class="listitem" style="list-style-type: disc">A string message</li><li class="listitem" style="list-style-type: disc">A duration in seconds that indicates the time the message has to be printed on the OLED display</li><li class="listitem" style="list-style-type: disc">A creation date and time-the timestamp will be added automatically when adding a new message to the collection</li><li class="listitem" style="list-style-type: disc">A message category description, such as "Warning" and "Information"</li><li class="listitem" style="list-style-type: disc">An integer counter that indicates the times the message has been printed in the OLED display</li><li class="listitem" style="list-style-type: disc">A <code class="literal">bool</code> value indicating whether the message was printed at least once on the OLED display</li></ul></div><p>The following table shows the HTTP verbs, the scope, and the semantics for the methods that our first version of the API must support. Each method is composed by an HTTP verb and a scope and all the methods have a well-defined meaning for all the messages and collections. In our API, each message has its own unique URL.</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<span class="strong"><strong>HTTP verb</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Scope</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Semantics</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of messages</p>
</td><td>
<p>Retrieve all the stored messages in the collection, sorted by their name in ascending order</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>Retrieve a single message</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of messages</p>
</td><td>
<p>Create a new message in the collection</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>Update a field for an existing message</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>Delete an existing message</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Understanding the tasks performed by each HTTP method"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Understanding the tasks performed by each HTTP method</h1></div></div></div><p>Let's consider that <code class="literal">http://localhost:5000/api/messages/</code> is the URL for the collection of messages. If we add a number to the preceding URL, we identify a specific message whose id is equal to the specified numeric value. For example, <code class="literal">http://localhost:5000/api/messsages/6</code> identifies the message whose id is equal to <code class="literal">6</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip40"/>Tip</h3><p>We want our API to be able to differentiate collections from a single resource of the collection in the URLs. When we refer a collection, we will use a slash (<code class="literal">/</code>) as the last character for the URL, as in <code class="literal">http://localhost:5000/api/messages/</code>. When we refer to a single resource of the collection we won't use a slash (<code class="literal">/</code>) as the last character for the URL, as in <code class="literal">http://localhost:5000/api/messages/6</code>.</p></div></div><p>We have to compose and send an HTTP request with the <code class="literal">POST</code> HTTP verb and the <code class="literal">http://localhost:5000/api/messages/</code> request URL to create a new message. In addition, we have to provide the JSON key-value pairs with the field names and the values to create the new message. As a result of the request, the server will validate the provided values for the fields, make sure that it is a valid message, and persist it in the messages dictionary.</p><p>The server will return a <code class="literal">201 Created</code> status code and a JSON body with the recently added message serialized to JSON, including the assigned id that was automatically generated by the server to the message object:</p><pre class="programlisting">POST http://localhost:5000/api/messages/ 
</pre><p>We have to compose and send an HTTP request with the <code class="literal">GET</code> HTTP verb and the <code class="literal">http://localhost:5000/api/messages/{id}</code> request URL to retrieve the message whose id matches the specified numeric value in the place where <code class="literal">{id}</code> is written. For example, if we use the request URL <code class="literal">http://localhost:5000/api/messages/82</code>, the server will retrieve the game whose id matches 82. As a result of the request, the server will retrieve a message with the specified id from the dictionary.</p><p>If a message is found, the server will serialize the message object into JSON and return a <code class="literal">200 OK</code> status code and a JSON body with the serialized message object. If no message matches the specified id or primary key, the server will return a <code class="literal">404 Not Found</code> status: </p><pre class="programlisting">GET http://localhost:5000/api/messages/{id} 
</pre><p>We have to compose and send an HTTP request with the <code class="literal">PATCH</code> HTTP verb and the <code class="literal">http://localhost:5000/api/messages/{id}</code> request URL to update one or more fields for the message whose id matches the specified numeric value in the place where <code class="literal">{id}</code> is written. In addition, we have to provide the JSON key-value pairs with the field names to be updated and their new values. As a result of the request, the server will validate the provided values for the fields, update these fields on the message that matches the specified id, and update the message in the dictionary, if it is a valid message.</p><p>The server will return a <code class="literal">200 OK</code> status code and a JSON body with the recently updated game serialized to JSON. If we provide invalid data for the fields to be updated, the server will return a <code class="literal">400 Bad Request</code> status code. If the server doesn't find a message with the specified id, the server will return just a <code class="literal">404 Not Found</code> status:</p><pre class="programlisting">PATCH http://localhost:5000/api/messages/{id} 
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip41"/>Tip</h3><p>The PATCH method will allow us to easily update two fields for a message: the integer counter, that indicates the times the message has been printed and the bool value, that specifies whether the message was printed at least once.</p></div></div><p>We have to compose and send an HTTP request with the <code class="literal">DELETE</code> HTTP verb and the <code class="literal">http://localhost:5000/api/messages/{id}</code> request URL to remove the message whose id matches the specified numeric value in the place where <code class="literal">{id}</code> is written. For example, if we use the request URL <code class="literal">http://localhost:5000/api/messages/15</code>, the server will delete the message whose <code class="literal">id</code> matches <code class="literal">15</code>. As a result of the request, the server will retrieve a message with the specified id from the dictionary. If a message is found, the server will request the dictionary to delete the entry associated with this message object and return a <code class="literal">204 No Content</code> status code. If no message matches the specified id, the server will return a <code class="literal">404 Not Found</code> status:</p><pre class="programlisting">DELETE http://localhost:5000/api/messages/{id} 
</pre></div>
<div class="section" title="Setting up a virtual environment with Flask and Flask-RESTful"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec61"/>Setting up a virtual environment with Flask and Flask-RESTful</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>
<span class="emphasis"><em>, </em></span>
<span class="emphasis"><em>Developing RESTful APIs with Django</em></span>, we learned that, throughout this book, we were going to work with the lightweight virtual environments introduced in Python 3.4 and improved in Python 3.4. Now, we will follow the steps to create a new lightweight virtual environment to work with Flask and Flask-RESTful. It is highly recommended to read <span class="emphasis"><em>
<a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, </em></span>
<span class="emphasis"><em>Developing RESTful APIs with Django</em></span>, in case you don't have experience with lightweight virtual environments in Python. The chapter includes all the detailed explanations of the effects of the steps we are going to follow.</p><p>First, we have to select the target folder or directory for our virtual environment. We will use the following path in the example for macOS and Linux. The target folder for the virtual environment will be the <code class="literal">PythonREST/Flask01</code> folder within our home directory. For example, if our home directory in macOS or Linux is <code class="literal">/Users/gaston</code>, the virtual environment will be created within <code class="literal">/Users/gaston/PythonREST/Flask01</code>. You can replace the specified path with your desired path in each command, as shown:</p><pre class="programlisting">~/PythonREST/Flask01 
</pre><p>We will use the following path in the example for Windows. The target folder for the virtual environment will be the <code class="literal">PythonREST\Flask01</code> folder within our user profile folder. For example, if our user profile folder is <code class="literal">C:\Users\Gaston</code>, the virtual environment will be created within <code class="literal">C:\Users\gaston\PythonREST\Flask01</code>. You can replace the specified path with your desired path in each command, as shown:</p><pre class="programlisting">%USERPROFILE%\PythonREST\Flask01 
</pre><p>Open a Terminal in macOS or Linux and execute the following command to create a virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>python3 -m venv ~/PythonREST/Flask01</strong></span>
</pre><p>In Windows, execute the following command to create a virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>python -m venv %USERPROFILE%\PythonREST\Flask01</strong></span>
</pre><p>The preceding command doesn't produce any output. Now that we have created a virtual environment, we will run a platform-specific script to activate it. After we activate the virtual environment, we will install packages that will only be available in this virtual environment.</p><p>If your Terminal is configured to use the <code class="literal">bash</code> shell in macOS or Linux, run the following command to activate the virtual environment. The command also works for the <code class="literal">zsh</code> shell:</p><pre class="programlisting">
<span class="strong"><strong>source ~/PythonREST/Flask01/bin/activate</strong></span>
</pre><p>If your Terminal is configured to use either the <code class="literal">csh</code> or <code class="literal">tcsh</code> shell, run the following command to activate the virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>source ~/PythonREST/Flask01/bin/activate.csh</strong></span>
</pre><p>If your Terminal is configured to use either the <code class="literal">fish</code> shell, run the following command to activate the virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>source ~/PythonREST/Flask01/bin/activate.fish</strong></span>
</pre><p>In Windows, you can run either a batch file in the Command Prompt or a Windows PowerShell script to activate the virtual environment. If you prefer the Command Prompt, run the following command in the Windows command line to activate the virtual environment:</p><pre class="programlisting">
<span class="strong"><strong>%USERPROFILE%\PythonREST\Flask01\Scripts\activate.bat</strong></span>
</pre><p>If you prefer the Windows PowerShell, launch it and run the following commands to activate the virtual environment. However, note that you should have the scripts execution enabled in Windows PowerShell to be able to run the script:</p><pre class="programlisting">
<span class="strong"><strong>cd $env:USERPROFILE</strong></span>
<span class="strong"><strong>PythonREST\Flask01\Scripts\Activate.ps1</strong></span>
</pre><p>After you activate the virtual environment, the Command Prompt will display the virtual environment root folder name, enclosed in parenthesis, as a prefix for the default prompt, to remind us that we are working in the virtual environment. In this case, we will see (<code class="literal">Flask01</code>) as a prefix for the Command Prompt because the root folder for the activated virtual environment is <code class="literal">Flask01</code>.</p><p>We have created and activated a virtual environment. Now it is time to run the commands that will be the same for macOS, Linux, or Windows; we must run the following command to install Flask-RESTful with pip. Flask is a dependency for Flask-RESTful, and therefore, pip will install it automatically, too:</p><pre class="programlisting">
<span class="strong"><strong>pip install flask-restful</strong></span>
</pre><p>The last lines for the output will indicate all the packages that have been successfully installed, including <code class="literal">flask-restful</code> and <code class="literal">Flask</code>:</p><pre class="programlisting">
<span class="strong"><strong>Installing collected packages: six, pytz, click, itsdangerous, MarkupSafe, Jinja2, Werkzeug, Flask, python-dateutil, aniso8601, flask-restful</strong></span>
<span class="strong"><strong>  Running setup.py install for click</strong></span>
<span class="strong"><strong>  Running setup.py install for itsdangerous</strong></span>
<span class="strong"><strong>  Running setup.py install for MarkupSafe</strong></span>
<span class="strong"><strong>  Running setup.py install for aniso8601</strong></span>
<span class="strong"><strong>Successfully installed Flask-0.11.1 Jinja2-2.8 MarkupSafe-0.23 Werkzeug-0.11.10 aniso8601-1.1.0 click-6.6 flask-restful-0.3.5 itsdangerous-0.24 python-dateutil-2.5.3 pytz-2016.4 six-1.10.0</strong></span>
</pre></div>
<div class="section" title="Declaring status codes for the responses"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Declaring status codes for the responses</h1></div></div></div><p>Neither Flask nor Flask-RESTful includes the declaration of variables for the different HTTP status codes. We don't want to return numbers as status codes. We want our code to be easy to read and understand, and therefore, we will use descriptive HTTP status codes. We will borrow the code that declares useful functions and variables related to HTTP status codes from the <code class="literal">status.py</code> file included in Django REST Framework, that is, the framework we have been using in the preceding chapters.</p><p>First, create a folder named <code class="literal">api</code> within the root folder for the recently created virtual environment, and then create a new <code class="literal">status.py</code> file within the <code class="literal">api</code> folder. The following lines show the code that declares functions and variables with descriptive HTTP status codes in the <code class="literal">api/models.py</code> file borrowed from the <code class="literal">rest_framework.status</code> module. We don't want to reinvent the wheel, and the module provides everything we need to work with HTTP status codes in our Flask-based API. The code file for the sample is included in the <code class="literal">restful_python_chapter_05_01</code> folder:</p><pre class="programlisting">def is_informational(code): 
    return code &gt;= 100 and code &lt;= 199 
 
 
def is_success(code): 
    return code &gt;= 200 and code &lt;= 299 
 
 
def is_redirect(code): 
    return code &gt;= 300 and code &lt;= 399 
 
 
def is_client_error(code): 
    return code &gt;= 400 and code &lt;= 499 
 
 
def is_server_error(code): 
    return code &gt;= 500 and code &lt;= 599 
 
 
HTTP_100_CONTINUE = 100 
HTTP_101_SWITCHING_PROTOCOLS = 101 
HTTP_200_OK = 200 
HTTP_201_CREATED = 201 
HTTP_202_ACCEPTED = 202 
HTTP_203_NON_AUTHORITATIVE_INFORMATION = 203 
HTTP_204_NO_CONTENT = 204 
HTTP_205_RESET_CONTENT = 205 
HTTP_206_PARTIAL_CONTENT = 206 
HTTP_300_MULTIPLE_CHOICES = 300 
HTTP_301_MOVED_PERMANENTLY = 301 
HTTP_302_FOUND = 302 
HTTP_303_SEE_OTHER = 303 
HTTP_304_NOT_MODIFIED = 304 
HTTP_305_USE_PROXY = 305 
HTTP_306_RESERVED = 306 
HTTP_307_TEMPORARY_REDIRECT = 307 
HTTP_400_BAD_REQUEST = 400 
HTTP_401_UNAUTHORIZED = 401 
HTTP_402_PAYMENT_REQUIRED = 402 
HTTP_403_FORBIDDEN = 403 
HTTP_404_NOT_FOUND = 404 
HTTP_405_METHOD_NOT_ALLOWED = 405 
HTTP_406_NOT_ACCEPTABLE = 406 
HTTP_407_PROXY_AUTHENTICATION_REQUIRED = 407 
HTTP_408_REQUEST_TIMEOUT = 408 
HTTP_409_CONFLICT = 409 
HTTP_410_GONE = 410 
HTTP_411_LENGTH_REQUIRED = 411 
HTTP_412_PRECONDITION_FAILED = 412 
HTTP_413_REQUEST_ENTITY_TOO_LARGE = 413 
HTTP_414_REQUEST_URI_TOO_LONG = 414 
HTTP_415_UNSUPPORTED_MEDIA_TYPE = 415 
HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE = 416 
HTTP_417_EXPECTATION_FAILED = 417 
HTTP_428_PRECONDITION_REQUIRED = 428 
HTTP_429_TOO_MANY_REQUESTS = 429 
HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE = 431 
HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS = 451 
HTTP_500_INTERNAL_SERVER_ERROR = 500 
HTTP_501_NOT_IMPLEMENTED = 501 
HTTP_502_BAD_GATEWAY = 502 
HTTP_503_SERVICE_UNAVAILABLE = 503 
HTTP_504_GATEWAY_TIMEOUT = 504 
HTTP_505_HTTP_VERSION_NOT_SUPPORTED = 505 
HTTP_511_NETWORK_AUTHENTICATION_REQUIRED = 511 
</pre><p>The code declares five functions that receive the HTTP status code in the code argument and determine which of the following categories the status code belongs to: informational, success, redirect, client error, or server error categories. We will use the previous variables when we have to return a specific status code. For example, in case we have to return a <code class="literal">404 Not Found</code> status code, we will return <code class="literal">status.HTTP_404_NOT_FOUND</code>, instead of just <code class="literal">404</code>.</p></div>
<div class="section" title="Creating the model"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec63"/>Creating the model</h1></div></div></div><p>Now, we will create a simple <code class="literal">MessageModel</code> class that we will use to represent messages. Remember that we won't be persisting the model in the database, and therefore, in this case, our class will just provide the required attributes and no mapping information. Create a new <code class="literal">models.py</code> file in the <code class="literal">api</code> folder. The following lines show the code that creates a <code class="literal">MessageModel</code> class in the <code class="literal">api/models.py</code> file. The code file for the sample is included in the <code class="literal">restful_python_chapter_05_01</code> folder:</p><pre class="programlisting">class MessageModel: 
    def __init__(self, message, duration, creation_date, message_category): 
        # We will automatically generate the new id 
        self.id = 0 
        self.message = message 
        self.duration = duration 
        self.creation_date = creation_date 
        self.message_category = message_category 
        self.printed_times = 0 
        self.printed_once = False 
</pre><p>The <code class="literal">MessageModel</code> class just declares a constructor, that is, the <code class="literal">__init__</code> method. This method receives many arguments and then uses them to initialize the attributes with the same names: <code class="literal">message</code>, <code class="literal">duration</code>, <code class="literal">creation_date</code>, and <code class="literal">message_category</code>. The <code class="literal">id</code> attribute is set to 0, <code class="literal">printed_times</code> is set to <code class="literal">0</code>, and <code class="literal">printed_once</code> is set to <code class="literal">False</code>. We will automatically increment the identifier for each new message generated with API calls.</p></div>
<div class="section" title="Using a dictionary as a repository"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec64"/>Using a dictionary as a repository</h1></div></div></div><p>Now, we will create a <code class="literal">MessageManager</code> class that we will use to persist the <code class="literal">MessageModel</code> instances in an in-memory dictionary. Our API methods will call methods for the <code class="literal">MessageManager</code> class to retrieve, insert, update, and delete <code class="literal">MessageModel</code> instances. Create a new <code class="literal">api.py</code> file in the <code class="literal">api</code> folder. The following lines show the code that creates a <code class="literal">MessageManager</code> class in the <code class="literal">api/api.py</code> file. In addition, the following lines declare all the <code class="literal">imports</code> we will need for all the code we will write in this file. The code file for the sample is included in the <code class="literal">restful_python_chapter_05_01</code> folder.</p><pre class="programlisting">from flask import Flask 
from flask_restful import abort, Api, fields, marshal_with, reqparse, Resource 
from datetime import datetime 
from models import MessageModel 
import status 
from pytz import utc 
 
 
class MessageManager(): 
    last_id = 0 
    def __init__(self): 
        self.messages = {} 
 
    def insert_message(self, message): 
        self.__class__.last_id += 1 
        message.id = self.__class__.last_id 
        self.messages[self.__class__.last_id] = message 
 
    def get_message(self, id): 
        return self.messages[id] 
 
    def delete_message(self, id): 
         del self.messages[id] 
</pre><p>The <code class="literal">MessageManager</code> class declares a <code class="literal">last_id</code> class attribute and initializes it to 0. This class attribute stores the last id that has been generated and assigned to a <code class="literal">MessageModel</code> instance stored in a dictionary. The constructor, that is, the <code class="literal">__init__</code> method, creates and initializes the <code class="literal">messages</code> attribute as an empty dictionary.</p><p>The code declares the following three methods for the class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">insert_message</code>: This method receives a recently created <code class="literal">MessageModel</code> instance in the <code class="literal">message</code> argument. The code increases the value for the <code class="literal">last_id</code> class attribute and then assigns the resulting value to the id for the received message. The code uses <code class="literal">self.__class__</code> to reference the type of the current instance. Finally, the code adds the <code class="literal">message</code> as a value to the key identified with the generated id, <code class="literal">last_id</code>, in the <code class="literal">self.messages</code> dictionary.</li><li class="listitem" style="list-style-type: disc"><code class="literal">get_message</code>: This method receives the <code class="literal">id</code> of the message that has to be retrieved from the <code class="literal">self.messages</code> dictionary. The code returns the value related to the key that matches the received <code class="literal">id</code> in the <code class="literal">self.messages</code> dictionary that we are using as our data source.</li><li class="listitem" style="list-style-type: disc"><code class="literal">delete_message</code>: This method receives the <code class="literal">id</code> of the message that has to be removed from the <code class="literal">self.messages</code> dictionary. The code deletes the key-value pair whose key matches the received id in the <code class="literal">self.messages</code> dictionary that we are using as our data source.</li></ul></div><p>We don't need a method to update a message because we will just make changes to the attributes of the <code class="literal">MessageModel</code> instance that is already stored in the <code class="literal">self.messages</code> dictionary. The value stored in the dictionary is a reference to the <code class="literal">MessageModel</code> instance that we are updating, and therefore, we don't need to call a specific method to update the instance in the dictionary. However, in case we were working with a database, we would need to call an update method for our ORM or data repository.</p></div>
<div class="section" title="Configuring output fields"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec65"/>Configuring output fields</h1></div></div></div><p>Now, we will create a <code class="literal">message_fields</code> dictionary that we will use to control the data that we want Flask-RESTful to render in our response, when we return <code class="literal">MessageModel</code> instances. Open the previously created <code class="literal">api/api.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_05_01</code> folder.</p><pre class="programlisting">message_fields = { 
    'id': fields.Integer, 
    'uri': fields.Url('message_endpoint'), 
    'message': fields.String, 
    'duration': fields.Integer, 
    'creation_date': fields.DateTime, 
    'message_category': fields.String, 
    'printed_times': fields.Integer, 
    'printed_once': fields.Boolean 
} 
 
 
message_manager = MessageManager() 
</pre><p>We declared the <code class="literal">message_fields</code> dictionary (<code class="literal">dict</code>) with key-value pairs of strings and classes declared in the <code class="literal">flask_restful.fields</code> module. The keys are the names of the attributes we want to render from the <code class="literal">MessageModel</code> class and the values are the classes that format and return the value for the field. In the previous code, we worked with the following classes, that format and return the value for the specified field in the key:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">field.Integer</code>: Outputs an integer value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fields.Url</code>: Generates a string representation of a URL. By default, this class generates a relative URI for the resource that is being requested. The code specifies <code class="literal">'message_endpoint'</code> for the <code class="literal">endpoint</code> argument. This way, the class will use the specified endpoint name. We will declare this endpoint later in the <code class="literal">api.py</code> file. We don't want to include the hostname in the generated URI, and therefore, we use the default value for the <code class="literal">absolute</code> bool attribute, which is <code class="literal">False</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fields.DateTime</code>: Outputs a formatted <code class="literal">datetime</code> string in UTC, in the default RFC 822 format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fields.Boolean</code>: Generates a string representation of a bool value.</li></ul></div><p>The <code class="literal">'uri'</code> field uses <code class="literal">fields.Url</code> and it is related to the specified endpoint instead of being associated to an attribute of the <code class="literal">MessageModel</code> class. It is the only case in which the specified field name doesn't have an attribute in the <code class="literal">MessageModel</code> class. The other strings specified as keys indicate all the attributes we want to be rendered in the output when we use the <code class="literal">message_fields</code> dictionary to make up the final serialized response output.</p><p>After we declared the <code class="literal">message_fields</code> dictionary, the next line of code creates an instance of the previously created <code class="literal">MessageManager</code> class named <code class="literal">message_manager</code>. We will use this instance to create, retrieve, and delete <code class="literal">MessageModel</code> instances.</p></div>
<div class="section" title="Working with resourceful routing on top of Flask pluggable views"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec66"/>Working with resourceful routing on top of Flask pluggable views</h1></div></div></div><p>Flask-RESTful uses resources built on top of Flask pluggable views as the main building block for a RESTful API. We just need to create a subclass of the <code class="literal">flask_restful.Resource</code> class and declare the methods for each supported HTTP verb. A subclass of <code class="literal">flask_restful.Resource</code> represents a RESTful resource and therefore, we will have to declare one class to represent the collection of messages and another one to represent the message resource.</p><p>First, we will create a <code class="literal">Message</code> class that we will use to represent the message resource. Open the previously created <code class="literal">api/api.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_05_01</code> folder, as shown:</p><pre class="programlisting">class Message(Resource): 
    def abort_if_message_doesnt_exist(self, id): 
        if id not in message_manager.messages: 
            abort( 
                status.HTTP_404_NOT_FOUND,  
                message="Message {0} doesn't exist".format(id)) 
 
   <span class="strong"><strong> @marshal_with(message_fields) 
    def get(self, id):</strong></span> 
        self.abort_if_message_doesnt_exist(id) 
        return message_manager.get_message(id) 
 
   <span class="strong"><strong> def delete(self, id):</strong></span> 
        self.abort_if_message_doesnt_exist(id) 
        message_manager.delete_message(id) 
        return '', status.HTTP_204_NO_CONTENT 
 
   <span class="strong"><strong> @marshal_with(message_fields) 
    def patch(self, id):</strong></span> 
        self.abort_if_message_doesnt_exist(id) 
        message = message_manager.get_message(id) 
        parser = reqparse.RequestParser() 
        parser.add_argument('message', type=str) 
        parser.add_argument('duration', type=int) 
        parser.add_argument('printed_times', type=int) 
        parser.add_argument('printed_once', type=bool) 
        args = parser.parse_args() 
        if 'message' in args: 
            message.message = args['message'] 
        if 'duration' in args: 
            message.duration = args['duration'] 
        if 'printed_times' in args: 
            message.printed_times = args['printed_times'] 
        if 'printed_once' in args: 
            message.printed_once = args['printed_once'] 
        return message 
</pre><p>The <code class="literal">Message</code> class is a subclass of <code class="literal">flask_restful.Resource</code> and declares the following three methods, that will be called when the HTTP method with the same name arrives as a request on the represented resource:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>: This method receives the id of the message that has to be retrieved in the <code class="literal">id</code> argument. The code calls the <code class="literal">self.abort_if_message_doesnt_exist</code> method to abort in case there is no message with the requested id. In case the message exists, the code returns the <code class="literal">MessageModel</code> instance whose <code class="literal">id</code> that matches the specified <code class="literal">id</code> returned by the <code class="literal">message_manager.get_message</code> method. The <code class="literal">get</code> method uses the <code class="literal">@marshal_with</code> decorator with <code class="literal">message_fields</code> as an argument. The decorator will take the <code class="literal">MessageModel</code> instance and apply the field filtering and output formatting specified in <code class="literal">message_fields</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code>: This method receives the id of the message that has to be deleted in the <code class="literal">id</code> argument. The code calls the <code class="literal">self.abort_if_message_doesnt_exist</code> method to abort, in case there is no message with the requested id. In case the <code class="literal">```</code>message exists, the code calls the <code class="literal">message_manager.delete_message</code> method with the received id as an argument to remove the <code class="literal">MessageModel</code> instance from our data repository. Then, the code returns an empty response body and a <code class="literal">204 No Content</code> status code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">patch</code>: This method receives the id of the message that has to be updated or patched in the <code class="literal">id</code> argument. The code calls the <code class="literal">self.abort_if_message_doesnt_exist</code> method to abort in case there is no message with the requested id. In case the message exists, the code saves the <code class="literal">MessageModel</code> instance whose <code class="literal">id</code> that matches the specified <code class="literal">id</code> returned by the <code class="literal">message_manager.get_message</code> method in the <code class="literal">message</code> variable. The next line creates a <code class="literal">flask_restful.reqparse.RequestParser</code> instance named <code class="literal">parser</code>. The <code class="literal">RequestParser</code> instance allows us to add arguments with their names and types and then easily parse the arguments received with the request. The code makes four calls to the <code class="literal">parser.add_argument</code> with the argument name and the type of the four arguments we want to parse. Then, the code calls the <code class="literal">parser.parse_args</code> method to parse all the arguments from the request and saves the returned dictionary (<code class="literal">dict</code>) in the <code class="literal">args</code> variable. The code updates all the attributes that have new values in the <code class="literal">args</code> dictionary in the <code class="literal">MessageModel</code> instance: <code class="literal">message</code>. In case the request didn't include values for certain fields, the code won't make changes to the realted attributes. The request doesn't require to include the four fields that can be updated with values. The code returns the updated <code class="literal">message</code>. The <code class="literal">patch</code> method uses the <code class="literal">@marshal_with</code> decorator with <code class="literal">message_fields</code> as an argument. The decorator will take the <code class="literal">MessageModel</code> instance, <code class="literal">message</code>, and apply the field filtering and output formatting specified in <code class="literal">message_fields</code>.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip42"/>Tip</h3><p>We used multiple return values to set the response code.</p></div></div><p>As previously explained, the three methods call the internal <code class="literal">abort_if_message_doesnt_exist</code> method that receives the id for an existing <code class="literal">MessageModel</code> instance in the <code class="literal">id</code> argument. If the received <code class="literal">id</code> is not present in the keys of the <code class="literal">message_manager.messages</code> dictionary, the method calls the <code class="literal">flask_restful.abort</code> function with <code class="literal">status.HTTP_404_NOT_FOUND</code> as the <code class="literal">http_status_code</code> argument and a message indicating that the message with the specified id doesn't exists. The <code class="literal">abort</code> function raises an <code class="literal">HTTPException</code> for the received <code class="literal">http_status_code</code> and attaches the additional keyword arguments to the exception for later processing. In this case, we generate an HTTP <code class="literal">404 Not Found</code> status code.</p><p>Both the <code class="literal">get</code> and <code class="literal">patch</code> methods use the <code class="literal">@marshal_with</code> decorator that takes a single data object or a list of data objects and applies the field filtering and output formatting specifies as an argument. The marshalling can also work with dictionaries (dicts). In both methods, we specified <code class="literal">message_fields</code> as an argument, and therefore, the code renders the following fields: <code class="literal">id</code>, <code class="literal">uri</code>, <code class="literal">message</code>, <code class="literal">duration</code>, <code class="literal">creation_date</code>, <code class="literal">message_category</code>, <code class="literal">printed_times</code> and <code class="literal">printed_once</code>. When we use the <code class="literal">@marshal_with</code> decorator, we are automatically returning an HTTP 200 <code class="literal">OK</code> status code.</p><p>The following <code class="literal">return</code> statement with the <code class="literal">@marshal_with(message_fields)</code> decorator returns an <code class="literal">HTTP 200 OK</code> status code because we didn't specify any status code after the returned object (<code class="literal">message</code>):</p><pre class="programlisting">return message 
</pre><p>The next line is the line of code that is really executed with the <code class="literal">@marshal_with(message_fields)</code> decorator, and we can use it instead of working with the decorator:</p><pre class="programlisting">return marshal(message, resource_fields), status.HTTP_200_OK 
</pre><p>For example, we can call the <code class="literal">marshal</code> function as shown in the previous line instead of using the <code class="literal">@marshal_with</code> decorator and the code will produce the same result.</p><p>Now, we will create a <code class="literal">MessageList</code> class that we will use to represent the collection of messages. Open the previously created <code class="literal">api/api.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_05_01</code> folder:</p><pre class="programlisting">class MessageList(Resource): 
    <span class="strong"><strong>@marshal_with(message_fields) 
    def get(self):</strong></span> 
        return [v for v in message_manager.messages.values()] 
 
   <span class="strong"><strong> @marshal_with(message_fields) 
    def post(self):</strong></span> 
        parser = reqparse.RequestParser() 
        parser.add_argument('message', type=str, required=True, help='Message cannot be blank!') 
        parser.add_argument('duration', type=int, required=True, help='Duration cannot be blank!') 
        parser.add_argument('message_category', type=str, required=True, help='Message category cannot be blank!') 
        args = parser.parse_args() 
        message = MessageModel( 
            message=args['message'], 
            duration=args['duration'], 
            creation_date=datetime.now(utc), 
            message_category=args['message_category'] 
            ) 
        message_manager.insert_message(message)  
        return message, status.HTTP_201_CREATED 
</pre><p>The <code class="literal">MessageList</code> class is a subclass of <code class="literal">flask_restful.Resource</code> and declares the following two methods that will be called when the HTTP method with the same name arrives as a request on the represented resource:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>: This method returns a list with all the <code class="literal">MessageModel</code> instances saved in the <code class="literal">message_manager.messages</code> dictionary. The <code class="literal">get</code> method uses the <code class="literal">@marshal_with</code> decorator with <code class="literal">message_fields</code> as an argument. The decorator will take each <code class="literal">MessageModel</code> instance in the returned list and apply the field filtering and output formatting specified in <code class="literal">message_fields</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">post</code>: This method creates a <code class="literal">flask_restful.reqparse.RequestParser</code> instance named <code class="literal">parser</code>. The <code class="literal">RequestParser</code> instance allows us to add arguments with their names and types and then easily parse the arguments received with the <code class="literal">POST</code> request to create a new <code class="literal">MessageModel</code> instance. The code makes three calls to the <code class="literal">parser.add_argument</code> with the argument name and the type of the three arguments we want to parse. Then, the code calls the <code class="literal">parser.parse_args</code> method to parse all the arguments from the request and saves the returned dictionary (<code class="literal">dict</code>) in the <code class="literal">args</code> variable. The code uses the parsed arguments in the dictionary to specify the values for the <code class="literal">message</code>, <code class="literal">duration</code> and <code class="literal">message_category</code> attributes to create a new <code class="literal">MessageModel</code> instance and save it in the <code class="literal">message</code> variable. The value for the <code class="literal">creation_date</code> argument is set to the current <code class="literal">datetime</code> with time zone info, and therefore, it isn't parsed from the request. Then, the code calls the <code class="literal">message_manager.insert_message</code> method with the new <code class="literal">MessageModel</code> instance (<code class="literal">message</code>) to add this new instance to the dictionary. The <code class="literal">post</code> method uses the <code class="literal">@marshal_with</code> decorator with <code class="literal">message_fields</code> as an argument. The decorator will take the recently created and stored <code class="literal">MessageModel</code> instance, <code class="literal">message</code>, and apply the field filtering and output formatting specified in <code class="literal">message_fields</code>. The code returns an HTTP <code class="literal">201 Created</code> status code.</li></ul></div><p>The following table shows the method of our previously created classes that we want to be executed for each combination of HTTP verb and scope:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<span class="strong"><strong>HTTP verb</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Scope</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Class and method</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of messages</p>
</td><td>
<p>MessageList.get</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>Message.get</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of messages</p>
</td><td>
<p>MessageList.post</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>Message.patch</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>Message.delete</p>
</td></tr></tbody></table></div><p>If the request results in the invocation of a resource with an unsupported HTTP method, Flask-RESTful will return a response with the HTTP <code class="literal">405 Method Not Allowed</code> status code.</p></div>
<div class="section" title="Configuring resource routing and endpoints"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec67"/>Configuring resource routing and endpoints</h1></div></div></div><p>We must make the necessary resource routing configurations to call the appropriate methods and pass them all the necessary arguments by defining URL rules. The following lines create the main entry point for the application, initialize it with a Flask application and configure the resource routing for the <code class="literal">api</code>. Open the previously created <code class="literal">api/api.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_05_01</code> folder:</p><pre class="programlisting">app = Flask(__name__) 
api = Api(app) 
api.add_resource(MessageList, '/api/messages/') 
api.add_resource(Message, '/api/messages/&lt;int:id&gt;', endpoint='message_endpoint') 
 
 
if __name__ == '__main__': 
    app.run(debug=True) 
</pre><p>The code creates an instance of the <code class="literal">flask_restful.Api</code> class and saves it in the <code class="literal">api</code> variable. Each call to the <code class="literal">api.add_resource</code> method routes a URL to a resource, specifically to one of the previously declared subclasses of the <code class="literal">flask_restful.Resource</code> class. When there is a request to the API and the URL matches one of the URLs specified in the <code class="literal">api.add_resource</code> method, Flask will call the method that matches the HTTP verb in the request for the specified class. The method follows standard Flask routing rules.</p><p>For example, the following line will make an HTTP GET request to <code class="literal">/api/messages/</code> without any additional parameters to call the <code class="literal">MessageList.get</code> method:</p><pre class="programlisting">api.add_resource(MessageList, '/api/messages/') 
</pre><p>Flask will pass the URL variables to the called method as arguments. For example, the following line will make an HTTP <code class="literal">GET</code> request to <code class="literal">/api/messages/12</code> to call the <code class="literal">Message.get</code> method with <code class="literal">12</code> passed as the value for the <code class="literal">id</code> argument:</p><pre class="programlisting">api.add_resource(Message, '/api/messages/&lt;int:id&gt;', endpoint='message_endpoint') 
</pre><p>In addition, we can specify a string value for the endpoint argument to make it easy to reference the specified route in <code class="literal">fields.Url</code> fields. We pass the same endpoint name, <code class="literal">'message_endpoint'</code> as an argument in the <code class="literal">uri</code> field declared as <code class="literal">fields.Url</code> in the <code class="literal">message_fields</code> dictionary that we use to render each <code class="literal">MessageModel</code> instance. This way, <code class="literal">fields.Url</code> will generate a URI considering this route.</p><p>We just required a few lines of code to configure resource routing and endpoints. The last line just calls the <code class="literal">app.run</code> method to start the Flask application with the <code class="literal">debug</code> argument set to <code class="literal">True</code> to enable debugging. In this case, we start the application by calling the <code class="literal">run</code> method to immediately launch a local server. We could also achieve the same goal by using the <code class="literal">flask</code> command-line script. However, this option would require us to configure environment variables and the instructions are different for the platforms that we are covering in this book-macOS, Windows and Linux.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip43"/>Tip</h3><p>As with any other Web framework, you should never enable debugging in a production environment.</p></div></div></div>
<div class="section" title="Making HTTP requests to the Flask API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec68"/>Making HTTP requests to the Flask API</h1></div></div></div><p>Now, we can run the <code class="literal">api/api.py</code> script that launches Flask's development server to compose and send HTTP requests to our unsecure and simple Web API (we will definitely add security later). Execute the following command.</p><pre class="programlisting">
<span class="strong"><strong>python api/api.py</strong></span>
</pre><p>The following lines show the output after we execute the previous command. The development server is listening at port <code class="literal">5000</code>.</p><pre class="programlisting">
<span class="strong"><strong> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</strong></span>
<span class="strong"><strong> * Restarting with stat</strong></span>
<span class="strong"><strong> * Debugger is active!</strong></span>
<span class="strong"><strong> * Debugger pin code: 294-714-594</strong></span>
</pre><p>With the previous command, we will start Flask development server and we will only be able to access it in our development computer. The previous command starts the development server in the default IP address, that is, <code class="literal">127.0.0.1</code> (<code class="literal">localhost</code>). It is not possible to access this IP address from other computers or devices connected on our LAN. Thus, if we want to make HTTP requests to our API from other computers or devices connected to our LAN, we should use the development computer IP address, <code class="literal">0.0.0.0</code> (for IPv4 configurations) or <code class="literal">::</code> (for IPv6 configurations), as the desired IP address for our development server.</p><p>If we specify <code class="literal">0.0.0.0</code> as the desired IP address for IPv4 configurations, the development server will listen on every interface on port 5000. In addition, it is necessary to open the default port <code class="literal">5000</code> in our firewalls (software and/or hardware) and configure port-forwarding to the computer that is running the development server.</p><p>We just need to specify <code class="literal">'0.0.0.0'</code> as the value for the host argument in the call to the <code class="literal">app.run</code> method, specifically, the last line in the <code class="literal">api/api.py</code> file. The following line shows the new call to <code class="literal">app.run</code> that launches Flask's development server in an IPv4 configuration and allows requests to be made from other computers and devices connected to our LAN. The line generates an externally visible server. The code file for the sample is included in the <code class="literal">restful_python_chapter_05_02</code> folder:</p><pre class="programlisting">if __name__ == '__main__': 
   <span class="strong"><strong> app.run(host='0.0.0.0', debug=True)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip44"/>Tip</h3><p>If you decide to compose and send HTTP requests from other computers or devices connected to the LAN, remember that you have to use the development computer's assigned IP address instead of <code class="literal">localhost</code>. For example, if the computer's assigned IPv4 IP address is <code class="literal">192.168.1.103</code>, instead of <code class="literal">localhost:5000</code>, you should use <code class="literal">192.168.1.103:5000</code>. Of course, you can also use the host name instead of the IP address. The previously explained configurations are very important because mobile devices might be the consumers of our RESTful APIs and we will always want to test the apps that make use of our APIs in our development environments. In addition, we can work with useful tools such as ngrok that allow us to generate secure tunnels to localhost. You can read more information about ngrok at <a class="ulink" href="http://www.ngrok.com">http://www.ngrok.com</a>.</p></div></div><p>The Flask development server is running on localhost (<code class="literal">127.0.0.1</code>), listening on port <code class="literal">5000</code>, and waiting for our HTTP requests. Now, we will compose and send HTTP requests locally in our development computer or from other computer or devices connected to our LAN.</p><div class="section" title="Working with command-line tools â curl and httpie"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec7"/>Working with command-line tools â curl and httpie</h2></div></div></div><p>We will start composing and sending HTTP requests with the command-line tools we have introduced in <span class="emphasis"><em>
<a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>
</em></span>, <span class="emphasis"><em>Developing RESTful APIs with Django</em></span>, curl and HTTPie. In case you haven't installed HTTPie, make sure you activate the virtual environment and then run the following command in the terminal or command prompt to install the HTTPie package.</p><pre class="programlisting">
<span class="strong"><strong>pip install --upgrade httpie</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip45"/>Tip</h3><p>In case you don't remember how to activate the virtual environment that we created for this example, read the following section in this chapter-<span class="emphasis"><em>Setting up the virtual environment with Django REST framework</em></span>.</p></div></div><p>Open a Cygwin Terminal in Windows or a Terminal in macOS or Linux, and run the following command. It is very important that you enter the ending slash (<code class="literal">/</code>) when specified /api/messages won't match any of the configured URL routes. Thus, we must enter <code class="literal">/api/messages/</code>, including the ending slash (/). We will compose and send an HTTP request to create a new message:</p><pre class="programlisting">
<span class="strong"><strong>http POST :5000/api/messages/ message='Welcome to IoT' duration=10 message_category='Information'</strong></span>
</pre><p>The following is the equivalent curl command. It is very important to use the <code class="literal">-H "Content-Type: application/json"</code> option to indicate curl to send the data specified after the <code class="literal">-d</code> option as <code class="literal">application/json</code> instead of the default <code class="literal">application/x-www-form-urlencoded</code>:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Welcome to IoT", "duration":10, "message_category": "Information"}' :5000/api/messages/</strong></span>
</pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">POST http://localhost:5000/api/messages/</code> with the following JSON key-value pairs:</p><pre class="programlisting">{  
    "message": "Welcome to IoT",  
    "duration": 10,  
    "message_category": "Information" 
} 
</pre><p>The request specifies <code class="literal">/api/messages/</code>, and therefore, it will match <code class="literal">'/api/messages/'</code> and run the <code class="literal">MessageList.post</code> method. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is <code class="literal">POST</code>, Flask calls the <code class="literal">post</code> method. If the new <code class="literal">MessageModel</code> was successfully persisted in the dictionary, the function returns an <code class="literal">HTTP 201 Created</code> status code and the recently persisted <code class="literal">MessageModel</code> serialized serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <code class="literal">MessageModel</code> object in the JSON response:</p><pre class="programlisting">
<span class="strong"><strong>HTTP/1.0 201 CREATED</strong></span>
<span class="strong"><strong>Content-Length: 245</strong></span>
<span class="strong"><strong>Content-Type: application/json</strong></span>
<span class="strong"><strong>Date: Wed, 20 Jul 2016 04:43:24 GMT</strong></span>
<span class="strong"><strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>    "creation_date": "Wed, 20 Jul 2016 04:43:24 -0000", </strong></span>
<span class="strong"><strong>    "duration": 10, </strong></span>
<span class="strong"><strong>    "id": 1, </strong></span>
<span class="strong"><strong>    "message": "Welcome to IoT", </strong></span>
<span class="strong"><strong>    "message_category": "Information", </strong></span>
<span class="strong"><strong>    "printed_once": false, </strong></span>
<span class="strong"><strong>    "printed_times": 0, </strong></span>
<span class="strong"><strong>    "uri": "/api/messages/1"</strong></span>
<span class="strong"><strong>}</strong></span>
</pre><p>We will compose and send an HTTP request to create another message. Go back to the Cygwin terminal in Windows or the Terminal in macOS or Linux, and run the following command:</p><pre class="programlisting">
<span class="strong"><strong>http POST :5000/api/messages/ message='Measuring ambient temperature' duration=5 message_category='Information'</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Measuring ambient temperature", "duration":5, "message_category": "Information"}' :5000/api/messages/</strong></span>
</pre><p>The previous commands will compose and send the following HTTP request, <code class="literal">POST http://localhost:5000/api/messages/</code>, with the following JSON key-value pairs:</p><pre class="programlisting">{  
    "message": "Measuring ambient temperature",  
    "duration": 5,  
    "message_category": "Information" 
} 
</pre><p>The following lines show an example response for the HTTP request, with the new <code class="literal">MessageModel</code> object in the JSON response:</p><pre class="programlisting">
<span class="strong"><strong>HTTP/1.0 201 CREATED</strong></span>
<span class="strong"><strong>Content-Length: 259</strong></span>
<span class="strong"><strong>Content-Type: application/json</strong></span>
<span class="strong"><strong>Date: Wed, 20 Jul 2016 18:27:05 GMT</strong></span>
<span class="strong"><strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>    "creation_date": "Wed, 20 Jul 2016 18:27:05 -0000", </strong></span>
<span class="strong"><strong>    "duration": 5, </strong></span>
<span class="strong"><strong>    "id": 2, </strong></span>
<span class="strong"><strong>    "message": "Measuring ambient temperature", </strong></span>
<span class="strong"><strong>    "message_category": "Information", </strong></span>
<span class="strong"><strong>    "printed_once": false, </strong></span>
<span class="strong"><strong>    "printed_times": 0, </strong></span>
<span class="strong"><strong>    "uri": "/api/messages/2"</strong></span>
<span class="strong"><strong>}</strong></span>
</pre><p>We will compose and send an HTTP request to retrieve all the messages. Go back to the Cygwin terminal in Windows or the Terminal in macOS or Linux, and run the following command:</p><pre class="programlisting">
<span class="strong"><strong>http :5000/api/messages/</strong></span>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX GET -H :5000/api/messages/</strong></span>
</pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">GET http://localhost:5000/api/messages/</code>. The request specifies <code class="literal">/api/messages/</code>, and therefore, it will match <code class="literal">'/api/messages/'</code> and run the <code class="literal">MessageList.get</code> method. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is <code class="literal">GET</code>, Flask calls the <code class="literal">get</code> method. The method retrieves all the <code class="literal">MessageModel</code> objects and generates a JSON response with all of these <code class="literal">MessageModel</code> objects serialized.</p><p>The following lines show an example response for the HTTP request. The first lines show the HTTP response headers, including the status (200 OK) and the Content-type (application/json). After the HTTP response headers, we can see the details for the two <code class="literal">MessageModel</code> objects in the JSON response:</p><pre class="programlisting">
<span class="strong"><strong>HTTP/1.0 200 OK</strong></span>
<span class="strong"><strong>Content-Length: 589</strong></span>
<span class="strong"><strong>Content-Type: application/json</strong></span>
<span class="strong"><strong>Date: Wed, 20 Jul 2016 05:32:28 GMT</strong></span>
<span class="strong"><strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong></span>
<span class="strong"><strong>[</strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>        "creation_date": "Wed, 20 Jul 2016 05:32:06 -0000", </strong></span>
<span class="strong"><strong>        "duration": 10, </strong></span>
<span class="strong"><strong>        "id": 1, </strong></span>
<span class="strong"><strong>        "message": "Welcome to IoT", </strong></span>
<span class="strong"><strong>        "message_category": "Information", </strong></span>
<span class="strong"><strong>        "printed_once": false, </strong></span>
<span class="strong"><strong>        "printed_times": 0, </strong></span>
<span class="strong"><strong>        "uri": "/api/messages/1"</strong></span>
<span class="strong"><strong>    }, </strong></span>
<span class="strong"><strong>    {</strong></span>
<span class="strong"><strong>        "creation_date": "Wed, 20 Jul 2016 05:32:18 -0000", </strong></span>
<span class="strong"><strong>        "duration": 5, </strong></span>
<span class="strong"><strong>        "id": 2, </strong></span>
<span class="strong"><strong>        "message": "Measuring ambient temperature", </strong></span>
<span class="strong"><strong>        "message_category": "Information", </strong></span>
<span class="strong"><strong>        "printed_once": false, </strong></span>
<span class="strong"><strong>        "printed_times": 0, </strong></span>
<span class="strong"><strong>        "uri": "/api/messages/2"</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>]</strong></span>
</pre><p>After we run the three requests, we will see the following lines in the window that is running the Flask development server. The output indicates that the server received three HTTP requests, specifically two <code class="literal">POST</code> requests and one <code class="literal">GET</code> request with <code class="literal">/api/messages/</code> as the URI. The server processed the three HTTP requests, returned status code 201 for the first two requests and 200 for the last request:</p><pre class="programlisting">
<span class="strong"><strong>127.0.0.1 - - [20/Jul/2016 02:32:06] "POST /api/messages/ HTTP/1.1" 201 -</strong></span>
<span class="strong"><strong>127.0.0.1 - - [20/Jul/2016 02:32:18] "POST /api/messages/ HTTP/1.1" 201 -</strong></span>
<span class="strong"><strong>127.0.0.1 - - [20/Jul/2016 02:32:28] "GET /api/messages/ HTTP/1.1" 200 -</strong></span>
</pre><p>The following image shows two Terminal windows side-by-side on macOS. The Terminal window at the left-hand side is running the Flask development server and displays the received and processed HTTP requests. The Terminal window at the right-hand side is running <code class="literal">http</code> commands to generate the HTTP requests. It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_001.jpg" alt="Working with command-line tools â curl and httpie"/></div><p>
</p><p>Now, we will compose and send an HTTP request to retrieve a message that doesn't exist. For example, in the previous list, there is no message with an <code class="literal">id</code> value equal to <code class="literal">800</code>. Run the following command to try to retrieve this message. Make sure you use an <code class="literal">id</code> value that doesn't exist. We must make sure that the utilities display the headers as part of the response to see the returned status code:</p><pre class="programlisting">
<span class="strong"><strong>http :5000/api/messages/800</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX GET :5000/api/messages/800</strong></span>
</pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">GET http://localhost:5000/api/messages/800</code>. The request is the same than the previous one we have analyzed, with a different number for the <code class="literal">id</code> parameter. The server will run the <code class="literal">Message.get</code> method with <code class="literal">800</code> as the value for the <code class="literal">id</code> argument. The method will execute the code that retrieves the <code class="literal">MessageModel</code> object whose id matches the <code class="literal">id</code> value received as an argument. However, the first line in the <code class="literal">MessageList.get</code> method calls the <code class="literal">abort_if_message_doesnt_exist</code> method that won't find the id in the dictionary keys and it will call the <code class="literal">flask_restful.abort</code> function because there is no message with the specified <code class="literal">id</code> value. Thus, the code will return an HTTP <code class="literal">404 Not Found</code> status code. The following lines show an example header response for the HTTP request and the message included in the body. In this case, we just leave the default message. Of course, we can customize it based on our specific needs:</p><pre class="programlisting">
<span class="strong"><strong>HTTP/1.0 404 NOT FOUND</strong></span>
<span class="strong"><strong>Content-Length: 138</strong></span>
<span class="strong"><strong>Content-Type: application/json</strong></span>
<span class="strong"><strong>Date: Wed, 20 Jul 2016 18:08:04 GMT</strong></span>
<span class="strong"><strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>    "message": "Message 800 doesn't exist. You have requested this URI [/api/messages/800] but did you mean /api/messages/&lt;int:id&gt; ?"</strong></span>
<span class="strong"><strong>}</strong></span>
</pre><p>Our API is able to update a single field for an existing resource, and therefore, we provide an implementation for the <code class="literal">PATCH</code> method. For example, we can use the <code class="literal">PATCH</code> method to update two fields for an existing message and set the value for its <code class="literal">printed_once</code> field to <code class="literal">true</code> and <code class="literal">printed_times</code> to <code class="literal">1</code>. We don't want to use the <code class="literal">PUT</code> method because this method is meant to replace an entire message. The <code class="literal">PATCH</code> method is meant to apply a delta to an existing message, and therefore, it is the appropriate method to just change the value of the <code class="literal">printed_once</code> and <code class="literal">printed_times</code> fields.</p><p>Now, we will compose and send an HTTP request to update an existing message, specifically, to update the value of two fields. Make sure you replace <code class="literal">2</code> with the id of an existing message in your configuration:</p><pre class="programlisting">
<span class="strong"><strong>http PATCH :5000/api/messages/2 printed_once=true printed_times=1</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX PATCH -H "Content-Type: application/json" -d '{"printed_once":"true", "printed_times":1}' :5000/api/messages/2</strong></span>
</pre><p>The previous command will compose and send a <code class="literal">PATCH</code> HTTP request with the specified JSON key-value pairs. The request has a number after <code class="literal">/api/messages/</code>, and therefore, it will match <code class="literal">'/api/messages/&lt;int:id&gt;'</code> and run the <code class="literal">Message.patch</code> method, that is, the <code class="literal">patch</code> method for the <code class="literal">Message</code> class. If a <code class="literal">MessageModel</code> instance with the specified id exists and it was successfully updated, the call to the method will return an HTTP <code class="literal">200 OK</code> status code and the recently updated <code class="literal">MessageModel</code> instance serialized to JSON in the response body. The following lines show a sample response:</p><pre class="programlisting">
<span class="strong"><strong>HTTP/1.0 200 OK</strong></span>
<span class="strong"><strong>Content-Length: 231</strong></span>
<span class="strong"><strong>Content-Type: application/json</strong></span>
<span class="strong"><strong>Date: Wed, 20 Jul 2016 18:28:01 GMT</strong></span>
<span class="strong"><strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>"creation_date": "Wed, 20 Jul 2016 18:27:05 -0000",</strong></span>
<span class="strong"><strong>"duration": 0,</strong></span>
<span class="strong"><strong>"id": 2,</strong></span>
<span class="strong"><strong>"message": "Measuring ambient temperature",</strong></span>
<span class="strong"><strong>"message_category": "Information",</strong></span>
<span class="strong"><strong>"printed_once": true,</strong></span>
<span class="strong"><strong>"printed_times": 1,</strong></span>
<span class="strong"><strong>"uri": "/api/messages/2"</strong></span>
<span class="strong"><strong>    }
  </strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip46"/>Tip</h3><p>The IoT device will make the previously explained HTTP request when it displays the message for the first time. Then, it will make additional PATCH requests to update the value for the <code class="literal">printed_times</code> field.</p></div></div><p>Now, we will compose and send an HTTP request to delete an existing message, specifically, the last message we added. As happened in our last HTTP requests, we have to check the value assigned to <code class="literal">id</code> in the previous response and replace <code class="literal">2</code> in the command with the returned value:</p><pre class="programlisting">
<span class="strong"><strong>http DELETE :5000/api/messages/2</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX DELETE :5000/api/messages/2</strong></span>
</pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">DELETE http://localhost:5000/api/messages/2</code>. The request has a number after <code class="literal">/api/messages/</code>, and therefore, it will match <code class="literal">'/api/messages/&lt;int:id&gt;'</code> and run the <code class="literal">Message.delete</code> method, that is, the <code class="literal">delete</code> method for the <code class="literal">Message</code> class. If a <code class="literal">MessageModel</code> instance with the specified id exists and it was successfully deleted, the call to the method will return an HTTP <code class="literal">204 No Content</code> status code. The following lines show a sample response:</p><pre class="programlisting">
<span class="strong"><strong>HTTP/1.0 204 NO CONTENT</strong></span>
<span class="strong"><strong>Content-Length: 0</strong></span>
<span class="strong"><strong>Content-Type: application/json</strong></span>
<span class="strong"><strong>Date: Wed, 20 Jul 2016 18:50:12 GMT</strong></span>
<span class="strong"><strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong></span>
</pre></div><div class="section" title="Working with GUI tools - Postman and others"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec8"/>Working with GUI tools - Postman and others</h2></div></div></div><p>So far, we have been working with two terminal-based or command-line tools to compose and send HTTP requests to our Flask development server-cURL and HTTPie. Now, we will work with one of the GUI tools we used when composing and sending HTTP requests to the Django development server-Postman.</p><p>Now, we will use the <span class="strong"><strong>Builder</strong></span> tab in Postman to easily compose and send HTTP requests to <code class="literal">localhost:5000</code> and test the RESTful API with this GUI tool. Remember that Postman doesn't support curl-like shorthands for localhost, and therefore, we cannot use the same shorthands we have been using when composing requests with curl and HTTPie.</p><p>Select <span class="strong"><strong>GET</strong></span> in the dropdown menu at the left-hand side of the <span class="strong"><strong>Enter request URL</strong></span> textbox, and enter <code class="literal">localhost:5000/api/messages/</code> in this textbox at the right-hand side of the dropdown. Then, click <span class="strong"><strong>Send</strong></span> and Postman will display the Status (<span class="strong"><strong>200 OK</strong></span>), the time it took for the request to be processed and the response body with all the games formatted as JSON with syntax highlighting (<span class="strong"><strong>Pretty</strong></span> view). The following screenshot shows the JSON response body in Postman for the HTTP GET request.</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_002.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p><p>Click on <span class="strong"><strong>Headers</strong></span> at the right-hand side of <span class="strong"><strong>Body</strong></span> and <span class="strong"><strong>Cookies</strong></span> to read the response headers. The following screenshot shows the layout for the response headers that Postman displays for the previous response. Notice that Postman displays the <span class="strong"><strong>Status</strong></span> at the right-hand side of the response and doesn't include it as the first line of the Headers, as happened when we worked with both the cURL and HTTPie utilities:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_003.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p><p>Now, we will use the <span class="strong"><strong>Builder</strong></span> tab in Postman to compose and send an HTTP request to create a new message, specifically, a POST request. Follow the next steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <span class="strong"><strong>POST</strong></span> in the drop-down menu at the left-hand side of the <span class="strong"><strong>Enter request URL</strong></span> textbox, and enter <code class="literal">localhost:5000/api/messages/</code> in this textbox at the right-hand side of the dropdown.</li><li class="listitem">Click <span class="strong"><strong>Body</strong></span> at the right-hand side of <span class="strong"><strong>Authorization</strong></span> and <span class="strong"><strong>Headers</strong></span>, within the panel that composes the request.</li><li class="listitem">Activate the <span class="strong"><strong>raw</strong></span> radio button and select <span class="strong"><strong>JSON (application/json)</strong></span> in the dropdown at the right-hand side of the <span class="strong"><strong>binary</strong></span> radio button. Postman will automatically add a <span class="strong"><strong>Content-type</strong></span> = <span class="strong"><strong>application/json</strong></span> header, and therefore, you will notice the <span class="strong"><strong>Headers</strong></span> tab will be renamed to <span class="strong"><strong>Headers (1)</strong></span>, indicating us that there is one key-value pair specified for the request headers.</li><li class="listitem">Enter the following lines in the textbox below the radio buttons, within the <span class="strong"><strong>Body</strong></span> tab:</li></ol></div><pre class="programlisting">{ 
   "message": "Measuring distance", 
   "duration": 5, 
   "message_category": "Information" 
} 
</pre><p>The following screenshot shows the request body in Postman:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_004.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p><p>We followed the necessary steps to create an HTTP POST request with a JSON body that specifies the necessary key-value pairs to create a new game. Click <span class="strong"><strong>Send</strong></span> and Postman will display the Status (<span class="strong"><strong>201 Created</strong></span>), the time it took for the request to be processed and the response body with the recently added game formatted as JSON with syntax highlighting (<span class="strong"><strong>Pretty</strong></span> view). The following screenshot shows the JSON response body in Postman for the HTTP POST request:</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_005.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip47"/>Tip</h3><p>If we want to compose and send an HTTP PATCH request for our API with Postman, it is necessary to follow the previously explained steps to provide JSON data within the request body.</p></div></div><p>Click or tap on the value for the url field in the JSON response body-<code class="literal">/api/messages/2</code>. You will notice that the value will be underlined when you hover the mouse pointer over it. Postman will automatically generate a <code class="literal">GET</code> request to <code class="literal">localhost:5000/api/messages/2</code>. Click <span class="strong"><strong>Send</strong></span> to run it and retrieve the recently added message. The field is useful to browse the API with a tool such as Postman.</p><p>Because we made the necessary changes to generate an externally visible Flask development server, we can also use apps that can compose and send HTTP requests from mobile devices to work with the RESTful API. For example, we can work with the iCurlHTTP App on iOS devices such as iPad Pro and iPhone. In Android devices, we can work with the previously introduced HTTP Request App.</p><p>The following screenshot shows the results of composing and sending the following HTTP request with the iCurlHTTP App: <code class="literal">GET http://192.168.2.3:5000/api/messages/</code>. Remember that you have to perform the previously explained configurations in your LAN and router to be able to access the Flask development server from other devices connected to your LAN. In this case, the IP assigned to the computer running the Flask Web server is <code class="literal">192.168.2.3</code>, and therefore, you must replace this IP with the IP assigned to your development computer.</p><p>
</p><div class="mediaobject"><img src="graphics/image_05_006.jpg" alt="Working with GUI tools - Postman and others"/></div><p>
</p></div></div>
<div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec69"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Flask-RESTful uses which of the following as the main building block for a RESTful API?<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Resources built on top of Flask pluggable views</li><li class="listitem">Statuses built on top of Flask resource views.</li><li class="listitem">Resources built on top of Flask pluggable controllers.</li></ol></div><p>
</p></li><li class="listitem">In order to be able to process an HTTP POST request on a resource, we must declare a method with the following name in a subclass of <code class="literal">flask_restful.Resource</code>.<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">post_restful</code></li><li class="listitem"><code class="literal">post_method</code></li><li class="listitem"><code class="literal">post</code></li></ol></div><p>
</p></li><li class="listitem">In order to be able to process an HTTP <code class="literal">GET</code> request on a resource, we must declare a method with the following name in a subclass of <code class="literal">flask_restful.Resource</code>.<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">get_restful</code></li><li class="listitem"><code class="literal">get_method</code></li><li class="listitem"><code class="literal">get</code></li></ol></div><p>
</p></li><li class="listitem">A subclass of <code class="literal">flask_restful.Resource</code> represents:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">A controller resource.</code></li><li class="listitem"><code class="literal">A RESTful resource.</code></li><li class="listitem"><code class="literal"> A single RESTful HTTP verb.</code></li></ol></div><p>
</p></li><li class="listitem">If we use the <code class="literal">@marshal_with</code> decorator with <code class="literal">message_fields</code> as an argument, the decorator will:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Apply the field filtering and output formatting specified in <code class="literal">message_fields</code> to the appropriate instance.</li><li class="listitem">Apply the field filtering specified in <code class="literal">message_fields</code> to the appropriate instance, without considering output formatting.</li><li class="listitem">Apply the output formatting specified in <code class="literal">message_fields</code> to the appropriate instance, without considering field filtering.</li></ol></div><p>
</p></li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec70"/>Summary</h1></div></div></div><p>In this chapter, we designed a RESTful API to interact with a simple dictionary that acted as a data repository and perform CRUD operations with messages. We defined the requirements for our API and we understood the tasks performed by each HTTP method. We set up a virtual environment with Flask and Flask-RESTful.</p><p>We created a model to represent and persist messages. We learned to configure serialization of messages into JSON representations with the features included in Flask-RESTful. We wrote classes that represent resources and process the different HTTP requests and we configured the URL patterns to route URLs to classes.</p><p>Finally, we started Flask development server and we used command-line tools to compose and send HTTP requests to our RESTful API and analyzed how each HTTP request was processed in our code. We also worked with GUI tools to compose and send HTTP requests.</p><p>Now that we understand the basics of the combination of Flask and Flask-RESTful to create RESTful APIs, we will expand the capabilities of the RESTful Web API by taking advantage of advanced features included in Flask-RESTful and related ORMs, which is what we are going to discuss in the next chapter.</p></div></body></html>