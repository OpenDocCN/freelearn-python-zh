- en: Creating Views with Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our data in an easily accessible format, displaying the information
    in a web page becomes much easier. In this chapter, we will learn how to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the included templating language for Flask, Jinja, to dynamically create
    HTML for our SQLAlchemy models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Jinja's methods to automate the creation of HTML and modify data for presentation
    inside a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically create and validate HTML forms with Jinja
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jinja's syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jinja** is a templating language written in Python. A **templating language**
    is a simple format that is designed to help automate the creation of documents.
    In any templating language, variables passed to the template replace predefined
    elements in the template. In Jinja, variable substitutions are defined by `{{
    }}`. The `{{ }}` syntax is called a **variable block**. There are also **control
    blocks** defined by `{% %}` that declare language functions, such as **loops**
    or `if` statements. For example, when the `Post` model from [Chapter 2](42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml), *Creating
    Models with SQLAlchemy*, is passed to it, we get the following Jinja code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables displayed in a Jinja template can be any Python type or object
    as long as they can be converted into a string via the Python function `str()`.
    For example, a dictionary or a list passed to a template can have its attributes
    displayed via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Many programmers prefer to use JavaScript to template and dynamically create
    their HTML documents to take the HTML rendering load off the server. This will
    not be covered in this chapter as it is an advanced JavaScript topic. However,
    many JavaScript templating engines use the `{{ }}` syntax as well. If you choose
    to combine Jinja and your JavaScript templates that are defined in your HTML files,
    then wrap the JavaScript templates in the `raw` control block to tell Jinja to
    ignore them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s a common mistake to believe that Jinja and Python''s syntax are the same
    because of their similarity. However, there is a lot of difference between the
    two. As you will see in this section, normal Python functions do not really exist.
    Instead, in Jinja, variables can be passed to built-in functions that modify the
    variables for display purposes. These functions, called filters, are called in
    the variable block with the pipe character, `|`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if no arguments are passed to the filter, the parentheses can be
    omitted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Filters called control blocks can also be applied to blocks of text, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are many filters in Jinja; this book will cover only the most useful filters.
    For the sake of brevity, in each example, the output of each filter will be listed
    directly beneath the filter itself.
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of all the default filters in Jinja, visit [http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/dev/templates/#list-of-builtin-filters).
  prefs: []
  type: TYPE_NORMAL
- en: The default filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the passed variable is `None`, then replace it with a `default` value as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to replace the variable with the `default` value, and if the variable
    evaluates to `False`, then pass `True` to the optional second parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The escape filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the passed variable is a string of HTML, then the `&`, `<`, `>`, `''`, and
    `"` characters will be printed as HTML `escape` sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The float filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `float` filter converts the passed value to a floating point number with
    the Python `float()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The int filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `int` filter converts the passed value to an integer with the Python `int()`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The join filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `join` filter joins elements of a list with a string, and works in exactly
    the same way as the `list` method of the same name. It is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The length filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `length` filter fills the same role as the Python `len()` function. It
    is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The round filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `round` filter rounds off a float to the specified precision, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify how you want the number to be rounded off, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `common` option rounds such figures in the same way that a person would:
    Any number at or above 0.5 is rounded up, and any number lower than 0.5 is rounded
    down. The `floor` option always rounds the number down and the `ceil` option always
    rounds up, regardless of the decimal value.'
  prefs: []
  type: TYPE_NORMAL
- en: The safe filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you try to insert HTML into your page from a variable—for example, when
    you wish to display a blog post—Jinja will automatically try to add HTML `escape`
    sequences to the output. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a necessary security feature. When an application has inputs that allow
    users to submit arbitrary text, it creates a vulnerability that a malicious user
    can use to input HTML code. For example, if a user were to submit a script tag
    as a comment and Jinja didn't have this feature, the script would be executed
    on all the browsers that visited the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we still need a way to display HTML that we know is safe to show,
    such as the HTML of our blog posts. We can achieve this using the `safe` filter
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The title filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `title` filter enables us to capitalize a string using the `title` case
    format as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The tojson filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the `tojson` filter to pass the variable to the Python `json.dumps`
    function, as shown in the following code. Remember that your passed object must
    be serializable by the `json` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This feature is most commonly used to pass SQLAlchemy models to JavaScript
    MVC frameworks upon the loading of the page load than waiting for an AJAX request.
    If you use `tojson` in this way, remember to pass the result to the `safe` filter
    as well to make sure that you don''t get HTML `escape` sequences in your JavaScript.
    Here is an example with a collection of models from `Backbone.js`, a popular JavaScript
    MVC framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The truncate filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `truncate` filter takes a long string, returns a string cutoff at the specified
    length in characters, and appends an ellipsis, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, any words that are cut in the middle are discarded. To disable
    this, pass `True` as an extra parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Custom filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding your own filter into Jinja is as simple as writing a Python function.
    To understand custom filters, we will look at an example. Our simple filter will
    count the number of occurrences of a substring in a string and return this figure.
    Look at the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to write a new Python function with the following signature, where
    the first argument is the *piped *variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define our filter as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To add this function to the list of available filters on **Jinja2**, we have
    to register it and add it to the `filters` dictionary of the `jinja_env` object
    in our `main.py` file. To do this, we can simply use a decorator that will handle
    this procedure for us—`@app.template_filter`.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comments in the template are defined by `{# #}`, as shown in the following
    code. They will be ignored by Jinja, and will not be in the returned HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `if` statements in Jinja is similar to using them in Python. Anything
    that returns, or is, a Boolean determines the flow of the code, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Filters can also be used in `if` statements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use loops in Jinja to iterate over any list or generator function, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Loops and `if` statements can be combined to mimic the `break` functionality
    in Python loops. In this example, the loop will only use the post `if post.text`
    is not `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop, you have access to a special variable called `loop`, which
    gives you access to information about the `for` loop. For example, if we want
    to know the current index of the current loop to emulate the `enumerate` function
    in Python, we can use the index variable of the `loop` variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'All the variables and functions that the `loop` object exposes are listed in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.index` | The current iteration of the loop (1 indexed) |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.index0` | The current iteration of the loop (0 indexed) |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.revindex` | The number of iterations from the end of the loop (1 indexed)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.revindex0` | The number of iterations from the end of the loop (0 indexed)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.first` | True if the current item is first in the iterator |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.last` | True if the current item is last in the iterator |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.length` | The number of items in the iterator |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.cycle` | The `helper` function to cycle between the items in the iterator
    (this is explained later) |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.depth` | Indicates how deep in a recursive loop the loop currently
    is (starts at level 1) |'
  prefs: []
  type: TYPE_TB
- en: '| `loop.depth0` | Indicates how deep in a recursive loop the loop currently
    is (starts at level 0) |'
  prefs: []
  type: TYPE_TB
- en: 'The `cycle` function is a function that goes through an iterator one item at
    a time in every loop. We can use the previous example to demonstrate, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **macro** is best understood as a function in Jinja that returns a template
    or HTML string. This is used to avoid reproducing code that is repeated over and
    over again and reduce it to one function call. For example, the following is a
    macro to add a Bootstrap CSS input and a label to your template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to quickly add an input to a form in any template, call your macro using
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Flask-specific variables and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask makes several functions and objects available to you by default in your
    template.
  prefs: []
  type: TYPE_NORMAL
- en: The config object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask makes the current `config` object available in templates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The request object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Flask `request` object refers to the current request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The session object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Flask `session` object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The url_for() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `url_for` function returns the URL of a route by giving the route function
    name as a parameter, as shown in the following code. This allows URLs to be changed
    without worrying about where links will break:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `home`is the name of a function that is registered as an endpoint on
    Flask,and the relative URL root associated with it, so on our `main.py`, we must
    define a function to deal with the HTTP request and register it on Flask using
    the decorator `app.route(rule, **options)`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had a route that had positional arguments in the URL, we pass them as
    `kwargs`. They will be filled in for us in the resultant URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With the respective function that we use to handle the request, we restrict
    this method to handle only GET and POST HTTP requests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The get_flashed_messages() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `get_flashed_messages()` function returns a list of all the messages passed
    through the `flash()` function in Flask. The `flash` function is a simple function
    that queues messages—which consist of Python tuples of (category, message) phrases—for
    the `get_flashed_messages` function to consume, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Proper feedback to the user is very important, and Flask makes it very simple
    to implement—for example, when handling a new post entry, we want to let the user
    know that his/her post was saved correctly. The `flash()` function accepts three
    different categories: `info`, `error`, and `warning`. Refer to the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Creating our views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we need to create a new folder named `templates` in our project
    directory. This folder will store all of our Jinja files, which are just HTML
    files with Jinja syntax mixed in. Our first template will be our home page, which
    will be a list of the first 10 posts with summaries. There will also be a view
    for a post that will just show the post content, the comments on the page, links
    to the author's user page, and links to tag pages. There will also be user and
    tag pages that show all the posts that have been made by a user and all the posts
    with a specific tag. Each page will also have a sidebar showing the five most
    recent posts and the top five most used tags.
  prefs: []
  type: TYPE_NORMAL
- en: The view function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because each page will have the same sidebar information, we can break that
    into a separate function to simplify our code. In the `main.py` file, add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The most recent posts query is straightforward, but the most popular tags query
    looks somewhat familiar, but a little odd. This is a bit outside the scope of
    this book, but using the SQLAlchemy `func` library to return a count on a group
    by query, we are able to order our tags by the most used tags. The `func` function
    is explained in detail at [http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html#sqlalchemy.sql.expression.func](http://docs.sqlalchemy.org/en/latest/core/functions.html#module-sqlalchemy.sql.expression).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `home` page function in `main.py` will need all the posts ordered by their publish
    date in a pagination object and the sidebar information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that using the `app.config['POSTS_PER_PAGE']` phrase gives us the option
    to configure it without having to change code, which is nice. It's a candidate
    config key for the main `Config` class, and let all environments inherit its value.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we finally see how Flask and Jinja tie together. The Flask function `render_template`
    takes the name of a file in the folder `templates` and passes all the `kwargs`
    to the template as variables. Also, our `home` function now has multiple routes
    to handle pagination, and will default to the first page if there is nothing after
    the slash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have all the information that you need to write view functions,
    let''s define the first view functions that we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /post/<POST_ID>` to render a specific post by its ID. This also renders
    all recent posts and tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /posts_by_tag/<TAG_NAME>` to render all posts by a specific tag name.
    This also renders all recent posts and tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /posts_by_user/<USER_NAME>` to render all posts authored by a specific
    user. This also renders all recent posts and tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This translates to the following view functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In Flask SQLAlchemy, there are two convenience functions that return HTTP `404`
    in the case of a nonexistent entry in the database, `get_or_404` and `first_or_404`,
    so on our get post by ID, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'All posts made by a user can be returned using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: However, this doesn't check the `posts_by_tag` function in the `main.py` file
    (see the provided code for this chapter). After all of your views are written,
    the only thing left to do is to write the templates.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the templates and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because this book does not focus on interface design, we will use the CSS library
    **Bootstrap** and avoid writing custom CSS. If you have never used it before,
    Bootstrap is a set of default CSS rules that make your website work well across
    all browsers and platforms, from desktop to mobile. Bootstrap has tools that allow
    you to easily control the layout of your website.
  prefs: []
  type: TYPE_NORMAL
- en: We will be downloading Bootstrap, JQuery, and Font Awesome directly from their
    CDN upon page load, but any extra assets you may need should be included in a
    project directory named `static`. It's common practice to use `static/css` for
    CSS, `static/js` for JavaScript, `static/img` for images, and `static/fonts` for
    fonts. One of the best ways to use Bootstrap is to download its `sass` files and
    use `sass `to customize it.
  prefs: []
  type: TYPE_NORMAL
- en: For the official documentation about SASS and Bootstrap, visit [https://getbootstrap.com/docs/4.0/getting-started/theming/](https://getbootstrap.com/docs/4.0/getting-started/theming/).
  prefs: []
  type: TYPE_NORMAL
- en: Because every route will have a template assigned to it, each template will
    need the requisite HTML boilerplate code with our metainformation, style sheets,
    common JavaScript libraries, and so on. To keep our templates **DRY** (**don't
    repeat yourself**), we will use one of the most powerful features of Jinja, **template
    inheritance**. Template inheritance is when a child template can import a base
    template as a starting point and only replace marked sections in the base. You
    can also include full sections of Jinja templates from other files; this will
    allow you to set some rigid default sections.
  prefs: []
  type: TYPE_NORMAL
- en: The base template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to outline the base layout for our site, split it into sections, and
    give each section a specific purpose. The following diagram is an abstract description
    of the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f31d75a6-e6b6-45aa-9297-14f2b0675f52.png)'
  prefs: []
  type: TYPE_IMG
- en: Some of these sections will always get rendered, and you don't want to repeat
    them on each template. Some possible options for these sections are the navigation
    bar, header, messages, and footer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following include and block structure to maintain our DRY principal
    and implement the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Include navbar**: Jinja2 template: `navbar.html`—Renders a navigation bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block head**: The header with the name of the site. Already includes the `head.html `Jinja2
    template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include messages**: Jinja2 template: `messages.html`—Renders alerts for the
    users with different categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block body:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block left body**: Normally, templates will override this block.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block right body**: This will display the most recent posts and tags.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block footer**: Jinja2 template: `footer.html`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note how the fixed sections, the ones that will almost always get rendered,
    already include templates even when inside blocks. The base template will handle
    these by default. If for some reason you want to override these, you just have
    to implement/inherit their block on the rendered template. For example, say that
    you want to render a whole body section on a certain page, taking the space of
    the right body section that displays the most recent posts and tags. A good candidate
    for this will be the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start our base template, we need a basic HTML skeleton and the Jinja2 block
    structure that we previously outlined (see the highlighted code in the following
    snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is the `base.html` template in the provided code in your `templates` directory.
    First, we include the Bootstrap and Font Awesome CSS, then implement the HTML
    body section, and finally include all the necessary JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The child templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have outlined the base layout, we need to implement all the child
    pages that will extend the base. Take a look at the way we are implementing the
    home page and inherit/override the left body block, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Surprisingly simple, this template extends the base template has expected, and
    then overrides the `title` and `leftbody` block sections. Inside, the `leftbody` uses
    two macros to render the posts and their pagination. The macros help us to reuse
    Jinja2 code and use it like functions, and also to hide some complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render_posts` macro is in the `macros.html` that was imported at the top
    of the file. We use macros more or less like modules in Python, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The macro iterates on each post, and on each `post.title`, there is a link to
    the Flask endpoint `post` with its respective post ID. As explained, we always
    use `url_for` to generate the right URL that references Flask's endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using this macro three times on the templates: to render all posts,
    all posts by a certain tag, and all posts by a certain user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tag.html` template renders all posts by a certain tag, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the `user.html` template in the preceding code, you'll see that
    they are almost identical. These templates are called by the Flask endpoint functions `posts_by_tag` and `posts_by_user`.
    When rendering the templates, they pass arguments for the `tag`/`user` object
    and a list of posts, as we saw before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out how the blog site looks now. In the command line, call `init.sh` to
    build a Python virtualenv, and then migrate/create our database and insert some
    fake data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `http://127.0.0.1:5000/` in your browser. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce1ce568-d1bd-431c-849b-3fef57b9d1b6.png)'
  prefs: []
  type: TYPE_IMG
- en: The `init.sh` phrase calls the `test_data.py`, which inserts fake data into
    the database. This Python module uses the `faker` library to generate data for
    user names and post text and tags (using color names).
  prefs: []
  type: TYPE_NORMAL
- en: For more details regarding `faker`, you can go to [http://faker.readthedocs.io/en/master/](http://faker.readthedocs.io/en/master/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example taken from `test_data.py` that inserts users
    into the database and returns a list of user objects that is reused to insert
    posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `template` folder contains the following templates that are rendered using
    the aforementioned hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`base.html`: Extended by all the other templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`footer.html`: Included by `base.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`head.html`: Included by `base.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messages.html`: Included by `base.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navbar.html`: Included by `base.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rightbody.html`: Included by `base.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`home.html`: Rendered by the `home` Flask endpoint function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post.html`: Rendered by the `post` Flask endpoint function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag.html`: Rendered by the `posts_by_tag` endpoint function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user.html`: Rendered by the `posts_by_user` endpoint function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the other templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know the ins and outs of inheritance, and you know which data is
    going to go to which template, you can have a clear idea of how to structure your
    web application to easily scale and maintain the same look and feel on every page.
    There is one final bit of functionality to add in this chapter—the ability for
    readers to add comments. For this, we will be using web forms.
  prefs: []
  type: TYPE_NORMAL
- en: Flask WTForms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding forms to your application seems to be an easy task, but when you start
    coding the server-side code, the task of validating user input grows bigger and
    bigger as the form becomes more complex. Security is paramount, as the data is
    from an untrustworthy source, and is going to be entered into the database. **WTForms**
    is a library that handles server form validation for you by checking input against
    common form types. Flask WTForms is a Flask extension that is built on top of
    WTForms that adds features, such as Jinja HTML rendering, and protects you against
    attacks, such as SQL injection and cross-site request forgery. This extension
    is already installed in your virtualenv, because it's declared in the `requirements.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting yourself against SQL injection and cross-site request forgery is
    extremely important, as these are the most common forms of attacks that your website
    will receive. To learn more about these attacks, visit [https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection)
    and [https://en.wikipedia.org/wiki/Cross-site_request_forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)
    for information on SQL injection and cross-site request forgery, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have Flask WTForms'' security measures working properly, we will need a
    **secret key**. A secret key is a random string of characters that will be used
    to cryptographically sign anything that needs to be tested for its authenticity.
    This cannot be just any string; it must be randomized and be of a certain length
    so that brute-force or dictionary attacks won''t be able to crack it in any viable
    amount of time. To generate a random string, enter a Python session and enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You should generate a different secret key for each environment. Just copy
    the output from `os.urandom` and paste it into each environment `config` class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: WTForms basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three main parts of WTForms—**forms**, **fields**, and **validators**.
    Fields are representations of input fields and perform rudimentary type checking,
    and validators are functions that are attached to fields that make sure that the
    data submitted in the form is within our constraints. The form is a class that
    contains fields and validators, and validates itself on a `POST` request. Let''s
    see this in action to get a better idea. In the `main.py` file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a class that inherits from Flask WTForm''s `Form` object and
    defines inputs with class variables that equal WTForm fields. The fields take
    an optional parameter, `validators`, which is a list of WTForm validators that
    will be applied to our data. The most commonly used fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fields.DateField` and `fields.DateTimeField`: Represents a Python `date` or
    `datetime` object and takes an optional parameter format that takes a `stftime`
    format string to translate the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.IntegerField`: This attempts to coerce passed data to an integer and
    is rendered in the template as a number input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.FloatField`: This attempts to coerce passed data to a float and is
    rendered in the template as a number input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.RadioField`: This represents a set of radio inputs and takes a `choices `parameter , which
    is a list of tuples that act as the displayed value and the returned value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.SelectField`: Along with `SelectMultipleField`, this represents a set
    of radio inputs. It takes a `choices `parameter, which is a list of tuples that
    act as the displayed and returned values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.StringField`: This represents a normal text input, and will attempt
    to coerce the returned data to a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full list of validators and fields, visit the WTForms documentation at
    [http://wtforms.readthedocs.org](http://wtforms.readthedocs.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common validators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validators.DataRequired()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.Email()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.Length(min=-1, max=-1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.NumberRange(min=None, max=None)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.Optional()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.Regexp(regex)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validators.URL()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these validations follows the Pythonic naming scheme. Therefore, it
    is rather straightforward as to what they do. All validators take an optional
    parameter called `message`, which is the error message that will be returned if
    the validator fails. If a message is not set, it uses the library defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing a custom validation function is very simple. All that is required is
    to write a function that takes the `form` object and the `field` object as parameters
    and raises a WTForm. A `ValidationError` is raised if the data does not pass the
    test. Here is an example of a custom email validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: To use this function, just add it to the list of validators for your field.
  prefs: []
  type: TYPE_NORMAL
- en: Posting comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our comment form and we understand how to build it, we need
    to add it to the start of our post view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: First, we add the `POST` method to the list of our view's allowed methods. Then,
    a new instance of our form object is created. The `validate_on_submit()` method
    then checks whether the Flask request is a `POST` request. If it is a `POST` request,
    it sends the request form data to the form object. If the data is validated, then
    `validate_on_submit()` returns `True` and adds the data to the `form` object.
    We then take the data from each field, populate a new comment, and add it to the
    database. Note how we don't need to fill in the comment data, because we have
    set a default value for it in the SQLAlchemy model definition—in this case, the `datatime.now` function
    that is going to be evaluated upon the object creation.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to ensure that we wrap all our database calls with a `try`/`except`
    block, and in the case of an error, roll back the session transaction and send
    proper feedback to the users.
  prefs: []
  type: TYPE_NORMAL
- en: Note the final `redirect` Flask call to the same endpoint, this time with an
    `HTTP GET`. This means that after a user inserts a new comment, the same page
    is rendered again with a clean form and shows the newly added comment.
  prefs: []
  type: TYPE_NORMAL
- en: If the form does not validate, or if we are handling an `HTTP GET`, we fetch
    the `Post` object from the database by `post_id`, collect all the related comments,
    and finally get all the necessary side-bar data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template itself is divided into three main sections. The first renders
    the post, the second displays the form where the user can submit a new comment
    about the post, and the third is where we render all the comments related to the
    post. Let''s focus on the third section, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: There are several new things happening here. First, we declare an HTML form
    section and make it submit (using `HTTP POST`) to our `post` Flask endpoint function
    with the current post ID.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `form.hidden_tag()` method adds an anticross-site request forgery
    measure automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when calling `field.label`, an HTML label will automatically be created for
    our input. This can be customized when we define our `WTForm FlaskForm` class;
    if not, WTForm will pretty print the field name.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check for any errors using `field.errors`, and if there are any, we
    will iterate all of them and render the form validation message to the user. Finally,
    calling the field itself as a method will render the HTML code of that field.
  prefs: []
  type: TYPE_NORMAL
- en: 'This third section of the template will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0cdd727-2108-49f3-94e6-1f08c71f1c6f.png)'
  prefs: []
  type: TYPE_IMG
- en: One challenge for the reader is to make a macro that takes a `form` object and
    an endpoint to send the `POST` request to and autogenerates HTML for the entire
    form tag. Refer to the WTForms documentation if you get stuck. It's tricky, but
    not too difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, after only two chapters, you already have a fully functional blog. This
    is where a lot of books on web development technologies would end. However, there
    are still 10 more chapters to go to turn your utilitarian blog into something
    that a user would actually use for their website.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on structuring Flask apps to accommodate
    long-term development and larger scale projects.
  prefs: []
  type: TYPE_NORMAL
