- en: Chapter 9. Imagining Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We work with images almost on a daily basis. Uploading images to your Facebook
    profile page, or manipulating images while developing your mobile or web applications;
    there are abundant use cases. With so many advancements in the field of computer
    vision, imaging has become a critical field. Working with images is trivial with
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing, cropping, and generating thumbnails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy-pasting and watermarking images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image differences and comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Face detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imaging as a business process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images in the electronic world are a series of bits comprised of 0s and 1s.
    They are an electronic snapshot of a scene or a document. Even paintings or photographs
    can be digitized to form images. Let's go deeper into images and understand how
    they're structured.
  prefs: []
  type: TYPE_NORMAL
- en: Every image is sampled and is represented by a grid of dots called **pixels**.
    These pixels represent the smallest controllable elements of a picture shown on
    the screen. The greater the number of pixels available in an image, the more accurate
    is the representation of the image on the device screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The intensity of each pixel is variable. In the digital world, the color of
    an image is represented by three or four intensities of different colors: **red,
    green, and blue** (**RGB**) or **cyan, magenta, yellow, and black** (**CMYK**),
    respectively. Computer programs often represent colors in RGBA format, where A
    stands for alpha (or the transparency of a color). Each pixel is represented in
    the binary representation in the RGBA format and is stored by the computer as
    a sequence. The computer then reads this sequence for display and, in some cases,
    converts it to its analog version for printing. Let''s look at specific image
    attributes in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Image attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s have a look at some of the image attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image size**: As you learned earlier, computer images are stored as a series
    of 0s and 1s and are measured in pixels (rectangular dots). The file size of an
    image is calculated based on the number of pixels it contains and the amount of
    color information that is stored. The file size is, in fact, the space taken up
    by the image on the computer hard drive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bit depth**: It is the number of bits used to indicate the color of a single
    pixel. This concept can be defined as the bits per pixel, which denotes the number
    of bits used to describe a pixel. The greater the bit depth of an image, greater
    the number of colors it can store. A 1-bit image can store only two (2^1) colors--0
    and 1--and is hence black and white in color. When compared with it, an 8-bit
    image can store 256 (2^8) colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image resolution**: Resolution refers to the number of pixels in an image.
    Resolution is sometimes identified by the width and height of the image. For example,
    an image of 1,920 by 1,024 pixel resolution contains 1,966,080 pixels or is a
    1.9-megapixel image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image quality**: It can be changed based on the information an image stores.
    Not all images need to store all the pixels to represent an image. For instance,
    a continuous block of blue sea in a picture need not have all the pixels, and
    the image can be compressed to reduce the disk space of the image without compromising
    on the image quality. This reduction in disk space is termed as compression. A
    higher compression means noticeable loss of detail. A typical compression type
    used in today''s world is the JPG compression, which reduces the size and also
    sacrifices the image''s quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image formats**: Images are stored in a computer with different extensions.
    Formats such as BMP or TIF are not compressed at all; hence, they occupy more
    disk space. Files such as JPG can be compressed and you can also choose the compression
    level. Hence, TIF images are lossless and JPG compression is termed as lossy compression.
    It is interesting to note that lossy compressions make use of humans'' inability
    to differentiate minor differences in shades. Multiple lossy conversions will
    result in image degradation, whereas multiple lossless conversions will preserve
    the image quality. But generally, it''s a trade-off between image degradation
    and size when it comes to compression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK, that's a good start. In this chapter, we will go through some more concepts
    of images and look at the various operations that you can perform on images with
    Python. We'll take a look at multiple modules that will help us manipulate images
    the way we need them. At the end of the chapter, we will also look at a typical
    business process that can be automated with the knowledge we built with the recipes
    covered in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, we will use the following Python modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pillow` ([https://pypi.python.org/pypi/Pillow](https://pypi.python.org/pypi/Pillow))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scipy` ([https://www.scipy.org/](https://www.scipy.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opencv` ([https://pypi.python.org/pypi/opencv-python](https://pypi.python.org/pypi/opencv-python))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin our journey of images with simple examples. But before going on,
    let's build our virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build the virtual environment using the `virtualenv` command and also
    activate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Nice! So, we now have an independent environment to work on our recipes for
    this chapter. For the first set of examples, we will use Python''s Pillow module.
    Let''s install this module first before going to the recipe. We will use our favorite
    `python-pip` to install the Pillow module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, we now have our environment, and the `Pillow` module is also installed.
    We're now ready to work with the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will deal with converting images to a different format.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's just download an image that can be used as a sample image to perform
    all our operations. I love sunsets and that's the reason I have used a sunset
    image for most of the recipes in this chapter. This is how it looks. I store it
    on my laptop and name it `beach_sunset.png`:![How to do it...](img/image_09_001.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s go ahead and write the Python code to convert this image to the
    JPEG format. The following code does exactly what we need. We store the Python
    code in a file named `convert.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run this program with Python's `convert.py` command it will take the
    original PNG image, convert it into JPG format, and store it as `beach-susnset-conv.jpg`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Neat! Now, let''s perform one more operation on this image and convert it to
    grayscale (black and white format). It''s common for people to convert images
    to black and white format to give them a nostalgic look; this can be easily achieved
    with the following set of command lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when you run this program, you will see another image generated on your
    disk, with the name `beach-sunset-gray.png`, which looks as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_002.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Cool, let''s go further and perform a few more operations such as rotating
    and flipping the image. These actions are often used in fun websites where you
    can simply play around with your images. The following code will help you rotate
    the images by 180 degrees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run this code with our base image, you will see an image rotated by
    180 degrees, that is, the image is seen upside down, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'While rotating images is nice, it''d be awesome fun if we could flip the images.
    PIL doesn''t disappoint here and provides you with the options of flipping the
    images horizontally and vertically. The following code will help us perform the
    flipping operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you run this piece of code, it will generate two images. The following
    image is the same as the original image, but is flipped horizontally (as if there
    is a mirror kept on the right side of the image). Note how the mountain has moved
    to the right of the image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_004.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The following screenshot is a mirror image of the original image, which is flipped
    vertically. Notice, the mountain is still on the left-hand side of the image but
    it's upside down. Similar is the fate of the setting sun. Is it looking like sunrise?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we dealt with two different image formats: PNG and JPEG. **Portable
    Network Graphics** (**PNG**) files are non-lossy files, compressing photographic
    images without degrading quality. It is an excellent file format for Internet
    graphics; it can be used with multiple backgrounds, and it supports transparency.
    For the image used in first code example, `beach_sunset.png`, the file size is
    550KB.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Joint Photographic Experts Group** (**JPEG**) uses lossy compression techniques
    to compress images. JPGs compress images by reducing the sections of images to
    pixels or tiles. JPG images can be compressed at a ratio of N:1, depending on
    the settings. Since images get compressed easily and can reduce the Internet bandwidth
    for accessing images on the Internet, JPG has become a standard for images on
    the Internet. For the converted image, I see the file size is 450KB--almost 20%
    smaller size than the PNG files.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's understand the Python code. We import the `Image` class from the
    `PIL` module. The `Image` class is responsible for opening, loading, and converting
    images, among other operations such as saving images on the disk. In our example,
    we open the PNG image with the `open()` method and save the image in the JPEG
    format with the `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we convert the image to the black and white format. Just
    as we have the RGB and CMYK formats, we also have the *L* format, which denotes
    black and white. While converting the image to the *L* format, it uses the ITU-R
    luma format, where *L=R*299/1000 + G*587/1000 + B*114/1000*.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of Python code, again we use the `Image` class to `open()` the file
    and use the `convert()` method with its argument as *L* to convert the image to
    black and white. Finally, we save the file on the disk with `save()` method. Here
    we maintain the file format to PNG.
  prefs: []
  type: TYPE_NORMAL
- en: In the third example, we use the same `Image` class and `open()` the image to
    get the `img` object. This object is then used to call the `rotate()` method with
    the angle of rotation being the argument. In our example, we rotated the image
    by 180 degrees and finally called `save()` to save the rotated image on the disk
    with the name, `sunset180deg.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: In the last example, we make use of the `transpose()` method of the `PIL` module
    and flip the images both ways, that is, left-right and top-bottom, using the attributes
    `Image.FLIP_LEFT_RIGHT` and `Image.FLIP_TOP_BOTTOM`, and then save the flipped
    images with the names `sunset_horizontal_flip.png` and `sunset_vertical_flip.png`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pillow module has many more methods that help us perform more complex operations
    on our images, such as resizing, pasting, cropping, and what not. We will look
    at them in the next recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing, cropping, and generating thumbnails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operations such as resizing images and cropping them to get a selected part
    of the image are very common, but these operations may become tedious when tried
    programmatically. See how we can achieve these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the `Pillow` library to resize and crop images.
    As we already have the Pillow module installed, we don't have to worry about any
    installations. Let's jump into doing stuff.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s look at how to resize an image to the given dimensions. Create
    a Python file, `resize.py`, and paste the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, download an image from the Internet and name it sunset.jpg. My image looks
    like this:![How to do it...](img/image_09_006.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run the Python code with the `python resize.py` command, and look at your
    disk for the image, `sunset-resize.jpg`. You'll see that the image gets resized
    and looks similar to the following screenshot:![How to do it...](img/image_09_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The image also has the dimensions of 256 pixels by 256 pixels as expected:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Another operation often needed in programming is to generate thumbnails for
    images. Thumbnails are used as the preview of an original image and are typically
    used in movie review websites or book publishing websites. Let''s see if we can
    easily generate thumbnails with the Pillow module. Create a Python file and add
    this piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you run this piece of code, you will get an image, `sunset.thumbnail.jpg`,
    which is a thumbnail of the original image and will look as shown in the screenshot
    below. If you look at the size of the image, it will not be 128 x 128 (for me,
    it's 128 x 80 pixels). We will cover the reasons for this in a bit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Nice! So, we have the thumbnail generated for the image and it can be used
    on a website as a profile thumbnail or a preview image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_009.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Another operation that we will cover in this recipe is the cropping of images.
    The following code does exactly what we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the preceding Python snippet, you will see an image generated on
    your disk, `sunset-crop.jpg`, which has a cropped image of the sun from the original
    sunset image. This is how it looks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_010.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: It was nice to see how we could perform multiple operations on the images with
    Pillow so easily and so intuitively. But how do these operations work; what are
    the methods used? Let's look at them.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we again used Pillow's `Image` class to resize and crop images
    and generate thumbnails from our original image.
  prefs: []
  type: TYPE_NORMAL
- en: In the first code snippet, we opened the sunset.jpg image with the `open()`
    method. We then used the `resize()` method with a tuple argument listing the width
    and height of the resized image. We then used the `save()` method with the filename,
    `sunset-esize.jpg` and the JPEG file format to save the file on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: In the second snippet, we opened the image with the `open()` method and got
    an image object. We then used the `thumbnail()` method of the `Image` class on
    the image object for generating the thumbnail. The `thumbnail()` method takes
    the size of the image (we used 128 x 128) and uses the BICUBIC image filtering
    mechanism. Finally, we saved the image with the `save()` method with the target
    filename set to `sunset.thumbnail.jpg`. We looked at the size of the thumbnail
    and figured that it's not exactly 128 x 128; in fact, it's 128 x 80\. This is
    because PIL keeps the width of the image to 128 pixels and then recalculates the
    height to maintain the aspect ratio of the image.
  prefs: []
  type: TYPE_NORMAL
- en: And in the third example, we cropped the image with the `crop()` method of the
    `Image` class from the Pillow module. The `crop()` method takes all the four coordinates
    from where the image needs to be carved out from the original image. In our example,
    we have given the coordinates `left = 965`, `top = 700`, `right = 1265`, `bottom
    = 960` to crop the original image and the result obtained is the image of the
    sun as we saw in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the thumbnail generation example, I briefly mentioned filters that are applied
    to images for better clarity. I'm not covering these in detail in this chapter,
    but if you're interested, you can look at them in detail at [http://pillow.readthedocs.io/en/3.0.x/releasenotes/2.7.0.html#default-filter-for-thumbnails](http://pillow.readthedocs.io/en/3.0.x/releasenotes/2.7.0.html#default-filter-for-thumbnails).
  prefs: []
  type: TYPE_NORMAL
- en: Copy-pasting and watermarking images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will cover one operation that is highly used by designers
    and marketers, that is, watermarking images. We will also see an interesting use
    of copy-pasting images over one another. Let's go ahead and look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will continue to use Pillow to copy-paste images, but we
    will use another Python module, `wand`, for watermarking. So, as is the normal
    practice, let''s install the `wand` module first before we start writing any code.
    We install wand with our favorite tool, Python''s `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Installed the module already? OK then, let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s look at how to perform the copy-paste operation with Pillow.
    Remember, from the previous sections we have two images: the original image, `sunset.jpg`,
    and the image of the sun that was cropped from the original image, `sunset-crop.jpg`.
    We will use these images in the following Python code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's store the code in a file by the name, `copy_paste.py`, and run the code
    with the Python command, `copy_paste.py`. Once we run the code, we will see a
    new file being generated, called `pasted.jpg`, which looks like the following
    screenshot:![How to do it...](img/image_09_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we have managed to do is copy the cropped image, paste it on the original
    image, and save the pasted image as `pasted.jpg`. Cool, isn't it?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s look at an interesting example that has commercial use. In this
    example, we will add a watermark to an existing image and store it under a different
    name. But before we get into the Python code, let''s look at how the watermark
    image looks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_012.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The following Python code helps us in adding the preceding watermark to our
    original `sunset.jpg` image file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run this code and you will see a `result.jpg` file being generated in your project.
    It will look similar to the following screenshot. Look at how the image is watermarked
    with the **Copyrighted Image** text on top:![How to do it...](img/image_09_013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the first code snippet, we used the `PIL` module and the Image class to
    `open()` the cropped image and original image and get the file handles of both
    the files, namely: `img` and `pasteImg`.'
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, we opened the cropped image `img` and pasted it on `pasteImg`,
    using the file handles.
  prefs: []
  type: TYPE_NORMAL
- en: For pasting the image, we used Pillow's `paste()` module and passed the `img`
    file handle to it as the source image. We also passed the coordinates where the
    cropped image is to be pasted on the original image. Since we have chosen the
    coordinates to be (0, 0), the cropped image is pasted on the upper-left corner
    of the original image. Finally, we saved this image as `pasted.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we opened the original image, `sunset.jpg`, and the watermark
    image, `watermark.jpg`, and created the file handles, `background` and `watermark`,
    respectively. We then used the `wand` module's `watermark()` method to add the
    watermark to the original image.
  prefs: []
  type: TYPE_NORMAL
- en: The `watermark()` method works on the background image object (in this case,
    background, our original image object). It uses image as the `keyword` argument,
    which indicates the object of the watermark image. You can also set the transparency
    of the watermark image, where `0` indicates that the watermark is completely visible
    while `1` indicates that it is invisible. Another useful thing you can achieve
    with the `watermark()` method is that you can choose the location of the watermark
    on the original image. In this example, we have chosen it to be at the coordinates `560`
    from the left and `300` from the top.
  prefs: []
  type: TYPE_NORMAL
- en: Cool; that's it in this recipe. Let's go ahead and see what we have in store
    in the remaining recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Image differences and comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You must have definitely used a text-based search or even implemented one.
    But do you know, you can now even perform an image-based search? Of course, Google
    does that quite nicely. How do you think it does that? If you have to implement
    one yourself, you better know how to compare two images. Based on your use case,
    you may also want to get a `diff` or the difference between two images. In this
    recipe, we will cover two use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: How to get the difference between two images and store the difference as an
    image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to objectively compare two images with scientific methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will continue using Pillow to compare images. Along with
    our `Image` class, we will also use the `ImageChops` class to get the difference
    between two images. We will use the `scipy` module to compare the images at the
    pixel level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have the Pillow module installed, so let''s go ahead and install
    the `scipy` module using Python `pip`. On Mac OS X machine, you''ll need to have
    a compiler to install the `scipy` module. We will install the GCC compiler on
    Mac with Mac''s `brew` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have GCC installed, let''s install `scipy` with `python-pip`. This
    is how the installation logs look on my system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the modules are already installed, let''s start utilizing them for
    our needs. First, let''s look at getting the difference between two images and
    storing the difference as an image itself. The following code does this operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code example, we calculated the difference between the original
    image, `sunset.jpg`, and the copy-pasted image, `pasted.jpg` (if you remember
    the previous recipe, `pasted.jpg` is obtained after pasting the cropped sun image
    on the original sunset image). This is how the difference image looks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_014.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Observe how the difference is only the cropped image of the sun since the base
    original image remains the same. Cool! What does the black region indicate? We
    will talk about it in the *How it works...* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s move ahead and look at calculating the difference between images
    in an objective manner. For this, we will use the `scipy` module. The following
    code example will help us with what we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the preceding Python code, we will get the difference in pixels in
    both these images. The output of our example is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first code snippet of this section, we calculated the difference between
    the two images using the `ImageChops` class of the Pillow library. As usual, we
    opened both the images with the `open()` method and got the image objects `image_one`
    and `image_two`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We then used the `difference()` method of the `ImageChops` class and passed
    the image objects as arguments to this method. The `difference()` method returns
    the `diff` object, which essentially is the object representing the difference
    between the two images.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saved the difference as an image on the disk with the name, `diff.jpg`.
    We also used the `getbbox()` method on the `diff` object, which calculates the
    bounding box of the nonzero regions in the image. Here nonzero regions indicate
    the pixels where the difference between `sunset.jpg` and `pasted.jpg` is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you look at `diff.jpg`, it contains a huge black region. These are the
    pixels where the difference is 0, hence the color black. For same images, the
    `getbbox()` method returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we compared the two images based on zero norm, which
    indicates the number of pixels not equal to zero, or in other words, indicates
    how many pixels differ between the two images. For comparing images, we first
    read both the images using the `imread()` method of the `scipy` module. Both the
    image objects are `img1` and `img2`.
  prefs: []
  type: TYPE_NORMAL
- en: We then calculated the difference between the two images with `diff = img1 -
    img2`. This difference returned is of the `ndarray` type of `scipy`. When we pass
    this difference to the `norm()` method, it returns the number of pixels that are
    different between images.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways of comparing images, which we haven't covered in this
    chapter. I suggest you do a deeper reading into this if you're really interested.
    But for all practical purposes, I think this chapter should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Face detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of operations on images in the preceding sections. In this
    recipe, let's delve deeper and cover an advanced operation such as face detection
    in images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use Python's `opencv` module, so let's start by installing
    the required module.
  prefs: []
  type: TYPE_NORMAL
- en: 'For using `opencv` Python bindings, we have to first install `opencv` on our
    computer. On my Mac OS X machine, I use the `brew` utility to install `opencv`
    this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just installing `opencv` on your computer doesn''t help. You also need to point
    the `cv2.so` (`.so` stands for shared object or library) to glue it with a virtual
    environment using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cool! So, we now have `opencv` installed, which is required for our examples
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go to your favorite editor, create a Python file, and name it `face_detection.py`.
    Now, copy the following code into the Python file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create an XML file by the name `haarcascade.xml` and copy the contents
    from the code repository of this book. In my example, I am using one of the pictures
    of myself, `Chetan.jpeg`, but you can use any of your pictures for this example.
    Here's how `Chetan.jpeg` looks:![How to do it...](img/image_09_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's run the Python code and see if our code is able to recognize my face
    from the image. We run the code with the command `python face_detection.py` and
    it generates an image, `Chetan_face.jpg`, which looks like the following. Indeed,
    it did detect my face.![How to do it...](img/image_09_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our recipe, we used the `opencv` module to first create a cascade classifier
    object with the `haarcascade.xml` file. We called this object `face_cascade`.
  prefs: []
  type: TYPE_NORMAL
- en: Object detection using Haar's feature-based cascade classifiers is an effective
    object detection method proposed by Paul Viola and Michael Jones in 2001\. It
    is a machine learning-based approach, where a cascade function is trained from
    a lot of positive and negative images. It is then used to detect objects in other
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Haar features are fed into a standard XML file, which is what we used in our
    code example. You can actually train your classifier to detect the objects you
    wish. For instance, eye detection uses another classifier.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we read the original base image, `Chetan.jpeg`, using the `opencv` module's
    `imread()` method and defined the smallest window for detection.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Haar cascade classifier works on a sliding window approach and hence
    needs the smallest window for detection. The classifier also needs to have `minNeighbors`
    configured.
  prefs: []
  type: TYPE_NORMAL
- en: Settings such as these are configured in the `detectMultiScale()` method of
    the cascade object. We have set `minSize=(30,30)` and `minNeighbors=3`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we stored the detected image on the disk and the original image has
    a green rectangle as an indication of face detection on the image.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at a very simple example of face detection with `opencv` and learned
    a bit about classifiers. `opencv` has more things that you may want to learn about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a link to a resource that you will find interesting to read: [http://docs.opencv.org/trunk/index.html](http://docs.opencv.org/trunk/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Imaging as a business process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Peter is an IT manager at MBI Inc, a big corporation. His company has been in
    existence for long enough for a majority of the contractual finance documents,
    standard operating procedures, and supply chain documents to be paper-based. He
    is tasked with this humongous responsibility of making his company go paperless.
  prefs: []
  type: TYPE_NORMAL
- en: This means that he is responsible for eliminating the hassle and cost of managing
    paper archives. With the imaging knowledge we have gathered so far (and we will
    learn more) in this chapter, let's see if we can help Peter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you carefully analyze, Peter needs to achieve two important tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Scan the papers and store them in an electronic format as images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate text files from these documents so that they can be easily indexed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this exercise, let''s start by installing the required modules. We will
    need the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scikit-image` ([http://scikit-image.org/](http://scikit-image.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyimagesearch` ([http://www.pyimagesearch.com/](http://www.pyimagesearch.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tessaract` and `pytesseract` ([https://pypi.python.org/pypi/pytesseract/](https://pypi.python.org/pypi/pytesseract/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start installing the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first start with `scikit-image`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's install `pyimagesearch`. This is a nice set of libraries developed
    by Adrian Rosebrock. He has his work open-sourced at [https://github.com/jrosebr1](https://github.com/jrosebr1).
    We, in fact, leverage the scanner example of `pyimagesearch` in this code recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, let''s install `tesseract` and `pytesseract`. We need to install `tesseract`,
    an **Optical Character Reader** (**OCR**) module, and `pytesseract`, a Python
    module to work with the OCR module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OK, cool! Now, let's look at the code in the *How to do it...* section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to your favorite editor, create a Python file, and name it `scanner.py`.
    For Peter, it would be all about his financial documents, which are in the image
    format, but for the sake of this example, it'll be an image that I have handy
    with me. Here's how my image looks. It's the picture of a newspaper article on
    Andy Murray and I'm trying to digitalize it:![How to do it...](img/image_09_017-e1485235547936.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, copy the following code in `scanner.py` and run the code with the command,
    `python scanner.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you run the Python code, you will see three images being created on your
    hard disk. The first one is the edge-detected image, which, in my case, looks
    as follows. It''s saved as `scan_edge.jpg`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_018.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, we get another image, which detects the whole area of the image where
    text is found. This is called the contours image and is generated as `scan_contours.jpg`.
    See how it highlights the portion of the image where text is available:![How to
    do it...](img/image_09_019.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we get the scanned copy of our news article on Andy Murray, and it
    is saved as `scanned.jpg`. Look how well the news article got scanned in the following
    screenshot:![How to do it...](img/image_09_020.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cool, this is the exact thing we wanted to achieve when we first started, isn't
    it? Give this to Peter and he will be very happy. He might be thinking of some
    costly consulting companies or scanners to do this job, while we could do it quickly and
    that too for free!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As if this was not enough, we have done more for Peter here. If you run the
    program, you will also get a text output, which gives out the text of the complete
    article. Using this text, Peter can choose to classify the documents and index
    them accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Awesome! Let's look at the internals of our program in the "How it works" section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our recipe, we started by taking a picture of our newspaper article. We named
    this as `murray.jpg`. I used a simple camera phone to take this image. We then
    went ahead and read the image using the `opencv` module's `imread()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We also computed the ratio of the original height to the new height, cloned
    the original image, and resized it. We used the `copy()` method to clone our image,
    and we used the `resize()` method to resize it to a new height.
  prefs: []
  type: TYPE_NORMAL
- en: We then converted the image to the grayscale format with the `cvtColor()` method
    and then applied the Gaussian filter to blur the image.
  prefs: []
  type: TYPE_NORMAL
- en: We subjected the blurred image to detect the edges of the text using the `Canny()`
    method and finally stored the edge-detected image as `scan_edge.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we found the contours of the image using the `findContours()` method and
    stored the outline of the image as `scan_contours.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: We then ran a couple of transforms on the image. The four-point transform helped
    us get a top-down view of the original image. For this, we used the `four_point_transform()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We also converted the image to grayscale and then thresholded it to give a black
    and white paper style feel. The `cvtColor()` method converts the image to grayscale
    and the `threshold_adaptive()` method applies the appropriate thresholds. And
    we're done; the image is now ready and is already scanned and saved as `scanned.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: But, as we saw in the previous section, we also printed the text of the newspaper
    column. This we could achieve by first reading the scanned image with Pillow's
    `Image` class and with the `pytessaract` module by using the `image_to_string()`
    method on the image object.
  prefs: []
  type: TYPE_NORMAL
- en: Cool, so we have automated the business process of converting paper-based documents
    into the electronic format and added a facility to index the files so that they
    can be easily fed into the company's ERP processes. Peter is damn happy with you!
    Congrats!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at OCR to extract text data from scanned images, but there are many
    more things that can be achieved, such as intelligent character recognition (extracts
    hand-written text) and barcode recognition (recognition of many types of barcodes),
    among others. Also, in this chapter we haven't dealt much with image filtering.
    If you're really interested, you can do lot of reading on these topics, which
    is beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
