<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Advanced Cython</h1></div></div></div><p>Throughout this book, we have exclusively been mixing C and Python together. In this chapter, we will delve into C++ and Cython. With every release of Cython C++, the support has improved. This is not to say that it's not ready for use yet. In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make native C++ classes callable from Python.</li><li class="listitem" style="list-style-type: disc">Wrapping C++ namespaces and templates</li><li class="listitem" style="list-style-type: disc">How exceptions can be propagated to and from C++ and Python</li><li class="listitem" style="list-style-type: disc">C++ new and del keyword</li><li class="listitem" style="list-style-type: disc">Operator overloading</li><li class="listitem" style="list-style-type: disc">Cython gil and nogil keywords</li></ul></div><p>We will wrap up this chapter by embedding a web server into a toy C++ messaging server.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Cython and C++</h1></div></div></div><p>Cython, above all <a id="id112" class="indexterm"/>binding generators, works with C++ the most seamlessly. C++ <a id="id113" class="indexterm"/>has some complexity when writing bindings for it, such as calling conventions, templates, and classes. I find this exception handling to be a shining feature of Cython, and we will look at the examples of each.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Namespaces</h2></div></div></div><p>I am introducing namespaces<a id="id114" class="indexterm"/> first because Cython uses namespaces as a way to reference C++ code within your module. Consider this C++ header with the following namespace:</p><div><pre class="programlisting">#ifndef __MY_HEADER_H__
#define __MY_HEADER_H__

<strong>namespace mynamespace {</strong>
….
}

#endif //__MY_HEADER_H__</pre></div><p>You will wrap this with the <code class="literal">cdef extern</code> declaration:</p><div><pre class="programlisting">cdef extern from <strong>"header.h" namespace "mynamespace":</strong>
    …</pre></div><p>You can now address <a id="id115" class="indexterm"/>it in Cython as you normally would do for a module:</p><div><pre class="programlisting">import cythonfile
<strong>cythonfile.mynamespace.attribute</strong>
</pre></div><p>It really feels like a Python module simply by using a namespace.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec28"/>Classes</h2></div></div></div><p>I would take a guess that most of your <a id="id116" class="indexterm"/>C++ code revolves around using classes. Being an object-oriented language, Cython handles this seamlessly:</p><div><pre class="programlisting">#ifndef __MY_HEADER_H__
#define __MY_HEADER_H__

<strong>namespace mynamespace {</strong>
  void myFunc (void);

  <strong>class</strong> myClass {
  <strong>public</strong>:
    int x;
    void printMe (void);
  };
}

#endif //__MY_HEADER_H__</pre></div><p>We can use Cython's <code class="literal">cppclass</code> keyword. This special keyword allows you to declare C++ classes and work with them directly, so you don't need to write the wrapper code, which can be very tedious and error prone in big projects. Using the previous namespace example, we will wrap the namespace and then the class within the namespace:</p><div><pre class="programlisting">cdef extern from <strong>"myheader.h" namespace "mynamespace"</strong>:
    void myFunc ()
    <strong>cppclass</strong> myClass:
        int x
        void printMe ()</pre></div><p>It's pretty simple just as C types were. Though now, you have a native C++ object, which can be very powerful.</p><p>Remember that<a id="id117" class="indexterm"/> Cython will only care about the <code class="literal">public</code> attributes. Since these are the only attributes a callee can access due to the encapsulation of private and protected methods. It is not possible to extend the C++ class. Now, you can work with these as if they were just <code class="literal">cdef</code> structs. Just use the '<code class="literal">.</code>' operator as before to access all the necessary attributes.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>C++ new and del keyword</h1></div></div></div><p>Cython understands the <code class="literal">new</code> keyword<a id="id118" class="indexterm"/> from C++; so, consider that you have a C++ class:</p><div><pre class="programlisting"> class Car {
    int doors;
    int wheels;
  public:
<strong>    Car ();</strong>
<strong>    ~Car ();</strong>
    void printCar (void);
    void setWheels (int x) { wheels = x; };
    void setDoors (int x) { doors = x; };
  };</pre></div><p>It is defined in Cython as follows:</p><div><pre class="programlisting">cdef extern from "cppcode.h" namespace "mynamespace":
    cppclass Car:
<strong>        Car ()</strong>
        void printCar ()
        void setWheels (int)
        void setDoors (int)</pre></div><p>Note that we do not declare the <code class="literal">~Car</code> destructor <a id="id119" class="indexterm"/>because we never call this directly. It's not an explicitly callable public member; this is why we never call it directly but delete will and the compiler will ensure this is called when it will go out of scope on the stack. To instantiate the raw C++ class in Cython code on the heap, we can simply run the following:</p><div><pre class="programlisting">cdef Car * c = <strong>new</strong> Car ()</pre></div><p>You can then go and use <code class="literal">del</code> to delete the object at any time using Python's <code class="literal">del</code> keyword:</p><div><pre class="programlisting">
<strong>del c</strong>
</pre></div><p>You will see that the destructor is called as you would expect:</p><div><pre class="programlisting">
<strong>$ cd chapter5/cppalloc; make; ./test</strong>
<strong>Car constructor</strong>
<strong>Car has 3 doors and 4 wheels</strong>
<strong>Car destructor</strong>
</pre></div><p>We can also declare a stack-allocated<a id="id120" class="indexterm"/> object, but it must only have a default constructor such as the following:</p><div><pre class="programlisting">cdef Car c</pre></div><p>There is no way to pass arguments with this syntax in Cython. But, note that you cannot use <code class="literal">del</code> on this instance, else you will get the following error:</p><div><pre class="programlisting">
<strong>cpycode.pyx:13:6: Deletion of non-heap C++ object</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec29"/>Exceptions</h2></div></div></div><p>With C++ exception handling, you can get a<a id="id121" class="indexterm"/> sense of how seamless Cython can feel within the C++ code. If any exceptions are thrown, such as memory allocations, Cython will handle these and translate them into more useful errors, and you still get the valid C++ exceptions objects. Python will also understand if these are caught or not and whether they are handled as required. This table gives you an idea of what Python exceptions will map to within C++:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>C++</p>
</th><th style="text-align: left" valign="bottom">
<p>Python</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">bad_alloc</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">MemoryError</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">bad_cast</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">TypeError</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">domain_error</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ValueError</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">invalid_argument</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ValueError</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ios_base::failure</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">IOError</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">out_of_range</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">IndexError</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">overflow_error</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">OverflowError</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">range_error</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ArithmeticError</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">underflow_error</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">ArithmeticError</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>All other exceptions</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">RuntimeError</code></p>
</td></tr></tbody></table></div><p>For instance, take this C++ code. It will simply throw an exception when the <code class="literal">myFunc</code> function is called. First, we define an exception with the following:</p><div><pre class="programlisting">namespace mynamespace {
  class mycppexcept: public std::exception {
<strong>    virtual const char * what () const throw () {</strong>
<strong>      return "C++ exception happened";</strong>
    }
  };

  void myFunc (void) <strong>throw (mycppexcept);</strong>
}</pre></div><p>Now, we write the function to throw the exception:</p><div><pre class="programlisting">void mynamespace::myFunc (void) <strong>throw (mynamespace::mycppexcept) {</strong>
  mynamespace::mycppexcept ex;
  cout &lt;&lt; "About to throw an exception!" &lt;&lt; endl;
<strong>  throw ex;</strong>
}</pre></div><p>We can call this in Cython with the following:</p><div><pre class="programlisting">cdef extern from "myheader.h" namespace "mynamespace":
    void myFunc () <strong>except +RuntimeError</strong>
</pre></div><p>When we run the<a id="id122" class="indexterm"/> function, we get the following output:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; import cpycode</strong>
<strong>About to throw an exception!</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "cpycode.pyx", line 3, in init cpycode (cpycode.cpp:763)</strong>
<strong>    myFunc ()</strong>
<strong>RuntimeError: C++ exception happened</strong>
<strong>&gt;&gt;&gt; ^D</strong>
</pre></div><p>If you want to catch the C++ exception in your Python code, you can simply use it as normal:</p><div><pre class="programlisting">try:
...
except RuntimeError:
...</pre></div><p>Notice that we told Cython to cast any exceptions to <code class="literal">RuntimeError</code>. This is important to make sure you understand where and which interfaces can throw an exception. Unhanded exceptions look really ugly and can be harder to debug. Cython cannot assume much about the state at this point since compilers won't throw errors on potentially unhandled exceptions in C++ at the code level. If this happens, you will get the following as the no exception handler is ready:</p><div><pre class="programlisting">
<strong>$ cd chapter5/cppexceptions; make; python</strong>
<strong>Python 2.7.2 (default, Oct 11 2012, 20:14:37)</strong>
<strong>[GCC 4.2.1 Compatible Apple Clang 4.0 (tags/Apple/clang-418.0.60)] on darwin</strong>
<strong>Type "help", "copyright", "credits" or "license" for more information.</strong>
<strong>&gt;&gt;&gt; import cpycode</strong>
<strong>About to throw an exception!</strong>
<strong>Segmentation fault: 11</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Bool type</h2></div></div></div><p>As seen in the previous chapter, to use the native <code class="literal">bool</code> type<a id="id123" class="indexterm"/> from C++, you need to firstly import the following:</p><div><pre class="programlisting">from <strong>libcpp</strong> cimport <strong>bool</strong>
</pre></div><p>Then, you can use <code class="literal">bool</code> as a normal <code class="literal">cdef</code>. If you want to use the pure PyObject <code class="literal">bool</code> type, you need to import the following:</p><div><pre class="programlisting">from <strong>cpython</strong> cimport <strong>bool</strong>
</pre></div><p>You can then assign them with the normal <code class="literal">true</code> or <code class="literal">false</code> values.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Overloading</h1></div></div></div><p>Since Python supports overloading<a id="id124" class="indexterm"/> to wrap C++ overload, just list the members as normal:</p><div><pre class="programlisting">cdef foobar (int)
cdef foobar (int, int)
…</pre></div><p>Cython understands that we are in C++ mode and can handle all the type conversion as normal. It's interesting that it can also handle an operator overload easily since it is just another hook! For example, let's take the <code class="literal">Car</code> class again and perform some operator overriding such as the following:</p><div><pre class="programlisting">namespace mynamespace {
  class Car {
    int doors;
    int wheels;
  public:
    Car ();
    ~Car ();
<strong>    Car * operator+(Car *);</strong>
    void printCar (void);
    void setWheels (int x) { wheels = x; };
    void setDoors (int x) { doors = x; };
  };
};</pre></div><p>Remember to add these operator-overloading class members to your Cythonized class; otherwise, your Cython will throw the following error:</p><div><pre class="programlisting">
<strong>Invalid operand types for '+' (Car *; Car *)</strong>
</pre></div><p>The Cython declaration of the operator overload looks as you expected:</p><div><pre class="programlisting">cdef extern from "cppcode.h" namespace "mynamespace":
    cppclass Car:
        Car ()
<strong>        Car * operator+ (Car *)</strong>
        void printCar ()
        void setWheels (int)
        void setDoors (int)</pre></div><p>Now, you can do the following:</p><div><pre class="programlisting">cdef Car * ccc = <strong>c[0] + cc</strong>
ccc.printCar ()</pre></div><p>This will then give us the following output on the command line:</p><div><pre class="programlisting">
<strong>$ cd chapter5/cppoverloading; make; ./test</strong>
<strong>Car constructor</strong>
<strong>Car constructor</strong>
<strong>Car has 3 doors and 4 wheels</strong>
<strong>Car has 6 doors and 8 wheels</strong>
<strong>inside operator +</strong>
<strong>Car constructor</strong>
<strong>Car has 9 doors and 12 wheels</strong>
</pre></div><p>Everything is handled <a id="id125" class="indexterm"/>as you would expect. This, for me, demonstrates the principle that inspired Guido to design Python classes.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Templates</h1></div></div></div><p>Templates<a id="id126" class="indexterm"/> are supported in Cython. Though, for the sake of completeness, template meta-programming patterns don't wrap up correctly or fail to compile. This keeps getting better with every release, so take this comment with a pinch of salt.</p><p>C++ class templates work very well; we can implement a template called <code class="literal">LinkedList</code> as the following class:</p><div><pre class="programlisting">cppclass LinkedList[T]:
        LinkedList ()
        void append (T)
        int getLength ()
...</pre></div><p>Now, you can access the template type with the declaration called <code class="literal">T</code>. You can follow the rest of this <a id="id127" class="indexterm"/>code in <code class="literal">chapter5/cpptemplates</code>.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Static class member attribute</h1></div></div></div><p>Sometimes, in classes, it's useful <a id="id128" class="indexterm"/>to have a static attribute such as the following:</p><div><pre class="programlisting">namespace <strong>mynamespace</strong> {
  class <strong>myClass</strong> {
    public:
<strong>      static void myStaticMethod (void);</strong>
  };
}</pre></div><p>In Cython, there is no support for this via a <code class="literal">static</code> keyword, but what you can do is tie this function to a namespace so that it becomes the following:</p><div><pre class="programlisting">cdef extern from "header.h" namespace <strong>"mynamespace::myClass":</strong>
    void <strong>myStaticMethod ()</strong>
</pre></div><p>Now, you simply call this method as a global method in Cython.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Calling C++ functions – Caveat</h1></div></div></div><p>When you write a code<a id="id129" class="indexterm"/> to call in a C++ function from C, you need to wrap the prototypes in the following:</p><div><pre class="programlisting">extern "C" { … }</pre></div><p>This allows you to call C++ prototypes because C won't understand a C++ class. With Cython, if you are telling your C output to call in C++ functions, you need to be careful about which compiler you are using or you need to write a new header to implement the minimal wrapper functions required to make the C++ calls.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec31"/>Namespaces – Caveat</h2></div></div></div><p>Cython seems to generally require a namespace<a id="id130" class="indexterm"/> to keep things nested, which you are already probably doing in your C++ code. Making PXD on non-namespaced code seems to make new declarations, meaning that you will get linking errors due to multiple symbols. The C++ support looks really good from these templates, and more metaprogramming idioms can be difficult to express in Cython. When polymorphism comes into play, it can be difficult to track down compilation errors. I would stress that you should keep your interfaces as simple as possible to perform debugging and to be more dynamic!</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Remember, when using Cython to generate C++, you need to specify <code class="literal">–cplus</code>, so it will default the <code class="literal">cythonfile.cpp</code> output. Pay attention to the extensions; I prefer to use <code class="literal">.cc</code> for my C++ code, so just be careful with your build system.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Python distutils</h1></div></div></div><p>As usual, we can also use Python <code class="literal">distutils</code>, but <a id="id131" class="indexterm"/>you will need to specify the language so that the auxiliary C++ code required will be compiled by the correct compiler:</p><div><pre class="programlisting">from distutils.core import setup
from Cython.Build import cythonize

setup (ext_modules = cythonize(
    "mycython.pyx",
    sources = ["mysource.cc"],
<strong>    language = "c++",</strong>
))</pre></div><p>Now, you can compile your C++ code to your Python module.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Python threading and GIL</h1></div></div></div><p><strong>GIL</strong><a id="id132" class="indexterm"/> stands for <strong>Global Interpreter Lock</strong>. What this means is <a id="id133" class="indexterm"/>when you link your program against <code class="literal">libpython.so</code> and use it, you really have the entire Python interpreter in your code. The reason this exists is to make concurrent applications really easy. In Python you can have two threads reading/writing to the same location and Python automatically handles all of this for you; unlike say in Java, where you need to specify that everything is under the GIL in Python. There are two things to consider when talking about the GIL and what it does—instruction atomicity and read/write lock.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Atomic instructions</h2></div></div></div><p>Remember that Cython necessarily <a id="id134" class="indexterm"/>generates the C code to make it look similar to any Python module that you can import. So, what's happening under the hood is that it will generate all the code to acquire lock on the GIL so that it can manipulate Python objects at runtime. Let's consider two types of execution. Firstly, you have the C stack where it executes atomically as you would expect; it doesn't care about synchronization between threads—this is left up to the programmer. The other is Python where it's doing all of this synchronization for us. When you embed Python into your application manually using <code class="literal">Py_Initilize</code>, this is under the C execution. When it comes to calling something, such as <code class="literal">import sys</code> and <code class="literal">sys.uname</code>, in the Cython code that is called from C, the Python GIL schedules, and blocks multiple threads from calling this at the same time to be safe. This makes writing multithreaded Python code extremely safe. Any errors from writing to the same location at the same time can happen and be handled correctly instead of <a id="id135" class="indexterm"/>having to use <a id="id136" class="indexterm"/><strong>mutex's</strong> on critical sections in C.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Read/write lock</h2></div></div></div><p>The read/write lock<a id="id137" class="indexterm"/> is great because it is pretty rare for you in Python to need to care about semaphores or mutex's on data unless you want to synchronize different thread's access to a resource<code class="literal">.</code> The worst that can happen is for you to get into an inconsistent state in your program, but you won't crash in contrast to C/C++. Any read/write operation to the global dictionary is handled the way you would expect in Python.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Cython keywords</h1></div></div></div><p>Okay, so <a id="id138" class="indexterm"/>how does this affect you and, more importantly, your code? It is important to know what way your code should and/or will execute in a concurrent manner. Without an understanding of this, your debugging will be confusing. There are times when the GIL gets in the way and can cause issues by blocking the execution of your C code from Python or vice versa. Cython allows us to control the GIL with the<a id="id139" class="indexterm"/> <code class="literal">gil</code> and <code class="literal">nogil</code> keywords, which <a id="id140" class="indexterm"/>is much simpler by wrapping this state for us:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Cython</p>
</th><th style="text-align: left" valign="bottom">
<p>Python</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>With gil</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">PyGILState_Ensure ()</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>With nogil</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">PyGILState_Release (state)</code></p>
</td></tr></tbody></table></div><p>I find that it's easier to think of multithreading in Python in terms of blocking and nonblocking the execution. In the next example, we will examine the steps needed to embed a web server into a toy messaging server.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Messaging server</h1></div></div></div><p>The messaging server<a id="id141" class="indexterm"/> is an example of something that would be highly concurrent; let's say we want to embed a web server into this to show the list of clients that are connected to the server. If you look at the flask, you can see how easily you can have a full web container in about eight lines of code.</p><p>The messaging <a id="id142" class="indexterm"/>server is asynchronous; therefore, it is callback based in C code. These callbacks can then call into Python roster object via Cython. Then, we can iterate over the roster dictionary to get online clients and simply return some JSON as a web service very easily reusing Python code and no need to write anything in C/C++.</p><p>It's important to note when embedding web servers is that they start a lot of threads. Calling the start web server function will block until it will exit, meaning if we start the web server first, we won't have the messaging server running concurrently. Also, due to the web-server function blocking, if we start it on a separate thread, it will never exit. Therefore, we are forced to run the messaging server on a background thread, and we can do this from the Python threading module. Again, this is where the GIL state becomes important. If we were to run the messaging server with the GIL and when the callbacks start, they will crash or block when they callback into Python. We can wrap the messaging server into the toy class called <code class="literal">MessageServer</code>:</p><div><pre class="programlisting">class MessageServer(threading.Thread):

    _port = None

    def __init__ (self, port):
        threading.Thread.__init__(self)
        # self.daemon = True
        self._port = port

    @property
    def roster(self):
        return _ROSTER

    @property
    def port(self):
        return self._port

    @staticmethod
    def set_callbacks():
        SetConnectCallback(pyconnect_callback)
        SetDisconnectCallback(pydisconnect_callback)
        SetReadCallback(pyread_callback)

    def stop(self):
        with nogil:
            StopServer();

    def run(self):
        logging.info("Starting Server on localhost:%i" % self.port)
        MessageServer.set_callbacks()
        cdef int cport = self.port
        with nogil:
            StartServer(cport)
        logging.info("Message Server Finished")
        </pre></div><p>Then, as you would expect, we can start the thread by running this:</p><div><pre class="programlisting">   # start libevent server
    message_server = MessageServer(port)
    message_server.start()</pre></div><p>Notice that I<a id="id143" class="indexterm"/> specified <code class="literal">with nogil</code>. Our C code doesn't need the GIL since we are only using pure C types and not touching any Python runtime until the callbacks. Once the <code class="literal">libevent</code> socket server is running asynchronously, we can then move onto starting our flask web server:</p><div><pre class="programlisting">from flask import Flask
from flask import jsonify

app = Flask("DashboardExample")
dashboard = None

@app.route("/")
def status():
    return jsonify(dashboard.roster.client_list())

class Dashboard:

    _port = None
    _roster = None

    def __init__(self, port, roster):
        global dashboard
        self._port = port
        self._roster = roster
        dashboard = self

    @property
    def port(self):
        return self._port

    @property
    def roster(self):
        return self._roster

    def start(self):
        app.run(port=self.port)</pre></div><p>Flask is fantastic for writing RESTful Web Services. It's clean, simple, and most importantly, easy to use and read. This service returns the JSON representation of the client roster. Since I have encapsulated the roster object, I am using a simple global so that all the flask routes can query the correct context:</p><div><pre class="programlisting"># start webserver
dashboard = Dashboard(port, roster)
dashboard.start()</pre></div><p>The web server now blocks until the kill signal is given. Then, it will return and we can then kill <code class="literal">MessageServer</code>:</p><div><pre class="programlisting">   # stop message server
message_server.stop()</pre></div><p>Now, we listen onto the specified port in <code class="literal">server.cfg</code>:</p><div><pre class="programlisting">[MessageServer]
port = 8080
webport = 8081</pre></div><p>This roster object <a id="id144" class="indexterm"/>holds a list of clients and handles each callback:</p><div><pre class="programlisting">class Roster:

    _clients = { }

    def handle_connect_event(self, client):
        """
        :returns True if client already exists else false
        """
        logging.info("connect: %s" % client)
        if client in self._clients:
            return True
        self._clients[client] = None
        return False;

    def handle_disconnect_event(self, client):
        logging.info("disconnect: %s" % client)
        self._clients.pop(client, None)

    def handle_read_event(self, client, message):
        logging.info("read: %s:[%s]" % (client, message))
        self._clients[client] = message

    def client_list(self):
        return self._clients</pre></div><p>We run the server as follows:</p><div><pre class="programlisting">$ python server --config=config.cfg</pre></div><p>We can then connect clients using a simple telnet session:</p><div><pre class="programlisting">$ telnet localhost 8080</pre></div><p>We can type in <a id="id145" class="indexterm"/>messages, see it handled in the server log, and press <em>Q</em> to quit. We can then query the web service for the list of clients:</p><div><pre class="programlisting">$ curl -X GET localhost:8081
{
  "127.0.0.1": "Hello World"
}</pre></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Caveat on GIL</h1></div></div></div><p>There is a caveat to <a id="id146" class="indexterm"/>remember when using <code class="literal">gil</code>. In our callbacks, we need to acquire the GIL on each callback before we call any Python code; otherwise, we will segfault and get really confused. So, if you look into each of the <code class="literal">libevent</code> callbacks when calling the Cython functions, you have the following:</p><div><pre class="programlisting"> PyGILState_STATE gilstate_save = <strong>PyGILState_Ensure();</strong>
<strong> readcb (client, (char *)data);</strong>
<strong> PyGILState_Release</strong>(gilstate_save);</pre></div><p>Notice that this is also called on the other two callbacks—firstly on the <code class="literal">discb</code> callback:</p><div><pre class="programlisting">  PyGILState_STATE gilstate_save = <strong>PyGILState_Ensure();</strong>
<strong>  discb (client, NULL);</strong>
<strong>  PyGILState_Release</strong>(gilstate_save);</pre></div><p>Finally, on the connect callback, we must be a little safer and call it this way:</p><div><pre class="programlisting"> PyGILState_STATE gilstate_save = <strong>PyGILState_Ensure();</strong>
  if <strong>(!conncb (NULL, inet_ntoa (client_addr.sin_addr)))</strong>
    {
…
    }
 else
    close (client_fd);
<strong>  PyGILState_Release(gilstate_save);</strong>
</pre></div><p>We have to do this since we executed this with <code class="literal">nogil</code> from Cython. We need to acquire <code class="literal">gil</code> before we go back into the Python land. You really need to look at something like this with your creativity cap on and imagine what you could do with this. For example, you can use this as a way to capture data and use the Twisted Web server to implement an embedded RESTful server. Maybe, you can even use Python JSON to wrap data into nice objects. But, it demonstrates how you can really extend a fairly complicated piece of C software with something nice and of a high-level nature using Python libraries. This keeps everything very <a id="id147" class="indexterm"/>simple and maintainable instead of trying to do everything from scratch.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Unit testing the native code</h1></div></div></div><p>Another use of Cython is unit <a id="id148" class="indexterm"/>testing the core functionality of shared C libraries. If you maintain a <code class="literal">.pxd</code> file (this is all you need really), you can write your own wrapper classes and do scalability testing of data structures with the expressiveness of Python. For example, we can write unit tests for something such as <code class="literal">std::map</code> and <code class="literal">std::vector</code> as follows:</p><div><pre class="programlisting">
<strong>from libcpp.vector cimport vector</strong>

PASSED = False

<strong>cdef vector[int] vect</strong>
cdef int i
for i in range(10):
    vect.push_back(i)
for i in range(10):
    print vect[i]

PASSED = True</pre></div><p>Then, write a test for <code class="literal">map</code> as follows:</p><div><pre class="programlisting">
<strong>from libcpp.map cimport map</strong>

PASSED = False

<strong>cdef map[int,int] mymap</strong>
cdef int i
for i in range (10):
    mymap[i] = (i + 1)

for i in range (10):
    print mymap[i]

PASSED = True</pre></div><p>Then, if we compile them into separate modules, we can simply write a test executor:</p><div><pre class="programlisting">#!/usr/bin/env python
print "Cython C++ Unit test executor"

print "[TEST] std::map"
import testmap
assert testmap.PASSED
<strong>print "[PASS]"</strong>

print "[TEST] std::vec"
<strong>import testvec</strong>
<strong>assert testvec.PASSED</strong>
print "[PASS]"

print "Done..."</pre></div><p>This is really trivial<a id="id149" class="indexterm"/> code, but it demonstrates the idea. If you put error handling with plenty of asserts and cause a fatal error, you can have some really nice unit testing against your C/C++ code. We can go further and implement this using Python's native unit testing framework.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Preventing subclassing</h1></div></div></div><p>If you create an extension type in<a id="id150" class="indexterm"/> Cython, something you never want to be subclassed, it is a <code class="literal">cpp</code> class wrapped in a Python class. To prevent this, you can do the following:</p><div><pre class="programlisting">cimport cython

<strong>@cython.final</strong>
cdef class <strong>A</strong>: pass

cdef class B (A): pass</pre></div><p>This annotation will give an error when someone tries to subclass:</p><div><pre class="programlisting">
<strong>pycode.pyx:7:5: Base class 'A' of type 'B' is final</strong>
</pre></div><p>Note that these annotations only work on the <code class="literal">cdef</code> or <code class="literal">cpdef</code> functions and not on normal Python <code class="literal">def</code> functions.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Parsing large amounts of data</h1></div></div></div><p>I want to try and prove how<a id="id151" class="indexterm"/> powerful and natively compiled C types are to programmers by showing the difference in parsing large amounts of XML. We can take the geographic data from the government as the test data for this experiment (<a class="ulink" href="http://www.epa.gov/enviro/geospatial-data-download-service">http://www.epa.gov/enviro/geospatial-data-download-service</a>).</p><p>Let's look at the size of this XML data:</p><div><pre class="programlisting">
<strong> ls -liah</strong>
<strong>total 480184</strong>
<strong>7849156 drwxr-xr-x   5 redbrain  staff   170B 25 Jul 16:42 ./</strong>
<strong>5803438 drwxr-xr-x  11 redbrain  staff   374B 25 Jul 16:41 ../</strong>
<strong>7849208 -rw-r--r--@  1 redbrain  staff   222M  9 Mar 04:27 EPAXMLDownload.xml</strong>
<strong>7849030 -rw-r--r--@  1 redbrain  staff    12M 25 Jul 16:38 EPAXMLDownload.zip</strong>
<strong>7849174 -rw-r--r--   1 redbrain  staff    57B 25 Jul 16:42 README</strong>
</pre></div><p>It's huge! Before we write programs, we need to understand a little bit about the structure of this data to see what we want to do with it. It contains facility site locations with addresses. This seems to be the bulk of the data in here, so let's try and parse it all out with a pure Python XML parser using the following:</p><div><pre class="programlisting">from <strong>xml.etree</strong> import ElementTree as <strong>etree</strong>
</pre></div><p>The code uses <code class="literal">etree</code> to parse the XML file via the following:</p><div><pre class="programlisting"> xmlroot = etree.parse (__xmlFile)</pre></div><p>Then, we look up the header and facilities via the following:</p><div><pre class="programlisting">headers = <strong>xmlroot.findall</strong> ('Header')
facs = <strong>xmlroot.findall </strong>('FacilitySite')</pre></div><p>Finally, we output them into a file:</p><div><pre class="programlisting">   try:
        fd = open (__output, "wb")
        for i in facs:
            location = ""
            for y in i:
                if isinstance (y.text, basestring):
                    location += y.tag + ": " + y.text + '\n'
            fd.write (location)
    # There is some dodgy unicode character
    # python doesn't like just ignore it
    except UnicodeEncodeError: pass
    except:
        print "Unexpected error:", sys.exc_info()[0]
        raise
    finally:
        if fd: fd.close ()</pre></div><p>We then time the<a id="id152" class="indexterm"/> execution as follows:</p><div><pre class="programlisting">
<strong>10-4-5-52:bigData redbrain$ time python pyparse.py</strong>
<strong>USEPA Geospatial DataEnvironmental Protection AgencyUSEPA Geospatial DataThis XML file was produced by US EPA and contains data specifying the locations of EPA regulated facilities or cleanups that are being provided by EPA for use by commercial mapping services and others with an interest in using this information. Updates to this file are produced on a regular basis by EPA and those updates as well as documentation describing the contents of the file can be found at URL:http://www.epa.gov/enviro</strong>
<strong>MAR-08-2013</strong>
<strong>[INFO] Number of Facilties 118421</strong>
<strong>[INFO] Dumping facilities to xmlout.dat</strong>

<strong>real    2m21.936s</strong>
<strong>user    1m58.260s</strong>
<strong>sys     0m9.5800s</strong>
</pre></div><p>This is quite long, but let's compare it using a different XML implementation—Python <code class="literal">lxml</code>. It's a different library implemented using Cython, but it implements the same library as the previous pure Python XML parser:</p><div><pre class="programlisting">
<strong>10-4-5-52:bigData redbrain$ sudo pip install lxml</strong>
</pre></div><p>We can simply drop the replacement import into the following:</p><div><pre class="programlisting">from <strong>lxml</strong> import <strong>etree</strong>
</pre></div><p>The code stays the same, but the execution time is dramatically reduced (compile the Cython version by running <code class="literal">make</code> and the <code class="literal">cpyparse</code> binary is created from the same code with just a different import):</p><div><pre class="programlisting">
<strong>10-4-5-52:bigData redbrain$ time ./cpyparse</strong>
<strong>USEPA Geospatial DataEnvironmental Protection AgencyUSEPA Geospatial DataThis XML file was produced by US EPA and contains data specifying the locations of EPA regulated facilities or cleanups that are being provided by EPA for use by commercial mapping services and others with an interest in using this information. Updates to this file are produced on a regular basis by EPA and those updates as well as documentation describing the contents of the file can be found at URL:http://www.epa.gov/enviro</strong>
<strong>MAR-08-2013</strong>
<strong>[INFO] Number of Facilties 118421</strong>
<strong>[INFO] Dumping facilities to xmlout.dat</strong>

<strong>real    0m7.874s</strong>
<strong>user    0m5.307s</strong>
<strong>sys     0m1.839s</strong>
</pre></div><p>You can really see the power of using native code when you make just a little effort. And to be finally assured that the code is the same, let's <code class="literal">MD5</code> sum <code class="literal">xmlout.dat</code> that we created:</p><div><pre class="programlisting">
<strong>10-4-5-52:bigData redbrain$ md5 xmlout.dat xmlout.dat.cython</strong>
<strong>MD5 (xmlout.dat.python) = c2103a2252042f143489216b9c238283</strong>
<strong>MD5 (xmlout.dat.cython) = c2103a2252042f143489216b9c238283</strong>
</pre></div><p>So, you can <a id="id153" class="indexterm"/>see that the outputs are exactly the same just so we know that no funny business is going on. It's scary how much faster this can make your XML parsing; and if we calculate the speed increase rate, it is approximately 17.75 times faster; but don't take my word for it; try running it yourself. My MacBook has a solid state disk and has a 4 GB RAM with a 2 GHz Core 2 Duo.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Summary</h1></div></div></div><p>Up to now, you will have seen the core of what's possible with Cython. In this chapter, we covered calling into C++ classes from Cython. You learned to wrap templates and even look at a more complex application demonstrating the usage of <code class="literal">gil</code> and <code class="literal">nogil</code>.</p><p><a class="link" href="ch06.html" title="Chapter 6. Further Reading">Chapter 6</a>, <em>Further Reading</em> is the final chapter and will review some final caveats and usages with Cython. I will show how you can use Cython with Python 3. Finally, we will look at related projects and my opinions on their usages.</p></div></div>
</body></html>