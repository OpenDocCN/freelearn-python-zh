- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Containerization and Flask Application Deployment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化与Flask应用程序部署
- en: After a long journey, we’ve reached the last chapter! We’re thrilled beyond
    words! Right now, we are about to embark on the last lap of showcasing our full
    stack web application to the world. In today’s modern software development sphere,
    the pace of containerization adoption is rapidly increasing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 经过漫长的旅程，我们终于到达了最后一章！我们兴奋得无法用言语表达！现在，我们即将开始展示我们的全栈Web应用程序给世界的最后一圈。在当今的软件开发生态中，容器化采用的步伐正在迅速加快。
- en: According to Gartner’s predictions, the adoption of containerized applications
    in production will increase significantly, with more than 75% of global organizations
    expected to utilize them by 2022, a notable increase from the less than 30% reported
    in 2020 ([https://www.gartner.com/en/documents/3985796](https://www.gartner.com/en/documents/3985796)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Gartner的预测，生产中容器化应用程序的采用将显著增加，预计到2022年，全球超过75%的组织将使用它们，这一比例从2020年报告的不到30%有显著增长
    ([https://www.gartner.com/en/documents/3985796](https://www.gartner.com/en/documents/3985796))。
- en: Containerization and the deployment of software applications have become essential
    skills needed for developers to stay modern and in demand. Developers who have
    the skills and knowledge to containerize and deploy software applications are
    better equipped to meet the demands of modern software development practices,
    stay up to date with industry trends, and remain competitive in the job market.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化与软件应用程序的部署已成为开发者保持现代性和需求所必需的技能。那些拥有容器化和部署软件应用程序技能和知识的开发者，将更好地满足现代软件开发实践的需求，跟上行业趋势，并在就业市场上保持竞争力。
- en: Containerization allows developers to package applications and required dependencies
    into a standardized and portable container that can run consistently across different
    computing environments. And, of course, deployment ensures that your application
    gets to the production environment, where it can be used by end users.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化允许开发者将应用程序及其所需依赖打包成一个标准化的、可移植的容器，该容器可以在不同的计算环境中一致运行。当然，部署确保了你的应用程序能够到达生产环境，在那里最终用户可以使用它。
- en: In this chapter, we will discuss containerization as a revolution changing the
    information technology industry. We will touch on the significance and benefits
    of containerization in software development, as well as exploring the issues it
    tackles.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论容器化作为改变信息技术行业的革命。我们将探讨容器化在软件开发中的重要性及其带来的好处，以及它所解决的问题。
- en: Furthermore, we will delve into one of the containerization platforms in the
    software development industry, called **Docker**. We will introduce Docker and
    use it to containerize both the React frontend and the Flask backend. We will
    discuss Docker’s benefits and why it is popular among developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将深入探讨软件开发行业中的一种容器化平台，称为**Docker**。我们将介绍Docker，并使用它来容器化React前端和Flask后端。我们将讨论Docker的优势以及为什么它在开发者中如此受欢迎。
- en: By the end of the chapter, you will understand the importance of containerization
    in modern software development, and you will be able to package React and Flask
    applications into containers ready to be shipped and shared.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解容器化在现代软件开发中的重要性，你将能够将React和Flask应用程序打包成可以运输和共享的容器。
- en: Finally, you will learn how to use **Amazon Web Services** (**AWS**) Elastic
    Beanstalk to deploy React-Flask applications leveraging the AWS fully managed
    cloud platform, which allows developers to deploy, manage, and scale their web
    applications and services with ease.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习如何使用**亚马逊网络服务**（**AWS**）Elastic Beanstalk来部署利用AWS完全托管云平台的React-Flask应用程序，这使得开发者可以轻松地部署、管理和扩展他们的Web应用程序和服务。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is containerization?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是容器化？
- en: Introducing Docker
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Docker
- en: Dockerizing React and Flask applications
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化React和Flask应用程序
- en: Understanding AWS Elastic Container Registry
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解AWS弹性容器注册
- en: Using `docker-compose`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker-compose`
- en: Deploying React and Flask applications to AWS Elastic Beanstalk
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将React和Flask应用程序部署到AWS Elastic Beanstalk
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16)。
- en: Due to page count constraints, some of the long code blocks have been shortened.
    Please refer to GitHub for the complete code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页面数量限制，一些较长的代码块已被缩短。请参考GitHub获取完整代码。
- en: What is containerization?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器化？
- en: '**Containerization** is a software development practice that involves packaging
    an application and required dependencies into a self-contained unit called a **container**.
    A container is an isolated and lightweight runtime environment that provides a
    consistent and reproducible way to run an application across different computing
    environments.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器化**是一种软件开发实践，涉及将应用程序及其所需依赖项打包到一个称为**容器**的自包含单元中。容器是一个隔离和轻量级的运行时环境，提供了一种在不同计算环境中一致和可重复运行应用程序的方式。'
- en: Let’s say you have developed a web application using the Flask framework on
    your local machine running on MacOS. You want to deploy this application to a
    server running Ubuntu Linux in a production environment. However, there may be
    differences in the versions of the operating system, dependencies, or other system
    configurations that could affect the behavior of your application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在运行MacOS的本地机器上使用Flask框架开发了一个Web应用程序。你希望将这个应用程序部署到运行Ubuntu Linux的服务器上，以生产环境运行。然而，操作系统版本、依赖项或其他系统配置可能存在差异，这些差异可能会影响应用程序的行为。
- en: By packaging your Flask application and all the required dependencies into a
    container, you can ensure that the application runs consistently and reliably
    across different computing environments. The container will provide an isolated
    and lightweight runtime environment that encapsulates the application and related
    dependencies, ensuring that it runs consistently regardless of the underlying
    system configurations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将你的Flask应用程序及其所有必需的依赖项打包到容器中，你可以确保应用程序在不同计算环境中的一致性和可靠性运行。容器将提供一个隔离和轻量级的运行时环境，封装应用程序和相关依赖项，确保它在底层系统配置变化的情况下也能一致运行。
- en: Containers are like **virtual machines** (**VMs**) in that they provide a way
    to isolate applications from the underlying host operating system. However, while
    VMs require a complete copy of the host operating system to run, containers only
    require the minimal runtime components needed to run the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 容器类似于**虚拟机（VMs**），因为它们提供了一种将应用程序与底层主机操作系统隔离的方法。然而，虽然VMs需要主机操作系统的完整副本才能运行，但容器只需要运行应用程序所需的最小运行时组件。
- en: Containers utilize a technique called containerization, which employs virtualization
    at the operating system level. Containerization allows multiple containers to
    run on the same host operating system, each with its own isolated filesystem,
    networking, and process space. With containerization, developers can lower the
    deployment time and cost.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器利用一种称为容器化的技术，该技术使用操作系统的虚拟化。容器化允许在同一主机操作系统上运行多个容器，每个容器都有自己的独立文件系统、网络和进程空间。通过容器化，开发者可以降低部署时间和成本。
- en: 'Let’s check out a few other benefits of containerization:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看容器化的其他一些好处：
- en: Containers provide a standardized way of packaging applications and required
    dependencies, which reduces the time and effort required for configuration and
    setup.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器提供了一种标准化的打包应用程序及其所需依赖项的方式，这减少了配置和设置所需的时间和精力。
- en: Containers are portable across different computing environments, allowing for
    deployment on any system with the same container runtime. This portability approach
    eliminates the need to create and maintain separate deployment configurations
    for different environments.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以在不同的计算环境中移动，允许在任何具有相同容器运行时系统的系统上部署。这种可移植性方法消除了为不同环境创建和维护单独部署配置的需要。
- en: Containers share the same operating system kernel, enabling more efficient use
    of system resources compared to traditional virtualization.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器共享相同的操作系统内核，与传统的虚拟化相比，这能更有效地使用系统资源。
- en: Containers provide isolation between applications and accompanying dependencies,
    making the conflicts and errors that can arise when running applications on a
    shared infrastructure obsolete.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器在应用程序及其伴随的依赖项之间提供隔离，使得在共享基础设施上运行应用程序时可能出现的冲突和错误变得过时。
- en: In a nutshell, containers are lightweight, self-containing to run applications,
    portable, and efficient, and can be easily replicated and scaled as needed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，容器是轻量级的、自包含的运行应用程序，可移植的，高效的，并且可以根据需要轻松复制和扩展。
- en: 'Although there are several containerization technologies to choose from, we
    will specifically discuss Docker in the next section. Before exploring Docker
    in depth, let’s take a brief look at some of the other containerization tools
    and platforms available in the software industry:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种容器化技术可供选择，我们将在下一节具体讨论Docker。在深入探讨Docker之前，让我们简要地看看软件行业中可用的其他容器化工具和平台：
- en: '**Kubernetes**: An open source container orchestration system that automates
    deploying, scaling, and managing containerized applications'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：一个开源的容器编排系统，用于自动化部署、扩展和管理容器化应用程序'
- en: '**Apache Mesos**: An open source platform for managing and deploying containerized
    applications and big data services'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Mesos**：一个开源平台，用于管理和部署容器化应用程序和大数据服务'
- en: '**LXC/LXD**: A containerization solution that uses lightweight VMs to provide
    isolation and resource management'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LXC/LXD**：一种使用轻量级虚拟机提供隔离和资源管理的容器化解决方案'
- en: '**CoreOS rkt**: A container runtime that provides security, simplicity, and
    speed to the container environment'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CoreOS rkt**：一个为容器环境提供安全、简单和速度的容器运行时'
- en: '**OpenVZ**: An open source containerization platform that provides container-based
    virtualization for Linux'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenVZ**：一个开源的容器化平台，为Linux提供基于容器的虚拟化'
- en: '**AWS Elastic Container Service (ECS)**: A fully managed container orchestration
    service provided by AWS'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS弹性容器服务 (ECS)**: AWS提供的一项完全管理的容器编排服务'
- en: '**Google Kubernetes Engine (GKE)**: A fully managed Kubernetes service provided
    by Google Cloud Platform'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Kubernetes Engine (GKE)**：由Google Cloud Platform提供的一项完全管理的Kubernetes服务'
- en: As the demand for scalable and efficient software deployment grows, more and
    more developers are going to turn to Docker as a solution. In the next section,
    we’ll explore the basics of Docker and how it can help you streamline your development
    workflow.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对可扩展和高效软件部署的需求不断增长，越来越多的开发者将转向Docker作为解决方案。在下一节中，我们将探讨Docker的基础知识以及它如何帮助您简化开发工作流程。
- en: Introducing Docker
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Docker
- en: '**Docker** is a popular platform for developing, packaging, and deploying applications
    in containers. Before Docker’s invention, software developers had to deal with
    the problem of software dependencies, which meant that the software would work
    well on one computer but fail to work on another system.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker**是一个流行的平台，用于在容器中开发、打包和部署应用程序。在Docker发明之前，软件开发者必须处理软件依赖性问题，这意味着软件在一个电脑上运行良好，但在另一个系统上可能无法工作。'
- en: Software developers would create programs on their computers, but when they
    tried to share them with other people, things often went wrong. Programs that
    worked perfectly on one computer might not have worked on another because of differences
    in the operating system, software versions, configuration files, or other system-related
    factors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发者会在他们的电脑上创建程序，但当他们试图与他人分享时，事情常常出错。在某一台电脑上运行完美的程序可能在另一台电脑上无法运行，这是因为操作系统、软件版本、配置文件或其他系统相关因素的不同。
- en: To solve this problem, a group of developers in 2013 released a tool called
    Docker. Docker lets developers package programs and all the necessary dependencies
    into something called a **Docker image**. A Docker image is a read-only template
    that contains the instructions for creating a Docker container. A Docker image
    includes the application code, runtime, libraries, dependencies, and configurations
    needed to run the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，2013年一群开发者发布了一个名为Docker的工具。Docker允许开发者将程序及其所有必要的依赖项打包成一个称为**Docker镜像**的东西。Docker镜像是一个只读模板，包含创建Docker容器的指令。Docker镜像包括运行应用程序所需的应用程序代码、运行时、库、依赖项和配置。
- en: With Docker, developers can create a Docker image for their programs and share
    it with others. A Docker container is a runnable instance of a Docker image. A
    Docker container is a lightweight, isolated, and portable environment that can
    run on any system that supports Docker. This means that the program will run the
    same way on every computer, which makes it much easier to share and deploy.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，开发者可以为他们的程序创建Docker镜像并与他人共享。Docker容器是Docker镜像的可运行实例。Docker容器是一个轻量级、隔离和可移植的环境，可以在支持Docker的任何系统上运行。这意味着程序将在每台电脑上以相同的方式运行，这使得共享和部署变得更加容易。
- en: Developers can create a Docker image by writing a **Dockerfile**, which is a
    text file that contains the instructions for building a Docker image. The Dockerfile
    specifies the base image, adds the necessary packages and files, and sets the
    configuration options for the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过编写**Dockerfile**来创建Docker镜像，这是一个包含构建Docker镜像指令的文本文件。Dockerfile指定了基础镜像，添加了必要的包和文件，并设置了应用程序的配置选项。
- en: Once you have built your application Docker image, you might want to ship to
    production or send it to other developers. To achieve this, you can use a Docker
    registry, which is a central repository for storing and distributing Docker images.
    Docker Hub is the most popular public registry, but you can also set up your own
    private registry for your organization. In the course of this chapter, we will
    store the book project Docker images in AWS **Elastic Container** **Registry**
    (**ECR**).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建了你的应用程序Docker镜像，你可能希望将其部署到生产环境或发送给其他开发者。为了实现这一点，你可以使用Docker仓库，这是一个用于存储和分发Docker镜像的中心仓库。Docker
    Hub是最受欢迎的公共仓库，但你也可以为你的组织设置自己的私有仓库。在本章的过程中，我们将存储本书项目的Docker镜像到AWS **弹性容器** **注册**
    **（ECR**）。
- en: Docker Compose is another tool of interest in the Docker ecosystem. Docker Compose
    is a tool for defining and running multi-container Docker applications. Docker
    Compose uses a YAML file to define the services, networks, and volumes needed
    to run the application. In the subsequent section, we will discuss Docker Compose
    in great detail. Next, we will explore how we can containerize a simple Flask
    application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是Docker生态系统中的另一个有趣工具。Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。Docker
    Compose使用YAML文件来定义运行应用程序所需的服务、网络和卷。在下一节中，我们将详细讨论Docker Compose。接下来，我们将探讨如何将一个简单的Flask应用程序容器化。
- en: Creating a Flask application
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Flask应用程序
- en: 'Now, let’s demonstrate with a simple Flask application the process of containerization
    using Docker:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个简单的Flask应用程序演示使用Docker进行容器化的过程：
- en: Download Docker from [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
    and install Docker on your system.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)下载Docker并在你的系统上安装Docker。
- en: '![Figure 16.1 – The download page of Docker](img/Figure_16.01_B18554.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1 – Docker的下载页面](img/Figure_16.01_B18554.jpg)'
- en: Figure 16.1 – The download page of Docker
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – Docker的下载页面
- en: Select the appropriate computer OS for your Docker platform.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择适合你的Docker平台的适当计算机操作系统。
- en: 'Once the Docker installation is complete, test it in your Terminal with the
    following command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker安装完成后，使用以下命令在终端中测试它：
- en: '[PRE0]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 16.2 – The command to verify the Docker installation](img/Figure_16.02_B18554.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2 – 验证Docker安装的命令](img/Figure_16.02_B18554.jpg)'
- en: Figure 16.2 – The command to verify the Docker installation
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2 – 验证Docker安装的命令](img/Figure_16.02_B18554.jpg)'
- en: 'Now that Docker is installed on your computer, run the `mkdir bizza-docker`
    command to create a new working directory for deploying a Flask application using
    a Docker container. Then, enter `cd bizza-docker`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在Docker已安装在你的计算机上，运行`mkdir bizza-docker`命令来创建一个新的工作目录，用于使用Docker容器部署Flask应用程序。然后，输入`cd
    bizza-docker`：
- en: '![Figure 16.3 – The creation of a Docker working directory](img/Figure_16.03_B18554.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3 – 创建Docker工作目录](img/Figure_16.03_B18554.jpg)'
- en: Figure 16.3 – The creation of a Docker working directory
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 创建Docker工作目录
- en: Let’s create a virtual environment for the new Flask Docker application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为新的Flask Docker应用程序创建一个虚拟环境。
- en: Run `python –m venv venv` in the Terminal to install a virtual environment.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行`python –m venv venv`来安装虚拟环境。
- en: 'Activate the virtual environment with these commands:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令激活虚拟环境：
- en: '`venv\Scripts\activate`'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venv\Scripts\activate`'
- en: '`source venv/bin/activate`'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source venv/bin/activate`'
- en: 'Inside the Docker project directory, `bizza-docker/`, create an `app.py` file
    and add the following code snippet to run a simple Flask application:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker项目目录`bizza-docker/`内部，创建一个`app.py`文件，并添加以下代码片段以运行一个简单的Flask应用程序：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code runs a simple Flask app showing **Bizza Web App Dockerization!**
    in the browser.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码运行了一个简单的Flask应用程序，在浏览器中显示**Bizza Web App Docker化**！
- en: 'Create a `.flaskenv` file inside `bizza-docker/` and add the following code
    snippet:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bizza-docker/`内部创建一个`.flaskenv`文件，并添加以下代码片段：
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, run the Flask app with `flask run` in the Terminal and you will get the
    following output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中使用`flask run`运行Flask应用程序，你将得到以下输出：
- en: '![Figure 16.4 – Testing the Flask application](img/Figure_16.04_B18554.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4 – 测试Flask应用程序](img/Figure_16.04_B18554.jpg)'
- en: Figure 16.4 – Testing the Flask application
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 – 测试Flask应用程序
- en: Now that the Flask app is working, let’s create a Flask application `requirements.txt`
    file to be able to reproduce the dependencies for this simple application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Flask应用已经运行正常，让我们创建一个Flask应用程序`requirements.txt`文件，以便能够重现此简单应用程序的依赖关系。
- en: 'Run the `pip freeze > requirements.txt` command and you will get the following
    output:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`pip freeze > requirements.txt`命令，你将得到以下输出：
- en: '![Figure 16.5 – The requirements.txt file for the Flask dependencies](img/Figure_16.05_B18554.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5 – Flask依赖的requirements.txt文件](img/Figure_16.05_B18554.jpg)'
- en: Figure 16.5 – The requirements.txt file for the Flask dependencies
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 – Flask依赖的requirements.txt文件
- en: 'The following block displays the content of the `requirements.txt` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的块显示了`requirements.txt`文件的内容：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We now have all the resources to build the Docker image.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了构建Docker镜像所需的所有资源。
- en: Creating a Dockerfile
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Dockerfile
- en: A Dockerfile defines the container image for a Flask application. We are going
    to create a Dockerfile that uses the official Python 3.8 image as the base image,
    installs Flask and its dependencies, and copies the Flask application code into
    the container.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile定义了Flask应用程序的容器镜像。我们将创建一个Dockerfile，它使用官方的Python 3.8镜像作为基础镜像，安装Flask及其依赖项，并将Flask应用程序代码复制到容器中。
- en: 'In the `bizza-docker` directory, create a Dockerfile file – make sure the capital
    *D* is used in creating the Dockerfile file. Don’t worry about why; this is a
    convention:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bizza-docker`目录中，创建一个Dockerfile文件 – 确保在创建Dockerfile文件时使用大写字母*D*。不用担心为什么；这是一个约定：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To simplify the deployment process and ensure consistent environments across
    different stages of development, testing, and production, let’s examine the anatomy
    of the preceding Dockerfile.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化部署过程并确保在不同开发、测试和生产阶段之间保持环境的一致性，让我们检查前面Dockerfile的结构。
- en: 'The preceding code is a Dockerfile used to build a Docker image for a Python
    Flask web application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个用于构建Python Flask Web应用程序Docker镜像的Dockerfile：
- en: '`FROM python:3.8.2-alpine`: This specifies the base image to use for building
    the Docker image. In this case, the base image is `python:3.8.2-alpine`, which
    is a lightweight version of Python 3.8.2 optimized for running in Alpine Linux.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM python:3.8.2-alpine`: 这指定了构建Docker镜像时要使用的基镜像。在这种情况下，基镜像为`python:3.8.2-alpine`，这是Python
    3.8.2的一个轻量级版本，针对在Alpine Linux上运行进行了优化。'
- en: '`WORKDIR /packt-bizza-docker`: This sets the working directory of the Docker
    container to `/packt-bizza-docker`. All subsequent commands in the Dockerfile
    will be executed relative to this directory.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR /packt-bizza-docker`: 这将Docker容器的当前工作目录设置为`/packt-bizza-docker`。Dockerfile中的所有后续命令都将相对于此目录执行。'
- en: '`ADD . /packt-bizza-docker`: This line copies all the files and directories
    in the current directory into the `/packt-bizza-docker` directory in the Docker
    container.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD . /packt-bizza-docker`: 这一行将当前目录中的所有文件和目录复制到Docker容器中的`/packt-bizza-docker`目录。'
- en: '`COPY requirements.txt .`: This copies the `requirements.txt` file from the
    current directory to the root directory of the Docker container.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY requirements.txt .`: 这将当前目录中的`requirements.txt`文件复制到Docker容器的根目录。'
- en: '`RUN pip install --no-cache-dir -r requirements.txt`: This installs the Python
    dependencies specified in the `requirements.txt` file using `pip`. The `--no-cache-dir`
    option ensures that `pip` does not cache the downloaded packages.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN pip install --no-cache-dir -r requirements.txt`: 这使用`pip`安装`requirements.txt`文件中指定的Python依赖项。`--no-cache-dir`选项确保`pip`不会缓存下载的包。'
- en: '`RUN pip install -r requirements.txt`: This line installs the Python dependencies
    specified in the `requirements.txt` file using `pip3`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN pip install -r requirements.txt`: 这一行使用`pip3`安装`requirements.txt`文件中指定的Python依赖项。'
- en: '`COPY . .`: This copies all the files and directories in the current directory
    to the root directory of the Docker container. This includes the Flask application
    code.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY . .`: 这将当前目录中的所有文件和目录复制到Docker容器的根目录。这包括Flask应用程序代码。'
- en: '`ENV FLASK_APP=app.py, ENV FLASK_ENV=development`: This sets the environment
    variables for the Flask application. `FLASK_APP` specifies the name of the main
    Flask application file (in this case, `app.py`). `FLASK_ENV` sets the Flask environment
    to development mode.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV FLASK_APP=app.py, ENV FLASK_ENV=development`: 这设置了Flask应用程序的环境变量。`FLASK_APP`指定了主Flask应用程序文件的名称（在本例中为`app.py`）。`FLASK_ENV`将Flask环境设置为开发模式。'
- en: '`EXPOSE 5001`: This exposes port `5001` of the Docker container.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE 5001`: 这将Docker容器的`5001`端口暴露出来。'
- en: '`CMD ["python3", "app.py"]`: This specifies the command to run when the Docker
    container is started. In this case, it runs the `app.py` file using Python 3.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["python3", "app.py"]`：这指定了在Docker容器启动时要运行的命令。在这种情况下，它使用Python 3运行 `app.py`
    文件。'
- en: Next, we will build the Docker image from the preceding defined `Dockerfile`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从先前定义的 `Dockerfile` 构建Docker镜像。
- en: Building the Docker image
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: With the Dockerfile defined, you can build a Docker image of the Flask application.
    This image contains all the dependencies and configuration files required to run
    the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了Dockerfile后，您可以构建Flask应用程序的Docker镜像。此镜像包含运行应用程序所需的全部依赖项和配置文件。
- en: 'To construct the Docker image, execute the following command in the Terminal
    from within the `bizza-docker` directory that contains the Dockerfile:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建Docker镜像，请在包含Dockerfile的 `bizza-docker` 目录中从终端执行以下命令：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![Figure 16.6 – Output of the docker build command](img/Figure_16.06_B18554.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6 – `docker build` 命令的输出](img/Figure_16.06_B18554.jpg)'
- en: Figure 16.6 – Output of the docker build command
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 – `docker build` 命令的输出
- en: The preceding command will build the Docker image using the Dockerfile present
    in the current directory. The resulting image will be tagged as `packt-bizza-docker`.
    Now, let’s proceed to the next step and launch the container to make the simple
    Flask application functional.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将使用当前目录中存在的Dockerfile构建Docker镜像。生成的镜像将被标记为 `packt-bizza-docker`。现在，让我们继续下一步并启动容器以使简单的Flask应用程序生效。
- en: Running the Docker container
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Docker容器
- en: After building the Docker image, you can run a Docker container from the image.
    This container provides a lightweight, isolated, and portable environment for
    running the Flask application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像后，您可以从镜像运行Docker容器。此容器为运行Flask应用程序提供了一个轻量级、隔离和可移植的环境。
- en: 'To run the Docker container, use the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Docker容器，请使用以下命令：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will get the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![Figure 16.7 – Output of docker run in detached mode](img/Figure_16.07_B18554.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图16.7 – 分离模式下的 `docker run` 输出](img/Figure_16.07_B18554.jpg)'
- en: Figure 16.7 – Output of docker run in detached mode
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 – 分离模式下的 `docker run` 输出
- en: 'The preceding command will run the container in detached mode (`-d`) and perform
    port mapping (`-p`) by mapping the host port `5001` to the container port `5001`.
    The container will be based on the `packt-bizza-docker` image. Alternatively,
    you can run the command without the `-d` flag to launch the container in a non-detached
    mode, as shown in the following figure:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将以分离模式（`-d`）运行容器，并通过将主机端口 `5001` 映射到容器端口 `5001` 来执行端口映射（`-p`）。容器将基于 `packt-bizza-docker`
    镜像。或者，您也可以不使用 `-d` 标志来以非分离模式启动容器，如下面的图所示：
- en: '![Figure 16.8 – Output of docker run in a non-detached mode](img/Figure_16.08_B18554.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8 – 非分离模式下的 `docker run` 输出](img/Figure_16.08_B18554.jpg)'
- en: Figure 16.8 – Output of docker run in a non-detached mode
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 – 非分离模式下的 `docker run` 输出
- en: The preceding `docker run` command allows us to access the Flask application
    running inside the Docker container. You need to expose the ports on the container
    to the host machine with `-p` `5001:5001 .`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `docker run` 命令使我们能够访问Docker容器内运行的Flask应用程序。您需要使用 `-p` `5001:5001` 将容器上的端口暴露给主机机器。
- en: Now that we have the Docker container running, we can test the Flask application
    by accessing it through a web browser or using a command-line tool such as `curl-`
    `http://127.0.0.1:5001`. Make sure that the application is functioning as expected
    and that all the dependencies are working correctly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了Docker容器，我们可以通过网页浏览器或使用 `curl` 命令行工具（如 `http://127.0.0.1:5001`）来测试Flask应用程序。请确保应用程序按预期运行，并且所有依赖项都正常工作。
- en: Finally, you can push the Docker image to a Docker registry such as Docker Hub
    or AWS ECS. This makes it easy to share the image with other developers or deploy
    it to production environments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以将Docker镜像推送到Docker仓库，如Docker Hub或AWS ECS。这使得与其他开发者共享镜像或部署到生产环境变得容易。
- en: To stop a running Docker container, you can use the `docker stop` command followed
    by the *container ID* or *name*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止正在运行的Docker容器，您可以使用 `docker stop` 命令后跟 *容器ID* 或 *名称*。
- en: 'For example, if the container ID is `c2d8f8a4b5e3`, you can stop the container
    using the `docker stop c2d8f8a4b5e3` command, as shown in the following figure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果容器ID是 `c2d8f8a4b5e3`，您可以使用 `docker stop c2d8f8a4b5e3` 命令停止容器，如下面的图所示：
- en: '![Figure 16.9 – Output of the docker stop command](img/Figure_16.09_B18554.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.9 – docker stop 命令的输出](img/Figure_16.09_B18554.jpg)'
- en: Figure 16.9 – Output of the docker stop command
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.9 – docker stop 命令的输出
- en: And if you don’t know the container ID or name, you can use the `docker ps`
    command to list all running containers and their details, including the ID and
    name. Once you have identified the container that you want to stop, you can use
    the `docker stop` command as described earlier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道容器 ID 或名称，你可以使用 `docker ps` 命令列出所有正在运行的容器及其详细信息，包括 ID 和名称。一旦你确定了想要停止的容器，你可以使用前面描述的
    `docker stop` 命令。
- en: 'Let’s glance at another important Docker command: `docker` `container prune`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下另一个重要的 Docker 命令：`docker` `container prune`。
- en: The `docker container prune` command is used to remove stopped containers and
    free up disk space. When you run a Docker container, the container consumes system
    resources such as memory and CPU cycles. When you stop a container, those resources
    are freed up, but the container still exists on your system. With time, if you
    run multiple containers, you may be housing many stopped containers, which can
    take up significant disk space on your system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container prune` 命令用于删除已停止的容器并释放磁盘空间。当你运行 Docker 容器时，容器会消耗系统资源，如内存和
    CPU 周期。当你停止容器时，这些资源会被释放，但容器仍然存在于你的系统中。随着时间的推移，如果你运行多个容器，你可能会拥有许多已停止的容器，这可能会占用你系统上大量的磁盘空间。'
- en: Running the `docker container prune` command is a simple way to remove all stopped
    containers and reclaim disk space. This `docker container prune` command will
    prompt you to confirm that you want to remove the containers before proceeding,
    so make sure you review the list of containers carefully before confirming.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker container prune` 命令是一种简单的方法来删除所有已停止的容器并回收磁盘空间。在继续之前，此 `docker container
    prune` 命令将提示你确认是否要删除容器，因此请在确认之前仔细检查容器列表。
- en: It’s important to note that the `docker container prune` command will only remove
    stopped containers. If you have any running containers, they will not be affected
    by this command.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`docker container prune` 命令只会删除已停止的容器。如果你有任何正在运行的容器，它们将不会受到此命令的影响。
- en: Next, we will discuss the process of dockerizing React and Flask applications.
    We will use the full stack Bizza web application as a case study.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 Docker 化 React 和 Flask 应用程序的过程。我们将使用全栈 Bizza 网络应用程序作为案例研究。
- en: Dockerizing React and Flask applications
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 化 React 和 Flask 应用程序
- en: Dockerizing web applications allows developers to set up a consistent development
    environment across different machines. Dockerizing tools reduce the time and effort
    required to set up a new development environment. With Docker, developers can
    easily replicate the production environment on their local machines, test their
    code, and debug any issues before deploying it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 化网络应用程序允许开发者在不同的机器上设置一致的开发环境。Docker 化工具减少了设置新开发环境所需的时间和精力。使用 Docker，开发者可以轻松地在本地机器上复制生产环境，测试他们的代码，并在部署之前调试任何问题。
- en: In this section, we will dockerize working applications for React and Flask,
    and make them ready to be shipped for production.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对 React 和 Flask 的工作应用程序进行 Docker 化，并使其准备好用于生产。
- en: Let’s start with the React.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 React 开始。
- en: Bizza frontend application with React
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React 的 Bizza 前端应用程序
- en: Once you have created your React application, the initial step toward making
    it accessible to internet users is to build the application. Building a React
    application is an essential step in the development process to ensure that the
    application is optimized for production and performs as expected.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了你的 React 应用程序，使其对互联网用户可访问的第一步就是构建该应用程序。构建 React 应用程序是开发过程中的一个关键步骤，以确保应用程序针对生产进行了优化，并按预期运行。
- en: 'The building process takes the source code of a React project and transforms
    it into a production-ready format that can be deployed and served to users:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程将 React 项目的源代码转换成可用于部署和向用户提供的生产就绪格式：
- en: Let’s download the *Bizza* app directory from the GitHub repo – [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/frontend](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/frontend).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 GitHub 仓库下载 *Bizza* 应用程序目录 – [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/frontend](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/frontend)。
- en: To install the dependencies required for the application, navigate to the `bizza/frontend`
    directory and execute the `npm install` command in the Terminal.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装应用程序所需的依赖项，请导航到 `bizza/frontend` 目录，并在终端中执行 `npm install` 命令。
- en: To run the frontend application, execute the `npm start` command in the Terminal.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行前端应用程序，请在终端中执行 `npm start` 命令。
- en: Now, let’s build the application with the `npm run` `build` command.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `npm run build` 命令构建应用程序。
- en: Now that the *bizza* React application has been built, the resulting files can
    be deployed to a web server or cloud platform and served to users. The eventual
    build directory is located inside `bizza/frontend/src/build`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着 *bizza* React 应用程序的构建完成，生成的文件可以部署到 Web 服务器或云平台，并向用户提供服务。最终的构建目录位于 `bizza/frontend/src/build`
    内。
- en: 'During the build process, the following steps were taken:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，采取了以下步骤：
- en: '**Transpiling JavaScript and JSX code**: React applications are typically written
    in JavaScript and JSX, a syntax extension for JavaScript. However, modern web
    browsers can only execute JavaScript code. Therefore, before deploying a React
    application, the JavaScript and JSX code needs to be transpiled into plain JavaScript
    using a tool such as Babel.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**转换 JavaScript 和 JSX 代码**：React 应用程序通常用 JavaScript 和 JSX 编写，JSX 是 JavaScript
    的语法扩展。然而，现代网络浏览器只能执行 JavaScript 代码。因此，在部署 React 应用程序之前，需要使用像 Babel 这样的工具将 JavaScript
    和 JSX 代码转换为纯 JavaScript。'
- en: '**Bundling the code and assets**: React applications often consist of multiple
    components, modules, and assets such as images, CSS files, and fonts. Bundling
    involves grouping all the required code and assets into a single file or set of
    files that can be served to the user.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打包代码和资源**：React 应用程序通常由多个组件、模块以及如图像、CSS 文件和字体等资源组成。打包涉及将所有必需的代码和资源组合成一个文件或一组文件，以便向用户提供服务。'
- en: '**Optimizing the code and assets**: To improve performance, the bundled code
    and assets can be optimized by minifying, compressing, or removing unnecessary
    code.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优化代码和资源**：为了提高性能，打包的代码和资源可以通过压缩、压缩或删除不必要的代码进行优化。'
- en: '`build` or `dist`.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build` 或 `dist`。'
- en: Now, typically at this stage, the `build` directory contents are deployed to
    a web server or cloud for end users. However, for the deployment process outlined
    in this book, you will utilize a Docker functionality known as **multi-stage builds**.
    A multi-stage build is a feature in Docker that allows you to create a Docker
    image that consists of multiple stages, where each stage is a self-contained Docker
    image with a specific purpose.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通常在这个阶段，`build` 目录的内容会被部署到 Web 服务器或云平台，供最终用户使用。然而，对于本书中概述的部署过程，您将利用 Docker
    的一项功能，称为 **多阶段构建**。多阶段构建是 Docker 的一项功能，允许您创建一个由多个阶段组成的 Docker 镜像，其中每个阶段都是一个具有特定用途的自包含
    Docker 镜像。
- en: The purpose of a multi-stage build is to optimize the size and efficiency of
    Docker images. With a multi-stage build, you can reduce the size of your final
    Docker image by only including the necessary files and dependencies. This results
    in faster builds, smaller image sizes, and more efficient use of resources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建的目的是优化 Docker 镜像的大小和效率。使用多阶段构建，您可以通过仅包含必要的文件和依赖项来减小最终 Docker 镜像的大小。这导致构建更快、镜像尺寸更小，以及资源使用更高效。
- en: The multi-stage build process involves creating multiple Docker images, each
    with a specific purpose. The first stage of the build typically contains the source
    code, dependencies, libraries, and other necessary files.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建过程涉及创建多个 Docker 镜像，每个镜像都有特定的用途。构建的第一阶段通常包含源代码、依赖项、库和其他必要的文件。
- en: The final stage of the build usually contains only the essential files and dependencies
    required to run the application, resulting in a smaller and more efficient Docker
    image. The essence of a multi-stage build is to ensure that the intermediate stages
    are used to build and compile the application but are not included in the final
    image.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的最后阶段通常只包含运行应用程序所需的必要文件和依赖项，从而生成一个更小、更高效的 Docker 镜像。多阶段构建的本质是确保中间阶段用于构建和编译应用程序，但不包含在最终镜像中。
- en: 'Right now, let’s examine a `Dockerfile` for the React frontend app that uses
    multi-stage builds:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一个使用多阶段构建的 React 前端应用的 `Dockerfile`：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s break the preceding `Dockerfile` image-building instruction down:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的 `Dockerfile` 镜像构建指令：
- en: '`Dockerfile` creates a build stage using the Node.js `14.17.0-alpine3.13` image
    as the base. The `Dockerfile` sets the working directory to `/frontend` and copies
    the `package*.json` files from the local directory to the image. The `npm install
    --production` command is then run to install the production dependencies. Next,
    the Dockerfile copies the entire project directory to the image and runs the `npm
    run build` command to build the React app.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile` 使用 Node.js `14.17.0-alpine3.13` 镜像作为基础创建一个构建阶段。Dockerfile 设置工作目录为
    `/frontend`，并将本地目录中的 `package*.json` 文件复制到镜像中。然后运行 `npm install --production`
    命令来安装生产依赖项。接下来，Dockerfile 将整个项目目录复制到镜像中，并运行 `npm run build` 命令来构建 React 应用程序。'
- en: '`Dockerfile` creates a production stage using the smaller `nginx:1.21.0-alpine
    image` as the base. The Dockerfile copies the built React app from the build stage,
    located at `/frontend/build`, to the `nginx` HTML directory at `/usr/share/nginx/html`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile` 使用较小的 `nginx:1.21.0-alpine` 镜像作为基础创建一个生产阶段。Dockerfile 将构建阶段位于
    `/frontend/build` 的构建好的 React 应用程序复制到 `nginx` 的 HTML 目录 `/usr/share/nginx/html`。'
- en: '`EXPOSE` command exposes port `80` to allow communication with the container.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE` 命令暴露端口 `80` 以允许与容器进行通信。'
- en: '`CMD` command sets the default command to run when the container starts up.
    In this case, the `Dockerfile` starts the `nginx` server in the foreground with
    the `nginx -g ''daemon` `off;''` command.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD` 命令设置容器启动时默认运行的命令。在这种情况下，`Dockerfile` 使用 `nginx -g ''daemon off;''` 命令在前台启动
    `nginx` 服务器。'
- en: '`Dockerfile` cleans up unnecessary files, such as the `node_modules` directory
    and other configuration files, using the `RUN` command with the `rm` command to
    remove them from the image. This cleaning-up process reduces the overall size
    of the image, making it faster to deploy.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile` 使用 `rm` 命令和 `RUN` 命令清理不必要的文件，例如 `node_modules` 目录和其他配置文件，从而减少镜像的整体大小，使其部署更快。'
- en: Now that we have the Docker image of the bizza frontend React app. Let’s create
    the Flask backend Docker image.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 bizza 前端 React 应用的 Docker 镜像。让我们创建 Flask 后端 Docker 镜像。
- en: Bizza backend application with Flask
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Flask 的 Bizza 后端应用程序
- en: 'In the Flask backend, we are going to create two Docker images. Download the
    full Flask backend application here: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/backend](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/backend).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask 后端，我们将创建两个 Docker 镜像。在此处下载完整的 Flask 后端应用程序：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/backend](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/backend)。
- en: We will create a Docker image for the Flask application and another Docker image
    for PostgreSQL. While it is possible to fuse the two images into a single Docker
    image, it is a best practice to separate the concerns for scalability and to reduce
    the image size.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 Flask 应用程序创建一个 Docker 镜像，并为 PostgreSQL 创建另一个 Docker 镜像。虽然将这两个镜像融合成一个单独的
    Docker 镜像是可能的，但为了可扩展性和减小镜像大小，将它们分开是最佳实践。
- en: Let’s review the Flask application multi-stage build Dockerfile definition.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾 Flask 应用程序多阶段构建 Dockerfile 的定义。
- en: 'The Dockerfile for the Flask application will be stored in the project `root`
    directory while a subdirectory named `postgres` will house the Dockerfile for
    PostgreSQL:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 应用程序的 Dockerfile 将存储在项目 `root` 目录中，而名为 `postgres` 的子目录将包含 PostgreSQL 的
    Dockerfile：
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s break down the preceding Dockerfile.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的 Dockerfile。
- en: 'This Dockerfile defines a multi-stage build for a Flask application. The Dockerfile
    has two stages: `build` and `run`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 定义了一个 Flask 应用程序的多阶段构建。Dockerfile 有两个阶段：`build` 和 `run`。
- en: 'The first stage, `build`, is responsible for building the application and installing
    the required dependencies. Right now, let’s check what each line of the build
    stage does:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段 `build` 负责构建应用程序并安装所需的依赖项。现在，让我们检查构建阶段每一行的作用：
- en: '`FROM python:3.8.12-slim-buster AS build`: This line sets the base image for
    the build stage to `python:3.8.12-slim-buster`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM python:3.8.12-slim-buster AS build`：这一行将构建阶段的基镜像设置为 `python:3.8.12-slim-buster`。'
- en: '`WORKDIR /app`: This line sets the working directory to `/app`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR /app`：这一行设置工作目录为 `/app`。'
- en: '`COPY requirements.txt .`: This line copies the `requirements.txt` file from
    the host machine to the `/app` directory in the container.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY requirements.txt .`：这一行将主机机器上的 `requirements.txt` 文件复制到容器中的 `/app` 目录。'
- en: '`RUN pip install --no-cache-dir -U pip==21.3.1 && \ pip install --no-cache-dir
    --user -r requirements.txt`: These lines update `pip` to version `21.3.1` and
    install the Python packages specified in the `requirements.txt` file.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN pip install --no-cache-dir -U pip==21.3.1 && \ pip install --no-cache-dir
    --user -r requirements.txt`: 这些行将 `pip` 更新到版本 `21.3.1` 并安装 `requirements.txt`
    文件中指定的 Python 包。'
- en: The `--no-cache-dir` option is used to prevent the installation from using any
    cached data from previous runs, which helps ensure that the installed packages
    are up to date and match the versions specified in `requirements.txt`. The `--user`
    option is used to install the packages to the user’s home directory, which helps
    avoid permission issues.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `--no-cache-dir` 选项是为了防止安装过程中使用之前运行中缓存的任何数据，这有助于确保安装的包是最新的，并且与 `requirements.txt`
    中指定的版本相匹配。使用 `--user` 选项将包安装到用户的家目录中，这有助于避免权限问题。
- en: '`COPY . .`: This line copies the entire application directory from the host
    machine to the `/app` directory in the container.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY . .`: 这行将整个应用程序目录从主机机器复制到容器的 `/app` 目录。'
- en: '`FROM python:3.8.12-slim-buster AS run`: This represents the start of the second
    stage.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM python:3.8.12-slim-buster AS run`: 这表示第二阶段的开始。'
- en: 'The second stage, `run`, is responsible for running the application in a production
    environment. The line sets the base image for the `run` stage to `python:3.8.12-slim-buster`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段，`run`，负责在生产环境中运行应用程序。这行将 `run` 阶段的基镜像设置为 `python:3.8.12-slim-buster`：
- en: '`WORKDIR /app`: This line sets the working directory to `/app`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR /app`: 这行设置工作目录为 `/app`。'
- en: '`COPY --from=build /root/.local /root/.local` and `COPY --from=build /app .`:
    These two lines copy the application directory and the installed packages from
    the build stage to the `run` stage. The first line copies the installed packages
    from the build stage to the `/root/.local` directory in the run stage. The second
    line copies the application directory from the build stage to the `/app` directory
    in the run stage.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY --from=build /root/.local /root/.local` 和 `COPY --from=build /app .`:
    这两行将应用程序目录和已安装的包从构建阶段复制到 `run` 阶段。第一行将已安装的包从构建阶段复制到运行阶段的 `/root/.local` 目录。第二行将应用程序目录从构建阶段复制到运行阶段的
    `/app` 目录。'
- en: '`ENV PATH=/root/.local/bin:$PATH`, `ENV FLASK_APP=app.py`, and `ENV FLASK_ENV=production`:
    These three lines set the environment variables for the application. The `PATH`
    environment variable is updated to include the `/root/.local/bin` directory, which
    contains the installed packages.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV PATH=/root/.local/bin:$PATH`, `ENV FLASK_APP=app.py`, 和 `ENV FLASK_ENV=production`:
    这三行设置了应用程序的环境变量。`PATH` 环境变量被更新以包含 `/root/.local/bin` 目录，该目录包含已安装的包。'
- en: This ensures that the installed packages are available in the system `PATH`.
    The `FLASK_APP` environment variable is set to `app.py`, which specifies the main
    application file for Flask to run. The `FLASK_ENV` environment variable is set
    to `production`, which enables features such as better error handling and improved
    performance.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保了安装的包在系统的 `PATH` 中可用。`FLASK_APP` 环境变量被设置为 `app.py`，这指定了 Flask 运行的主应用程序文件。`FLASK_ENV`
    环境变量被设置为 `production`，这启用了诸如更好的错误处理和改进的性能等特性。
- en: '`EXPOSE 5001`: This line exposes port `5001`, which is the port that the Flask
    application will listen on.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE 5001`: 这行暴露端口 `5001`，这是 Flask 应用程序将监听的端口。'
- en: '`CMD ["python3", "app.py"]`: This line specifies the default command to run
    when the container starts. It runs the `app.py` file using the `python3` command.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["python3", "app.py"]`: 这行指定了容器启动时默认运行的命令。它使用 `python3` 命令运行 `app.py`
    文件。'
- en: Having discussed the Dockerfile for the main Flask application, let’s examine
    the Dockerfile for PostgreSQL.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了主 Flask 应用程序的 Dockerfile 之后，让我们检查 PostgreSQL 的 Dockerfile。
- en: 'Here’s the Dockerfile for Postgres to create a database image:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于创建数据库镜像的 Postgres Dockerfile：
- en: '[PRE9]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s go through the Postgres Dockerfile:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 Postgres Dockerfile 来了解：
- en: '`FROM postgres:13-alpine`: This line specifies the base image for our Docker
    container, which is `postgres:13-alpine`. This image is based on the Alpine Linux
    distribution and includes PostgreSQL version 13.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM postgres:13-alpine`: 这行指定了我们的 Docker 容器的基镜像，即 `postgres:13-alpine`。这个镜像基于
    Alpine Linux 发行版，并包含 PostgreSQL 版本 13。'
- en: '`ENV POSTGRES_DB=<database_name>`, `ENV POSTGRES_USER=<database_user>`, and
    `ENV POSTGRES_PASSWORD=<database_password>`: These three lines set the environment
    variables for the Postgres container. The `POSTGRES_DB` variable specifies the
    name of the database to be created. The `POSTGRES_USER` variable specifies the
    username to be created for the database, and the `POSTGRES_PASSWORD` variable
    specifies the password for that user.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV POSTGRES_DB=<database_name>`, `ENV POSTGRES_USER=<database_user>`, 和 `ENV
    POSTGRES_PASSWORD=<database_password>`：这三行设置了Postgres容器的环境变量。`POSTGRES_DB`变量指定要创建的数据库的名称。`POSTGRES_USER`变量指定为数据库创建的用户名，而`POSTGRES_PASSWORD`变量指定该用户的密码。'
- en: '`RUN apk add --no-cache --update bash`: This line copies the `init.sql` file
    to the `/docker-entrypoint-initdb.d/` directory in the container. This directory
    is used by the Postgres image to run initialization scripts when the container
    is first started. In this case, the `init.sql` file is a script that will create
    the database and any necessary tables.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN apk add --no-cache --update bash`：这一行将`init.sql`文件复制到容器中的`/docker-entrypoint-initdb.d/`目录。这个目录用于Postgres镜像在容器首次启动时运行初始化脚本。在这种情况下，`init.sql`文件是一个脚本，将创建数据库和任何必要的表。'
- en: '`EXPOSE 5432`: This line exposes port `5432`, which is the default port used
    by PostgreSQL, to allow connections from outside the container. However, this
    does not actually publish the port, as this needs to be done at runtime using
    the `docker run` or `docker-compose` commands.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE 5432`：这一行暴露了默认由PostgreSQL使用的端口`5432`，以便允许从容器外部建立连接。然而，这实际上并没有发布端口，因为这需要在运行时使用`docker
    run`或`docker-compose`命令来完成。'
- en: This Postgres Dockerfile can be used to build a Docker image for a Postgres
    database, which can be used in conjunction with React and Flask application Docker
    containers to build a complete web application stack.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Postgres Dockerfile可以用来构建Postgres数据库的Docker镜像，它可以与React和Flask应用的Docker容器一起使用，以构建一个完整的Web应用堆栈。
- en: With the Flask application and Postgres images well defined, we will be pushing
    the created Docker images to AWS ECR for online storage of Docker images.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask应用和Postgres镜像定义良好后，我们将把创建的Docker镜像推送到AWS ECR以进行在线存储。
- en: Understanding AWS ECR
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解AWS ECR
- en: Amazon ECR is a fully managed Docker registry service that makes it easy to
    store, manage, and deploy Docker images. Amazon ECR is integrated with Amazon
    ECS to provide a seamless experience for building, deploying, and managing containerized
    applications at scale. Amazon ECR is designed to scale to meet the needs of even
    the most demanding containerized applications. Amazon ECR has security features
    to protect your container images, including encryption at rest and in transit,
    and **role-based access** **control** (**RBAC**).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECR是一个完全托管的Docker注册服务，它使得存储、管理和部署Docker镜像变得容易。Amazon ECR与Amazon ECS集成，以提供构建、部署和管理大规模容器化应用的无缝体验。Amazon
    ECR旨在扩展以满足甚至最苛刻的容器化应用的需求。Amazon ECR具有安全功能来保护您的容器镜像，包括静态和传输中的加密，以及**基于角色的访问控制**（RBAC）。
- en: To begin using Amazon ECR, the first step is to create an ECR repository. Please
    refer to the following screenshot of the Amazon ECR interface.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Amazon ECR，第一步是创建一个ECR仓库。请参考以下Amazon ECR界面的截图。
- en: Click on the **Get Started** button to initiate the repository creation process.
    This will allow you to establish a dedicated location for storing your Docker
    images.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**开始使用**按钮以启动仓库创建过程。这将允许您为存储Docker镜像创建一个专用位置。
- en: "![Figure 16.10 \uFEFF– AWS ECR](img/Figure_16.10_B18554.jpg)"
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10 – AWS ECR](img/Figure_16.10_B18554.jpg)'
- en: Figure 16.10 – AWS ECR
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – AWS ECR
- en: 'Next, we have a screenshot showcasing a public repository named `packt-bizza-web-app`
    in Amazon ECR:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个截图展示了在Amazon ECR中名为`packt-bizza-web-app`的公共仓库：
- en: '![Figure 16.11 – The public repository](img/Figure_16.11_B18554.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图16.11 – 公共仓库](img/Figure_16.11_B18554.jpg)'
- en: Figure 16.11 – The public repository
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11 – 公共仓库
- en: A **repository** is a logical container for storing your Docker images. Once
    you have created a repository, you can push your Docker images to the repository.
    You can then pull your images from the repository to deploy them to your ECS clusters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**仓库**是存储您的Docker镜像的逻辑容器。一旦创建了仓库，您就可以将Docker镜像推送到仓库。然后，您可以从仓库拉取镜像以部署到您的ECS集群。'
- en: Amazon ECR is a powerful tool that can help you to simplify the management of
    your container images. Interestingly, Amazon ECR is very cost-effective in storing
    and managing container images.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECR 是一个强大的工具，可以帮助您简化容器镜像的管理。有趣的是，Amazon ECR 在存储和管理容器镜像方面非常经济高效。
- en: Using ECR is free; you only pay for the storage and bandwidth that you use.
    Next, we will use Docker Compose to define and run the React, Flask, and Postgres
    containers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ECR 是免费的；您只需为使用的存储和带宽付费。接下来，我们将使用 Docker Compose 来定义和运行 React、Flask 和 Postgres
    容器。
- en: Using Docker Compose
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose
- en: '**Docker Compose** is a tool for defining and running multi-container Docker
    applications. Docker Compose provides a tool to define a set of containers and
    their relationships to each other, and then run them all with a single command.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker Compose** 是一个用于定义和运行多容器 Docker 应用的工具。Docker Compose 提供了一个工具来定义一组容器及其相互之间的关系，然后通过单个命令运行它们所有。'
- en: With Docker Compose, developers can define the exact configuration of the application’s
    containers, including the images, environment variables, and network settings.
    This ensures that the application runs consistently across different environments
    and can be easily reproduced.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Compose，开发者可以定义应用程序容器的确切配置，包括镜像、环境变量和网络设置。这确保了应用程序在不同环境中的一致运行，并且可以轻松地复制。
- en: 'The following are a few components of Docker Compose we need to understand
    before we delve into details for configuration definitions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解配置定义的细节之前，我们需要了解 Docker Compose 的以下几个组件：
- en: '**YAML file**: A YAML file is used to define the configuration of your application’s
    containers. The YAML file specifies the images to use, ports to expose, environment
    variables, and any other settings that are required.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAML 文件**: YAML 文件用于定义应用程序容器的配置。YAML 文件指定了要使用的镜像、要公开的端口、环境变量以及任何其他所需的设置。'
- en: '**Services**: Each container in your application is defined as a service in
    the YAML file. Services can depend on each other and can be started and stopped
    together.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务（Services）**: 您应用程序中的每个容器都在 YAML 文件中定义为服务。服务可以相互依赖，并且可以一起启动和停止。'
- en: '**Networks**: Docker Compose creates a network for your application, allowing
    the containers to communicate with each other.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络（Networks）**: Docker Compose 为您的应用程序创建一个网络，允许容器之间相互通信。'
- en: '**Volumes**: Volumes are used to persist data between container runs.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷（Volumes）**: 卷用于在容器运行之间持久化数据。'
- en: '**Commands**: Docker Compose provides a set of commands to start, stop, and
    manage your application.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令（Commands）**: Docker Compose 提供了一套命令来启动、停止和管理您的应用程序。'
- en: 'Now, let’s create a Docker Compose file that manages the relationship between
    the React frontend, Flask backend, and PostgreSQL database containers:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 Docker Compose 文件来管理 React 前端、Flask 后端和 PostgreSQL 数据库容器之间的关系：
- en: Inside the main project directory, `bizza/`, create `docker-compose.yaml`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主项目目录 `bizza/` 内，创建 `docker-compose.yaml`。
- en: 'Define services for each container. In the `docker-compose.yaml` file, define
    a separate service for each container:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个容器定义服务。在 `docker-compose.yaml` 文件中，为每个容器定义一个独立的服务：
- en: '[PRE10]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we define three services: `frontend`, `backend`, and
    `db`. The `frontend` service runs the *Bizza* frontend React app, the `backend`
    service runs the *Bizza* backend Flask app, and the `db` service runs the PostgreSQL
    database.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了三个服务：`frontend`、`backend` 和 `db`。`frontend` 服务运行 *Bizza* 前端 React
    应用，`backend` 服务运行 *Bizza* 后端 Flask 应用，而 `db` 服务运行 PostgreSQL 数据库。
- en: Now, let’s configure networking and dependencies. Use the `ports` and `depend_
    on` options to configure the network connections between the services. For instance,
    the frontend service is exposed on port `3000`, the backend service is exposed
    on port `5000`, and the `db` service is exposed on port `5432`. The backend service
    also depends on the `db` service, so the backend will start after the `db` service
    is running.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置网络和依赖关系。使用 `ports` 和 `depend_on` 选项配置服务之间的网络连接。例如，前端服务在端口 `3000` 上公开，后端服务在端口
    `5000` 上公开，而 `db` 服务在端口 `5432` 上公开。后端服务还依赖于 `db` 服务，因此后端将在 `db` 服务启动后启动。
- en: Once we’ve defined the services in the `docker-compose.yaml` file, we can start
    the containers using the `docker-compose up` command. This will start the containers
    and connect them to the appropriate network.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 `docker-compose.yaml` 文件中定义了服务，我们就可以使用 `docker-compose up` 命令启动容器。这将启动容器并将它们连接到适当的网络。
- en: With Docker Compose managing the application’s containers, we can simplify the
    process of starting and stopping our application, as well as ensure that all the
    required components are running correctly and communicating with each other.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Docker Compose 管理应用的容器，我们可以简化启动和停止应用的过程，同时确保所有必需的组件都在正确运行并相互通信。
- en: Interestingly, Docker Compose is a useful tool for managing containers; however,
    Docker Compose is more suited to small-scale deployments and development environments.
    Docker Compose serves the purpose of the *bizza* project, being a small-scale
    application for learning purposes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Docker Compose 是一个用于管理容器的有用工具；然而，Docker Compose 更适合小规模部署和开发环境。Docker Compose
    适用于 *bizza* 项目，这是一个用于学习目的的小规模应用。
- en: However, AWS Elastic Beanstalk, on the other hand, is designed to handle production-grade
    workloads and provides many features and benefits that can help simplify the management
    and scaling of web applications. Regardless, we will pivot the *bizza* application's
    final deployment on AWS Elastic Beanstalk.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，AWS Elastic Beanstalk 是设计来处理生产级工作负载的，并提供许多功能和好处，可以帮助简化 Web 应用管理和扩展。无论如何，我们将把
    *bizza* 应用的最终部署转向 AWS Elastic Beanstalk。
- en: In the next section, we will explore AWS Elastic Beanstalk, a service for deploying
    and managing applications in the cloud.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 AWS Elastic Beanstalk，这是一个用于在云端部署和管理应用的服务。
- en: Deploying React and Flask applications to AWS Elastic Beanstalk
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 React 和 Flask 应用部署到 AWS Elastic Beanstalk
- en: '**AWS Elastic Beanstalk** is a fully managed AWS cloud service that allows
    developers to easily deploy and manage web applications and services on AWS. AWS
    Elastic Beanstalk provides a platform that simplifies the process of deploying
    and managing web applications on AWS by automatically handling the infrastructure
    provisioning, load balancing, and scaling of the application.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS Elastic Beanstalk** 是一种完全托管的 AWS 云服务，允许开发者轻松地在 AWS 上部署和管理 Web 应用和服务。AWS
    Elastic Beanstalk 提供了一个平台，通过自动处理基础设施配置、负载均衡和应用扩展，简化了在 AWS 上部署和管理 Web 应用的过程。'
- en: You can deploy Elastic Beanstalk on a wide range of programming languages and
    web frameworks, including Node.js, Python, Ruby, and Go. Elastic Beanstalk also
    integrates with other AWS services such as Amazon RDS, Amazon DynamoDB, and Amazon
    SNS to provide a complete solution for building and scaling web applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在包括 Node.js、Python、Ruby 和 Go 在内的多种编程语言和 Web 框架上部署 Elastic Beanstalk。Elastic
    Beanstalk 还与 Amazon RDS、Amazon DynamoDB 和 Amazon SNS 等其他 AWS 服务集成，以提供构建和扩展 Web
    应用的完整解决方案。
- en: With Elastic Beanstalk, developers can easily focus on coding. Once you are
    ready to deploy your application, you can simply upload your application package
    or link to a repository, and then choose the appropriate platform and environment
    for your application. Elastic Beanstalk automatically provisions the required
    resources and sets up the environment and can also automatically scale the application
    based on demand.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Elastic Beanstalk，开发者可以轻松地专注于编码。一旦你准备好部署你的应用，你可以简单地上传你的应用包或链接到一个仓库，然后选择适合你应用的适当平台和环境。Elastic
    Beanstalk 会自动配置所需资源并设置环境，还可以根据需求自动扩展应用。
- en: Also, AWS Elastic Beanstalk provides a range of capabilities and tools that
    help developers streamline their development workflows, such as **continuous integration
    and continuous delivery** (**CI/CD**) pipelines, monitoring and logging tools,
    and integration with popular development tools such as Git and Jenkins.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AWS Elastic Beanstalk 还提供了一系列功能和工具，帮助开发者简化他们的开发工作流程，例如 **持续集成和持续交付**（**CI/CD**）管道、监控和日志工具，以及与流行的开发工具如
    Git 和 Jenkins 的集成。
- en: 'Now, let’s get started with using Elastic Beanstalk to deploy our application.
    This guide assumes you have created an AWS account. If not, go to [https://aws.amazon.com/free/](https://aws.amazon.com/free/)
    and follow the instructions to create an AWS account. The AWS free tier is enough
    to deploy this book project:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用 Elastic Beanstalk 部署我们的应用。本指南假设你已经创建了一个 AWS 账户。如果没有，请访问 [https://aws.amazon.com/free/](https://aws.amazon.com/free/)
    并按照说明创建一个 AWS 账户。AWS 免费层足以部署这个项目：
- en: Log in to your AWS account and go to the Amazon ECR console at [https://console.aws.amazon.com/ecr/](https://console.aws.amazon.com/ecr/).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到你的 AWS 账户，并访问 Amazon ECR 控制台 [https://console.aws.amazon.com/ecr/](https://console.aws.amazon.com/ecr/)。
- en: 'To create an Amazon ECR repository, you can use the following steps:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个 Amazon ECR 仓库，你可以按照以下步骤操作：
- en: Go to the Amazon ECR console.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Amazon ECR 控制台。
- en: In the navigation pane, select **Repositories**.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航面板中，选择**存储库**。
- en: Select **Create repository**.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建存储库**。
- en: In the **Repository name** field, enter a name for your repository.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**存储库名称**字段中，输入您的存储库名称。
- en: In the **Repository type** field, select **Public** or **Private**.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**存储库类型**字段中，选择**公共**或**私有**。
- en: Select **Create**.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建**。
- en: 'Alternatively, you can create an Amazon ECR repository with the following AWS
    CLI command:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下AWS CLI命令创建Amazon ECR存储库：
- en: '[PRE11]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, to successfully run the preceding command you need to have the following
    sorted:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，要成功运行前面的命令，您需要以下内容已排序：
- en: Have an AWS account and an IAM user with permissions to create ECR repositories.
    You can find the link to the permissions JSON file on the GitHub at [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter16/bizza/Deployment/ecr-permissions.json](B18554_16.xhtml)
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个AWS账户和一个具有创建ECR存储库权限的IAM用户。您可以在GitHub上找到权限JSON文件的链接：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter16/bizza/Deployment/ecr-permissions.json](B18554_16.xhtml)
- en: Have AWS CLI installed and configured with your AWS credentials.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装并配置AWS CLI，并使用您的AWS凭证。
- en: 'Next, we need to push the Docker images to the Amazon ECR repository. To push
    the bizza application Docker images to the Amazon ECR repository, follow these
    steps:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将Docker镜像推送到Amazon ECR存储库。要将bizza应用程序的Docker镜像推送到Amazon ECR存储库，请按照以下步骤操作：
- en: 'On the command line, navigate to the directory that contains each of the applications’
    Dockerfile. Build the Docker image with the following command:'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到包含每个应用程序Dockerfile的目录。使用以下命令构建Docker镜像：
- en: '[PRE12]'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, tag your image with the following command:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令标记您的镜像：
- en: '[PRE13]'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Push each of the Docker images to the Amazon ECR repository. Inside your project
    directory, run `docker login` and enter docker login credentials. Once done, run
    the `aws configure` command to log in to AWS as well.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个Docker镜像推送到Amazon ECR存储库。在您的项目目录中，运行`docker login`并输入docker登录凭证。完成后，运行`aws
    configure`命令以登录AWS。
- en: 'Once you are logged in to both Docker and AWS in your terminal, run the following
    command:'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您在终端中登录了Docker和AWS，请运行以下命令：
- en: '[PRE14]'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s go over the aspects of the preceding command:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面命令的各个方面：
- en: '`aws ecr get-login-password`:- This command retrieves an authentication token
    from ECR.'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aws ecr get-login-password`：此命令从ECR检索认证令牌。'
- en: '`--region <region>`: This specifies the region where the ECR registry is located.
    If you do not know where your ECR repository is located, run the following command:
    `aws ecr describe-repositories –``repository-names nameofyourrepository`.'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--region <region>`：这指定了ECR注册表所在的区域。如果您不知道您的ECR存储库在哪里，请运行以下命令：`aws ecr describe-repositories
    –``repository-names nameofyourrepository`。'
- en: '`|`: This is the pipe operator. It tells the shell to take the output of the
    first command and pass it as input to the second command.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|`：这是管道操作符。它告诉shell将第一个命令的输出作为输入传递给第二个命令。'
- en: '`docker login`: This command logs you in to a Docker registry.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker login`：此命令将您登录到Docker注册表。'
- en: '`--username AWS`: This specifies the username to use when logging in to the
    registry.'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--username AWS`：这指定了登录注册表时使用的用户名。'
- en: '`--password-stdin`:- This tells the Docker CLI to read the password from standard
    input.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--password-stdin`：这告诉Docker CLI从标准输入读取密码。'
- en: '`<AWS_ACCOUNT_ID>.dkr.ecr.<region>.amazonaws.com`:- This is the registry ID
    of the ECR registry you want to log in to.'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<AWS_ACCOUNT_ID>.dkr.ecr.<region>.amazonaws.com`：这是您想要登录的ECR注册表的注册ID。'
- en: Enter `docker push <account-id>.dkr.ecr.<region>.amazonaws.com/<nameof yourrepository:<tag_name>>`
    in each of the project component directories.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个项目组件目录中输入`docker push <account-id>.dkr.ecr.<region>.amazonaws.com/<nameof
    yourrepository:<tag_name>>`。
- en: 'To create an Elastic Beanstalk environment, you can use the following steps:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建Elastic Beanstalk环境，您可以按照以下步骤操作：
- en: Go to the Elastic Beanstalk console at [https://console.aws.amazon.com/elasticbeanstalk](https://console.aws.amazon.com/elasticbeanstalk).
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Elastic Beanstalk控制台：[https://console.aws.amazon.com/elasticbeanstalk](https://console.aws.amazon.com/elasticbeanstalk)。
- en: In the navigation pane, select **Create environment**.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航面板中，选择**创建环境**。
- en: In the **Platform** section, select **Docker**.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**平台**部分，选择**Docker**。
- en: In the **Application** code section, select **Use an** **existing application**.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**应用程序**代码部分，选择**使用现有的应用程序**。
- en: In the **Application code repository** field, enter the URL of your Docker image
    repository.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**应用程序代码存储库**字段中，输入您的Docker镜像存储库的URL。
- en: In the **Application name** field, enter a name for your environment.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**应用程序名称**字段中，输入您环境的名称。
- en: Select **Create environment**.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建环境**。
- en: 'To configure the Elastic Beanstalk environment to use the Amazon ECR repository,
    you can use the following steps:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置 Elastic Beanstalk 环境以使用 Amazon ECR 存储库，您可以按照以下步骤操作：
- en: In the Elastic Beanstalk console, select the name of your environment.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Elastic Beanstalk 控制台中，选择您环境的名称。
- en: In the navigation pane, select **Configuration**.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航面板中，选择**配置**。
- en: In the **Software** section, select **Docker**.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**软件**部分，选择**Docker**。
- en: In the **Repository URL** field, enter the URL of your Amazon ECR repository.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**存储库 URL**字段中，输入您的 Amazon ECR 存储库的 URL。
- en: Select **Save**.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**保存**。
- en: 'To deploy the application to the Elastic Beanstalk environment, you can use
    the following steps:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将应用程序部署到 Elastic Beanstalk 环境，您可以按照以下步骤操作：
- en: In the Elastic Beanstalk console, select the name of your environment.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Elastic Beanstalk 控制台中，选择您环境的名称。
- en: In the navigation pane, select **Deploy**.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航面板中，选择**部署**。
- en: In the **Deployment method** section, select **One-click deploy**.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**部署方法**部分，选择**一键部署**。
- en: Select **Deploy**.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**部署**。
- en: Now the application is deployed to the Elastic Beanstalk environment. You can
    access the application by using the URL that is displayed in the Elastic Beanstalk
    console.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，应用程序已部署到 Elastic Beanstalk 环境。您可以通过 Elastic Beanstalk 控制台中显示的 URL 访问应用程序。
- en: AWS Elastic Beanstalk is undoubtedly an excellent choice for developers who
    want to focus on building applications and services rather than managing infrastructure.
    AWS Elastic Beanstalk provides a simple, scalable, and flexible platform that
    can help developers quickly and easily deploy applications on the AWS cloud platform.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Elastic Beanstalk 无疑是那些希望专注于构建应用程序和服务而不是管理基础设施的开发者的绝佳选择。AWS Elastic Beanstalk
    提供了一个简单、可扩展和灵活的平台，可以帮助开发者快速轻松地将应用程序部署到 AWS 云平台。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the world of containerization and deployment. We
    began by discussing what containerization is and why it is useful for modern software
    development. We then introduced Docker, the most popular containerization technology,
    and learned how to use it to package and deploy React and Flask applications.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了容器化和部署的世界。我们首先讨论了什么是容器化以及为什么它对现代软件开发有用。然后，我们介绍了最受欢迎的容器化技术 Docker，并学习了如何使用它来打包和部署
    React 和 Flask 应用程序。
- en: Next, we explored the use of Docker Compose, a tool for defining and running
    multi-container Docker applications. We learned how to use Docker Compose to orchestrate
    the deployment of our applications across multiple containers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了 Docker Compose 的使用，这是一个用于定义和运行多容器 Docker 应用程序的工具。我们学习了如何使用 Docker
    Compose 在多个容器中编排应用程序的部署。
- en: We also delved into AWS ECR, a fully managed container registry service that
    allows developers to store, manage, and deploy Docker container images securely
    and reliably. Finally, we looked at AWS Elastic Beanstalk, a service that simplifies
    the process of deploying, managing, and scaling web applications. We learned how
    to deploy our dockerized React and Flask applications to Elastic Beanstalk with
    all the features with security and scalability.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还深入探讨了 AWS ECR，这是一个完全托管的容器注册服务，允许开发者安全、可靠地存储、管理和部署 Docker 容器镜像。最后，我们了解了 AWS
    Elastic Beanstalk，这是一个简化部署、管理和扩展 Web 应用程序流程的服务。我们学习了如何将我们的 Docker 化 React 和 Flask
    应用程序部署到 Elastic Beanstalk，并具备所有安全性和可扩展性功能。
- en: In a nutshell, containerization and deployment are critical components of modern
    software development, and tools such as Docker and AWS services such as Elastic
    Container Registry and Elastic Beanstalk are essential for managing and scaling
    container-based applications.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，容器化和部署是现代软件开发的关键组成部分，而像 Docker 这样的工具以及 AWS 的 Elastic Container Registry
    和 Elastic Beanstalk 这样的服务对于管理和扩展基于容器的应用程序至关重要。
- en: We extend our sincere gratitude to you for selecting this book as your guide
    in mastering the art of full stack development. Your choice reflects your determination
    to embark on a transformative journey that combines the power of modern web technologies.
    It is our honor to accompany you on this path of discovery and learning.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们衷心感谢您选择这本书作为您掌握全栈开发艺术的指南。您的选择反映了您踏上结合现代网络技术力量的变革性旅程的决心。能陪伴您在这条探索和学习之路上，我们深感荣幸。
- en: Throughout the pages of this book, we have meticulously crafted a comprehensive
    roadmap to equip you with the skill set needed to conquer the realms of both frontend
    and backend development. We delved into the depths of React, unraveling its component-based
    architecture, state management, and dynamic user interfaces. Simultaneously, we
    navigated the intricacies of Flask, empowering you to construct robust APIs, manage
    databases, and handle server-side operations with finesse.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的每一页中，我们都精心制作了一份全面的路线图，旨在为你提供征服前端和后端开发领域所需的所有技能集。我们深入React的深处，揭示了其基于组件的架构、状态管理和动态用户界面。同时，我们也探讨了Flask的复杂性，赋予你构建强大的API、管理数据库以及优雅地处理服务器端操作的能力。
- en: As you turn the final pages of this book, please take a moment to appreciate
    the knowledge you’ve gained and the skills you’ve honed. You now possess the tools
    to craft stunning user interfaces, harness the power of server-side applications,
    and seamlessly connect frontend and backend functionalities. Your journey as a
    full stack developer has begun, and the possibilities are limitless.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当你翻到这本书的最后一页时，请花一点时间来欣赏你所获得的知识和所磨练的技能。你现在拥有了打造令人惊叹的用户界面、利用服务器端应用的力量以及无缝连接前端和后端功能所需的工具。作为全栈开发者的旅程已经开启，可能性无限。
- en: But wait, your expedition doesn’t end here! As you close this chapter, new horizons
    await you. The world of technology is ever-evolving, and your dedication to mastering
    full stack development aligns perfectly with the opportunities that lie ahead.
    Whether you choose to build intricate web applications, design intuitive user
    experiences, or contribute to innovative projects, your expertise will be a cornerstone
    of success.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，你的探险还没有结束！当你关闭这一章时，新的天地在等待着你。技术世界是不断演变的，你对掌握全栈开发的执着完美地与未来的机遇相吻合。无论你选择构建复杂的Web应用、设计直观的用户体验，还是为创新项目做出贡献，你的专业知识都将成为成功的基石。
- en: So, with your newfound proficiency in React and Flask, what’s next? Perhaps
    you’ll explore advanced React frameworks such as `Next.js`, dive deeper into microservices
    with Flask, or even embark on creating your own groundbreaking applications. The
    road ahead is paved with endless prospects, and your ability to shape digital
    experiences has never been more significant.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着你在React和Flask方面的新技能，接下来是什么？也许你会探索高级的React框架，如`Next.js`，深入微服务领域使用Flask，甚至开始创建你自己的开创性应用。前方的道路铺满了无限的可能，你塑造数字体验的能力从未如此重要。
- en: Once again, thank you for choosing *Full Stack with Flask and React* as your
    guide. Your commitment to learning and growth is inspiring, and we eagerly anticipate
    the remarkable contributions you will make to the ever-evolving world of technology.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 再次感谢您选择*使用Flask和React的全栈开发*作为您的指南。您对学习和成长的承诺令人鼓舞，我们热切期待您为不断发展的技术世界做出的卓越贡献。
