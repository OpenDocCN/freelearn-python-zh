- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerization and Flask Application Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a long journey, we’ve reached the last chapter! We’re thrilled beyond
    words! Right now, we are about to embark on the last lap of showcasing our full
    stack web application to the world. In today’s modern software development sphere,
    the pace of containerization adoption is rapidly increasing.
  prefs: []
  type: TYPE_NORMAL
- en: According to Gartner’s predictions, the adoption of containerized applications
    in production will increase significantly, with more than 75% of global organizations
    expected to utilize them by 2022, a notable increase from the less than 30% reported
    in 2020 ([https://www.gartner.com/en/documents/3985796](https://www.gartner.com/en/documents/3985796)).
  prefs: []
  type: TYPE_NORMAL
- en: Containerization and the deployment of software applications have become essential
    skills needed for developers to stay modern and in demand. Developers who have
    the skills and knowledge to containerize and deploy software applications are
    better equipped to meet the demands of modern software development practices,
    stay up to date with industry trends, and remain competitive in the job market.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization allows developers to package applications and required dependencies
    into a standardized and portable container that can run consistently across different
    computing environments. And, of course, deployment ensures that your application
    gets to the production environment, where it can be used by end users.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss containerization as a revolution changing the
    information technology industry. We will touch on the significance and benefits
    of containerization in software development, as well as exploring the issues it
    tackles.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will delve into one of the containerization platforms in the
    software development industry, called **Docker**. We will introduce Docker and
    use it to containerize both the React frontend and the Flask backend. We will
    discuss Docker’s benefits and why it is popular among developers.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will understand the importance of containerization
    in modern software development, and you will be able to package React and Flask
    applications into containers ready to be shipped and shared.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will learn how to use **Amazon Web Services** (**AWS**) Elastic
    Beanstalk to deploy React-Flask applications leveraging the AWS fully managed
    cloud platform, which allows developers to deploy, manage, and scale their web
    applications and services with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is containerization?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerizing React and Flask applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding AWS Elastic Container Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `docker-compose`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying React and Flask applications to AWS Elastic Beanstalk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16).'
  prefs: []
  type: TYPE_NORMAL
- en: Due to page count constraints, some of the long code blocks have been shortened.
    Please refer to GitHub for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: What is containerization?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Containerization** is a software development practice that involves packaging
    an application and required dependencies into a self-contained unit called a **container**.
    A container is an isolated and lightweight runtime environment that provides a
    consistent and reproducible way to run an application across different computing
    environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you have developed a web application using the Flask framework on
    your local machine running on MacOS. You want to deploy this application to a
    server running Ubuntu Linux in a production environment. However, there may be
    differences in the versions of the operating system, dependencies, or other system
    configurations that could affect the behavior of your application.
  prefs: []
  type: TYPE_NORMAL
- en: By packaging your Flask application and all the required dependencies into a
    container, you can ensure that the application runs consistently and reliably
    across different computing environments. The container will provide an isolated
    and lightweight runtime environment that encapsulates the application and related
    dependencies, ensuring that it runs consistently regardless of the underlying
    system configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are like **virtual machines** (**VMs**) in that they provide a way
    to isolate applications from the underlying host operating system. However, while
    VMs require a complete copy of the host operating system to run, containers only
    require the minimal runtime components needed to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Containers utilize a technique called containerization, which employs virtualization
    at the operating system level. Containerization allows multiple containers to
    run on the same host operating system, each with its own isolated filesystem,
    networking, and process space. With containerization, developers can lower the
    deployment time and cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check out a few other benefits of containerization:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers provide a standardized way of packaging applications and required
    dependencies, which reduces the time and effort required for configuration and
    setup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers are portable across different computing environments, allowing for
    deployment on any system with the same container runtime. This portability approach
    eliminates the need to create and maintain separate deployment configurations
    for different environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers share the same operating system kernel, enabling more efficient use
    of system resources compared to traditional virtualization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers provide isolation between applications and accompanying dependencies,
    making the conflicts and errors that can arise when running applications on a
    shared infrastructure obsolete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a nutshell, containers are lightweight, self-containing to run applications,
    portable, and efficient, and can be easily replicated and scaled as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are several containerization technologies to choose from, we
    will specifically discuss Docker in the next section. Before exploring Docker
    in depth, let’s take a brief look at some of the other containerization tools
    and platforms available in the software industry:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes**: An open source container orchestration system that automates
    deploying, scaling, and managing containerized applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Mesos**: An open source platform for managing and deploying containerized
    applications and big data services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LXC/LXD**: A containerization solution that uses lightweight VMs to provide
    isolation and resource management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CoreOS rkt**: A container runtime that provides security, simplicity, and
    speed to the container environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenVZ**: An open source containerization platform that provides container-based
    virtualization for Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Elastic Container Service (ECS)**: A fully managed container orchestration
    service provided by AWS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine (GKE)**: A fully managed Kubernetes service provided
    by Google Cloud Platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the demand for scalable and efficient software deployment grows, more and
    more developers are going to turn to Docker as a solution. In the next section,
    we’ll explore the basics of Docker and how it can help you streamline your development
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker** is a popular platform for developing, packaging, and deploying applications
    in containers. Before Docker’s invention, software developers had to deal with
    the problem of software dependencies, which meant that the software would work
    well on one computer but fail to work on another system.'
  prefs: []
  type: TYPE_NORMAL
- en: Software developers would create programs on their computers, but when they
    tried to share them with other people, things often went wrong. Programs that
    worked perfectly on one computer might not have worked on another because of differences
    in the operating system, software versions, configuration files, or other system-related
    factors.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, a group of developers in 2013 released a tool called
    Docker. Docker lets developers package programs and all the necessary dependencies
    into something called a **Docker image**. A Docker image is a read-only template
    that contains the instructions for creating a Docker container. A Docker image
    includes the application code, runtime, libraries, dependencies, and configurations
    needed to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: With Docker, developers can create a Docker image for their programs and share
    it with others. A Docker container is a runnable instance of a Docker image. A
    Docker container is a lightweight, isolated, and portable environment that can
    run on any system that supports Docker. This means that the program will run the
    same way on every computer, which makes it much easier to share and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can create a Docker image by writing a **Dockerfile**, which is a
    text file that contains the instructions for building a Docker image. The Dockerfile
    specifies the base image, adds the necessary packages and files, and sets the
    configuration options for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have built your application Docker image, you might want to ship to
    production or send it to other developers. To achieve this, you can use a Docker
    registry, which is a central repository for storing and distributing Docker images.
    Docker Hub is the most popular public registry, but you can also set up your own
    private registry for your organization. In the course of this chapter, we will
    store the book project Docker images in AWS **Elastic Container** **Registry**
    (**ECR**).
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose is another tool of interest in the Docker ecosystem. Docker Compose
    is a tool for defining and running multi-container Docker applications. Docker
    Compose uses a YAML file to define the services, networks, and volumes needed
    to run the application. In the subsequent section, we will discuss Docker Compose
    in great detail. Next, we will explore how we can containerize a simple Flask
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Flask application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s demonstrate with a simple Flask application the process of containerization
    using Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Docker from [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
    and install Docker on your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.1 – The download page of Docker](img/Figure_16.01_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – The download page of Docker
  prefs: []
  type: TYPE_NORMAL
- en: Select the appropriate computer OS for your Docker platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the Docker installation is complete, test it in your Terminal with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.2 – The command to verify the Docker installation](img/Figure_16.02_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – The command to verify the Docker installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that Docker is installed on your computer, run the `mkdir bizza-docker`
    command to create a new working directory for deploying a Flask application using
    a Docker container. Then, enter `cd bizza-docker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.3 – The creation of a Docker working directory](img/Figure_16.03_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – The creation of a Docker working directory
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a virtual environment for the new Flask Docker application.
  prefs: []
  type: TYPE_NORMAL
- en: Run `python –m venv venv` in the Terminal to install a virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Activate the virtual environment with these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`venv\Scripts\activate`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source venv/bin/activate`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the Docker project directory, `bizza-docker/`, create an `app.py` file
    and add the following code snippet to run a simple Flask application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code runs a simple Flask app showing **Bizza Web App Dockerization!**
    in the browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `.flaskenv` file inside `bizza-docker/` and add the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the Flask app with `flask run` in the Terminal and you will get the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Testing the Flask application](img/Figure_16.04_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – Testing the Flask application
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Flask app is working, let’s create a Flask application `requirements.txt`
    file to be able to reproduce the dependencies for this simple application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `pip freeze > requirements.txt` command and you will get the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.5 – The requirements.txt file for the Flask dependencies](img/Figure_16.05_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – The requirements.txt file for the Flask dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block displays the content of the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We now have all the resources to build the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Dockerfile defines the container image for a Flask application. We are going
    to create a Dockerfile that uses the official Python 3.8 image as the base image,
    installs Flask and its dependencies, and copies the Flask application code into
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `bizza-docker` directory, create a Dockerfile file – make sure the capital
    *D* is used in creating the Dockerfile file. Don’t worry about why; this is a
    convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To simplify the deployment process and ensure consistent environments across
    different stages of development, testing, and production, let’s examine the anatomy
    of the preceding Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is a Dockerfile used to build a Docker image for a Python
    Flask web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM python:3.8.2-alpine`: This specifies the base image to use for building
    the Docker image. In this case, the base image is `python:3.8.2-alpine`, which
    is a lightweight version of Python 3.8.2 optimized for running in Alpine Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR /packt-bizza-docker`: This sets the working directory of the Docker
    container to `/packt-bizza-docker`. All subsequent commands in the Dockerfile
    will be executed relative to this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD . /packt-bizza-docker`: This line copies all the files and directories
    in the current directory into the `/packt-bizza-docker` directory in the Docker
    container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY requirements.txt .`: This copies the `requirements.txt` file from the
    current directory to the root directory of the Docker container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN pip install --no-cache-dir -r requirements.txt`: This installs the Python
    dependencies specified in the `requirements.txt` file using `pip`. The `--no-cache-dir`
    option ensures that `pip` does not cache the downloaded packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN pip install -r requirements.txt`: This line installs the Python dependencies
    specified in the `requirements.txt` file using `pip3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY . .`: This copies all the files and directories in the current directory
    to the root directory of the Docker container. This includes the Flask application
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV FLASK_APP=app.py, ENV FLASK_ENV=development`: This sets the environment
    variables for the Flask application. `FLASK_APP` specifies the name of the main
    Flask application file (in this case, `app.py`). `FLASK_ENV` sets the Flask environment
    to development mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE 5001`: This exposes port `5001` of the Docker container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD ["python3", "app.py"]`: This specifies the command to run when the Docker
    container is started. In this case, it runs the `app.py` file using Python 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will build the Docker image from the preceding defined `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Dockerfile defined, you can build a Docker image of the Flask application.
    This image contains all the dependencies and configuration files required to run
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct the Docker image, execute the following command in the Terminal
    from within the `bizza-docker` directory that contains the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 – Output of the docker build command](img/Figure_16.06_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 – Output of the docker build command
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command will build the Docker image using the Dockerfile present
    in the current directory. The resulting image will be tagged as `packt-bizza-docker`.
    Now, let’s proceed to the next step and launch the container to make the simple
    Flask application functional.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Docker container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After building the Docker image, you can run a Docker container from the image.
    This container provides a lightweight, isolated, and portable environment for
    running the Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the Docker container, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 – Output of docker run in detached mode](img/Figure_16.07_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.7 – Output of docker run in detached mode
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will run the container in detached mode (`-d`) and perform
    port mapping (`-p`) by mapping the host port `5001` to the container port `5001`.
    The container will be based on the `packt-bizza-docker` image. Alternatively,
    you can run the command without the `-d` flag to launch the container in a non-detached
    mode, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Output of docker run in a non-detached mode](img/Figure_16.08_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8 – Output of docker run in a non-detached mode
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `docker run` command allows us to access the Flask application
    running inside the Docker container. You need to expose the ports on the container
    to the host machine with `-p` `5001:5001 .`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the Docker container running, we can test the Flask application
    by accessing it through a web browser or using a command-line tool such as `curl-`
    `http://127.0.0.1:5001`. Make sure that the application is functioning as expected
    and that all the dependencies are working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can push the Docker image to a Docker registry such as Docker Hub
    or AWS ECS. This makes it easy to share the image with other developers or deploy
    it to production environments.
  prefs: []
  type: TYPE_NORMAL
- en: To stop a running Docker container, you can use the `docker stop` command followed
    by the *container ID* or *name*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the container ID is `c2d8f8a4b5e3`, you can stop the container
    using the `docker stop c2d8f8a4b5e3` command, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9 – Output of the docker stop command](img/Figure_16.09_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.9 – Output of the docker stop command
  prefs: []
  type: TYPE_NORMAL
- en: And if you don’t know the container ID or name, you can use the `docker ps`
    command to list all running containers and their details, including the ID and
    name. Once you have identified the container that you want to stop, you can use
    the `docker stop` command as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s glance at another important Docker command: `docker` `container prune`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `docker container prune` command is used to remove stopped containers and
    free up disk space. When you run a Docker container, the container consumes system
    resources such as memory and CPU cycles. When you stop a container, those resources
    are freed up, but the container still exists on your system. With time, if you
    run multiple containers, you may be housing many stopped containers, which can
    take up significant disk space on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Running the `docker container prune` command is a simple way to remove all stopped
    containers and reclaim disk space. This `docker container prune` command will
    prompt you to confirm that you want to remove the containers before proceeding,
    so make sure you review the list of containers carefully before confirming.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the `docker container prune` command will only remove
    stopped containers. If you have any running containers, they will not be affected
    by this command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the process of dockerizing React and Flask applications.
    We will use the full stack Bizza web application as a case study.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerizing React and Flask applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dockerizing web applications allows developers to set up a consistent development
    environment across different machines. Dockerizing tools reduce the time and effort
    required to set up a new development environment. With Docker, developers can
    easily replicate the production environment on their local machines, test their
    code, and debug any issues before deploying it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will dockerize working applications for React and Flask,
    and make them ready to be shipped for production.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the React.
  prefs: []
  type: TYPE_NORMAL
- en: Bizza frontend application with React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have created your React application, the initial step toward making
    it accessible to internet users is to build the application. Building a React
    application is an essential step in the development process to ensure that the
    application is optimized for production and performs as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The building process takes the source code of a React project and transforms
    it into a production-ready format that can be deployed and served to users:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s download the *Bizza* app directory from the GitHub repo – [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/frontend](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/frontend).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To install the dependencies required for the application, navigate to the `bizza/frontend`
    directory and execute the `npm install` command in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the frontend application, execute the `npm start` command in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s build the application with the `npm run` `build` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the *bizza* React application has been built, the resulting files can
    be deployed to a web server or cloud platform and served to users. The eventual
    build directory is located inside `bizza/frontend/src/build`.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the build process, the following steps were taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transpiling JavaScript and JSX code**: React applications are typically written
    in JavaScript and JSX, a syntax extension for JavaScript. However, modern web
    browsers can only execute JavaScript code. Therefore, before deploying a React
    application, the JavaScript and JSX code needs to be transpiled into plain JavaScript
    using a tool such as Babel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bundling the code and assets**: React applications often consist of multiple
    components, modules, and assets such as images, CSS files, and fonts. Bundling
    involves grouping all the required code and assets into a single file or set of
    files that can be served to the user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Optimizing the code and assets**: To improve performance, the bundled code
    and assets can be optimized by minifying, compressing, or removing unnecessary
    code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`build` or `dist`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, typically at this stage, the `build` directory contents are deployed to
    a web server or cloud for end users. However, for the deployment process outlined
    in this book, you will utilize a Docker functionality known as **multi-stage builds**.
    A multi-stage build is a feature in Docker that allows you to create a Docker
    image that consists of multiple stages, where each stage is a self-contained Docker
    image with a specific purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a multi-stage build is to optimize the size and efficiency of
    Docker images. With a multi-stage build, you can reduce the size of your final
    Docker image by only including the necessary files and dependencies. This results
    in faster builds, smaller image sizes, and more efficient use of resources.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-stage build process involves creating multiple Docker images, each
    with a specific purpose. The first stage of the build typically contains the source
    code, dependencies, libraries, and other necessary files.
  prefs: []
  type: TYPE_NORMAL
- en: The final stage of the build usually contains only the essential files and dependencies
    required to run the application, resulting in a smaller and more efficient Docker
    image. The essence of a multi-stage build is to ensure that the intermediate stages
    are used to build and compile the application but are not included in the final
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, let’s examine a `Dockerfile` for the React frontend app that uses
    multi-stage builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break the preceding `Dockerfile` image-building instruction down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dockerfile` creates a build stage using the Node.js `14.17.0-alpine3.13` image
    as the base. The `Dockerfile` sets the working directory to `/frontend` and copies
    the `package*.json` files from the local directory to the image. The `npm install
    --production` command is then run to install the production dependencies. Next,
    the Dockerfile copies the entire project directory to the image and runs the `npm
    run build` command to build the React app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dockerfile` creates a production stage using the smaller `nginx:1.21.0-alpine
    image` as the base. The Dockerfile copies the built React app from the build stage,
    located at `/frontend/build`, to the `nginx` HTML directory at `/usr/share/nginx/html`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE` command exposes port `80` to allow communication with the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD` command sets the default command to run when the container starts up.
    In this case, the `Dockerfile` starts the `nginx` server in the foreground with
    the `nginx -g ''daemon` `off;''` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dockerfile` cleans up unnecessary files, such as the `node_modules` directory
    and other configuration files, using the `RUN` command with the `rm` command to
    remove them from the image. This cleaning-up process reduces the overall size
    of the image, making it faster to deploy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have the Docker image of the bizza frontend React app. Let’s create
    the Flask backend Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Bizza backend application with Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Flask backend, we are going to create two Docker images. Download the
    full Flask backend application here: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/backend](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter16/bizza/backend).'
  prefs: []
  type: TYPE_NORMAL
- en: We will create a Docker image for the Flask application and another Docker image
    for PostgreSQL. While it is possible to fuse the two images into a single Docker
    image, it is a best practice to separate the concerns for scalability and to reduce
    the image size.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review the Flask application multi-stage build Dockerfile definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile for the Flask application will be stored in the project `root`
    directory while a subdirectory named `postgres` will house the Dockerfile for
    PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break down the preceding Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Dockerfile defines a multi-stage build for a Flask application. The Dockerfile
    has two stages: `build` and `run`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first stage, `build`, is responsible for building the application and installing
    the required dependencies. Right now, let’s check what each line of the build
    stage does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM python:3.8.12-slim-buster AS build`: This line sets the base image for
    the build stage to `python:3.8.12-slim-buster`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR /app`: This line sets the working directory to `/app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY requirements.txt .`: This line copies the `requirements.txt` file from
    the host machine to the `/app` directory in the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN pip install --no-cache-dir -U pip==21.3.1 && \ pip install --no-cache-dir
    --user -r requirements.txt`: These lines update `pip` to version `21.3.1` and
    install the Python packages specified in the `requirements.txt` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--no-cache-dir` option is used to prevent the installation from using any
    cached data from previous runs, which helps ensure that the installed packages
    are up to date and match the versions specified in `requirements.txt`. The `--user`
    option is used to install the packages to the user’s home directory, which helps
    avoid permission issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`COPY . .`: This line copies the entire application directory from the host
    machine to the `/app` directory in the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FROM python:3.8.12-slim-buster AS run`: This represents the start of the second
    stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second stage, `run`, is responsible for running the application in a production
    environment. The line sets the base image for the `run` stage to `python:3.8.12-slim-buster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKDIR /app`: This line sets the working directory to `/app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY --from=build /root/.local /root/.local` and `COPY --from=build /app .`:
    These two lines copy the application directory and the installed packages from
    the build stage to the `run` stage. The first line copies the installed packages
    from the build stage to the `/root/.local` directory in the run stage. The second
    line copies the application directory from the build stage to the `/app` directory
    in the run stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV PATH=/root/.local/bin:$PATH`, `ENV FLASK_APP=app.py`, and `ENV FLASK_ENV=production`:
    These three lines set the environment variables for the application. The `PATH`
    environment variable is updated to include the `/root/.local/bin` directory, which
    contains the installed packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures that the installed packages are available in the system `PATH`.
    The `FLASK_APP` environment variable is set to `app.py`, which specifies the main
    application file for Flask to run. The `FLASK_ENV` environment variable is set
    to `production`, which enables features such as better error handling and improved
    performance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`EXPOSE 5001`: This line exposes port `5001`, which is the port that the Flask
    application will listen on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD ["python3", "app.py"]`: This line specifies the default command to run
    when the container starts. It runs the `app.py` file using the `python3` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having discussed the Dockerfile for the main Flask application, let’s examine
    the Dockerfile for PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the Dockerfile for Postgres to create a database image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go through the Postgres Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM postgres:13-alpine`: This line specifies the base image for our Docker
    container, which is `postgres:13-alpine`. This image is based on the Alpine Linux
    distribution and includes PostgreSQL version 13.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV POSTGRES_DB=<database_name>`, `ENV POSTGRES_USER=<database_user>`, and
    `ENV POSTGRES_PASSWORD=<database_password>`: These three lines set the environment
    variables for the Postgres container. The `POSTGRES_DB` variable specifies the
    name of the database to be created. The `POSTGRES_USER` variable specifies the
    username to be created for the database, and the `POSTGRES_PASSWORD` variable
    specifies the password for that user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN apk add --no-cache --update bash`: This line copies the `init.sql` file
    to the `/docker-entrypoint-initdb.d/` directory in the container. This directory
    is used by the Postgres image to run initialization scripts when the container
    is first started. In this case, the `init.sql` file is a script that will create
    the database and any necessary tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE 5432`: This line exposes port `5432`, which is the default port used
    by PostgreSQL, to allow connections from outside the container. However, this
    does not actually publish the port, as this needs to be done at runtime using
    the `docker run` or `docker-compose` commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This Postgres Dockerfile can be used to build a Docker image for a Postgres
    database, which can be used in conjunction with React and Flask application Docker
    containers to build a complete web application stack.
  prefs: []
  type: TYPE_NORMAL
- en: With the Flask application and Postgres images well defined, we will be pushing
    the created Docker images to AWS ECR for online storage of Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AWS ECR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon ECR is a fully managed Docker registry service that makes it easy to
    store, manage, and deploy Docker images. Amazon ECR is integrated with Amazon
    ECS to provide a seamless experience for building, deploying, and managing containerized
    applications at scale. Amazon ECR is designed to scale to meet the needs of even
    the most demanding containerized applications. Amazon ECR has security features
    to protect your container images, including encryption at rest and in transit,
    and **role-based access** **control** (**RBAC**).
  prefs: []
  type: TYPE_NORMAL
- en: To begin using Amazon ECR, the first step is to create an ECR repository. Please
    refer to the following screenshot of the Amazon ECR interface.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Get Started** button to initiate the repository creation process.
    This will allow you to establish a dedicated location for storing your Docker
    images.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 16.10 \uFEFF– AWS ECR](img/Figure_16.10_B18554.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 16.10 – AWS ECR
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a screenshot showcasing a public repository named `packt-bizza-web-app`
    in Amazon ECR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.11 – The public repository](img/Figure_16.11_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.11 – The public repository
  prefs: []
  type: TYPE_NORMAL
- en: A **repository** is a logical container for storing your Docker images. Once
    you have created a repository, you can push your Docker images to the repository.
    You can then pull your images from the repository to deploy them to your ECS clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon ECR is a powerful tool that can help you to simplify the management of
    your container images. Interestingly, Amazon ECR is very cost-effective in storing
    and managing container images.
  prefs: []
  type: TYPE_NORMAL
- en: Using ECR is free; you only pay for the storage and bandwidth that you use.
    Next, we will use Docker Compose to define and run the React, Flask, and Postgres
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker Compose** is a tool for defining and running multi-container Docker
    applications. Docker Compose provides a tool to define a set of containers and
    their relationships to each other, and then run them all with a single command.'
  prefs: []
  type: TYPE_NORMAL
- en: With Docker Compose, developers can define the exact configuration of the application’s
    containers, including the images, environment variables, and network settings.
    This ensures that the application runs consistently across different environments
    and can be easily reproduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few components of Docker Compose we need to understand
    before we delve into details for configuration definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**YAML file**: A YAML file is used to define the configuration of your application’s
    containers. The YAML file specifies the images to use, ports to expose, environment
    variables, and any other settings that are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: Each container in your application is defined as a service in
    the YAML file. Services can depend on each other and can be started and stopped
    together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networks**: Docker Compose creates a network for your application, allowing
    the containers to communicate with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volumes**: Volumes are used to persist data between container runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commands**: Docker Compose provides a set of commands to start, stop, and
    manage your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s create a Docker Compose file that manages the relationship between
    the React frontend, Flask backend, and PostgreSQL database containers:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the main project directory, `bizza/`, create `docker-compose.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define services for each container. In the `docker-compose.yaml` file, define
    a separate service for each container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we define three services: `frontend`, `backend`, and
    `db`. The `frontend` service runs the *Bizza* frontend React app, the `backend`
    service runs the *Bizza* backend Flask app, and the `db` service runs the PostgreSQL
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s configure networking and dependencies. Use the `ports` and `depend_
    on` options to configure the network connections between the services. For instance,
    the frontend service is exposed on port `3000`, the backend service is exposed
    on port `5000`, and the `db` service is exposed on port `5432`. The backend service
    also depends on the `db` service, so the backend will start after the `db` service
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve defined the services in the `docker-compose.yaml` file, we can start
    the containers using the `docker-compose up` command. This will start the containers
    and connect them to the appropriate network.
  prefs: []
  type: TYPE_NORMAL
- en: With Docker Compose managing the application’s containers, we can simplify the
    process of starting and stopping our application, as well as ensure that all the
    required components are running correctly and communicating with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, Docker Compose is a useful tool for managing containers; however,
    Docker Compose is more suited to small-scale deployments and development environments.
    Docker Compose serves the purpose of the *bizza* project, being a small-scale
    application for learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: However, AWS Elastic Beanstalk, on the other hand, is designed to handle production-grade
    workloads and provides many features and benefits that can help simplify the management
    and scaling of web applications. Regardless, we will pivot the *bizza* application's
    final deployment on AWS Elastic Beanstalk.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore AWS Elastic Beanstalk, a service for deploying
    and managing applications in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying React and Flask applications to AWS Elastic Beanstalk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AWS Elastic Beanstalk** is a fully managed AWS cloud service that allows
    developers to easily deploy and manage web applications and services on AWS. AWS
    Elastic Beanstalk provides a platform that simplifies the process of deploying
    and managing web applications on AWS by automatically handling the infrastructure
    provisioning, load balancing, and scaling of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: You can deploy Elastic Beanstalk on a wide range of programming languages and
    web frameworks, including Node.js, Python, Ruby, and Go. Elastic Beanstalk also
    integrates with other AWS services such as Amazon RDS, Amazon DynamoDB, and Amazon
    SNS to provide a complete solution for building and scaling web applications.
  prefs: []
  type: TYPE_NORMAL
- en: With Elastic Beanstalk, developers can easily focus on coding. Once you are
    ready to deploy your application, you can simply upload your application package
    or link to a repository, and then choose the appropriate platform and environment
    for your application. Elastic Beanstalk automatically provisions the required
    resources and sets up the environment and can also automatically scale the application
    based on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Also, AWS Elastic Beanstalk provides a range of capabilities and tools that
    help developers streamline their development workflows, such as **continuous integration
    and continuous delivery** (**CI/CD**) pipelines, monitoring and logging tools,
    and integration with popular development tools such as Git and Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s get started with using Elastic Beanstalk to deploy our application.
    This guide assumes you have created an AWS account. If not, go to [https://aws.amazon.com/free/](https://aws.amazon.com/free/)
    and follow the instructions to create an AWS account. The AWS free tier is enough
    to deploy this book project:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your AWS account and go to the Amazon ECR console at [https://console.aws.amazon.com/ecr/](https://console.aws.amazon.com/ecr/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create an Amazon ECR repository, you can use the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Amazon ECR console.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the navigation pane, select **Repositories**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Create repository**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Repository name** field, enter a name for your repository.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Repository type** field, select **Public** or **Private**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Create**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, you can create an Amazon ECR repository with the following AWS
    CLI command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, to successfully run the preceding command you need to have the following
    sorted:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Have an AWS account and an IAM user with permissions to create ECR repositories.
    You can find the link to the permissions JSON file on the GitHub at [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter16/bizza/Deployment/ecr-permissions.json](B18554_16.xhtml)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Have AWS CLI installed and configured with your AWS credentials.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we need to push the Docker images to the Amazon ECR repository. To push
    the bizza application Docker images to the Amazon ECR repository, follow these
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the command line, navigate to the directory that contains each of the applications’
    Dockerfile. Build the Docker image with the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, tag your image with the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Push each of the Docker images to the Amazon ECR repository. Inside your project
    directory, run `docker login` and enter docker login credentials. Once done, run
    the `aws configure` command to log in to AWS as well.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you are logged in to both Docker and AWS in your terminal, run the following
    command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s go over the aspects of the preceding command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`aws ecr get-login-password`:- This command retrieves an authentication token
    from ECR.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--region <region>`: This specifies the region where the ECR registry is located.
    If you do not know where your ECR repository is located, run the following command:
    `aws ecr describe-repositories –``repository-names nameofyourrepository`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`|`: This is the pipe operator. It tells the shell to take the output of the
    first command and pass it as input to the second command.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker login`: This command logs you in to a Docker registry.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--username AWS`: This specifies the username to use when logging in to the
    registry.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--password-stdin`:- This tells the Docker CLI to read the password from standard
    input.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<AWS_ACCOUNT_ID>.dkr.ecr.<region>.amazonaws.com`:- This is the registry ID
    of the ECR registry you want to log in to.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter `docker push <account-id>.dkr.ecr.<region>.amazonaws.com/<nameof yourrepository:<tag_name>>`
    in each of the project component directories.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create an Elastic Beanstalk environment, you can use the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Elastic Beanstalk console at [https://console.aws.amazon.com/elasticbeanstalk](https://console.aws.amazon.com/elasticbeanstalk).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the navigation pane, select **Create environment**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Platform** section, select **Docker**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Application** code section, select **Use an** **existing application**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Application code repository** field, enter the URL of your Docker image
    repository.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Application name** field, enter a name for your environment.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Create environment**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To configure the Elastic Beanstalk environment to use the Amazon ECR repository,
    you can use the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Elastic Beanstalk console, select the name of your environment.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the navigation pane, select **Configuration**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Software** section, select **Docker**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Repository URL** field, enter the URL of your Amazon ECR repository.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Save**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To deploy the application to the Elastic Beanstalk environment, you can use
    the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Elastic Beanstalk console, select the name of your environment.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the navigation pane, select **Deploy**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Deployment method** section, select **One-click deploy**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Deploy**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the application is deployed to the Elastic Beanstalk environment. You can
    access the application by using the URL that is displayed in the Elastic Beanstalk
    console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AWS Elastic Beanstalk is undoubtedly an excellent choice for developers who
    want to focus on building applications and services rather than managing infrastructure.
    AWS Elastic Beanstalk provides a simple, scalable, and flexible platform that
    can help developers quickly and easily deploy applications on the AWS cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of containerization and deployment. We
    began by discussing what containerization is and why it is useful for modern software
    development. We then introduced Docker, the most popular containerization technology,
    and learned how to use it to package and deploy React and Flask applications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored the use of Docker Compose, a tool for defining and running
    multi-container Docker applications. We learned how to use Docker Compose to orchestrate
    the deployment of our applications across multiple containers.
  prefs: []
  type: TYPE_NORMAL
- en: We also delved into AWS ECR, a fully managed container registry service that
    allows developers to store, manage, and deploy Docker container images securely
    and reliably. Finally, we looked at AWS Elastic Beanstalk, a service that simplifies
    the process of deploying, managing, and scaling web applications. We learned how
    to deploy our dockerized React and Flask applications to Elastic Beanstalk with
    all the features with security and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, containerization and deployment are critical components of modern
    software development, and tools such as Docker and AWS services such as Elastic
    Container Registry and Elastic Beanstalk are essential for managing and scaling
    container-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: We extend our sincere gratitude to you for selecting this book as your guide
    in mastering the art of full stack development. Your choice reflects your determination
    to embark on a transformative journey that combines the power of modern web technologies.
    It is our honor to accompany you on this path of discovery and learning.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the pages of this book, we have meticulously crafted a comprehensive
    roadmap to equip you with the skill set needed to conquer the realms of both frontend
    and backend development. We delved into the depths of React, unraveling its component-based
    architecture, state management, and dynamic user interfaces. Simultaneously, we
    navigated the intricacies of Flask, empowering you to construct robust APIs, manage
    databases, and handle server-side operations with finesse.
  prefs: []
  type: TYPE_NORMAL
- en: As you turn the final pages of this book, please take a moment to appreciate
    the knowledge you’ve gained and the skills you’ve honed. You now possess the tools
    to craft stunning user interfaces, harness the power of server-side applications,
    and seamlessly connect frontend and backend functionalities. Your journey as a
    full stack developer has begun, and the possibilities are limitless.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, your expedition doesn’t end here! As you close this chapter, new horizons
    await you. The world of technology is ever-evolving, and your dedication to mastering
    full stack development aligns perfectly with the opportunities that lie ahead.
    Whether you choose to build intricate web applications, design intuitive user
    experiences, or contribute to innovative projects, your expertise will be a cornerstone
    of success.
  prefs: []
  type: TYPE_NORMAL
- en: So, with your newfound proficiency in React and Flask, what’s next? Perhaps
    you’ll explore advanced React frameworks such as `Next.js`, dive deeper into microservices
    with Flask, or even embark on creating your own groundbreaking applications. The
    road ahead is paved with endless prospects, and your ability to shape digital
    experiences has never been more significant.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, thank you for choosing *Full Stack with Flask and React* as your
    guide. Your commitment to learning and growth is inspiring, and we eagerly anticipate
    the remarkable contributions you will make to the ever-evolving world of technology.
  prefs: []
  type: TYPE_NORMAL
