<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Pydrivers and Constraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Pydrivers and Constraints</h1></div></div></div><p>When designing a complex object with movable parts we'd like to control how these parts move in relation to each other. Sometimes, we might want to try and simulate reality by using a physics engine such as bullet, but often this is either not accurate enough or does not provide an animator with enough control. Most of the time the clever use of multiple constraints will achieve our goals, but sometimes the restrictions and relations cannot be expressed in terms of simple constraints and key-framed motions. In those cases, we can extend Blender's capabilities by defining our own constraints or relations between animated properties by using Python.</p><p>In this chapter, we will see how we can associate built-in constraints with Blender objects and how to define complex relationships between animated properties by using the so-called <span class="strong"><strong>pydrivers</strong></span>. <a class="indexterm" id="id256"/>We will also define new complex constraints that may be used just like the built-in constraints. We will not yet look into defining key frames for animated properties as we will encounter those in later chapters.</p><p>In this chapter, we will see:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to drive one <span class="strong"><strong>IPO</strong></span> from another by a Python expression</li><li class="listitem" style="list-style-type: disc">How to work around some limitations inherent in <span class="strong"><strong>pydrivers</strong></span></li><li class="listitem" style="list-style-type: disc">How to restrict the motion of  objects and bones by adding constraints</li><li class="listitem" style="list-style-type: disc">How to write a constraint in Python that will snap an object to the closest vertex on another object</li></ul></div><p>There is a lot to cover here so let's first start off with some definitions to get a clear idea about what we are dealing with.</p><div class="section" title="Getting to grips with animated properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Getting to grips with animated properties</h1></div></div></div><p>Blender's system is versatile, yet complex. Before we are able to manipulate animated properties from a Python script it is necessary we understand the concepts involved thoroughly.</p><div class="section" title="IPO"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>IPO</h2></div></div></div><a class="indexterm" id="id257"/><a class="indexterm" id="id258"/><p>In Blender, almost any property can be animated. Normally this is done by fixing the values of some property such as the position of an Object at certain key frames and interpolating between these values for intermediate frames. Blender groups related animated properties together in so-called IPOs. For instance, all spatial properties such as location, rotation, and scale are grouped as an <a class="indexterm" id="id259"/>
<a class="indexterm" id="id260"/>Object type IPO and may be associated with almost any Blender Object for instance, a <code class="literal">Mesh</code>, a <code class="literal">Camera</code>, or a <code class="literal">Lamp</code>. The many properties of Blender Materials are grouped in the Material type IPO<a class="indexterm" id="id261"/>. A Material type IPO<a class="indexterm" id="id262"/> may be associated with any object that has associated materials. Likewise, a Lamp type IPO should be associated with a <code class="literal">Lamp</code> object. An overview of possible IPO types is given in the next table.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>
<span class="strong"><strong>IPO</strong></span> sounds like an abbreviation and it probably is, but what it stands for exactly is a bit vague. The Blender wiki states that it stands for InterPOlation system, but InterPolation Object is sometimes encountered as well. Most of the time, IPO is used as a noun by itself however, so this discussion is a bit academical.</p></div></div><p>Each IPO may be associated with more than one object. It is for example possible to animate the rotation of many objects in the same manner by associating a single appropriate Object type IPO with them. In the Blender Python API, IPOs are represented by IPO objects. An IPO object may be associated with another object by means of the <code class="literal">setIpo()</code> method. The following table gives an overview of IPO types, typical channels, and the type of objects they can be applied to. Refer to the API documentation for the Blender.IPO module for more details (<a class="ulink" href="http://www.blender.org/documentation/249PythonDoc/index.html">http://www.blender.org/documentation/249PythonDoc/index.html</a>).</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>IPO type</p>
</th><th style="text-align: left" valign="bottom">
<p>IPO channels (some examples, refer to API documentation for a full list)</p>
</th><th style="text-align: left" valign="bottom">
<p>Relevant to these Blender objects</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Object<a class="indexterm" id="id263"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">LocX</code>, <code class="literal">LocY</code>, <code class="literal">LocZ</code> (location)</p>
<p>
<code class="literal">RotX</code>, <code class="literal">RotY</code>, <code class="literal">RotZ</code> (rotation)</p>
<p>
<code class="literal">ScaleX</code>, <code class="literal">ScaleY</code>, <code class="literal">ScaleZ</code> (scale)</p>
</td><td style="text-align: left" valign="top">
<p>All Blender objects that can be positioned, such as <code class="literal">Mesh</code>, <code class="literal">Lamp</code>, <code class="literal">Camera</code>, and so on</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Pose<a class="indexterm" id="id264"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">RotX</code>, <code class="literal">RotY</code>, <code class="literal">RotZ</code> (rotation)</p>
</td><td style="text-align: left" valign="top">
<p>Bone</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Material<a class="indexterm" id="id265"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">R</code>,<code class="literal">G</code>,<code class="literal">B</code> (diffuse color)</p>
</td><td style="text-align: left" valign="top">
<p>Any object that takes a material</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Texture<a class="indexterm" id="id266"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Contrast</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Any object with associated textures, such as <code class="literal">Mesh</code>, <code class="literal">Lamp</code>, <code class="literal">World</code>, and so on</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Curve<a class="indexterm" id="id267"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Speed</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Curve</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Lamp<a class="indexterm" id="id268"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Energ</code> (energy)</p>
<p>
<code class="literal">R</code>,<code class="literal">G</code>,<code class="literal">B</code> (color)</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Lamp</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>World<a class="indexterm" id="id269"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">HorR</code>,<code class="literal">HorG</code>,<code class="literal">HorB</code> (horizon color)</p>
</td><td style="text-align: left" valign="top">
<p>World</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Constraint<a class="indexterm" id="id270"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Inf</code> (Influence)</p>
</td><td style="text-align: left" valign="top">
<p>Constraint</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Sequence<a class="indexterm" id="id271"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Fac</code> (Factor, for example, the volume of an audio strip)</p>
</td><td style="text-align: left" valign="top">
<p>Sequence</p>
</td></tr></tbody></table></div></div><div class="section" title="IPOchannels and IPOCurves"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>IPOchannels and IPOCurves</h2></div></div></div><a class="indexterm" id="id272"/><a class="indexterm" id="id273"/><a class="indexterm" id="id274"/><a class="indexterm" id="id275"/><p>IPOs of a given type will contain a whole collection of related animated properties. Each of these properties is often referred to as a channel. Examples of channels in an Object type IPO are for example <code class="literal">LocX</code> (the x-component of a location) and <code class="literal">RotY</code> (the rotation around the y-axis). Each channel is represented by an <code class="literal">IPOCurve</code> object that implements the required functionality to return a value interpolated between key frames.</p><p>An example of a channel in a Material type IPO would be <code class="literal">SpecB</code>—the blue component of the specular color.</p><p>
<code class="literal">IPOCurve</code> objects of a given IPO are accessed as attributes, for example, <code class="literal">myipo.LocX</code> will refer to a <code class="literal">LocX</code> <code class="literal">IPOCurve</code> if <code class="literal">myipo</code> is an Object type IPO.</p><p>To illustrate these concepts imagine that we want to animate the movement of a simple cube along the x-axis. We want to start the motion at frame number 1 and to end it at frame number 25. Within Blender, this is accomplished by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a simple <code class="literal">Cube</code> by selecting <span class="strong"><strong>Add | Mesh | Cube</strong></span> and make sure that you are in Object mode again.</li><li class="listitem">Go to frame number one (for example, by entering the frame number in the frame number widget below the 3D View window).</li><li class="listitem">Insert a location key frame by selecting <span class="strong"><strong>Object | Insert keyframe | Loc</strong></span>. In the <code class="literal">IPOCurve</code> editing window this location key frame will show up as an Object type IPO (highlighted in the following screenshot).<div class="mediaobject"><img alt="IPOchannels and IPOCurves" src="graphics/0400-04-01.jpg"/></div></li></ol></div><a class="indexterm" id="id276"/><a class="indexterm" id="id277"/><a class="indexterm" id="id278"/><a class="indexterm" id="id279"/><p>The current frame is visible as a green vertical line. A location IPO holds three distinct channels (for the location along the x-axis, <code class="literal">LocX</code>, and along the y– and z-axes (<code class="literal">LocY</code> and <code class="literal">LocZ</code>). These channels are represented as different colored graphs (they might overlap). These graphs may be manipulated in the <code class="literal">IPOCurve</code> editor directly, but here we will just add a second key frame in the 3D View window.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the 3D View window, go to frame number 25.</li><li class="listitem">Select the Cube and move it along the x-axis to the right.</li><li class="listitem">Insert a second location key frame by selecting <span class="strong"><strong>Object | Insert keyframe | Loc</strong></span>. Now we see that each of the graphs representing the three location IPO channels have a second point defined on them. Because we changed the location of the cube only along the x-axis, the graphs of the other channels remain flat, but the <code class="literal">LocX</code> channel shows how the change of x-position progresses with each frame.<div class="mediaobject"><img alt="IPOchannels and IPOCurves" src="graphics/0400-04-02.jpg"/></div></li></ol></div><a class="indexterm" id="id280"/><a class="indexterm" id="id281"/><a class="indexterm" id="id282"/><a class="indexterm" id="id283"/><p>By adding more key frames we can make any motion as complex as we want, but this becomes a lot of work if we want our object to follow a precise precalculated path for example. Later in this chapter we will see how we can manipulate the <code class="literal">IPOCurve</code> objects that represent these channels within an IPO programmatically.</p></div><div class="section" title="Constraints"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Constraints</h2></div></div></div><a class="indexterm" id="id284"/><a class="indexterm" id="id285"/><p>
<span class="strong"><strong>Constraints</strong></span> in Blender are associated with top-level Blender Objects or Blender Bone objects and represented by <code class="literal">Constraint</code> objects. Blender Objects and Bones have a <code class="literal">constraints</code> attribute, which is an object implementing a sequence of constraints and methods to add, remove, and alter the order of constraints in this sequence (being able to change the order of constraints is necessary because in some situations the order in which constraints are applied matters).</p><p>When a constraint is associated with an object the result will be a mix of the constrained parameters and the calculated parameters. How much this mix will consist of constrained or unconstrained parameters is determined by the <code class="literal">influence</code> attribute and this may even be animated.</p></div></div></div>
<div class="section" title="Difference between drivers and constraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Difference between drivers and constraints</h1></div></div></div><a class="indexterm" id="id286"/><a class="indexterm" id="id287"/><p>Drivers and constraints are related in the sense that they influence the way parameters may change but they are also very different: constraints act on objects while drivers determine how IPO curves (animated parameters) change other IPO curves. And where constraints can only influence the spatial properties of an object such as its position, scale or rotation, any IPO curve may be driven by another IPO curve. This means that even material parameters, such as color or a <code class="literal">Lamp</code> parameter such as energy, may be driven by another IPO. There is a restriction though: the IPO curves that drive other IPO curves must currently be special properties of an object so you can drive the color of a material by the rotation of some object but you cannot drive that color by the energy of a lamp for instance. Also, the fact that constraints can affect only spatial properties means that there is for instance no way that you can limit the diffuse color of a material. The following table shows some constraints and their relevant attributes. Refer to the API documentation for the <code class="literal">Blender.Constraint</code> module for more details.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Constraint type</p>
</th><th style="text-align: left" valign="bottom">
<p>Typical attributes</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TrackTo</code>
</p>
</td><td style="text-align: left" valign="top">
<a class="indexterm" id="id288"/>
<p>
<code class="literal">Target</code> (target object)</p>
<p>
<code class="literal">Track</code> (axis to track)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Floor</code>
</p>
</td><td style="text-align: left" valign="top">
<a class="indexterm" id="id289"/>
<p>
<code class="literal">Target</code> (target object)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">StretchTo</code>
</p>
</td><td style="text-align: left" valign="top">
<a class="indexterm" id="id290"/>
<p>
<code class="literal">Target</code> (target object)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CopyLocation</code>
</p>
</td><td style="text-align: left" valign="top">
<a class="indexterm" id="id291"/>
<p>
<code class="literal">Copy</code> (which location component(s) to copy)</p>
</td></tr></tbody></table></div><p>Note that it is possible to animate the influence of a constraint as well, in which case an Object will have an associated constraint type IPO.</p></div>
<div class="section" title="Programming with constraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Programming with constraints</h1></div></div></div><a class="indexterm" id="id292"/><p>Blender has many constraints that you may apply to an object. Some of them are quite like drivers, in the sense that they do not restrict a motion of an object but copy some parameters such as rotation or location. From a developer's point of view, each Blender Object has a <code class="literal">constraints</code> attribute<a class="indexterm" id="id293"/> that is a sequence of constraint objects. This sequence can be appended and items from this sequence can be deleted. It is also possible to alter the order of the items.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Action</p>
</th><th style="text-align: left" valign="bottom">
<p>Example</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">append(</code><span class="emphasis"><em>type</em></span><code class="literal">)</code>
</p>
</td><td style="text-align: left" valign="top">
<a class="indexterm" id="id294"/>
<p>Appends a new constraint to an object and returns the constraint</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ob.constraints.append(Constraint.Type.TRACKTO)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">remove(</code><span class="emphasis"><em>constraint</em></span><code class="literal">)</code>
</p>
</td><td style="text-align: left" valign="top">
<a class="indexterm" id="id295"/>
<p>Removes a constraint from an object</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ob.constraints.remove(ob.constraints[0])</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">moveUp(</code><span class="emphasis"><em>constraint</em></span><code class="literal">)</code>
</p>
<p>
<code class="literal">moveDown(</code><span class="emphasis"><em>constraint</em></span><code class="literal">)</code>
</p>
</td><td style="text-align: left" valign="top">
<a class="indexterm" id="id296"/>
<a class="indexterm" id="id297"/>
<p>Change the position of a constraint in the list of constraints</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ob.constraints.moveDown(ob.constraints[0])</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">[]</code><a class="indexterm" id="id298"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Accesses an attribute of a constraint</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Con = ob.constraints[0]</code>
</p>
<p>
<code class="literal">Con[Constraint.Settings.TARGET] = other</code>
</p>
</td></tr></tbody></table></div><p>New <code class="literal">Constraint</code> objects are not instanced by way of a constructor, but by calling the <code class="literal">append()</code> method of the <code class="literal">constraints</code> attribute with the type of the constraint to add. <code class="literal">append()</code> will then return the new <code class="literal">Constraint</code> whose settings may then be altered.</p></div>
<div class="section" title="Programming with IPOs"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Programming with IPOs</h1></div></div></div><p>IPO channels can be changed from a script just as constraints can but they are rather more diverse than constraints because there are many different types of IPO channels and some of them, notably texture channels and shape keys, need a special treatment. They have a separate chapter of their own (<a class="link" href="ch06.html" title="Chapter 6. Shape Keys, IPOs, and Poses">Chapter 6</a>: <span class="emphasis"><em>Shape keys, IPOs, and Poses</em></span>) but a different use of Python for IPO channels is shown in the next section.</p></div>
<div class="section" title="PyDrivers"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>PyDrivers</h1></div></div></div><p>There are many cases where we would like to change some property by referring to another property but where the relationship cannot be captured by driving an IPO channel by another one. Often, this is because the relation is not a simple linear dependency, for example, a piston driven by a circular motion. Another case would be if the relation is non continuous, for example, a light that is turned on when a switch is in a certain position.</p><p>In these cases the relationship may be defined by a Python expression or by the so-called <span class="emphasis"><em>pydriver</em></span>. A pydriver takes the IPO channel of another object as input and produces output that will drive a channel on the current object. Because these Python expressions can access the complete Blender API, these relations can be made very complex indeed.</p></div>
<div class="section" title="PyConstraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>PyConstraints</h1></div></div></div><p>Where pydrivers may be used to bypass limitations in the built-in possibilities to drive IPO channels, <span class="strong"><strong>PyConstraints</strong></span> allow us to conquer difficulties in situations where the built-in constraints will not suffice. For example, it is not possible to restrict the position of an object to the surface of another object with holes in it. The built-in constraints offer ways to limit the position to a location not lower than another object (the <code class="literal">floor</code> constraint). But if we would like it to be possible for our object to drop below the surface at locations where there is a hole, we would have to program such a constraint ourselves. As we will see, PyConstraints allow us to do just that.</p><p>With all these introductory remarks behind us we can finally turn to programming again in the next section.</p></div>
<div class="section" title="Setting the time&#x2014;one to rule them all"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Setting the time—one to rule them all</h1></div></div></div><p>What use is a clock if you cannot set the time in a convenient way? Instead of positioning each hand, we would like to turn a single knob to move both the big hand and the little hand where the little hand would have to move twelve times as slow as the big hand.</p><p>Therefore, we would have to define a <code class="literal">knob</code> object (that we probably would not render) and drive the rotation of the bones in the clock by the rotation of this knob.</p><p>To set up the driven channels we follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the 3D View, select the <code class="literal">bighand</code> object.</li><li class="listitem">In the IPO window, make sure that you have the object IPO types selected. On the right-hand side, there will be a list of channels. Select the one labeled <span class="strong"><strong>RotZ</strong></span> by left-clicking on it. It will be highlighted.<div class="mediaobject"><img alt="Setting the time—one to rule them all" src="graphics/0400-04-03.jpg"/></div></li><li class="listitem">Select <span class="strong"><strong>Curve | Transform Properties</strong></span>. A pop-up window will appear. Click on the <span class="strong"><strong>Add Driver</strong></span> button. <div class="mediaobject"><img alt="Setting the time—one to rule them all" src="graphics/0400-04-04.jpg"/></div></li><li class="listitem">With the <span class="strong"><strong>Transform Properties</strong></span> pop up still present, select <span class="strong"><strong>Curve | Insert 1:1</strong></span> <span class="strong"><strong>mapping</strong></span> and next click on the <span class="strong"><strong>Default one-to-one mapping</strong></span> pop up (or press <span class="emphasis"><em>Enter</em></span>). The resulting graph will show up as a straight, pale blue line in the IPO editor window.<div class="mediaobject"><img alt="Setting the time—one to rule them all" src="graphics/0400-04-05.jpg"/></div></li><li class="listitem">In the <span class="strong"><strong>Transform Properties</strong></span> pop-up window, click on the pale green python icon. The python icon will turn dark green and it is now possible to enter a pydriver expression in the adjacent text field. Enter the following line of code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ob('Knob').RotZ</strong></span>*(360/(2*m.pi))/10</pre></div></li></ol></div><p>Et voila! If you now rotate the <code class="literal">knob</code> object about its z-axis the big hand follows suit. The pydriver expression does need some clarification though. The highlighted part is the driver—the object channel that supplies the input for our driven channel. The <code class="literal">ob('Knob')</code> part is the shorthand allowed in pydriver expressions for <code class="literal">Blender.Object.Get('Knob')</code> and the <code class="literal">RotZ</code> attribute supplies us with the rotation about the z-axis. This rotation, however, is given in radians, whereas the result of a pydriver expression for a rotation channel should be in degrees, so we multiply by 360 degrees and divide by 2 times pi. Finally, we divide our calculated number of degrees by ten because for some obscure reason, Blender does not really expect degrees but the number of degrees divided by 10! (Note that this "divide by ten" business is valid only for rotation channels and not for any of the other channels!)</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>1-on-1 mappings</p><p>You may wonder why we would have to insert a 1-on-1 curve first. Well, the relation between a driven channel and its driver contains one more layer and that is a curve translating the output of the pydriver to the final output. This curve can be tweaked of course, but normally we would do all the fine-tuning in our pydriver and just put in a 1-on-1 curve. This way of working is so common that Blender provides a menu entry especially for this situation since it is quite tedious to create the necessary curves again and again for each driven channel.</p></div></div><p>Of course, we could have accomplished the same feat by driving the rotation channel directly by the rotation channel of the <code class="literal">knob</code> object or even by a copy rotation constraint. That would have saved us the strange conversion issues but the purpose of this section is to show the basics.</p><p>The little hand is an example where using a pydriver really is a valid solution. (Although by tweaking the IPO curve itself we could alter the pace of the driven channel but that would not be as clear as a simple expression and almost impossible for more complex relations) We repeat the list of actions shown earlier but now for the little hand object and enter the following pydriver expression:</p><div class="informalexample"><pre class="programlisting">ob('Knob').RotZ*(360/(2*m.pi))/10/12</pre></div><p>Because the little hand runs twelve times as slow as the big hand, we use the same pydriver expression as for the big hand but divide that result by twelve. Now when we rotate the <code class="literal">knob</code> object about its z-axis, the big hand will follow as will the little hand at its set pace. Instead of manually rotating the knob it is also possible to animate the rotation of the knob to animate both clock hands. The complete result is available as <code class="literal">clock-pydriver.blend</code> and a rendered image of the clock, with the knob driving the motion of the hands visible on the top left, is shown in the next screenshot:</p><div class="mediaobject"><img alt="Setting the time—one to rule them all" src="graphics/0400-04-06.jpg"/></div><div class="section" title="Shortcuts"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Shortcuts</h2></div></div></div><p>Within pydriver expressions some useful shortcuts can be used to save on typing. In the step-by-step example we already made use of the <code class="literal">ob('&lt;name&gt;')</code> shortcut that refers to Blender objects by name and likewise, it is possible to access <code class="literal">Mesh</code> objects and materials by <code class="literal">me('&lt;name&gt;')</code> and <code class="literal">ma('&lt;name&gt;')</code> respectively. Furthermore, the <code class="literal">Blender</code> module is available as <code class="literal">b</code>, the <code class="literal">Blender.Noise</code> module as <code class="literal">n</code>, and Python's <code class="literal">math</code> module as <code class="literal">m</code>. This allows for expressions using trigonometric functions such as sinus, for example. These facilities are sufficient to cover many issues but they still might not be enough, for instance if we would like to import external modules. There is a way around these difficulties though as we will see in the next section.</p><div class="section" title="Overcoming limitations: pydrivers.py"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Overcoming limitations: pydrivers.py</h3></div></div></div><p>The input field for pydrivers is limited to 125 characters and even though the shortcuts provided to access Python's <code class="literal">math</code> module and some of the Blender modules allow for shorter expressions, the space provided is often not enough. Also, as pydrivers must be Python expressions, it is quite difficult to debug them (because you cannot insert <code class="literal">print</code> statements for example) or to attain something like an <code class="literal">if/then</code> functionality. The latter can be overcome, to a certain extent, by clever tricks based on the fact that <code class="literal">True</code> and <code class="literal">False</code> in Python are converted to 1 and 0 respectively inside numerical expressions, so the statement:</p><div class="informalexample"><pre class="programlisting">if a&gt;b:
   c=14
else:
   c=109</pre></div><p>may be expressed as:</p><div class="informalexample"><pre class="programlisting">c = (a&gt;b)*14 + (a&lt;=b)*109</pre></div><p>However, this feels awkward and evaluates the condition twice. Fortunately, both the space problem and the limitation to a single expression can be solved by using a text block named <code class="literal">pydrivers.py</code>. If such a text block is present, its contents are accessible as a module called <code class="literal">p</code>. So, for example, if we define a function <code class="literal">clamp()</code> in <code class="literal">pydrivers.py</code> that looks like this:</p><div class="informalexample"><pre class="programlisting">def clamp(a,low,high):
   if a&lt;low : a=low
   if a&gt;high: a=high
   return a</pre></div><p>We may invoke this function in our pydriver expression as <code class="literal">p.clamp(a,14,109)</code>. </p><p>We will use <code class="literal">pydrivers.py</code> quite a bit in the following examples, not only because it allows for more complex expressions, but also because the width of the pydriver field is even smaller than the length of its allowed content making it very hard to read as you have to scroll about to access all parts of an expression.</p></div></div></div>
<div class="section" title="Internal combustion&#x2014;correlating complex changes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Internal combustion—correlating complex changes</h1></div></div></div><p>Imagine that we want to demonstrate how a four-stroke internal combustion engine works. Such an engine has a lot of moving parts and many of them are related in complex ways.</p><p>To see what these exact relations are, it might be useful to have a look at the following illustration. It lists the names that we will use when we refer to the various parts. (I am neither an automotive engineer nor a mechanic so these part names may not be accurate but at least we will be talking about the same things. For more information you may want to read <a class="ulink" href="http://en.wikipedia.org/wiki/Four-stroke_cycle">http://en.wikipedia.org/wiki/Four-stroke_cycle</a>.)</p><div class="mediaobject"><img alt="Internal combustion—correlating complex changes" src="graphics/0400-04-07.jpg"/></div><p>Before we start to configure the parts to have their rotation and position driven by another part, it is a good thing to think ahead: in real life, the pistons inside the cylinders are propelled by the expansion of the ignited fuel and the pistons drive the drive shaft (or crank-shaft) with the attached flywheel and a distribution belt (or in our case some gears, that are not shown here) transfers that motion back to the camshafts that drive the motion of the inlet and outlet valves. Obviously, we cannot follow this concept directly as there is no fuel object of some sort to drive other objects so it makes more sense to reverse the chain of relations. In our setup the flywheel will drive the drive shaft and the different gears and the drive shaft will drive most other objects, including the piston and its connecting rod. We will also drive the energy of the lamp positioned at the tip of the spark plug by the rotation of the drive shaft.</p><p>The drive shaft will simply follow the rotation of the flywheel as will the lower gear (this could be implemented with a <code class="literal">copy</code> <code class="literal">rotation</code> constraint just as well but here we choose to implement everything by pydrivers). The corresponding pydrivers for the <code class="literal">RotX</code> channel will look like this:</p><div class="informalexample"><pre class="programlisting">ob('Flywheel').RotX/(2*m.pi)*36</pre></div><p>This may look awkward for something just copying a rotation but remember that rotations are stored as radians while pydriver expressions should return rotations as degrees divided by 10.</p><p>The top gear and both the camshafts will also follow the rotation of the flywheel but with the speed reduced to half and with the direction of the rotation reversed:</p><div class="informalexample"><pre class="programlisting">m.degrees(ob('Flywheel').RotX*-0.5)/10.0</pre></div><p>To illustrate how to access functions in Python's <code class="literal">math</code> module we did not do the conversion to degrees ourselves but used the <code class="literal">degrees()</code> function supplied by the <code class="literal">math</code> module.</p><p>We modeled the camshafts with the cam pointing exactly downward. If we want to drive the x-axis rotation of the inlet camshaft by the rotation of the drive shaft we have to take into account that it moves at half the speed. Also, its rotation lags behind a bit to match the ignition cycle of the cylinder as it opens the inlet valve on the first downstroke and closes the valve just before the ignition spark:</p><div class="informalexample"><pre class="programlisting">ob('DriveShaftPart').RotX/(2*m.pi)*18+9</pre></div><p>The expression for the outlet camshaft is almost identical except for the amount it lags behind (here <code class="literal">24</code>, but tuning this engine is left to real mechanics):</p><div class="informalexample"><pre class="programlisting">ob('DriveShaftPart').RotX/(2*m.pi)*18+24</pre></div><div class="mediaobject"><img alt="Internal combustion—correlating complex changes" src="graphics/0400-04-08.jpg"/></div><p>The movement of the piston is limited to just the vertical, but the exact motion is somewhat more involved to calculate. We are interested in the position of the quantity <span class="strong"><strong>Q</strong></span>—see the preceding figure—and the distance between the center of the drive shaft and point where the connecting rod (<span class="strong"><strong>L</strong></span> in the diagram) connects to the piston. Because the length of the connecting rod is fixed, <span class="strong"><strong>Q</strong></span> will vary as a function of the rotation angle <span class="strong"><strong>α</strong></span> of the drive shaft. The distance from the center of the drive shaft to point where the connecting rod is connected to the drive shaft is also fixed. We call this distance R. Now we have a triangle with sides <span class="strong"><strong>Q</strong></span>, <span class="strong"><strong>L</strong></span>, and <span class="strong"><strong>R</strong></span> and a known angle <span class="strong"><strong>α</strong></span>. As three of these quantities (L, R, and α) are known, we can calculate the fourth, <span class="strong"><strong>Q</strong></span>, by using the cosine rule (<a class="ulink" href="http://en.wikipedia.org/wiki/Law_of_cosines">http://en.wikipedia.org/wiki/Law_of_cosines</a>). Therefore, we define a function <code class="literal">q()</code> in <code class="literal">pydrivers.py</code> that will return the length <span class="strong"><strong>Q</strong></span> when <span class="strong"><strong>L</strong></span>,<span class="strong"><strong>R</strong></span>, and <span class="strong"><strong>α</strong></span> are given:</p><div class="informalexample"><pre class="programlisting">def q(l,r,a): return r*cos(a)+sqrt(l**2-(r*sin(a))**2)</pre></div><p>The expression for the <code class="literal">LocZ</code> channel of the piston will then simply call this function with the appropriate values for the arguments:</p><div class="informalexample"><pre class="programlisting">p.q(1.542,0.655,ob('DriveShaftPart').RotX)</pre></div><p>The precise values for <span class="strong"><strong>L</strong></span> and <span class="strong"><strong>R</strong></span> were taken from the mesh by noting the position of appropriate vertices of the connecting rod and the drive shaft in the <code class="literal">Transform Properties</code> window. (<span class="emphasis"><em>N</em></span> key in the 3D View)</p><p>The connecting rod itself may use the same expression for its <code class="literal">LocZ</code> channel as we carefully made the mesh origins of the piston and the connecting rod to coincide. </p><p>However, the motion of the connecting rod is not limited to the z-location as it will rotate around the x-axis centered on the point connecting it to the piston. The angle of this rotation (<span class="strong"><strong>γ</strong></span> in the diagram) can be derived from the quantities <span class="strong"><strong>L</strong></span>, <span class="strong"><strong>R</strong></span>, and <span class="strong"><strong>α</strong></span>:</p><div class="informalexample"><pre class="programlisting">def topa(l,r,a):
   Q=q(l,r,a)
   ac=acos((Q**2+l**2-r**2)/(2*Q*l))
   if a%(2*pi)&gt;pi : ac = -ac
   return -ac</pre></div><p>The pydriver expression for <code class="literal">RotX</code> will then look like this:</p><div class="informalexample"><pre class="programlisting">m.degrees(p.topa(1.542,0.655,ob('DriveShaftPart').RotX))/10.0</pre></div><p>The inlet and outlet valves are driven by the rotation of their respective camshafts. The outline of the actual cam is quite complex so here, we use not the actual form of that outline but approximate it by something that looks good enough (that is, open the valve in a fluent yet brisk motion at the correct moment). The following graph shows the valve travel as a function of rotation angle:</p><div class="mediaobject"><img alt="Internal combustion—correlating complex changes" src="graphics/0400-04-09.jpg"/></div><p>To this end, in <code class="literal">pydrivers.py</code> we define a function <code class="literal">spike()</code> that will take the rotation of the camshaft as its argument and returns a value between <code class="literal">0.0</code> and <code class="literal">1.0</code> that rises steeply around the zero angle:</p><div class="informalexample"><pre class="programlisting">def spike(angle):
   t = (cos(angle)+1.0)/2.0
   return t**4</pre></div><a class="indexterm" id="id299"/><p>Now the motion of the valve is linear but the line it follows is tilted by 10 degrees (forward for the inlet valve, backward for the outlet valve) so we have to drive two channels, <code class="literal">LocZ</code> and <code class="literal">LocY</code>, each multiplied by the correct amount to effect the slanted motion. We therefore define two functions in <code class="literal">pydrivers.py</code>:</p><div class="informalexample"><pre class="programlisting">def valveZ(angle,tilt,travel,offset):
   return cos(radians(tilt))*spike(angle)*travel+offset
def valveY(angle,tilt,travel,offset):
   return sin(radians(tilt))*spike(angle)*travel+offset</pre></div><p>Both functions will return a distance given the rotation angle of the object driving it. The <code class="literal">tilt</code> is the amount that the valve is tilted (in degrees), <code class="literal">travel</code> is the maximum distance the valve will travel along the tilted line, and <code class="literal">offset</code> is a value that allows us to tweak the position of the valve. The corresponding pydriver expressions for the <code class="literal">LocZ</code> and <code class="literal">LocY</code> channels of the inlet valve will then become:</p><div class="informalexample"><pre class="programlisting">p.valveZ(ob('CamInlet').RotX+m.pi,-10.0,-0.1,6.55)</pre></div><p>and</p><div class="informalexample"><pre class="programlisting">p.valveY(ob('CamInlet').RotX+m.pi,-10.0,-0.1,-0.03)</pre></div><p>(The expressions for the outlet valve look the same but with a positive tilt angle.)</p><a class="indexterm" id="id300"/><p>Until now, all channels have been object channels, that is, locations and rotations. But it is also possible to drive other channels, and that is precisely what we need to drive the energy of the lamp positioned at the tip of our spark plug. In <code class="literal">pydrivers.py</code> we first define a helper function <code class="literal">topi()</code><a class="indexterm" id="id301"/> that, besides the rotation angle of the driving object, will take an angle <code class="literal">h</code> (in radians) and an intensity <code class="literal">i</code> as arguments. It will return that intensity if the angle of the driving object is between <code class="literal">0</code> and <code class="literal">h</code> and will return zero outside this range. Because the input angle may be larger than two times pi (when the driving object is rotated more than full circle), we correct this by the highlighted <span class="emphasis"><em>modulo</em></span> operation:</p><div class="informalexample"><pre class="programlisting">def topi(a,h,i):
 <span class="strong"><strong>  m = a%(2*pi)</strong></span>
   r=0.0
   if m&lt;h: r=i
   return r</pre></div><p>The pydriver expression for the energy channel (called "Energ" in the IPO editor window) can then be expressed as follows:</p><div class="informalexample"><pre class="programlisting">p.topi(ob('DriveShaftPart').RotX/2+m.pi,0.3,0.5)</pre></div><p>As shown, this expression will 'fire' the spark plug for the first 17 degrees or so (<code class="literal">0.3</code> radians) of its cycle by setting the energy to <code class="literal">0.5</code>.</p><div class="section" title="More power—combining multiple cylinders to an engine"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>More power—combining multiple cylinders to an engine</h2></div></div></div><p>Once we have modeled a single cylinder and taken care of driving the motions of the individual parts, our next step is to duplicate the cylinders to create a set like the opening illustration of this chapter. In principle we can select all parts, duplicate them by pressing <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>D</em></span>, and adjust the timing of the individual driven channels.</p><p>There is a snag, however. When using <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>D</em></span> rather than <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>D</em></span> we make actual copies of the object meshes instead of merely referring to the same. We would expect the same for other items associated with an object, such as materials, textures, and IPOs. This is not the case however as Blender, by default, does not duplicate those last three categories when duplicating an object. This would be awkward, as a change in the IPO of the first piston for example would affect all duplicated pistons as well.</p><p>We could make those copies unique afterward (by clicking on the user count field of those IPOs for instance and confirm the <span class="strong"><strong>make</strong></span> <span class="strong"><strong>single</strong></span> <span class="strong"><strong>user?</strong></span> popup) but this is tedious as it would have to be repeated for each copy.</p><div class="mediaobject"><img alt="More power—combining multiple cylinders to an engine" src="graphics/0400-04-10.jpg"/></div><p>A better way is to alter the <span class="strong"><strong>Duplicate</strong></span> <span class="strong"><strong>with</strong></span> <span class="strong"><strong>object</strong></span> settings in the <span class="strong"><strong>Edit</strong></span> <span class="strong"><strong>Methods</strong></span> screen of the <span class="strong"><strong>User Preferences</strong></span> window as shown in the preceding screenshot. In this way, IPOs associated with an object will be made into unique copies when duplicating an object. A screenshot of the <span class="strong"><strong>User Preferences</strong></span> window with buttons to duplicate IPOs (highlighted) is shown above.</p><a class="indexterm" id="id302"/><p>The result of our labors, a four cylinder engine with gears to transfer the motion of the drive shaft to the camshafts is available as <code class="literal">engine001.blend</code>. A still image from the animation available at <a class="ulink" href="http://vimeo.com/7170769">http://vimeo.com/7170769</a> is shown in the next screenshot:</p><div class="mediaobject"><img alt="More power—combining multiple cylinders to an engine" src="graphics/0400-04-11.jpg"/></div></div></div>
<div class="section" title="Adding simple constraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Adding simple constraints</h1></div></div></div><a class="indexterm" id="id303"/><p>Constraints may be applied to objects as well as to bones. In both instances a new constraint is added by calling the <code class="literal">append()</code> method of the <code class="literal">constraints</code> attribute. Our next example will show how we may restrict the movement of the clock hands from the rigged clock (from <a class="link" href="ch03.html" title="Chapter 3. Vertex Groups and Materials">Chapter 3</a>, 
<span class="emphasis"><em>Vertex Groups and Materials</em></span>) to rotate around the z-axis. The code defining the function to accomplish this starts off with two <code class="literal">import</code> statements that will save us some typing:</p><div class="informalexample"><pre class="programlisting">from Blender.Constraint import Type
from Blender.Constraint import Settings</pre></div><p>The function itself will take two arguments: <code class="literal">obbones</code>, a reference to a Blender object whose data is an armature (that is, not the armature object itself) and <code class="literal">bone</code>, the name of the bone whose motion we would like to restrict. It is important to understand that the constraint that we will associate with a bone is not a property of the armature but of the pose of the object containing the armature. Many objects may refer to the same armature and any poses are associated with the object so different objects referring to the same armature may strike different poses.</p><p>So the function starts off by getting the pose first and then a reference to the bone that we want to constrain. The highlighted line shows how to associate the constraint (this would be similar if we would associate a constraint with a Blender object instead of a bone):</p><div class="informalexample"><pre class="programlisting">def zrotonly(obbones,bone):
   poseob = obbones.getPose()
   bigarmpose = poseob.bones[bone]
 <span class="strong"><strong>  c=bigarmpose.constraints.append(Type.LIMITROT)</strong></span>
   c[Settings.LIMIT]=Settings.LIMIT_XROT|Settings.LIMIT_YROT
   c[Settings.XMIN]=0.0
   c[Settings.XMAX]=0.0
   c[Settings.YMIN]=0.0
   c[Settings.YMAX]=0.0
   poseob.update()</pre></div><a class="indexterm" id="id304"/><p>The newly appended constraint is retained as the variable <code class="literal">c</code> and the subsequent lines show that the different attributes of a constraint may be accessed like a dictionary. First, we configure the <code class="literal">LIMIT</code> attribute (a bitmap) to limit the rotation of the x and y axes. Next, we set the minimum and maximum of the rotations around these axes to <code class="literal">0.0</code>, as we disallow any movement. In the rigging of a realistic animal skeleton, for example, these values could be set to limit the extent of the rotation to values comparable with a real joint. Finally, to make the changes to our <code class="literal">Pose</code> object visible, we call its <code class="literal">update()</code> method.</p></div>
<div class="section" title="Defining complex constraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Defining complex constraints</h1></div></div></div><a class="indexterm" id="id305"/><p>Where pydrivers enable us to drive the change of one <code class="literal">IPOCurve</code> by the change in another, PyConstraints provide us with ways to let object properties change only in a limited way.</p><p>Of course, Blender has many simple constraints predefined as we saw in previous sections and often a combination of simple constraints may be exactly what you want. But say you want your objects to move about freely within a non-rectangular area, for example to simplify the allowed placement of traffic lights and phone booths on a street grid. How would we achieve that? Enter pyconstraints.</p><p>
<span class="strong"><strong>PyConstraints</strong></span><a class="indexterm" id="id306"/> are Python scripts that should be present as a text block in Blender's text editor and start with a comment line identifying it as a constraint:</p><div class="informalexample"><pre class="programlisting">#BPYCONSTRAINT</pre></div><a class="indexterm" id="id307"/><a class="indexterm" id="id308"/><p>A Python constraint should contain three functions called <code class="literal">doConstraint()</code>, <code class="literal">doTarget()</code>, and <code class="literal">getSettings()</code>. <a class="indexterm" id="id309"/>The first two are invoked anytime we move either the target or the constrained object and the last one is called when the user clicks the <span class="strong"><strong>Options</strong></span> button that is present once the user has selected a pyconstraint. The following screenshot shows the <span class="strong"><strong>Constraints</strong></span> tab once a pyconstraint is selected.</p><div class="mediaobject"><img alt="Defining complex constraints" src="graphics/0400-04-12.jpg"/></div><p>The easiest way to understand what these functions do is by looking at the built-in constraint template that we can use as a basis to write our own constraints. It is accessible in the text editor from the menu <span class="strong"><strong>Text | Script Templates | Script Constraint</strong></span>. If clicked, it will create a new text block that can be selected from the dropdown at the bottom of the text editor.</p><div class="section" title="The Blender constraint template"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>The Blender constraint template</h2></div></div></div><a class="indexterm" id="id310"/><a class="indexterm" id="id311"/><a class="indexterm" id="id312"/><p>The Blender constraint template contains a lot of helpful comments as well, but here we list mostly the bare functions. Also, the template creates a dummy properties window. We will encounter properties in the next section so our example of <code class="literal">getSettings()</code> here will be almost empty. As shown the functions will implement a functional constraint, however, nothing is actually constrained. Location, rotation, and scale of the constrained object are all kept the same.</p><div class="informalexample"><pre class="programlisting">def doConstraint(obmatrix, targetmatrices, idprop):
   # Separate out the transformation components for easy access.
   obloc = obmatrix.translationPart()   # Translation
   obrot = obmatrix.toEuler()         # Rotation
   obsca = obmatrix.scalePart()      # Scale

   # code to actually change location, rotation or scale goes here

   # Convert back into a matrix for loc, scale, rotation,
   mtxloc = Mathutils.TranslationMatrix(obloc)
   mtxrot = obrot.toMatrix().resize4x4()
   mtxsca = Mathutils.Matrix([obsca[0],0,0,0], [0,obsca[1],0,0],[0,0,obsca[2],0], [0,0,0,1])
   
   # Recombine the separate elements into a transform matrix.
   outputmatrix = mtxsca * mtxrot * mtxloc

   # Return the new matrix.
   return outputmatrix</pre></div><p>The <code class="literal">doConstraint()</code> function will be passed the transformation matrix of the constrained object and a list of transformation matrices for every target object. It will also receive a dictionary of properties of the constraint that may be accessed by name.</p><a class="indexterm" id="id313"/><p>The first thing we do is to separate out the translation, rotation, and scale components of the constrained objects' transformation matrix. The translation part will be a vector with the x, y, z position and the scale part will be a vector with scaling factors along the x, y, and z-axis. The rotation part will be represented by a Euler vector with the rotation about the three principal axes. (Eulers greatly simplify working with rotations in 3D but are rather difficult to grasp at first. Wikipedia has a great page on Euler angles <a class="ulink" href="http://en.wikipedia.org/wiki/Euler_angle">http://en.wikipedia.org/wiki/Euler_angle</a> but for now, it is easiest to think of Eulers as a rotation separated out as rotations around the local x, y, and z axes.) We could separate any of the target object's transformation matrices as well, if we wanted, and then modify the transformation components of the transformation matrix of the constrained object in any way we wish.</p><p>The function as shown here does nothing but converts the different transformation components back to matrices by using API methods (where available) and then recombines them by using matrix multiplication to a single matrix that is subsequently returned.</p><p>The <code class="literal">doTarget()</code> function is called prior to calling <code class="literal">doConstraint()</code> and gives us the opportunity to manipulate the target matrix before it is passed to <code class="literal">doConstraint()</code>. Its arguments are the target object, the subtarget (either a <code class="literal">Bone</code> or a vertex group for a target armature or mesh respectively), the target matrix, and the properties of the constraint. In a later section, we exploit this opportunity to store a reference to the target object in the properties so that <code class="literal">doConstraint()</code> may access that information that it otherwise could not access. If we do not wish to alter anything then returning the target matrix as is will suffice, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">def doTarget(target_object, subtarget_bone, target_matrix,id_properties_of_constraint):
   return target_matrix</pre></div><p>Likewise, if there is no need to offer the user the possibility to specify additional properties, <code class="literal">getSettings()</code> may simply return. If we <span class="emphasis"><em>do</em></span> want to show a pop up, <code class="literal">getSettings()</code> is the place where it should happen. We see an example of that in a later section as well. The following code is a valid "do nothing" implementation:</p><div class="informalexample"><pre class="programlisting">def getSettings(idprop):
   return</pre></div></div><div class="section" title="Do you find me attractive too?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Do you find me attractive too?</h2></div></div></div><a class="indexterm" id="id314"/><p>As the moon and earth revolve around each other they feel each other's gravitational attraction. On earth this will result in tides, but the solid body of the earth and moon will be distorted as well, although this effect is small. Now there is a lot more to tides than attraction alone (<a class="ulink" href="http://en.wikipedia.org/wiki/Tides">http://en.wikipedia.org/wiki/Tides</a>), but we can show the gravitational distortion in an exaggerated way by applying constraints.</p><p>One way of doing this is to use a <code class="literal">TrackTo</code> constraint<a class="indexterm" id="id315"/> to orient an axis of our constrained object towards the attracting object and add a second constraint that scales the constrained object along the same axis. The size of the scale will depend on the inverse distance between the constrained object and the target object. The effect is illustrated in the next screenshot where the effect of a <code class="literal">TrackTo</code> constraint is combined with the script constraint <code class="literal">moon_constraint.py</code>.</p><div class="mediaobject"><img alt="Do you find me attractive too?" src="graphics/0400-04-13.jpg"/></div><p>We will have to write this distance-dependent scaling ourselves. If we take the constraint template provided by Blender we can leave the <code class="literal">doTarget()</code> and <code class="literal">getSettings()</code> functions as is, but we do have to write a suitable <code class="literal">doConstraint()</code> function (full code available as <code class="literal">moon_constraint.py</code>):<a class="indexterm" id="id316"/>
</p><div class="informalexample"><pre class="programlisting">def doConstraint(obmatrix, targetmatrices, idprop):
   obloc = obmatrix.translationPart()   # Translation
   obrot = obmatrix.toEuler()         # Rotation
   obsca = obmatrix.scalePart()      # Scale

 <span class="strong"><strong>  tloc = targetmatrices[0].translationPart()</strong></span>
 <span class="strong"><strong>  d = abs((obloc-tloc).length)</strong></span>
 <span class="strong"><strong>  d = max(0.01,d)</strong></span>
 <span class="strong"><strong>  f = 1.0+1.0/d</strong></span>
 <span class="strong"><strong>  obsca[1]*=f</strong></span>
   
   mtxloc = Mathutils.TranslationMatrix(obloc)
   mtxrot = obrot.toMatrix().resize4x4()
   mtxsca = Mathutils.Matrix([obsca[0],0,0,0], [0,obsca[1],0,0],[0,0,obsca[2],0], [0,0,0,1])
   
   outputmatrix = mtxsca * mtxrot * mtxloc

   return outputmatrix</pre></div><p>We left out any lines related to properties as we do not implement any user-configurable properties for this constraint. The highlighted lines show what we have to do to calculate the distance-dependent scaling.</p><p>The first line gets the location of our target. Next, we calculate the distance between the constrained object and the target and limit this to a minimum (slightly larger than zero) to prevent a division by zero in the next highlighted line. The formula used here is nowhere near an approximation of any gravitational influence but behaves nicely enough for our purpose; the scale factor will be <code class="literal">1.0</code> if <code class="literal">d</code> is very large and will smoothly increase as the distance <code class="literal">d</code> becomes smaller. The final highlighted line shows that we alter the scale only of the y-axis, that is, the axis we orient towards the target object with the <code class="literal">TrackTo</code> constraint.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>
<span class="strong"><strong>Cyclic dependencies:</strong></span>
</p><p>If both objects have a comparable mass, the gravitational distortion would be of comparable size on both objects. We might be tempted to add the <code class="literal">TrackTo</code> and <code class="literal">moon_constraint.py</code> constraints to both objects to see the effect they assert on each other, but unfortunately that will not work because it will create a cyclic dependency and Blender will protest.</p></div></div></div><div class="section" title="Snapping to mesh vertices"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Snapping to mesh vertices</h2></div></div></div><a class="indexterm" id="id317"/><p>This is like the "snap to vertex" mode that is available in Blender from the menu <span class="strong"><strong>Object | Transform | Snap </strong></span>(see <span class="strong"><strong/></span>
<a class="ulink" href="http://wiki.blender.org/index.php/Doc:Manual/Modelling/Meshes/Snap_to_Mesh">http://wiki.blender.org/index.php/Doc:Manual/Modelling/Meshes/Snap_to_Mesh</a> for more about snapping) except that the effect is not permanent (the object reverts to its unconstrained position once the constraint is removed) and the strength of the constraint can be modulated (animated even) by changing the Influence slider.</p><p>In the constraints that we designed so far, only the position of the target object was needed to calculate the effects on the constrained object. This position was readily available to the <code class="literal">doConstraint()</code> function as the matrices of the targets were passed as arguments. Now we are facing a different challenge though: if we want to snap to a vertex we must have access to the mesh data of the target object, but the target object is not passed to the <code class="literal">doConstraint()</code> function.</p><p>The way around this obstacle is the <code class="literal">idprop</code> argument that is passed to <code class="literal">doConstraint()</code>. Before <code class="literal">doConstraint()</code> is called, Blender first calls <code class="literal">doTarget()</code> for each target object. This function is passed as a reference to the target object and to the properties of the constraint. This allows us to insert a reference to the target object in these properties and because these properties are passed to <code class="literal">doConstraint()</code>, this provides us with a means to pass the necessary information to <code class="literal">doConstraint()</code> to get at the <code class="literal">Mesh</code> data. There is a minor point to consider here though: Blender properties can only be numbers or strings so we cannot actually store a reference to an object but have to settle for its name. Because a name is unique and Blender's <code class="literal">Object.Get()</code> provides a way to retrieve an object by name, this is not a problem.</p><p>The code for <code class="literal">doConstraint()</code> and <code class="literal">doTarget()</code> will look like this (the full code is provided as <code class="literal">zoning_constraint.py</code>):</p><div class="informalexample"><pre class="programlisting">def doConstraint(obmatrix, targetmatrices, idprop):
   
   obloc = obmatrix.translationPart().resize3D()
   obrot = obmatrix.toEuler()      
   obsca = obmatrix.scalePart()

   # get the target mesh
   <span class="strong"><strong>to = Blender.Object.Get(idprop['target_object'])</strong></span>
   me = to.getData(mesh=1)
   
   # get the location of the target object
   tloc = targetmatrices[0].translationPart().resize3D()
   
   # find the nearest vertex in the target object
   smallest = 1000000.0
   delta_ob=tloc-obloc
   for v in me.verts:
      d = (v.co+delta_ob).length
      if d &lt; smallest:
         smallest=d
         sv=v
   obloc = sv.co + tloc
   
   # reconstruct the object matrix
   mtxrot = obrot.toMatrix().resize4x4()
   mtxloc = Mathutils.TranslationMatrix(obloc)
   mtxsca = Mathutils.Matrix([obsca[0],0,0,0], [0,obsca[1],0,0],[0,0,obsca[2],0], [0,0,0,1])
   outputmatrix = mtxsca * mtxrot * mtxloc
   return outputmatrix

def doTarget(target_object, subtarget_bone, target_matrix,id_properties_of_constraint):
 <span class="strong"><strong>  id_properties_of_constraint['target_object']=target_object.name</strong></span>
   return target_matrix</pre></div><a class="indexterm" id="id318"/><p>The highlighted lines show how we pass the name of the target object to <code class="literal">doConstraint()</code>. In <code class="literal">doConstraint()</code> we first retrieve the target mesh. This may throw an exception, for example, if the target object is not a mesh, but this will be caught by Blender itself. The constraint will not be affected then and an error is shown on the console, but Blender will proceed happily.</p><p>Once we have the mesh data of the target object we retrieve the object location of the target object. We need this because all vertex coordinates are relative to this. Next we compare the location of the constrained object to all the vertex locations of the target mesh and remember the closest one to calculate the object location of the constrained object. Finally, we reconstruct the transformation matrix of the constrained object by combining various transformation components as before.</p></div><div class="section" title="Aligning along a vertex normal"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Aligning along a vertex normal</h2></div></div></div><a class="indexterm" id="id319"/><p>Now that we can constrain an object to the closest vertex on a target mesh we can see that something is missing: the object is not oriented in a meaningful way. This might not always be a problem, for example, trees will normally point upward, but in many situations it would be nice if we could orient the constrained object perpendicular to the surface. This is the same for all practical purposes, as orienting the constrained object along the vertex normal of the vertex it has been snapped to.</p><p>Therefore, after finding the closest vertex we determine the angle between the vertex normal and the z-axis (that is, we arbitrarily define the z direction as 'up') and then rotate the constrained object by the same amount around the axis perpendicular to both the vertex normal and the z-axis. This will orient the constrained object along that vertex normal. If the constrained object was rotated manually before adding the constraint these previous rotations would be lost. If that is not what we want, we can apply any rotations permanently before adding the constraint.</p><a class="indexterm" id="id320"/><p>To implement this alignment feature, our code will change (<code class="literal">zoning_constraint.py</code> contains these changes already): <code class="literal">doConstraint()</code> will have to calculate the rotation part of the transformation matrix. We have to calculate the rotation angle, the rotation axis, and then the new rotation matrix. The highlighted part of the following code shows that the essential tools for these calculations are already provided by the <code class="literal">Mathutils</code> module<a class="indexterm" id="id321"/>:</p><div class="informalexample"><pre class="programlisting">   vnormal = sv.no
   if idprop['NormalAlign'] :
      zunit=Mathutils.Vector(0,0,1)
 <span class="strong"><strong>     a=Mathutils.AngleBetweenVecs(vnormal,zunit)</strong></span>
 <span class="strong"><strong>     rotaxis=zunit.cross(vnormal)</strong></span>
 <span class="strong"><strong>     rotmatrix=Mathutils.RotationMatrix(a,4,"r",rotaxis)</strong></span>
      mtxrot = rotmatrix
   else:
      mtxrot = obrot.toMatrix().resize4x4()</pre></div><p>In the preceding code we can see that we have made an alignment dependent on the <code class="literal">NormalAlign</code> property<a class="indexterm" id="id322"/>. Only if it is set do we calculate the necessary transformation. Therefore, we need to adapt <code class="literal">getSettings()</code> as well because the user needs a way to select whether he wants alignment or not:</p><div class="informalexample"><pre class="programlisting">def getSettings(idprop):
   if not idprop.has_key('NormalAlign'): idprop['NormalAlign'] = True
   
   align = Draw.Create(idprop['NormalAlign'])
   
   block = []
   block.append("Additional restrictions: ")
   block.append(("Alignment: ",align,"Align along vertex normal"))
   
   retval = Draw.PupBlock("Zoning Constraint", block)
   
   if (retval):
      idprop['NormalAlign']= align.val</pre></div><p>As shown, the <code class="literal">NormalAlign</code> property will be set to <code class="literal">True</code> by default. The option is then presented as a simple pop up with a toggle button. If the user clicks outside the pop up or presses the <span class="emphasis"><em>Esc</em></span> key, the return value from <code class="literal">PupBlock()</code><a class="indexterm" id="id323"/> will be <code class="literal">None</code> and we won't change the <code class="literal">NormalAlign</code> property. Otherwise, it will be set to the value of the toggle button.</p><p>The effects are shown in the illustrations. The first one shows a small pine tree constrained to a vertex of a simple subdivided ground plane. It is snapped to the exact vertex location but its z-axis points straight up along the global z-axis. The following screenshot shows a fir tree constrained to a vertex in a craggy landscape.</p><div class="mediaobject"><img alt="Aligning along a vertex normal" src="graphics/0400-04-14.jpg"/></div><a class="indexterm" id="id324"/><p>If we turn on the <code class="literal">NormalAlign</code> property we see that the tree model is no longer pointing straight up, but that its z-axis is aligned along the direction of the vertex normal of the vertex it is snapped to. The following screenshot shows a fir tree constrained to a vertex and aligned along the vertex normal.</p><div class="mediaobject"><img alt="Aligning along a vertex normal" src="graphics/0400-04-15.jpg"/></div><p>It is possible to restrict the vertices the model can snap to even further, for example, to <a class="indexterm" id="id325"/>just the vertices belonging to a vertex group. In the following illustration, our model cannot move beyond the extent of the vertex group that is shown in white. How this might be accomplished is shown in the next section.</p><div class="mediaobject"><img alt="Aligning along a vertex normal" src="graphics/0400-04-16.jpg"/></div></div><div class="section" title="Snap to vertices in a vertex group"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Snap to vertices in a vertex group</h2></div></div></div><a class="indexterm" id="id326"/><p>What if we want to restrict the vertices we can snap an object to? This can be achieved by defining a vertex group and then consider only vertices from this vertex group as candidates to snap to. The code needed for this would take just a couple of lines and the relevant part of <code class="literal">doConstraint()</code> would look like this (the highlighted code shows the additional lines dealing with the matching against a vertex group):</p><div class="informalexample"><pre class="programlisting">   # get the target mesh
   to = Blender.Object.Get(idprop['target_object'])
   me = to.getData(mesh=1)
   
   # get the location of the target object
   tloc = targetmatrices[0].translationPart().resize3D()
   
   # find the nearest vertex in the target object
   smallest = 1000000.0
   delta_ob=tloc-obloc

 <span class="strong"><strong>  try:</strong></span>
 <span class="strong"><strong>     verts = me.getVertsFromGroup(idprop['VertexGroup'])</strong></span>
 <span class="strong"><strong>     for vi in verts:</strong></span>
 <span class="strong"><strong>        d = (me.verts[vi].co+delta_ob).length</strong></span>
 <span class="strong"><strong>        if d &lt; smallest :</strong></span>
 <span class="strong"><strong>           smallest = d</strong></span>
 <span class="strong"><strong>           si = vi</strong></span>
 <span class="strong"><strong>     obloc = me.verts[si].co+tloc</strong></span>
 <span class="strong"><strong>     vnormal = me.verts[si].no</strong></span>
 <span class="strong"><strong>  except AttributeError:</strong></span>
      for v in me.verts:
         d = (v.co+delta_ob).length
         if d &lt; smallest:
            smallest=d
            sv=v
      obloc = sv.co + tloc
      vnormal = sv.no   </pre></div><p>The <code class="literal">try/except</code> construction ensures that if the <code class="literal">VertexGroup</code> property refers to a nonexistent vertex group, we will get the chance to check all vertices. Of course, we now need a way for the user to select the vertex group, so <code class="literal">getSettings()</code> will have to be adapted too. We settle for a simple string input field where the name of a vertex group can be typed. There is no checking if the vertex group exists and if we do not want to restrict the snapping to a vertex group, then we can either leave this input field blank or type in the name of a nonexistent group. Not very elegant but it works (added lines highlighted):<a class="indexterm" id="id327"/>
</p><div class="informalexample"><pre class="programlisting">def getSettings(idprop):
 <span class="strong"><strong>  if not idprop.has_key('VertexGroup'): idprop['VertexGroup'] ='Zone'</strong></span>
   if not idprop.has_key('NormalAlign'): idprop['NormalAlign'] = True
   
 <span class="strong"><strong>  vgroup = Draw.Create(idprop['VertexGroup'])</strong></span>
   align = Draw.Create(idprop['NormalAlign'])
   
   block = []
   block.append("Additional restrictions: ")
 <span class="strong"><strong>  block.append(("Vertex Group: ",vgroup,0,30,"Vertex Group torestrict location to"))</strong></span>
   block.append(("Alignment: ",align,"Align along vertex normal"))
   
   retval = Draw.PupBlock("Zoning Constraint", block)
   
   if (retval):
 <span class="strong"><strong>     idprop['VertexGroup']= vgroup.val</strong></span>
      idprop['NormalAlign']= align.val</pre></div><p>The next screenshot shows how the input box for the vertex group may look:</p><div class="mediaobject"><img alt="Snap to vertices in a vertex group" src="graphics/0400-04-17.jpg"/></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Note that the script constraint also presents the user with a VG string input field that may refer to a vertex group, but this is different from the vertex group input field that we show the user in the <span class="strong"><strong>Options</strong></span> pop up. This VG field will alter the way the constraint looks at a target. If a valid vertex group is set here, the target matrix passed to <code class="literal">doConstraint()</code> will be that of the median position of the vertices in the vertex group.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we saw how different animated properties can be linked together and how we could constrain the spatial properties of objects to complex limitations. We have learned how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Drive one <span class="strong"><strong>IPO</strong></span> from another by a Python expression</li><li class="listitem" style="list-style-type: disc">Work around some limitations inherent in pydrivers</li><li class="listitem" style="list-style-type: disc">Restrict the motion of objects and bones by adding constraints</li><li class="listitem" style="list-style-type: disc">Write a constraint in Python that will snap an object to the closest vertex on another object</li></ul></div><p>Next we take a look at how to perform some action every time we advance a frame in our animation.</p></div></body></html>