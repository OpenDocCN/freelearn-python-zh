- en: Chapter 10. The Final Project – a Remote Home Monitoring System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 最终项目 – 一个远程家庭监控系统
- en: It is now time to combine every topic that we learned in the previous chapters
    into a project that combines Arduino programming, Python GUI development, MQTT
    messaging protocol, and a Python-based cloud application. As you might have already
    figured out from the chapter title, we are going to develop a remote home monitoring
    system using these components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们在前几章中学到的每个主题结合起来，创建一个结合Arduino编程、Python GUI开发、MQTT消息协议和基于Python的云应用的项目。正如你可能已经从章节标题中推测出的那样，我们将使用这些组件开发一个远程家庭监控系统。
- en: The first section of the chapter covers the project design process, including
    goals, requirements, architecture, and UX. Once we are done with the design process,
    we will jump into the actual development of the project, which is divided into
    three separate stages. Next, we will cover common troubleshooting topics that
    are usually faced while working with large projects. In our efforts to develop
    utilizable DIY projects, the later section covers tips and features to extend
    the project. As this is quite a large project compared to other projects in the
    book, we are not going to jump straight into the actual development process without
    having any strategy. Let's start by getting ourselves familiar with the standard
    design methodology for hardware projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分涵盖了项目设计过程，包括目标、需求、架构和UX。一旦我们完成设计过程，我们将进入项目的实际开发，这分为三个独立阶段。接下来，我们将涵盖在处理大型项目时通常会遇到的一些常见故障排除主题。在我们努力开发可用的DIY项目时，后面的部分涵盖了扩展项目的技巧和功能。由于与其他书籍中的项目相比，这是一个相当大的项目，我们不会在没有任何策略的情况下直接进入实际开发过程。让我们首先熟悉硬件项目的标准设计方法。
- en: The design methodology for IoT projects
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网项目的设计方法
- en: 'The process of developing a complex product that tightly couples hardware devices
    with high-level software services requires an additional level of planning. For
    this project, we will exercise a proper product development approach to help you
    get familiar with the process of creating real-world hardware projects. This method
    can then be used to plan your own projects and take them to the next level. The
    following diagram describes a typical prototype development process, which always
    begins by defining the major goals that you want to achieve with your product:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个将硬件设备与高级软件服务紧密耦合的复杂产品需要额外的规划层次。对于这个项目，我们将采用适当的产品开发方法，帮助你熟悉创建真实世界硬件项目的流程。然后，可以使用这种方法来规划你自己的项目并将它们提升到下一个层次。以下图表描述了一个典型的原型开发过程，它始终从定义你希望通过产品实现的主要目标开始：
- en: '![The design methodology for IoT projects](img/5938OS_10_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![物联网项目的设计方法](img/5938OS_10_01.jpg)'
- en: Once you have defined the set of major goals, you need to break them down into
    project requirements that include every detail of the tasks that your prototype
    should execute to achieve these goals. Using the project requirements, you need
    to sketch out the overall architecture of the system. The next step includes the
    process of defining the UX flow that will help you to lay out the user interaction
    points for your system. At this stage, you will be able to identify any changes
    that are required in the system architecture and the hardware and software components
    to start the development.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了主要目标集合，你需要将它们分解成项目需求，这些需求包括实现这些目标时原型应执行的每个任务的详细信息。使用项目需求，你需要勾勒出系统的整体架构。下一步包括定义UX流程的过程，这将帮助你规划系统的用户交互点。在这个阶段，你将能够识别系统架构、硬件和软件组件中所需的所有更改，以便开始开发。
- en: As you have defined the interaction points, now you need to distribute the entire
    project development process into multiple stages and delegate the tasks between
    these stages. Once you have completed the development of these stages, you will
    have to interface these stages with each other according to your architecture
    and debug the components if it is needed. At the end, you will have to test your
    project as a whole system and troubleshoot minor problems. In hardware projects,
    it is very difficult to work on your electric circuits again after the completion
    of complex development processes, as the changes can have recurring effects on
    all other components. This process will help you to minimize any hardware rework
    and subsequent software modifications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经定义了交互点，现在你需要将整个项目开发过程分成多个阶段，并在这些阶段之间分配任务。一旦你完成了这些阶段的发展，你将不得不根据你的架构将这些阶段相互连接，并在需要时调试组件。最后，你必须将你的项目作为一个整体系统进行测试，并解决小问题。在硬件项目中，在复杂开发过程完成后再次处理你的电线路是非常困难的，因为变化可能会对所有其他组件产生重复影响。这个过程将帮助你最小化任何硬件返工和随后的软件修改。
- en: Now that you have learned about the methodology, let's begin with the actual
    development process for our remote home monitoring system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了方法论，让我们开始实际开发我们的远程家庭监控系统。
- en: Project overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: The smart home is one of the most well-defined and popular subdomains of the
    IoT. The most important feature of any smart home is its capability to monitor
    the physical environment. Fortunately, the exercises and projects that we covered
    in the previous chapters include components and features that can be used for
    the same purpose. In this chapter, we are going to define a project that will
    utilize these existing components and programming exercises. In the midterm project
    of [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"),
    *The Midterm Project – a Portable DIY Thermostat*, we created a deployable thermostat
    with the ability to measure temperature, humidity, and ambient light. If we want
    to utilize this midterm project, the nearest IoT project that we can build on
    top of it is the remote home monitoring system. The project will have Arduino
    as the main point of interaction between the physical environment and the software-based
    services. We will have a Python program as the middle layer, which will bridge
    the sensor information coming from Arduino with the user-facing graphical interface.
    Let's start by defining the goals that we want to achieve and the project requirements
    to satisfy these goals.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 智能家居是物联网中最定义明确且最受欢迎的子领域之一。任何智能家居最重要的功能是其监控物理环境的能力。幸运的是，我们在前几章中涵盖的练习和项目包括可用于相同目的的组件和功能。在本章中，我们将定义一个将利用这些现有组件和编程练习的项目。在[第7章](ch07.html
    "第7章。中期项目 – 便携式DIY恒温器")的中期项目中，即“中期项目 – 便携式DIY恒温器”，我们创建了一个可部署的恒温器，能够测量温度、湿度和环境光线。如果我们想利用这个中期项目，我们可以在其基础上构建的最近的物联网项目是远程家庭监控系统。该项目将以Arduino作为物理环境和基于软件的服务之间的主要交互点。我们将有一个Python程序作为中间层，它将连接来自Arduino的传感器信息与面向用户的图形界面。让我们首先定义我们想要实现的目标以及满足这些目标的项目需求。
- en: The project goals
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目目标
- en: The Nest thermostat provides an idea of the type of features that a properly
    designed remote monitoring system with professional features should have. Achieving
    this level of system capabilities requires a lot of development effort from a
    large team. Although it will be difficult to include each of the features that
    are supported by a commercial system in our project, we will still try to implement
    the common features that can be incorporated by a prototype project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Nest恒温器提供了一个关于一个设计良好的远程监控系统应具备的特性的例子，该系统具有专业功能。实现这一级别的系统能力需要来自大型团队的大量开发工作。尽管很难在我们的项目中包含商业系统支持的每个功能，但我们仍将尝试实现原型项目可以整合的常见功能。
- en: The top-level features that we are planning to incorporate in this project can
    be described by the following goals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划在这个项目中整合的顶级功能可以通过以下目标来描述。
- en: Observe the physical environment and make it accessible remotely
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察物理环境并使其远程可访问
- en: Provide basic level controls to the user to interact with the system
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户提供基本级别的控制以与系统交互
- en: Demonstrate a primitive level of built-in situational awareness
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示基本的内置情境意识
- en: The project requirements
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目需求
- en: 'Now that we have defined the major goals, let''s convert them into detailed
    system requirements. On the completion of the project, the system should be able
    to satisfy the following requirements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了主要目标，让我们将它们转换为详细的系统需求。项目完成后，系统应能够满足以下要求：
- en: It must be able to observe physical phenomenon such as temperature, humidity,
    motion, and ambient light.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够观察物理现象，如温度、湿度、运动和周围光线。
- en: It should provide local access to sensor information and control over actuators
    such as a buzzer, a button switch, and an LED.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应提供对传感器信息和执行器（如蜂鸣器、按钮开关和LED）的本地访问和控制。
- en: The monitoring should be done by a unit that is developed using the open source
    hardware platform, Arduino.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控应由使用开源硬件平台Arduino开发的单元进行。
- en: The monitoring unit should be limited to collect sensor information and communicate
    it to the control unit.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控单元应限于收集传感器信息并将其传达给控制单元。
- en: The control unit should not comprise of a desktop computer or laptop. Instead,
    it should be made deployable using a platform such as a Raspberry Pi.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制单元不应包含台式计算机或笔记本电脑。相反，它应该使用像Raspberry Pi这样的平台来部署。
- en: The control unit should demonstrate a primitive level of situation awareness
    capability by utilizing the collected sensor information.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制单元应通过利用收集到的传感器信息展示原始级别的态势感知能力。
- en: The control unit should have a graphical interface to provide the sensor's observation
    and the current state of the system.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制单元应具有图形界面，以提供传感器的观察结果和系统的当前状态。
- en: The system must be accessible via the Internet using cloud-based services.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统必须通过基于云的服务通过互联网访问。
- en: The web application that provides remote access should have the capability to
    display the sensor's observations through a web browser.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供远程访问的Web应用程序应具有通过Web浏览器显示传感器观察结果的能力。
- en: The system should also provide basic control of the actuators to complete the
    remote access experience by using the web application.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统还应提供对执行器的基本控制，通过使用Web应用程序完成远程访问体验。
- en: As the monitoring unit can be constrained by computation resources, the system
    should use hardware-oriented messaging protocols to transfer information.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于监控单元可能受到计算资源的限制，系统应使用面向硬件的消息协议来传输信息。
- en: Although there are many other minor requirements that can be part of our project,
    they have been skipped in this book. If you have any additional plans for your
    remote home monitoring system, this is the time that you must define these requirements
    before you jump into designing the architecture. Any future changes to the requirements
    can significantly affect the development stage and make hardware and software
    modification difficult. In the last section of the chapter, we have laid down
    a number of additional features that you may want to consider implementing for
    your future projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管还有许多其他可能成为我们项目一部分的次要要求，但它们在这本书中被省略了。如果你对你的远程家庭监控系统有任何额外的计划，这是你必须在你开始设计架构之前定义这些要求的时候。对需求的任何未来更改都可能显著影响开发阶段，并使硬件和软件修改变得困难。在章节的最后部分，我们列出了一些你可能希望考虑实现于未来项目的附加功能。
- en: Designing system architecture
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计系统架构
- en: 'Continuing from project goals, first, you need to sketch out a high-level architecture
    of the system. This architectural sketch should include major components that
    enable the system to pass on information between the sensors and the remote users.
    The following figure shows an architectural sketch for our project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目目标继续，首先，你需要绘制出系统的概要架构。这个架构草图应包括使系统能够在传感器和远程用户之间传递信息的主要组件。以下图显示了我们的项目架构草图：
- en: '![Designing system architecture](img/5938OS_10_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![设计系统架构](img/5938OS_10_02.jpg)'
- en: According to the goals, the user should be able to access the system using the
    Internet; this means that we need cloud components in the architecture. The system
    also needs to monitor the physical environment using a resource-constrained device,
    and this can be executed using Arduino. The middle layer, which connects the cloud
    service and the sensor system, can be built using a Raspberry Pi. In the last
    project, we connected Arduino and the Raspberry Pi using a serial connection,
    but we want to move away from serial connections and start using our home's Ethernet
    network to make the system deployable. Hence, the Arduino-based unit is connected
    to the network using Ethernet while the Raspberry Pi uses Wi-Fi to connect to
    the same network.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据目标，用户应能够通过互联网访问系统；这意味着我们需要在架构中包含云组件。系统还需要使用资源受限的设备来监控物理环境，这可以使用Arduino实现。连接云服务和传感器系统的中间层可以使用Raspberry
    Pi构建。在上一个项目中，我们通过串行连接连接了Arduino和Raspberry Pi，但我们希望摆脱串行连接，开始使用我们家的以太网网络来使系统可部署。因此，基于Arduino的单元通过以太网连接到网络，而Raspberry
    Pi则使用Wi-Fi连接到同一网络。
- en: 'In order to lay out the overall system architecture, let''s utilize the sketch
    that we designed, which can be seen in the preceding figure. As you can see in
    the next figure, we have converted the overall system into three main architectural
    units:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了布局整体系统架构，让我们利用我们设计的草图，如图所示。正如您在下一张图中可以看到的，我们将整体系统转换成了三个主要架构单元：
- en: Monitoring station
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控站
- en: Control center
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制中心
- en: Cloud service
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务
- en: In this figure, we have addressed each and every major component that we are
    going to utilize in the project along with their association to each other. In
    the following sections, we are going to define these three main units briefly.
    The comprehensive description and implementation steps for these units are provided
    later in the chapter under separate sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们已经针对我们将要利用的每个主要组件及其相互关联进行了说明。在接下来的章节中，我们将简要定义这三个主要单元。这些单元的详细描述和实现步骤将在本章的单独部分提供。
- en: '![Designing system architecture](img/5938OS_10_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![设计系统架构](img/5938OS_10_03.jpg)'
- en: The monitoring station
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控站
- en: We need a resource-constrained and robust unit that will communicate with the
    physical environment periodically. This monitoring unit can be built using Arduino
    since low-level microcontroller programming can provide uninterrupted stream of
    sensor data. The usage of Arduino at this stage will also help us to avoid the
    direct interfacing of basic low-level sensors with computers that are running
    on complex operating systems. The sensors and the actuators are connected to Arduino
    using digital, analog, PWM, and I2C interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个资源受限且健壮的单元，该单元将定期与物理环境进行通信。这个监控单元可以使用Arduino构建，因为低级微控制器编程可以提供不间断的传感器数据流。在这个阶段使用Arduino也将帮助我们避免将基本低级传感器直接与运行在复杂操作系统上的计算机进行接口连接。传感器和执行器通过数字、模拟、PWM和I2C接口连接到Arduino。
- en: The control center
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制中心
- en: The control center behaves as the main user interaction point between the sensor
    information and the user. It is also responsible for conveying the sensor information
    from the monitoring station to the cloud services. The control center can be developed
    using your regular computer or a single-board computer such as a Raspberry Pi.
    We are going to utilize a Raspberry Pi since it can be easily deployed as a hardware
    unit and it is also capable enough at hosting Python programs. We will replace
    a computer screen with a small TFT LCD screen for the Raspberry Pi to display
    the GUI.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 控制中心作为传感器信息和用户之间的主要交互点。它还负责将监控站中的传感器信息传递到云服务。控制中心可以使用您的普通计算机或单板计算机（如Raspberry
    Pi）开发。我们将使用Raspberry Pi，因为它可以轻松部署为硬件单元，并且它也足以托管Python程序。我们将用一个小型TFT LCD屏幕替换Raspberry
    Pi的计算机屏幕来显示GUI。
- en: The cloud services
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云服务
- en: The main purpose of the cloud services is to provide an Internet-based interface
    for the control center so that the user can access it remotely. Before we host
    a web application to perform this operation, we will need an intermediate data
    relay. This sensor data relay works as a host between the cloud-based web application
    and the control center. In this project, we will be using Xively as the platform
    to collect this sensor data. The web application can be hosted on an Internet
    server; in our case, we are going to use Amazon AWS due to our familiarity with
    it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务的主要目的是为控制中心提供一个基于互联网的接口，以便用户可以远程访问它。在我们托管一个网络应用程序来执行此操作之前，我们需要一个中间数据中继。这个传感器数据中继充当基于云的网络应用程序和控制中心之间的主机。在这个项目中，我们将使用Xively作为平台来收集这些传感器数据。网络应用程序可以托管在互联网服务器上；在我们的情况下，我们将使用我们熟悉的Amazon
    AWS。
- en: Defining UX flow
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义UX流程
- en: Now, although we know what the architecture of the overall system looks like,
    we haven't defined how the user is going to interact with it. This process of
    designing user interaction for our system will also help us to figure out data
    flow between major components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管我们知道整个系统的架构看起来是什么样子，但我们还没有定义用户将如何与之交互。为我们的系统设计用户交互的过程也将帮助我们弄清楚主要组件之间的数据流。
- en: Let's begin with the components that are operating locally at your house, that
    is, the monitoring station and the control center. As you can see from the following
    figure, we have our first user interaction point at the control center. The user
    can observe the information or act upon it if the system's status is an alert.
    The user action to dismiss the alert prompts multiple operations to take place
    at the control center and the monitoring station. We recommend you thoroughly
    examine the figure to better understand the flow of the system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从您家中本地运行的组件开始，即监测站和控制中心。如图所示，我们在控制中心有我们的第一个用户交互点。用户可以观察信息或对其采取行动，如果系统状态是警报。取消警报的用户操作会在控制中心和监测站引发多个操作。我们建议您仔细查看图表，以更好地理解系统的流程。
- en: '![Defining UX flow](img/5938OS_10_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![定义UX流程](img/5938OS_10_04.jpg)'
- en: 'Similarly, the second user interaction point is located at the web application.
    The web application displays the observations and system''s status that we calculated
    at the control center and provides an interface to dismiss the alert. In this
    scenario, the dismiss action will travel through Xively to the control center
    where the appropriate actions for the control center will remain the same as in
    the previous scenario. However, in the web application, the user has to load the
    web browser every time to request the data, which was happening automatically
    at the control center. Take a look at the following figure to understand the UX
    flow for the web application:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，第二个用户交互点位于网络应用程序中。网络应用程序显示我们在控制中心计算出的观察结果和系统状态，并提供一个界面来取消警报。在这种情况下，取消操作将通过Xively传输到控制中心，控制中心的适当操作将与之前的情况相同。然而，在网络应用程序中，用户每次都必须加载网络浏览器来请求数据，而这在控制中心是自动发生的。请查看以下图表以了解网络应用程序的用户体验流程：
- en: '![Defining UX flow](img/5938OS_10_05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![定义UX流程](img/5938OS_10_05.jpg)'
- en: The list of required components
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所需组件列表
- en: 'The necessary components for the project are derived using three main criteria:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 项目所需组件是根据以下三个主要标准推导出来的：
- en: Ease of availability
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于获取
- en: Compatibility with the Arduino board
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Arduino板兼容
- en: Familiarity with the components due to previous utilization in this book
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在此书中之前的使用而熟悉组件
- en: This is the list of the components that you will need to start working on the
    project. If you have completed the previous exercises and projects, you should
    already have most of the components. If you don't want to disassemble the projects,
    you can obtain them from the websites of SparkFun, Adafruit, or Amazon, whose
    links are provide in the next table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您开始项目所需的组件列表。如果您已经完成了之前的练习和项目，您应该已经拥有了大部分组件。如果您不想拆解项目，您可以从SparkFun、Adafruit或Amazon的网站上获取它们，这些网站的链接将在下一表中提供。
- en: 'The hardware components for the monitoring station are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 监测站点的硬件组件如下：
- en: '| Component (first stage) | Quantity | Link |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 组件（第一阶段） | 数量 | 链接 |'
- en: '| --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Arduino Uno | 1 | [https://www.sparkfun.com/products/11021](https://www.sparkfun.com/products/11021)
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Arduino Uno | 1 | [https://www.sparkfun.com/products/11021](https://www.sparkfun.com/products/11021)
    |'
- en: '| Arduino Ethernet Shield | 1 | [https://www.sparkfun.com/products/9026](https://www.sparkfun.com/products/9026)
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| Breadboard | 1 | [https://www.sparkfun.com/products/9567](https://www.sparkfun.com/products/9567)
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| TMP102 temperature sensor | 1 | [https://www.sparkfun.com/products/11931](https://www.sparkfun.com/products/11931)
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| HIH-4030 humidity sensor | 1 | [https://www.sparkfun.com/products/9569](https://www.sparkfun.com/products/9569)
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| Mini photocell | 1 | [https://www.sparkfun.com/products/9088](https://www.sparkfun.com/products/9088)
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| PIR motion sensor | 1 | [https://www.sparkfun.com/products/8630](https://www.sparkfun.com/products/8630)
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| Super-flux RGB LED, common anode | 1 | [http://www.adafruit.com/product/314](http://www.adafruit.com/product/314)
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| Buzzer | 1 | [http://www.adafruit.com/products/160](http://www.adafruit.com/products/160)
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| Push button switch | 1 | [https://www.sparkfun.com/products/97](https://www.sparkfun.com/products/97)
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| USB cable for Arduino(for development stage) | 1 | [https://www.sparkfun.com/products/512](https://www.sparkfun.com/products/512)
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| Arduino power supply(for deployment stage) | 1 | [http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/](http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/)
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| Resistors | As required | 220 ohm, 1 kilo-ohm, and 10 kilo-ohm |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| Connection wires | As required |   |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: 'The hardware components for the control center are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '| Component (first stage) | Quantity | Link |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi | 1 | [https://www.sparkfun.com/products/11546](https://www.sparkfun.com/products/11546)
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| TFT LCD screen | 1 | [http://www.amazon.com/gp/product/B00GASHVDU/](http://www.amazon.com/gp/product/B00GASHVDU/)
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| SD card (8 GB) | 1 | [https://www.sparkfun.com/products/12998](https://www.sparkfun.com/products/12998)
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| Wi-Fi dongle | 1 | [http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY](http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY)
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi power supply | 1 | [http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0](http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0)
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| Keyboard, mouse, USB hub, and monitor | As required | Requried for development
    and debugging stages |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: Defining the project development stages
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As per the system architecture, we have three main units that collaboratively
    create the remote home monitoring project. The overall hardware and software development
    process is also aligned with these three units and can be distributed as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring station development stage
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control center development stage
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web application development stage
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The software development for the monitoring station stage includes developing
    the Arduino code to monitor sensors and perform actuator actions on one side,
    while publishing this information to the control center on the other side. The
    middle layer of the development stage, that is, the Raspberry Pi-based control
    center, hosts the Mosquitto broker. This stage also contains the Python program
    that contains the GUI, situation awareness logic, and subroutines to communicate
    with the Xively cloud service. The last stage, the cloud services, includes two
    distinct components, sensor data relay and a web application. We will be using
    the Xively platform as our sensor data relay and the web application will be developed
    in Python on the Amazon AWS cloud instance. Now, let's jump into the actual development
    process and our first stop will be the Arduino-based monitoring station.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 监控站阶段的软件开发包括编写Arduino代码以监控传感器并执行执行器动作，同时将此信息发布到控制中心。开发阶段的中间层，即基于Raspberry Pi的控制中心，托管了Mosquitto代理。此阶段还包括包含GUI、态势感知逻辑和与Xively云服务通信的子例程的Python程序。最后阶段，云服务，包括两个不同的组件，传感器数据中继和Web应用程序。我们将使用Xively平台作为我们的传感器数据中继，并将使用Python在Amazon
    AWS云实例上开发Web应用程序。现在，让我们进入实际的开发过程，我们的第一个目的地将是基于Arduino的监控站。
- en: Stage 1 – a monitoring station using Arduino
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1阶段 - 使用Arduino的监控站
- en: As we discussed, the main tasks of the monitoring systems are to interface sensor
    components and communicate the information generated by these sensors to the observers.
    You will be using Arduino Uno as the central microcontroller component to integrate
    these sensors and actuators. We also need a means of communication between the
    Arduino Uno and the control center and we will be utilizing the Arduino Ethernet
    Shield for this purpose. Let's discuss the hardware architecture of the monitoring
    station and its components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，监控系统的主要任务是接口传感器组件并将这些传感器生成的信息传达给观察者。你将使用Arduino Uno作为中央微控制器组件来集成这些传感器和执行器。我们还需要Arduino
    Uno和控制中心之间的通信手段，我们将利用Arduino以太网盾来实现这一目的。让我们讨论监控站的硬件架构及其组件。
- en: Designing the monitoring station
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计监控站
- en: We already designed units based on Arduino and the Ethernet Shield in various
    exercises in [Chapter 8](ch08.html "Chapter 8. Introduction to Arduino Networking"),
    *Introduction to Arduino Networking*, and [Chapter 9](ch09.html "Chapter 9. Arduino
    and the Internet of Things"), *Arduino and the Internet of Things*. Therefore,
    we have assumed that you are familiar with interfacing the Ethernet Shield with
    the Arduino board. We will connect various sensors and actuators with the Arduino
    board, as displayed in the following diagram. As you can see in this diagram,
    the sensors will provide the data to the Arduino board while the actuators will
    seek the data from the Arduino board. Although we are automatically collecting
    environment data for these sensors, the data from the button will be collected
    from manual user inputs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第8章](ch08.html "第8章。Arduino网络介绍")“Arduino网络介绍”和[第9章](ch09.html "第9章。Arduino与物联网")“Arduino与物联网”的各种练习中设计了基于Arduino和以太网盾的单元。因此，我们假设你已经熟悉将以太网盾与Arduino板进行接口。我们将使用Arduino板连接各种传感器和执行器，如下面的图所示。如图所示，传感器将向Arduino板提供数据，而执行器将从Arduino板获取数据。尽管我们自动收集这些传感器的环境数据，但按钮的数据将通过手动用户输入进行收集。
- en: '![Designing the monitoring station](img/5938OS_10_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![设计监控站](img/5938OS_10_06.jpg)'
- en: Check out the following Fritzing diagram for the detailed connections in the
    monitoring station. As you can see in our hardware design, the temperature sensor
    TMP102 is connected through the I2C interface, which means that we will need the
    SDA and SCL lines. We will be using analog pins 5 and 6 of the Arduino board to
    interface SDA and SCL respectively. The humidity (HIH-4030) and ambient light
    sensors also provide analog output and are connected to the analog pins of the
    Arduino board. Meanwhile, the buzzer, the button switch, and the PIR motion sensor
    are connected through the digital I/O pins. The super-flux RGB LED is a common
    anode LED; this means that it is always powered using the common anode pins and
    the R, G, and B pins are controlled by using the PWM pins.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下Fritzing图以了解监控站中的详细连接。正如你在我们的硬件设计中看到的那样，温度传感器TMP102通过I2C接口连接，这意味着我们需要SDA和SCL线。我们将使用Arduino板的模拟引脚5和6来分别接口SDA和SCL。湿度（HIH-4030）和环境光传感器也提供模拟输出，并连接到Arduino板的模拟引脚。同时，蜂鸣器、按钮开关和PIR运动传感器通过数字I/O引脚连接。超级流明RGB
    LED是正极LED；这意味着它总是使用正极引脚供电，而R、G和B引脚通过PWM引脚控制。
- en: 'Make sure that you properly connect all the components to the pins that are
    specified in the following diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你将所有组件正确连接到以下图中指定的引脚：
- en: '![Designing the monitoring station](img/5938OS_10_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![设计监控站](img/5938OS_10_07.jpg)'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about the interfacing of RGB LED with Arduino from the tutorial
    at [https://learn.adafruit.com/all-about-leds](https://learn.adafruit.com/all-about-leds).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://learn.adafruit.com/all-about-leds](https://learn.adafruit.com/all-about-leds)教程中了解更多关于RGB
    LED与Arduino接口的信息。
- en: If you are using an Arduino board other than Arduino Uno, you will have to adjust
    the appropriate pin numbers in the Arduino code. In addition, make sure that this
    Arduino board is compatible with the Ethernet Shield.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是除Arduino Uno以外的Arduino板，你将不得不在Arduino代码中调整适当的引脚编号。此外，确保这个Arduino板与以太网盾兼容。
- en: In terms of circuit connections, you can use a breadboard as shown in the previous
    diagram, or if you are comfortable, you can use a PCB prototype board and solder
    the components. In our setup, we first tested the components on the breadboard
    and once they were tested, we soldered the components, as shown in the following
    figure. If you venture to solder the PCB board, make sure that you have the necessary
    components for the job. The PCB prototype will yield a robust performance compared
    to the breadboard, but it will also make it difficult for you to debug and change
    the components afterwards.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在电路连接方面，你可以使用前面图中所示的面包板，或者如果你感到舒适，你可以使用PCB原型板并焊接组件。在我们的设置中，我们首先在面包板上测试了组件，一旦测试通过，我们就焊接了组件，如图所示。如果你尝试焊接PCB板，请确保你有完成这项工作的必要组件。与面包板相比，PCB原型板将提供更坚固的性能，但这也将使你在之后调试和更换组件变得困难。
- en: '![Designing the monitoring station](img/5938OS_10_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![设计监控站](img/5938OS_10_08.jpg)'
- en: If you are ready with your circuit connection, connect your Arduino to your
    computer using the USB cable. Also, connect the Ethernet Shield to your home router
    using an Ethernet cable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经准备好了电路连接，请使用USB线将Arduino连接到你的电脑。同时，使用以太网线将以太网盾连接到你的家庭路由器。
- en: The Arduino sketch for the monitoring station
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控站的Arduino草图
- en: Before jumping into the coding stage, make sure that you have collected the
    prebuilt Arduino code for the project. You can find it in the code folder of this
    chapter with the filename `Arduino_monitoring_station.ino`. The code implements
    the necessary logic to support the overall UX flow at the monitoring station,
    which we discussed in the previous section. In the following sections, we will
    go through the major areas of the program so that you can better understand these
    code snippets. Now, open this sketch in the Arduino IDE. You are already familiar
    with setting up the IP address for Arduino. You also learned how to use the Arduino
    MQTT library `PubSubClient` in the previous chapter, which means that your Arduino
    IDE should already have the `PubSubClient` library installed on it. At the beginning
    of the code, we have also declared few constants, such as the IP addresses of
    the MQTT server and Arduino and the pin numbers of various sensor and actuators.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will have to change the IP address of the monitoring station and the control
    center according to your network setup. Make sure that you perform these modifications
    before uploading the Arduino code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In the code structure, we have two mandatory Arduino functions, `setup()` and
    `loop()`. In the `setup()` function, we will set up the Arduino pin types and
    the MQTT subscriber channels. In the same function, we will also attach an interrupt
    for the press of the button while setting up the timer for the `publishData()`
    function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Publishing sensor information
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `publishData()` function reads the sensor inputs and publishes this data
    to the Mosquitto broker that is located on the control center. As you can see
    in the following code snippet, we are measuring sensors values one by one and
    publishing them to the broker using the `client.publish()` method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you check out the `setup()` function, you will notice that we have used
    a library called `SimpleTimer` to set up a `timer` method for this function. This
    method executes the `publishData()` function periodically without interrupting
    and blocking the actual flow of the Arduino execution cycle. In the following
    code snippet, the number `300000` represents the time delay in milliseconds, that
    is, 5 minutes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to download and import the `SimpleTimer` library to compile and
    run the code successfully. You can download the library from [https://github.com/infomaniac50/SimpleTimer](https://github.com/infomaniac50/SimpleTimer).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to actuator actions
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can see in the `setup()` function that we are initializing the code by
    subscribing to the `MonitoringStation/led` and `MonitoringStation/buzzer` channels.
    The `client.subscribe()` method will make sure that whenever the Mosquitto broker
    gets any updates for these channels, the Arduino-based monitoring system gets
    notified:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Programming an interrupt to handle the press of a button
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have taken care of the publishing and subscribing functions of the monitoring
    station. Now, we will need to integrate the button switch that is controlled by
    inputs from the user. In the Arduino programming routines, we run a periodic loop
    to check the status of the pins. However, this may not be useful if the button
    is pressed since it requires immediate action. This action of pressing the button
    is handled using the Arduino interrupts, as shown in the following line of code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding line of code associates an interrupt at pin 0 (digital pin 2)
    with the `buttonPress()` function. This function sets off the buzzers whenever
    the state of the interrupt is changed. In other words, when the button is pressed
    by the user, the buzzer will be instantaneously turned off irrespective of the
    current status of the buzzer:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Testing
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current Arduino code communicates with the control center for publishing
    and subscribing the data, but we haven't yet set up the Mosquitto broker to handle
    these requests. You can still go ahead and upload the Arduino sketch to your monitoring
    station using the USB cable. This will not result in any fruitful actions from
    the monitoring station and you will only be able to use the `Serial.prinln()`
    command to print various sensor measurements. Therefore, we will develop the control
    center next so that we can start addressing communication requests from the monitoring
    station.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Stage 2 – a control center using Python and the Raspberry Pi
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to deliver the status of the system and other sensor observations to
    the user, the control center needs to perform various operations that include
    obtaining raw sensor data from the monitoring station, calculating the status
    of the system, reporting this data to the cloud services, and displaying observation
    using GUI. While the control center includes two major hardware components (the
    Raspberry Pi and TFT LCD screen), it is also comprised of two major software components
    (the Mosquitto broker and Python code) to handle the control center logic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using a Raspberry Pi instead of a regular computer as we want the control
    center to be a deployable and portable unit that can be mounted on a wall.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: You can still use your own computer to edit and test the Python code for development
    purposes instead of using a Raspberry Pi directly. However, we recommend that
    you switch back to the Raspberry Pi once you are ready for deployment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The control center architecture
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Raspberry Pi is the main computation unit of the control center and works
    as the brain of the entire system. Since the Raspberry Pi is used as a replacement
    for a regular computer, the architecture of the control center can interchangeably
    use a computer in place of the Raspberry Pi. As you can see in the following diagram,
    the control center is connected to the home network using Wi-Fi and this will
    make it accessible to the monitoring station. The control center includes the
    Mosquitto broker; this is used as the communication point between the monitoring
    station and the Python program for the control center. The Python program utilizes
    the `Tkinter` library for GUI and the `paho_mqtt` library to communicate with
    the Mosquitto broker. By utilizing these two libraries, we can convey sensor information
    from the monitoring station to the user. However, we will need a separate arrangement
    to establish communication between the control center and cloud services. In our
    overall system architecture, the control center is designed to communicate with
    the intermediate data relay, Xively. The Python code uses the `xively-python`
    library to enable this communication.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![The control center architecture](img/5938OS_10_09.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 8](ch08.html "Chapter 8. Introduction to Arduino Networking"), *Introduction
    to Arduino Networking*, we already provided you with methods to install the Mosquitto
    broker, the `Python-mosquitto` library, and the `xively-python` library. We also
    learned the process of setting up the TFT LCD screen with the Raspberry Pi in
    [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"),
    *The Midterm Project – a Portable DIY Thermostat*. Please refer to those tutorials
    in case you haven't completed those exercises yet. Assuming that you have configured
    the Mosquitto broker and the required Python libraries, you can move on to the
    next section, which includes the actual Python programming.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The Python code for the control center
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start interfacing these libraries in the Python code, start your
    Mosquitto broker first from the command line using this simple command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure that you restart your monitoring station every time you start or restart
    the Mosquitto broker. This action will make sure that your monitoring station
    is connected to the Mosquitto broker, since the process of establishing the connection
    only gets executed once in our Arduino code, that is, at the beginning of the
    setup process.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for the current project is located in the code folder of this
    chapter with the name `controlCenter.py`. Open this file using your Python IDE
    and modify the values of the appropriate parameters before executing it. These
    parameters include the IP address of the Mosquitto broker along with the feed
    ID and the API key of the Xively virtual device. You should already have the feed
    ID and the API key of your Xively virtual device from the previous chapter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are using a local instance of the Mosquitto broker, you can replace the
    IP address with `127.0.0.1`. Otherwise, replace the `10.0.0.18` address with the
    appropriate IP address of the computer that is hosting the Mosquitto broker. Let's
    try to understand the code now.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes on Mac OS X, you won't be able to run `Tkinter` window and Python
    threads in parallel due to an unknown bug. You should be able to execute the program
    successfully in Windows and Linux environments. This program has been tested with
    the Raspberry Pi, which means you won't encounter the same bug while deploying
    the control center.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Creating the GUI using Tkinter
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous exercises, we always used a single Python thread to run the
    program. This practice will not help us to perform multiple tasks in parallel
    such as obtaining sensor observation from the monitoring station and simultaneously
    updating the GUI with that information. As a solution, we have introduced multithreading
    in this exercise. As we need two separate loops, one each for `Tkinter` and `paho-mqtt`,
    we will be running them independently in separate threads. The main thread will
    run methods that are related to Mosquitto and the cloud services, while the second
    thread will handle the `Tkinter` GUI. In the following code snippet, you can see
    that we have initialized the `controlCenterWindow()` class with the `threading.thread`
    parameter. Therefore, when we execute `window = controlCenterWindow()` in the
    main program, it will create another thread for this class. Basically, this class
    creates the GUI window while populating labels and other GUI components. The labels
    need to be updated when new sensor observations arrive, are declared as class
    variables, and are accessible from the class instant. As you can see in the following
    code snippet, we have declared the labels for temperature, humidity, light, and
    motion as class variables:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous code snippet doesn't contain the portion where we declared the
    `Tkinter` components, as it is similar to what we coded in the midterm project.
    If you have questions regarding Tkinter-related issues, please refer to [Chapter
    6](ch06.html "Chapter 6. Storing and Plotting Arduino Data"), *Storing and Plotting
    Arduino Data*, and [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable
    DIY Thermostat"), *The Midterm Project – a Portable DIY Thermostat*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the Mosquitto broker
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the control center level, we subscribe to topics that are published from
    the monitoring station, that is, `MonitoringStation/temperature`, `MonitoringStation/humidity`,
    and so on. If you have performed any modification to the Arduino code to change
    the MQTT topics, you need to reflect those changes in this section. If the topics
    published by the monitoring station do not match the topics in the control center''s
    code, you will not get any updates. As you can see in the Python code, we are
    associating the `on_message` and `on_publish` methods with very important function.
    Whenever a message arrives from the subscriber, the client will call the functions
    associated with the `on_message` method. However, every time a message gets published
    from the Python code, the `onPublish()` function will get called:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Calculating the system's status and situation awareness
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The control center is assigned with the task of calculating the status of the
    overall system. The control center calculates the status of the system as `Alert`,
    `Caution`, or `Normal` using the current values of temperature and humidity. To
    calculate the status, the control center executes the `calculateStatus()` function
    every time it gets an update for the temperature or humidity from the monitoring
    station. According to the current situation awareness logic, if the temperature
    is measured above 45 degree Celsius or below 5 degree Celsius, we call the system''s
    status as `Alert`. Similarly, you can identify the range of temperature and humidity
    values for `Caution` and `Normal` statuses from the following code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Communicating with Xively
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The control center is also required to communicate with Xively when it receives
    a message from the subscribed topics. We are already familiar with the process
    of setting up virtual devices and data streams on Xively. Open your Xively account
    and create a virtual device called `ControlCenter`. Note down the feed ID and
    API key for this device and replace them in the current code. Once you have these
    values, create the `Temperature`, `Humidity`, `Light`, `Motion`, `Buzzer`, and
    `Status` channels in this virtual device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the Python code, you can see that we have declared the individual
    data stream for each topic and associated them with the appropriate Xively channel.
    The following code snippet shows the data stream for just the temperature observation,
    but the code also contains a similar configuration for all the other sensor observations:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the control center receives a message from the monitoring station, it
    updates the data stream with the latest values and pushes these changes to Xively.
    At the same time, we will also update the appropriate label in the `Tkinter` GUI
    using the `onMessage()` function. We will use the same code snippet for all the
    subscribed channels:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The control center also implements the function to set the system''s status
    across the system, once it is calculated using the `calculateStatus()` function.
    There are three different functions to perform this task using a method that is
    similar to what we described in the previous code snippet. These functions include
    `setAlert()`, `setCaution()`, and `setNormal()` and these are associated with
    `Alert`, `Caution`, and `Normal` respectively. While updating the system''s status,
    these functions also perform buzzer and LED actions by publishing the LED and
    buzzer values to the Mosquitto broker:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Checking and updating the buzzer's status
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the control center, we set the buzzer's status to `ON` if the system's status
    is determined as `Alert`. If you look back at the UX flow, you will notice that
    we also want to include a feature for the user to manually turn off the buzzer.
    The `checkBuzzerFromXively()` function keeps track of the buzzer's status from
    Xively and if the user manually turns off the buzzer using the web application,
    this function sets off the buzzer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue this process independently from the GUI and situation awareness
    threads, we will need to create another thread for this function. The timer on
    this thread will automatically execute the function every 30 seconds:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this function running in a separate thread every 30 seconds, the control
    center will check the status of the Xively channel and stop the buzzer if the
    status is set to `OFF`. We will explain how the user can update the Xively channel
    for the buzzer in the next section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Testing the control center with the monitoring station
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming your Mosquitto broker is running, execute the `controlCenter.py` code
    with the changed parameters. Then, start the monitoring station. After a few moments,
    you will see on the terminal that the control center has already started getting
    messages from the publishers that are initialized on the monitoring station. The
    update interval for the messages from the publisher at the control center depends
    upon the configured publishing interval at the monitoring station.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino code executes the process of connecting to the Mosquitto broker
    only once after powering on. If you start your Mosquitto broker after that, it
    won't be able to communicate with the broker. So, you need to make sure that you
    start the Mosquitto broker before powering on the monitoring station.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: If you need to restart the Mosquitto broker for any reason, remove and restart
    the monitoring station first.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the control center with the monitoring station](img/5938OS_10_10.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'On execution of the program, you will be able to see a small GUI window, as
    shown in the following screenshot. This window displays the sensor''s values for
    temperature, humidity, ambient light, and motion. Along with these values, the
    GUI also displays the status of the system, which is **Normal** in this screenshot.
    You can also observe that every time the control center gets updates from the
    monitoring station, the system''s status and sensor observations change in real
    time:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the control center with the monitoring station](img/5938OS_10_11.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: If this setup is working correctly on your computer, let's move on to deploy
    the control center on the Raspberry Pi.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the control center on the Raspberry Pi
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of installing the Raspbian operating system is explained in [Chapter
    7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"), *The
    Midterm Project – a Portable DIY Thermostat*. You can use the same module that
    you used in the Midterm project or set up a new one. Once you have installed Raspbian
    and configured the TFT screen, connect the Wi-Fi dongle through a USB port. At
    this stage, we assume that your Raspberry Pi is connected with a monitor, a keyboard,
    and a mouse to perform the basic changes. Although we won''t recommend it, you
    can also use the TFT screen for the following operations, if you are comfortable
    with it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your Raspberry Pi and log in. At the command prompt, execute the following
    command to enter the visual desktop mode:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once your graphical desktop starts, you will be able to see the icon of the
    **WiFi config** utility. Double-click on this icon and open the **WiFi config**
    utility. Scan for wireless networks and connect to the Wi-Fi network that has
    the monitoring station. When asked, enter the password of your network in the
    form window called **PSK**, and connect to your network.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, your Raspberry Pi is connected to the local home network and to the Internet
    through it. It''s time to update the existing packages and install the required
    ones. To update the Raspberry Pi''s existing system, execute the following commands
    in the terminal:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once your system is updated with the latest version, it''s time to install
    the Mosquitto broker on your Raspberry Pi. The Raspbian OS has Mosquitto in the
    default repository, but it doesn''t have the current version that we need. To
    install the latest version of Mosquitto, execute following commands in the terminal:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To install other Python dependencies, let''s first install the Setuptools package
    using `apt-get`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using Setuptools, we can now install all the required Python libraries such
    as `paho_mqtt`, `xively-python`, and `web.py`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have installed all the necessary software tools that are required
    to run our control center on the Raspberry Pi, it is time to configure the Raspberry
    Pi so that it can provide uninterrupted operation for a critical system such as
    a remote home monitoring system:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current configuration of the Raspberry Pi, the screen of the Raspberry
    Pi will go to sleep after some time and the Wi-Fi connection will be terminated
    when this happens. To avoid this problem and force the screen to remain active,
    you will need to perform the following changes. Open the `lightdm.conf` file using
    the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the file, navigate to the `SetDefaults` section and edit the following line:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that your Raspberry Pi is set up, it is time to copy the program file from
    your computer to the Raspberry Pi. You can use SCP, PuTTY, or just a USB drive
    to transfer the necessary file to the Raspberry Pi.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you install and configure everything as specified, your program should run
    without any errors. You can run the Python program constantly in the background
    using the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The last thing that we want to set up on the Raspberry Pi is the TFT LCD screen.
    The installation and configuration processes of the TFT LCD screen are described
    in [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"),
    *The Midterm Project – a Portable DIY Thermostat*. Please follow the steps in
    the given order to set up the screen. The control center module along with the
    Raspberry Pi and the TFT screen can now be deployed in any part of your house.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Stage 3 – a web application using Xively, Python, and Amazon cloud service
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cloud services module of the overall system enables remote access to your
    monitoring station through the Internet. The unit interacts with the user via
    a web application as an extended version of the control center. With the use of
    this web application, the user can observe the sensor information from the monitoring
    station and the system's status calculated by the control center while having
    remote control to turn off the buzzer. So, what does the architecture of the cloud
    services look like?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of the cloud services
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The architecture of the cloud services module with its associated components
    is displayed in the following diagram. In the cloud services architecture, we
    are using Xively as the intermediate data relay between the web application and
    the control center. The control center pushes the observations obtained from the
    monitoring station to the Xively channels. Xively stores and relays the data to
    the web application that is hosted on the Amazon AWS. The server instance on the
    Amazon AWS is used to make the web application accessible through the Internet.
    The server instance runs the Ubuntu operating system and the web application that
    is developed using the `web.py` library in Python.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture of the cloud services](img/5938OS_10_12.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: In the previous stage, we already covered the process of setting up Xively and
    the channels to accommodate sensor data. In the control center code, we also explained
    how we can push the updated observations to the appropriate Xively channels. Therefore,
    we really do not have any ground to cover for the Xively platform at this stage
    and we can move on to the web application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Python web application hosted on Amazon AWS
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we set up an Amazon AWS cloud instance to host a web
    application. You can use the same instance to host the web application for the
    remote home monitoring system too. However, make sure that you have installed
    the `web.py` library on your server.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: In your computer, open the `Web_Application` folder and then the `RemoteMonitoringApplication.py`
    file in your editor.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the code, you will be able to see that we just expand the web application
    program that we created in [Chapter 9](ch09.html "Chapter 9. Arduino and the Internet
    of Things"), *Arduino and the Internet of Things*. We use the templates based
    on `web.py` and the `GET()` and `POST()` functions to enable the web application.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the application, we fetch information from each Xively channel and process
    it via a separate function. For example, the `fetchTempXively()` function obtains
    the temperature information from Xively. Every time the `POST()` function is executed,
    the `fetchTempXively()` function fetches the latest value of temperature reading
    from Xively. This also means that the web application does not populate and refresh
    the latest information automatically and waits for `POST()` to execute the appropriate
    functions:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The web application also provides access to control the buzzer from the user
    interface. The following code snippet adds the **Buzzer Off** button with other
    `Form` components. When the form is submitted after this button is pressed, the
    web application executes the `setBuzzer()` function:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `setBuzzer()` function access the Xively channel, `Buzzer`, and sends the
    off value if the **Buzzer Off** button is pressed. The current web application
    doesn''t include the **Buzzer On** button, but you can easily implement this functionality
    by reusing the code that we developed for the **Buzzer Off** button. This function
    provides the reference code for other control points, which you can reuse with
    minor modifications:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the code, you will also have to modify the Xively feed ID and the API key
    and replace them with the values that your obtained from your virtual device.
    Once you have performed this modification, run the following command. If everything
    goes as planned, you will be able to open the web application in your web browser.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you are running the Python code on your computer, you can open `http://127.0.0.1:8080`
    to access the application. If you are running the application on the cloud server,
    you need to enter the IP address or domain name of your server to access the web
    application, `http://<AWS-IP-address>:8080`. If the web application is running
    from the cloud, it can be accessed from anywhere using the Internet, which was
    one of the original project requirements. With this last step, you have successfully
    completed the development of the remote home monitoring system that is based on
    Arduino and Python.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Testing the web application
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you open the web application in a browser, you will be able to see a similar
    output as shown in the following screenshot. As you can see, the web application
    displays the temperature, humidity, light, and motion values. The **Refresh**
    button fetches the sensor data from Xively again and loads the application once
    more. The **Buzzer Off** button sets the value of the Xively''s `Buzzer` channel
    to `OFF`, which then get picked up by the control center, and it turns off the
    buzzer at the monitoring station subsequently:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the web application](img/5938OS_10_13.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: Testing and troubleshooting
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Due to the number of components involved and complex programming associated
    with them, the overall project is a complex system to test and debug. Before you
    jump into troubleshooting, make sure that you have properly followed the steps
    that were described in the previous sections in order. The following are a few
    solutions to possible problems that can occur during the execution of the project:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Troubleshoot individual sensor performance:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your sensor measurements are way off the expected values, the first thing
    that you want to evaluate is the connection of the sensor pins to the Arduino
    board. Make sure that you have connected the digital, analog, and PWM pins correctly.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether your Ethernet Shield board is properly connected to Arduino Uno.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate the connections of the 5V power supply and ground for each component.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid Xively's update limit
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xively imposes a limit on the maximum number of transactions that you can perform
    in a limited amount of time. While running your control center code, if you encounter
    an error for exceeding the limit, wait for 5 minutes before your access limit
    gets lifted.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Increase the delay between consecutive Xively updates at the control center
    level:'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Reduce the frequency of published messages at the monitoring station:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can also combine various Xively channels by formatting data into JSON or
    XML.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with the maximum current draw limitation of Arudino:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The +5V power pin and digital pin of Arduino can provide a maximum current of
    200 mA and 40 mA respectively. When running sensors directly from the Arduino
    board, make sure that you do not exceed these limits.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the combined current requirement of all the sensors is less than 200
    mA. Otherwise, the components won't be able to get enough power to run and this
    will translate into faulty sensor information.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can provide external power to the components that require large amounts
    of current and control this power mechanism via Arduino itself. You will need
    a transistor that is acting as a switch that can then be controlled using the
    digital pins of Arduino. The tutorial at [https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors](https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors)
    shows a similar example for a DC motor.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solve network problems:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some scenarios, your monitoring station won't be able to communicate with
    the control center due to network problems.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This problem can be solved by using manual IP addresses for both, Arduino and
    the Raspberry Pi. In our project, we use a manual IP address for the Arduino,
    but the Raspberry Pi is connected using the Wi-Fi network. In most cases, when
    you are using your home Wi-Fi network, Wi-Fi routers are set up to provide dynamic
    IP addresses to the device every time they reconnect to the router.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can solve this by configuring your Wi-Fi router to a fixed IP address for
    the Raspberry Pi. As the type and model of the Wi-Fi router is different for every
    scenario, you will have to use its user manual or online help forums for setting
    it up.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with buzzer-related issues:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes the buzzer sound can be too loud or too quiet, depending upon the
    sensor that you are using. You can use PWM to configure the intensity of the buzzer.
    In our project, we used the Arduino digital pin 9 to connect the buzzer. This
    pin also supports PWM. In your Arduino code, modify the line to reflect changes
    for the PWM pin. Replace the `digitalWrite(BUZZER, HIGH);` line with `analogWrite(BUZZER,
    127);`.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This routine will reduce the intensity of the buzzer by half from the original
    level. You can also change the PWM value from 0 to 255 and set the intensity of
    the buzzer sound from lowest to highest.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Control center GUI calibration:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending upon the size of the TFT LCD screen that you are using, you will have
    to adjust the size of the main window of `Tkinter`.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, run the current code on your Raspberry Pi and if you see that the GUI
    window does not match the screen, add the following line of code after initializing
    the main window:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code will fix the problem with the size for a 2.8 inch TFT LCD screen.
    In the previous code snippet, `320` and `200` represent the pixel sizes for width
    and length respectively. For other screen sizes, change the pixel size accordingly.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test the LED:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In current code configuration, the LED is turned on only when the system changes
    to `Alert` or `Caution`. That means you won''t be able to test the LEDs unless
    these situations occur. To check whether they are working correctly, execute the
    following command at the control center:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command will light up the LED in red. To turn off the LED, just use `off`
    instead of `red` in the previous code.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If nothing lights up, you should check the connection wires of the LEDs. In
    addition, check for network-related issues as the Mosquitto itself might not be
    working.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you see any color other than red, this means that you haven't connected the
    LED correctly and you need to interchange the pin configuration of your LED. If
    you are using an LED different than super-flux RGB, you should check out the pin
    layout in the datasheet and reorganize the connections.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending your remote home monitoring system
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To successfully create commercial products from DIY project prototypes, you
    will need an additional layer of features on top of basic functionalities. These
    features actually make things convenient for a user when they interact with the
    system. The other distinguishable feature is the tangibility of the system, which
    makes large-scale production and support possible. Although there are plenty of
    features that you can implement, we recommend the following major improvements
    to elevate the level of the current project.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing multiple monitoring stations
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we developed a monitoring station as a prototype with a range
    of functionality that is demonstrated by a remote home monitoring system. A remote
    monitoring system can have multiple numbers of monitoring stations to cover various
    geographical locations, such as different rooms inside a house, or different office
    cubicles. Basically, a large number of monitoring stations can cover an extended
    area and provide efficient surveillance of the domain that you are trying to monitor.
    If you want to extend the current project with an array of monitoring stations,
    you will require some of the following modifications:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Each monitoring station can have its own control center or a centralized control
    center for all of them, depending upon the application requirements.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to update the Python code for the control center to accommodate
    the changes. Examples of these changes include modifying topic titles for MQTT,
    coordinating between these monitoring stations, updating data models for Xively
    updates, and so on.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The free Xively account may not be able to handle the large amounts of data
    coming from the monitoring stations. In this case, you can either optimize the
    update rate and/or payload size or upgrade your Xively account to comply with
    the requirements. You can also resort to other free services such as ThingSpeak,
    Dweet.io, and Carriots, but you will have to make substantial modifications to
    the existing code structure.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also update the web application to provide you with a selection menu
    for the monitoring stations or display all of them at once. You will also have
    to change the code to yield the modified data models.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending sensory capabilities
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In term of sensors, we are only interfacing temperature, humidity, ambient light,
    and motion sensors. However, the actuation is limited to the buzzer and LED. You
    can implement the following changes to improve the sensory capabilities of the
    project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: In a real scenario, a remote home monitoring system should be able to interface
    with other existing sensors such as the security system, monitoring cameras, refrigerator
    sensors, door sensors, and garage sensors throughout a home.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also interface this project with other appliances such as the air conditioner,
    heater, and security alarm, which can help you to control the environment that
    you are already monitoring. As a trial, these components can be interfaced using
    a set of relays and switches.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can upgrade the current sensors at the monitoring station with more powerful,
    efficient, and accurate sensors. However, the monitoring station with the upgraded
    sensors may require a more powerful version of Arduino with more I/O pins and
    computation capabilities.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use additional sensors other than those used in this project at
    the monitoring station. There are large amount of heterogeneous, Arduino-supported
    DIY sensors that you can buy off the shelf. Examples of these sensors include
    the Alcohol Gas Sensor (MQ-3), LPG Gas Sensor (MQ-6), Carbon Monoxide Sensor (MQ-7),
    Methane Gas Sensor (MQ-4), and so on. These sensors can be simply interfaced with
    the Arduino just like the other sensors that we connected earlier.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To accommodate these changes, you will be required to change the control center
    logic and algorithms. If you are interfacing a third-party component, you may
    also have to revisit the system architecture and adjust it.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, you will also have to run frequent updates to Xively for the additional
    number of sensors, making the free version inadequate. To resolve this, you can
    pay for the commercial version of a Xively account or use a limited number of
    requests using a JSON file format similar to the one displayed in the following
    code snippet:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Improving UX
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we designed the user experience for this project, our goal was to demonstrate
    the usefulness of a UX design in developing the software flow. In the current
    UX design, the control center and the web application have limited control and
    features for a user. The following are a few changes that you need to implement
    to improve the UX of the project:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Add tooltips and proper naming conventions for the various descriptions. Implement
    a proper layout to differentiate between the various information categories.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add buttons for the buzzer and the LED control on the control center GUI.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the web application, use a JavaScript and Ajax-based interface to automatically
    refresh the changes in sensor values.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a UI mechanism so that the user can change the update interval at the
    control center and the web application. Once these changes are made, propagate
    them through each program so that the monitoring station can start publishing
    messages at the new interval.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding cloud-based features
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the current setup, we are using two stages to provide cloud-based capabilities
    and enable remote monitoring. We have Xively as a data relay and Amazon AWS to
    host the web application. If you are working on a commercial-grade product and
    want to reduce the complexity of the architecture, you can implement the following
    changes:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: You can develop your own data relay on your cloud instance using open source
    tools such as ThingSpeak. Your control center will then communicate directly to
    your server and eliminate dependency on third-party IoT services.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Xively is your platform, you can also use additional features, such as graphs
    on your smart phone, which are provided by Xively. Once your phone is paired with
    Xively, you can access this feature directly.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can use other cloud services such as Microsoft Azure and
    Google App engine instead of Amazon AWS. You can also set up your own cloud server,
    depending upon your familiarity with cloud computing. Although having your own
    cloud will give you complete control of the server, third-party services such
    as Amazon can be more cost effective and require less maintenance compared to
    self-hosted servers.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are planning to develop a large-scale system that is based on the current
    architecture, you can increase the computing capability of your existing cloud
    instance. You can also implement a distributed server system to accommodate the
    large number of remote monitoring systems that can be accessed by an even greater
    number of users.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving intelligence for situation awareness
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we have used four different sensors to monitor the physical
    environment—each sensor obtains user inputs with two types of actuators for notification.
    Although we are using a good amount of information sources, our situation awareness
    algorithm is limited to identifying out-of-range temperature and humidity values.
    You can implement a few extended features to make your system more versatile and
    useful:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Implement different logic for day and night scenarios, which can help you to
    avoid unwarranted false alarms at night.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an intruder detection algorithm using the motion sensor for when you
    are not at home.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize a combination of ambient light sensor values with motion sensors to
    identify energy wastage. For example, a scenario in which more light is recorded
    during the night when the motions are significantly low explains that you may
    have forgotten to turn off the lights during the night.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an enclosure for hardware components
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like software-based features, the hardware components also require a major
    revamp if you develop a commercial-grade product. Nowadays, 3D printers have become
    viable and it is really easy to design and print plastic 3D components. You can
    also use professional 3D printing services such as Shapeways ([http://www.shapeways.com](http://www.shapeways.com)),
    Sculpteo ([http://www.sculpteo.com](http://www.sculpteo.com)), or makexyz ([http://www.makexyz.com](http://www.makexyz.com))
    for your enclosures. You can even use a laser cutter or other means of model making
    to create the hardware enclosures. These are a few hardware improvements that
    you can implement:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The sensor and actuators that are assembled on a prototype board can be organized
    on a PCB and permanently fixed for stable and robust operation.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hardware enclosure for the monitoring station can make it portable and easily
    deployable in any environment. When designing this enclosure, you should also
    consider the proper placement of the motion sensor and the ambient light sensor,
    along with a button to make them accessible to the user.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Raspberry Pi and TFT LCD screen, which make up the control center hardware,
    can also be enclosed in a mountable package.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding touch screen capabilities to the TFT LCD screen can enable additional
    control over the system, expanding the UX use cases.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a working prototype of a remote home monitoring
    system and also learned the process of hardware product development simultaneously.
    In the project, we utilized most of the hardware components and software tools
    that we used throughout the book. We began by designing the system architecture
    so that we could coordinate the utilization of these tools. Later, we ventured
    into the actual development stages, which included designing the hardware units
    and developing programs to run these units. In the end, we provided a list of
    improvements to make this prototype into a real commercial product. You are welcome
    to use this methodology to develop your future projects and products, as you now
    have experience working with this one.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we are going to utilize the same project development methodology
    to create an interesting project that utilizes your messages from a social network
    website to give you control over your hardware.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
