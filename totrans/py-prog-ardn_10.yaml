- en: Chapter 10. The Final Project – a Remote Home Monitoring System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to combine every topic that we learned in the previous chapters
    into a project that combines Arduino programming, Python GUI development, MQTT
    messaging protocol, and a Python-based cloud application. As you might have already
    figured out from the chapter title, we are going to develop a remote home monitoring
    system using these components.
  prefs: []
  type: TYPE_NORMAL
- en: The first section of the chapter covers the project design process, including
    goals, requirements, architecture, and UX. Once we are done with the design process,
    we will jump into the actual development of the project, which is divided into
    three separate stages. Next, we will cover common troubleshooting topics that
    are usually faced while working with large projects. In our efforts to develop
    utilizable DIY projects, the later section covers tips and features to extend
    the project. As this is quite a large project compared to other projects in the
    book, we are not going to jump straight into the actual development process without
    having any strategy. Let's start by getting ourselves familiar with the standard
    design methodology for hardware projects.
  prefs: []
  type: TYPE_NORMAL
- en: The design methodology for IoT projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of developing a complex product that tightly couples hardware devices
    with high-level software services requires an additional level of planning. For
    this project, we will exercise a proper product development approach to help you
    get familiar with the process of creating real-world hardware projects. This method
    can then be used to plan your own projects and take them to the next level. The
    following diagram describes a typical prototype development process, which always
    begins by defining the major goals that you want to achieve with your product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The design methodology for IoT projects](img/5938OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have defined the set of major goals, you need to break them down into
    project requirements that include every detail of the tasks that your prototype
    should execute to achieve these goals. Using the project requirements, you need
    to sketch out the overall architecture of the system. The next step includes the
    process of defining the UX flow that will help you to lay out the user interaction
    points for your system. At this stage, you will be able to identify any changes
    that are required in the system architecture and the hardware and software components
    to start the development.
  prefs: []
  type: TYPE_NORMAL
- en: As you have defined the interaction points, now you need to distribute the entire
    project development process into multiple stages and delegate the tasks between
    these stages. Once you have completed the development of these stages, you will
    have to interface these stages with each other according to your architecture
    and debug the components if it is needed. At the end, you will have to test your
    project as a whole system and troubleshoot minor problems. In hardware projects,
    it is very difficult to work on your electric circuits again after the completion
    of complex development processes, as the changes can have recurring effects on
    all other components. This process will help you to minimize any hardware rework
    and subsequent software modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about the methodology, let's begin with the actual
    development process for our remote home monitoring system.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The smart home is one of the most well-defined and popular subdomains of the
    IoT. The most important feature of any smart home is its capability to monitor
    the physical environment. Fortunately, the exercises and projects that we covered
    in the previous chapters include components and features that can be used for
    the same purpose. In this chapter, we are going to define a project that will
    utilize these existing components and programming exercises. In the midterm project
    of [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"),
    *The Midterm Project – a Portable DIY Thermostat*, we created a deployable thermostat
    with the ability to measure temperature, humidity, and ambient light. If we want
    to utilize this midterm project, the nearest IoT project that we can build on
    top of it is the remote home monitoring system. The project will have Arduino
    as the main point of interaction between the physical environment and the software-based
    services. We will have a Python program as the middle layer, which will bridge
    the sensor information coming from Arduino with the user-facing graphical interface.
    Let's start by defining the goals that we want to achieve and the project requirements
    to satisfy these goals.
  prefs: []
  type: TYPE_NORMAL
- en: The project goals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Nest thermostat provides an idea of the type of features that a properly
    designed remote monitoring system with professional features should have. Achieving
    this level of system capabilities requires a lot of development effort from a
    large team. Although it will be difficult to include each of the features that
    are supported by a commercial system in our project, we will still try to implement
    the common features that can be incorporated by a prototype project.
  prefs: []
  type: TYPE_NORMAL
- en: The top-level features that we are planning to incorporate in this project can
    be described by the following goals.
  prefs: []
  type: TYPE_NORMAL
- en: Observe the physical environment and make it accessible remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide basic level controls to the user to interact with the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrate a primitive level of built-in situational awareness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have defined the major goals, let''s convert them into detailed
    system requirements. On the completion of the project, the system should be able
    to satisfy the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: It must be able to observe physical phenomenon such as temperature, humidity,
    motion, and ambient light.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should provide local access to sensor information and control over actuators
    such as a buzzer, a button switch, and an LED.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The monitoring should be done by a unit that is developed using the open source
    hardware platform, Arduino.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The monitoring unit should be limited to collect sensor information and communicate
    it to the control unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The control unit should not comprise of a desktop computer or laptop. Instead,
    it should be made deployable using a platform such as a Raspberry Pi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The control unit should demonstrate a primitive level of situation awareness
    capability by utilizing the collected sensor information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The control unit should have a graphical interface to provide the sensor's observation
    and the current state of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system must be accessible via the Internet using cloud-based services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web application that provides remote access should have the capability to
    display the sensor's observations through a web browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system should also provide basic control of the actuators to complete the
    remote access experience by using the web application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the monitoring unit can be constrained by computation resources, the system
    should use hardware-oriented messaging protocols to transfer information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although there are many other minor requirements that can be part of our project,
    they have been skipped in this book. If you have any additional plans for your
    remote home monitoring system, this is the time that you must define these requirements
    before you jump into designing the architecture. Any future changes to the requirements
    can significantly affect the development stage and make hardware and software
    modification difficult. In the last section of the chapter, we have laid down
    a number of additional features that you may want to consider implementing for
    your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Designing system architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing from project goals, first, you need to sketch out a high-level architecture
    of the system. This architectural sketch should include major components that
    enable the system to pass on information between the sensors and the remote users.
    The following figure shows an architectural sketch for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing system architecture](img/5938OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: According to the goals, the user should be able to access the system using the
    Internet; this means that we need cloud components in the architecture. The system
    also needs to monitor the physical environment using a resource-constrained device,
    and this can be executed using Arduino. The middle layer, which connects the cloud
    service and the sensor system, can be built using a Raspberry Pi. In the last
    project, we connected Arduino and the Raspberry Pi using a serial connection,
    but we want to move away from serial connections and start using our home's Ethernet
    network to make the system deployable. Hence, the Arduino-based unit is connected
    to the network using Ethernet while the Raspberry Pi uses Wi-Fi to connect to
    the same network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to lay out the overall system architecture, let''s utilize the sketch
    that we designed, which can be seen in the preceding figure. As you can see in
    the next figure, we have converted the overall system into three main architectural
    units:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring station
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control center
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this figure, we have addressed each and every major component that we are
    going to utilize in the project along with their association to each other. In
    the following sections, we are going to define these three main units briefly.
    The comprehensive description and implementation steps for these units are provided
    later in the chapter under separate sections.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing system architecture](img/5938OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The monitoring station
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need a resource-constrained and robust unit that will communicate with the
    physical environment periodically. This monitoring unit can be built using Arduino
    since low-level microcontroller programming can provide uninterrupted stream of
    sensor data. The usage of Arduino at this stage will also help us to avoid the
    direct interfacing of basic low-level sensors with computers that are running
    on complex operating systems. The sensors and the actuators are connected to Arduino
    using digital, analog, PWM, and I2C interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The control center
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The control center behaves as the main user interaction point between the sensor
    information and the user. It is also responsible for conveying the sensor information
    from the monitoring station to the cloud services. The control center can be developed
    using your regular computer or a single-board computer such as a Raspberry Pi.
    We are going to utilize a Raspberry Pi since it can be easily deployed as a hardware
    unit and it is also capable enough at hosting Python programs. We will replace
    a computer screen with a small TFT LCD screen for the Raspberry Pi to display
    the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main purpose of the cloud services is to provide an Internet-based interface
    for the control center so that the user can access it remotely. Before we host
    a web application to perform this operation, we will need an intermediate data
    relay. This sensor data relay works as a host between the cloud-based web application
    and the control center. In this project, we will be using Xively as the platform
    to collect this sensor data. The web application can be hosted on an Internet
    server; in our case, we are going to use Amazon AWS due to our familiarity with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining UX flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, although we know what the architecture of the overall system looks like,
    we haven't defined how the user is going to interact with it. This process of
    designing user interaction for our system will also help us to figure out data
    flow between major components.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the components that are operating locally at your house, that
    is, the monitoring station and the control center. As you can see from the following
    figure, we have our first user interaction point at the control center. The user
    can observe the information or act upon it if the system's status is an alert.
    The user action to dismiss the alert prompts multiple operations to take place
    at the control center and the monitoring station. We recommend you thoroughly
    examine the figure to better understand the flow of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining UX flow](img/5938OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the second user interaction point is located at the web application.
    The web application displays the observations and system''s status that we calculated
    at the control center and provides an interface to dismiss the alert. In this
    scenario, the dismiss action will travel through Xively to the control center
    where the appropriate actions for the control center will remain the same as in
    the previous scenario. However, in the web application, the user has to load the
    web browser every time to request the data, which was happening automatically
    at the control center. Take a look at the following figure to understand the UX
    flow for the web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining UX flow](img/5938OS_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The list of required components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The necessary components for the project are derived using three main criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Ease of availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility with the Arduino board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarity with the components due to previous utilization in this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the list of the components that you will need to start working on the
    project. If you have completed the previous exercises and projects, you should
    already have most of the components. If you don't want to disassemble the projects,
    you can obtain them from the websites of SparkFun, Adafruit, or Amazon, whose
    links are provide in the next table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hardware components for the monitoring station are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component (first stage) | Quantity | Link |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Uno | 1 | [https://www.sparkfun.com/products/11021](https://www.sparkfun.com/products/11021)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino Ethernet Shield | 1 | [https://www.sparkfun.com/products/9026](https://www.sparkfun.com/products/9026)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Breadboard | 1 | [https://www.sparkfun.com/products/9567](https://www.sparkfun.com/products/9567)
    |'
  prefs: []
  type: TYPE_TB
- en: '| TMP102 temperature sensor | 1 | [https://www.sparkfun.com/products/11931](https://www.sparkfun.com/products/11931)
    |'
  prefs: []
  type: TYPE_TB
- en: '| HIH-4030 humidity sensor | 1 | [https://www.sparkfun.com/products/9569](https://www.sparkfun.com/products/9569)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mini photocell | 1 | [https://www.sparkfun.com/products/9088](https://www.sparkfun.com/products/9088)
    |'
  prefs: []
  type: TYPE_TB
- en: '| PIR motion sensor | 1 | [https://www.sparkfun.com/products/8630](https://www.sparkfun.com/products/8630)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Super-flux RGB LED, common anode | 1 | [http://www.adafruit.com/product/314](http://www.adafruit.com/product/314)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Buzzer | 1 | [http://www.adafruit.com/products/160](http://www.adafruit.com/products/160)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Push button switch | 1 | [https://www.sparkfun.com/products/97](https://www.sparkfun.com/products/97)
    |'
  prefs: []
  type: TYPE_TB
- en: '| USB cable for Arduino(for development stage) | 1 | [https://www.sparkfun.com/products/512](https://www.sparkfun.com/products/512)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino power supply(for deployment stage) | 1 | [http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/](http://www.amazon.com/Arduino-9V-1A-Power-Adapter/dp/B00CP1QLSC/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Resistors | As required | 220 ohm, 1 kilo-ohm, and 10 kilo-ohm |'
  prefs: []
  type: TYPE_TB
- en: '| Connection wires | As required |   |'
  prefs: []
  type: TYPE_TB
- en: 'The hardware components for the control center are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Component (first stage) | Quantity | Link |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi | 1 | [https://www.sparkfun.com/products/11546](https://www.sparkfun.com/products/11546)
    |'
  prefs: []
  type: TYPE_TB
- en: '| TFT LCD screen | 1 | [http://www.amazon.com/gp/product/B00GASHVDU/](http://www.amazon.com/gp/product/B00GASHVDU/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| SD card (8 GB) | 1 | [https://www.sparkfun.com/products/12998](https://www.sparkfun.com/products/12998)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Wi-Fi dongle | 1 | [http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY](http://www.amazon.com/Edimax-EW-7811Un-150Mbps-Raspberry-Supports/dp/B003MTTJOY)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi power supply | 1 | [http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0](http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Keyboard, mouse, USB hub, and monitor | As required | Requried for development
    and debugging stages |'
  prefs: []
  type: TYPE_TB
- en: Defining the project development stages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As per the system architecture, we have three main units that collaboratively
    create the remote home monitoring project. The overall hardware and software development
    process is also aligned with these three units and can be distributed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring station development stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control center development stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web application development stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The software development for the monitoring station stage includes developing
    the Arduino code to monitor sensors and perform actuator actions on one side,
    while publishing this information to the control center on the other side. The
    middle layer of the development stage, that is, the Raspberry Pi-based control
    center, hosts the Mosquitto broker. This stage also contains the Python program
    that contains the GUI, situation awareness logic, and subroutines to communicate
    with the Xively cloud service. The last stage, the cloud services, includes two
    distinct components, sensor data relay and a web application. We will be using
    the Xively platform as our sensor data relay and the web application will be developed
    in Python on the Amazon AWS cloud instance. Now, let's jump into the actual development
    process and our first stop will be the Arduino-based monitoring station.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 1 – a monitoring station using Arduino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed, the main tasks of the monitoring systems are to interface sensor
    components and communicate the information generated by these sensors to the observers.
    You will be using Arduino Uno as the central microcontroller component to integrate
    these sensors and actuators. We also need a means of communication between the
    Arduino Uno and the control center and we will be utilizing the Arduino Ethernet
    Shield for this purpose. Let's discuss the hardware architecture of the monitoring
    station and its components.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the monitoring station
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already designed units based on Arduino and the Ethernet Shield in various
    exercises in [Chapter 8](ch08.html "Chapter 8. Introduction to Arduino Networking"),
    *Introduction to Arduino Networking*, and [Chapter 9](ch09.html "Chapter 9. Arduino
    and the Internet of Things"), *Arduino and the Internet of Things*. Therefore,
    we have assumed that you are familiar with interfacing the Ethernet Shield with
    the Arduino board. We will connect various sensors and actuators with the Arduino
    board, as displayed in the following diagram. As you can see in this diagram,
    the sensors will provide the data to the Arduino board while the actuators will
    seek the data from the Arduino board. Although we are automatically collecting
    environment data for these sensors, the data from the button will be collected
    from manual user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the monitoring station](img/5938OS_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Check out the following Fritzing diagram for the detailed connections in the
    monitoring station. As you can see in our hardware design, the temperature sensor
    TMP102 is connected through the I2C interface, which means that we will need the
    SDA and SCL lines. We will be using analog pins 5 and 6 of the Arduino board to
    interface SDA and SCL respectively. The humidity (HIH-4030) and ambient light
    sensors also provide analog output and are connected to the analog pins of the
    Arduino board. Meanwhile, the buzzer, the button switch, and the PIR motion sensor
    are connected through the digital I/O pins. The super-flux RGB LED is a common
    anode LED; this means that it is always powered using the common anode pins and
    the R, G, and B pins are controlled by using the PWM pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you properly connect all the components to the pins that are
    specified in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the monitoring station](img/5938OS_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about the interfacing of RGB LED with Arduino from the tutorial
    at [https://learn.adafruit.com/all-about-leds](https://learn.adafruit.com/all-about-leds).
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an Arduino board other than Arduino Uno, you will have to adjust
    the appropriate pin numbers in the Arduino code. In addition, make sure that this
    Arduino board is compatible with the Ethernet Shield.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of circuit connections, you can use a breadboard as shown in the previous
    diagram, or if you are comfortable, you can use a PCB prototype board and solder
    the components. In our setup, we first tested the components on the breadboard
    and once they were tested, we soldered the components, as shown in the following
    figure. If you venture to solder the PCB board, make sure that you have the necessary
    components for the job. The PCB prototype will yield a robust performance compared
    to the breadboard, but it will also make it difficult for you to debug and change
    the components afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the monitoring station](img/5938OS_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are ready with your circuit connection, connect your Arduino to your
    computer using the USB cable. Also, connect the Ethernet Shield to your home router
    using an Ethernet cable.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino sketch for the monitoring station
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before jumping into the coding stage, make sure that you have collected the
    prebuilt Arduino code for the project. You can find it in the code folder of this
    chapter with the filename `Arduino_monitoring_station.ino`. The code implements
    the necessary logic to support the overall UX flow at the monitoring station,
    which we discussed in the previous section. In the following sections, we will
    go through the major areas of the program so that you can better understand these
    code snippets. Now, open this sketch in the Arduino IDE. You are already familiar
    with setting up the IP address for Arduino. You also learned how to use the Arduino
    MQTT library `PubSubClient` in the previous chapter, which means that your Arduino
    IDE should already have the `PubSubClient` library installed on it. At the beginning
    of the code, we have also declared few constants, such as the IP addresses of
    the MQTT server and Arduino and the pin numbers of various sensor and actuators.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will have to change the IP address of the monitoring station and the control
    center according to your network setup. Make sure that you perform these modifications
    before uploading the Arduino code.
  prefs: []
  type: TYPE_NORMAL
- en: In the code structure, we have two mandatory Arduino functions, `setup()` and
    `loop()`. In the `setup()` function, we will set up the Arduino pin types and
    the MQTT subscriber channels. In the same function, we will also attach an interrupt
    for the press of the button while setting up the timer for the `publishData()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing sensor information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `publishData()` function reads the sensor inputs and publishes this data
    to the Mosquitto broker that is located on the control center. As you can see
    in the following code snippet, we are measuring sensors values one by one and
    publishing them to the broker using the `client.publish()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check out the `setup()` function, you will notice that we have used
    a library called `SimpleTimer` to set up a `timer` method for this function. This
    method executes the `publishData()` function periodically without interrupting
    and blocking the actual flow of the Arduino execution cycle. In the following
    code snippet, the number `300000` represents the time delay in milliseconds, that
    is, 5 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to download and import the `SimpleTimer` library to compile and
    run the code successfully. You can download the library from [https://github.com/infomaniac50/SimpleTimer](https://github.com/infomaniac50/SimpleTimer).
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to actuator actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can see in the `setup()` function that we are initializing the code by
    subscribing to the `MonitoringStation/led` and `MonitoringStation/buzzer` channels.
    The `client.subscribe()` method will make sure that whenever the Mosquitto broker
    gets any updates for these channels, the Arduino-based monitoring system gets
    notified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Programming an interrupt to handle the press of a button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have taken care of the publishing and subscribing functions of the monitoring
    station. Now, we will need to integrate the button switch that is controlled by
    inputs from the user. In the Arduino programming routines, we run a periodic loop
    to check the status of the pins. However, this may not be useful if the button
    is pressed since it requires immediate action. This action of pressing the button
    is handled using the Arduino interrupts, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line of code associates an interrupt at pin 0 (digital pin 2)
    with the `buttonPress()` function. This function sets off the buzzers whenever
    the state of the interrupt is changed. In other words, when the button is pressed
    by the user, the buzzer will be instantaneously turned off irrespective of the
    current status of the buzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current Arduino code communicates with the control center for publishing
    and subscribing the data, but we haven't yet set up the Mosquitto broker to handle
    these requests. You can still go ahead and upload the Arduino sketch to your monitoring
    station using the USB cable. This will not result in any fruitful actions from
    the monitoring station and you will only be able to use the `Serial.prinln()`
    command to print various sensor measurements. Therefore, we will develop the control
    center next so that we can start addressing communication requests from the monitoring
    station.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 2 – a control center using Python and the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to deliver the status of the system and other sensor observations to
    the user, the control center needs to perform various operations that include
    obtaining raw sensor data from the monitoring station, calculating the status
    of the system, reporting this data to the cloud services, and displaying observation
    using GUI. While the control center includes two major hardware components (the
    Raspberry Pi and TFT LCD screen), it is also comprised of two major software components
    (the Mosquitto broker and Python code) to handle the control center logic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using a Raspberry Pi instead of a regular computer as we want the control
    center to be a deployable and portable unit that can be mounted on a wall.
  prefs: []
  type: TYPE_NORMAL
- en: You can still use your own computer to edit and test the Python code for development
    purposes instead of using a Raspberry Pi directly. However, we recommend that
    you switch back to the Raspberry Pi once you are ready for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The control center architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Raspberry Pi is the main computation unit of the control center and works
    as the brain of the entire system. Since the Raspberry Pi is used as a replacement
    for a regular computer, the architecture of the control center can interchangeably
    use a computer in place of the Raspberry Pi. As you can see in the following diagram,
    the control center is connected to the home network using Wi-Fi and this will
    make it accessible to the monitoring station. The control center includes the
    Mosquitto broker; this is used as the communication point between the monitoring
    station and the Python program for the control center. The Python program utilizes
    the `Tkinter` library for GUI and the `paho_mqtt` library to communicate with
    the Mosquitto broker. By utilizing these two libraries, we can convey sensor information
    from the monitoring station to the user. However, we will need a separate arrangement
    to establish communication between the control center and cloud services. In our
    overall system architecture, the control center is designed to communicate with
    the intermediate data relay, Xively. The Python code uses the `xively-python`
    library to enable this communication.
  prefs: []
  type: TYPE_NORMAL
- en: '![The control center architecture](img/5938OS_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 8](ch08.html "Chapter 8. Introduction to Arduino Networking"), *Introduction
    to Arduino Networking*, we already provided you with methods to install the Mosquitto
    broker, the `Python-mosquitto` library, and the `xively-python` library. We also
    learned the process of setting up the TFT LCD screen with the Raspberry Pi in
    [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"),
    *The Midterm Project – a Portable DIY Thermostat*. Please refer to those tutorials
    in case you haven't completed those exercises yet. Assuming that you have configured
    the Mosquitto broker and the required Python libraries, you can move on to the
    next section, which includes the actual Python programming.
  prefs: []
  type: TYPE_NORMAL
- en: The Python code for the control center
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start interfacing these libraries in the Python code, start your
    Mosquitto broker first from the command line using this simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you restart your monitoring station every time you start or restart
    the Mosquitto broker. This action will make sure that your monitoring station
    is connected to the Mosquitto broker, since the process of establishing the connection
    only gets executed once in our Arduino code, that is, at the beginning of the
    setup process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code for the current project is located in the code folder of this
    chapter with the name `controlCenter.py`. Open this file using your Python IDE
    and modify the values of the appropriate parameters before executing it. These
    parameters include the IP address of the Mosquitto broker along with the feed
    ID and the API key of the Xively virtual device. You should already have the feed
    ID and the API key of your Xively virtual device from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you are using a local instance of the Mosquitto broker, you can replace the
    IP address with `127.0.0.1`. Otherwise, replace the `10.0.0.18` address with the
    appropriate IP address of the computer that is hosting the Mosquitto broker. Let's
    try to understand the code now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes on Mac OS X, you won't be able to run `Tkinter` window and Python
    threads in parallel due to an unknown bug. You should be able to execute the program
    successfully in Windows and Linux environments. This program has been tested with
    the Raspberry Pi, which means you won't encounter the same bug while deploying
    the control center.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the GUI using Tkinter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous exercises, we always used a single Python thread to run the
    program. This practice will not help us to perform multiple tasks in parallel
    such as obtaining sensor observation from the monitoring station and simultaneously
    updating the GUI with that information. As a solution, we have introduced multithreading
    in this exercise. As we need two separate loops, one each for `Tkinter` and `paho-mqtt`,
    we will be running them independently in separate threads. The main thread will
    run methods that are related to Mosquitto and the cloud services, while the second
    thread will handle the `Tkinter` GUI. In the following code snippet, you can see
    that we have initialized the `controlCenterWindow()` class with the `threading.thread`
    parameter. Therefore, when we execute `window = controlCenterWindow()` in the
    main program, it will create another thread for this class. Basically, this class
    creates the GUI window while populating labels and other GUI components. The labels
    need to be updated when new sensor observations arrive, are declared as class
    variables, and are accessible from the class instant. As you can see in the following
    code snippet, we have declared the labels for temperature, humidity, light, and
    motion as class variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet doesn't contain the portion where we declared the
    `Tkinter` components, as it is similar to what we coded in the midterm project.
    If you have questions regarding Tkinter-related issues, please refer to [Chapter
    6](ch06.html "Chapter 6. Storing and Plotting Arduino Data"), *Storing and Plotting
    Arduino Data*, and [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable
    DIY Thermostat"), *The Midterm Project – a Portable DIY Thermostat*.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the Mosquitto broker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the control center level, we subscribe to topics that are published from
    the monitoring station, that is, `MonitoringStation/temperature`, `MonitoringStation/humidity`,
    and so on. If you have performed any modification to the Arduino code to change
    the MQTT topics, you need to reflect those changes in this section. If the topics
    published by the monitoring station do not match the topics in the control center''s
    code, you will not get any updates. As you can see in the Python code, we are
    associating the `on_message` and `on_publish` methods with very important function.
    Whenever a message arrives from the subscriber, the client will call the functions
    associated with the `on_message` method. However, every time a message gets published
    from the Python code, the `onPublish()` function will get called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the system's status and situation awareness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The control center is assigned with the task of calculating the status of the
    overall system. The control center calculates the status of the system as `Alert`,
    `Caution`, or `Normal` using the current values of temperature and humidity. To
    calculate the status, the control center executes the `calculateStatus()` function
    every time it gets an update for the temperature or humidity from the monitoring
    station. According to the current situation awareness logic, if the temperature
    is measured above 45 degree Celsius or below 5 degree Celsius, we call the system''s
    status as `Alert`. Similarly, you can identify the range of temperature and humidity
    values for `Caution` and `Normal` statuses from the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Communicating with Xively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The control center is also required to communicate with Xively when it receives
    a message from the subscribed topics. We are already familiar with the process
    of setting up virtual devices and data streams on Xively. Open your Xively account
    and create a virtual device called `ControlCenter`. Note down the feed ID and
    API key for this device and replace them in the current code. Once you have these
    values, create the `Temperature`, `Humidity`, `Light`, `Motion`, `Buzzer`, and
    `Status` channels in this virtual device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the Python code, you can see that we have declared the individual
    data stream for each topic and associated them with the appropriate Xively channel.
    The following code snippet shows the data stream for just the temperature observation,
    but the code also contains a similar configuration for all the other sensor observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the control center receives a message from the monitoring station, it
    updates the data stream with the latest values and pushes these changes to Xively.
    At the same time, we will also update the appropriate label in the `Tkinter` GUI
    using the `onMessage()` function. We will use the same code snippet for all the
    subscribed channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The control center also implements the function to set the system''s status
    across the system, once it is calculated using the `calculateStatus()` function.
    There are three different functions to perform this task using a method that is
    similar to what we described in the previous code snippet. These functions include
    `setAlert()`, `setCaution()`, and `setNormal()` and these are associated with
    `Alert`, `Caution`, and `Normal` respectively. While updating the system''s status,
    these functions also perform buzzer and LED actions by publishing the LED and
    buzzer values to the Mosquitto broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Checking and updating the buzzer's status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the control center, we set the buzzer's status to `ON` if the system's status
    is determined as `Alert`. If you look back at the UX flow, you will notice that
    we also want to include a feature for the user to manually turn off the buzzer.
    The `checkBuzzerFromXively()` function keeps track of the buzzer's status from
    Xively and if the user manually turns off the buzzer using the web application,
    this function sets off the buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue this process independently from the GUI and situation awareness
    threads, we will need to create another thread for this function. The timer on
    this thread will automatically execute the function every 30 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this function running in a separate thread every 30 seconds, the control
    center will check the status of the Xively channel and stop the buzzer if the
    status is set to `OFF`. We will explain how the user can update the Xively channel
    for the buzzer in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the control center with the monitoring station
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming your Mosquitto broker is running, execute the `controlCenter.py` code
    with the changed parameters. Then, start the monitoring station. After a few moments,
    you will see on the terminal that the control center has already started getting
    messages from the publishers that are initialized on the monitoring station. The
    update interval for the messages from the publisher at the control center depends
    upon the configured publishing interval at the monitoring station.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino code executes the process of connecting to the Mosquitto broker
    only once after powering on. If you start your Mosquitto broker after that, it
    won't be able to communicate with the broker. So, you need to make sure that you
    start the Mosquitto broker before powering on the monitoring station.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to restart the Mosquitto broker for any reason, remove and restart
    the monitoring station first.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the control center with the monitoring station](img/5938OS_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On execution of the program, you will be able to see a small GUI window, as
    shown in the following screenshot. This window displays the sensor''s values for
    temperature, humidity, ambient light, and motion. Along with these values, the
    GUI also displays the status of the system, which is **Normal** in this screenshot.
    You can also observe that every time the control center gets updates from the
    monitoring station, the system''s status and sensor observations change in real
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the control center with the monitoring station](img/5938OS_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If this setup is working correctly on your computer, let's move on to deploy
    the control center on the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the control center on the Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of installing the Raspbian operating system is explained in [Chapter
    7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"), *The
    Midterm Project – a Portable DIY Thermostat*. You can use the same module that
    you used in the Midterm project or set up a new one. Once you have installed Raspbian
    and configured the TFT screen, connect the Wi-Fi dongle through a USB port. At
    this stage, we assume that your Raspberry Pi is connected with a monitor, a keyboard,
    and a mouse to perform the basic changes. Although we won''t recommend it, you
    can also use the TFT screen for the following operations, if you are comfortable
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your Raspberry Pi and log in. At the command prompt, execute the following
    command to enter the visual desktop mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once your graphical desktop starts, you will be able to see the icon of the
    **WiFi config** utility. Double-click on this icon and open the **WiFi config**
    utility. Scan for wireless networks and connect to the Wi-Fi network that has
    the monitoring station. When asked, enter the password of your network in the
    form window called **PSK**, and connect to your network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, your Raspberry Pi is connected to the local home network and to the Internet
    through it. It''s time to update the existing packages and install the required
    ones. To update the Raspberry Pi''s existing system, execute the following commands
    in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once your system is updated with the latest version, it''s time to install
    the Mosquitto broker on your Raspberry Pi. The Raspbian OS has Mosquitto in the
    default repository, but it doesn''t have the current version that we need. To
    install the latest version of Mosquitto, execute following commands in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To install other Python dependencies, let''s first install the Setuptools package
    using `apt-get`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using Setuptools, we can now install all the required Python libraries such
    as `paho_mqtt`, `xively-python`, and `web.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have installed all the necessary software tools that are required
    to run our control center on the Raspberry Pi, it is time to configure the Raspberry
    Pi so that it can provide uninterrupted operation for a critical system such as
    a remote home monitoring system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current configuration of the Raspberry Pi, the screen of the Raspberry
    Pi will go to sleep after some time and the Wi-Fi connection will be terminated
    when this happens. To avoid this problem and force the screen to remain active,
    you will need to perform the following changes. Open the `lightdm.conf` file using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the file, navigate to the `SetDefaults` section and edit the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that your Raspberry Pi is set up, it is time to copy the program file from
    your computer to the Raspberry Pi. You can use SCP, PuTTY, or just a USB drive
    to transfer the necessary file to the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you install and configure everything as specified, your program should run
    without any errors. You can run the Python program constantly in the background
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The last thing that we want to set up on the Raspberry Pi is the TFT LCD screen.
    The installation and configuration processes of the TFT LCD screen are described
    in [Chapter 7](ch07.html "Chapter 7. The Midterm Project – a Portable DIY Thermostat"),
    *The Midterm Project – a Portable DIY Thermostat*. Please follow the steps in
    the given order to set up the screen. The control center module along with the
    Raspberry Pi and the TFT screen can now be deployed in any part of your house.
  prefs: []
  type: TYPE_NORMAL
- en: Stage 3 – a web application using Xively, Python, and Amazon cloud service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cloud services module of the overall system enables remote access to your
    monitoring station through the Internet. The unit interacts with the user via
    a web application as an extended version of the control center. With the use of
    this web application, the user can observe the sensor information from the monitoring
    station and the system's status calculated by the control center while having
    remote control to turn off the buzzer. So, what does the architecture of the cloud
    services look like?
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of the cloud services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The architecture of the cloud services module with its associated components
    is displayed in the following diagram. In the cloud services architecture, we
    are using Xively as the intermediate data relay between the web application and
    the control center. The control center pushes the observations obtained from the
    monitoring station to the Xively channels. Xively stores and relays the data to
    the web application that is hosted on the Amazon AWS. The server instance on the
    Amazon AWS is used to make the web application accessible through the Internet.
    The server instance runs the Ubuntu operating system and the web application that
    is developed using the `web.py` library in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture of the cloud services](img/5938OS_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous stage, we already covered the process of setting up Xively and
    the channels to accommodate sensor data. In the control center code, we also explained
    how we can push the updated observations to the appropriate Xively channels. Therefore,
    we really do not have any ground to cover for the Xively platform at this stage
    and we can move on to the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Python web application hosted on Amazon AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we set up an Amazon AWS cloud instance to host a web
    application. You can use the same instance to host the web application for the
    remote home monitoring system too. However, make sure that you have installed
    the `web.py` library on your server.
  prefs: []
  type: TYPE_NORMAL
- en: In your computer, open the `Web_Application` folder and then the `RemoteMonitoringApplication.py`
    file in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the code, you will be able to see that we just expand the web application
    program that we created in [Chapter 9](ch09.html "Chapter 9. Arduino and the Internet
    of Things"), *Arduino and the Internet of Things*. We use the templates based
    on `web.py` and the `GET()` and `POST()` functions to enable the web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the application, we fetch information from each Xively channel and process
    it via a separate function. For example, the `fetchTempXively()` function obtains
    the temperature information from Xively. Every time the `POST()` function is executed,
    the `fetchTempXively()` function fetches the latest value of temperature reading
    from Xively. This also means that the web application does not populate and refresh
    the latest information automatically and waits for `POST()` to execute the appropriate
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The web application also provides access to control the buzzer from the user
    interface. The following code snippet adds the **Buzzer Off** button with other
    `Form` components. When the form is submitted after this button is pressed, the
    web application executes the `setBuzzer()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `setBuzzer()` function access the Xively channel, `Buzzer`, and sends the
    off value if the **Buzzer Off** button is pressed. The current web application
    doesn''t include the **Buzzer On** button, but you can easily implement this functionality
    by reusing the code that we developed for the **Buzzer Off** button. This function
    provides the reference code for other control points, which you can reuse with
    minor modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the code, you will also have to modify the Xively feed ID and the API key
    and replace them with the values that your obtained from your virtual device.
    Once you have performed this modification, run the following command. If everything
    goes as planned, you will be able to open the web application in your web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are running the Python code on your computer, you can open `http://127.0.0.1:8080`
    to access the application. If you are running the application on the cloud server,
    you need to enter the IP address or domain name of your server to access the web
    application, `http://<AWS-IP-address>:8080`. If the web application is running
    from the cloud, it can be accessed from anywhere using the Internet, which was
    one of the original project requirements. With this last step, you have successfully
    completed the development of the remote home monitoring system that is based on
    Arduino and Python.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you open the web application in a browser, you will be able to see a similar
    output as shown in the following screenshot. As you can see, the web application
    displays the temperature, humidity, light, and motion values. The **Refresh**
    button fetches the sensor data from Xively again and loads the application once
    more. The **Buzzer Off** button sets the value of the Xively''s `Buzzer` channel
    to `OFF`, which then get picked up by the control center, and it turns off the
    buzzer at the monitoring station subsequently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the web application](img/5938OS_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing and troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Due to the number of components involved and complex programming associated
    with them, the overall project is a complex system to test and debug. Before you
    jump into troubleshooting, make sure that you have properly followed the steps
    that were described in the previous sections in order. The following are a few
    solutions to possible problems that can occur during the execution of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Troubleshoot individual sensor performance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your sensor measurements are way off the expected values, the first thing
    that you want to evaluate is the connection of the sensor pins to the Arduino
    board. Make sure that you have connected the digital, analog, and PWM pins correctly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether your Ethernet Shield board is properly connected to Arduino Uno.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate the connections of the 5V power supply and ground for each component.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid Xively's update limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xively imposes a limit on the maximum number of transactions that you can perform
    in a limited amount of time. While running your control center code, if you encounter
    an error for exceeding the limit, wait for 5 minutes before your access limit
    gets lifted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Increase the delay between consecutive Xively updates at the control center
    level:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Reduce the frequency of published messages at the monitoring station:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: You can also combine various Xively channels by formatting data into JSON or
    XML.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with the maximum current draw limitation of Arudino:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The +5V power pin and digital pin of Arduino can provide a maximum current of
    200 mA and 40 mA respectively. When running sensors directly from the Arduino
    board, make sure that you do not exceed these limits.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the combined current requirement of all the sensors is less than 200
    mA. Otherwise, the components won't be able to get enough power to run and this
    will translate into faulty sensor information.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can provide external power to the components that require large amounts
    of current and control this power mechanism via Arduino itself. You will need
    a transistor that is acting as a switch that can then be controlled using the
    digital pins of Arduino. The tutorial at [https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors](https://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors)
    shows a similar example for a DC motor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solve network problems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some scenarios, your monitoring station won't be able to communicate with
    the control center due to network problems.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This problem can be solved by using manual IP addresses for both, Arduino and
    the Raspberry Pi. In our project, we use a manual IP address for the Arduino,
    but the Raspberry Pi is connected using the Wi-Fi network. In most cases, when
    you are using your home Wi-Fi network, Wi-Fi routers are set up to provide dynamic
    IP addresses to the device every time they reconnect to the router.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can solve this by configuring your Wi-Fi router to a fixed IP address for
    the Raspberry Pi. As the type and model of the Wi-Fi router is different for every
    scenario, you will have to use its user manual or online help forums for setting
    it up.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Working with buzzer-related issues:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes the buzzer sound can be too loud or too quiet, depending upon the
    sensor that you are using. You can use PWM to configure the intensity of the buzzer.
    In our project, we used the Arduino digital pin 9 to connect the buzzer. This
    pin also supports PWM. In your Arduino code, modify the line to reflect changes
    for the PWM pin. Replace the `digitalWrite(BUZZER, HIGH);` line with `analogWrite(BUZZER,
    127);`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This routine will reduce the intensity of the buzzer by half from the original
    level. You can also change the PWM value from 0 to 255 and set the intensity of
    the buzzer sound from lowest to highest.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Control center GUI calibration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending upon the size of the TFT LCD screen that you are using, you will have
    to adjust the size of the main window of `Tkinter`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, run the current code on your Raspberry Pi and if you see that the GUI
    window does not match the screen, add the following line of code after initializing
    the main window:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: This code will fix the problem with the size for a 2.8 inch TFT LCD screen.
    In the previous code snippet, `320` and `200` represent the pixel sizes for width
    and length respectively. For other screen sizes, change the pixel size accordingly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test the LED:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In current code configuration, the LED is turned on only when the system changes
    to `Alert` or `Caution`. That means you won''t be able to test the LEDs unless
    these situations occur. To check whether they are working correctly, execute the
    following command at the control center:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: This command will light up the LED in red. To turn off the LED, just use `off`
    instead of `red` in the previous code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If nothing lights up, you should check the connection wires of the LEDs. In
    addition, check for network-related issues as the Mosquitto itself might not be
    working.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you see any color other than red, this means that you haven't connected the
    LED correctly and you need to interchange the pin configuration of your LED. If
    you are using an LED different than super-flux RGB, you should check out the pin
    layout in the datasheet and reorganize the connections.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending your remote home monitoring system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To successfully create commercial products from DIY project prototypes, you
    will need an additional layer of features on top of basic functionalities. These
    features actually make things convenient for a user when they interact with the
    system. The other distinguishable feature is the tangibility of the system, which
    makes large-scale production and support possible. Although there are plenty of
    features that you can implement, we recommend the following major improvements
    to elevate the level of the current project.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing multiple monitoring stations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we developed a monitoring station as a prototype with a range
    of functionality that is demonstrated by a remote home monitoring system. A remote
    monitoring system can have multiple numbers of monitoring stations to cover various
    geographical locations, such as different rooms inside a house, or different office
    cubicles. Basically, a large number of monitoring stations can cover an extended
    area and provide efficient surveillance of the domain that you are trying to monitor.
    If you want to extend the current project with an array of monitoring stations,
    you will require some of the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Each monitoring station can have its own control center or a centralized control
    center for all of them, depending upon the application requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to update the Python code for the control center to accommodate
    the changes. Examples of these changes include modifying topic titles for MQTT,
    coordinating between these monitoring stations, updating data models for Xively
    updates, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The free Xively account may not be able to handle the large amounts of data
    coming from the monitoring stations. In this case, you can either optimize the
    update rate and/or payload size or upgrade your Xively account to comply with
    the requirements. You can also resort to other free services such as ThingSpeak,
    Dweet.io, and Carriots, but you will have to make substantial modifications to
    the existing code structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also update the web application to provide you with a selection menu
    for the monitoring stations or display all of them at once. You will also have
    to change the code to yield the modified data models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending sensory capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In term of sensors, we are only interfacing temperature, humidity, ambient light,
    and motion sensors. However, the actuation is limited to the buzzer and LED. You
    can implement the following changes to improve the sensory capabilities of the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: In a real scenario, a remote home monitoring system should be able to interface
    with other existing sensors such as the security system, monitoring cameras, refrigerator
    sensors, door sensors, and garage sensors throughout a home.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also interface this project with other appliances such as the air conditioner,
    heater, and security alarm, which can help you to control the environment that
    you are already monitoring. As a trial, these components can be interfaced using
    a set of relays and switches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can upgrade the current sensors at the monitoring station with more powerful,
    efficient, and accurate sensors. However, the monitoring station with the upgraded
    sensors may require a more powerful version of Arduino with more I/O pins and
    computation capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use additional sensors other than those used in this project at
    the monitoring station. There are large amount of heterogeneous, Arduino-supported
    DIY sensors that you can buy off the shelf. Examples of these sensors include
    the Alcohol Gas Sensor (MQ-3), LPG Gas Sensor (MQ-6), Carbon Monoxide Sensor (MQ-7),
    Methane Gas Sensor (MQ-4), and so on. These sensors can be simply interfaced with
    the Arduino just like the other sensors that we connected earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To accommodate these changes, you will be required to change the control center
    logic and algorithms. If you are interfacing a third-party component, you may
    also have to revisit the system architecture and adjust it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, you will also have to run frequent updates to Xively for the additional
    number of sensors, making the free version inadequate. To resolve this, you can
    pay for the commercial version of a Xively account or use a limited number of
    requests using a JSON file format similar to the one displayed in the following
    code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Improving UX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we designed the user experience for this project, our goal was to demonstrate
    the usefulness of a UX design in developing the software flow. In the current
    UX design, the control center and the web application have limited control and
    features for a user. The following are a few changes that you need to implement
    to improve the UX of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Add tooltips and proper naming conventions for the various descriptions. Implement
    a proper layout to differentiate between the various information categories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add buttons for the buzzer and the LED control on the control center GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the web application, use a JavaScript and Ajax-based interface to automatically
    refresh the changes in sensor values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a UI mechanism so that the user can change the update interval at the
    control center and the web application. Once these changes are made, propagate
    them through each program so that the monitoring station can start publishing
    messages at the new interval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding cloud-based features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the current setup, we are using two stages to provide cloud-based capabilities
    and enable remote monitoring. We have Xively as a data relay and Amazon AWS to
    host the web application. If you are working on a commercial-grade product and
    want to reduce the complexity of the architecture, you can implement the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: You can develop your own data relay on your cloud instance using open source
    tools such as ThingSpeak. Your control center will then communicate directly to
    your server and eliminate dependency on third-party IoT services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Xively is your platform, you can also use additional features, such as graphs
    on your smart phone, which are provided by Xively. Once your phone is paired with
    Xively, you can access this feature directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can use other cloud services such as Microsoft Azure and
    Google App engine instead of Amazon AWS. You can also set up your own cloud server,
    depending upon your familiarity with cloud computing. Although having your own
    cloud will give you complete control of the server, third-party services such
    as Amazon can be more cost effective and require less maintenance compared to
    self-hosted servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are planning to develop a large-scale system that is based on the current
    architecture, you can increase the computing capability of your existing cloud
    instance. You can also implement a distributed server system to accommodate the
    large number of remote monitoring systems that can be accessed by an even greater
    number of users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving intelligence for situation awareness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we have used four different sensors to monitor the physical
    environment—each sensor obtains user inputs with two types of actuators for notification.
    Although we are using a good amount of information sources, our situation awareness
    algorithm is limited to identifying out-of-range temperature and humidity values.
    You can implement a few extended features to make your system more versatile and
    useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement different logic for day and night scenarios, which can help you to
    avoid unwarranted false alarms at night.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an intruder detection algorithm using the motion sensor for when you
    are not at home.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize a combination of ambient light sensor values with motion sensors to
    identify energy wastage. For example, a scenario in which more light is recorded
    during the night when the motions are significantly low explains that you may
    have forgotten to turn off the lights during the night.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an enclosure for hardware components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like software-based features, the hardware components also require a major
    revamp if you develop a commercial-grade product. Nowadays, 3D printers have become
    viable and it is really easy to design and print plastic 3D components. You can
    also use professional 3D printing services such as Shapeways ([http://www.shapeways.com](http://www.shapeways.com)),
    Sculpteo ([http://www.sculpteo.com](http://www.sculpteo.com)), or makexyz ([http://www.makexyz.com](http://www.makexyz.com))
    for your enclosures. You can even use a laser cutter or other means of model making
    to create the hardware enclosures. These are a few hardware improvements that
    you can implement:'
  prefs: []
  type: TYPE_NORMAL
- en: The sensor and actuators that are assembled on a prototype board can be organized
    on a PCB and permanently fixed for stable and robust operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hardware enclosure for the monitoring station can make it portable and easily
    deployable in any environment. When designing this enclosure, you should also
    consider the proper placement of the motion sensor and the ambient light sensor,
    along with a button to make them accessible to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Raspberry Pi and TFT LCD screen, which make up the control center hardware,
    can also be enclosed in a mountable package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding touch screen capabilities to the TFT LCD screen can enable additional
    control over the system, expanding the UX use cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a working prototype of a remote home monitoring
    system and also learned the process of hardware product development simultaneously.
    In the project, we utilized most of the hardware components and software tools
    that we used throughout the book. We began by designing the system architecture
    so that we could coordinate the utilization of these tools. Later, we ventured
    into the actual development stages, which included designing the hardware units
    and developing programs to run these units. In the end, we provided a list of
    improvements to make this prototype into a real commercial product. You are welcome
    to use this methodology to develop your future projects and products, as you now
    have experience working with this one.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we are going to utilize the same project development methodology
    to create an interesting project that utilizes your messages from a social network
    website to give you control over your hardware.
  prefs: []
  type: TYPE_NORMAL
