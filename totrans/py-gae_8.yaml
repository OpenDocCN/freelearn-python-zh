- en: Chapter 8. Exposing a REST API with Google Cloud Endpoints
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 使用 Google Cloud Endpoints 暴露 REST API
- en: 'In [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*,
    we provided the definition of a web application, and one chapter after another,
    you learned to implement an application using App Engine. At this point, we know
    enough about the anatomy of such kinds of software to understand the differences
    between the backend and frontend components of a web application: the first provides
    logic, definition, and access to data, and the latter provides the user interface.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章. 入门")，*入门*中，我们提供了网络应用程序的定义，然后一章又一章，你学习了如何使用 App Engine
    实现应用程序。到目前为止，我们对这类软件的结构有了足够的了解，可以理解网络应用程序的后端和前端组件之间的区别：前者提供逻辑、定义和数据访问，而后者提供用户界面。
- en: We did not make a clear distinction between these two components in the previous
    chapters, and the code we wrote so far provided both the frontend and the backend
    components without too much separation. In this chapter, we will tear apart the
    frontend component of our Notes application, implementing a standalone backend
    server ready to exchange data with different clients, from mobile applications
    to rich JavaScript clients running in a browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们没有在这两个组件之间做出明确的区分，我们编写的代码到目前为止提供了前端和后端组件，而没有太多的分离。在本章中，我们将拆解我们的 Notes
    应用程序的前端组件，实现一个独立的后端服务器，准备与不同的客户端交换数据，从移动应用程序到在浏览器中运行的富 JavaScript 客户端。
- en: Once again, to implement our application, we are going to leverage some tools
    and services provided by the Google Cloud Platform, known as Google Cloud Endpoints.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了实现我们的应用程序，我们将利用 Google Cloud Platform 提供的一些工具和服务，称为 Google Cloud Endpoints。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What REST is, and designing an API for the Notes application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 REST，以及为 Notes 应用设计 API
- en: Using Cloud Endpoints to implement the REST API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cloud Endpoints 实现REST API
- en: The API explorer tool
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 探索工具
- en: Protecting the API with OAuth2
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OAuth2 保护 API
- en: Reasons to use a REST API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REST API 的原因
- en: '**Representational State Transfer** (**REST**) is a simple stateless architecture
    style usually running over the HTTP protocol. The idea behind REST is exposing
    the state of the system as a collection of resources we can manipulate, addressing
    them by their name or ID. The backend service is responsible for making a resource''s
    data persist, usually through the use of a database server. Clients retrieve the
    state of a resource performing HTTP requests to the server. The resource can be
    manipulated and sent back to the server through an HTTP request as well. Resources
    can be represented in several formats but we will use JSON, a lightweight, human-readable,
    and widespread interchange format. We can see the manipulation of a resource state
    a bit like a **Create, Retrieve, Update, Delete** (**CRUD**) system. What we are
    going to do is map each of these operations to a specific HTTP verb. We will perform
    an HTTP `POST` request to create a new resource, a `GET` request to retrieve an
    existing one, a `PUT` request to update its state, and a `DELETE` request to remove
    it from the system.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）是一种简单的无状态架构风格，通常在 HTTP 协议上运行。REST 背后的理念是将系统的状态作为我们可以操作的资源集合暴露出来，通过名称或
    ID 来寻址。后端服务负责使资源的数据持久化，通常通过使用数据库服务器来实现。客户端通过向服务器发送 HTTP 请求来检索资源的状态。资源可以通过 HTTP
    请求进行操作并返回给服务器。资源可以用几种格式表示，但我们将使用 JSON，这是一种轻量级、可读性强且广泛使用的交换格式。我们可以将资源的状态操作看作是一个
    **创建、检索、更新、删除**（**CRUD**）系统。我们将要做的是将这些操作映射到特定的 HTTP 动词。我们将通过发送 HTTP `POST` 请求来创建新的资源，通过发送
    `GET` 请求来检索现有的资源，通过发送 `PUT` 请求来更新其状态，以及通过发送 `DELETE` 请求来从系统中删除它。'
- en: REST is widely adopted these days, mainly because it allows a strong decoupling
    of clients from servers, is easy to implement over HTTP, has a very good performance,
    can be cached, and in general, can scale very well. Exposing a REST API makes
    it extremely easy to provide a mobile client, a browser extension, or any piece
    of software that needs to access and process application data; for these reasons,
    we are going to provide a REST API for Notes. Using Cloud Endpoints, we'll be
    able to add a REST API to the existing codebase of the webapp2 version of Notes
    without touching the data models or the overall architecture of the application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，REST被广泛采用，主要是因为它允许客户端和服务器之间有很强的解耦，易于在HTTP上实现，性能非常好，可以缓存，并且总的来说，可以很好地扩展。公开REST
    API使得提供移动客户端、浏览器扩展或任何需要访问和处理应用程序数据的软件变得极其容易；出于这些原因，我们将为Notes提供REST API。使用Cloud
    Endpoints，我们可以在Notes的webapp2版本现有代码库中添加REST API，而无需触及数据模型或应用程序的整体架构。
- en: Designing and building the API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和构建API
- en: Before writing the code, we need to have a neat idea in mind of the resources
    we are going to make available through the API, the methods we will provide to
    manipulate such resources, and the response codes we will deliver to the clients.
    After designing the API, we can start write some code to implement resources representation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，我们需要在心中有一个整洁的想法，即通过API提供的资源、我们将提供用于操作这些资源的方法以及我们将向客户端提供的响应代码。设计完API后，我们可以开始编写一些代码来实现资源表示。
- en: Resources, URLs, HTTP verbs, and response code
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源、URL、HTTP动词和响应代码
- en: 'Defining a resource is very similar to defining a model class in an ORM system,
    and it''s not uncommon for them to coincide, like in our case. In fact, we will
    provide the following resources:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 定义资源与在ORM系统中定义模型类非常相似，并且它们通常是一致的，就像在我们的案例中一样。实际上，我们将提供以下资源：
- en: Note
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Note
- en: NoteFile
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoteFile
- en: ChecklistItem
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChecklistItem
- en: 'Every resource will be identified by a URL. We omit the hostname here for clarity:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源都将由一个URL来标识。我们在这里省略了主机名以保持清晰：
- en: '**The** `/notes` **URL**: This identifies a collection of resources of type
    Note'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**The** `/notes` **URL**: 这标识了一个类型为Note的资源集合'
- en: '**The** `/notes/:id` **URL**: This identifies a single resource of type Note
    using its ID as the discriminator'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**The** `/notes/:id` **URL**: 这使用其ID作为区分符来标识类型为Note的单个资源'
- en: '**The** `/notefiles` **URL**: This identifies a collection of resources of
    type NoteFile'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**The** `/notefiles` **URL**: 这标识了一个类型为NoteFile的资源集合'
- en: '**The** `/notefiles/:id` **URL**: This identifies a single resource of type
    NoteFile'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**The** `/notefiles/:id` **URL**: 这标识了一个类型为NoteFile的单个资源'
- en: We won't expose the `CheckListItem` resource through the API because in the
    underlying data model, we defined the items as a `StructuredProperty` field of
    the `Note` model. Since corresponding entities don't exist in the Datastore, we
    cannot alter the state of a `ChecklistItem` resource without altering the Note
    state as well. For this reason, exposing two different resources doesn't make
    much sense.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会通过API公开`CheckListItem`资源，因为在底层数据模型中，我们将条目定义为`Note`模型的`StructuredProperty`字段。由于相应的实体在Datastore中不存在，我们不能在不更改Note状态的情况下更改`ChecklistItem`资源的状态。因此，公开两个不同的资源没有太多意义。
- en: 'A client specifies a certain HTTP verb, or method, in the request header when
    contacting the backend server, and HTTP verbs tell the server what to do with
    the data identified by the URL. We need to know that, depending on whether a URL
    represents a single resources or a collection, a verb might have different meanings.
    For the URLs exposed by our REST API, we will support the following verbs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在联系后端服务器时，在请求头中指定一个特定的HTTP动词或方法，HTTP动词告诉服务器如何处理由URL标识的数据。我们需要知道，根据URL是否代表单个资源或集合，动词可能具有不同的含义。对于我们的REST
    API公开的URL，我们将支持以下动词：
- en: '**The** `GET` **request**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**The** `GET` **request**'
- en: '**On a collection**: This retrieves a list of resource representations'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**On a collection**: 这将检索资源表示列表'
- en: '**On a single resource**: This retrieves a resource representation'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**On a single resource**: 这将检索资源表示'
- en: '**The** `POST` **request**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**The** `POST` **request**'
- en: '**On a collection**: This creates a new resource and returns its representation'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**On a collection**: 这将创建一个新的资源并返回其表示'
- en: '**On a single resource**: This is not applicable and returns an error'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**On a single resource**: 这不适用并返回错误'
- en: '**The** `PUT` **request**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**The** `PUT` **request**'
- en: '**On a collection**: This updates a list of resources in a batch and returns
    no payload'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**On a collection**: 这批量更新资源列表并返回无负载'
- en: '**On a single resource**: This updates the single resource and returns the
    updated representation'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在单个资源上**：这更新单个资源并返回更新后的表示'
- en: '**The** `DELETE` **request**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE** 请求'
- en: '**On a collection**: This is not applicable and returns an error'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在集合上**：这不适用，并返回错误'
- en: '**On a single resource**: This deletes the resources and returns no payload'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单个资源**：这将删除资源并返回无负载'
- en: 'Every time the server answers a request from a client, an HTTP status code
    is transmitted along with a possible payload. Our API will provide the following
    status codes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每当服务器响应用户的请求时，都会传输一个HTTP状态码，以及可能的负载。我们的API将提供以下状态码：
- en: '**200 OK**: This indicates that the request was successful.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200 OK**：这表示请求成功。'
- en: '**204 No Content**: This indicates that the request was successful but the
    response contains no data, usually returned after a `DELETE` request.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**204 无内容**：这表示请求成功，但响应不包含数据，通常在`DELETE`请求之后返回。'
- en: '**400 Bad Request**: This means the request was malformed; for example, the
    data did not pass validation or is in the wrong format.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**400 错误请求**：这意味着请求格式不正确；例如，数据未通过验证或格式不正确。'
- en: '**404 Not Found**: This indicates that the requested resource could not be
    found.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**404 未找到**：这表示请求的资源无法找到。'
- en: '**401 Unauthorized**: This indicates that we need to perform authentication
    before accessing the resource.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**401 未授权**：这表示在访问资源之前我们需要执行身份验证。'
- en: '**405 Method Not Allowed**: This means that the HTTP method used is not supported
    for this resource.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**405 方法不允许**：这意味着用于此资源的HTTP方法不受支持。'
- en: '**409 Conflict**: This indicates a conflict occurred when updating the state
    of the system, for example when we try to insert duplicates.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**409 冲突**：这表示在更新系统状态时发生了冲突，例如当我们尝试插入重复项时。'
- en: '**503 Service Unavailable**: This indicates that the server is temporarily
    unavailable. In particular, this occurs when our Cloud Endpoints application raises
    an uncaught exception'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**503 服务不可用**：这表示服务器暂时不可用。特别是，当我们的Cloud Endpoints应用程序抛出一个未捕获的异常时，这种情况会发生。'
- en: '**500 Internal Server Error**: This occurs when everything else has failed.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**500 内部服务器错误**：当其他所有操作都失败时发生。'
- en: Now that the design of the API is complete, it's time for us to write some code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在API的设计已经完成，是我们开始编写代码的时候了。
- en: Defining resource representations
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义资源表示
- en: We have already mentioned that both requests and responses might contain representations
    of one or more resources, and we have also stated that we will use the JSON format
    to implement such representations. Now we need to define a resource in our code,
    and Cloud Endpoints will take care of transforming our resources back and forth
    in JSON format for us. This operation is known as serialization.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，请求和响应可能包含一个或多个资源的表示，我们也已经声明我们将使用JSON格式来实现这样的表示。现在我们需要在我们的代码中定义一个资源，Cloud
    Endpoints将负责将我们的资源在JSON格式之间转换。这个操作被称为序列化。
- en: Before we start coding, we need to spend some time on the Cloud Endpoints architecture
    so that it'll be easier to understand why we use certain Python packages or data
    structures.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，我们需要花一些时间在Cloud Endpoints架构上，这样会更容易理解为什么我们使用某些Python包或数据结构。
- en: Cloud Endpoints is built on top of the Google Protocol RPC Library, a framework
    implementing **Remote Procedure Call** (**RPC**) services over the HTTP protocol.
    A service is a collection of methods that can be invoked through regular HTTP
    requests. A method receives an object of a message type in the request and returns
    another message type in response. Message types are regular Python classes deriving
    from the `protorpc.messages.Message` class, while services are methods of a Python
    class deriving from `protorpc.remote.Service` class. Since Cloud Endpoints are
    actually an RPC service under the hood, the representations of our REST resources
    will be implemented as RPC messages.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Endpoints建立在Google Protocol RPC库之上，这是一个在HTTP协议上实现远程过程调用（RPC）服务的框架。一个服务是一组可以通过常规HTTP请求调用的方法。一个方法接收请求中的消息类型对象，并返回另一个消息类型作为响应。消息类型是派生自`protorpc.messages.Message`类的常规Python类，而服务是派生自`protorpc.remote.Service`类的Python类的方法。由于Cloud
    Endpoints实际上是一个底层的RPC服务，因此我们REST资源的表示将作为RPC消息实现。
- en: 'We create a new module called `resources.py` on the application root, containing
    the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序根目录下创建了一个名为`resources.py`的新模块，包含以下代码：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Defining message classes is a bit like defining model classes in an ORM; we
    specify class attributes that correspond to each of the fields we want to use
    to represent a resource. Fields have a type, and their constructors take an integer
    parameter used as identifier that must be unique within the message class. The
    `CheckListItemRepr` class will be used to serialize the checkable items attached
    to a note. `NoteRepr` represents the note resource and is the core of our API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定义消息类有点像在ORM中定义模型类；我们指定与我们要用来表示资源的每个字段相对应的类属性。字段有一个类型，并且它们的构造函数接受一个整数参数作为标识符，该标识符必须在消息类中是唯一的。`CheckListItemRepr`类将用于序列化附加到笔记上的可检查项。`NoteRepr`表示笔记资源，并且是我们API的核心。
- en: We need a `key` field so that clients can have a reference if they want to get
    details or modify the resource. The `checklist_items` field references the `CheckListItemRepr`
    class, which will be nested into note representations. We represent the files
    associated with a note as a list of strings called `files`, containing keys for
    `models.NoteFile` instances. Finally, we define a representation for a collection
    of notes called `NoteCollection`. It has only one field, `items`, containing single-note
    representations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`key`字段，以便客户端在需要获取详细信息或修改资源时有一个参考。`checklist_items`字段引用`CheckListItemRepr`类，它将嵌套到笔记表示中。我们将与笔记关联的文件表示为一个名为`files`的字符串列表，其中包含`models.NoteFile`实例的键。最后，我们定义了一个名为`NoteCollection`的笔记集合表示。它只有一个字段，即`items`，包含单个笔记表示。
- en: 'Once serialized, a JSON representation of a note should look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦序列化，笔记的JSON表示应该看起来像这样：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, the JSON representation is very easy to read.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，JSON表示非常易于阅读。
- en: Now that we have representations for our REST resources, we can start implementing
    the endpoints for our REST API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们REST资源的表示，我们可以开始实现REST API的端点。
- en: Implementing API endpoints
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现API端点
- en: 'As we already mentioned, our REST API will be integrated with the existing
    App Engine application without altering its behavior, so we need to specify a
    new WSGI application that will handle the URLs we map to the API endpoints. Let''s
    start with the `app.yaml` file, where we add the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们的REST API将与现有的App Engine应用程序集成，而不会改变其行为，因此我们需要指定一个新的WSGI应用程序来处理我们映射到API端点的URL。让我们从`app.yaml`文件开始，其中我们添加以下代码：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The regular expression that matches API URLs is actually `/_ah/spi/.*`. Even
    if we perform requests to an URL such as `https://example.com/_ah/api/v1/an-endpoint`,
    Cloud Endpoints will take care of the proper redirects. The handler script of
    the API URLs points to the `app` variable in the `notes_api` module, which we
    are yet to create. In a new file called `notes_api.py`, we add the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配API URL的正则表达式实际上是`/_ah/spi/.*`。即使我们向类似于`https://example.com/_ah/api/v1/an-endpoint`的URL发出请求，Cloud
    Endpoints也会负责适当的重定向。API URL的处理脚本指向`notes_api`模块中的`app`变量，我们尚未创建。在一个名为`notes_api.py`的新文件中，我们添加以下代码：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the very basic scaffold for our REST API. Now we need to define the
    endpoints as methods of a Python class deriving from `protorpc.remote.Service`
    class, and append this class to the list that was passed as a parameter to the
    `api_server()` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的REST API的非常基本的框架。现在我们需要定义端点作为从`protorpc.remote.Service`类派生的Python类的成员方法，并将此类附加到传递给`api_server()`函数的参数列表中。
- en: 'In the `notes_api.py` module, we add the `NotesApi` class, which will contain
    all the endpoints needed to retrieve and manipulate note resources. Let''s see
    how to implement the endpoints operating on collections of notes, one at a time,
    starting from the endpoint supporting `GET` requests:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`notes_api.py`模块中，我们添加了`NotesApi`类，它将包含所有用于检索和操作笔记资源的端点。让我们看看如何实现操作笔记集合的端点，一次一个，从支持`GET`请求的端点开始：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The decorator we apply to the `NotesApi` class, the `@endpoints.api` decorator,
    tells Cloud Endpoints that this class is a part of an API called `notes` with
    version v1\. The `note_list()` method is decorated with the `@endpoints.method`
    decorator, and this method expects the following parameters, in the order given:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用到`NotesApi`类的装饰器，即`@endpoints.api`装饰器，告诉Cloud Endpoints这个类是名为`notes`的API的一部分，版本为v1。`note_list()`方法被`@endpoints.method`装饰器装饰，并且这个方法期望以下参数，按照给出的顺序：
- en: The message class used for the request. In this case, we don't expect any input,
    so we use, `message_types.VoidMessage`, a special message class provided by Cloud
    Endpoints.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于请求的消息类。在这种情况下，我们不期望任何输入，所以我们使用 `message_types.VoidMessage`，这是 Cloud Endpoints
    提供的一个特殊消息类。
- en: The message class we will return in the response, in this case our `resources.NoteCollection`
    class.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在响应中返回的消息类，在这种情况下是我们的 `resources.NoteCollection` 类。
- en: The URL or path of the endpoint.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点的 URL 或路径。
- en: The HTTP method or verb supported by the endpoint.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端点支持的 HTTP 方法或动词。
- en: A string representing the name of the endpoint.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表示端点名的一个字符串。
- en: The logic of the endpoint is simple—we load all the Note instances from the
    Datastore, and for each of them, we build a `NoteRepr` object. Representations
    are then added to a collection using the `NoteCollection` class and returned to
    the client.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 端点的逻辑很简单——我们从 Datastore 加载所有笔记实例，并为每个实例构建一个 `NoteRepr` 对象。然后使用 `NoteCollection`
    类将这些表示添加到集合中，并将其返回给客户端。
- en: 'Now we add the endpoint supporting requests of the `POST` type:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加支持 `POST` 类型请求的端点：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We name the method `note_create()` to better describe its semantics. It expects
    a `NoteRepr` message in the request containing the information to create a new
    resource, and will return a `NoteRepr` message in the response containing the
    resource created. The `new_resource` parameter contains the `NoteRepr` instance
    that arrived in the request and is used to build a new `Note` entity in the Datastore.
    We need to pass a user as the owner of the note, so we call the `get_current_user`
    method from the endpoints package. We will see later in the chapter how users
    can authenticate to use our API. After calling the `PUT` type, we can access the
    key of the newly created entity, so we update the `new_resource` message fields
    and return it to the client.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将方法命名为 `note_create()` 以更好地描述其语义。它期望请求中包含创建新资源信息的 `NoteRepr` 消息，并将返回一个包含已创建资源的
    `NoteRepr` 消息。`new_resource` 参数包含请求中到达的 `NoteRepr` 实例，并用于在 Datastore 中构建一个新的 `Note`
    实体。我们需要传递一个用户作为笔记的所有者，因此我们调用 endpoints 包中的 `get_current_user` 方法。我们将在本章的后面部分看到用户如何通过我们的
    API 进行身份验证。在调用 `PUT` 类型后，我们可以访问新创建实体的键，因此我们更新 `new_resource` 消息字段并将其返回给客户端。
- en: 'Here is the code for the endpoint supporting requests of the `PUT` type:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是支持 `PUT` 类型请求的端点的代码：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The method is called `note_batch_update()` because it's supposed to perform
    updates on a collection of resources received in the request, returning no payload
    to the clients. It expects a `NoteCollection` message class in the input, and
    after performing all the updates needed, it returns a `VoidMessage` instance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法被命名为 `note_batch_update()`，因为它应该对请求中接收到的资源集合执行更新，不向客户端返回任何有效载荷。它期望输入中有一个
    `NoteCollection` 消息类，并在执行所有必要的更新后返回一个 `VoidMessage` 实例。
- en: 'The last endpoint operating on a collection of notes is actually a handler
    for an error condition. In fact, performing a `DELETE` request on a collection
    should result in an **HTTP error 405: method not allowed** message. To respond
    to an API call with an error code, we can just raise a proper exception in the
    Python method implementing the endpoint:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记集合上操作的最后一个端点实际上是一个错误条件的处理器。实际上，在集合上执行 `DELETE` 请求应该导致一个 **HTTP 错误 405：不允许的方法**
    消息。为了响应带有错误代码的 API 调用，我们只需在实现端点的 Python 方法中抛出一个适当的异常：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `note_list_delete()` method just raises an exception that we still have
    to define. In a new `errors.py` module in our application, we add the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`note_list_delete()` 方法只是抛出一个我们仍然需要定义的异常。在我们的应用程序中，我们添加一个新的 `errors.py` 模块，并添加以下内容：'
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to define our own `MethodNotAllowed` exception because Cloud Endpoints
    only provides exception classes for the most common HTTP error codes: `400`, `401`,
    `403`, `404`, and `500`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义自己的 `MethodNotAllowed` 异常，因为 Cloud Endpoints 只提供了最常见的 HTTP 错误代码的异常类：`400`、`401`、`403`、`404`
    和 `500`。
- en: 'The portion of the REST API operating on a collection of resources of type
    `note` is now complete, so we can move on and start implementing the endpoints
    operating on a single note. The path to single resources contains an argument,
    the resource identifier. In such cases, as well as when there''s the need to pass
    query string arguments, we cannot use a simple `Message` class for the request,
    but we must use a special container, defined in the `endpoints.ResourceContainer`
    parameter, that wraps both the message and the arguments in the path and in the
    query string. In our case, since we''re going to use the container more than once,
    we can define it as a field of our `NotesApi` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`note`类型资源集合上操作的REST API部分现在已经完成，因此我们可以继续并开始实现操作单个笔记的端点。单个资源的路径包含一个参数，即资源标识符。在这种情况下，以及当需要传递查询字符串参数时，我们不能使用简单的`Message`类来处理请求，而必须使用一个特殊的容器，该容器定义在`endpoints.ResourceContainer`参数中，它将消息和路径中的参数以及查询字符串中的参数包装在一起。在我们的例子中，由于我们将多次使用该容器，我们可以将其定义为`NotesApi`类的字段：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We pass the message we want to wrap to the constructor, along with the arguments
    we need to receive through the request path or in the query string. Each argument
    must be defined as a message field with a unique identifier.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要包装的消息及其通过请求路径或查询字符串接收的参数传递给构造函数。每个参数都必须定义为具有唯一标识符的消息字段。
- en: 'We then proceed to define the endpoint that handles `GET` requests for a single-note
    resource:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来定义处理单个资源`GET`请求的端点：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We expect the `NoteRequestContainer` parameter in the input for our endpoint,
    `note_get()`, that will return a `NoteRepr` message. The path contains the `{key}`
    argument, and whenever the requested URL matches, Cloud Endpoint will fill the
    corresponding `key` field in the `NoteRequestContainer` instance with the parsed
    value. We then use the key of the resource to retrieve the corresponding entity
    from the Datastore, and finally fill and return a `NoteRepr` message object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在端点`note_get()`的输入中有一个`NoteRequestContainer`参数，它将返回一个`NoteRepr`消息。路径包含`{key}`参数，每当请求的URL匹配时，Cloud
    Endpoint将填充`NoteRequestContainer`实例中的相应`key`字段，并解析其值。然后我们使用资源的键从Datastore检索相应的实体，并最终填充并返回一个`NoteRepr`消息对象。
- en: 'We raise an error when clients make requests of type `POST` on a single resource,
    so the endpoint is implemented as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端对单个资源发出`POST`类型请求时，我们抛出一个错误，因此端点实现如下：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `note_update()` method retrieves the `note` entity from the Datastore and
    updates its fields accordingly with the content of the request. Finally, the method
    returns a representation of the updated resource.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`note_update()`方法从Datastore检索`note`实体，并根据请求的内容相应地更新其字段。最后，该方法返回更新资源的表示。'
- en: 'The last method we need to support for a single resource is `DELETE`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个资源，我们需要支持的最后一个方法是`DELETE`：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The endpoint takes a request container, deletes the corresponding Datastore
    entity, and returns an empty payload if everything is fine.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 端点接收一个请求容器，删除相应的Datastore实体，如果一切正常，则返回一个空的有效载荷。
- en: We finally have a complete REST API to deal with note entities. Now it's time
    to play with it and check whether the results are as we expect.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终拥有一个完整的REST API来处理笔记实体。现在是时候玩玩它并检查结果是否符合我们的预期。
- en: Testing the API with API Explorer
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API Explorer测试API
- en: We can test our REST API on the local development environment by running the
    `dev_appserver.py` script or deploying the application on App Engine. In both
    cases, Cloud Endpoints provides a tool that let us explore our API; let's see
    how.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`dev_appserver.py`脚本或在App Engine上部署应用程序来在本地开发环境中测试我们的REST API。在这两种情况下，Cloud
    Endpoints提供了一个工具，允许我们探索我们的API；让我们看看如何。
- en: 'With the local development server running, we point the browser to the `http://localhost:8080/_ah/api/explorer`
    URL, and we are immediately redirected to the API Explorer, where we can see our
    API listed, as shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当本地开发服务器正在运行时，我们将浏览器指向`http://localhost:8080/_ah/api/explorer` URL，我们立即被重定向到API
    Explorer，在那里我们可以看到我们的API被列出，如下面的截图所示：
- en: '![Testing the API with API Explorer](img/8194OS_08_01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![使用API Explorer测试API](img/8194OS_08_01.jpg)'
- en: When we click on our API name, the explorer lists all the endpoints exposed
    through the Cloud Endpoints service. Before we begin our test, we should ensure
    that some notes exist in the Datastore. We can use the Notes web application to
    insert them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击我们的API名称时，探索器列出了通过Cloud Endpoints服务公开的所有端点。在我们开始测试之前，我们应该确保Datastore中存在一些笔记。我们可以使用Notes网络应用程序来插入它们。
- en: By clicking on the notes **List** entry, we can access the details page for
    the endpoint, where we can click on the **Execute** button to perform a `GET`
    request and retrieve a collection of notes visible in the **Response** section,
    represented in JSON format. We can also copy the **key** field of one of the notes
    in the collection and access the details page for the `notesDetail` endpoint.
    Here, we paste the key on the **key** field in the form and then press **Execute**
    button. This time, the response should contain the resource representation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**笔记列表**条目，我们可以访问端点的详细信息页面，在那里我们可以点击**执行**按钮来执行`GET`请求并检索在**响应**部分可见的笔记集合，以JSON格式表示。我们还可以复制集合中笔记的**键**字段，并访问`notesDetail`端点的详细信息页面。在这里，我们在表单的**键**字段中粘贴键，然后按**执行**按钮。这次，响应应该包含资源表示。
- en: To see how to update this resource, we access the details page for the `notesUpdate`
    endpoint. Here, we can again paste the key of the resource we want to update and
    build a request body with the **Request body** editor, a very powerful tool that
    let us compose complex JSON objects by just pointing and clicking on some HTML
    controls.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何更新此资源，我们访问`notesUpdate`端点的详细信息页面。在这里，我们可以再次粘贴我们想要更新的资源的键，并使用**请求体**编辑器构建请求体，这是一个非常强大的工具，它允许我们通过仅指向和点击一些HTML控件来组合复杂的JSON对象。
- en: '![Testing the API with API Explorer](img/8194OS_08_02.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![使用API探索器测试API](img/8194OS_08_02.jpg)'
- en: .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: The API Explorer is of great help while developing an API to immediately see
    the results of a call to an endpoint, test endpoints with particular payloads
    in the request, and check the behavior of different versions of the same API.
    We could also use other clients to test our API, such as the `curl` program from
    the command line, but the interactivity granted by the API Explorer is a great
    value added.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: API探索器在开发API时非常有帮助，可以立即看到对端点的调用结果，测试具有特定有效负载的端点，并检查同一API不同版本的行为。我们也可以使用其他客户端来测试我们的API，例如命令行中的`curl`程序，但API探索器提供的交互性是一个巨大的增值。
- en: In the next paragraph, we will see another functionality of the API Explorer
    that will make our lives much easier—the opportunity to test our API with a client
    authenticated with OAuth2.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一段中，我们将看到API探索器的另一个功能，这将使我们的生活变得更加容易——有机会使用通过OAuth2认证的客户端测试我们的API。
- en: Protecting an endpoint with OAuth2
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth2保护端点
- en: 'Even if our REST API seems quite complete, a critical component is missing
    in our implementation: any client in fact is currently able to retrieve all the
    notes stored in the Datastore without providing authentication and regardless
    of being or not the owner of those notes. Moreover, until we don''t provide authentication
    for our REST API, creating a note will be impossible because we need an authenticated
    user to create an entity in the `note_create()` method of the `NotesApi` class.
    We can easily fill this gap in our requirements because Cloud Endpoints provides
    support to protect all or part of our API with the OAuth2 authorization framework.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的REST API看起来相当完整，但在我们的实现中仍缺少一个关键组件：实际上任何客户端目前都能在不提供身份验证的情况下检索存储在Datastore中的所有笔记，无论这些笔记的所有者是否是客户端。此外，直到我们为我们的REST
    API提供身份验证之前，创建笔记将是不可能的，因为我们需要在`NotesApi`类的`note_create()`方法中需要一个经过身份验证的用户来创建实体。我们可以很容易地填补这个需求缺口，因为Cloud
    Endpoints提供了使用OAuth2授权框架保护我们API全部或部分的支持。
- en: 'The first step to provide protection to our API is to specify which clients
    we allow to access the API. Here, we use the term "client" to actually identify
    a type of client, such as a JavaScript application running in a browser, a mobile
    application running on Android or iOS, and so on. Each client is identified with
    a string called client ID that we must generate using the Developer console:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的API提供保护的第一步是指定允许访问API的客户端。在这里，我们使用“客户端”一词实际上来识别一种客户端类型，例如在浏览器中运行的JavaScript应用程序、在Android或iOS上运行的移动应用程序等等。每个客户端都有一个称为客户端ID的字符串来标识，我们必须使用开发者控制台生成它：
- en: On the left menu, choose **APIs & auth**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，选择**APIs & auth**。
- en: Select **credentials**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**credentials**。
- en: Click on the **Create new Client ID** button.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建新的Client ID**按钮。
- en: A guided procedure is then started, and all we have to do to generate a new
    client ID is follow the instructions on the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将启动一个引导程序，我们只需遵循屏幕上的说明即可生成新的客户端ID。
- en: 'We then specify the list of authorized client IDs with the `@endpoints.api`
    decorator of our `NotesApi` class, like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`NotesApi`类的`@endpoints.api`装饰器指定授权的客户端ID列表，如下所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To access the API from the explorer, we also list its client ID, which is provided
    by the `endpoints` package. Since the client IDs are listed inside the Python
    source code, we have to remember that we need to redeploy the application every
    time we change the `allowed_client_ids` list.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要从探索器访问 API，我们也列出其客户端 ID，该 ID 由 `endpoints` 包提供。由于客户端 ID 列在 Python 源代码中，我们必须记住，每次我们更改
    `allowed_client_ids` 列表时，都需要重新部署应用程序。
- en: 'If we add an Android application to the list of allowed client IDs, we must
    also specify the audience parameter in the `@endpoints.api` decorator. The value
    of this parameter is the same as that of the client ID:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 Android 应用程序添加到允许的客户端 ID 列表中，我们必须也在 `@endpoints.api` 装饰器中指定受众参数。此参数的值与客户端
    ID 相同：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last configuration step is the declaration of the OAuth2 scopes we want
    a client to provide in order to access our API. For our Notes API, we will require
    only the `endpoints.EMAIL_SCOPE` class, the minimum required by Cloud Endpoints
    to provide OAuth2 authentication and authorization. We add the following to the
    list of parameters we pass to the `@endpoints.api` decorator:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的配置步骤是声明我们希望客户端提供的 OAuth2 范围，以便访问我们的 API。对于我们的 Notes API，我们只需要 `endpoints.EMAIL_SCOPE`
    类，这是 Cloud Endpoints 提供OAuth2 认证和授权所需的最小范围。我们将以下内容添加到传递给 `@endpoints.api` 装饰器的参数列表中：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From now on, the Cloud Endpoints framework will automatically authenticate users
    and enforce the list of allowed clients, providing a valid `User` instance to
    our application if the authentication procedure succeeds. To retrieve the authenticated
    user, we call the `endpoints.get_current_user()` function the same way as we did
    in the `create_note()` endpoint method. If the authentication procedure fails,
    the `get_current_user()` function returns the `None` parameter. It's up to our
    code to check whether the current user is valid inside the methods we want to
    protect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，Cloud Endpoints 框架将自动验证用户并强制执行允许的客户端列表，如果认证过程成功，将为我们的应用程序提供一个有效的 `User`
    实例。要检索已认证的用户，我们以与在 `create_note()` 端点方法中相同的方式调用 `endpoints.get_current_user()`
    函数。如果认证过程失败，`get_current_user()` 函数返回 `None` 参数。检查当前用户是否有效是我们代码的责任，在我们要保护的各个方法中。
- en: 'For example, we can add the following security check at the very beginning
    of the `note_list()` method in our `NotesApi` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在 `NotesApi` 类的 `note_list()` 方法开头添加以下安全检查：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, if we open the API Explorer and try to perform a `GET` request on the
    `notesList` endpoint, we will get this response:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开 API 探索器并尝试对 `notesList` 端点执行 `GET` 请求，我们将得到以下响应：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Thanks to the API Explorer, we can authenticate ourselves with OAuth2 and try
    to access the same endpoint to check whether we are allowed this time. Staying
    on the page where we used to perform the failed request, we can see on the top-right
    corner of the API Explorer interface a switch labeled **Authorize requests using
    OAuth 2.0**. If we click on it, the explorer will start the authorization procedure
    using OAuth2 with one of our Google accounts, and once it is finished, we will
    be able to perform the request without authentication errors again.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 API 探索器，我们可以使用 OAuth2 进行认证并尝试访问相同的端点，以检查我们这次是否被允许。停留在我们之前执行失败请求的页面上，我们可以在
    API 探索器界面的右上角看到一个标签为 **使用 OAuth 2.0 授权请求** 的开关。如果我们点击它，探索器将使用我们的一个 Google 账户启动
    OAuth2 授权过程，一旦完成，我们就可以再次执行请求而不会出现认证错误。
- en: Besides having authentication in place, now we can also filter Datastore queries
    using the user instance so that each user can only access their own data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置认证之外，现在我们还可以使用用户实例过滤 Datastore 查询，这样每个用户就只能访问他们自己的数据。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this final chapter, we took an in-depth look at the Cloud Endpoints framework,
    and you now have the skills needed to complete the REST API and potentially support
    a wide variety of clients: someone could write an Android version of Notes, some
    other might provide a porting on iOS. We can write a JavaScript client and deliver
    it as a Chrome or Firefox application through their respective marketplaces.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们深入探讨了 Cloud Endpoints 框架，你现在拥有了完成 REST API 以及可能支持各种客户端所需的技能：有人可以编写
    Notes 的 Android 版本，其他人可能提供 iOS 的移植。我们可以编写一个 JavaScript 客户端，并通过它们各自的市场交付为 Chrome
    或 Firefox 应用程序。
- en: You learned about REST in brief and why you should choose it among other solutions
    to talk with miscellaneous clients. We accurately designed our API, providing
    a comprehensive set of endpoints to retrieve and manipulate resources in our application.
    We finally implemented the code and played with the API using the API Explorer,
    an interactive exploring tool capable of executing API methods, showing request
    and response data, and authenticating the client.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您简要了解了REST，以及为什么您应该在众多解决方案中选择它来与各种客户端通信。我们精心设计了我们的API，提供了一套全面的端点来检索和操作我们应用程序中的资源。我们最终实现了代码，并使用API
    Explorer（一个能够执行API方法、显示请求和响应数据以及验证客户端的交互式探索工具）来玩转API。
- en: REST is a language used in many places on the Internet, and thanks to the Cloud
    Endpoints, we have the opportunity to easily provide a modern and powerful API
    for every web application running on App Engine.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种在互联网上许多地方使用的语言，多亏了Cloud Endpoints，我们有机会为在App Engine上运行的每个Web应用程序轻松提供现代且强大的API。
- en: I hope you have enjoyed this book as much as I've enjoyed writing it, and whether
    your next Python application will be running on Google App Engine or not, I hope
    this book has helped you in making that decision.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您像我写作这本书一样喜欢它，无论您的下一个Python应用程序是否将在Google App Engine上运行，我都希望这本书能帮助您做出那个决定。
