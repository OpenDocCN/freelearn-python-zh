<html><head></head><body>
		<div><h1 id="_idParaDest-225" class="chapter-number"><a id="_idTextAnchor239"/>12</h1>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor240"/>Deployment Basics – Git, GitHub, and AWS</h1>
			<p>It’s nice to develop an application with a functioning backend and a nice, flexible frontend on your machine. Still, if you want your application to be used publicly, you need to deploy the application to production. From this chapter to the last one, you will learn how to prepare the application we’ve built for deployment, deploy the backend on <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>) and the frontend on Vercel, and finally, go through some security and performance optimizations.</p>
			<p>In this chapter, we will learn deployment basics such as jargon and concepts to understand before going further. We will be learning about the following topics:</p>
			<ul>
				<li>Basics of software deployment</li>
				<li>Tools and methods of web application deployment</li>
				<li>Platforms for web application deployment</li>
			</ul>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor241"/>Technical requirements</h1>
			<p>For this chapter, you will need to have Git installed on your machine. If you are on Linux or macOS, it will come by default. You can check its existence with the following command in the terminal:</p>
			<pre class="console">
git –version</pre>
			<p>Otherwise, feel free to download the right version at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</p>
			<p>After the installation, let’s configure Git if not done yet. In a terminal, enter the following configuration commands to set the username (usually the username on your GitHub account) and the email address (usually the email address on your GitHub account):</p>
			<pre class="console">
git config --global user.name "username"
git config --global user.email "email@address.com"</pre>
			<p>You will also need an active GitHub account. You can register on the official website at <a href="https://github.com/">https://github.com/</a>. As we will also be deploying the application on a remote AWS server, you will need an AWS account that can be created at <a href="https://portal.aws.amazon.com/billing/signup">https://portal.aws.amazon.com/billing/signup</a>. If you don’t have an AWS account, you can still use any <strong class="bold">virtual private server</strong> (<strong class="bold">VPS</strong>) or <strong class="bold">virtual private cloud</strong> (<strong class="bold">VPC</strong>) you have online. However, this chapter will also document how to create a VPC instance using AWS and how to upload the code and serve the Django API.</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor242"/>Basics of software deployment</h1>
			<p><strong class="bold">Software deployment</strong> concerns <a id="_idIndexMarker682"/>all the activities that make a software system available to consumers. The term <em class="italic">software deployment</em> is also commonly described as application deployment. Following the best software deployment practices will ensure that all applications deployed operate smoothly and work as expected.</p>
			<p>There are several <a id="_idIndexMarker683"/>benefits of software deployment, such as:</p>
			<ul>
				<li><strong class="bold">Saved time</strong>: A good software deployment process can be configured to only take a few minutes. This saves time for compiling and distribution to the users.</li>
				<li><strong class="bold">Increased security</strong>: Deploying your application in a structured manner rather than doing it manually or for individual users means you ensure the security of the application and not only the security of the application on every user’s device.</li>
				<li><strong class="bold">Better monitoring</strong>: Deploying an application on production servers helps provide more control and data on what is working from the user’s end.</li>
			</ul>
			<p>With software deployment defined, we will dive deeper into the tools and methods used for web application deployment.</p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor243"/>Tools and methods of web application deployment</h1>
			<p>Deploying a <a id="_idIndexMarker684"/>web application for production has drastically evolved over the years. From manual deployment to automated deployment techniques, web application deployment has advanced, making the process more secure, smooth, and as fast as possible. There are many tools for web application deployment, but in <a id="_idIndexMarker685"/>this book, we will focus on the automated tools and configure the Django project and the React project for automated deployments when pushes are made on the remote repository of the code.</p>
			<p>But where will the code be pushed first? Let’s start describing and learning how to use the tools for our full stack application deployment, starting with Git and GitHub.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor244"/>Using Git and GitHub</h2>
			<p>Git is <a id="_idIndexMarker686"/>a <a id="_idIndexMarker687"/>popular tool used for source code version control and collaboration. It not only helps the user keep track of changes made to the code but also allows developers to work through small or large code bases, with collaboration made easier. In the following subsections, we will initialize a Git repository in the backend project, commit the changes, and then push the changes to a remote repository on GitHub.</p>
			<h3>Creating a Git repository</h3>
			<p>Open a <a id="_idIndexMarker688"/>new terminal in the directory where you created the Django project and enter the following command:</p>
			<pre class="console">
git init</pre>
			<p>This command will create an empty <code>.git/</code> directory in the current directory: this is a Git repository. This repository tracks all changes made to files in the project, helping build a history of changes made, with details on the files changed, the name of the person making the changes, and much more information.</p>
			<p>After the initialization, we will need to ignore some files in the project. We are talking about files such as <code>.pycache</code>, <code>.env</code>, and the virtual environment directories. After all, we don’t want important information such as secret environment variables to be available in the project or useless cache files to be present in the changes.</p>
			<p>Inside the directory of the Django API, create a new file called <code>.gitignore</code>. This file tells Git which files and directories to ignore when tracking changes:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">.gitignore</p>
			<pre class="source-code">
__pycache__
venv
env
.env</pre>
			<p>These files<a id="_idIndexMarker689"/> and directories in the preceding code will be ignored. Next, we will add the change in the directory to the staging area. The staging area allows you to group related changes before committing them to the project history. As we have successfully added a <code>.gitignore</code> file, we can freely run the <code>git </code><code>add</code> command:</p>
			<pre class="console">
git add .</pre>
			<p>The dot (<code>.</code>) at the end of the command tells Git to only look for changed files in the current directory. To have a look at the changes to be committed to the Git history, run the following command:</p>
			<pre class="console">
git status</pre>
			<p>The <code>git status</code> command is used to show the state of the working directory and also the staging area. Using the command, you can see changes that are tracked or not. The following figure shows an example of the output you should have:</p>
			<div><div><img src="img/Figure_12.1_B18821.jpg" alt="Figure 12.1 – Running the git status command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Running the git status command</p>
			<p>We can now run the <code>git commit</code> command. A commit is an operation that writes the latest changes of the source code to the version control system history. In our case, with <code>git commit</code> command will save the changes to the local repository:</p>
			<pre class="console">
git commit</pre>
			<p>The preceding command will prompt you to a text editor in the terminal or an app, depending on your system. Either way, you will need to enter a message. It’s important to enter a <a id="_idIndexMarker690"/>meaningful message because this message will be shown in the history of changes made to the source code. You can enter the following line if you want:</p>
			<pre class="source-code">
Initialize git in API project</pre>
			<p>After saving the message, you can check the Git history with the <code>git </code><code>log</code> command:</p>
			<pre class="console">
git log</pre>
			<p>You will have something similar to the following figure:</p>
			<div><div><img src="img/Figure_12.2_B18821.jpg" alt="Figure 12.2 – Writing a commit message"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Writing a commit message</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Writing meaningful commit messages is important, particularly in a team or a collaborative environment. You can read more about commit messages at <a href="https://www.conventionalcommits.org/en/v1.0.0/">https://www.conventionalcommits.org/en/v1.0.0/</a>.</p>
			<p>The project <a id="_idIndexMarker691"/>repository has been initialized locally; however, we want the code on GitHub. The next section will show you how to upload your code on GitHub.</p>
			<h3>Uploading code on GitHub</h3>
			<p>GitHub<a id="_idIndexMarker692"/> is a <a id="_idIndexMarker693"/>code <a id="_idIndexMarker694"/>hosting platform for collaboration and version control. It helps developers around the world work together on projects and is actually the code hosting platform for the majority of popular open source projects.</p>
			<p>On your GitHub account dashboard, on the navigation bar, create a new repository:</p>
			<div><div><img src="img/Figure_12.3_B18821.jpg" alt="Figure 12.3 – Creating a repository on GitHub"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Creating a repository on GitHub</p>
			<p>Once it’s <a id="_idIndexMarker695"/>done, you will be redirected to a new page to enter basic information about the repository, such <a id="_idIndexMarker696"/>as the name of the repository and a description, stating if the repository is public or private, and adding a license or a <code>.gitignore</code> file. The repository name is required, and the other pieces of information are optional.</p>
			<p>You can now create the repository, and you will have a similar page to this:</p>
			<div><div><img src="img/Figure_12.4_B18821.jpg" alt="Figure 12.4 – Repository created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Repository created</p>
			<p>We have an existing repository, and we want to push it to the GitHub platform. Let’s follow the steps for <strong class="bold">…or push an existing repository from the command line</strong>. Inside the directory of your backend project, open a new terminal, and let’s enter the shell commands:</p>
			<pre class="console">
git remote add origin your_repository_git_url</pre>
			<p>The <code>git remote</code> command allows you to create, view, and delete connections to Git repositories hosted on the internet or another network. In the preceding command, we are adding a <a id="_idIndexMarker697"/>remote repository URL of the GitHub repository. Let’s change the name of the branch we are working on:</p>
			<pre class="console">
git branch -M main</pre>
			<p>By default, when a repository is created using Git on a local machine, the branch of work is called master. What is a branch in Git?</p>
			<p>Well, it is <a id="_idIndexMarker698"/>just a separate version of the main repository. This allows multiple developers to work on the same project. For example, if you are working with a backend developer who wants to add support for file uploading on posts and comments, instead of working directly on the main branch, the developer can create a new branch (<code>feature/images-post</code>) from the main branch. After the work is done on this branch, the <code>feature/images-post</code> branch can be merged with the main branch.</p>
			<p>With the main branch created, we can now push the changes to GitHub:</p>
			<pre class="console">
git push -u origin main</pre>
			<p>The <code>git push</code> command is used to upload local repository changes on the source code to a remote repository. In your case, the command will push the current code to your GitHub repository URL.</p>
			<p>Reload the repository page on GitHub, and you will see something similar to this:</p>
			<div><div><img src="img/Figure_12.5_B18821.jpg" alt="Figure 12.5 – Code pushed to the repository"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Code pushed to the repository</p>
			<p>And voilà! We <a id="_idIndexMarker699"/>have the code <a id="_idIndexMarker700"/>uploaded on GitHub. But this is just the code. What if you can have this running on a remote server that you can access from anywhere?</p>
			<p>Let’s talk about platforms for web application deployment and deploy the Django backend on AWS.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor245"/>Platforms for web application deployment</h2>
			<p>With<a id="_idIndexMarker701"/> the complexity of software development increasing and more innovative and data-intensive applications evolving or being created every year, there has been an explosion of services to allow teams to deploy their products on the internet and scale them with ease. This has created a new kind of service called cloud computing: the on-demand delivery of IT resources over the internet with pay-as-you-go model pricing.</p>
			<p>In this book, we will deploy the <a id="_idIndexMarker702"/>backend on AWS, mostly on an <strong class="bold">Elastic Compute Cloud</strong> (<strong class="bold">EC2</strong>) instance, which is just a fancy name for a VPS. Well, actually, an AWS EC2 instance is a virtual server in Amazon’s EC2 for running web applications. Let’s start by creating the AWS server.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The following steps can work for any VPS, not just for an AWS VPS. If you can’t create a VPS on AWS, you can see other solutions such as Linode, <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>), Azure, or IBM. They<a id="_idIndexMarker703"/> provide free credit you can use for learning about their services.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor246"/>Creating an EC2 instance</h2>
			<p>Follow<a id="_idIndexMarker704"/> these steps to create an <a id="_idIndexMarker705"/>EC2 instance:</p>
			<ol>
				<li>Make sure to be logged in to your AWS account. On the dashboard, open the EC2 console:</li>
			</ol>
			<div><div><img src="img/Figure_12.6_B18821.jpg" alt="Figure 12.6 – Accessing the EC2 console"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Accessing the EC2 console</p>
			<ol>
				<li value="2">On the EC2 console, launch a new instance:</li>
			</ol>
			<div><div><img src="img/Figure_12.7_B18821.jpg" alt="Figure 12.7 – Creating an EC2 instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Creating an EC2 instance</p>
			<p>You will <a id="_idIndexMarker706"/>be shown a<a id="_idIndexMarker707"/> page where you will have to configure the instance.</p>
			<ol>
				<li value="3">Enter the name of the instance:</li>
			</ol>
			<div><div><img src="img/Figure_12.8_B18821.jpg" alt="Figure 12.8 – Naming the EC2 instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Naming the EC2 instance</p>
			<ol>
				<li value="4">The next step is to choose an operating system. We will use <strong class="bold">Ubuntu Server 22.04 LTS</strong> for<a id="_idIndexMarker708"/> the <strong class="bold">Amazon Machine </strong><strong class="bold">Image</strong> (<strong class="bold">AMI</strong>):</li>
			</ol>
			<div><div><img src="img/Figure_12.9_B18821.jpg" alt="Figure 12.9 – Choosing an operating system on the EC2 instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Choosing an operating system on the EC2 instance</p>
			<p>We are using Ubuntu here because of its security, versatility, and the policy of regular updates. However, feel free to use any other Linux distros you are familiar with.</p>
			<ol>
				<li value="5">And finally, you <a id="_idIndexMarker709"/>will need <a id="_idIndexMarker710"/>to set the instance <a id="_idIndexMarker711"/>type and create a pair of keys for <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) login. After that, you can launch the instance:</li>
			</ol>
			<div><div><img src="img/Figure_12.10_B18821.jpg" alt="Figure 12.10 – Launching the instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – Launching the instance</p>
			<ol>
				<li value="6">Wait a<a id="_idIndexMarker712"/> moment, and<a id="_idIndexMarker713"/> the instance will be created:</li>
			</ol>
			<div><div><img src="img/Figure_12.11_B18821.jpg" alt="Figure 12.11 – Instance created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Instance created</p>
			<ol>
				<li value="7">Click on the <strong class="bold">View all instances</strong> button, and you will see the created Postagram instance.</li>
				<li>Click on the checkbox next to the name of the instance and click the <strong class="bold">Connect</strong> button:</li>
			</ol>
			<div><div><img src="img/Figure_12.12_B18821.jpg" alt="Figure 12.12 – Connecting to an EC2 instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Connecting to an EC2 instance</p>
			<p>This will redirect <a id="_idIndexMarker714"/>you to a page <a id="_idIndexMarker715"/>with the information and steps needed to connect via SSH:</p>
			<div><div><img src="img/Figure_12.13_B18821.jpg" alt="Figure 12.13 – Connecting via SSH to an EC2 instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Connecting via SSH to an EC2 instance</p>
			<ol>
				<li value="9">In your terminal, type the following command to connect via SSH:<pre class="source-code">
<strong class="bold">ssh -i path/to/your_keypair.pem ec2-user@ipaddress</strong></pre></li>
				<li>Once you are connected to the server, we will configure it to have a Django backend running on this machine and accessible from the internet:<pre class="source-code">
<strong class="bold">sudo apt update</strong></pre><pre class="source-code">
<strong class="bold">sudo apt upgrade</strong></pre></li>
			</ol>
			<p>The preceding <a id="_idIndexMarker716"/>commands update the <code>apt</code> packages index of Ubuntu packages and upgrade all packages on the server.</p>
			<p>The <a id="_idIndexMarker717"/>Django project will run on port <code>8000</code> on the machine, so we have to allow a connection to this port. By default, EC2 instances will only allow connections on ports <code>80</code> for HTTP requests, <code>22</code> for <a id="_idIndexMarker718"/>SSH connections, and—sometimes—<code>443</code> for <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) connections. </p>
			<p>You can allow connections on port <code>8000</code> directly on the <strong class="bold">Details</strong> page of the created EC2 instance to access the <strong class="bold">Security</strong> tab on the list of tabs at the bottom of the page and click on the security setting group:</p>
			<div><div><img src="img/Figure_12.14_B18821.jpg" alt="Figure 12.14 – Security tab"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – Security tab</p>
			<p>On the security group setting, access the <strong class="bold">Actions</strong> menu and click on <strong class="bold">Edit inbound</strong> <strong class="bold">rules</strong>. You will have access to a page where you can add a new rule, as follows:</p>
			<ul>
				<li>The type of connection is set to <strong class="bold">Custom TCP</strong></li>
				<li>The port range is set to <code>8000</code></li>
				<li>The source is set to <code>0.0.0.0</code> to indicate that all requests should be redirected to the machine on port <code>8000</code></li>
				<li>And finally, add a default description to not forget why we have added this rule</li>
			</ul>
			<p>Click on <code>8000</code>:</p>
			<div><div><img src="img/Figure_12.15_B18821.jpg" alt="Figure 12.15 – Adding a new security rule"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15 – Adding a new security rule</p>
			<p>The server is now ready for work, and we can now run the Django backend application. Let’s see the next steps in the following sections.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor247"/>Configuring the server for the Django project</h2>
			<p>The<a id="_idIndexMarker721"/> source code<a id="_idIndexMarker722"/> for the Django project is hosted on GitHub. It’s definitely possible to directly use <code>scp</code> to copy the code from your machine to the remote machine but let’s go with Git, as it will be an important command of our workflow. On the terminal of the remote instance, enter the following command:</p>
			<pre class="console">
git clone your_repository_git_url</pre>
			<p>In my case, I am using the following repository for this project:</p>
			<pre class="console">
git clone https://github.com/PacktPublishing/Full-stack-Django-and-React.git –branch chap12</pre>
			<p>The <code>git clone</code> command is used to get a copy of an existing repository from a remote machine on the internet or another network. The <code>–branch</code> flag is used to denote a specific branch you want to clone.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">As I am working using the repository of the project in this book, the current code and actions done are on the <code>chap12</code> branch. In your case, if you are using your own repository, you may not have to use the <code>–branch</code> flag. Also, depending on if the GitHub repository is private or public, you will only enter your GitHub credentials if the repository is private.</p>
			<p>The <code>git clone</code> command <a id="_idIndexMarker723"/>will clone the content of the project in a new directory. Enter the newly <a id="_idIndexMarker724"/>created directory and let’s start configuring the project. We will follow most of the steps done in <a href="B18221_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating a Django Project</em>, until the creation of the Django project:</p>
			<ol>
				<li value="1">First of all, create a virtual environment with the following command:<pre class="source-code">
<strong class="bold">python3 -m venv venv</strong></pre></li>
				<li>And activate the virtual environment with the following command:<pre class="source-code">
<strong class="bold">source venv/bin/activate</strong></pre></li>
				<li>Let’s install the packages from the <code>requirements.txt</code> file:<pre class="source-code">
pip install -r requirements.txt</pre></li>
			</ol>
			<p>Great! The project is ready, but we need to configure a Postgres server to have the Django project running.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor248"/>Postgres configuration and deployment</h2>
			<p>In <a href="B18221_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a> of the<a id="_idIndexMarker725"/> book, <em class="italic">Creating a Django Project</em>, we configured Postgres by directly<a id="_idIndexMarker726"/> installing an executable or building the source code. On the EC2 instance, we will directly use the <code>apt</code> tool to install the <a id="_idIndexMarker727"/>Postgres server. You can follow these steps to install the Postgres server on the EC2 machine:</p>
			<ol>
				<li value="1">Enter the following command to install the Postgres server:<pre class="source-code">
<strong class="bold">sudo apt install postgresql-14</strong></pre></li>
				<li>Let’s connect to the <code>psql</code> console and create a database:<pre class="source-code">
<strong class="bold">sudo su postgres </strong></pre><pre class="source-code">
<strong class="bold">psql</strong></pre></li>
				<li>Great! Let’s create <a id="_idIndexMarker728"/>the <a id="_idIndexMarker729"/>database with the same information on the <code>DATABASES</code> settings <a id="_idIndexMarker730"/>in the <code>CoreRoot/settings.py</code> file:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
...
DATABASES = {
    'default': {
        'ENGINE':
          'django.db.backends.postgresql_psycopg2',
        'NAME': coredb,
        'USER': 'core',
        'PASSWORD': 'wCh29&amp;HE&amp;T83',
        'HOST': 'localhost',
        'PORT': '5342',
    }
}
...</pre>
			<ol>
				<li value="4">Enter the following command on the <code>psql</code> console to create the <code>coredb</code> database:<pre class="source-code">
<strong class="bold">CREATE DATABASE coredb;</strong></pre></li>
				<li>To connect to the database, we need a user with a password. Execute the following command:<pre class="source-code">
<strong class="bold">CREATE USER core WITH PASSWORD 'wCh29&amp;HE&amp;T83';</strong></pre></li>
				<li>And the <a id="_idIndexMarker731"/>next step is to grant access to our database to the new user:<pre class="source-code">
<strong class="bold">GRANT ALL PRIVILEGES ON DATABASE coredb TO core;</strong></pre></li>
				<li>And we are <a id="_idIndexMarker732"/>nearly done. We also need to make sure this user can create a database. This will be helpful when we can run tests. To run tests, Django will configure a full environment but will also use a database:<pre class="source-code">
<strong class="bold">GRANT CREATE PRIVILEGE TO core;</strong></pre></li>
			</ol>
			<p>And we are done <a id="_idIndexMarker733"/>with the<a id="_idIndexMarker734"/> creation of the database. Next, let’s connect this database to our Django project:</p>
			<ol>
				<li value="1">In the project directory, run the <code>migrate</code> command:<pre class="source-code">
<strong class="bold">python manage.py migrate</strong>.</pre></li>
				<li>The <code>migrate</code> command should pass, and we can now start the Django server by running the following command:<pre class="source-code">
<strong class="bold">python manage.py runserver 0.0.0.0:8000</strong></pre></li>
				<li>With the Django server running, visit <code>http://public_ip:8000</code> in your web browser to access your Django project. You will have a page similar to the following figure:</li>
			</ol>
			<div><div><img src="img/Figure_12.16_B18821.jpg" alt="Figure 12.16 – DisallowedHost error"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.16 – DisallowedHost error</p>
			<p>This is actually an error. This comes from the <code>ALLOWED_HOSTS</code> setting being empty. It is implemented by Django to prevent security vulnerabilities such as HTTP host<a id="_idIndexMarker735"/> header attacks. The <code>ALLOWED_HOSTS</code> setting contains a list of hostnames or domain names that Django can serve:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
...
ALLOWED_HOSTS = []
...</pre>
			<ol>
				<li value="4">As we are<a id="_idIndexMarker736"/> running the project from the terminal, let’s modify the settings file directly on the server:<pre class="source-code">
vim CoreRoot/settings.py</pre></li>
			</ol>
			<p>Or, you can use the <code>emacs</code> or <code>nano</code> command. It’s up to you. The following line tells Django to accept requests from whatever is the hostname:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
...
<strong class="bold">ALLOWED_HOSTS = ["*"]</strong>
...</pre>
			<ol>
				<li value="5">Save the file and launch the server again:<pre class="source-code">
python manage.py runserver 0.0.0.0:8000</pre></li>
				<li>Then, again, visit <code>http://public_ip:8000</code> in your web browser. You will see the<a id="_idIndexMarker737"/> following:</li>
			</ol>
			<div><div><img src="img/Figure_12.17_B18821.jpg" alt="Figure 12.17 – Issues with DisallowedHost resolved"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.17 – Issues with DisallowedHost resolved</p>
			<p>Great! The<a id="_idIndexMarker738"/> project is running fine on <a id="_idIndexMarker739"/>the internet, and you can even play with the API using an API client such as Postman or Insomnia. Congratulations! You have successfully deployed your Django application on an AWS EC2 machine.</p>
			<p>However, we have a lot of issues (we can access debugging information directly on the internet, as in <em class="italic">Figure 12</em><em class="italic">.17</em>), and we made some dangerous decisions such as not serving the API through HTTPS or not correctly setting allowed hosts throughout the deployment. Let’s explore these issues in the next section.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor249"/>Errors made when deploying on EC2</h2>
			<p>We have <a id="_idIndexMarker740"/>successfully deployed the<a id="_idIndexMarker741"/> Django backend on AWS. However, I decided to ignore some important and best practices for deployment so that we can have the Django server running ASAP. Let’s correct this. Let’s start with the errors that Django can show us. In the terminal of the project on the remote server, run the following command:</p>
			<pre class="console">
python manage.py check –deploy</pre>
			<p>Here’s the<a id="_idIndexMarker742"/> output of the preceding command:</p>
			<pre class="console">
System check identified some issues:
WARNINGS:
?: (security.W004) You have not set a value for the SECURE_HSTS_SECONDS setting. If your entire site is served only over SSL, you may want to consider setting a value and enabling HTTP Strict Transport Security. Be sure to read the documentation first; enabling HSTS carelessly can cause serious, irreversible problems.
?: (security.W008) Your SECURE_SSL_REDIRECT setting is not set to True. Unless your site should be available over both SSL and non-SSL connections, you may want to either set this setting True or configure a load balancer or reverse-proxy server to redirect all connections to HTTPS.
?: (security.W009) Your SECRET_KEY has less than 50 characters, less than 5 unique characters, or it's prefixed with 'django-insecure-' indicating that it was generated automatically by Django. Please generate a long and random SECRET_KEY, otherwise many of Django's security-critical features will be vulnerable to attack.
?: (security.W012) SESSION_COOKIE_SECURE is not set to True. Using a secure-only session cookie makes it more difficult for network traffic sniffers to hijack user sessions.
?: (security.W016) You have 'django.middleware.csrf.CsrfViewMiddleware' in your MIDDLEWARE, but you have not set CSRF_COOKIE_SECURE to True. Using a secure-only CSRF cookie makes it more difficult for network traffic sniffers to steal the CSRF token.
?: (security.W018) You should not have DEBUG set to True in deployment.
System check identified 6 issues (0 silenced).</pre>
			<p>That’s a lot of things. As <a id="_idIndexMarker743"/>we are building <a id="_idIndexMarker744"/>an API, let’s focus on the security issues that concern our API:</p>
			<ul>
				<li><code>SECRET_KEY</code>: This is an important setting in Django. It is used for all sessions, cryptographic signings, and even <code>PasswordReset</code> tokens. Having an already set value for <code>SECRET_KEY</code> can lead to dangerous security issues such as privilege escalation and remote code execution.</li>
				<li><code>DEBUG</code>, which is set to <code>True</code>. That is basically why we were able to see the <code>DisallowedHost</code> error. Imagine an attacker going through your API, causing a <code>500</code> error, and then being able to read everything. That would be very bad.</li>
			</ul>
			<p>Those are mostly the errors that Django has detected. In the last section, <em class="italic">Postgres configuration and deployment</em>, we resolved the issue of the <code>DisallowedHost</code> error by having Django allow whichever hostname comes in a Host header. Well, this is actually bad because<a id="_idIndexMarker745"/> it can lead to an <strong class="bold">HTTP Host header attack</strong>, a <a id="_idIndexMarker746"/>technique used for web cache poisoning, poisoning links in the email, and modification of sensitive operations such as password reset.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can read <a id="_idIndexMarker747"/>more about HTTP Host header attacks at <a href="https://www.invicti.com/web-vulnerability-scanner/vulnerabilities/http-header-injection/">https://www.invicti.com/web-vulnerability-scanner/vulnerabilities/http-header-injection/</a>.</p>
			<p>There are also some issues concerning the developer experience. It’s true that we have seen how to use Git and GitHub to host source code online, clone it on a remote server, and then configure it for deployment. You can repeat the same process, right? But what happens when you have to update the code for features or fixes multiple times per day? It can quickly become draining, so we need a solution for automated deployment on our EC2 server.</p>
			<p>Also, we have Postgres and, finally, the Django project running separately. Sometimes, there might come a time when you will need to add another service to the machine. This can be done manually, but it creates an issue: the production environment starts to become different from the development environment.</p>
			<p>It is an<a id="_idIndexMarker748"/> important habit to make sure that the development environment and the production environment are as similar as possible; this can make the reproduction of bugs easier but also the development of features predictable.</p>
			<p>All these issues will be addressed in the next chapters. You will be introduced to environment variables, Docker, NGINX, and <strong class="bold">continuous integration/continuous deployment</strong> (<strong class="bold">CI/CD</strong>) concepts <a id="_idIndexMarker749"/>with GitHub Actions.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor250"/>Summary</h1>
			<p>In this chapter, we have successfully deployed a Django application on an EC2 instance. Before deploying the Django application, we used Git to create a repository on a local machine, then created a remote repository on GitHub and pushed the changes online.</p>
			<p>We have also learned how to configure a server for deployment manually with the installation of essential and interesting tools such as the Postgres server. We also explored the errors made when deploying the application and how we will address these errors in the following chapters.</p>
			<p>These errors will be resolved in the next chapters, but first, we’ll learn more about environment variables and Docker in the next chapter.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor251"/>Questions</h1>
			<ol>
				<li value="1">What is the usage of a Git branch?</li>
				<li>What is the difference between Git and GitHub?</li>
				<li>What is an HTTP Host header attack?</li>
				<li>What is the use of <code>SECRET_KEY</code> in Django?</li>
			</ol>
		</div>
		<div><div></div>
		</div>
	</body></html>