<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introduction and First Steps – Take a Deep Breath</h1></div></div></div><div><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><em>"Give a man a fish and you feed him for a day. Teach a man to fish and you feed him for a lifetime."</em></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<em>Chinese proverb</em></td></tr></table></div><p>According to Wikipedia, <strong>computer programming</strong>
<a id="id0" class="indexterm"/> is:</p><div><blockquote class="blockquote"><p><em>"...a process that leads from an original formulation of a computing problem to executable computer programs. Programming involves activities such as analysis, developing understanding, generating algorithms, verification of requirements of algorithms including their correctness and resources consumption, and implementation (commonly referred to as coding) of algorithms in a target programming language".</em></p></blockquote></div><p>In a nutshell, coding<a id="id1" class="indexterm"/> is telling a computer to do something using a language it understands.</p><p>Computers are very powerful tools, but unfortunately, they can't think for themselves. So they need to be told everything. They need to be told how to perform a task, how to evaluate a condition to decide which path to follow, how to handle data that comes from a device such as the network or a disk, and how to react when something unforeseen happens, say, something is broken or missing.</p><p>You can code in many different styles and languages. Is it hard? I would say "yes" and "no". It's a bit like writing. Everybody can learn how to write, and you can too. But what if you wanted to become a poet? Then writing alone is not enough. You have to acquire a whole other set of skills and this will take a longer and greater effort.</p><p>In the end, it all comes down to how far you want to go down the road. Coding is not just putting together some instructions that work. It is so much more!</p><p>Good code is short, fast, elegant, easy to read and understand, simple, easy to modify and extend, easy to scale and refactor, and easy to test. It takes time to be able to write code that has all these qualities at the same time, but the good news is that you're taking the first step towards it at this very moment by reading this book. And I have no doubt you can do it. Anyone can, in fact, we all program all the time, only we aren't aware of it.</p><p>Would you like an example?</p><p>Say you want to make instant coffee. You have to get a mug, the instant coffee jar, a teaspoon, water, and the kettle. Even if you're not aware of it, you're evaluating a lot of data. You're making sure that there is water in the kettle as well as the kettle is plugged-in, that the mug is clean, and that there is enough coffee in the jar. Then, you boil the water and maybe in the meantime you put some coffee in the mug. When the water is ready, you pour it into the cup, and stir.</p><p>So, how is this programming?</p><p>Well, we gathered resources (the kettle, coffee, water, teaspoon, and mug) and we verified some conditions on them (kettle is plugged-in, mug is clean, there is enough coffee). Then we started two actions (boiling the water and putting coffee in the mug), and when both of them were completed, we finally ended the procedure by pouring water in the mug and stirring.</p><p>Can you see it? I have just described the high-level functionality of a coffee program. It wasn't that hard because this is what the brain does all day long: evaluate conditions, decide to take actions, carry out tasks, repeat some of them, and stop at some point. Clean objects, put them back, and so on.</p><p>All you need now is to learn how to deconstruct all those actions you do automatically in real life so that a computer can actually make some sense of them. And you need to learn a language as well, to instruct it.</p><p>So this is what this book is for. I'll tell you how to do it and I'll try to do that by means of many simple but focused examples (my favorite kind).</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>A proper introduction</h1></div></div></div><p>I love to make references to the real world when I teach coding; I believe they help people retain the concepts better. However, now is the time to be a bit more rigorous and see what coding is from a more technical perspective.</p><p>When we write code, we're instructing a computer on what are the things it has to do. Where does the action happen? In many places: the computer memory, hard drives, network cables, CPU, and so on. It's a whole "world", which most of the time is the representation of a subset of the real world.</p><p>If you write a piece of software that allows people to buy clothes online, you will have to represent real people, real clothes, real brands, sizes, and so on and so forth, within the boundaries of a program.</p><p>In order to do so, you will need to create and handle objects in the program you're writing. A person can be an object. A car is an object. A pair of socks is an object. Luckily, Python understands objects very well.</p><p>The two main features any object has are <a id="id2" class="indexterm"/>properties and <a id="id3" class="indexterm"/>methods. Let's take a person object as an example. Typically in a computer program, you'll represent people as customers or employees. The properties that you store against them are things like the name, the SSN, the age, if they have a driving license, their e-mail, gender, and so on. In a computer program, you store all the data you need in order to use an object for the purpose you're serving. If you are coding a website to sell clothes, you probably want to store the height and weight as well as other measures of your customers so that you can suggest the appropriate clothes for them. So, properties are characteristics of an object. We use them all the time: "Could you pass me that pen?" – "Which one?" – "The black one." Here, we used the "black" property of a pen to identify it (most likely amongst a blue and a red one).</p><p>Methods are things that an object can do. As a person, I have methods such as <em>speak</em>, <em>walk</em>, <em>sleep</em>, <em>wake-up</em>, <em>eat</em>, <em>dream</em>, <em>write</em>, <em>read</em>, and so on. All the things that I can do could be seen as methods of the objects that represents me.</p><p>So, now that you know what objects are and that they expose methods that you can run and properties that you can inspect, you're ready to start coding. Coding in fact is simply about managing those objects that live in the subset of the world that we're reproducing in our software. You can create, use, reuse, and delete objects as you please.</p><p>According to the <em>Data Model</em> chapter on the official Python documentation:</p><div><blockquote class="blockquote"><p><em>"Objects <a id="id4" class="indexterm"/>are Python's abstraction for data. All data in a Python program is represented by objects or by relations between objects."</em></p></blockquote></div><p>We'll take a closer look at Python objects in <a class="link" href="ch06.html" title="Chapter 6. Advanced Concepts – OOP, Decorators, and Iterators">Chapter 6</a>, <em>Advanced Concepts – OOP, Decorators, and Iterators</em>. For now, all we need to know is that every object in Python has an ID (or identity), a type, and a value.</p><p>Once created, the identity of an object is never changed. It's a unique identifier for it, and it's used behind the scenes by Python to retrieve the object when we want to use it.</p><p>The type as well, never changes. The type tells what operations are supported by the object and the possible values that can be assigned to it.</p><p>We'll see Python's most important data types in <a class="link" href="ch02.html" title="Chapter 2. Built-in Data Types">Chapter 2</a>, <em>Built-in Data Types</em>.</p><p>The value can either change or not. If it can, the object is said to be <a id="id5" class="indexterm"/>
<strong>mutable</strong>, while when it cannot, the object is said to be <a id="id6" class="indexterm"/>
<strong>immutable</strong>.</p><p>How do we use an<a id="id7" class="indexterm"/> object? We give it a name of course! When you give an object a name, then you can use the name to retrieve the object and use it.</p><p>In a more generic sense, objects such as numbers, strings (text), collections, and so on are associated with a name. Usually, we say that this name is the name of a variable. You can see the variable as being like a box, which you can use to hold data.</p><p>So, you have all the objects you need: what now? Well, we need to use them, right? We may want to send them over a network connection or store them in a database. Maybe display them on a web page or write them into a file. In order to do so, we need to react to a user filling in a form, or pressing a button, or opening a web page and performing a search. We react by running our code, evaluating conditions to choose which parts to execute, how many times, and under which circumstances.</p><p>And to do all this, basically we need a language. That's what Python is for. Python is the language we'll use together throughout this book to instruct the computer to do something for us.</p><p>Now, enough of this theoretical stuff, let's get started.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Enter the Python</h1></div></div></div><p>Python <a id="id8" class="indexterm"/>is the marvelous creature of Guido Van Rossum, a Dutch computer scientist and mathematician who decided to gift the world with a project he was playing around with over Christmas 1989. The language appeared to the public somewhere around 1991, and since then has evolved to be one of the leading programming languages used worldwide today.</p><p>I started programming when I was 7 years old, on a Commodore VIC 20, which was later replaced by its bigger brother, the Commodore 64. The language was BASIC. Later on, I landed on Pascal, Assembly, C, C++, Java, JavaScript, Visual Basic, PHP, ASP, ASP .NET, C#, and other minor languages I cannot even remember, but only when I landed on Python, I finally had that feeling that you have when you find the right couch in the shop. When all of your body parts are yelling, "Buy this one! This one is perfect for us!"</p><p>It took me about a day to get used to it. Its syntax is a bit different from what I was used to, and in general, I very rarely worked with a language that defines scoping with indentation. But after getting past that initial feeling of discomfort (like having new shoes), I just fell in love with it. Deeply. Let's see why.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>About Python</h1></div></div></div><p>Before we get into<a id="id9" class="indexterm"/> the gory details, let's get a sense of why someone would want to use Python (I would recommend you to read the Python page on Wikipedia to get a more detailed introduction).</p><p>To my mind, Python exposes the following qualities.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Portability</h2></div></div></div><p>Python runs <a id="id10" class="indexterm"/>everywhere, and porting a program from Linux to Windows or Mac is usually just a matter of fixing paths and settings. Python is designed for portability and it takes care of <a id="id11" class="indexterm"/>
<strong>operating system</strong> (<strong>OS</strong>) specific quirks behind interfaces that shield you from the pain of having to write code tailored to a specific platform.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Coherence</h2></div></div></div><p>Python is extremely <a id="id12" class="indexterm"/>logical and coherent. You can see it was designed by a brilliant computer scientist. Most of the time you can just guess how a method is called, if you don't know it.</p><p>You may not realize how important this is right now, especially if you are at the beginning, but this is a major feature. It means less cluttering in your head, less skimming through the documentation, and less need for mapping in your brain when you code.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Developer productivity</h2></div></div></div><p>According to <a id="id13" class="indexterm"/>Mark Lutz (<em>Learning Python, 5th Edition</em>, <em>O'Reilly Media</em>), a Python program is typically one-fifth to one-third the size of equivalent Java or C++ code. This means the job gets done faster. And faster is good. Faster means a faster response on the market. Less code not only means less code to write, but also less code to read (and professional coders read much more than they write), less code to maintain, to debug, and to refactor.</p><p>Another important aspect is that Python runs without the need of lengthy and time consuming compilation and linkage steps, so you don't have to wait to see the results of your work.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>An extensive library</h2></div></div></div><p>Python has an incredibly wide <a id="id14" class="indexterm"/>standard library (it's said to come with "batteries included"). If that wasn't enough, the Python community all over the world maintains a body of third party libraries, tailored to specific needs, which you can access freely at the<a id="id15" class="indexterm"/> <strong>Python Package Index</strong> (<strong>PyPI</strong>). When you code Python and you realize that you need a certain feature, in most cases, there is at least one library where that feature has already been implemented for you.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Software quality</h2></div></div></div><p>Python is heavily focused on<a id="id16" class="indexterm"/> readability, coherence, and quality. The language uniformity allows for high readability and this is crucial nowadays where code is more of a collective effort than a solo experience. Another important aspect of Python is its intrinsic multi-paradigm nature. You can use it as scripting language, but you also can exploit object-oriented, imperative, and functional programming styles. It is versatile.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Software integration</h2></div></div></div><p>Another important aspect<a id="id17" class="indexterm"/> is that Python can be extended and integrated with many other<a id="id18" class="indexterm"/> languages, which means that even when a company is using a different language as their mainstream tool, Python can come in and act as a glue agent between complex applications that need to talk to each other in some way. This is kind of an advanced topic, but in the real world, this feature is very important.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Satisfaction and enjoyment</h2></div></div></div><p>Last but not least, the fun of it! Working with Python is fun. I can code for 8 hours and leave the office happy and satisfied, alien to the struggle other coders have to endure because they use languages that don't provide them with the same amount of well-designed data structures and constructs. Python makes coding fun, no doubt about it. And fun promotes motivation and productivity.</p><p>These are the major aspects why <a id="id19" class="indexterm"/>I would recommend Python to everyone for. Of course, there are many other technical and advanced features that I could have talked about, but they don't really pertain to an introductory section like this one. They will come up naturally, chapter after chapter, in this book.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>What are the drawbacks?</h1></div></div></div><p>Probably, the only <a id="id20" class="indexterm"/>drawback that one could find in Python, which is not due to personal preferences, is the <em>execution speed</em>. Typically, Python is slower than its compiled brothers. The standard implementation of Python produces, when you run an application, a compiled version of the source code called byte code (with the extension <code class="literal">.pyc</code>), which is then run by the Python interpreter. The advantage of this approach is portability, which we pay for with a slowdown due to the fact that Python is not compiled down to machine level as are other languages.</p><p>However, Python speed is rarely a problem today, hence its wide use regardless of this suboptimal feature. What happens is that in real life, hardware cost is no longer a problem, and usually it's easy enough to gain speed by parallelizing tasks. When it comes to number crunching though, one can switch to faster Python implementations, such as PyPy, which provides an average<a id="id21" class="indexterm"/> 7-fold speedup by implementing advanced compilation techniques (check <a class="ulink" href="http://pypy.org/">http://pypy.org/</a> for reference).</p><p>When doing<a id="id22" class="indexterm"/> data science, you'll most likely find that the libraries that you use with Python, such as Pandas and Numpy, achieve native speed due to the way they are implemented.</p><p>If that wasn't a good enough argument, you can always consider that Python is driving the backend of services such as Spotify and Instagram, where performance is a concern. Nonetheless, Python does its job perfectly adequately.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Who is using Python today?</h1></div></div></div><p>Not yet convinced? Let's take a <a id="id23" class="indexterm"/>very brief look at the companies that are using Python today: Google, YouTube, Dropbox, Yahoo, Zope Corporation, Industrial Light &amp; Magic, Walt Disney Feature Animation, Pixar, NASA, NSA, Red Hat, Nokia, IBM, Netflix, Yelp, Intel, Cisco, HP, Qualcomm, and JPMorgan Chase, just to name a few.</p><p>Even games such as <em>Battlefield 2</em>, <em>Civilization 4</em>, and <em>QuArK</em> are implemented using Python.</p><p>Python is used in many different contexts, such as system programming, web programming, GUI applications, gaming and robotics, rapid prototyping, system integration, data science, database applications, and much more.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Setting up the environment</h1></div></div></div><p>Before we talk about installing <a id="id24" class="indexterm"/>Python on your system, let me tell you about which Python version I'll be using in this book.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Python 2 versus Python 3 – the great debate</h2></div></div></div><p>Python comes in two main <a id="id25" class="indexterm"/>versions—Python 2, which is the past—and Python 3, which is the present. The two versions, though very similar, are incompatible on some aspects.</p><p>In the real world, Python 2 is actually quite far from being the past. In short, even though Python 3 has been out since 2008, the transition phase is still far from being over. This is mostly due to the fact that Python 2 is widely used in the industry, and of course, companies aren't so keen on updating their systems just for the sake of updating, following the <em>if it ain't broke, don't fix it</em> philosophy. You can read all about the transition between the two versions on the Web.</p><p>Another issue that was hindering the transition is the availability of third-party libraries. Usually, a Python project relies on tens of external libraries, and of course, when you start a new project, you need to be sure that there is already a version 3 compatible library for any business requirement that may come up. If that's not the case, starting a brand new project in Python 3 means introducing a potential risk, which many companies are not happy to take.</p><p>At the time of writing, the<a id="id26" class="indexterm"/> majority of the most widely used libraries have been ported to Python 3, and it's quite safe to start a project in Python 3 for most cases. Many of the libraries have been rewritten so that they are compatible with both versions, mostly harnessing the power of the six (2 x 3) library, which helps introspecting and adapting the behavior according to the version used.</p><p>On my Linux box (Ubuntu 14.04), I have the following Python version:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; import sys</strong>
<strong>&gt;&gt;&gt; print(sys.version)</strong>
<strong>3.4.0 (default, Apr 11 2014, 13:05:11)</strong>
<strong>[GCC 4.8.2]</strong>
</pre></div><p>So you can see that my Python version is 3.4.0. The preceding text is a little bit of Python code that I typed into my console. We'll talk about it in a moment.</p><p>All the examples in this book will be run using this Python version. Most of them will run also in Python 2 (I have version 2.7.6 installed as well), and those that won't will just require some minor adjustments to cater for the small incompatibilities between the two versions. Another reason behind this choice is that I think it's better to learn Python 3, and then, if you need to, learn the differences it has with Python 2, rather than going the other way around.</p><p>Don't worry about this version thing though: it's not that big an issue in practice.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Installing Python</h1></div></div></div><p>I never really got the<a id="id27" class="indexterm"/> point of <a id="id28" class="indexterm"/>having a <em>setup</em> section in a book, regardless of what it is that you have to set up. Most of the time, between the time the author writes the instruction and the time you actually try them out, months have passed. That is, if you're lucky. One version change and things may not work the way it is described in the book. Luckily, we have the Web now, so in order to help you get<a id="id29" class="indexterm"/> up and<a id="id30" class="indexterm"/> running, I'll just give you pointers and objectives.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>If any of the URLs or resources I'll point you to are no longer there by the time you read this book, just remember: Google is your friend.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Setting up the Python interpreter</h2></div></div></div><p>First of all, let's talk about <a id="id31" class="indexterm"/>your OS. Python is fully integrated and most likely already installed in basically almost every Linux distribution. If you have a Mac, it's likely that Python is already there as well (however, possibly only Python 2.7), whereas if you're using Windows, you probably need to install it.</p><p>Getting Python and the libraries you need up and running requires a bit of handiwork. Linux happens to be the most user friendly OS for Python programmers, Windows on the other hand is the one that requires the biggest effort, Mac being somewhere in between. For this reason, if you can choose, I suggest you to use Linux. If you can't, and you have a Mac, then go for it anyway. If you use Windows, you'll be fine for the examples in this book, but in general working with Python will require you a bit more tweaking.</p><p>My OS is Ubuntu 14.04, and this is what I will use throughout the book, along with Python 3.4.0.</p><p>The place you want to start is the official Python website: <a class="ulink" href="https://www.python.org">https://www.python.org</a>. This website hosts the official Python documentation and many other resources that you <a id="id32" class="indexterm"/>will find very useful. Take the time to explore it.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Another excellent, resourceful website on Python and its ecosystem is <a class="ulink" href="http://docs.python-guide.org">http://docs.python-guide.org</a>.</p></div></div><p>Find the download section and choose the installer for your OS. If you are on Windows, make sure that when you run the installer, you check the option <code class="literal">install pip</code> (actually, I would suggest to make a complete installation, just to be safe, of all the components the installer holds). We'll talk about pip later.</p><p>Now that Python is installed in your system, the objective is to be able to open a console and run the Python interactive shell by typing <code class="literal">python</code>.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Please note that I usually refer to the <em>Python interactive shell</em> simply as <em>Python console</em>.</p></div></div><p>To open the console in Windows, go to the <strong>Start</strong> menu, choose <strong>Run</strong>, and type <code class="literal">cmd</code>. If you encounter anything that looks like a permission problem while working on the examples of this book, please make sure you are running the console with administrator rights.</p><p>On the Mac OS X, you can start a terminal by going to <strong>Applications</strong> | <strong>Utilities</strong> | <strong>Terminal</strong>.</p><p>If you are on Linux, you know all that there is to know about the console.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>I will use the term <em>console</em> interchangeably to indicate the Linux <a id="id33" class="indexterm"/>
<strong>console</strong>, the Windows <a id="id34" class="indexterm"/>
<strong>command prompt</strong>, and the Mac<a id="id35" class="indexterm"/> <strong>terminal</strong>. I will also indicate the command-line prompt with the Linux default format, like this:</p><div><pre class="programlisting">
<strong>$ sudo apt-get update</strong>
</pre></div></div></div><p>Whatever console <a id="id36" class="indexterm"/>you open, type <code class="literal">python</code> at the prompt, and make sure the Python interactive shell shows up. Type <code class="literal">exit()</code> to quit. Keep in mind that you may have to specify <code class="literal">python3</code> if your OS comes with Python 2.* preinstalled.</p><p>This is how it should look on Windows 7:</p><div><img src="img/4715_01_01.jpg" alt="Setting up the Python interpreter"/></div><p>And this is how it should look on Linux:</p><div><img src="img/4715_01_02.jpg" alt="Setting up the Python interpreter"/></div><p>Now that Python is<a id="id37" class="indexterm"/> set up and you can run it, it's time to make sure you have the other tool that will be indispensable to follow the examples in the book: virtualenv.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>About virtualenv</h2></div></div></div><p>As you probably have guessed by its name, <strong>virtualenv</strong> <a id="id38" class="indexterm"/>is all about virtual environments. Let me explain what they are and why we need them and let me do it by means of a simple example.</p><p>You install Python on your system and you start working on a website for client X. You create a project folder and start coding. Along the way you also install some libraries, for example the Django framework, which we'll see in depth in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <em>Web Development Done Right</em>. Let's say the Django version you install for project X is 1.7.1.</p><p>Now, your website is so good that you get another client, Y. He wants you to build another website, so you start project Y and, along the way, you need to install Django again. The only issue is that now the Django version is 1.8 and you cannot install it on your system because this would replace the version you installed for project X. You don't want to risk introducing incompatibility issues, so you have two choices: either you stick with the version you have currently on your machine, or you upgrade it and make sure the first project is still fully working correctly with the new version.</p><p>Let's be honest, neither of these options is very appealing, right? Definitely not. So, here's the solution: virtualenv!</p><p>virtualenv is a tool that allows you to create a virtual environment. In other words, it is a tool to create isolated Python environments, each of which is a folder that contains all the necessary executables to use the packages that a Python project would need (think of packages as libraries for the time being).</p><p>So you create a virtual environment for project X, install all the dependencies, and then you create a virtual environment for project Y, installing all its dependencies without the slightest worry because every library you install ends up within the boundaries of the appropriate virtual environment. In our example, project X will hold Django 1.7.1, while project Y will hold Django 1.8.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>It is of vital importance that you never install libraries directly at the system level. Linux for example relies on Python for many different tasks and operations, and if you fiddle with the system installation of Python, you risk compromising the integrity of the whole system (guess to whom this happened…). So take this as a rule, such as brushing your teeth before going to bed: <em>always, always create a virtual environment when you start a new project</em>.</p></div></div><p>To install <a id="id39" class="indexterm"/>virtualenv on your system, there are a few different ways. On a Debian-based distribution of Linux for example, you can install it with the following command:</p><div><pre class="programlisting">
<strong>$ sudo apt-get install python-virtualenv</strong>
</pre></div><p>Probably, the easiest way is to use <code class="literal">pip</code> though, with the following command:</p><div><pre class="programlisting">
<strong>$ sudo pip install virtualenv # sudo may by optional</strong>
</pre></div><p>
<code class="literal">pip</code> is a package management system used to install and manage software packages written in Python.</p><p>Python 3 has built-in support for virtual environments, but in practice, the external libraries are still the default on production systems. If you have trouble getting virtualenv up and running, please refer to the <a id="id40" class="indexterm"/>virtualenv official website: <a class="ulink" href="https://virtualenv.pypa.io">https://virtualenv.pypa.io</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Your first virtual environment</h2></div></div></div><p>It is very easy to create a <a id="id41" class="indexterm"/>virtual environment, but according to how your system is configured and which Python version you want the virtual environment to run, you need to run the command properly. Another thing you will need to do with a virtualenv, when you want to work with it, is to activate it. Activating a virtualenv basically produces some path juggling behind the scenes so that when you call the Python interpreter, you're actually calling the active virtual environment one, instead of the mere system one.</p><p>I'll show you a full example on both Linux and Windows. We will:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a folder named <code class="literal">learning.python</code> under your project root (which in my case is a folder called <code class="literal">srv</code>, in my home folder). Please adapt the paths according to the setup you fancy on your box.</li><li class="listitem">Within the <code class="literal">learning.python</code> folder, we will create a virtual environment called <code class="literal">.lpvenv</code>.<div><div><h3 class="title"><a id="note05"/>Note</h3><p>Some developers prefer to call all virtual environments using the same name (for example, <code class="literal">.venv</code>). This way they can run scripts against any virtualenv by just knowing the name of the project they dwell in. This is a very common technique that I use as well. The dot in <code class="literal">.venv</code> is because in Linux/Mac prepending a name with a dot makes that file or folder invisible.</p></div></div></li><li class="listitem">After creating<a id="id42" class="indexterm"/> the virtual environment, we will activate it (this is slightly different between Linux, Mac, and Windows).</li><li class="listitem">Then, we'll make sure that we are running the desired Python version (3.4.*) by running the Python interactive shell.</li><li class="listitem">Finally, we will deactivate the virtual environment using the deactivate command.</li></ol></div><p>These five simple steps will show you all you have to do to start and use a project.</p><p>Here's an example of how those steps might look like on Linux (commands that start with a <code class="literal">#</code> are comments):</p><div><img src="img/4715_01_03.jpg" alt="Your first virtual environment"/></div><p>Notice that I had to <a id="id43" class="indexterm"/>explicitly tell virtualenv to use the Python 3.4 interpreter because on my box Python 2.7 is the default one. Had I not done that, I would have had a virtual environment with Python 2.7 instead of Python 3.4.</p><p>You can combine the two instructions for <em>step 2</em> in one single command like this:</p><div><pre class="programlisting">
<strong>$ virtualenv -p $( which python3.4 ) .lpvenv</strong>
</pre></div><p>I preferred to be explicitly verbose in this instance, to help you understand each bit of the procedure.</p><p>Another thing to notice is that in order to activate a virtual environment, we need to run the <code class="literal">/bin/activate</code> script, which needs to be sourced (when a script is "sourced", it means that its effects stick around when it's done running). This is very important. Also notice how the prompt changes after we activate the virtual environment, showing its name on the left (and how it disappears when we deactivate). In Mac OS, the steps are the same so I won't repeat them here.</p><p>Now let's have a look at how we can achieve the same result in Windows. You will probably have to play around a bit, especially if you have a different Windows or Python version than I'm using here. This is all good experience though, so try and think positively at the initial struggle that every coder has to go through in order to get things going.</p><p>Here's how it should look on <a id="id44" class="indexterm"/>Windows (commands that start with <code class="literal">::</code> are comments):</p><div><img src="img/4715_01_04.jpg" alt="Your first virtual environment"/></div><p>Notice there are a few small differences from the Linux version. Apart from the commands to create and navigate the folders, one important difference is how you activate your virtualenv. Also, in Windows there is no <code class="literal">which</code> command, so we used the <code class="literal">where</code> command.</p><p>At this point, you should be able to create and activate a virtual environment. Please try and create another one without me guiding you, get acquainted to this procedure because it's something that you will always be doing: <em>we never work system-wide with Python</em>, remember? It's extremely important.</p><p>So, with the scaffolding<a id="id45" class="indexterm"/> out of the way, we're ready to talk a bit more about Python and how you can use it. Before we do it though, allow me to spend a few words about the console.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Your friend, the console</h2></div></div></div><p>In this era of GUIs and <a id="id46" class="indexterm"/>touchscreen devices, it seems a little ridiculous to have to resort to a tool such as the console, when everything is just about one click away.</p><p>But the truth is every time you remove your right hand from the keyboard (or the left one, if you're a lefty) to grab your mouse and move the cursor over to the spot you want to click, you're losing time. Getting things done with the console, counter-intuitively as it may be, results in higher productivity and speed. I know, you have to trust me on this.</p><p>Speed and productivity are important and personally, I have nothing against the mouse, but there is another very good reason for which you may want to get well acquainted with the console: when you develop code that ends up on some server, the console might be the only available tool. If you make friends with it, I promise you, you will never get lost when it's of utmost importance that you don't (typically, when the website is down and you have to investigate very quickly what's going on).</p><p>So it's really up to you. If you're in doubt, please grant me the benefit of the doubt and give it a try. It's easier than you think, and you'll never regret it. There is nothing more pitiful than a good developer who gets lost within an SSH connection to a server because they are used to their own custom set of tools, and only to that.</p><p>Now, let's get back to Python.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>How you can run a Python program</h1></div></div></div><p>There are a few different ways in<a id="id47" class="indexterm"/> which you can run a Python program.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Running Python scripts</h2></div></div></div><p>Python can <a id="id48" class="indexterm"/>be used as a scripting language. In fact, it always proves itself very useful. Scripts are files (usually of small dimensions) that you normally execute to do something like a task. Many developers end up having their own arsenal of tools that they fire when they need to perform a task. For example, you can have scripts to parse data in a format and render it into another different format. Or you can use a script to work with files and folders. You can create or modify configuration files, and much more. Technically, there is not much that cannot be done in a script.</p><p>It's quite common to have scripts running at a precise time on a server. For example, if your website database needs cleaning every 24 hours (for example, the table that stores the user sessions, which expire pretty quickly but aren't cleaned automatically), you could set up a cron job that fires your script at 3:00 A.M. every day.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>According to Wikipedia, the software utility Cron<a id="id49" class="indexterm"/> is a time-based job scheduler in Unix-like computer operating systems. People who set up and maintain software environments use cron to schedule jobs (commands or shell scripts) to run periodically at fixed times, dates, or intervals.</p></div></div><p>I have Python <a id="id50" class="indexterm"/>scripts to do all the menial tasks that would take me minutes or more to do manually, and at some point, I decided to automate. For example, I have a laptop that doesn't have a <em>Fn</em> key to toggle the touchpad on and off. I find this very annoying, and I don't want to go clicking about through several menus when I need to do it, so I wrote a small script that is smart enough to tell my system to toggle the touchpad active state, and now I can do it with one simple click from my launcher. Priceless.</p><p>We'll devote half of <a class="link" href="ch08.html" title="Chapter 8. The Edges – GUIs and Scripts">Chapter 8</a>, <em>The Edges – GUIs and Scripts</em> on scripting with Python.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Running the Python interactive shell</h2></div></div></div><p>Another way of running <a id="id51" class="indexterm"/>Python is by calling the interactive shell. This is something we already saw when we typed <code class="literal">python</code> on the command line of our console.</p><p>So open a console, activate your virtual environment (which by now should be second nature to you, right?), and type <code class="literal">python</code>. You will be presented with a couple of lines that should look like this (if you are on Linux):</p><div><pre class="programlisting">
<strong>Python 3.4.0 (default, Apr 11 2014, 13:05:11)</strong>
<strong>[GCC 4.8.2] on linux</strong>
<strong>Type "help", "copyright", "credits" or "license" for more information.</strong>
</pre></div><p>Those <code class="literal">&gt;&gt;&gt;</code> are the prompt of the shell. They tell you that Python is waiting for you to type something. If you type a simple instruction, something that fits in one line, that's all you'll see. However, if you type something that requires more than one line of code, the shell will change the prompt to <code class="literal">...</code>, giving you a visual clue that you're typing a multiline statement (or anything that would require more than one line of code).</p><p>Go on, try it out, let's do some basic maths:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; 2 + 4</strong>
<strong>6</strong>
<strong>&gt;&gt;&gt; 10 / 4</strong>
<strong>2.5</strong>
<strong>&gt;&gt;&gt; 2 ** 1024</strong>
<strong>179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216</strong>
</pre></div><p>The last operation is showing you something incredible. We raise 2 to the power of 1024, and Python is handling this task with no trouble at all. Try to do it in Java, C++, or C#. It won't work, unless you use special libraries to handle such big numbers.</p><p>I use the interactive <a id="id52" class="indexterm"/>shell every day. It's extremely useful to debug very quickly, for example, to check if a data structure supports an operation. Or maybe to inspect or run a piece of code.</p><p>When you use Django (a web framework), the interactive shell is coupled with it and allows you to work your way through the framework tools, to inspect the data in the database, and many more things. You will find that the interactive shell will soon become one of your dearest friends on the journey you are embarking on.</p><p>Another solution, which comes in a much nicer graphic layout, is to use <a id="id53" class="indexterm"/>
<strong>IDLE</strong> (<strong>Integrated DeveLopment Environment</strong>). It's quite a simple IDE, which is intended mostly for beginners. It has a slightly larger set of capabilities than the naked interactive shell you get in the console, so you may want to explore it. It comes for free in the Windows Python installer and you can easily install it in any other system. You can find information about it on the Python website.</p><p>Guido Van Rossum named Python after the British comedy group Monty Python, so it's rumored that the name IDLE has been chosen in honor of Erik Idle, one of Monty Python's founding members.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Running Python as a service</h2></div></div></div><p>Apart from being <a id="id54" class="indexterm"/>run as a script, and within the boundaries of a shell, Python<a id="id55" class="indexterm"/> can be coded and run as proper software. We'll see many examples throughout the book about this mode. And we'll understand more about it in a moment, when we'll talk about how Python code is organized and run.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Running Python as a GUI application</h2></div></div></div><p>Python <a id="id56" class="indexterm"/>can also be run as a<a id="id57" class="indexterm"/> <strong>GUI</strong> (<strong>Graphical User Interface</strong>). There<a id="id58" class="indexterm"/> are several frameworks available, some of which are cross-platform and some others are platform-specific. In <a class="link" href="ch08.html" title="Chapter 8. The Edges – GUIs and Scripts">Chapter 8</a>, <em>The Edges – GUIs and Scripts</em>, we'll see an example of a GUI application created using <em>Tkinter</em>, which is an object-oriented layer that lives on top of <strong>Tk</strong>
<a id="id59" class="indexterm"/> (Tkinter means Tk Interface).</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Tk is a graphical user interface toolkit that takes desktop application development to a higher level than the conventional approach. It is the standard GUI for<a id="id60" class="indexterm"/> <strong>Tcl</strong> (<strong>Tool Command Language</strong>), but also for many other dynamic languages and can produce rich native applications that run seamlessly under Windows, Linux, Mac OS X, and more.</p></div></div><p>Tkinter<a id="id61" class="indexterm"/> comes bundled with Python, therefore it gives the programmer easy access to the GUI world, and for these reasons, I have chosen it to be the framework for the GUI examples that I'll present in this book.</p><p>Among the other GUI frameworks, we find that the following are the most widely used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">PyQt</li><li class="listitem" style="list-style-type: disc">wxPython</li><li class="listitem" style="list-style-type: disc">PyGtk</li></ul></div><p>Describing them in detail is outside the scope of this book, but you can find all the information you need on the Python website in the <em>GUI Programming</em> section. If GUIs are what you're looking for, remember to choose the one you want according to some principles. Make sure they:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Offer all the features you may need to develop your project</li><li class="listitem" style="list-style-type: disc">Run on all the platforms you may need to support</li><li class="listitem" style="list-style-type: disc">Rely on a community that is as wide and active as possible</li><li class="listitem" style="list-style-type: disc">Wrap graphic drivers/tools that you can easily install/access</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>How is Python code organized</h1></div></div></div><p>Let's talk a little bit about how<a id="id62" class="indexterm"/> Python code is organized. In this paragraph, we'll start going down the rabbit hole a little bit more and introduce a bit more technical names and concepts.</p><p>Starting with the basics, how is Python code organized? Of course, you write your code into files. When you save a file with the extension <code class="literal">.py</code>, that file is said to be a Python module.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>If you're on Windows or Mac, which typically hide file extensions to the user, please make sure you change the configuration so that you can see the complete name of the files. This is not strictly a requirement, but a hearty suggestion.</p></div></div><p>It would be impractical to save all the code that it is required for software to work within one single file. That solution works for <em>scripts</em>, which are usually not longer than a few hundred lines (and often they are quite shorter than that).</p><p>A complete Python application can be made of hundreds of thousands of lines of code, so you will have to scatter it through different modules. Better, but not nearly good enough. It turns out that even like this it would still be impractical to work with the code. So Python gives you another structure, called<a id="id63" class="indexterm"/> <strong>package</strong>, which allows you to group modules together. A<a id="id64" class="indexterm"/> package is nothing more than a folder, which must contain a special file, <code class="literal">__init__.py</code> that doesn't need to hold any code but whose presence is required to tell Python that the folder is not just some folder, but it's actually a package (note that as of Python 3.3 <code class="literal">__init__.py</code> is not strictly required any more).</p><p>As always, an example will make all of this much clearer. I have created an example structure in my book project, and when I type in my Linux console:</p><div><pre class="programlisting">
<strong>$ tree -v example</strong>
</pre></div><p>I get a tree representation of the contents of the <code class="literal">ch1/example</code> folder, which holds the code for the examples of this chapter. Here's how a structure of a real simple application could look like:</p><div><pre class="programlisting">
<strong>example/</strong>
<strong>├── core.py</strong>
<strong>├── run.py</strong>
<strong>└── util</strong>
<strong>    ├── __init__.py</strong>
<strong>    ├── db.py</strong>
<strong>    ├── math.py</strong>
<strong>    └── network.py</strong>
</pre></div><p>You can see that within the root of this example, we have two modules, <code class="literal">core.py</code> and <code class="literal">run.py</code>, and one package: <code class="literal">util</code>. Within <code class="literal">core.py</code>, there may be the core logic of our application. On the other hand, within the <code class="literal">run.py</code> module, we can probably find the logic to start the application. Within the <code class="literal">util</code> package, I expect to find various utility tools, and in fact, we can guess that the modules there are called by the type of tools they hold: <code class="literal">db.py</code> would hold tools to work with databases, <code class="literal">math.py</code> would of course hold mathematical tools (maybe our application deals with financial data), and <code class="literal">network.py</code> would probably hold tools to send/receive data on networks.</p><p>As explained before, the <code class="literal">__init__.py</code> file is there just to tell Python that <code class="literal">util</code> is a package and not just a mere folder.</p><p>Had this software been organized within modules only, it would have been much harder to infer its structure. I put a <em>module only</em> example under the <code class="literal">ch1/files_only</code> folder, see it for yourself:</p><div><pre class="programlisting">
<strong>$ tree -v files_only</strong>
</pre></div><p>This shows us a completely different picture:</p><div><pre class="programlisting">
<strong>files_only/</strong>
<strong>├── core.py</strong>
<strong>├── db.py</strong>
<strong>├── math.py</strong>
<strong>├── network.py</strong>
<strong>└── run.py</strong>
</pre></div><p>It is a little harder to guess <a id="id65" class="indexterm"/>what each module does, right? Now, consider that this is just a simple example, so you can guess how much harder it would be to understand a real application if we couldn't organize the code in packages and modules.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How do we use modules and packages</h2></div></div></div><p>When a developer is <a id="id66" class="indexterm"/>writing an application, it is very likely that they will need to apply the same piece of logic in different parts of it. For example, when writing a parser for the data that<a id="id67" class="indexterm"/> comes from a form that a user can fill in a web page, the application will have to validate whether a certain field is holding a number or not. Regardless of how the logic for this kind of validation is written, it's very likely that it will be needed in more than one place. For example in a poll application, where the user is asked many question, it's likely that several of them will require a numeric answer. For example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is your age</li><li class="listitem" style="list-style-type: disc">How many pets do you own</li><li class="listitem" style="list-style-type: disc">How many children do you have</li><li class="listitem" style="list-style-type: disc">How many times have you been married</li></ul></div><p>It would be very bad practice to copy paste (or, more properly said: duplicate) the validation logic in every place where we expect a numeric answer. This would violate the <a id="id68" class="indexterm"/>
<strong>DRY</strong> (<strong>Don't Repeat Yourself</strong>) principle, which states that you should never repeat the same piece of code more than once in your application. I feel the need to stress the importance of this principle: <em>you should never repeat the same piece of code more than once in your application</em> (got the irony?).</p><p>There are several reasons why repeating the same piece of logic can be very bad, the most important ones being:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There could be a bug in the logic, and therefore, you would have to correct it in every place that logic is applied.</li><li class="listitem" style="list-style-type: disc">You may want to amend the way you carry out the validation, and again you would have to change it in every place it is applied.</li><li class="listitem" style="list-style-type: disc">You may forget to fix/amend a piece of logic because you missed it when searching for all its occurrences. This would leave wrong/inconsistent behavior in your application.</li><li class="listitem" style="list-style-type: disc">Your code would be longer than needed, for no good reason.</li></ul></div><p>Python is <a id="id69" class="indexterm"/>a wonderful<a id="id70" class="indexterm"/> language and provides you with all the tools you need to apply all the coding best practices. For this particular example, we need to be able to reuse a piece of code. To be able to reuse a piece of code, we need to have a construct that will hold the code for us so that we can call that construct every time we need to repeat the logic inside it. That construct exists, and it's called<a id="id71" class="indexterm"/> <strong>function</strong>.</p><p>I'm not going too deep into the specifics here, so please just remember that a function is a block of organized, reusable code which is used to perform a task. Functions can assume many forms and names, according to what kind of environment they belong to, but for now this is not important. We'll see the details when we are able to appreciate them, later on, in the book. Functions are the building blocks of modularity in your application, and they are almost indispensable (unless you're writing a super simple script, you'll use functions all the time). We'll explore functions in <a class="link" href="ch04.html" title="Chapter 4. Functions, the Building Blocks of Code">Chapter 4</a>, <em>Functions, the Building Blocks of Code</em>.</p><p>Python comes with a very extensive library, as I already said a few pages ago. Now, maybe it's a good time to define what a library is: a <strong>library</strong>
<a id="id72" class="indexterm"/> is a collection of functions and objects that provide functionalities that enrich the abilities of a language.</p><p>For example, within Python's <code class="literal">math</code> library we can find a plethora of functions, one of which is the <code class="literal">factorial</code> function, which of course calculates the factorial of a number.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>In mathematics, the <strong>factorial</strong>
<a id="id73" class="indexterm"/> of a non-negative integer number <em>N</em>, denoted as <em>N!</em>, is defined as the product of all positive integers less than or equal to N. For example, the factorial of 5 is calculated as:</p><div><pre class="programlisting">
<strong>5! = 5 * 4 * 3 * 2 * 1 = 120</strong>
</pre></div><p>The factorial of <code class="literal">0</code> is <code class="literal">0! = 1</code>, to respect the convention for an empty product.</p></div></div><p>So, if you wanted to use this function in your code, all you would have to do is to import it and call it with the right input values. Don't worry too much if input values and the concept of calling is not very clear for now, please just concentrate on the import part.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>We use a library by importing what we need from it, and then we use it.</p></div></div><p>In Python, to calculate the factorial of number 5, we just need the following code:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; from math import factorial</strong>
<strong>&gt;&gt;&gt; factorial(5)</strong>
<strong>120</strong>
</pre></div><div><div><h3 class="title"><a id="note11"/>Note</h3><p>Whatever we type in the shell, if it has a printable representation, will be printed on the console for us (in this case, the result of the function call: 120).</p></div></div><p>So, let's go <a id="id74" class="indexterm"/>back to our example, the one with <code class="literal">core.py</code>, <code class="literal">run.py</code>, <code class="literal">util</code>, and so on.</p><p>In our example, the <a id="id75" class="indexterm"/>package <code class="literal">util</code> is our utility library. Our custom utility belt that holds all those reusable tools (that is, functions), which we need in our application. Some of them will deal with databases (<code class="literal">db.py</code>), some with the network (<code class="literal">network.py</code>), and some will perform mathematical calculations (<code class="literal">math.py</code>) that are outside the scope of Python's standard <code class="literal">math</code> library and therefore, we had to code them for ourselves.</p><p>We will see in detail how to import functions and use them in their dedicated chapter. Let's now talk about another very important concept: Python's execution model.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Python's execution model</h1></div></div></div><p>In this paragraph, I would like <a id="id76" class="indexterm"/>to introduce you to a few very important concepts, such <a id="id77" class="indexterm"/>as scope, names, and namespaces. You can read all about Python's execution model in the official Language reference, of course, but I would argue that it is quite technical and abstract, so let me give you a less formal explanation first.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Names and namespaces</h2></div></div></div><p>Say you are looking for <a id="id78" class="indexterm"/>a book, so <a id="id79" class="indexterm"/>you go to the library and ask someone for the book you want to fetch. They tell you something like "second floor, section X, row three". So you go up the stairs, look for section X, and so on.</p><p>It would be very different to enter a library where all the books are piled together in random order in one big room. No floors, no sections, no rows, no order. Fetching a book would be extremely hard.</p><p>When we write code we have the same issue: we have to try and organize it so that it will be easy for someone who has no prior knowledge about it to find what they're looking for. When software is structured correctly, it also promotes code reuse. On the other hand, disorganized software is more likely to expose scattered pieces of duplicated logic.</p><p>First of all, let's start with the book. We refer to a book by its title and in Python lingo, that would be a name. Python names are the closest abstraction to what other languages call variables. Names basically refer to objects and are introduced by name binding operations. Let's make a quick example (notice that anything that follows a <code class="literal">#</code> is a comment):</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; n = 3  # integer number</strong>
<strong>&gt;&gt;&gt; address = "221b Baker Street, NW1 6XE, London"  # S. Holmes</strong>
<strong>&gt;&gt;&gt; employee = {</strong>
<strong>...     'age': 45,</strong>
<strong>...     'role': 'CTO',</strong>
<strong>...     'SSN': 'AB1234567',</strong>
<strong>... }</strong>
<strong>&gt;&gt;&gt; # let's print them</strong>
<strong>&gt;&gt;&gt; n</strong>
<strong>3</strong>
<strong>&gt;&gt;&gt; address</strong>
<strong>'221b Baker Street, NW1 6XE, London'</strong>
<strong>&gt;&gt;&gt; employee</strong>
<strong>{'role': 'CTO', 'SSN': 'AB1234567', 'age': 45}</strong>
<strong>&gt;&gt;&gt; # what if I try to print a name I didn't define?</strong>
<strong>&gt;&gt;&gt; other_name</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>NameError: name 'other_name' is not defined</strong>
</pre></div><p>We defined three objects in the preceding code (do you remember what are the three features every Python object has?):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An integer number <code class="literal">n</code> (type: <code class="literal">int</code>, value: <code class="literal">3</code>)</li><li class="listitem" style="list-style-type: disc">A string <code class="literal">address</code> (type: <code class="literal">str</code>, value: Sherlock Holmes' address)</li><li class="listitem" style="list-style-type: disc">A dictionary <code class="literal">employee</code> (type: <code class="literal">dict</code>, value: a dictionary which holds three key/value pairs)</li></ul></div><p>Don't worry, I know<a id="id80" class="indexterm"/> you're not supposed to know what a dictionary is. We'll see in<a id="id81" class="indexterm"/> the next chapter that it's the king of Python data structures.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Have you noticed that the prompt changed from <code class="literal">&gt;&gt;&gt;</code> to <code class="literal">...</code> when I typed in the definition of employee? That's because the definition spans over multiple lines.</p></div></div><p>So, what are <code class="literal">n</code>, <code class="literal">address</code> and <code class="literal">employee</code>? They are <strong>names</strong>. Names that we can use to retrieve data within our code. They need to be kept somewhere so that whenever we need to retrieve those objects, we can use their names to fetch them. We need some space to hold them, hence: namespaces!</p><p>A <strong>namespace</strong> is therefore a mapping from names to objects. Examples are the set of built-in names (containing functions that are always accessible for free in any Python program), the global names in a module, and the local names in a function. Even the set of attributes of an object can be considered a namespace.</p><p>The beauty of namespaces is that they allow you to define and organize your names with clarity, without overlapping or interference. For example, the namespace associated with that book we were looking for in the library can be used to import the book itself, like this:</p><div><pre class="programlisting">from library.second_floor.section_x.row_three import book</pre></div><p>We start from the <code class="literal">library</code> namespace, and by means of the dot (<code class="literal">.</code>) operator, we walk into that namespace. Within this namespace, we look for <code class="literal">second_floor</code>, and again we walk into it with the <code class="literal">.</code> operator. We then walk into <code class="literal">section_x</code>, and finally within the last namespace, <code class="literal">row_tree</code>, we find the name we were looking for: <code class="literal">book</code>.</p><p>Walking through a namespace will be clearer when we'll be dealing with real code examples. For now, just keep in mind that namespaces are places where names are associated to objects.</p><p>There is another concept, which is closely related to that of a namespace, which I'd like to briefly talk about: the <strong>scope</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Scopes</h2></div></div></div><p>According to Python's <a id="id82" class="indexterm"/>documentation, <em>a scope is a textual region of a Python program, where a namespace is directly accessible</em>. Directly accessible means that when you're looking for an unqualified reference to a name, Python tries to find it in the namespace.</p><p>Scopes are determined statically, but actually during runtime they are used dynamically. This means that by inspecting the source code you can tell what the scope of an object is, but this doesn't prevent the software to alter that during runtime. There are four different scopes that Python makes accessible (not necessarily all of them present at the same time, of course):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong>local</strong><a id="id83" class="indexterm"/> scope, which<a id="id84" class="indexterm"/> is the innermost one and contains the local names.</li><li class="listitem" style="list-style-type: disc">The <strong>enclosing</strong><a id="id85" class="indexterm"/> scope, that <a id="id86" class="indexterm"/>is, the scope of any enclosing function. It contains non-local names and also non-global names.</li><li class="listitem" style="list-style-type: disc">The <strong>global</strong><a id="id87" class="indexterm"/> scope <a id="id88" class="indexterm"/>contains the global names.</li><li class="listitem" style="list-style-type: disc">The <strong>built-in</strong><a id="id89" class="indexterm"/> scope <a id="id90" class="indexterm"/>contains the built-in names. Python comes with a set of functions that you can use in a off-the-shelf fashion, such as <code class="literal">print</code>, <code class="literal">all</code>, <code class="literal">abs</code>, and so on. They live in the built-in scope.</li></ul></div><p>The rule is the following: when we refer to a name, Python starts looking for it in the current namespace. If the name is not found, Python continues the search to the enclosing scope and this continue until the built-in scope is searched. If a name hasn't been found after searching the built-in scope, then Python raises <a id="id91" class="indexterm"/>a <code class="literal">NameError</code> <strong>exception</strong>, which basically means that the name hasn't been defined (you saw this in the preceding example).</p><p>The order in which the namespaces are scanned when looking for a name is therefore: <a id="id92" class="indexterm"/>
<strong>local</strong>, <strong>enclosing</strong>, <strong>global</strong>, <strong>built-in</strong> (<strong>LEGB</strong>).</p><p>This is all very theoretical, so let's see an example. In order to show you Local and Enclosing namespaces, I will have to define a few functions. Don't worry if you are not familiar with their syntax for the moment, we'll study functions in <a class="link" href="ch04.html" title="Chapter 4. Functions, the Building Blocks of Code">Chapter 4</a>, <em>Functions, the Building Blocks of Code</em>. Just remember that in the following code, when you see <code class="literal">def</code>, it means I'm defining a function.</p><p><code class="literal">scopes1.py</code></p><div><pre class="programlisting"># Local versus Global

# we define a function, called local
def local():
    <strong>m = 7</strong>
    print(m)

<strong>m = 5</strong>
print(m)

# we call, or `execute` the function local
local()</pre></div><p>In the preceding example, we define the same name <code class="literal">m</code>, both in the global scope and in the local one (the one defined by the function local). When we execute this program with the following command (have you activated your virtualenv?):</p><div><pre class="programlisting">
<strong>$ python scopes1.py</strong>
</pre></div><p>We see two numbers printed on the console: <code class="literal">5</code> and <code class="literal">7</code>.</p><p>What happens is that the<a id="id93" class="indexterm"/> Python interpreter parses the file, top to bottom. First, it finds a couple of comment lines, which are skipped, then it parses the definition of the function <code class="literal">local</code>. When called, this function does two things: it sets up a name to an object representing number 7 and prints it. The Python interpreter keeps going and it finds another name binding. This time the binding happens in the global scope and the value is 5. The next line is a call to the <code class="literal">print</code> function, which is executed (and so we get the first value printed on the console: <code class="literal">5</code>).</p><p>After this, there is a call to the function <code class="literal">local</code>. At this point, Python executes the function, so at this time, the binding <code class="literal">m = 7</code> happens and it's printed.</p><p>One very important thing to notice is that the part of the code that belongs to the definition of the function local is indented by four spaces on the right. Python in fact defines scopes by indenting the code. You walk into a scope by indenting and walk out of it by unindenting. Some coders use two spaces, others three, but the suggested number of spaces to use is four. It's a good measure to maximize readability. We'll talk more about all the conventions you should embrace when writing Python code later.</p><p>What would happen if we removed that <code class="literal">m = 7</code> line? Remember the LEGB rule. Python would start looking for <code class="literal">m</code> in the local scope (function <code class="literal">local</code>), and, not finding it, it would go to the next enclosing scope. The next one in this case is the global one because there is no enclosing function wrapped around <code class="literal">local</code>. Therefore, we would see two number <code class="literal">5</code> printed on the console. Let's actually see how the code would look like:</p><p>
<code class="literal">scopes2.py</code>
</p><div><pre class="programlisting"># Local versus Global

def local():
    # m doesn't belong to the scope defined by the local function
    # so Python will keep looking into the next enclosing scope.
    # m is finally found in the global scope
    print(m, 'printing from the local scope')

<strong>m = 5</strong>
print(m, 'printing from the global scope')

local()</pre></div><p>Running <code class="literal">scopes2.py</code> will print this:</p><div><pre class="programlisting">
<strong>(.lpvenv)fab@xps:ch1$ python scopes2.py</strong>
<strong>5 printing from the global scope</strong>
<strong>5 printing from the local scope</strong>
</pre></div><p>As expected, Python <a id="id94" class="indexterm"/>prints <code class="literal">m</code> the first time, then when the function <code class="literal">local</code> is called, <code class="literal">m</code> isn't found in its scope, so Python looks for it following the LEGB chain until <code class="literal">m</code> is found in the global scope.</p><p>Let's see an example with an extra layer, the enclosing scope:</p><p>
<code class="literal">scopes3.py</code>
</p><div><pre class="programlisting"># Local, Enclosing and Global

def enclosing_func():
    <strong>m = 13</strong>
    def local():
        # m doesn't belong to the scope defined by the local
        # function so Python will keep looking into the next
        # enclosing scope. This time m is found in the enclosing
        # scope
        print(m, 'printing from the local scope')

    # calling the function local
    local()

<strong>m = 5</strong>
print(m, 'printing from the global scope')

enclosing_func()</pre></div><p>Running <code class="literal">scopes3.py</code> will print on the console:</p><div><pre class="programlisting">
<strong>(.lpvenv)fab@xps:ch1$ python scopes3.py</strong>
<strong>5 printing from the global scope</strong>
<strong>13 printing from the local scope</strong>
</pre></div><p>As you can see, the <code class="literal">print</code> instruction from the function <code class="literal">local</code> is referring to <code class="literal">m</code> as before. <code class="literal">m</code> is still not defined within the function itself, so Python starts walking scopes following the LEGB order. This time <code class="literal">m</code> is found in the enclosing scope.</p><p>Don't worry if this is still not perfectly clear for now. It will come to you as we go through the examples in the book. The <em>Classes</em> section of the Python tutorial (official documentation) has an interesting paragraph about scopes and namespaces. Make sure you read it at some point if you wish for a deeper understanding of the subject.</p><p>Before we finish off this chapter, I would like to talk a bit more about objects. After all, basically everything in Python is an object, so I think they deserve a bit more attention.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>Object and classes</h2></div></div></div><p>When I introduced objects in the <em>A proper introduction</em> section, I said that we use them to represent real-life objects. For example, we sell goods of any kind on the Web nowadays and we need to be able to handle, store, and represent them properly. But objects are actually so much more than that. Most of what you will ever do, in Python, has to do with manipulating objects.</p><p>So, without going too much into detail (we'll do that in <a class="link" href="ch06.html" title="Chapter 6. Advanced Concepts – OOP, Decorators, and Iterators">Chapter 6</a>, <em>Advanced Concepts – OOP, Decorators, and Iterators</em>), I want to give you the <em>in a nutshell</em> kind of explanation about classes and objects.</p><p>We've already seen that objects are Python's abstraction for data. In fact, everything in Python is an object. Numbers, strings (data structures that hold text), containers, collections, even functions. You can think of them as if they were boxes with at least three features: an ID (unique), a type, and a value.</p><p>But how do they come to life? How do we create them? How to we write our own custom objects? The answer lies in one simple word: classes.</p><p>Objects <a id="id95" class="indexterm"/>are, in fact, instances of <a id="id96" class="indexterm"/>classes. The beauty of Python is that classes are objects themselves, but let's not go down this road. It leads to one of the most advanced concepts of this <a id="id97" class="indexterm"/>language: <strong>metaclasses</strong>. We'll talk very briefly about them in <a class="link" href="ch06.html" title="Chapter 6. Advanced Concepts – OOP, Decorators, and Iterators">Chapter 6</a>, <em>Advanced Concepts – OOP, Decorators, and Iterators</em>. For now, the best way for you to get the difference between classes and objects, is by means of an example.</p><p>Say a friend tells you "I bought a new bike!" You immediately understand what she's talking about. Have you seen the bike? No. Do you know what color it is? Nope. The brand? Nope. Do you know anything about it? Nope. But at the same time, you know everything you need in order to understand what your friend meant when she told you she bought a new bike. You know that a bike has two wheels attached to a frame, a saddle, pedals, handlebars, brakes, and so on. In other words, even if you haven't seen the bike itself, you know the concept of bike. An abstract set of features and characteristics that together form something called bike.</p><p>In computer programming, that is called a <a id="id98" class="indexterm"/>
<strong>class</strong>. It's that simple. Classes are used to create objects. In fact, objects are said to be <a id="id99" class="indexterm"/>
<strong>instances of classes</strong>.</p><p>In other words, we all know what a bike is, we know the class. But then I have my own bike, which is an instance of the class bike. And my bike is an object with its own characteristics and methods. You have your own bike. Same class, but different instance. Every bike ever created in the world is an instance of the bike class.</p><p>Let's see an example. We will write a class that defines a bike and then we'll create two bikes, one red and one blue. I'll keep the code very simple, but don't fret if you don't understand everything about it; all you need to care about at this moment is to understand the difference between class and object (or instance of a class):</p><p>
<code class="literal">bike.py</code>
</p><div><pre class="programlisting"># let's define the class Bike
<strong>class Bike:</strong>
    def __init__(self, colour, frame_material):
        self.colour = colour
        self.frame_material = frame_material

    def brake(self):
        print("Braking!")

# let's create a couple of instances
<strong>red_bike = Bike('Red', 'Carbon fiber')</strong>
<strong>blue_bike = Bike('Blue', 'Steel')</strong>

# let's inspect the objects we have, instances of the Bike class.
print(red_bike.colour)  # prints: Red
print(red_bike.frame_material)  # prints: Carbon fiber
print(blue_bike.colour)  # prints: Blue
print(blue_bike.frame_material)  #  prints: Steel

# let's brake!
red_bike.brake()  # prints: Braking!</pre></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>I hope by now I don't need to tell you to run the file every time, right? The filename is indicated in the first line of the code block. Just run <code class="literal">$ python filename</code>, and you'll be fine.</p></div></div><p>So many interesting things to notice here. First things first; the definition of a class happens with the <code class="literal">class</code> statement (highlighted in the code). Whatever code comes after the <code class="literal">class</code> statement, and is indented, is called the body of the class. In our case, the last line that belongs to the class definition is the <code class="literal">print("Braking!")</code> one.</p><p>After having defined the class we're ready to create instances. You can see that the class body hosts the definition of two methods. A method is basically (and simplistically) a function that belongs to a class.</p><p>The first method, <code class="literal">__init__</code> is an<a id="id100" class="indexterm"/> <strong>initializer</strong>. It uses some Python magic to set up the objects with the values we pass when we create it.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Every method that has leading and trailing double underscore, in Python, is called<a id="id101" class="indexterm"/> <strong>magic method</strong>. Magic methods are used by Python for a multitude of different purposes, hence it's never a good idea to name a custom method using two leading and trailing underscores. This naming convention is best left to Python.</p></div></div><p>The other method we defined, <code class="literal">brake</code>, is just an example of an additional method that we could call if we wanted to brake the bike. It contains just a <code class="literal">print</code> statement, of course, it's an example.</p><p>We created two bikes then. One has red color and a carbon fiber frame, and the other one has blue color and steel frame. We pass those values upon creation. After creation, we print out the color property and frame type of the red bike, and the frame type of the blue one just as an example. We also call the <code class="literal">brake</code> method of the <code class="literal">red_bike</code>.</p><p>One last thing to notice. You remember I told you that the set of attributes of an object is considered to be a namespace? I hope it's clearer now, what I meant. You see that by getting to the <code class="literal">frame_type</code> property through different namespaces (<code class="literal">red_bike</code>, <code class="literal">blue_bike</code>) we obtain different values. No overlapping, no confusion.</p><p>The dot (<code class="literal">.</code>) operator is of course the means we use to walk into a namespace, in the case of objects as well.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Guidelines on how to write good code</h1></div></div></div><p>Writing good code is not as <a id="id102" class="indexterm"/>easy as it seems. As I already said before, good code exposes a long list of qualities that is quite hard to put together. Writing good code is, to some extent, an art. Regardless of where on the path you will be happy to settle, there is something that you can embrace which will make your code instantly better: <strong>PEP8</strong>.</p><p>According to Wikipedia:</p><div><blockquote class="blockquote"><p><em>"Python's development is conducted largely through the Python Enhancement Proposal (PEP)<a id="id103" class="indexterm"/> process. The PEP process is the primary mechanism for proposing major new features, for collecting community input on an issue, and for documenting the design decisions that have gone into Python."</em></p></blockquote></div><p>Among all the PEPs, probably<a id="id104" class="indexterm"/> the most famous one is PEP8. It lays out a simple but effective set of guidelines to define Python aesthetic so that we write beautiful Python code. If you take one suggestion out of this chapter, please let it be this: use it. Embrace it. You will thank me later.</p><p>Coding today is no longer a check-in/check-out business. Rather, it's more of a social effort. Several developers collaborate to a piece of code through tools like git and mercurial, and the result is code that is fathered by many different hands.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>Git<a id="id105" class="indexterm"/> and Mercurial<a id="id106" class="indexterm"/> are probably the most used distributed revision control systems today. They are essential tools designed to help teams of developers collaborate on the same software.</p></div></div><p>These days, more than ever, we need to have a consistent way of writing code, so that readability is maximized. When all developers of a company abide with PEP8, it's not uncommon for any of them landing on a piece of code to think they wrote it themselves. It actually happens to me all the time (I always forget the code I write).</p><p>This has a tremendous advantage: when you read code that you could have written yourself, you read it easily. Without a convention, every coder would structure the code the way they like most, or simply the way they were taught or are used to, and this would mean having to interpret every line according to someone else's style. It would mean having to lose much more time just trying to understand it. Thanks to PEP8, we can avoid this. I'm such a fan of it that I won't sign off a code review if the code doesn't respect it. So please take the time to study it, it's very important.</p><p>In the examples of this book, I will try to respect it as much as I can. Unfortunately, I don't have the luxury of 79 characters (which is the maximum line length suggested by PEP*), and I will have to cut down on blank lines and other things, but I promise you I'll try to layout my code so that it's as readable as possible.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec19"/>The Python culture</h1></div></div></div><p>Python has been adopted widely in<a id="id107" class="indexterm"/> all coding industries. It's used by many different companies for many different purposes, and it's also used in education (it's an excellent language for that purpose, because of its many qualities and the fact that it's easy to learn).</p><p>One of the reasons Python is so popular today is that the community around it is vast, vibrant, and full of brilliant people. Many events are organized all over the world, mostly either around Python or its main web framework, Django.</p><p>Python is open, and very often so are the minds of those who embrace it. Check out the community page on the Python website for more information and get involved!</p><p>There is another aspect to Python which revolves around the notion of being <strong>Pythonic</strong>. It has to do with the fact that Python allows you to use some idioms that aren't found elsewhere, at least not in the same form or easiness of use (I feel quite claustrophobic when I have to code in a language which is not Python now).</p><p>Anyway, over the years, this concept of being Pythonic has emerged and, the way I understand it, is something along the lines of <em>doing things the way they are supposed to be done in Python.</em>
</p><p>To help you <a id="id108" class="indexterm"/>understand a little bit more about Python's culture and about being Pythonic, I will show you the <em>Zen of Python</em>. A lovely Easter egg that is very popular. Open up a Python console and type <code class="literal">import this</code>. What follows is the result of this line:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; import this</strong>
<strong>The Zen of Python, by Tim Peters</strong>

<strong>Beautiful is better than ugly.</strong>
<strong>Explicit is better than implicit.</strong>
<strong>Simple is better than complex.</strong>
<strong>Complex is better than complicated.</strong>
<strong>Flat is better than nested.</strong>
<strong>Sparse is better than dense.</strong>
<strong>Readability counts.</strong>
<strong>Special cases aren't special enough to break the rules.</strong>
<strong>Although practicality beats purity.</strong>
<strong>Errors should never pass silently.</strong>
<strong>Unless explicitly silenced.</strong>
<strong>In the face of ambiguity, refuse the temptation to guess.</strong>
<strong>There should be one-- and preferably only one --obvious way to do it.</strong>
<strong>Although that way may not be obvious at first unless you're Dutch.</strong>
<strong>Now is better than never.</strong>
<strong>Although never is often better than *right* now.</strong>
<strong>If the implementation is hard to explain, it's a bad idea.</strong>
<strong>If the implementation is easy to explain, it may be a good idea.</strong>
<strong>Namespaces are one honking great idea -- let's do more of those!</strong>
</pre></div><p>There are two levels of reading here. One is to consider it as a set of guidelines that have been put down in a fun way. The other one is to keep it in mind, and maybe read it once in a while, trying to understand how it refers to something deeper. Some Python characteristics that you will have to understand deeply in order to write Python the way it's supposed to be written. Start with the fun level, and then dig deeper. Always dig deeper.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec20"/>A note on the IDEs</h1></div></div></div><p>Just a few words about <a id="id109" class="indexterm"/>
<strong>Integrated Development Environments</strong> (<strong>IDEs</strong>). To follow the examples in this book you don't need one, any text editor will do fine. If you want to have more advanced features such as syntax coloring and auto completion, you will have to fetch yourself an IDE. You can find a comprehensive list of open source IDEs (just Google "python ides") on the Python website. I personally use Sublime Text editor. It's free to try out and it costs just a few dollars. I have tried many IDEs in my life, but this is the one that makes me most productive.</p><p>Two extremely important pieces of advice:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Whatever IDE you will chose to use, try to learn it well so that you can exploit its strengths, but <em>don't depend on it</em>. Exercise yourself to work with VIM (or any other text editor) once in a while, learn to be able to do some work on any platform, with any set of tools.</li><li class="listitem" style="list-style-type: disc">Whatever text editor/IDE you will use, when it comes to writing Python, <em>indentation is four spaces</em>. Don't use tabs, don't mix them with spaces. Use four spaces, not two, not three, not five. Just use four. The whole world works like that, and you don't want to become an outcast because you were fond of the three-space layout.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we started to explore the world of programming and that of Python. We've barely scratched the surface, just a little, touching concepts that will be discussed later on in the book in greater detail.</p><p>We talked about Python's main features, who is using it and for what, and what are the different ways in which we can write a Python program.</p><p>In the last part of the chapter, we flew over the fundamental notions of namespace, scope, class, and object. We also saw how Python code can be organized using modules and packages.</p><p>On a practical level, we learned how to install Python on our system, how to make sure we have the tools we need, pip and virtualenv, and we also created and activated our first virtual environment. This will allow us to work in a self-contained environment without the risk of compromising the Python system installation.</p><p>Now you're ready to start this journey with me. All you need is enthusiasm, an activated virtual environment, this book, your fingers, and some coffee.</p><p>Try to follow the examples, I'll keep them simple and short. If you put them under your fingertips, you will retain them much better than if you just read them.</p><p>In the next chapter, we will explore Python's rich set of built-in data types. There's much to cover and much to learn!</p></div></body></html>