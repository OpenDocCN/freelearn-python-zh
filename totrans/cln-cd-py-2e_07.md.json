["```py\n<purchase_date>, <price>\n... \n```", "```py\nclass PurchasesStats:\n    def __init__(self, purchases):\n        self.purchases = iter(purchases)\n        self.min_price: float = None\n        self.max_price: float = None\n        self._total_purchases_price: float = 0.0\n        self._total_purchases = 0\n        self._initialize()\n    def _initialize(self):\n        try:\n            first_value = next(self.purchases)\n        except StopIteration:\n            raise ValueError(\"no values provided\")\n        self.min_price = self.max_price = first_value\n        self._update_avg(first_value)\n    def process(self):\n        for purchase_value in self.purchases:\n            self._update_min(purchase_value)\n            self._update_max(purchase_value)\n            self._update_avg(purchase_value)\n        return self\n    def _update_min(self, new_value: float):\n        if new_value < self.min_price:\n            self.min_price = new_value\n    def _update_max(self, new_value: float):\n        if new_value > self.max_price:\n            self.max_price = new_value\n    @property\n    def avg_price(self):\n        return self._total_purchases_price / self._total_purchases\n    def _update_avg(self, new_value: float):\n        self._total_purchases_price += new_value\n        self._total_purchases += 1\n    def __str__(self):\n        return (\n            f\"{self.__class__.__name__}({self.min_price}, \"\n            f\"{self.max_price}, {self.avg_price})\"\n        ) \n```", "```py\ndef _load_purchases(filename):\n    purchases = []\n    with open(filename) as f:\n        for line in f:\n            *_, price_raw = line.partition(\",\")\n            purchases.append(float(price_raw))\n    return purchases \n```", "```py\ndef load_purchases(filename):\n    with open(filename) as f:\n        for line in f:\n            *_, price_raw = line.partition(\",\")\n            yield float(price_raw) \n```", "```py\n>>> load_purchases(\"file\")\n<generator object load_purchases at 0x...> \n```", "```py\n>>> [x**2 for x in range(10)]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n>>> (x**2 for x in range(10))\n<generator object <genexpr> at 0x...>\n>>> sum(x**2 for x in range(10))\n285 \n```", "```py\n>>> sum([x**2 for x in range(10)])  # here the list can be avoided \n```", "```py\n>>> list(enumerate(\"abcdef\"))\n[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'), (5, 'f')] \n```", "```py\nclass NumberSequence:\n    def __init__(self, start=0):\n        self.current = start\n    def next(self):\n        current = self.current\n        self.current += 1\n        return current \n```", "```py\n>>> seq = NumberSequence()\n>>> seq.next()\n0\n>>> seq.next()\n1\n>>> seq2 = NumberSequence(10)\n>>> seq2.next()\n10\n>>> seq2.next()\n11 \n```", "```py\n>>> list(zip(NumberSequence(), \"abcdef\"))\nTraceback (most recent call last):\n  File \"...\", line 1, in <module>\nTypeError: zip argument #1 must support iteration \n```", "```py\nclass SequenceOfNumbers:\n    def __init__(self, start=0):\n        self.current = start\n    def __next__(self):\n        current = self.current\n        self.current += 1\n        return current\n    def __iter__(self):\n        return self \n```", "```py\n>>> list(zip(SequenceOfNumbers(), \"abcdef\"))\n[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'), (5, 'f')]\n>>> seq = SequenceOfNumbers(100)\n>>> next(seq)\n100\n>>> next(seq)\n101 \n```", "```py\n>>> word = iter(\"hello\")\n>>> next(word)\n'h'\n>>> next(word)\n'e'  # ... \n```", "```py\n>>> ...\n>>> next(word)\n'o'\n>>> next(word)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration\n>>> \n```", "```py\n>>> next(word, \"default value\")\n'default value' \n```", "```py\ndef sequence(start=0):\n    while True:\n        yield start\n        start += 1 \n```", "```py\n>>> seq = sequence(10)\n>>> next(seq)\n10\n>>> next(seq)\n11\n>>> list(zip(sequence(), \"abcdef\"))\n[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'), (5, 'f')] \n```", "```py\n# ...\n    def process(self):\n        for purchase in self.purchases:\n            if purchase > 1000.0:\n                ... \n```", "```py\n>>> from itertools import islice\n>>> purchases = islice(filter(lambda p: p > 1000.0, purchases), 10)\n>>> stats = PurchasesStats(purchases).process()  # ... \n```", "```py\ndef process_purchases(purchases):\n    min_, max_, avg = itertools.tee(purchases, 3)\n    return min(min_), max(max_), median(avg) \n```", "```py\ndef search_nested_bad(array, desired_value):\n    coords = None\n    for i, row in enumerate(array):\n        for j, cell in enumerate(row):\n            if cell == desired_value:\n                coords = (i, j)\n                break\n        if coords is not None:\n            break\n    if coords is None:\n        raise ValueError(f\"{desired_value} not found\")\n    logger.info(\"value %r found at [%i, %i]\", desired_value, *coords)\n    return coords \n```", "```py\ndef _iterate_array2d(array2d):\n    for i, row in enumerate(array2d):\n        for j, cell in enumerate(row):\n            yield (i, j), cell\ndef search_nested(array, desired_value):\n    try:\n        coord = next(\n            coord\n            for (coord, cell) in _iterate_array2d(array)\n            if cell == desired_value\n        )\n    except StopIteration as e:\n        raise ValueError(f\"{desired_value} not found\") from e\n    logger.info(\"value %r found at [%i, %i]\", desired_value, *coord)\n    return coord \n```", "```py\nclass SequenceIterator:\n    def __init__(self, start=0, step=1):\n        self.current = start\n        self.step = step\n    def __next__(self):\n        value = self.current\n        self.current += self.step\n        return value \n```", "```py\n>>> si = SequenceIterator(1, 2)\n>>> next(si)\n1\n>>> next(si)\n3\n>>> next(si)\n5\n>>> for _ in SequenceIterator(): pass\n... \nTraceback (most recent call last):\n  ...\nTypeError: 'SequenceIterator' object is not iterable \n```", "```py\n# generators_iteration_2.py\nclass MappedRange:\n    \"\"\"Apply a transformation to a range of numbers.\"\"\"\n    def __init__(self, transformation, start, end):\n        self._transformation = transformation\n        self._wrapped = range(start, end)\n    def __getitem__(self, index):\n        value = self._wrapped.__getitem__(index)\n        result = self._transformation(value)\n        logger.info(\"Index %d: %s\", index, result)\n        return result\n    def __len__(self):\n        return len(self._wrapped) \n```", "```py\n>>> mr = MappedRange(abs, -10, 5)\n>>> mr[0]\nIndex 0: 10\n10\n>>> mr[-1]\nIndex -1: 4\n4\n>>> list(mr)\nIndex 0: 10\nIndex 1: 9\nIndex 2: 8\nIndex 3: 7\nIndex 4: 6\nIndex 5: 5\nIndex 6: 4\nIndex 7: 3\nIndex 8: 2\nIndex 9: 1\nIndex 10: 0\nIndex 11: 1\nIndex 12: 2\nIndex 13: 3\nIndex 14: 4\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4] \n```", "```py\ndef stream_db_records(db_handler):\n    try:\n        while True:\n            yield db_handler.read_n_records(10)\n    except GeneratorExit:\n        db_handler.close() \n```", "```py\n>>> streamer = stream_db_records(DBHandler(\"testdb\"))\n>>> next(streamer)\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), ...]\n>>> next(streamer)\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), ...]\n>>> streamer.close()\nINFO:...:closing connection to database 'testdb' \n```", "```py\nclass CustomException(Exception):\n    \"\"\"A type of exception that is under control.\"\"\"\ndef stream_data(db_handler):\n    while True:\n        try:\n            yield db_handler.read_n_records(10)\n        except CustomException as e:\n            logger.info(\"controlled error %r, continuing\", e)\n        except Exception as e:\n            logger.info(\"unhandled error %r, stopping\", e)\n            db_handler.close()\n            break \n```", "```py\n>>> streamer = stream_data(DBHandler(\"testdb\"))\n>>> next(streamer)\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), (4, 'row 4'), ...]\n>>> next(streamer)\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), (4, 'row 4'), ...]\n>>> streamer.throw(CustomException)\nWARNING:controlled error CustomException(), continuing\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), (4, 'row 4'), ...]\n>>> streamer.throw(RuntimeError)\nERROR:unhandled error RuntimeError(), stopping\nINFO:closing connection to database 'testdb'\nTraceback (most recent call last):\n  ...\nStopIteration \n```", "```py\ndef stream_db_records(db_handler):\n    retrieved_data = None\n    previous_page_size = 10\n    try:\n        while True:\n            page_size = yield retrieved_data\n            if page_size is None:\n                page_size = previous_page_size\n            previous_page_size = page_size\n            retrieved_data = db_handler.read_n_records(page_size)\n    except GeneratorExit:\n        db_handler.close() \n```", "```py\nreceive = yield produced \n```", "```py\n>>> def coro():\n...     y = yield\n...\n>>> c = coro()\n>>> c.send(1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: can't send non-None value to a just-started generator\n>>> \n```", "```py\ndef stream_db_records(db_handler):\n    retrieved_data = None\n    page_size = 10\n    try:\n        while True:\n            page_size = (yield retrieved_data) or page_size\n            retrieved_data = db_handler.read_n_records(page_size)\n    except GeneratorExit:\n        db_handler.close() \n```", "```py\n@prepare_coroutine\ndef auto_stream_db_records(db_handler):\n    retrieved_data = None\n    page_size = 10\n    try:\n        while True:\n            page_size = (yield retrieved_data) or page_size\n            retrieved_data = db_handler.read_n_records(page_size)\n    except GeneratorExit:\n        db_handler.close() \n```", "```py\n>>> streamer = auto_stream_db_records(DBHandler(\"testdb\"))\n>>> len(streamer.send(5))\n5 \n```", "```py\n>>> def generator():\n...     yield 1\n...     yield 2\n...     return 3\n... \n>>> value = generator()\n>>> next(value)\n1\n>>> next(value)\n2\n>>> try:\n...     next(value)\n... except StopIteration as e:\n...     print(f\">>>>>> returned value: {e.value}\")\n... \n>>>>>> returned value: 3 \n```", "```py\ndef chain(*iterables):\n    for it in iterables:\n        for value in it:\n            yield value \n```", "```py\ndef chain(*iterables):\n    for it in iterables:\n        yield from it \n```", "```py\n>>> list(chain(\"hello\", [\"world\"], (\"tuple\", \" of \", \"values.\")))\n['h', 'e', 'l', 'l', 'o', 'world', 'tuple', ' of ', 'values.'] \n```", "```py\ndef all_powers(n, pow):\n    yield from (n ** i for i in range(pow + 1)) \n```", "```py\ndef sequence(name, start, end):\n    logger.info(\"%s started at %i\", name, start)\n    yield from range(start, end)\n    logger.info(\"%s finished at %i\", name, end)\n    return end\ndef main():\n    step1 = yield from sequence(\"first\", 0, 5)\n    step2 = yield from sequence(\"second\", step1, 10)\n    return step1 + step2 \n```", "```py\n>>> g = main()\n>>> next(g)\nINFO:generators_yieldfrom_2:first started at 0\n0\n>>> next(g)\n1\n>>> next(g)\n2\n>>> next(g)\n3\n>>> next(g)\n4\n>>> next(g)\nINFO:generators_yieldfrom_2:first finished at 5\nINFO:generators_yieldfrom_2:second started at 5\n5\n>>> next(g)\n6\n>>> next(g)\n7\n>>> next(g)\n8\n>>> next(g)\n9\n>>> next(g)\nINFO:generators_yieldfrom_2:second finished at 10\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration: 15 \n```", "```py\ndef sequence(name, start, end):\n    value = start\n    logger.info(\"%s started at %i\", name, value)\n    while value < end:\n        try:\n            received = yield value\n            logger.info(\"%s received %r\", name, received)\n            value += 1\n        except CustomException as e:\n            logger.info(\"%s is handling %s\", name, e)\n            received = yield \"OK\"\n    return end \n```", "```py\n>>> g = main()\n>>> next(g)\nINFO: first started at 0\n0\n>>> next(g)\nINFO: first received None\n1\n>>> g.send(\"value for 1\")\nINFO: first received 'value for 1'\n2\n>>> g.throw(CustomException(\"controlled error\"))\nINFO: first is handling controlled error\n'OK'\n... # advance more times\nINFO:second started at 5\n5\n>>> g.throw(CustomException(\"exception at second generator\"))\nINFO: second is handling exception at second generator\n'OK' \n```", "```py\nresult = yield from iterable_or_awaitable() \n```", "```py\n@contextlib.asynccontextmanager\nasync def db_management():\n    try:\n        await stop_database()\n        yield\n    finally:\n        await start_database() \n```", "```py\n@contextlib.asynccontextmanager\nasync def metrics_logger():\n    yield await create_metrics_logger()\n\nasync def run_db_backup():\n    async with db_management(), metrics_logger():\n        print(\"Performing DB backup...\") \n```", "```py\nimport asyncio\nimport random\n\nasync def coroutine():\n    await asyncio.sleep(0.1)\n    return random.randint(1, 10000)\n\nclass RecordStreamer:\n    def __init__(self, max_rows=100) -> None:\n        self._current_row = 0\n        self._max_rows = max_rows\n\n    def __aiter__(self):\n        return self\n\n    async def __anext__(self):\n        if self._current_row < self._max_rows:\n            row = (self._current_row, await coroutine())\n            self._current_row += 1\n            return row\n        raise StopAsyncIteration \n```", "```py\nasync for row in RecordStreamer(10):\n    ... \n```", "```py\nawait async_iterator.__anext__() \n```", "```py\nNOT_SET = object()\n\nasync def anext(async_generator_expression, default=NOT_SET):\n    try:\n        return await async_generator_expression.__anext__()\n    except StopAsyncIteration:\n        if default is NOT_SET:\n            raise\n        return default \n```", "```py\n$ python -m asyncio\n>>> streamer = RecordStreamer(10)\n>>> await anext(streamer)\n(0, 5017)\n>>> await anext(streamer)\n(1, 5257)\n>>> await anext(streamer)\n(2, 3507)\n...\n>>> await anext(streamer)\n(9, 5440)\n>>> await anext(streamer)\nTraceback (most recent call last):\n    ...\n    raise StopAsyncIteration\nStopAsyncIteration\n>>> \n```", "```py\nasync def record_streamer(max_rows):\n    current_row = 0\n    while current_row < max_rows:\n        row = (current_row, await coroutine())\n        current_row += 1\n        yield row \n```"]