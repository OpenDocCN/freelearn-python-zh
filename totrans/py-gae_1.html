<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started</h1></div></div></div><p>Any software available over the Internet, usually accessed with a web browser, can be addressed as a web application. Social networks, e-commerce sites, e-mail clients, online games are just a few examples of a trend known as web 2.0, which was started in the late 1990s and emerged in the past few years. Today, if we want to provide a service for multiple clients and multiple users, we will likely end in with writing a web application.</p><p>Web applications come with an endless list of benefits from a developer's point of view but there is one major drawback to face every time we want to make our software available to other users: we need a remote server connected to the Internet to host the application. This server must be constantly available and respond to clients in a reasonable amount of time, irrespective of the number of clients, or the application won't be usable.</p><p>A noteworthy solution to the hosting problem is cloud computing, which is a rather generic term that usually refers to the opportunity to run applications and services on someone else's infrastructure at a reasonable cost and in a way that is simple and quick for the needed resources to be provisioned and released.</p><p>In this first chapter we will define in detail the term cloud computing and then introduce the model provided by Google, focusing on the elements that are important to us, as developers, and use them to run our first application using the Google Cloud Platform and Google App Engine.</p><p>In this chapter we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A detailed introduction to Google Cloud Platform and Google App Engine</li><li class="listitem" style="list-style-type: disc">Setting up an App Engine code environment</li><li class="listitem" style="list-style-type: disc">Writing a simple application</li><li class="listitem" style="list-style-type: disc">Loading and running the application on a remote server</li><li class="listitem" style="list-style-type: disc">Using the administration console</li></ul></div><div class="section" title="The cloud computing stack – SaaS, PaaS, and IaaS"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The cloud computing stack – SaaS, PaaS, and IaaS</h1></div></div></div><p>We <a id="id0" class="indexterm"/>can choose to outsource our <a id="id1" class="indexterm"/>applications and the hardware they run on, still being<a id="id2" class="indexterm"/> responsible for the whole<a id="id3" class="indexterm"/> software stack, including the operating system; or, <a id="id4" class="indexterm"/>we can simply<a id="id5" class="indexterm"/> use existing applications available from another vendor.</p><p>We can represent cloud computing as a stack of three different categories: <span class="strong"><strong>Software</strong></span> <span class="strong"><strong>as</strong></span> <span class="strong"><strong>a</strong></span> <span class="strong"><strong>Service</strong></span> (<span class="strong"><strong>SaaS</strong></span>), <span class="strong"><strong>Platform</strong></span> <span class="strong"><strong>as</strong></span> <span class="strong"><strong>a</strong></span> <span class="strong"><strong>Service</strong></span> (<span class="strong"><strong>PaaS</strong></span>), and <span class="strong"><strong>Infrastructure as a Service</strong></span> (<span class="strong"><strong>IaaS</strong></span>) as follows:</p><div class="mediaobject"><img src="graphics/8194OS_01_01.jpg" alt="The cloud computing stack – SaaS, PaaS, and IaaS"/></div><p>In the first case, the cloud computing model is defined as IaaS and we basically outsource hardware and every inherent service such as power supply, cooling, networking, and storage systems. We decide how to allocate resources, how many web applications, or database servers we need, whether or not we need to use a load balancer, how to manage backups and so on; the installation, monitoring, and maintenance are under our responsibilities. A notable example of IaaS services are EC2 from Amazon and Rackspace Cloud Hosting.</p><p>In the<a id="id6" class="indexterm"/> second case, the cloud computing model is defined as<a id="id7" class="indexterm"/> SaaS and is the opposite of IaaS since we simply<a id="id8" class="indexterm"/> use a turnkey software provided by a third-party vendor, who has no technical knowledge of the infrastructure it runs on; the vendor is responsible for the reliability and security of the product. Notable examples of SaaS are Gmail from Google and Salesforce.</p><p>Between IaaS and SaaS we find the PaaS model, which seems to be the most interesting solution from a developer's point of view. A PaaS system provides a platform with which we can build and run our application without worrying about the underlying levels, both hardware and software.</p></div></div>
<div class="section" title="Google Cloud Platform"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Google Cloud Platform</h1></div></div></div><p>Google <a id="id9" class="indexterm"/>Cloud Platform is designed to offer developers tools and services needed to build and run web applications on Google's reliable and highly scalable infrastructure. The platform consists of several cloud computing products that can be composed and used according to our needs, so it's important to know what these building blocks can do for us, as developers, and how they do so.</p><p>As we <a id="id10" class="indexterm"/>can learn from the main documentation page at <a class="ulink" href="https://cloud.google.com">https://cloud.google.com</a>, Google classifies Google Cloud Platform's components into four groups: Hosting + Compute, Storage, Big Data, and services.</p><div class="section" title="Hosting + Compute"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec04"/>Hosting + Compute</h2></div></div></div><p>There <a id="id11" class="indexterm"/>are two options if we want to host an application on Google Cloud Platform:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Google App Engine</strong></span>: This<a id="id12" class="indexterm"/> is <a id="id13" class="indexterm"/>Google's PaaS and it will be covered in detail later in this chapter.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Google Compute Engine</strong></span>: This is <a id="id14" class="indexterm"/>Google's IaaS and lets users run virtual machines<a id="id15" class="indexterm"/> on Google's infrastructure with a variety of hardware and software configurations.</li></ul></div></div><div class="section" title="Storage"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec05"/>Storage</h2></div></div></div><p>Google<a id="id16" class="indexterm"/> Cloud Platform provides several options to store and access users' data:</p><p><span class="strong"><strong>Google Cloud Storage</strong></span>: This is a highly available and scalable file storage service with versioning <a id="id17" class="indexterm"/>and caching. We will <a id="id18" class="indexterm"/>learn how to use Cloud Storage in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <span class="emphasis"><em>Storing and Processing User's Data</em></span>.</p><p><span class="strong"><strong>Google Cloud SQL</strong></span>: This is a fully managed MySQL relational database; replication, security<a id="id19" class="indexterm"/> and availability are Google's responsibilities. <a class="link" href="ch05.html" title="Chapter 5. Storing Data in Google Cloud SQL">Chapter 5</a>, <span class="emphasis"><em>Storing Data in Google Cloud SQL</em></span>, is entirely dedicated<a id="id20" class="indexterm"/> to this service.</p><p><span class="strong"><strong>Google Cloud Datastore</strong></span>: This is a managed schemaless database that stores nonrelational<a id="id21" class="indexterm"/> data objects called <a id="id22" class="indexterm"/>entities; it scales automatically, supports transactions, and can be queried with SQL-like syntax. We will start using it in <a class="link" href="ch02.html" title="Chapter 2. A More Complex Application">Chapter 2</a>, <span class="emphasis"><em>A More Complex Application</em></span>, and learn how to get the most out of it in <a class="link" href="ch04.html" title="Chapter 4. Improving Application Performance">Chapter 4</a>, <span class="emphasis"><em>Improving Application Performance</em></span>.</p></div><div class="section" title="BigQuery"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>BigQuery</h2></div></div></div><p><span class="strong"><strong>BigQuery</strong></span> is a <a id="id23" class="indexterm"/>tool provided by Google Cloud Platform<a id="id24" class="indexterm"/> that allows to perform queries using an SQL-like syntax against <a id="id25" class="indexterm"/>a huge amount of data in a matter of seconds. Before it can be analyzed, data must be streamed into BigQuery through its API or uploaded to Google Cloud Storage.</p></div><div class="section" title="Services"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Services</h2></div></div></div><p>Instead <a id="id26" class="indexterm"/>of writing code from scratch, we can easily add <a id="id27" class="indexterm"/>functionalities to our applications using some of Google's services through APIs that are very well integrated within Google Cloud Platform:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Translate API</strong></span>: This can<a id="id28" class="indexterm"/> translate text between dozens of languages programmatically, from within our applications.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The Prediction API</strong></span>: This predicts future trends using Google's machine learning <a id="id29" class="indexterm"/>algorithms and can<a id="id30" class="indexterm"/> be used from within our applications or through a <span class="strong"><strong>Representational State Transfer</strong></span> (<span class="strong"><strong>REST</strong></span>) API. REST is a stateless architecture style that describes how a system can communicate with another through a network; we will delve into more details on REST in <a class="link" href="ch08.html" title="Chapter 8. Exposing a REST API with Google Cloud Endpoints">Chapter 8</a>, <span class="emphasis"><em>Exposing a REST API with Google Cloud Endpoints</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Google Cloud Endpoints</strong></span>: Using this tool, it's<a id="id31" class="indexterm"/> easy to create applications that expose REST <a id="id32" class="indexterm"/>services, providing also <span class="strong"><strong>Denial-of-Service</strong></span> (<span class="strong"><strong>DoS</strong></span>) protection and <span class="strong"><strong>OAuth2</strong></span> authentication. We will learn how to use them in <a class="link" href="ch08.html" title="Chapter 8. Exposing a REST API with Google Cloud Endpoints">Chapter 8</a>, <span class="emphasis"><em>Exposing a REST API with Google Cloud Endpoints</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Google Cloud DNS</strong></span>: This is global <span class="strong"><strong>Domain Name System</strong></span> (<span class="strong"><strong>DNS</strong></span>) service that<a id="id33" class="indexterm"/> runs on Google's<a id="id34" class="indexterm"/> infrastructure and provides high volume serving that is programmable from within our applications.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Google Cloud Pub/Sub</strong></span>: This is middleware that provides many-to-many, asynchronous<a id="id35" class="indexterm"/> messaging between services that either run on Google Cloud Platform or externally.</li></ul></div><p>All the tools and services provided by Google Cloud Platform are billed with a pay-per-use model so that applications can scale up or down as needed and we only pay for resources we actually use. A handy calculator is provided to have a precise idea of the costs depending on the services and resources we think we will need. Google Cloud Platform offers a certain amount of resources we can use without paying anything; usually, these free quotas are well suited to host web applications with low traffic at no cost.</p></div></div>
<div class="section" title="What Google App Engine does"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>What Google App Engine does</h1></div></div></div><p>As<a id="id36" class="indexterm"/> mentioned earlier, App Engine is a PaaS, which means that we have the benefits of SaaS products but with an augmented flexibility as we have complete control over the code. We also have the benefits of an IaaS solution but without the hassle of maintaining and configuring the software environment needed to run applications on a raw hardware system.</p><p>Developers are the favored users of a PaaS product such as App Engine because the platform helps them in two ways: it provides an easy way to deploy, scale, tune, and monitor web applications without the need for a system administrator and it offers a set of tools and services that speed up the software development process. Let's explore these two aspects in detail.</p><div class="section" title="The runtime environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>The runtime environment</h2></div></div></div><p>App <a id="id37" class="indexterm"/>Engine runs on computing units that are <a id="id38" class="indexterm"/>completely managed called instances. We can (and should) ignore which operating system is running on an instance because we interact solely with the runtime environment, which is an abstraction of the operating system that provides resource allocation, computation management, request handling, scaling, and load balancing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Developers can choose among four different programming languages to write applications on App Engine: Python, Java, Hypertext Preprocessor (PHP), and Go but we will focus on the Python environment.</p></div></div><p>Every time a client contacts an application that runs on App Engine, a component of the runtime environment called scheduler selects an instance that can provide a fast response, initializes it with application data if needed, and executes the application with a Python interpreter in a safe, sandboxed environment. The application receives the HTTP request, performs its work, and sends an HTTP response back to the environment. Communication between <a id="id39" class="indexterm"/>the runtime environment and the application is performed using the <span class="strong"><strong>Web Server Gateway Interface</strong></span> (<span class="strong"><strong>WSGI</strong></span>) protocol; this means that developers can use any WSGI-compatible web framework in their application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>WSGI is a specification that describes how a web server communicates with web applications written in Python. It was originally described in PEP-0333 and later updated in PEP-3333, mainly to improve usability under the Python 3.0 release.</p></div></div><p>The runtime environment is sandboxed to improve security and provide isolation between applications running on the same instance. The interpreter can execute any Python code, import other modules, and access the standard library, provided that it doesn't violate sandbox restrictions. In particular, the interpreter will raise an exception whenever it tries to write to the filesystem, perform network connections, or import extension modules written in the C language. Another isolation mechanism we must be aware of that is provided by sandboxing, prevents an application from overusing an instance by raising an exception whenever the entire request/response cycle lasts more than 60 seconds.</p><p>Thanks to sandboxing, the runtime can decide at any given time whether to run an application on one instance or many instances, with requests being spread across all of them depending on the traffic. This capability, together with load balancing and scheduler settings is what makes App Engine really scalable.</p><p>Users can<a id="id40" class="indexterm"/> easily tune an application's performance<a id="id41" class="indexterm"/> by increasing its responsiveness or optimizing costs with a simple and interactive administrative console. We can specify instance performance in terms of memory and CPU limits, the number of idle instances always ready to satisfy a request, and the number of instances dynamically started when the traffic increases. We can also specify the maximum amount of time in milliseconds we tolerate for a pending request and let App Engine adjust the settings automatically.</p></div><div class="section" title="The services"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>The services</h2></div></div></div><p>At first <a id="id42" class="indexterm"/>sight, restrictions imposed by the runtime environment might seem too restrictive. In the end, how can developers make something useful without being able to write data on disk, receive incoming network connections, fetch <a id="id43" class="indexterm"/>resources from external web applications, or start utility services such as a cache? This is why App Engine provides a set of higher-level APIs/services that can be used by developers to store and cache data or communicate over the Internet.</p><p>Some of these services are provided by the Google Cloud Platform as standalone products and are smoothly integrated into App Engine, while some others are only available from within the runtime environment.</p><p>The list of available services changes quite often as Google releases new APIs and tools; the following is a subset of tools we will use later in the book in addition to the Datastore, Google Cloud Endpoints, Google Cloud SQL, and Google Cloud Storage services we introduced earlier:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Channel</strong></span>: This API allows applications to create persistent connections <a id="id44" class="indexterm"/>with the clients and push data through such connections in real time instead of using polling strategies. Clients must use some JavaScript code to interact with the server. We will learn how to use Channels in <a class="link" href="ch06.html" title="Chapter 6. Using Channels to Implement a Real-time Application">Chapter 6</a>, <span class="emphasis"><em>Using Channels to Implement a Real-time Application</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Datastore backup/restore</strong></span>: At any given time, it's possible to perform a backup<a id="id45" class="indexterm"/> of the entities contained in the Datastore or restore them from a previous backup; management operations are very easy as they can be performed interactively from the administrative console. We will see backup and restore procedures in detail in <a class="link" href="ch04.html" title="Chapter 4. Improving Application Performance">Chapter 4</a>, <span class="emphasis"><em>Improving Application Performance</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Images</strong></span>: This API lets developers access and manipulate image data provided by the application or loaded from Google Cloud Storage. We can get information about the format, size, and colors and perform operations such as resizing, rotating, and cropping and we can convert images between different formats and apply some basic filters provided by the API. We will use some of the features <a id="id46" class="indexterm"/>provided by<a id="id47" class="indexterm"/> the Images API in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <span class="emphasis"><em>Storing and Processing Users' Data</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mail</strong></span>: This <a id="id48" class="indexterm"/>service allows applications to send e-mails on behalf of the administrators or users who are logged in with a Google Account and to receive e-mail messages sent to certain addresses and routed to the application. We will use both these features provided by the service in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <span class="emphasis"><em>Storing and Processing Users' Data</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Memcache</strong></span>: This is a general-purpose, distributed memory caching system that <a id="id49" class="indexterm"/>can be used to dramatically improve application performance, serving frequently accessed data way faster than accessing a database or an API. We will see how to use Memcache in <a class="link" href="ch04.html" title="Chapter 4. Improving Application Performance">Chapter 4</a>, <span class="emphasis"><em>Improving Application Performance</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Modules</strong></span>: These<a id="id50" class="indexterm"/> are used to split applications into logical components that can communicate and share their state with each other. They can be extremely useful as each of them can have different versions and performance and scaling settings, which provide developers with a great level of flexibility when tuning an application. We will see how to use Modules in <a class="link" href="ch04.html" title="Chapter 4. Improving Application Performance">Chapter 4</a>, <span class="emphasis"><em>Improving Application Performance</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scheduled tasks</strong></span>: This is how App Engine implements the cron jobs. Developers<a id="id51" class="indexterm"/> can schedule a job to be executed at a defined date or at regular intervals. Schedules are defined in an English-like format: for example, <code class="literal">every Friday 20:00</code> is a valid schedule we can use to send weekly reports to our users. We will see how to use scheduled tasks in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <span class="emphasis"><em>Storing and Processing Users' Data</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Task Queue</strong></span>: As mentioned earlier, the entire request/response cycle of an application <a id="id52" class="indexterm"/>running on App Engine must last at most 60 seconds, making it impossible to perform long operations. This is why the Task Queue API exists––it can perform work outside the user request so that long operations can be executed later in background with 10 minutes to finish. We will see how to use a task queue in <a class="link" href="ch03.html" title="Chapter 3. Storing and Processing Users' Data">Chapter 3</a>, <span class="emphasis"><em>Storing and Processing Users' Data</em></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>URL Fetch</strong></span>: As we already know, the runtime environment prevents our application<a id="id53" class="indexterm"/> from performing any kind of network connection but accessing external resources through HTTP requests is a common requirement for a web application. This limitation can be overcome using the URL Fetch API to issue HTTP or HTTPS requests and retrieve a response in a scalable and efficient manner.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Users</strong></span>: We can <a id="id54" class="indexterm"/>authenticate users within our applications using Google Accounts, accounts in a Google Apps domain, or through OpenID identifiers. Using the Users API our application can determine whether a user is logged in and redirect them to the login page or access their e-mail otherwise. Using this API, developers can delegate to Google or to the OpenID provider the responsibility of creating accounts and verifying the user's data.</li></ul></div><p>For more<a id="id55" class="indexterm"/> information on the tools and services provided by <a id="id56" class="indexterm"/>Google that we can use from within the App Engine environment, refer to <a class="ulink" href="https://developers.google.com/appengine/features/">https://developers.google.com/appengine/features/</a>.</p></div></div>
<div class="section" title="Making our first Python application"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Making our first Python application</h1></div></div></div><p>We <a id="id57" class="indexterm"/>have now have an idea of the features Google Cloud Platform can provide us with and we are ready to put App Engine in action, but before we can start writing some code, we need to set up our workstation.</p><div class="section" title="Download and installation"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Download and installation</h2></div></div></div><p>To get<a id="id58" class="indexterm"/> started, we need to install the Google App<a id="id59" class="indexterm"/> Engine SDK for Python for the platform of our choice. The SDK contains all the libraries needed to develop an application and a set of tools to run and test the application in the local environment and deploy it in the production servers. On some platforms, administrative tasks can be performed through a GUI, the Google App Engine Launcher, on other platforms we can use a comprehensive set of command line tools. We will see Google App Engine Launcher in detail later in this chapter.</p><p>Before installing the SDK, we have to check whether a working installation of Python 2.7 (version 2.7.8 is the latest at the time of writing this book) is available on our system; we need this specific version of Python because, with 2.5 deprecated now, it is the only version supported by the App Engine platform. If we are using Linux or Mac OS X, we can check the Python version from the terminal that issues the command (notice the capital letter <code class="literal">V</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python -V</strong></span>
</pre></div><p>The output should look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Python 2.7.8</strong></span>
</pre></div><p>If we are on Windows, we can just ensure the right version of Python is listed in the <span class="strong"><strong>Programs</strong></span> section within the <span class="strong"><strong>Control Panel</strong></span>.</p><p>The<a id="id60" class="indexterm"/> official App Engine download page contains links for <a id="id61" class="indexterm"/>all the available SDKs. The following link points directly to the Python version: <a class="ulink" href="https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python">https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python</a>.</p><p>We have to choose the right package for our platform, download the installer, and proceed with the installation.</p><div class="section" title="Installing on Windows"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Installing on Windows</h3></div></div></div><p>To <a id="id62" class="indexterm"/>install the SDK on Windows we have to<a id="id63" class="indexterm"/> download the <code class="literal">.msi</code> file from the App Engine download page, double-click it to launch the installation wizard, and follow the instructions on the screen. Once the install is complete, a shortcut to Google App Engine Launcher will be placed on the desktop as well as an item within the <span class="strong"><strong>Start</strong></span> menu. The Windows version of the SDK does not provide any command-line tool, so we will always use Launcher to manage our applications.</p></div><div class="section" title="Installing on Mac OS X"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Installing on Mac OS X</h3></div></div></div><p>To<a id="id64" class="indexterm"/> install the SDK on Mac OS X, we have <a id="id65" class="indexterm"/>to download the <code class="literal">.dmg</code> file from the App Engine download page, double-click it to open the disk image, and drag the App Engine icon into the <code class="literal">Applications</code> folder. It is convenient to keep a shortcut to Launcher in our Dock; to do so, we just have to just drag the App Engine icon again from the <code class="literal">Applications</code> folder to the dock. The command-line tools will also be installed and during the first execution of Launcher, a pop-up dialog will prompt us as to whether we want to create the symlinks needed to make the tools available system-wide, so they can be executed from any terminal window without further configuration.</p></div><div class="section" title="Installing on Linux"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Installing on Linux</h3></div></div></div><p>To install <a id="id66" class="indexterm"/>the SDK on Linux and more generally<a id="id67" class="indexterm"/> on POSIX-compliant systems, we have to download the <code class="literal">.zip</code> file from the App Engine download page and extract its contents in a directory of our choice. The archive contains a folder named <code class="literal">google_appengine</code> that contains the runtime and the command-line tools, and we have to add it to our shell's <code class="literal">PATH</code> environment variable to make the tools available from within any <a id="id68" class="indexterm"/>terminal. The Linux version of the SDK<a id="id69" class="indexterm"/> does not include Launcher.</p></div></div><div class="section" title="App Engine Launcher"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>App Engine Launcher</h2></div></div></div><p>The <a id="id70" class="indexterm"/>Windows and OS X versions of the SDK<a id="id71" class="indexterm"/> ships with a graphical user interface tool called Launcher that we can use to perform administrative tasks such as creating and managing multiple applications.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Launcher is a very handy tool but bear in mind that while every single task we can accomplish through Launcher can be performed by command-line tools as well, the contrary isn't true. There are tasks that can be performed only from the command line using the proper tools as we will see later in the book.</p></div></div><p>The following screenshot shows the Launcher window in OS X:</p><div class="mediaobject"><img src="graphics/8194OS_01_02.jpg" alt="App Engine Launcher"/></div><p>We can see the Launcher in Windows in the following screenshot:</p><div class="mediaobject"><img src="graphics/8194OS_01_03.jpg" alt="App Engine Launcher"/></div><p>Before <a id="id72" class="indexterm"/>we start using the Launcher it's important to<a id="id73" class="indexterm"/> check whether it is using the right Python version. This is very important if we have more than one Python installation in our system. To check the Python version used by Launcher and to change it, we can open the <span class="strong"><strong>Preferences...</strong></span> dialog by clicking the appropriate menu depending on our platform and set the Python path value. In the same dialog we can specify which text editor Launcher will open by default when we need to edit application files.</p><p>To create a new application we can click <span class="strong"><strong>New Application</strong></span> in the <span class="strong"><strong>File</strong></span> menu or click the button with a plus sign icon in the bottom-left corner of the Launcher window. Launcher will prompt for the application name and the path to the folder that will contain all the project files; once created, the application will be listed in the main window of Launcher.</p><p>We can start the local development server by clicking the <span class="strong"><strong>Run</strong></span> button on the Launcher toolbar or clicking <span class="strong"><strong>Run</strong></span> in the <span class="strong"><strong>Control</strong></span> menu. Once the server is started, we can stop it by clicking on the <span class="strong"><strong>Stop</strong></span> button or the <span class="strong"><strong>Stop</strong></span> entry in the <span class="strong"><strong>Control</strong></span> menu. Clicking the <span class="strong"><strong>Browse</strong></span> button or the <span class="strong"><strong>Browse</strong></span> entry in the <span class="strong"><strong>Control</strong></span> menu opens the default browser at the home page of the selected application. To browse the logs produced by the development server, we can open the <span class="strong"><strong>Log Console</strong></span> window by clicking the <span class="strong"><strong>Logs</strong></span> button on the toolbar or the <span class="strong"><strong>Logs</strong></span> entry in the <span class="strong"><strong>Control</strong></span> menu. The <span class="strong"><strong>SDK Console</strong></span> button on the toolbar and the <span class="strong"><strong>SDK Console</strong></span> action on the <span class="strong"><strong>Control</strong></span> menu will open the default browser at the URL that serves the<a id="id74" class="indexterm"/> Developer Console, a built-in application to<a id="id75" class="indexterm"/> interact with the local development server, which we will explore in detail later in this chapter.</p><p>The <span class="strong"><strong>Edit</strong></span> button will open the configuration file for the selected application in an external text editor, maybe the one we specified in the <span class="strong"><strong>Preferences...</strong></span> dialog; the same happens when we click the <span class="strong"><strong>Open in External Editor</strong></span> action in the <span class="strong"><strong>Edit</strong></span> menu.</p><p>To deploy and upload the selected application to App Engine we can click the <span class="strong"><strong>Deploy</strong></span> button on the toolbar or click the <span class="strong"><strong>Deploy</strong></span> action in the <span class="strong"><strong>Control</strong></span> menu. The <span class="strong"><strong>Dashboard</strong></span> button on the toolbar and the <span class="strong"><strong>Dashboard</strong></span> action in the <span class="strong"><strong>Control</strong></span> menu will open the default browser at the URL of App Engine Administrative Console.</p><p>Using Launcher we can set additional flags for the local development server and customize some parameters such as the TCP port number to which listens. To do so we have to click the <span class="strong"><strong>Application Settings...</strong></span> entry in the <span class="strong"><strong>Edit</strong></span> menu and make the desired adjustments in the settings dialog.</p><p>Launcher can also handle existing applications created from scratch through the command line or checked out from an external repository. To add an existing application to the Launcher, we can click the <span class="strong"><strong>Add Existing Application...</strong></span> entry in the <span class="strong"><strong>File</strong></span> menu and specify the application path.</p></div><div class="section" title="Creating the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Creating the application</h2></div></div></div><p>The first <a id="id76" class="indexterm"/>step to create an application is pick a name for it. According to the tradition we're going to write an application that will print <span class="strong"><strong>"Hello, World!"</strong></span> so we can choose <code class="literal">helloword</code> as the application name. We already know how to create an application from Launcher, the alternative is to do it manually from the command line.</p><p>At the simplest, a working Python application consists of a folder called application root that contains an <code class="literal">app.yaml</code> configuration file and a Python module with the code needed to handle HTTP requests. When we create an application within Launcher, it takes care of generating those files and the <code class="literal">root</code> folder for us, but let's see how can we can accomplish the same result from the command line.</p><div class="section" title="The app.yaml configuration file"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>The app.yaml configuration file</h3></div></div></div><p>When <a id="id77" class="indexterm"/>we start creating the <code class="literal">root</code> folder, it <a id="id78" class="indexterm"/>doesn't matter how we name it but to be consistent with Launcher we can use the application's name:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mkdir helloworld &amp;&amp; cd helloworld</strong></span>
</pre></div><p>We then create an <code class="literal">app.yaml</code> file that contains the following <code class="literal">YAML</code> code:</p><div class="informalexample"><pre class="programlisting">application: helloworld
version: 1
runtime: python27
api_version: 1
threadsafe: yes

handlers:
- url: .*
  script: main.app

libraries:
- name: webapp2
  version: "2.5.2"</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p><span class="strong"><strong>YAML </strong></span>(<span class="strong"><strong>a recursive acronym for YAML Ain't Markup Language</strong></span>) is a human-readable serialization format that is<a id="id79" class="indexterm"/> suitable for configuration files that have to be accessed and manipulated both from users and programmatically.</p></div></div><p>The first section of the previous code defines some setup parameters for the application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The</strong></span> <code class="literal">application</code> <span class="strong"><strong>parameter</strong></span>: This is<a id="id80" class="indexterm"/> the application name; later in the chapter, we'll see how important it is.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The</strong></span> <code class="literal">version</code> <span class="strong"><strong>parameter</strong></span>: This is a string that specifies the version of the application. App Engine retains a copy of each version deployed and we can run <a id="id81" class="indexterm"/>them selectively, a very useful feature for testing an application before making it public.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The</strong></span> <code class="literal">runtime</code> <span class="strong"><strong>parameter</strong></span>: At the time of writing this book, Python 27 is the only <a id="id82" class="indexterm"/>runtime available for newly created applications as Python 25 was deprecated.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The</strong></span> <code class="literal">api_version</code> <span class="strong"><strong>parameter</strong></span>: This is the version of the API for the current runtime <a id="id83" class="indexterm"/>environment. At the time writing this, 1 is the only API version available for the Python 27 runtime.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The</strong></span> <code class="literal">threadsafe</code> <span class="strong"><strong>parameter</strong></span>: This specifies whether our application can handle<a id="id84" class="indexterm"/> requests concurrently in separate threads or not.</li></ul></div><p>The next section of the <code class="literal">app.yaml</code> file lists the URLs we want to match in the form of a regular expression; the <code class="literal">script</code> property specifies the handler for each URL. A handler is a procedure App Engine invokes to provide a response when an application receives a request. There are two types of handlers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The</strong></span> <code class="literal">script</code> <span class="strong"><strong>handlers</strong></span>: These<a id="id85" class="indexterm"/> handlers run the Python code provided by the application</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The</strong></span> <code class="literal">static file</code> <span class="strong"><strong>handlers</strong></span>: These handlers return the content of a static resource <a id="id86" class="indexterm"/>such as an image or a file that contain the JavaScript code</li></ul></div><p>In this <a id="id87" class="indexterm"/>case, we are using a <code class="literal">script</code> handler, a Python callable addressed with a dot notation import string: App Engine <a id="id88" class="indexterm"/>will match any URL and invoke the <code class="literal">app</code> object contained in the <code class="literal">main</code> module.</p><p>The final section lists the name and version of third-party modules provided by App Engine we want to use from our application, and in this case we only need the latest version of the webapp2 web framework. We might wonder why we need something complex such as a web framework to simply print a <span class="strong"><strong>"Hello, World!"</strong></span> message, but as we already know, our handler must implement a WSGI-compliant interface and this is exactly one of the features provided by webapp2. We will see how to use it in the next section.</p></div><div class="section" title="The main.py application script"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>The main.py application script</h3></div></div></div><p>Now <a id="id89" class="indexterm"/>that the application is configured, we <a id="id90" class="indexterm"/>need to provide logic, so we create a file named <code class="literal">main.py</code> in the application root folder that will contain the following:</p><div class="informalexample"><pre class="programlisting">import webapp2

class MainHandler(webapp2.RequestHandler):
    def get(self):
        self.response.write('Hello world!')

app = webapp2.WSGIApplication([
    ('/', MainHandler)
], debug=True)</pre></div><p>In the first line of the previous code we import the <code class="literal">webapp2</code> package into our code, and then we proceed to define a class named <code class="literal">MainHandler</code> that is derived from the <code class="literal">RequestHandler</code> class provided by the framework. The base class implements a behavior that makes it very easy to implement a handler for HTTP requests; all we have to do is to define a method named after the HTTP action we want to handle. In this case, we implement the <code class="literal">get()</code> method that will be automatically invoked whenever the application<a id="id91" class="indexterm"/> receives a request of the type <code class="literal">GET</code>. The <code class="literal">RequestHandler</code> class also provides a <code class="literal">self.response</code> property we can use to access the response object that will be returned to the application server. This property is a file-like object that supports a <code class="literal">write()</code> method we can use to add content to the body of the HTTP response; in this case we write a string inside the response body with the default content type <code class="literal">text/html</code> so that it will be shown inside the browser.</p><p>Right <a id="id92" class="indexterm"/>after the <code class="literal">MainHandler</code> class definition we<a id="id93" class="indexterm"/> create the <code class="literal">app</code> object, which is an instance of the <code class="literal">WSGIApplication</code> class provided by webapp2 that implements the WSGI-compliant callable entry point we specified in <code class="literal">app.yaml</code> with the import string <code class="literal">main.app</code>. We pass two parameters to the class constructor, a list of URL patterns, and a Boolean flag stating whether the application should run in debug mode or not. URL patterns are tuples that contain two elements: a regular expression that matches requested URLs and a class object derived from <code class="literal">webapp2.RequestHandler</code> class that will be instantiated to handle requests. URL patterns are processed one by one in the order they are in the list until one matches and the corresponding handler is called.</p><p>As we may notice, URL mappings take place twice—firstly in the <code class="literal">app.yaml</code> file, where a URL is routed to a WSGI compatible application in our code and then in the <code class="literal">WSGIApplication</code> class instance, where an URL is routed to a request handler object. We can freely choose how to use these mappings, that is either route all URLs in the <code class="literal">app.yaml</code> file to a single webapp2 application where they are dispatched to handlers or to different URLs to different, smaller webapp2 applications.</p></div></div><div class="section" title="Running the development server"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Running the development server</h2></div></div></div><p>The App<a id="id94" class="indexterm"/> Engine SDK provides an extremely useful tool called <span class="strong"><strong>development server</strong></span> that runs on our local system emulating <a id="id95" class="indexterm"/>the runtime environment we will find in production. This way, we can test our applications locally as we write them. We already know how to start the development server from Launcher. To launch it from the command line instead, we run the <code class="literal">dev_appserver.py</code> command tool passing the root folder of the application we want to execute as an argument. For example, if we're already inside the root folder of our <code class="literal">helloworld</code> application, to start the server, we can run this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dev_appserver.py .</strong></span>
</pre></div><p>The development server will print some status information on the shell and will then start listen at the local host to the default TCP ports 8000 and 8080, serving the admin console and the application respectively.</p><p>While the server is running, we can open a browser, point it at <code class="literal">http://localhost:8080</code> and see our first web application serving content.</p><p>The following screenshot shows the output:</p><div class="mediaobject"><img src="graphics/8194OS_01_04.jpg" alt="Running the development server"/></div><p>If we are using Launcher, we can simply press the <span class="strong"><strong>Browse</strong></span> button and the browser will be opened automatically at the right URL.</p><p>The development <a id="id96" class="indexterm"/>server automatically <a id="id97" class="indexterm"/>restarts application instances whenever it detects that some content on the application root folder has changed. For example, while the server is running we can try to change the Python code that alters the string we write in the response body:</p><div class="informalexample"><pre class="programlisting">import webapp2

class MainHandler(webapp2.RequestHandler):
    def get(self):
        self.response.write('&lt;H1&gt;Hello world!&lt;/H1&gt;')
        self.response.write("&lt;p&gt;I'm using App Engine!&lt;/p&gt;")

app = webapp2.WSGIApplication([
    ('/', MainHandler)
], debug=True)</pre></div><p>After saving the file, we can refresh the browser and immediately see the changes without <a id="id98" class="indexterm"/>reloading the server, as shown in the <a id="id99" class="indexterm"/>following screenshot:</p><div class="mediaobject"><img src="graphics/8194OS_01_05.jpg" alt="Running the development server"/></div><p>We can now move our application to a production server on App Engine and make it available through the Internet.</p></div><div class="section" title="Uploading the application to App Engine"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Uploading the application to App Engine</h2></div></div></div><p>Every <a id="id100" class="indexterm"/>application running on App Engine is<a id="id101" class="indexterm"/> uniquely identified by its name within the Google Cloud Platform. That is why sometimes we find parts of the documentation and tools referring to that as application ID. When working on a local system, we can safely pick any name we want for an application as the local server does not enforce any control on the application ID; but, if we want to deploy an application in production, the application ID must be validated and registered through App Engine Admin Console.</p><p>Admin Console<a id="id102" class="indexterm"/> can be accessed at <a class="ulink" href="https://appengine.google.com/">https://appengine.google.com/</a> and log in with a valid Google user account or a Google apps account for custom domains. If we are using Application Launcher, clicking the <span class="strong"><strong>Dashboard</strong></span> button will open the browser at the right address for us. Once logged in, we can click the <span class="strong"><strong>Create Application</strong></span> button to access the application creation page. We have to provide an application ID (the console will tell us whether it is valid and available) and a title for the application and we're done. For now, we can accept the default values for the remaining options; clicking on <span class="strong"><strong>Create Application</strong></span> again will finally register the application's ID for us.</p><p>Now we have to change the dummy application ID we provided for our application with the one registered on App Engine. Open the <code class="literal">app.yaml</code> configuration file and change the <code class="literal">application</code> property accordingly:</p><div class="informalexample"><pre class="programlisting">application: the_registered_application_ID
version: 1
runtime: python27
api_version: 1
threadsafe: yes

handlers:
- url: .*
  script: main.app

libraries:
- name: webapp2
  version: "2.5.2"</pre></div><p>We are now ready to deploy the application on App Engine. If we are using Application Launcher, all we have to do is click on the <span class="strong"><strong>Deploy</strong></span> button in the toolbar. Launcher will ask for our Google credentials and then the log window will open showing the deployment status. If everything went fine the last line shown should be something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>*** appcfg.py has finished with exit code 0 ***</strong></span>
</pre></div><p>Deploying from the command line is just as easy; from the application root directory, we issue the command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>appcfg.py update .</strong></span>
</pre></div><p>We will be prompted for our Google account credentials, and then the deployment will proceed automatically.</p><p>Every App Engine application running in production can be accessed via <code class="literal">http://the_registered_application_ID.appspot.com/</code>, so we can tell whether the application is actually working by accessing this URL from a browser and checking whether the output is the same as that produced by the local development server.</p><p>Google<a id="id103" class="indexterm"/> App Engine allow us to serve<a id="id104" class="indexterm"/> content over <span class="strong"><strong>HTTPS</strong></span> (<span class="strong"><strong>HTTP Secure</strong></span>) connections <a id="id105" class="indexterm"/>on top of the <span class="strong"><strong>Secure Sockets Layer</strong></span> (<span class="strong"><strong>SSL</strong></span>) protocol, which<a id="id106" class="indexterm"/> means that data transferred from and to the server is encrypted. When using the <code class="literal">appspot.com</code> domain, this option is free of charge. To enable secure connections between clients and the App Engine server, all we have to do is add the <code class="literal">secure</code> option to the URLs listed in the <code class="literal">app.yaml</code> file:</p><div class="informalexample"><pre class="programlisting">handlers:
- url: .*
  script: main.app
  secure: always</pre></div><p>On the local development server we will still use regular HTTP connections, but in production we will access <code class="literal">https://the_registered_application_ID.appspot.com/</code> in a secure manner over HTTPS connections.</p><p>If we want to access the application over HTTPS through a custom domain instead, such as <code class="literal">example.com</code>, we<a id="id107" class="indexterm"/> have to configure App Engine so that the platform can use our certificates by following the instructions at <a class="ulink" href="https://cloud.google.com/appengine/docs/ssl">https://cloud.google.com/appengine/docs/ssl</a>. This service has a fee and we will be charged monthly.</p></div></div>
<div class="section" title="Google Developer Console"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Google Developer Console</h1></div></div></div><p>Before Google Cloud Platform was released, Admin Console was the only tool available to developers to perform administrative and monitoring tasks on App Engine applications.<a id="id108" class="indexterm"/> Admin Console provides a lot of functionalities and it's still powerful enough to manage App Engine applications of any size. However, it's not the right tool if we extensively use the new range of services offered by the Google Cloud Platform, especially if we store data on Google Cloud Storage or our database server is Google Cloud SQL; in this case, to collect information such as billing data and usage history we have to interact with other tools.</p><p>Recently Google released <span class="strong"><strong>Developer Console</strong></span>, a comprehensive tool to manage and monitor services, resources, authentication, and billing information for Google Cloud Platform, including <a id="id109" class="indexterm"/>App Engine applications. We can access the Developer Console at <a class="ulink" href="https://console.developers.google.com/">https://console.developers.google.com/</a> and log in with a valid Google user account or a Google apps account for custom domains.</p><p>To emphasize the concept that developers can combine various pieces coming from Google's cloud infrastructure to build complex applications, Developer Console introduces the notion of cloud projects. A project is a set of functionally grouped cloud products that share the same team and billing information. At the core of a project there is always an <a id="id110" class="indexterm"/>App Engine application: every time we create a project, an App Engine application pops up in Admin Console. Simultaneously, when we register an application in Admin Console, a corresponding project is created and listed in Developer Console. Every project is identified by a descriptive name, which is a unique identifier called project ID that is also the ID of the related App Engine application and another unique identifier that is automatically generated called project number.</p><p>Beside creating and deleting projects, the developer console also let us do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manage project members</strong></span>: When we create a project we become the owner of that project. As owners, we<a id="id111" class="indexterm"/> can add or remove members and set their permissions.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manage APIs</strong></span>: We can add or remove API services provided by Google Cloud<a id="id112" class="indexterm"/> Platform, set up billing, and monitor data.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manage applications identity</strong></span>: We can tie requests to specific projects so that <a id="id113" class="indexterm"/>we can monitor specific traffic and billing and enforce quotas if needed.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Manage applications security</strong></span>: We can set up<a id="id114" class="indexterm"/> OAuth2 for our applications or provide API keys to authorize requests.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Filter and cap services</strong></span>: We can allow requests coming only from authorized hosts<a id="id115" class="indexterm"/> or IP addresses and limit the <a id="id116" class="indexterm"/>amount of requests allowed for each user every second or every day for all the users.</li></ul></div><p>For every service of Google Cloud Platform, Developer Console provides us with handy tools to perform maintenance operations through the web interface. For example, we can add or remove Google Cloud SQL instances, perform queries on Google Cloud Datastore, browse and manipulate the content of Google Cloud Storage, and manage virtual machines running on Google Compute Engine. We will use several parts of Developer Console later in the book.</p><div class="section" title="Development Console"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Development Console</h2></div></div></div><p>When we<a id="id117" class="indexterm"/> are on the local development <a id="id118" class="indexterm"/>server we can still access a tool to browse and manage Datastore, task queues, cron jobs, and other App Engine emulated components running locally. This tool is called <span class="strong"><strong>Development Console</strong></span> and is accessible at <code class="literal">http://localhost:8000</code> when the local server is active.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter we have learned what Google Cloud Platform is, the tools and services it provides, and how we can use them to develop and run fast and scalable web applications written in Python.</p><p>We explored what tools we need to start developing with Python for the App Engine platform, how to run an application locally with the development server, and how fast and easy it is to upload it in a production server, ready to be served through the Internet.</p><p>The simple example we used in the chapter, although a fully functional App Engine application, is quite simple and it doesn't make use of anything provided by the platform besides the runtime environment. In the next chapter, we will start from scratch with a new, more useful application, exploring the webapp2 framework and taking advantage of Cloud Datastore.</p></div></body></html>