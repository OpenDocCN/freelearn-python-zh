["```py\npython -m pip install matplotlib jupyterlab\n```", "```py\nInstalling collected packages: pyparsing, pillow, numpy, kiwisolver, fonttools, cycler, contourpy, matplotlib\n```", "```py\n    (coobook3) % python -m jupyter lab\n    ```", "```py\n    from matplotlib import pyplot as plt \n\n    from pydantic import BaseModel\n    ```", "```py\n(cookbook3) % python -m jupyter server list\n```", "```py\n(cookbook3) % jupyter server list \n\nCurrently running servers: \n\nhttp://localhost:8888/?token=85e8ad8455cd154bd3253ba0339c783ea60c56f836f7b81c :: /Users/slott/Documents/Writing/Python/Python Cookbook 3e\n```", "```py\n    import json \n\n    from pathlib import Path\n    ```", "```py\n    source_path = Path.cwd().parent.parent / \"data\" / \"anscombe.json\" \n\n    with source_path.open() as source_file: \n\n        all_data = json.load(source_file) \n\n    [data[’series’] for data in all_data]\n    ```", "```py\n    all_data[0][’data’]\n    ```", "```py\n    import json \n\n    from pathlib import Path \n\n    from pydantic import BaseModel\n    ```", "```py\n    class Pair(BaseModel): \n\n        x: float \n\n        y: float \n\n    class Series(BaseModel): \n\n        series: str \n\n        data: list[Pair]\n    ```", "```py\n    clean_data = [Series.model_validate(d) for d in all_data]\n    ```", "```py\n    quartet = {s.series: s for s in clean_data}\n    ```", "```py\nsource_path = Path.cwd().parent.parent / \"data\" / \"anscombe.json\" \n\nwith source_path.open() as source_file: \n\n    json_document = json.load(source_file) \n\n    source_data = (Series.model_validate(s) for s in json_document) \n\n    quartet = {s.series: s for s in source_data}\n```", "```py\nfor name in quartet: \n\n    print(f\"{name:3s} {len(quartet[name].data):d}\")\n```", "```py\n    # Anscombe’s Quartet \n\n    The raw data has four series. The correlation coefficients are high. \n\n    Visualization shows that a simple linear regression model is misleading. \n\n    ## Raw Data for the Series\n    ```", "```py\n    import json \n\n    from pathlib import Path \n\n    from pydantic import BaseModel\n    ```", "```py\n    class Pair(BaseModel): \n\n        x: float \n\n        y: float \n\n    class Series(BaseModel): \n\n        series: str \n\n        data: list[Pair]\n    ```", "```py\n    source = Path.cwd().parent.parent / \"data\" / \"anscombe.json\" \n\n    with source.open() as source_file: \n\n        json_document = json.load(source_file) \n\n        source_data = (Series.model_validate(s) for s in json_document) \n\n        quartet = {s.series: s for s in source_data}\n    ```", "```py\n    ## Visualization of each series\n    ```", "```py\n    from matplotlib import pyplot as plt\n    ```", "```py\n    x = [p.x for p in quartet[’I’].data] \n\n    y = [p.y for p in quartet[’I’].data] \n    ```", "```py\n    plt.scatter(x, y) \n\n    plt.title(f\"Series {quartet[’I’].series}\") \n\n    plt.show()\n    ```", "```py\nclass Series(BaseModel): \n\n    series: str \n\n    data: list[Pair] \n\n    @property \n\n    def x(self) -> list[float]: \n\n        return [p.x for p in self.data] \n\n    @property \n\n    def y(self) -> list[float]: \n\n        return [p.y for p in self.data]\n```", "```py\nplt.figure(layout=’tight’) \n\nfor n, series in enumerate(quartet.values(), start=1): \n\n    title = f\"Series {series.series}\" \n\n    plt.subplot(2, 2, n) \n\n    plt.scatter(series.x, series.y) \n\n    plt.title(title)\n```", "```py\n    # Anscombe’s Quartet \n\n    Visualization with correlation coefficients and linear regression model. \n\n    ## Raw Data for the Series\n    ```", "```py\n    import json \n\n    from pathlib import Path \n\n    import statistics \n\n    from pydantic import BaseModel\n    ```", "```py\n    class Pair(BaseModel): \n\n        x: float \n\n        y: float\n    ```", "```py\n     return [p.y for p in self.data] \n\n        @property \n\n        def correlation(self) -> float: \n\n            return statistics.correlation(self.x, self.y) \n    ```", "```py\n    source = Path.cwd().parent.parent / \"data\" / \"anscombe.json\" \n\n    with source.open() as source_file: \n\n        json_document = json.load(source_file) \n\n        source_data = (Series.model_validate(s) for s in json_document) \n\n        quartet = {s.series: s for s in source_data}\n    ```", "```py\n    fig = plt.figure(layout=’tight’)\n    ```", "```py\n    ax_dict = fig.subplot_mosaic( \n\n        [ \n\n            [\"I\", \"II\"], \n\n            [\"III\", \"IV\"], \n\n        ], \n\n    )\n    ```", "```py\n    for name, ax in ax_dict.items(): \n\n        series = quartet[name] \n\n        ax.scatter(series.x, series.y) \n\n        ax.set_title(f\"Series {name}\") \n\n        eq1 = rf\"$r = {series.correlation:.3f}$\" \n\n        ax.text(.95, .05, f\"{eq1}\", \n\n                fontfamily=’sans-serif’, \n\n                horizontalalignment=’right’, verticalalignment=’bottom’, transform=ax.transAxes) \n\n    plt.show()\n    ```", "```py\n    plt.show()\n    ```", "```py\n     @property \n\n        def regression(self) -> tuple[float, float]: \n\n            return statistics.linear_regression(self.x, self.y)\n    ```", "```py\n     lr = series.regression \n\n        eq1 = rf\"$r = {series.correlation:.3f}$\" \n\n        eq2 = rf\"$Y = {lr.slope:.1f} \\times X + {lr.intercept:.2f}$\" \n\n        ax.text(.95, .05, f\"{eq1}\\n{eq2}\", \n\n                fontfamily=’sans-serif’, \n\n                horizontalalignment=’right’, verticalalignment=’bottom’, transform=ax.transAxes) \n\n        ax.axline((0, lr.intercept), slope=lr.slope)\n    ```", "```py\n    ax.axline((0, lr.intercept), slope=lr.slope)\n```", "```py\n    from IPython.display import display, Markdown\n    ```", "```py\n    m = Markdown(rf\"\"\" \n\n    We can see that $r = {quartet[’I’].correlation:.2f}$; this is a strong correlation. \n\n    This leads to a linear regression result with $y = {r.slope:.1f} \\times x + {r.intercept:.1f}$ as the best fit \n\n    for this collection of samples. \n\n    Interestingly, this is true for all four series in spite of the dramatically distinct scatter plots. \n\n    \"\"\")\n    ```", "```py\n    display(m)\n    ```", "```py\n    def ingest(source: Path) -> dict[str, Series]: \n\n        \"\"\" \n\n        >>> doctest example \n\n        \"\"\" \n\n        with source.open() as source_file: \n\n            json_document = json.load(source_file) \n\n            source_data = (Series.model_validate(s) for s in json_document) \n\n            quartet = {s.series: s for s in source_data} \n\n        return quartet\n    ```", "```py\n    source = Path.cwd().parent.parent / \"data\" / \"anscombe.json\" \n\n    quartet = ingest(source)\n    ```", "```py\n     assert len(quartet) == 4, f\"read {len(quartet)} series\" \n\n    assert list(quartet.keys()) == [\"I\", \"II\", \"III\", \"IV\"], f\"keys were {list(quartet.keys())}\"\n    ```", "```py\n    (cookbook3) % jupyter execute src/ch12/recipe_06.ipynb\n    ```", "```py\n    [NbClientApp] Executing src/ch12/recipe_06.ipynb \n\n    [NbClientApp] Executing notebook with kernel: python3\n    ```", "```py\nvalue = 355/113 \n\nassert value == 3.14, f\"invald {value}\"\n```", "```py\n--------------------------------------------------------------------------- \n\nAssertionError                            Traceback (most recent call last) \n\nCell In[4], line 2 \n\n      1 value = 355/113 \n\n----> 2 assert value == 3.14, f\"invald {value}\" \n\nAssertionError: invald 3.1415929203539825\n```", "```py\nfrom math import isclose \n\ntest = Series( \n\n    series=\"test\", \n\n    data=[Pair(x=2, y=4), Pair(x=3, y=6), Pair(x=5, y=10)] \n\n) \n\nassert isclose(test.correlation, 1.0) \n\nassert isclose(test.regression.slope, 2.0) \n\nassert isclose(test.regression.intercept, 0.0)\n```"]