- en: 8\. Media Serving and File Uploads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 媒体服务和文件上传
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter starts by introducing you to media files and then teaching you
    how to set up Django to serve them. Once you have understood this, you will learn
    how to build a form in HTML that can upload files to a view for storage to disk.
    To enhance this process and reduce the amount of code, you will use Django forms
    to generate and validate a form and learn how to process file uploads through
    it. You will then look at some enhancements that Django provides specifically
    for working with image files and use the `FileField` and `ImageField` to store
    a file and image respectively and upload to it using a Django form. After this,
    you will build a `ModelForm` instance automatically from the model and save the
    model and the files using just one line of code. At the end of this chapter, you
    will enhance the Bookr app by adding a cover image and book excerpt to the `Book`
    model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先向您介绍媒体文件，然后教您如何设置Django以服务它们。一旦您理解了这一点，您将学习如何使用HTML构建一个表单，该表单可以将文件上传到一个视图以存储到磁盘。为了增强这个过程并减少代码量，您将使用Django表单来生成和验证表单，并学习如何通过它处理文件上传。然后，您将查看Django为处理图像文件提供的特定增强功能，并使用`FileField`和`ImageField`分别存储文件和图像，并通过Django表单上传它们。在此之后，您将自动从模型构建一个`ModelForm`实例，并仅用一行代码保存模型和文件。在本章结束时，您将通过向`Book`模型添加封面图像和书籍摘录来增强Bookr应用。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Media files refer to extra files that can be added after deployment to enrich
    your Django application. Usually, they are extra images that you would use in
    your site, but any type of file (including video, audio, PDF, text, documents,
    or even HTML) can be served as media.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体文件是指在部署后可以添加的额外文件，用于丰富您的Django应用。通常，它们是您在网站上使用的额外图像，但任何类型的文件（包括视频、音频、PDF、文本、文档，甚至是HTML）都可以作为媒体提供服务。
- en: You can think of them as somewhere between dynamic data and static assets. They
    are not dynamic data that Django generates on the fly, like when rendering a template.
    They also are not the static files that are included by the site developer when
    the site is deployed. Instead, they are extra files that can be uploaded by users
    or generated by your application for later retrieval.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将它们视为介于动态数据和静态资产之间。它们不是Django在动态生成时产生的动态数据，例如在渲染模板时。它们也不是网站开发者在网站部署时包含的静态文件。相反，它们是可以由用户上传或由您的应用程序生成以供以后检索的额外文件。
- en: Some common examples of media files (that you will see in *Activity 8.01*, *Image
    and PDF Uploads of Books*, later in this chapter) are book covers and preview
    PDFs that can be attached to a `Book` object. You can also use media files to
    allow users to upload images for a blog post or avatars for a social media site.
    If you wanted to use Django to build your own video sharing platform, you would
    store the uploaded videos as media. Your website will not function well if all
    these files are static files, as users won't be able to upload their own book
    covers, videos, and so on, and will be stuck with the ones you deployed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体文件的常见示例（您将在本章后面的*活动8.01*、*书籍图像和PDF上传*中看到）包括书籍封面和可以附加到`Book`对象的预览PDF。您还可以使用媒体文件允许用户上传博客文章的图像或社交媒体网站的头像。如果您想使用Django构建自己的视频分享平台，您将存储上传的视频作为媒体。如果所有这些文件都是静态文件，您的网站将无法很好地运行，因为用户将无法上传自己的书籍封面、视频等，并将陷入您部署的状态。
- en: Settings for Media Uploads and Serving
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体上传和服务的设置
- en: 'In *Chapter 5*, *Serving Static Files*, we looked at how Django can be used
    to serve static files. Serving media files is quite similar. Two settings must
    be configured in `settings.py`: `MEDIA_ROOT` and `MEDIA_URL`. These are analogous
    to `STATIC_ROOT` and `STATIC_URL` for serving static files.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*服务静态文件*中，我们探讨了如何使用Django来服务静态文件。服务媒体文件相当类似。必须在`settings.py`中配置两个设置：`MEDIA_ROOT`和`MEDIA_URL`。这些与用于服务静态文件的`STATIC_ROOT`和`STATIC_URL`类似。
- en: '`MEDIA_ROOT`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEDIA_ROOT`'
- en: This is the path on the disk where the media (such as uploaded files) will be
    stored. As with static files, your web server should be configured to serve directly
    from this directory, to take the load off Django.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是磁盘上存储媒体（如上传的文件）的路径。与静态文件一样，您的Web服务器应该配置为直接从这个目录提供服务，以减轻Django的负担。
- en: '`MEDIA_URL`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEDIA_URL`'
- en: This is similar to `STATIC_URL`, but as you might guess, it's the URL that should
    be used to serve media. It must end in a `/`. Generally, you will use something
    like `/media/`.
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与`STATIC_URL`类似，但正如您可能猜到的，这是应该用于服务媒体的URL。它必须以`/`结尾。通常，您将使用类似`/media/`的东西。
- en: Note
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For security reasons, the path for `MEDIA_ROOT` must not be the same as the
    path for `STATIC_ROOT`, and `MEDIA_URL` must not be the same as `STATIC_URL`.
    If they were the same, a user might replace your static files (such as JavaScript
    or CSS files) with malicious code and exploit your users.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于安全原因，`MEDIA_ROOT` 的路径必须与 `STATIC_ROOT` 的路径不同，并且 `MEDIA_URL` 必须与 `STATIC_URL`
    不同。如果它们相同，用户可能会用恶意代码替换你的静态文件（如 JavaScript 或 CSS 文件），并利用你的用户。
- en: '`MEDIA_URL` is designed to be used in templates so that you are not hardcoding
    the URL and it can be changed easily. For example, you might want to set it to
    a specific host or `MEDIA_URL` in templates in an upcoming section.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEDIA_URL` 设计用于在模板中使用，这样你就不需要硬编码 URL，并且可以轻松更改。例如，你可能希望将其设置为特定主机或在下文中的模板中的
    `MEDIA_URL`。'
- en: Serving Media Files in Development
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发中服务媒体文件
- en: As with static files, when serving media in production, your web server should
    be configured to serve directly from the `MEDIA_ROOT` directory to prevent Django
    from being tied up servicing the request. The Django dev server can serve media
    files in development. However, unlike static files, the URL mapping and view is
    not set up automatically for media files.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像静态文件一样，在生产环境中服务媒体时，你的 Web 服务器应该配置为直接从 `MEDIA_ROOT` 目录服务，以防止 Django 被绑定在服务请求上。Django
    开发服务器可以在开发中服务媒体文件。然而，与静态文件不同，媒体文件的 URL 映射和视图不是自动设置的。
- en: 'Django provides the `static` URL mapping that can be added to your existing
    URL maps to serve media files. It is added to your `urls.py` file like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了 `static` URL 映射，可以添加到现有的 URL 映射中，以服务媒体文件。它像这样添加到你的 `urls.py` 文件中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will serve the `MEDIA_ROOT` setting defined in `settings.py` to the `MEDIA_URL`
    setting that is also defined there. The reason we check for `settings.DEBUG` before
    appending the map is so we don't add this map in production.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将 `settings.py` 中定义的 `MEDIA_ROOT` 设置服务到那里也定义的 `MEDIA_URL` 设置。我们在添加映射之前检查 `settings.DEBUG`
    的原因是为了确保在生产环境中不添加此映射。
- en: For example, if your `MEDIA_ROOT` was set to `/var/www/bookr/media`, and your
    `MEDIA_URL` was set to `/media/`, then the `/var/www/bookr/media/image.jpg` file
    would be available at `http://127.0.0.1:8000/media/image.jpg`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的 `MEDIA_ROOT` 设置为 `/var/www/bookr/media`，而你的 `MEDIA_URL` 设置为 `/media/`，那么
    `/var/www/bookr/media/image.jpg` 文件将在 `http://127.0.0.1:8000/media/image.jpg`
    处可用。
- en: The `static` URL map does not work when the Django `DEBUG` setting is `False`,
    and so it can't be used in production. However, as mentioned earlier, in production
    your web server should be serving these requests, so Django will not need to handle
    them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Django 的 `DEBUG` 设置为 `False` 时，`static` URL 映射不起作用，因此不能在生产环境中使用。然而，如前所述，在生产环境中，你的
    Web 服务器应该服务这些请求，因此 Django 不需要处理它们。
- en: In the first exercise, you will create and add a new `MEDIA_ROOT` and `MEDIA_URL`
    to your `settings.py` file. You will then add the `static` media serving URL map
    and add a test file to ensure media serving is configured correctly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，你将在 `settings.py` 文件中创建并添加一个新的 `MEDIA_ROOT` 和 `MEDIA_URL`。然后，你将添加 `static`
    媒体服务 URL 映射，并添加一个测试文件以确保媒体服务配置正确。
- en: 'Exercise 8.01: Configuring Media Storage and Serving Media Files'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.01：配置媒体存储和服务媒体文件
- en: In this exercise, you will set up a new Django project as an example project
    to use throughout this chapter. Then you'll configure it to be able to serve media
    files. You'll do this by creating a `media` directory and adding the `MEDIA_ROOT`
    and `MEDIA_URL` settings. Then you'll set up the URL mapping for `MEDIA_URL`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将设置一个新的 Django 项目作为本章中使用的示例项目。然后，你将配置它以能够服务媒体文件。你将通过创建一个 `media` 目录并添加
    `MEDIA_ROOT` 和 `MEDIA_URL` 设置来实现这一点。然后，你将为 `MEDIA_URL` 设置 URL 映射。
- en: 'To check that everything is configured and being served correctly, you will
    put a test file inside the `media` directory:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查一切配置正确并且正确服务，你将在 `media` 目录中放置一个测试文件：
- en: 'As with the previous example Django projects you''ve set up, you can reuse
    the existing `bookr` virtual environment. In a terminal, activate the `bookr`
    virtual environment. Then, start a new project named `media_project`, using `django-admin.py`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前你设置的 Django 项目一样，你可以重用现有的 `bookr` 虚拟环境。在终端中激活 `bookr` 虚拟环境。然后，使用 `django-admin.py`
    启动一个名为 `media_project` 的新项目：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Change (or `cd`) into the `media_project` directory that was created, then
    use the `startapp` management command to start an app called `media_example`:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 切换（或 `cd`）到创建的 `media_project` 目录，然后使用 `startapp` 管理命令启动一个名为 `media_example`
    的应用：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Open the `media_project` directory in PyCharm. Set up a run configuration for
    the `runserver` command in the same manner as for the other Django projects you''ve
    opened:![Figure 8.1: Runserver configuration'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm中打开`media_project`目录。以与其他你打开的Django项目相同的方式设置`runserver`命令的运行配置：![图8.1：Runserver配置
- en: '](img/B15509_08_01.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_01.jpg)'
- en: 'Figure 8.1: Runserver configuration'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.1：Runserver配置
- en: '*Figure 8.1* shows the `runserver` configuration of the project in PyCharm.'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图8.1*显示了PyCharm中项目的`runserver`配置。'
- en: 'Create a new directory named `media` inside the `media_project` project directory.
    Then, create a new file in this directory named `test.txt`. The directory structure
    of this will look like *Figure 8.2*:![Figure 8.2: media directory and test.txt
    layout'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`media_project`项目目录内创建一个名为`media`的新目录。然后，在这个目录中创建一个名为`test.txt`的新文件。这个目录结构将看起来像*图8.2*：![图8.2：媒体目录和test.txt布局
- en: '](img/B15509_08_02.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_02.jpg)'
- en: 'Figure 8.2: media directory and test.txt layout'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.2：媒体目录和test.txt布局
- en: '`test.txt` will also open automatically. Enter the text `Hello, world!` into
    it, then you can save and close the file.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test.txt`也会自动打开。将文本`Hello, world!`输入其中，然后你可以保存并关闭文件。'
- en: 'Open `settings.py` inside the `media_project` package directory. At the end
    of the file, add a setting for `MEDIA_ROOT`, using the path to the media directory
    you just created. Make sure to import the `os` module at the top of the file:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`media_project`包目录内打开`settings.py`。在文件末尾添加一个`MEDIA_ROOT`的设置，使用你刚刚创建的媒体目录的路径。确保在文件顶部导入`os`模块：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then use it to join it to `BASE_DIR` using the `os.path.join` function:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后使用`os.path.join`函数将其与`BASE_DIR`连接：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Directly below the line added in *step 5*, add another setting for `MEDIA_URL`.
    This should just be `''/media/''`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤5*中添加的行下面，为`MEDIA_URL`添加另一个设置。这应该只是`'/media/'`：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After this, save `settings.py`. Here''s what it should look like:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，保存`settings.py`。它应该看起来像这样：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open the `media_project` package''s `urls.py` file. After the `urlpatterns`
    definition, add the following code to add the media serving URL if running in
    `DEBUG` mode. First, you will need to import the Django settings and static serving
    view by adding the highlighted import lines above the `urlpatterns` definition:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`media_project`包的`urls.py`文件。在`urlpatterns`定义之后，添加以下代码以在`DEBUG`模式下运行时添加媒体服务URL。首先，您需要通过在`urlpatterns`定义上方添加突出显示的导入行来导入Django设置和静态服务视图：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, add the following code right after your `urlpatterns` definition (refer
    to the code block in the previous step) to conditionally add a mapping from `MEDIA_URL`
    to the `static` view, which will serve from `MEDIA_ROOT`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在你的`urlpatterns`定义之后（参考上一步中的代码块）添加以下代码，以有条件地添加从`MEDIA_URL`到`static`视图的映射，它将从`MEDIA_ROOT`提供服务：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can now save this file. It should look like this: [http://packt.live/3nVUiPn](http://packt.live/3nVUiPn).'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在可以保存这个文件了。它应该看起来像这样：[http://packt.live/3nVUiPn](http://packt.live/3nVUiPn)。
- en: 'Start the Django dev server if it is not already running, then visit `http://127.0.0.1:8000/media/test.txt`.
    If you did everything correctly, then you should see the text `Hello, world!`
    in your browser:![Figure 8.3: Serving a media file'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Django开发服务器尚未运行，请启动它，然后访问`http://127.0.0.1:8000/media/test.txt`。如果你一切都做对了，那么你应该在你的浏览器中看到文本`Hello,
    world!`：![图8.3：服务媒体文件
- en: '](img/B15509_08_03.jpg)'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_03.jpg)'
- en: 'Figure 8.3: Serving a media file'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：服务媒体文件
- en: If your browser looks like *Figure 8.3*, it means that the media files are being
    served from the `MEDIA_ROOT` directory. The `test.txt` file we created was just
    for testing, but we will use it in *Exercise 8.02*, *Template Settings and Using
    MEDIA_URL in Templates*, so don't delete it yet.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的浏览器看起来像*图8.3*，这意味着媒体文件正在从`MEDIA_ROOT`目录提供服务。我们创建的`test.txt`文件只是为了测试，但我们将它在*练习8.02*，*模板设置和使用MEDIA_URL在模板中*中使用，所以现在不要删除它。
- en: In this exercise, we configured Django to serve media files. We served a test
    file just to make sure everything works as expected, and it did. We'll now look
    at how we can automatically generate media URLs in templates.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们配置了Django来服务媒体文件。我们只服务了一个测试文件以确保一切按预期工作，并且确实如此。我们现在将看看我们如何在模板中自动生成媒体URL。
- en: Context Processors and Using MEDIA_URL in Templates
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文处理器和在模板中使用MEDIA_URL
- en: 'To use `MEDIA_URL` in a template, we could pass it in through the rendering
    context dictionary, in our view. For example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模板中使用`MEDIA_URL`，我们可以在视图中通过渲染上下文字典传递它。例如：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will work, but the problem is that `MEDIA_URL` is a common variable that
    we might want to use in many places, and so we'd have to pass it through in practically
    every view.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效，但问题是`MEDIA_URL`是一个我们可能在许多地方想要使用的通用变量，因此我们几乎必须在每个视图中传递它。
- en: Instead, we can use a `render` call.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用`render`调用。
- en: A context processor is a function that accepts one argument, the current request.
    It returns a dictionary of context information that will be merged with the dictionary
    that was passed to the `render` call.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文处理器是一个接受一个参数的函数，即当前请求。它返回一个包含上下文信息的字典，该字典将与传递给`render`调用的字典合并。
- en: 'We can look at the source code of the `media` context processor, which illustrates
    how they work:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看`media`上下文处理器的源代码，它说明了它们是如何工作的：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the media context processor activated, `MEDIA_URL` will be added to our
    context dictionaries. We could change our `render` call, seen previously, to this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 启用媒体上下文处理器后，`MEDIA_URL`将被添加到我们的上下文字典中。我们可以将之前看到的`render`调用更改为以下内容：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The same data would be sent to the template, as the context processor would
    add `MEDIA_URL`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的数据将被发送到模板，因为上下文处理器会添加`MEDIA_URL`。
- en: 'The full module path to the `media` context processor is `django.template.context_processors.media`.
    Some examples of other context processors that Django provides are:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`media`上下文处理器的完整模块路径是`django.template.context_processors.media`。Django提供的其他上下文处理器的示例包括：'
- en: '`django.template.context_processors.debug`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.debug`'
- en: 'This returns the dictionary `{"DEBUG": settings.DEBUG}`.'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这返回字典 `{"DEBUG": settings.DEBUG}`。'
- en: '`django.template.context_processors.request`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.template.context_processors.request`'
- en: 'This returns the dictionary `{"request": request}`, that is, it just adds the
    current HTTP request to the context.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这将返回字典 `{"request": request}`，也就是说，它只是将当前的HTTP请求添加到上下文中。'
- en: To enable a context processor, its module path must be added to the `context_processors`
    option of your `TEMPLATES` setting. For example, to enable the media context processor,
    add `django.template.context_processors.media`. We will cover how to do this in
    detail in *Exercise 8.02*, *Template Settings and Using MEDIA_URL in Templates*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用上下文处理器，必须将其模块路径添加到`TEMPLATES`设置的`context_processors`选项中。例如，要启用媒体上下文处理器，请添加`django.template.context_processors.media`。我们将在*练习8.02*，*模板设置和使用MEDIA_URL在模板中*中详细说明如何做到这一点。
- en: 'Once the `media` context processor is enabled, the `MEDIA_URL` variable can
    be accessed inside a template just like a normal variable:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用`media`上下文处理器，`MEDIA_URL`变量就可以像普通变量一样在模板中访问：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You could use it, for example, to source an image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用它来获取图像：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that, unlike with static files, there is no template tag for loading media
    files (that is, there is no equivalent to the `{% static %}` template tag).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与静态文件不同，没有用于加载媒体文件的模板标签（也就是说，没有`{% static %}`模板标签的等效物）。
- en: 'Custom context processors can also be written. For example, referring back
    to the Bookr application that we have been building, we might want to show a list
    of the five latest reviews in a sidebar that''s on every page. A context processor
    like this would perform this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以编写自定义上下文处理器。例如，回顾我们一直在构建的Bookr应用，我们可能希望在每一页的侧边栏中显示最新的五条评论列表。这样的上下文处理器将执行以下操作：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This would be saved in a file named `context_processors.py` in the Bookr project
    directory, then referred to in the `context_processors` setting by its module
    path, `context_processors.latest_reviews`. Or we could save it inside the `reviews`
    app and refer to it as `reviews.context_processors.latest_reviews`. It is up to
    you to decide whether a context processor should be considered project-wide or
    app-specific. However, bear in mind that regardless of where it is stored, once
    activated, it applies to all `render` calls for all apps.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Bookr项目目录下的名为`context_processors.py`的文件中保存，然后在`context_processors`设置中通过其模块路径`context_processors.latest_reviews`进行引用。或者我们也可以将其保存在`reviews`应用中，并作为`reviews.context_processors.latest_reviews`进行引用。是否将上下文处理器视为项目级或应用级取决于您。然而，请注意，无论其存储位置如何，一旦激活，它将应用于所有应用的`render`调用。
- en: A context processor can return a dictionary with multiple items, or even zero
    items. It would do this if it had conditions to only add items if certain criteria
    were met, for example, showing the latest reviews only if the user is logged in.
    Let's explore this in detail in the next exercise.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文处理器可以返回包含多个项的字典，甚至可以是零项。如果它有条件，只有当满足某些标准时才添加项，例如，只有当用户登录时才显示最新的评论。让我们在下一项练习中详细探讨这一点。
- en: 'Exercise 8.02: Template Settings and Using MEDIA_URL in Templates'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.02：模板设置和使用模板中的MEDIA_URL
- en: 'In this exercise, you will continue with `media_project` and configure Django
    to automatically add the `MEDIA_URL` setting to every template. You do this by
    adding `django.template.context_processors.media` to the `TEMPLATES` `context_processors`
    setting. You''ll then add a template that uses this new variable, and an example
    view to render it. You will make changes to the view and template throughout the
    exercises in this chapter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将继续使用`media_project`并配置Django以自动将`MEDIA_URL`设置添加到每个模板中。你通过将`django.template.context_processors.media`添加到`TEMPLATES`的`context_processors`设置来实现这一点。然后，你将添加一个使用这个新变量的模板和一个示例视图来渲染它。你将在本章的练习中修改视图和模板：
- en: 'In PyCharm, open `settings.py`. First, you will need to add `media_example`
    to the `INSTALLED_APPS` setting, since it wasn''t done when the project was set up:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm中打开`settings.py`。首先，你需要将`media_example`添加到`INSTALLED_APPS`设置中，因为项目设置时没有完成：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: About halfway down the file, you will find the `TEMPLATES` setting, which is
    a dictionary. Inside it is the item `OPTIONS` (another dictionary). Inside `OPTIONS`
    is the `context_processors` setting.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件大约一半的位置，你会找到`TEMPLATES`设置，它是一个字典。在这个字典中是`OPTIONS`项（另一个字典）。在`OPTIONS`中是`context_processors`设置。
- en: 'To the end of this list, add this:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下内容添加到列表末尾：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The full list should look like this:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的列表应该看起来像这样：
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The complete file should look like this: [http://packt.live/3nVOpSx](http://packt.live/3nVOpSx).'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的文件应该看起来像这样：[http://packt.live/3nVOpSx](http://packt.live/3nVOpSx)。
- en: 'Open the `media_example` app''s `views.py` and create a new view called `media_example`.
    For now, it can just render a template named `media-example.html` (you will create
    this in *step 5*). The entire code of the view function is like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`media_example`应用的`views.py`并创建一个名为`media_example`的新视图。目前，它只需渲染一个名为`media-example.html`的模板（你将在*步骤5*中创建它）。视图函数的整个代码如下：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Save `views.py`. It should look like this: [http://packt.live/3pvEGCB](http://packt.live/3pvEGCB).'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存`views.py`。它应该看起来像这样：[http://packt.live/3pvEGCB](http://packt.live/3pvEGCB)。
- en: You need a URL mapping to the `media_example` view. Open the `media_project`
    package's `urls.py` file.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一个指向`media_example`视图的URL映射。打开`media_project`包的`urls.py`文件。
- en: 'First, `import` `media_example.views` with the other imports in the file:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，使用文件中的其他导入导入`media_example.views`：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then add a `path` into `urlpatterns` to map `media-example/` to the `media_example`
    view:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在`urlpatterns`中添加一个`path`，将`media-example/`映射到`media_example`视图：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Your full `urlpatterns` should look like this code block:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的完整`urlpatterns`应该像以下代码块所示：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can save and close the file.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以保存并关闭文件。
- en: 'Create a `templates` directory inside the `media_example` app directory. Then,
    create a new HTML file inside the `media_project` project''s `templates` directory.
    Select `HTML 5 file` and name the file `media-example.html`:![Figure 8.4: Create
    media-example.html'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`media_example`应用目录内创建一个`templates`目录。然后，在`media_project`项目的`templates`目录内创建一个新的HTML文件。选择`HTML
    5 file`并将文件命名为`media-example.html`：![图8.4：创建media-example.html
- en: '](img/B15509_08_04.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_04.jpg)'
- en: 'Figure 8.4: Create media-example.html'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.4：创建media-example.html
- en: 'The `media-example.html` file should open automatically. You are just going
    to add a link inside the file to the `test.txt` file you created in *Exercise
    8.01*, *Configuring Media Storage and Serving*. Inside the `<body>` element, add
    the highlighted code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`media-example.html`文件应该会自动打开。你只需要在文件内添加一个指向你在*练习8.01*，*配置媒体存储和提供媒体文件*中创建的`test.txt`文件的链接。在`<body>`元素中添加高亮代码：'
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Start the Django dev server if it is not already running, then visit `http://127.0.0.1:8000/media-example/`.
    You should see a simple page, like in *Figure 8.5*:![Figure 8.5: Basic media link
    page'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Django开发服务器尚未运行，请启动它，然后访问`http://127.0.0.1:8000/media-example/`。你应该会看到一个简单的页面，就像*图8.5*所示：![图8.5：基本的媒体链接页面
- en: '](img/B15509_08_05.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_05.jpg)'
- en: 'Figure 8.5: Basic media link page'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：基本的媒体链接页面
- en: If you click the link, you will be taken to the `test.txt` display and see the
    `Hello, world!` text you created in *Exercise 8.01*, *Configuring Media Storage
    and Serving Media Files* (*Figure 8.3*). This means you have configured the Django
    `context_processors` settings correctly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击链接，你将被带到`test.txt`显示页面，并看到你在*练习8.01*，*配置媒体存储和提供媒体文件*中创建的`Hello, world!`文本（*图8.3*）。这意味着你已经正确配置了Django的`context_processors`设置。
- en: We have finished with `test.txt`, so you can delete the file now. We will use
    the `media_example` view and template in the other exercises, so leave them around.
    In the next section, we will talk about how to upload files using a web browser,
    and how Django accesses them in a view.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 `test.txt`，所以你现在可以删除该文件了。我们将在其他练习中使用 `media_example` 视图和模板，所以请保留它们。在下一节中，我们将讨论如何使用网络浏览器上传文件，以及
    Django 如何在视图中访问它们。
- en: File Uploads Using HTML Forms
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTML 表单进行文件上传
- en: In *Chapter 6*, *Forms*, we learned about HTML forms. We discussed how to use
    the `method` attribute of `<form>` for `GET` or `POST` requests. Though we have
    only submitted text data using a form so far, it is also possible to submit one
    or more files using a form.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 6 章*，*表单* 中，我们学习了关于 HTML 表单的内容。我们讨论了如何使用 `<form>` 的 `method` 属性进行 `GET`
    或 `POST` 请求。尽管我们迄今为止只使用表单提交了文本数据，但也可以使用表单提交一个或多个文件。
- en: 'When submitting files, we must ensure that there are at least two attributes
    on the form: `method` and `enctype`. You may still also need other attributes,
    such as `action`. A form that supports file uploads might look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交文件时，我们必须确保表单上至少有两个属性：`method` 和 `enctype`。你可能还需要其他属性，例如 `action`。支持文件上传的表单可能看起来像这样：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: File uploads are only available for `POST` requests. They are not possible with
    `GET` requests as it would be impossible to send all the data for a file through
    a URL. The `enctype` attribute must be set to let the browser know it should send
    the form data as multiple parts, one part for the text data of the form, and separate
    parts for each of the files that have been attached to the form. This encoding
    is seamless to the user; they do not know how the browser is encoding the form,
    nor do they need to do anything different.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文件上传仅适用于 `POST` 请求。使用 `GET` 请求是不可能的，因为无法通过 URL 发送文件的全部数据。必须设置 `enctype` 属性，以便浏览器知道它应该将表单数据作为多个部分发送，一部分用于表单的文本数据，另一部分用于附加到表单的每个文件。这种编码对用户来说是无缝的；他们不知道浏览器是如何编码表单的，也不需要做任何不同的事情。
- en: 'To attach files to a form, you need to create an input of type `file`. You
    can manually write the HTML code, like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件附加到表单，你需要创建一个类型为 `file` 的输入。你可以手动编写 HTML 代码，如下所示：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the input is rendered in the browser it looks like this when empty:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入在浏览器中渲染时，它看起来如下（为空时）：
- en: '![Figure 8.6: Empty file input'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6：空文件输入'
- en: '](img/B15509_08_06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_08_06.jpg]'
- en: 'Figure 8.6: Empty file input'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6：空文件输入'
- en: The title of the button might be different depending on your browser.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的标题可能因你的浏览器而异。
- en: 'Clicking the `Browse…` button will display a *file open* dialog box:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `浏览…` 按钮将显示一个 *文件打开* 对话框：
- en: '![Figure 8.7: File browser on macOS'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7：macOS 上的文件浏览器'
- en: '](img/B15509_08_07.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_08_07.jpg]'
- en: 'Figure 8.7: File browser on macOS'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7：macOS 上的文件浏览器'
- en: 'And after selecting a file, the name of the file is shown in the field:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 选择文件后，文件名将显示在字段中：
- en: '![Figure 8.8: File input with cover.jpg selected'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.8：已选择 cover.jpg 的文件输入'
- en: '](img/B15509_08_08.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_08_08.jpg]'
- en: 'Figure 8.8: File input with cover.jpg selected'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.8：已选择 cover.jpg 的文件输入'
- en: '*Figure 8.8* shows a file input with a file named `cover.jpg` having been selected.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.8* 显示了一个已选择名为 `cover.jpg` 的文件输入。'
- en: Working with Uploaded Files in a View
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视图中处理上传的文件
- en: In addition to text data, if a form also contains file uploads, Django will
    populate the `request.FILES` attribute with these files. `request.FILES` is a
    dictionary-like object that is keyed on the `name` attribute given to the `file`
    input.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文本数据外，如果表单还包含文件上传，Django 将使用这些文件填充 `request.FILES` 属性。`request.FILES` 是一个类似于字典的对象，它以
    `file` 输入的 `name` 属性为键。
- en: In the form example in the previous section, the file input had the name `file-upload-name`.
    So, the file would be accessible in the view using `request.FILES["file-upload-name"]`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中的表单示例中，文件输入的名称是 `file-upload-name`。因此，文件可以通过 `request.FILES["file-upload-name"]`
    在视图中访问。
- en: 'The objects that `request.FILES` contains are file-like objects (specifically,
    a `django.core.files.uploadedfile.UploadedFile` instance), so to use them, you
    must read their data. For example, to get the content of an uploaded file in your
    view, you can write:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`request.FILES` 包含的对象是文件类对象（具体来说，是一个 `django.core.files.uploadedfile.UploadedFile`
    实例），因此要使用它们，你必须读取它们的数据。例如，要在你的视图中获取上传文件的文件内容，你可以编写：'
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A more common action is to write the file contents to disk. When files are uploaded,
    they are stored in a temporary location (in memory if they are under 2.5 MB, otherwise
    in a temporary file on disk). To store the file data in a known location, the
    contents must be read and then written to disk at the desired location. An `UploadedFile`
    instance has a `chunks` method that will read the file data one chunk at a time
    to prevent too much memory from being used by reading the entirety of the file
    at once.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的操作是将文件内容写入磁盘。当文件上传时，它们被存储在临时位置（如果文件大小小于2.5 MB，则在内存中，否则在磁盘上的临时文件中）。要将文件数据存储在已知位置，必须读取内容并将其写入磁盘的期望位置。`UploadedFile`实例有一个`chunks`方法，它将一次读取文件数据的一个块，以防止一次性读取整个文件而占用太多内存。
- en: 'So, instead of simply using the `read` and `write` functions, use the `chunks`
    method to only read small chunks of the file into memory at a time:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，而不是简单地使用`read`和`write`函数，使用`chunks`方法一次只读取文件的小块到内存中：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that in some of the upcoming examples, we will refer to this code as the
    `save_file_upload` function. Assume the function is defined like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在即将到来的某些示例中，我们将把这个代码称为`save_file_upload`函数。假设函数定义如下：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The previous example code could then be refactored to call the function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例代码可以重构为调用以下函数：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Each `UploadedFile` object (the `uploaded_file` variable in the previous example
    code snippets) also contains extra metadata about the uploaded file, such as the
    file''s name, size, and content type. The attributes you will find most useful
    are:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`UploadedFile`对象（前一个示例代码片段中的`uploaded_file`变量）还包含有关上传文件的额外元数据，例如文件名、大小和内容类型。你将发现最有用的属性是：
- en: '`size`: As the name suggests, this is the size of the uploaded file in bytes.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：正如其名所示，这是上传文件的字节数。'
- en: '`name`: This refers to the name of the uploaded file, for example, `image.jpg`,
    `file.txt`, `document.pdf`, and so on. This value is sent by the browser.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这指的是上传文件的名称，例如，`image.jpg`、`file.txt`、`document.pdf`等等。这个值是由浏览器发送的。'
- en: '`content_type`: The content type (MIME type) of the uploaded file. For example,
    `image/jpeg`, `text/plain`, `application/pdf`, and so on. Like `name`, this value
    is sent by the browser.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content_type`：这是上传文件的内容类型（MIME类型）。例如，`image/jpeg`、`text/plain`、`application/pdf`等等。像`name`一样，这个值是由浏览器发送的。'
- en: '`charset`: This refers to the charset or text encoding of the uploaded file,
    for text files. This will be something like `utf8` or `ascii`. Once again, this
    value is also determined and sent by the browser.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charset`：这指的是上传文件的字符集或文本编码，对于文本文件。这将是类似`utf8`或`ascii`的东西。同样，这个值也是由浏览器确定并发送的。'
- en: 'Here is a quick example of accessing these attributes (such as inside a view):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速示例，展示如何访问这些属性（例如在视图中）：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Security and Trust of Browsers' Sent Values
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器发送值的 安全性和信任
- en: As we just described, the values of an `UploadedFile` for `name`, `content_type`,
    and `charset` are determined by the browser. This is important to consider because
    a malicious user could send fake values in place of real ones to disguise the
    actual files being uploaded. Django does not automatically try to determine the
    content type or charset of the uploaded file, and so it relies on the client to
    be accurate when it sends this information.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才描述的，`UploadedFile`的`name`、`content_type`和`charset`值是由浏览器确定的。这一点很重要，因为恶意用户可能会发送虚假值来代替真实值，以伪装实际上传的文件。Django不会自动尝试确定上传文件的类型或字符集，因此它依赖于客户端在发送此信息时准确无误。
- en: 'If we manually handle the saving of tile uploads without suitable checks, then
    a scenario like this could happen:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们手动处理文件上传的保存而没有适当的检查，那么可能会发生如下场景：
- en: A user of the site uploads a malicious executable `malware.exe` but sends the
    content type `image/jpeg`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站的用户上传了一个恶意可执行文件`malware.exe`，但发送的内容类型为`image/jpeg`。
- en: Our code checks the content type and considers it to be safe, and so saves `malware.exe`
    to the `MEDIA_ROOT` file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码检查内容类型，并认为它是安全的，因此将`malware.exe`保存到`MEDIA_ROOT`文件。
- en: Another user of the site downloads what they think is a book cover image but
    is the `malware.exe` executable. They open the file, and their computer is infected
    with malware.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站的另一用户下载了他们认为是一本封面图片的文件，但实际上是`malware.exe`可执行文件。他们打开了文件，然后他们的电脑被恶意软件感染。
- en: This scenario has been simplified – the malicious file would probably have a
    name that was not so obvious (maybe something like `cover.jpg.exe`), but the general
    process has been illustrated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景已经被简化了——恶意文件可能有一个不那么明显的名字（比如 `cover.jpg.exe`），但总体过程已经被说明了。
- en: 'How you choose to handle the security of your uploads will depend on the specific
    use case, but for most cases, these tips will help:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何选择处理上传的安全性将取决于特定的用例，但对于大多数情况，这些提示将有所帮助：
- en: When you save the file to disk, generate a name instead of using the one provided
    by the uploader. You should replace the file extension with what you expect. For
    example, if a file is named `cover.exe` but the content type is `image/jpeg`,
    save the file as `cover.jpg`. You could also generate a completely random filename
    for extra security.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将文件保存到磁盘时，生成一个名称而不是使用上传者提供的名称。你应该将文件扩展名替换为你期望的。例如，如果一个文件被命名为 `cover.exe` 但内容类型是
    `image/jpeg`，则将文件保存为 `cover.jpg`。你也可以为额外的安全性生成一个完全随机的文件名。
- en: 'Check that the file name extension matches the content type. This method is
    not foolproof as there are so many mime types that if you are handling uncommon
    files you might not get a match. The built-in `mimetypes` Python module can help
    you here. Its `guess_type` function takes a filename and returns a tuple of `mimetype`
    (content type) and `encoding`. Here is a short snippet showing its use, in a Python
    console:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查文件扩展名是否与内容类型匹配。这种方法并不是万无一失的，因为存在如此多的 MIME 类型，如果你处理不常见的文件，你可能不会得到匹配。内置的 `mimetypes`
    Python 模块可以在这里帮助你。它的 `guess_type` 函数接受一个文件名，并返回一个包含 `mimetype`（内容类型）和 `encoding`
    的元组。以下是一个展示其使用的简短片段，在 Python 控制台中：
- en: '[PRE30]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Either element of the tuple might be `None` if the type or encoding cannot
    be guessed. Once it is imported into your file by doing `import mimetypes`, you
    would use it like this in your view function:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果类型或编码无法猜测，元组的任一元素都可能为 `None`。一旦通过 `import mimetypes` 将其导入到你的文件中，你可以在你的视图函数中使用它：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method will work for common file types such as images, but as mentioned,
    many uncommon types may return `None` for `mimetype`.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法适用于常见的文件类型，如图像，但如前所述，许多不常见的类型可能会返回 `mimetype` 为 `None`。
- en: If you are expecting image uploads, use the `Pillow` library to try to open
    the uploaded file as an image. If it is not a valid image, then `Pillow` will
    be unable to open it. This is what Django does when using its `ImageField` to
    upload images. We will show how to use this technique to open and manipulate an
    image in *Exercise 8.05*, *Image Uploads using Django Forms*.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你预计会有图像上传，请使用 `Pillow` 库尝试以图像的形式打开上传的文件。如果它不是一个有效的图像，那么 `Pillow` 将无法打开它。这就是
    Django 在使用其 `ImageField` 上传图像时所做的。我们将在 *练习 8.05*，*使用 Django 表单的图像上传* 中展示如何使用这种技术打开和操作图像。
- en: 'You can also consider the `python-magic` Python package, which examines the
    actual content of files to try to determine their type. It is installable using
    `pip`, and its GitHub project is [https://github.com/ahupp/python-magic](https://github.com/ahupp/python-magic).
    Once installed, and imported into your file with `import magic`, you can use it
    like this in your view function:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以考虑使用 `python-magic` Python 包，该包检查文件的实际内容以尝试确定其类型。它可以通过 `pip` 安装，其 GitHub
    项目是 [https://github.com/ahupp/python-magic](https://github.com/ahupp/python-magic)。一旦安装，并通过
    `import magic` 导入到你的文件中，你可以在你的视图函数中使用它：
- en: '[PRE32]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You could then verify that `mimetype` was in a list of allowed types.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以验证 `mimetype` 是否在允许的类型列表中。
- en: This is not a definitive list of all the ways of protecting against malicious
    file uploads. The best approach will depend on what type of application you are
    building. You might build a site for hosting arbitrary files, in which case you
    would not need any kind of content checking at all.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个保护恶意文件上传的所有方法的完整列表。最佳方法将取决于你正在构建的应用程序类型。你可能正在构建一个用于托管任意文件的网站，在这种情况下，你根本不需要进行任何内容检查。
- en: Let us now see how we can build an HTML form and view that will allow files
    to be uploaded. We will then store them inside the `media` directory and retrieve
    the downloaded files in our browser.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何构建一个 HTML 表单和视图，允许上传文件。然后我们将它们存储在 `media` 目录中，并在我们的浏览器中检索下载的文件。
- en: 'Exercise 8.03: File Upload and Download'
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.03：文件上传和下载
- en: 'In this exercise, you will add a form with a file field to the `media-example.html`
    template. This will allow you to upload a file to the `media_example` view using
    your browser. You will also update the `media_example` view to save the file to
    the `MEDIA_ROOT` directory so that it''s available for download. You will then
    test that this all works by downloading the file again:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将向 `media-example.html` 模板添加一个带有文件字段的表单。这将允许您使用浏览器将文件上传到 `media_example`
    视图。您还将更新 `media_example` 视图，以便将文件保存到 `MEDIA_ROOT` 目录，以便可供下载。然后，您将通过再次下载文件来测试这一切是否正常工作：
- en: 'In PyCharm, open the `media-example.html` template located inside the `templates`
    folder. Inside the `<body>` element, remove the `<a>` link that was added in *step
    6* of *Exercise 8.02*, *Template Settings and Using MEDIA_URL in Templates*. Replace
    it with a `<form>` element (highlighted here). Make sure the opening tag has `method="post"`
    and `enctype="multipart/form-data"`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，打开位于 `templates` 文件夹内的 `media-example.html` 模板。在 `<body>` 元素内部，移除在
    *练习 8.02* 的 *步骤 6* 中添加的 `<a>` 链接，用 `<form>` 元素（如图所示）替换它。确保打开标签具有 `method="post"`
    和 `enctype="multipart/form-data"`：
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Insert the `{% csrf_token %}` template tag inside the `<form>` body.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<form>` 主体内部插入 `{% csrf_token %}` 模板标签。
- en: 'After `{% csrf_token %}`, add an `<input>` element, with `type="file"` and
    `name="file_upload"`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `{% csrf_token %}` 之后，添加一个 `type="file"` 和 `name="file_upload"` 的 `<input>`
    元素：
- en: '[PRE34]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, before the closing `</form>` tag, add a `<button>` element with `type="submit"`
    and the text content `Submit`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在关闭 `</form>` 标签之前，添加一个 `type="submit"` 并具有文本内容 `提交` 的 `<button>` 元素：
- en: '[PRE35]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Your HTML body should now look like this:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的 HTML 主体现在应该看起来像这样：
- en: '[PRE36]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, save and close the file. It should look like this: [http://packt.live/37XJPh3](http://packt.live/37XJPh3).'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，保存并关闭文件。它应该看起来像这样：[http://packt.live/37XJPh3](http://packt.live/37XJPh3)。
- en: 'Open the `media_example` app''s `views.py`. Inside the `media_example` view,
    add code to save the uploaded file to the `MEDIA_ROOT` directory. For this, you
    need access to `MEDIA_ROOT` from settings, so import the Django settings at the
    top of the file:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `media_example` 应用程序的 `views.py` 文件。在 `media_example` 视图中，添加代码以将上传的文件保存到
    `MEDIA_ROOT` 目录。为此，您需要从设置中访问 `MEDIA_ROOT`，因此请在文件顶部导入 Django 设置：
- en: '[PRE37]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will also need to use the `os` module to build the save path, so import
    that as well (also at the top of the file):'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还需要使用 `os` 模块来构建保存路径，因此也要导入它（同样在文件顶部）：
- en: '[PRE38]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The uploaded file should only be saved if the request method is `POST`. Inside
    the `media_example` view, add an `if` statement to validate that `request.method`
    is `POST`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当请求方法是 `POST` 时，上传的文件才应该被保存。在 `media_example` 视图中，添加一个 `if` 语句来验证 `request.method`
    是否为 `POST`：
- en: '[PRE39]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside the `if` statement added in the previous step, generate the output path
    by joining the uploaded filename to `MEDIA_ROOT`. Then, open this path in `wb`
    mode and iterate over the uploaded file using the `chunks` method. Finally, write
    each chunk to the saved file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前步骤中添加的 `if` 语句内部，通过将上传的文件名与 `MEDIA_ROOT` 连接来生成输出路径。然后，以 `wb` 模式打开此路径，并使用
    `chunks` 方法遍历上传的文件。最后，将每个块写入保存的文件：
- en: '[PRE40]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Start the Django dev server if it is not already running, then navigate to
    `http://127.0.0.1:8000/media-example/`. You should see the file upload field and
    `Submit` button, as can be seen here:![Figure 8.9: File upload form'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未运行，请启动 Django 开发服务器，然后导航到 `http://127.0.0.1:8000/media-example/`。您应该看到文件上传字段和
    `提交` 按钮，如图所示：![图 8.9：文件上传表单
- en: '](img/B15509_08_09.jpg)'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_08_09.jpg](img/B15509_08_09.jpg)'
- en: 'Figure 8.9: File upload form'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.9：文件上传表单'
- en: Click `Browse…` (or the equivalent in your browser) and select a file to upload.
    The name of the file will appear in the file input. Then, click `Submit`. The
    page will reload, and the form will be empty again. This is normal – in the background,
    the file should have been saved.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击 `浏览…`（或在您的浏览器中对应的选项）并选择一个文件进行上传。文件名将出现在文件输入框中。然后，点击 `提交`。页面将重新加载，表单将再次为空。这是正常的——在后台，文件应该已经被保存。
- en: 'Try to download the file you uploaded using `MEDIA_URL`. In this example, a
    file named `cover.jpg` was uploaded. It will be downloadable at `http://127.0.0.1:8000/media/cover.jpg`.
    Your URL will depend on the name of the file you uploaded.![Figure 8.10: Uploaded
    file visible inside MEDIA_URL'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用 `MEDIA_URL` 下载您上传的文件。在这个例子中，上传了一个名为 `cover.jpg` 的文件。它将在 `http://127.0.0.1:8000/media/cover.jpg`
    可以下载。您的 URL 将取决于您上传的文件名。![图 8.10：可见于 MEDIA_URL 的上传文件
- en: '](img/B15509_08_10.jpg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15509_08_10.jpg](img/B15509_08_10.jpg)'
- en: 'Figure 8.10: Uploaded file visible inside MEDIA_URL'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.10：可见于 MEDIA_URL 的上传文件'
- en: If you uploaded an image file, HTML file, or another type of file your browser
    can display, you will be able to view it inside the browser. Otherwise, your browser
    will just download it to disk again. In both cases, it means the upload was successful.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上传了一个图像文件、HTML 文件或其他浏览器可以显示的文件类型，你将能够在浏览器中查看它。否则，你的浏览器将再次将其下载到磁盘上。在两种情况下，这意味着上传是成功的。
- en: 'You can also confirm the upload was successful by looking inside the `media`
    directory in the `media_project` project directory:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过查看 `media_project` 项目目录中的 `media` 目录来确认上传是否成功：
- en: '![Figure 8.11: cover.jpg inside the media directory'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11：媒体目录中的 cover.jpg'
- en: '](img/B15509_08_11.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_08_11.jpg)'
- en: 'Figure 8.11: cover.jpg inside the media directory'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11：媒体目录中的 cover.jpg
- en: '*Figure 8.11* shows `cover.jpg` inside the `media` directory in PyCharm.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.11* 展示了 PyCharm 中 `media` 目录内的 `cover.jpg`。'
- en: In this exercise, you added an HTML form with `enctype` set to `multipart/form-data`
    so that it would allow file uploads. It contained a `file` input to select a file
    to upload. You then added saving functionality to the `media_example` view to
    save the uploaded file to disk.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你添加了一个 `enctype` 设置为 `multipart/form-data` 的 HTML 表单，以便允许文件上传。它包含一个 `file`
    输入来选择要上传的文件。然后你添加了保存功能到 `media_example` 视图中，以便将上传的文件保存到磁盘上。
- en: In the next section, we will look at how to simplify form generation and add
    validation using Django forms.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 Django 表单简化表单生成并添加验证。
- en: File Uploads with Django Forms
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Django 表单进行文件上传
- en: In *Chapter 6*, *Forms*, we saw how Django makes it easy to define forms and
    automatically render them to HTML. In the previous example, we defined our form
    manually and wrote the HTML. We can replace this with a Django form, and implement
    the file input with a `FileField` constructor.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 6 章*，*表单* 中，我们看到了 Django 如何使定义表单并自动将其渲染为 HTML 变得容易。在上一个示例中，我们手动定义了表单并编写了
    HTML。我们可以用 Django 表单来替换它，并使用 `FileField` 构造函数实现文件输入。
- en: 'Here is how a `FileField` is defined on a form:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在表单上定义 `FileField`：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `FileField` constructor can take the following keyword arguments:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileField` 构造函数可以接受以下关键字参数：'
- en: '`required`: This should be `True` for required fields and `False` if the field
    is optional.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`：对于必填字段，应为 `True`；如果字段是可选的，则为 `False`。'
- en: '`max_length`: This refers to the maximum length of the filename of the file
    being uploaded.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_length`：这指的是上传文件文件名的最大长度。'
- en: '`allow_empty_file`: A field with this argument is valid even if the uploaded
    file is empty (has a size of `0`).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allow_empty_file`：具有此参数的字段即使上传的文件为空（大小为 `0`）也是有效的。'
- en: Apart from these three keyword arguments, the constructor can also accept the
    standard `Field` arguments, such as `widget`. The default widget class for a `FileField`
    is `ClearableFileInput`. This is a file input that can display a checkbox that
    can be checked to send a null value and clear the saved file on a model field.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个关键字参数之外，构造函数还可以接受标准的 `Field` 参数，例如 `widget`。`FileField` 的默认小部件类是 `ClearableFileInput`。这是一个可以显示复选框的文件输入，可以选中以发送空值并清除模型字段上保存的文件。
- en: Using a form with a `FileField` in a view is similar to other forms, but when
    the form has been submitted (that is, `request.METHOD` is `POST`), then `request.FILES`
    should be passed into the form constructor as well. This is because Django needs
    to access `request.FILES` to find information about uploaded files when validating
    the form.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中使用带有 `FileField` 的表单与其他表单类似，但当表单已提交（即 `request.METHOD` 是 `POST`）时，则应将 `request.FILES`
    也传递给表单构造函数。这是因为 Django 需要访问 `request.FILES` 来在验证表单时查找有关上传文件的信息。
- en: 'The basic flow in a `view` function is therefore like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `view` 函数中的基本流程如下：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When working with uploaded files and forms, you can interact with the uploaded
    files by accessing them through `request.FILES`, or through `form.cleaned_data`:
    the values will return to the same object. In our above example, we could process
    the uploaded file like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理上传文件和表单时，你可以通过通过 `request.FILES` 或通过 `form.cleaned_data` 访问它们来与上传文件进行交互：返回的值将指向同一个对象。在我们的上述示例中，我们可以这样处理上传的文件：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or, since they contain the same object, you can use `form.cleaned_data`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，由于它们包含相同的对象，你可以使用 `form.cleaned_data`：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The data that is saved will be the same.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 保存的数据将保持不变。
- en: Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In *Chapter 6*, *Forms*, you experimented with forms and submitting them with
    invalid values. When the page refreshed to show the form errors, the data that
    you had previously entered was populated when the page reloaded. This does not
    occur with file fields; instead, the user will have to navigate and select the
    file again if the form is invalid.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 6 章*，*表单* 中，你尝试了表单和提交无效值。当页面刷新以显示表单错误时，你之前输入的数据会在页面重新加载时被填充。对于文件字段来说，这种情况不会发生；相反，如果表单无效，用户将不得不再次导航并选择文件。
- en: In the next exercise, we will put what we have seen with `FileFields` into practice
    by building an example form, then modifying our view to save the file only if
    the form is valid.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将通过构建一个示例表单，然后修改我们的视图，仅在表单有效时保存文件，来将我们之前看到的 `FileFields` 应用到实践中。
- en: 'Exercise 8.04: File Uploads with a Django Form'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.04：使用 Django 表单上传文件
- en: In the previous exercise, you created a form in HTML and used it to upload a
    file to a Django view. If you tried submitting the form without selecting a file,
    you would get a Django exception screen. You did not do any validation on the
    form, so this method is quite fragile.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，你创建了一个 HTML 表单，并使用它将文件上传到 Django 视图。如果你尝试提交没有选择文件的表单，你会得到一个 Django 异常屏幕。你没有对表单进行任何验证，所以这种方法相当脆弱。
- en: 'In this exercise, you will create a Django form with a `FileFIeld`, which will
    allow you to use form validation functions to make the view more robust as well
    to reduce the amount of code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个带有 `FileField` 的 Django 表单，这将允许你使用表单验证函数使视图更加健壮，同时减少代码量：
- en: 'In PyCharm, inside the `media_example` app, create a new file named `forms.py`.
    It will open automatically. At the start of the file, import the Django `forms` library:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，在 `media_example` 应用程序内部，创建一个名为 `forms.py` 的新文件。它将自动打开。在文件开头，导入
    Django 的 `forms` 库：
- en: '[PRE45]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, create a `forms.Form` subclass, and name it `UploadForm`. Add one field
    to it, a `FileField` named `file_upload`. Your class should have this code:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，创建一个 `forms.Form` 子类，并将其命名为 `UploadForm`。向其中添加一个字段，一个名为 `file_upload` 的 `FileField`。你的类应该有如下代码：
- en: '[PRE46]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can save and close this file. The complete file should look like this:
    [http://packt.live/34S5hBV](http://packt.live/34S5hBV).'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以保存并关闭此文件。完整的文件应如下所示：[http://packt.live/34S5hBV](http://packt.live/34S5hBV)。
- en: 'Open the `form_example` app''s `views.py` file. At the start of the file, right
    below the existing `import` statements, you will need to import your new class,
    like this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `form_example` 应用的 `views.py` 文件。在文件的开头，现有 `import` 语句的下方，你需要导入你的新类，如下所示：
- en: '[PRE47]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you are in the `POST` branch of the view, `UploadForm` needs to be instantiated
    with both `request.POST` and `request.FILES`. If you do not pass in `request.FILES`,
    then the `form` instance will not be able to access the uploaded files. Under
    the `if request.method == "POST"` check, instantiate the `UploadForm` with these
    two arguments:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你处于视图的 `POST` 分支，`UploadForm` 需要使用 `request.POST` 和 `request.FILES` 两个参数进行实例化。如果你没有传入
    `request.FILES`，那么 `form` 实例将无法访问上传的文件。在 `if request.method == "POST"` 检查下，使用这两个参数实例化
    `UploadForm`：
- en: '[PRE48]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The existing lines that define the `save_path` and store the file contents
    can be retained, but they should be indented by one block and put inside a form
    validity check, so they are only executed if the form is valid. Add the `if form.is_valid():`
    line and then indent the other lines so the code looks like this:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `save_path` 和存储文件内容的现有行可以保留，但它们应该缩进一个块，并放在表单有效性检查内部，这样它们只有在表单有效时才会执行。添加 `if
    form.is_valid():` 行，然后缩进其他行，使代码看起来像这样：
- en: '[PRE49]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since you are using a form now, you can access the file upload through the
    form. Replace usages of `request.FILES["file_upload"]` with `form.cleaned_data["file_upload"]`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你现在正在使用表单，你可以通过表单访问文件上传。将 `request.FILES["file_upload"]` 的使用替换为 `form.cleaned_data["file_upload"]`：
- en: '[PRE50]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, add an `else` branch to handle non-`POST` requests, which simply instantiates
    a form without any arguments:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个 `else` 分支来处理非 `POST` 请求，它只是实例化一个不带任何参数的表单：
- en: '[PRE51]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add a context dictionary argument to the `render` call and set the `form` variable
    in the `form` key:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上下文字典参数添加到 `render` 调用中，并将 `form` 变量设置在 `form` 键中：
- en: '[PRE52]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can now save and close this file. It should look like this: [http://packt.live/3psXxyc](http://packt.live/3psXxyc).'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在可以保存并关闭此文件。它应该如下所示：[http://packt.live/3psXxyc](http://packt.live/3psXxyc)。
- en: 'Finally, open the `media-example.html` template and remove your manually defined
    file `<input>`. Replace it with `form`, rendered using the `as_p` method (highlighted):'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `media-example.html` 模板，删除你手动定义的文件 `<input>`。用使用 `as_p` 方法渲染的 `form` 替换它（高亮显示）：
- en: '[PRE53]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should not change any other parts of the file. You can save and close this
    file. It should look like this: [http://packt.live/3qHHSMi](http://packt.live/3qHHSMi).'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不应该更改文件的任何其他部分。你可以保存并关闭此文件。它应该看起来像这样：[http://packt.live/3qHHSMi](http://packt.live/3qHHSMi)。
- en: 'Start the Django dev server if it is not already running, then navigate to
    `http://127.0.0.1:8000/media-example/`. You should see the `File upload` field
    and the `Submit` button, as follows:![Figure 8.12: File upload Django form rendered
    in the browser'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Django开发服务器尚未运行，请启动它，然后导航到 `http://127.0.0.1:8000/media-example/`。你应该会看到 `文件上传`
    字段和 `提交` 按钮，如下所示：![图8.12：在浏览器中渲染的文件上传Django表单
- en: '](img/B15509_08_12.jpg)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_08_12.jpg)'
- en: 'Figure 8.12: File upload Django form rendered in the browser'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.12：在浏览器中渲染的文件上传Django表单
- en: 'Since we are using a Django form, we get its built-in validation automatically.
    If you try to submit the form without selecting a file, your browser should prevent
    you and show an error, as can be seen here:![Figure 8.13: Form submission prevented
    by the browser'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用的是Django表单，我们自动获得其内置验证。如果你尝试不选择文件就提交表单，你的浏览器应该阻止你并显示错误，如下所示：![图8.13：浏览器阻止表单提交
- en: '](img/B15509_08_13.jpg)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_08_13.jpg)'
- en: 'Figure 8.13: Form submission prevented by the browser'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.13：浏览器阻止表单提交
- en: 'Finally, repeat the upload test that you performed in *Exercise 8.03*, *File
    Upload and Download*, by selecting a file and submitting the form. You should
    then be able to retrieve the file using `MEDIA_URL`. In this case, a file named
    `cover.jpg` is being uploaded again (see the following figure):![Figure 8.14:
    Uploading a file named cover.jpg'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，重复你在 *练习8.03*，*文件上传和下载* 中进行的上传测试，通过选择一个文件并提交表单。然后你应该能够使用 `MEDIA_URL` 检索文件。在这种情况下，正在再次上传一个名为
    `cover.jpg` 的文件（见下图）：![图8.14：上传名为cover.jpg的文件
- en: '](img/B15509_08_14.jpg)'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_08_14.jpg)'
- en: 'Figure 8.14: Uploading a file named cover.jpg'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：上传名为cover.jpg的文件
- en: 'You can then retrieve the file at `http://127.0.0.1:8000/media/cover.jpg`,
    and you can see it in the browser as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随后在 `http://127.0.0.1:8000/media/cover.jpg` 上检索文件，你可以在浏览器中看到如下所示：
- en: '![Figure 8.15: The file uploaded using a Django form is also visible in the
    browser'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15：使用Django表单上传的文件在浏览器中也是可见的'
- en: '](img/B15509_08_15.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15509_08_15.jpg)'
- en: 'Figure 8.15: The file uploaded using a Django form is also visible in the browser'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：使用Django表单上传的文件在浏览器中也是可见的
- en: In this exercise, we replaced a manually built form with a Django form containing
    a `FileField`. We instantiated the form in the view by passing in both `request.POST`
    and `request.FILES`. We then used the standard `is_valid` method to check the
    validity of the form, and only saved the file upload if the form was valid. We
    tested the file uploading and saw we were able to retrieve uploaded files using
    `MEDIA_URL`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们用一个包含 `FileField` 的Django表单替换了手动构建的表单。我们在视图中通过传递 `request.POST` 和 `request.FILES`
    来实例化表单。然后我们使用标准的 `is_valid` 方法来检查表单的有效性，并且只有在表单有效的情况下才保存文件上传。我们测试了文件上传，并看到我们能够使用
    `MEDIA_URL` 检索上传的文件。
- en: In the next section, we will look at `ImageField`, which is like a `FileField`
    but specifically for images.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看 `ImageField`，它类似于 `FileField`，但专门用于图像。
- en: Image Uploads with Django Forms
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Django表单进行图像上传
- en: 'If you want to work with images in Python, the most common library that you
    will use is called `Image` object is imported from PIL:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Python中处理图像，你将最常使用的库叫做 `Image`，它从PIL导入：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The terms Python Imaging Library, PIL, and Pillow are often used interchangeably.
    You can assume that if someone refers to PIL, they mean the latest Pillow library.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Python Imaging Library、PIL和Pillow这些术语经常可以互换使用。你可以假设如果有人提到PIL，他们指的是最新的Pillow库。
- en: Pillow provides various methods of retrieving data about or manipulating images.
    You can find out the width and height of images, or scale, crop, and apply transformations
    to them. There are too many operations available to cover in this chapter, so
    we will just introduce a simple example (scaling an image), which you will use
    in the next exercise.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow提供了各种检索图像数据或操作图像的方法。你可以找出图像的宽度和高度，或者缩放、裁剪并对它们应用变换。由于本章中可用的操作太多，我们只介绍一个简单的例子（缩放图像），你将在下一个练习中使用它。
- en: Since images are one of the most common types of files that a user may want
    to upload, Django also includes an `ImageField` instance. This behaves similarly
    to `FileField` instance but also automatically validates that the data is an image
    file. This helps mitigate security issues where we expect an image, but the user
    uploads a malicious file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图片是用户可能想要上传的最常见的文件类型之一，Django也包含了一个`ImageField`实例。这个实例的行为与`FileField`实例类似，但也会自动验证数据是否为图片文件。这有助于减轻我们期望是图片但用户上传了恶意文件时的安全问题。
- en: 'An `UploadedFile` from an `ImageField` has all the same attributes and methods
    as that of a `FileField` (`size`, `content_type`, `name`, `chunks()`, and so on)
    but adds an extra attribute: `image`. This is an instance of the PIL `Image` object
    that is used to verify that the file being uploaded is a valid image.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`ImageField`的`UploadedFile`具有与`FileField`相同的所有属性和方法（`size`、`content_type`、`name`、`chunks()`等），但增加了一个额外的属性：`image`。这是一个PIL
    `Image`对象的实例，用于验证上传的文件是否为有效的图片。
- en: After checking that the form is valid, the underlying PIL `Image` object is
    closed. This is to free up memory and prevent the Python process from holding
    too many files open, which could cause performance issues. What this means for
    the developer is that you can access some of the metadata about the image (such
    as its `width`, `height`, and `format`) but you can't access the actual image
    data without re-opening the image.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查表单有效后，底层的PIL `Image`对象被关闭。这是为了释放内存并防止Python进程打开太多文件，这可能会引起性能问题。对于开发者来说，这意味着你可以访问一些关于图片的元数据（如其`width`、`height`和`format`），但如果不重新打开图片，你无法访问实际的图片数据。
- en: 'To illustrate, we will have a form with an `ImageField`, named `picture`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们将有一个包含`ImageField`的表单，命名为`picture`：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Inside the view function, the `picture` field can be accessed in the form''s
    `cleaned_data`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图函数内部，可以在表单的`cleaned_data`中访问`picture`字段：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, the `picture` field''s `Image` object can be retrieved:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以检索`picture`字段的`Image`对象：
- en: '[PRE57]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that we have a reference to the image in the view, we can get some metadata:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在视图中有了图片的引用，我们可以获取一些元数据：
- en: '[PRE58]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Django will also automatically update the `content_type` attribute of `UploadedFile`
    to the correct type for the `picture` field. This overwrites the value that the
    browser sent when uploading the file.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Django还会自动更新`UploadedFile`的`content_type`属性，使其适用于`picture`字段。这将覆盖浏览器上传文件时发送的值。
- en: Attempting to use a method that accesses the actual image data (rather than
    just the metadata) will cause an exception to be raised. This is because Django
    has already closed the underlying image file.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用访问实际图片数据的方法（而不是仅访问元数据）将引发异常。这是因为Django已经关闭了底层的图片文件。
- en: 'For example, the following code snippet will raise an `AttributeError`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段将引发`AttributeError`：
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Instead, we need to re-open the image. The image data can be opened with the
    `ImageField` reference, after importing the `Image` class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要重新打开图片。在导入`Image`类后，可以使用`ImageField`引用打开图片数据：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now that the image has been opened, you can perform operations on it. In the
    next section, we will look at a simple example – resizing the uploaded image.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图片已经打开，你可以对它进行操作。在下一节中，我们将查看一个简单的示例——调整上传的图片大小。
- en: Resizing an Image with Pillow
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Pillow调整图片大小
- en: 'Pillow supports many operations that you might want to perform on an image
    before saving it. We cannot explain them all in this book, so we will just use
    a common operation: resizing an image to a specific size before saving it. This
    will help us save storage space and improve the download speed. For example, a
    user may upload large cover images in Bookr that are bigger than are needed for
    our purposes. When saving the file (writing it back to disk) we must specify the
    format to use. We could determine the type of image that was uploading with a
    number of methods (such as checking the `content_type` of the uploaded file or
    the `format` from the `Image` object), but in our example, we will always just
    save the image as a `JPEG` file.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow支持许多在保存图片之前你可能想要执行的操作。我们无法在这本书中解释所有这些操作，所以我们只使用一个常见的操作：在保存之前将图片调整到特定大小。这将帮助我们节省存储空间并提高下载速度。例如，用户可能在Bookr上传了比我们所需更大的封面图片。当保存文件（将其写回磁盘）时，我们必须指定要使用的格式。我们可以通过多种方法确定上传的图片类型（例如检查上传文件的`content_type`或`Image`对象的`format`），但在我们的示例中，我们总是将图片保存为`JPEG`文件。
- en: 'The PIL `Image` class has a `thumbnail` method that will resize an image to
    a maximum size while retaining the aspect ratio. For example, we could set a maximum
    size of 50px by 50px. A 200px by 100px image would be resized to 50px by 25px:
    the aspect ratio is retained by setting the maximum dimension to 50px. Each dimension
    is scaled by a factor of 0.25:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: PIL的`Image`类有一个`thumbnail`方法，可以将图像调整到最大尺寸同时保持宽高比。例如，我们可以将最大尺寸设置为50px x 50px。一个200px
    x 100px的图像将被调整到50px x 25px：通过将最大尺寸设置为50px来保持宽高比。每个维度都按0.25的因子缩放：
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'At this point, the resize has been done in memory only. The change is not saved
    to disk until the `save` method is called, like so:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，调整仅在内存中完成。直到调用`save`方法，更改才不会保存到磁盘，如下所示：
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output format is automatically determined from the file extension used,
    in this case, JPEG. The `save` method can also take a format argument to override
    it. For example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式会自动根据使用的文件扩展名确定，在本例中为JPEG。`save`方法也可以接受一个格式参数来覆盖它。例如：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Despite having the extension `png`, the format is specified as `JPEG` and so
    the output will be in JPEG format. As you might imagine, this can be very confusing,
    so you might decide to stick with specifying the extension only.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管扩展名为`png`，格式指定为`JPEG`，因此输出将是JPEG格式。正如你可能想象的那样，这可能会非常令人困惑，因此你可能决定只坚持指定扩展名。
- en: In the next exercise, we will change the `UploadForm` we have been working with
    to use an `ImageField` instead of a `FileField`, then implement the resizing of
    an uploaded image before saving it to the media directory.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将更改我们一直在使用的`UploadForm`，使用`ImageField`而不是`FileField`，然后实现在上传的图像保存到媒体目录之前对其进行调整。
- en: 'Exercise 8.05: Image Uploads using Django Forms'
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.05：使用Django表单上传图片
- en: 'In this exercise, you will update the `UploadForm` class you created in *Exercise
    8.04*, *File Uploads with a Django Form*, to use an `ImageField` instead of a
    `FileField` (this will involve simply changing the field''s class). You will then
    see that the form renders it in the browser. Next, you will try uploading some
    non-image files and see how Django validates the form to disallow them. Finally,
    you will update your view to use PIL to resize the image before saving it, and
    then test it in action:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将更新你在*练习8.04*中创建的`UploadForm`类，使用`ImageField`而不是`FileField`（这将涉及简单地更改字段的类）。然后你将看到表单在浏览器中渲染。接下来，你将尝试上传一些非图像文件，看看Django如何验证表单以禁止它们。最后，你将更新你的视图，在保存到媒体目录之前使用PIL调整图像大小，并在实际操作中测试它：
- en: 'Open the `media_example` app''s `forms.py` file. In the `UploadForm` class,
    change `file_upload` so it''s an instance of `ImageField` instead of `FileField`.
    After updating, your `UploadForm` should look like this:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`media_example`应用的`forms.py`文件。在`UploadForm`类中，将`file_upload`更改为`ImageField`的实例而不是`FileField`。更新后，你的`UploadForm`应该看起来像这样：
- en: '[PRE64]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Start the Django dev server if it is not already running, then navigate to
    `http://127.0.0.1:8000/media-example/`. You should see the form rendered, and
    it will look identical as to when we used a `FileField` (see the following figure):![Figure
    8.16: The ImageField looks the same as a FileField'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Django开发服务器尚未运行，请启动它，然后导航到`http://127.0.0.1:8000/media-example/`。你应该能看到渲染的表单，并且它的外观与我们使用`FileField`时相同（见下图）：![图8.16：ImageField与FileField外观相同
- en: '](img/B15509_08_16.jpg)'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_16.jpg)'
- en: 'Figure 8.16: The ImageField looks the same as a FileField'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.16：ImageField与FileField外观相同
- en: 'You will notice the difference when you try to upload a non-image file. Click
    the `Browse…` button and try to select a non-image file. Depending on your browser
    or operating system, you might not be able to select anything other than an image
    file, as in *Figure 8.17*:![Figure 8.17: Only image files are selectable'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你尝试上传非图像文件时，你会注意到差异。点击`浏览…`按钮并尝试选择一个非图像文件。根据你的浏览器或操作系统，你可能无法选择除图像文件以外的任何内容，就像*图8.17*所示：![图8.17：只能选择图像文件
- en: '](img/B15509_08_17.jpg)'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_17.jpg)'
- en: 'Figure 8.17: Only image files are selectable'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.17：只能选择图像文件
- en: Your browser may allow selecting an image but show an error in the form after
    selection. Or your browser may allow you to select a file and submit the form,
    and Django will raise a `ValidationError`. Regardless, you can be sure that in
    your view, the form's `is_valid` view will only return `True` if an image has
    been uploaded.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的浏览器可能允许选择图像，但在选择后显示错误。或者你的浏览器可能允许你选择文件并提交表单，Django将引发`ValidationError`。无论如何，你可以确信在你的视图中，表单的`is_valid`视图只有在上传了图像时才会返回`True`。
- en: Note
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You do not need to test uploading a file at this point, as the result would
    be the same as in *Exercise 8.04*, *File Uploads with a Django Form*.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在不需要测试上传文件，因为结果将与*练习8.04*中的相同，即使用Django表单上传文件。
- en: 'The first thing you will need to do is to make sure the Pillow library is installed.
    In a terminal (making sure your virtual environment has been activated), run:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先需要确保Pillow库已安装。在终端（确保你的虚拟环境已激活）中运行：
- en: '[PRE65]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '(In Windows, this is `pip install pillow`.) You will get output like *Figure 8.18*:'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （在Windows中，这是`pip install pillow`。）你将得到类似于*图8.18*的输出：
- en: '![Figure 8.18: pip3 installing Pillow'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.18：pip3安装Pillow'
- en: '](img/B15509_08_18.jpg)'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_18.jpg)'
- en: 'Figure 8.18: pip3 installing Pillow'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.18：pip3安装Pillow
- en: Or if Pillow was already installed, you will see the output message `Requirement
    already satisfied`.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，如果Pillow已经安装，你将看到输出消息`Requirement already satisfied`。
- en: 'Now we can update the `media_example` view to resize the image before saving
    it. Switch back to PyCharm and open the `media_example` app''s `views.py` file,
    then import PIL''s `Image` class. So, add this import line below the `import os`
    statement near the top of the file:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以更新`media_example`视图，在保存图像之前调整其大小。切换回PyCharm并打开`media_example`应用的`views.py`文件，然后导入PIL的`Image`类。所以，在文件顶部靠近`import
    os`语句下方添加此导入行：
- en: '[PRE66]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Go to the `media_example` view. Under the line that generates the `save_path`,
    take out the three lines that open the output file, iterate over the uploaded
    file, and write out its chunks. Replace this with the code that opens the uploaded
    file with PIL, resizes it, then saves it:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`media_example`视图。在生成`save_path`的行下面，移除打开输出文件的三个行，遍历上传的文件，并写出其块。用以下代码替换这些代码，该代码使用PIL打开上传的文件，调整其大小，然后保存：
- en: '[PRE67]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The first line creates an `Image` instance by opening the uploaded file, the
    next performs the thumbnail conversion (to a maximum size of 50px by 50px), and
    the third line saves the file to the same save path that we have been generating
    in previous exercises. You can save the file. It should look like this: [http://packt.live/34PWvof](http://packt.live/34PWvof).'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行通过打开上传的文件创建一个`Image`实例，下一行执行缩略图转换（最大尺寸为50px x 50px），第三行将文件保存到我们在之前练习中生成的相同保存路径。你可以保存文件。它应该看起来像这样：[http://packt.live/34PWvof](http://packt.live/34PWvof)。
- en: The Django dev server should still be running from *step 2*, but you should
    start it if it is not. Then, navigate to `http://127.0.0.1:8000/media-example/`.
    You will see the familiar `UploadForm`. Select an image and submit the form. If
    the upload and resize was successful, the form will refresh and be empty again.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django开发服务器应该仍然在*步骤2*中运行，但如果它没有运行，你应该启动它。然后，导航到`http://127.0.0.1:8000/media-example/`。你会看到熟悉的`UploadForm`。选择一个图像并提交表单。如果上传和调整大小成功，表单将刷新并再次为空。
- en: 'View the uploaded image using `MEDIA_URL`. For example, a file named `cover.jpg`
    will be downloadable from `http://127.0.0.1:8000/media/cover.jpg`. You should
    see the image has been resized to have a maximum dimension of just 50px:![Figure
    8.19: Resized logo'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`MEDIA_URL`查看上传的图像。例如，一个名为`cover.jpg`的文件将从`http://127.0.0.1:8000/media/cover.jpg`处可下载。你应该看到图像已被调整大小，最大尺寸仅为50px：![图8.19：调整大小的标志
- en: '](img/B15509_08_19.jpg)'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_19.jpg)'
- en: 'Figure 8.19: Resized logo'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：调整大小的标志
- en: While a thumbnail this size might not be that useful, it at least lets us be
    sure that the image resize has worked correctly.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个尺寸的缩略图可能不是非常有用，但它至少让我们确信图像调整大小已经正确完成。
- en: In this exercise, we changed the `FileField` on `UploadForm` to an `ImageField`.
    We saw that the browser wouldn't let us upload anything other than images. We
    then added code to the `media_example` view to resize the uploaded image using
    PIL.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将`UploadForm`上的`FileField`更改为`ImageField`。我们注意到浏览器不允许我们上传除图像之外的内容。然后我们在`media_example`视图中添加了代码，使用PIL调整上传的图像大小。
- en: We have encouraged the use of a separate web server to serve static and media
    files, for performance reasons. However, in some cases, you might want to use
    Django to serve files, for example, to provide authentication before allowing
    access. In the next section, we will discuss how to use Django to serve media
    files.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励使用单独的Web服务器来提供静态和媒体文件，出于性能考虑。然而，在某些情况下，你可能想使用Django来提供文件，例如，在允许访问之前提供身份验证。在下一节中，我们将讨论如何使用Django来提供媒体文件。
- en: Serving Uploaded (and Other) Files Using Django
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Django提供上传的（和其他）文件
- en: Throughout this chapter and *Chapter 5*, *Serving Static Files*, we have discouraged
    serving files using Django. This is because it would needlessly tie up a Python
    process just serving a file – something that the web server is capable of handling.
    Unfortunately, web servers do not usually provide dynamic access control, that
    is, allowing only authenticated users to download a file. Depending on your web
    server used in production, you might be able to have it authenticate against Django
    and then serve the file itself; however, the specific configuration of specific
    web servers is outside the scope of this book.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和*第五章* *静态文件服务*中，我们不建议使用Django来提供文件服务。这是因为这会无谓地占用一个Python进程来仅提供文件服务——这是Web服务器能够处理的事情。不幸的是，Web服务器通常不提供动态访问控制，即仅允许认证用户下载文件。根据你在生产中使用的Web服务器，你可能能够让它对Django进行身份验证，然后自己提供文件；然而，特定Web服务器的具体配置超出了本书的范围。
- en: One approach you can take is to specify a subdirectory of your `MEDIA_ROOT`
    directory and have your web server prevent access to just this specific folder.
    Any protected media should be stored inside it. If you do this, only Django will
    be able to read the files inside. For example, your web server could serve everything
    in the `MEDIA_ROOT` directory, except for a `MEDIA_ROOT/protected` directory.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取的一种方法是指定`MEDIA_ROOT`目录的子目录，并让你的Web服务器仅阻止对这个特定文件夹的访问。任何受保护的媒体都应该存储在其中。如果你这样做，只有Django能够读取其中的文件。例如，你的Web服务器可以提供`MEDIA_ROOT`目录中的所有内容，除了`MEDIA_ROOT/protected`目录。
- en: Another approach would be to configure a Django view to serve a specific file
    from disk. The view will determine the path of the file on disk to send, then
    send it using the `FileResponse` class. The `FileResponse` class takes an open
    filehandle as an argument and tries to determine the correct content type from
    the file's content. Django will close the filehandle after the request completes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将Django视图配置为从磁盘提供特定文件。视图将确定要发送的文件在磁盘上的路径，然后使用`FileResponse`类发送它。`FileResponse`类接受一个打开的文件句柄作为参数，并尝试从文件的内容中确定正确的MIME类型。Django将在请求完成后关闭文件句柄。
- en: The view function will accept the request and a relative path to the file to
    be downloaded, as parameters. This relative path is the path inside the `MEDIA_ROOT/protected`
    folder.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 视图函数将接受请求和一个指向要下载文件的相对路径作为参数。这个相对路径是`MEDIA_ROOT/protected`文件夹内的路径。
- en: 'In our case, we will just check whether the user is anonymous (not logged in).
    We will do this by checking the `request.user.is_anonymous` property. If they
    are not logged in then we will raise a `django.core.exceptions.PermissionDenied`
    exception, which returns an HTTP `403 Forbidden` response to the browser. This
    will stop the execution of the view and not return any file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只需检查用户是否匿名（未登录）。我们将通过检查`request.user.is_anonymous`属性来完成此操作。如果他们未登录，我们将引发一个`django.core.exceptions.PermissionDenied`异常，该异常会向浏览器返回一个HTTP
    `403 Forbidden`响应。这将停止视图的执行，并且不会返回任何文件：
- en: '[PRE68]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The URL mapping to this view could be like this, using the `<path>` path converter.
    Inside your `urls.py` file:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个视图的URL映射可以是这样的，使用`<path>`路径转换器。在你的`urls.py`文件中：
- en: '[PRE69]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: There are many ways that you could choose to implement a view that sends files.
    The important thing is that you use the `FileResponse` class, which is designed
    to stream the file to the client in chunks instead of loading it all into memory.
    This will reduce the load on the server and lessen the impact on resource usage
    if you have to resort to sending files with Django.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择多种方式来实现发送文件的视图。重要的是要使用`FileResponse`类，它被设计为以块的形式将文件流式传输到客户端，而不是将其全部加载到内存中。这将减少服务器的负载，并减少在必须使用Django发送文件时的资源使用影响。
- en: Storing Files on Model Instances
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模型实例上存储文件
- en: So far, we have manually managed the uploading and saving of files. You can
    also associate a file with a model instance by assigning the path to which it
    was saved to a `CharField`. However, as with much of Django, this capability (and
    more) is already provided with the `models.FileField` class. `FileField` instances
    do not actually store the file data; instead, they store the path where the file
    is stored (like a `CharField` would), but they also provide helper methods. These
    methods assist with loading files (so you do not have to manually open them) and
    generating disk paths for you based on the ID of the instance (or other attributes).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们手动管理了文件的上传和保存。您还可以通过将保存路径分配给`CharField`来将文件与模型实例关联。然而，正如Django的许多功能一样，这种能力（以及更多）已经通过`models.FileField`类提供。`FileField`实例实际上并不存储文件数据；相反，它们存储文件存储的路径（就像`CharField`一样），但它们还提供了辅助方法。这些方法帮助您加载文件（因此您不必手动打开它们）并根据实例的ID（或其他属性）为您生成磁盘路径。
- en: '`FileField` can accept two specific optional arguments in its constructor (as
    well as the base `Field` arguments, such as `required`, `unique`, `help_text`,
    and so on):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileField`在其构造函数中可以接受两个特定的可选参数（以及基本的`Field`参数，如`required`、`unique`、`help_text`等）：'
- en: '`max_length`: Like `max_length` in the form''s `ImageField`, this is the maximum
    length of the filename that is allowed.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_length`：与表单中的`ImageField`的`max_length`类似，这是允许的文件名最大长度。'
- en: '`upload_to`: The `upload_to` argument has three different behaviors depending
    on what type of variable is passed to it. Its simplest use is with a string or
    `pathlib.Path` object. The path is simply appended to `MEDIA_ROOT`.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upload_to`：`upload_to`参数的行为取决于传递给它的变量类型。其最简单的用法是与字符串或`pathlib.Path`对象一起使用。路径简单地附加到`MEDIA_ROOT`。'
- en: 'In this example, `upload_to` is just defined as a string:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`upload_to`只是定义为一个字符串：
- en: '[PRE70]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Files saved to this `FileField` would be stored in the `MEDIA_ROOT/files` directory.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 保存到这个`FileField`的文件将存储在`MEDIA_ROOT/files`目录中。
- en: 'You could achieve the same result using a `pathlib.Path` instance too:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`pathlib.Path`实例来实现相同的结果：
- en: '[PRE71]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The next way of using `upload_to` is with a string that contains `strftime`
    formatting directives (for example, `%Y` to substitute the current year, `%m`
    for the current month, and `%d` for the current day of the month). The full list
    of these directives is extensive and can be found at [https://docs.python.org/3/library/time.html#time.strftime](https://docs.python.org/3/library/time.html#time.strftime).
    Django will automatically interpolate these values when saving the file.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`upload_to`的另一种方式是使用包含`strftime`格式化指令的字符串（例如，`%Y`用于替换当前年份，`%m`用于当前月份，`%d`用于当前月份的日期）。这些指令的完整列表非常广泛，可以在[https://docs.python.org/3/library/time.html#time.strftime](https://docs.python.org/3/library/time.html#time.strftime)中找到。Django会在保存文件时自动插入这些值。
- en: 'For example, say you defined the model and `FileField` like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您这样定义了模型和`FileField`：
- en: '[PRE72]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: For the first file uploaded on a specific day, Django would create the directory
    structure for that day. For example, for the first file uploaded on January 1,
    2020, Django would create the directory `MEDIA_ROOT/2020/01/01` and then store
    the uploaded file in there. The next file (and all subsequent ones) uploaded on
    the same day would also be stored in that directory. Similarly, on January 2,
    2020, Django would create the `MEDIA_ROOT/2020/01/02` directory, and files would
    be stored there.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定一天上传的第一个文件，Django会为该天创建目录结构。例如，对于2020年1月1日上传的第一个文件，Django会创建`MEDIA_ROOT/2020/01/01`目录，并将上传的文件存储在那里。同一天上传的下一个文件（以及所有后续文件）也会存储在该目录中。同样，在2020年1月2日，Django会创建`MEDIA_ROOT/2020/01/02`目录，并将文件存储在那里。
- en: If you have many thousands of files being uploaded every day, you could even
    have the files split up further by including the hour and minute in the `upload_to`
    argument (`upload_to="files/%Y/%m/%d/%H/%M/"`). This may not be necessary if you
    only have a small volume of uploads though.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您每天上传成千上万的文件，您甚至可以通过在`upload_to`参数中包含小时和分钟来进一步拆分文件（`upload_to="files/%Y/%m/%d/%H/%M/"`）。但如果上传量很小，这可能不是必要的。
- en: By utilizing this method of the `upload_to` argument, you can have Django automatically
    segregate uploads and prevent too many files from being stored within a single
    directory (which can be hard to manage).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用`upload_to`参数的这种方法，您可以让Django自动隔离上传，防止太多文件存储在单个目录中（这可能很难管理）。
- en: 'The final method of using `upload_to` is by passing a function that will be
    called to generate the storage path. Note that this is different than the other
    uses of `upload_to` as it should generate the full path, including filename, rather
    than just the directory. The function takes two arguments: `instance` and `filename`.
    `instance` is the model instance that the `FileField` is attached to, and `filename`
    is the name of the uploaded file.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`upload_to`的最终方法是传递一个函数来生成存储路径。请注意，这与`upload_to`的其他用法不同，因为它应该生成包括文件名在内的完整路径，而不仅仅是目录。该函数接受两个参数：`instance`和`filename`。`instance`是与`FileField`相关联的模型实例，`filename`是上传文件的名称。
- en: 'Here is an example function that takes the first two characters of a filename
    to generate the saved directory. This will mean that each uploaded file will be
    grouped into parent directories, which can help organize files and prevent there
    from being too many in one directory:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例函数，它取文件名的前两个字符来生成保存的目录。这意味着每个上传的文件都将被分组到父目录中，这有助于组织文件并防止一个目录中文件过多：
- en: '[PRE73]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If this function is called with the filename `Test.jpg`, it will return `<username>/t/e/Test.jpg`.
    If called with `example.txt`, it will return `<username>e/x/example.txt`, and
    so on. `username` is retrieved from the instance that is being saved. To illustrate,
    here is a model with a `FileField` that uses this function. It also has a username,
    which is a `CharField`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数用文件名`Test.jpg`调用，它将返回`<username>/t/e/Test.jpg`。如果用`example.txt`调用，它将返回`<username>e/x/example.txt`，依此类推。`username`是从正在保存的实例中检索的。为了说明，这里有一个使用此函数的`FileField`的模型示例。它还有一个用户名，这是一个`CharField`：
- en: '[PRE74]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You can use any attribute of the instance in the `upload_to` function, but be
    aware that if this instance is in the process of being created, then the file
    save function will be called before it is saved to the database. Therefore, some
    of the automatically generated attributes on the instance (such as `id`/`pk`)
    will not yet be populated and should not be used to generate a path.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`upload_to`函数中使用实例的任何属性，但请注意，如果这个实例正在创建过程中，那么文件保存函数将在它保存到数据库之前被调用。因此，实例上的一些自动生成的属性（如`id`/`pk`）可能尚未填充，不应用于生成路径。
- en: Whatever path is returned from the `upload_to` function, it is appended to `MEDIA_ROOT`
    so the uploaded files would be saved at `MEDIA_ROOT/<username>/t/e/Test.jpg` and
    `MEDIA_ROOT/<username>/e/x/example.txt` respectively.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 从`upload_to`函数返回的任何路径都会附加到`MEDIA_ROOT`，因此上传的文件将被保存在`MEDIA_ROOT/<username>/t/e/Test.jpg`和`MEDIA_ROOT/<username>/e/x/example.txt`分别。
- en: Note that `user_grouped_file_path` is just an illustrative function that has
    intentionally been kept short, so it will not work correctly with single-character
    filenames or if the username has invalid characters. For example, if the username
    has a `/` in it, then this would act as a directory separator in the generated
    path.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`user_grouped_file_path`只是一个说明性函数，故意保持简短，所以它不能正确处理单字符文件名或用户名包含无效字符的情况。例如，如果用户名中包含`/`，那么这将在生成的路径中充当目录分隔符。
- en: 'Now we have done a deep dive into setting up a `FileField` on a model, but
    how do we actually save an uploaded file to it? It is as easy as assigning the
    uploaded file to the attribute of the model, as you would with any type of value.
    Here is a quick example with a view, and the simple `ExampleModel` class we were
    using as an example earlier in this section:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入探讨了在模型上设置`FileField`的过程，但我们是如何实际将上传的文件保存到它的呢？这就像将上传的文件分配给模型的属性一样简单，就像分配任何类型的值一样。这里有一个使用视图和我们在本节前面作为示例使用的简单`ExampleModel`类的快速示例：
- en: '[PRE75]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this example, we create a new `ExampleModel` class and assign the uploaded
    file (which had the name `uploaded_file` in the form) to its `file_field` attribute.
    When we save the model instance, Django automatically writes the file with its
    name to the `upload_to` directory path. If the uploaded file had the name `image.jpg`,
    the save path would be `MEDIA_ROOT/upload_to/image.jpg`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个新的`ExampleModel`类，并将上传的文件（在表单中名为`uploaded_file`）分配给其`file_field`属性。当我们保存模型实例时，Django会自动将文件及其名称写入`upload_to`目录路径。如果上传的文件名为`image.jpg`，保存路径将是`MEDIA_ROOT/upload_to/image.jpg`。
- en: 'We could just have easily updated the file field on an existing model or used
    a form (validating it before saving). Here is another simple example demonstrating
    this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样可以更新现有模型上的文件字段或使用表单（在保存之前进行验证）。这里还有一个演示这一点的简单示例：
- en: '[PRE76]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: You can see that updating a `FileField` on an existing model instance is the
    same process as setting it on a new instance; and if you choose to use a Django
    form, or just access `request.FILES` directly, the process is just as simple.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，更新现有模型实例上的 `FileField` 与在新的实例上设置它的过程相同；如果你选择使用 Django 表单，或者直接访问 `request.FILES`，过程同样简单。
- en: Storing Images on Model Instances
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模型实例上存储图像
- en: While a `FileField` can store any type of file, including images, there is also
    an `ImageField`. As you would expect, this is only for storing images. The relationship
    between models' `forms.FileField` and `forms.ImageField` is similar to that between
    `models.FileField` and `models.ImageField`, that is, `ImageField` extends `FileField`
    and adds extra methods for working with images.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `FileField` 可以存储任何类型的文件，包括图像，但还有一个 `ImageField`。正如你所期望的，这只是为了存储图像。模型 `forms.FileField`
    和 `forms.ImageField` 之间的关系类似于 `models.FileField` 和 `models.ImageField` 之间的关系，即
    `ImageField` 扩展了 `FileField` 并为处理图像添加了额外的方法。
- en: 'The `ImageField` constructor takes the same arguments as `FileField`, and adds
    two extra optional arguments:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageField` 构造函数接受与 `FileField` 相同的参数，并添加了两个额外的可选参数：'
- en: '`height_field`: This is the name of the field of the model that will be updated
    with the height of the image every time the model instance is saved.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height_field`：这是模型中将被更新为图像高度的字段名称，每次保存模型实例时都会更新。'
- en: '`width_field`: The width counterpart to `height_field`, the field that stores
    the width of the image that is updated every time the model instance is saved.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width_field`：与 `height_field` 相对应的宽度字段，该字段存储每次保存模型实例时更新的图像宽度。'
- en: Both of these arguments are optional, but the fields they name must exist if
    used. That is, it is valid to have `height_field` or `width_field` unset, but
    if they are set to the name of a field that does not exist, then an error will
    occur. The purpose of this is to assist with searching the database for files
    of a particular dimension.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数都是可选的，但如果使用，它们命名的字段必须存在。也就是说，可以不设置 `height_field` 或 `width_field`，但如果它们被设置为不存在字段的名称，则将发生错误。这样做的目的是帮助搜索特定尺寸的文件。
- en: 'Here is an example model using an `ImageField`, which updates the image dimension
    fields:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用 `ImageField` 的示例模型，它更新图像尺寸字段：
- en: '[PRE77]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Notice that the `ImageField` is using the `upload_to` parameter with date formatting
    directives that are updated on save. The behavior of `upload_to` is identical
    to that of `FileField`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ImageField` 使用了 `upload_to` 参数，该参数包含在保存时更新的日期格式化指令。`upload_to` 的行为与 `FileField`
    相同。
- en: Upon saving an `ExampleModel` instance, its `image_height` field would be updated
    with the height of the image, and `image_width` with the width of the image.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当保存 `ExampleModel` 实例时，其 `image_height` 字段会更新为图像的高度，而 `image_width` 会更新为图像的宽度。
- en: We will not show examples for setting `ImageField` values in a view, as the
    process is the same as for a plain `FileField`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会展示在视图中设置 `ImageField` 值的示例，因为这个过程与普通的 `FileField` 相同。
- en: Working with FieldFile
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 FieldFile
- en: When you access a `FileField` or `ImageField` attribute of a model instance,
    you will not get a native Python `file` object. Instead, you will be working with
    a `FieldFile` object. The `FieldFile` class is a wrapper around a `file` that
    adds extra methods. Yes, it can be confusing to have classes called `FileField`
    and `FieldFile`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问模型实例的 `FileField` 或 `ImageField` 属性时，你不会得到一个原生的 Python `file` 对象。相反，你将使用一个
    `FieldFile` 对象。`FieldFile` 类是一个围绕 `file` 的包装器，它添加了额外的方法。是的，有 `FileField` 和 `FieldFile`
    这样的类名可能会让人困惑。
- en: The reason that Django uses `FieldFile` instead of just a `file` object is twofold.
    First, it adds extra methods to open, read, delete, and generate the URL of the
    file. Second, it provides an abstraction to allow alternative storage engines
    to be used.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Django 使用 `FieldFile` 而不是仅仅一个 `file` 对象的原因有两个。首先，它为打开、读取、删除和生成文件URL添加了额外的方法。其次，它提供了一个抽象，允许使用替代存储引擎。
- en: Custom Storage Engines
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义存储引擎
- en: We looked at custom storage engines in *Chapter 5*, *Serving Static Files*,
    regarding storing static files. We will not examine custom storage engines in
    detail about media files, since the code outlined in *Chapter 5*, *Serving Static
    Files*, for static files also applies to media files. The important thing to note
    is that the storage engine you are using can be changed without updating your
    other code. This means that you can have your media files stored on your local
    drive during development and then saved to a CDN when your application is deployed
    to production.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第5章*，*服务静态文件*中讨论了自定义存储引擎，关于存储静态文件。我们不会详细检查媒体文件的自定义存储引擎，因为*第5章*，*服务静态文件*中概述的代码也适用于媒体文件。需要注意的是，您所使用的存储引擎可以在不更新其他代码的情况下更改。这意味着您可以在开发期间将媒体文件存储在本地驱动器上，然后在应用程序部署到生产环境时将其保存到CDN。
- en: 'The default storage engine class can be set with `DEFAULT_FILE_STORAGE` in
    `settings.py`. The storage engine can also be specified on a per-field basis (for
    `FileField` or `ImageField`) with the `storage` argument. For example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 默认存储引擎类可以通过在`settings.py`中使用`DEFAULT_FILE_STORAGE`来设置。存储引擎也可以通过`storage`参数按字段设置（对于`FileField`或`ImageField`）。例如：
- en: '[PRE78]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This demonstrates what actually happens when you upload or retrieve a file.
    Django delegates to the storage engine to write or read it, respectively. This
    happens even while saving to disk; however, it is fundamental and is invisible
    to the user.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了当你上传或检索文件时实际发生的情况。Django委托给存储引擎来分别写入或读取它。即使在保存到磁盘时也是如此；然而，这是基本的，对用户来说是不可见的。
- en: Reading a Stored FieldFile
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取存储的字段文件
- en: Now that we have learned about custom storage engines, let us look at reading
    from a `FieldFile`. In the previous sections, we saw how to set the file on the
    model instance. Reading the data back again is just as easy – we have a couple
    of different methods that can help us, depending on our use case.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了自定义存储引擎，让我们看看如何从`FieldFile`中读取。在前面的章节中，我们看到了如何在模型实例上设置文件。再次读取数据同样简单——我们有几种不同的方法可以帮助我们，具体取决于我们的用例。
- en: 'In the following few code snippets, assume we are inside a view and have retrieved
    our model instance in some manner, and it is stored in a variable, `m`. For example:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几个代码片段中，假设我们处于一个视图中，并且以某种方式检索了我们的模型实例，并将其存储在变量`m`中。例如：
- en: '[PRE79]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can read all the data from the file with the `read` method:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`read`方法从文件中读取所有数据：
- en: '[PRE80]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Or we can manually open the file with the `open` method. This might be useful
    if we want to write our own generated data to the file:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`open`方法手动打开文件。如果我们想将我们自己生成的数据写入文件，这可能很有用：
- en: '[PRE81]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If we wanted to read the file in chunks, we can use the `chunks` method. This
    works the same as reading chunks from the uploaded file, as we saw earlier:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想分块读取文件，可以使用`chunks`方法。这与我们之前看到的从上传的文件中读取块的方式相同：
- en: '[PRE82]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can also manually open the file ourselves by using its `path` attribute:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用其`path`属性手动打开文件：
- en: '[PRE83]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If we want to stream a `FileField` for download, the best way is by using the
    `FileResponse` class as we saw earlier. Combine this with the `open` method on
    the `FileField`. Note that if we are just trying to serve a media file, we should
    only implement a view to do this if we are trying to restrict access to the file.
    Otherwise, we should just serve the file using `MEDIA_URL` and allow the web server
    to handle the request. Here is how we''d write our `download_view` to use a `FileField`
    instead of the manually specified path:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为下载流式传输`FileField`，最好的方法是我们之前看到的`FileResponse`类。结合`FileField`上的`open`方法。请注意，如果我们只是尝试提供媒体文件，我们应该只实现一个视图来执行此操作，如果我们试图限制对文件的访问。否则，我们应该使用`MEDIA_URL`提供文件，并允许Web服务器处理请求。以下是我们的`download_view`如何使用`FileField`而不是手动指定的路径来编写的示例：
- en: '[PRE84]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Django opens the correct path and closes it after the response. Django will
    also attempt to determine the correct mime type for the file. We assume that this
    `FileField` has its `upload_to` attribute set to a protected directory that the
    web server is preventing direct access to.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Django打开正确的路径，在响应后关闭它。Django还将尝试确定文件的正确MIME类型。我们假设这个`FileField`的`upload_to`属性设置为一个受保护的目录，该目录被Web服务器阻止直接访问。
- en: Storing Existing Files or Content in FileField
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在FileField中存储现有文件或内容
- en: 'We''ve seen how to store an uploaded file in an image field – simply assign
    it to the field like so:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何将上传的文件存储在图像字段中——只需将其分配给字段即可：
- en: '[PRE85]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'But how can we set the `field` value to that of an existing file that we might
    already have on disk? You might think you can use a standard Python `file` object,
    but this won''t work:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何将 `field` 值设置为可能已经在磁盘上存在的现有文件的值？你可能认为你可以使用标准的 Python `file` 对象，但这不会起作用：
- en: '[PRE86]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You might also try setting the file using some content:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试使用一些内容来设置文件：
- en: '[PRE87]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This won't work either.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不会起作用。
- en: You instead need to use the `save` method of `FileField`, which accepts an instance
    of a Django `File` or `ContentFile` object (these classes' full paths are `django.core.files.File`
    and `django.core.files.base.ContentFile`, respectively). We will briefly discuss
    the `save` method and its arguments then return to these classes.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用 `FileField` 的 `save` 方法，它接受 Django `File` 或 `ContentFile` 对象的实例（这些类的完整路径分别是
    `django.core.files.File` 和 `django.core.files.base.ContentFile`）。然后我们将简要讨论 `save`
    方法及其参数，然后返回到这些类。
- en: 'The `save` method of `FileField` takes three arguments:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileField` 的 `save` 方法接受三个参数：'
- en: '`name`: The name of the file you are saving. This is the name the file will
    have when saved to the storage engine (in our case, to disk, inside `MEDIA_ROOT`).'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：你要保存的文件名。这是文件在存储引擎（在我们的例子中，是磁盘，在 `MEDIA_ROOT` 内部）保存时的名称。'
- en: '`Content`: This is an instance of `File` or `ContentFile`, which we just saw;
    again, we will discuss these soon.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content`：这是一个 `File` 或 `ContentFile` 的实例，我们刚刚提到；再次，我们很快就会讨论这些。'
- en: '`Save`: This argument is optional and defaults to `True`. This indicates whether
    or not to save the model instance to the database after saving the file. If set
    to `False` (that is, the model is not saved), then the file will still be written
    to the storage engine (to disk), but the association is not stored on the model.
    The previous file path (or no file if one was not set) will still be stored in
    the database until the model instance''s `save` method is called manually. You
    should only set this argument to `False` if you intend to make other changes to
    the model instance and then save it manually.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Save`：此参数是可选的，默认为 `True`。这表示在保存文件后是否将模型实例保存到数据库。如果设置为 `False`（即模型未保存），则文件仍将被写入存储引擎（到磁盘），但关联不会存储在模型中。之前的文件路径（或如果没有设置则没有文件）将仍然存储在数据库中，直到手动调用模型实例的
    `save` 方法。你应该只在打算对模型实例进行其他更改然后手动保存时设置此参数。'
- en: 'Back to `File` and `ContentFile`: the one to use depends on what you want to
    store in a `FileField`.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `File` 和 `ContentFile`：使用哪一个取决于你想要在 `FileField` 中存储什么。
- en: '`File` is used as a wrapper around a Python `file` object, and you should use
    it if you have an existing `file` or file-like object that you want to save. File-like
    objects include `io.BytesIO` or `io.StringIO` instances. To instantiate a `File`
    instance, just pass the native `file` object to the constructor, for example:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 被用作 Python `file` 对象的包装器，如果你有一个现有的 `file` 或类似文件的对象需要保存，你应该使用它。类似文件的对象包括
    `io.BytesIO` 或 `io.StringIO` 实例。要实例化一个 `File` 对象，只需将原生 `file` 对象传递给构造函数，例如：'
- en: '[PRE88]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Use `ContentFile` when you already have some data loaded, either a `str` or
    `bytes` object. Pass the data to the `ContentFile` constructor:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当你已经有了一些数据加载，无论是 `str` 或 `bytes` 对象时，使用 `ContentFile`。将数据传递给 `ContentFile` 构造函数：
- en: '[PRE89]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now that you have either a `File` or `ContentFile` instance, saving the data
    to the `FileField` is easy, using the `save` method:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个 `File` 或 `ContentFile` 实例，使用 `save` 方法将数据保存到 `FileField` 是很容易的：
- en: '[PRE90]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Since we did not pass a value for `save` to the `save` method, it will default
    to `True`, so the model instance is automatically persisted to the database.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有向 `save` 方法传递 `save` 的值，它将默认为 `True`，因此模型实例将自动持久化到数据库。
- en: Next, we will look at how to store an image that has been manipulated with a
    PIL back to an image field.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何将使用 PIL 处理过的图片存储回图像字段。
- en: Writing PIL Images to ImageField
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 PIL 图片写入 ImageField
- en: 'In *Exercise 8.05*, *Image Uploads Using Django Forms*, you used PIL to resize
    an image and save it to disk. When working with a model, you might want to perform
    a similar operation, but have Django handle the file storage using the `ImageField`
    so that you do not have to do it manually. As in the exercise, you could save
    the image to disk and then use the `File` class to wrap the stored path – something
    like this:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习 8.05*，*使用 Django 表单上传图片*中，你使用了 PIL 来调整图片大小并将其保存到磁盘。当与模型一起工作时，你可能想要执行类似的操作，但让
    Django 使用 `ImageField` 来处理文件存储，这样你就不必手动操作。就像练习中那样，你可以将图片保存到磁盘，然后使用 `File` 类来包装存储的路径——类似于以下内容：
- en: '[PRE91]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In this example, we're having PIL stored to a temporary location with the `Image.save()`
    method, and then re-opening the file.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`Image.save()`方法将PIL存储到一个临时位置，然后重新打开文件。
- en: This method works but is not ideal as it involves writing the file to disk and
    then reading it out again, which can sometimes be slow. Instead, we can perform
    this whole process in memory.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法虽然可行，但不是最佳选择，因为它涉及到将文件写入磁盘然后再读出来，这有时可能会很慢。相反，我们可以在内存中完成整个流程。
- en: Note
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`io.BytesIO` and `io.StringIO` are useful objects. They behave like files but
    exist in memory only. `BytesIO` is used for storing raw bytes, and `StringIO`
    accepts Python 3''s native Unicode strings. You can `read`, `write`, and `seek`
    them, just like a normal file. Unlike a normal file though, they do not get written
    to disk and instead will disappear when your program terminates, or they go out
    of scope and are garbage-collected. They are very useful if a function wants to
    write to something like a file, but you want to access the data immediately.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.BytesIO`和`io.StringIO`是非常有用的对象。它们的行为类似于文件，但仅存在于内存中。`BytesIO`用于存储原始字节，而`StringIO`接受Python
    3的本地Unicode字符串。你可以像操作普通文件一样`read`、`write`和`seek`它们。不过，与普通文件不同的是，它们不会写入磁盘，而是在程序终止或超出作用域并被垃圾回收时消失。如果函数想要写入类似文件的东西，但又想立即访问数据，它们非常有用。'
- en: First, we will save the image data to an `io.BytesIO` object. Then, we will
    wrap the `BytesIO` object in a `django.core.files.images.ImageFile` instance (a
    subclass of `File` that is specifically for images and provides `width` and `height`
    attributes). Once we have this `ImageFile` instance, we can use it in the `save`
    method of `ImageField`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将图像数据保存到一个`io.BytesIO`对象中。然后，我们将`BytesIO`对象包装在一个`django.core.files.images.ImageFile`实例中（这是一个专门用于图像的`File`子类，提供了`width`和`height`属性）。一旦我们有了这个`ImageFile`实例，我们就可以在`ImageField`的`save`方法中使用它。
- en: Note
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'An `ImageFile` is a file or file-like wrapper just like `File`. It provides
    two extra attributes: `width`, and `height`. `ImageFile` does not generate any
    errors if you use it to wrap a non-image. For example, you could `open()` a text
    file and pass the filehandle to the `ImageFile` constructor without any issue.
    You can check whether the image file you passed in was valid by trying to access
    the `width` or `height` attributes: if these are `None`, then PIL was unable to
    decode the image data. You could check for the validity of these values yourself
    and throw an exception if they were `None`.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageFile`是一个文件或类似文件的包装器，就像`File`一样。它提供了两个额外的属性：`width`和`height`。如果你使用它来包装非图像文件，`ImageFile`不会生成任何错误。例如，你可以打开一个文本文件，并将文件句柄传递给`ImageFile`构造函数而不会出现任何问题。你可以通过尝试访问`width`或`height`属性来检查你传递的图像文件是否有效：如果这些是`None`，那么PIL无法解码图像数据。你可以自己检查这些值的有效性，并在它们是`None`时抛出异常。'
- en: 'Let us have a look at this in practice, in a view:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实践中看看这个例子，在一个视图中：
- en: '[PRE92]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: You can see this is a little bit more code, but it saves on writing the data
    to disk. You can choose to use either method (or another one that you come up
    with) depending on your needs.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这需要一点更多的代码，但它可以节省将数据写入磁盘。你可以根据自己的需要选择使用任何一种方法（或你想到的另一种方法）。
- en: Referring to Media in Templates
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中引用媒体
- en: Once we have uploaded a file, we want to be able to refer to it in a template.
    For an uploaded image, such as a book cover, we will want to be able to display
    the image on the page. We saw in *Exercise 8.02*, *Template Settings and Using
    MEDIA_URL in Templates*, how to build a URL using `MEDIA_URL` in a template. When
    working with `FileField` or `ImageField` on a model instance, it is not necessary
    to do this as Django provides this functionality for you.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们上传了一个文件，我们希望能够在模板中引用它。对于一个上传的图像，比如书的封面，我们希望能够在页面上显示这个图像。我们在*练习8.02*，*模板设置和使用模板中的MEDIA_URL*中看到了如何使用模板中的`MEDIA_URL`构建一个URL。当在模型实例上使用`FileField`或`ImageField`时，没有必要这样做，因为Django为你提供了这个功能。
- en: The `url` attribute of a `FileField` will automatically generate the full URL
    to the media file, based on the `MEDIA_URL` in your settings.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileField`的`url`属性将自动根据你的设置中的`MEDIA_URL`生成媒体文件的完整URL。'
- en: Note
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that references we make to a `FileField` in this section also apply to
    `ImageField`, as it is a subclass of `FileField`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本节中我们对`FileField`的引用也适用于`ImageField`，因为它是`FileField`的子类。
- en: 'This can be used anywhere that you have access to the instance and field, such
    as in a view or a template. For example, in a view:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在任何你可以访问实例和字段的地方使用，例如在视图中。例如，在视图中：
- en: '[PRE93]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Or in a template (assuming the `instance` has been passed to the template context):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在一个模板中（假设 `instance` 已经传递到模板上下文中）：
- en: '[PRE94]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In the next exercise, we will create a new model with a `FileField` and `ImageField`,
    then show how Django can automatically save these. We'll also demonstrate how
    to retrieve the URL for an uploaded file.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将创建一个新的具有 `FileField` 和 `ImageField` 的模型，然后展示 Django 如何自动保存这些字段。我们还将演示如何检索上传文件的
    URL。
- en: 'Exercise 8.06: FileField and ImageField on Models'
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.06：在模型中使用 `FileField` 和 `ImageField`
- en: 'In this exercise, we will create a model with a `FileField` and `ImageField`.
    After doing this, we will have to generate a migration and apply it. We will then
    change the `UploadForm` we have been using so it has both a `FileField` and an
    `ImageField`. The `media_example` view will be updated to store the uploaded files
    in the model instance. Finally, we will add an `<img>` into the example template
    to show the previously uploaded image:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个具有 `FileField` 和 `ImageField` 的模型。完成此操作后，我们将必须生成迁移并应用它。然后，我们将更改我们一直在使用的
    `UploadForm`，使其具有 `FileField` 和 `ImageField`。`media_example` 视图将被更新以将上传的文件存储在模型实例中。最后，我们将在示例模板中添加一个
    `<img>` 标签以显示之前上传的图像：
- en: 'In PyCharm, open the `media_example` app''s `models.py` file. Create a new
    model called `ExampleModel`, with two fields: an `ImageField` named `image_field`,
    and a `FileField` called `file_field`. The `ImageField` should have its `upload_to`
    set to `images/`, and the `FileField` should have its `upload_to` set to `files/`.
    The finished model should look like this:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，打开 `media_example` 应用程序的 `models.py` 文件。创建一个名为 `ExampleModel` 的新模型，包含两个字段：一个名为
    `image_field` 的 `ImageField`，一个名为 `file_field` 的 `FileField`。`ImageField` 应将其
    `upload_to` 设置为 `images/`，而 `FileField` 应将其 `upload_to` 设置为 `files/`。完成后的模型应如下所示：
- en: '[PRE95]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Your `models.py` should now look like this: [http://packt.live/3p4bfrr](http://packt.live/3p4bfrr).'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的 `models.py` 应该现在看起来像这样：[http://packt.live/3p4bfrr](http://packt.live/3p4bfrr)。
- en: 'Open a terminal and navigate to the `media_project` project directory. Make
    sure your `bookr` virtual environment is active. Run the `makemigrations` management
    command to generate the migrations for this new model (for Windows, you can use
    `python` instead of `python3` in the following code):'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到 `media_project` 项目目录。确保你的 `bookr` 虚拟环境是激活的。运行 `makemigrations` 管理命令以生成此新模型的迁移（对于
    Windows，你可以在以下代码中使用 `python` 而不是 `python3`）：
- en: '[PRE96]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Apply the migration by running the `migrate` management command:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `migrate` 管理命令来应用迁移：
- en: '[PRE97]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output is like the following:'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE98]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note that all the initial Django migrations will also be applied since we did
    not apply those after creating the project.
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于我们在创建项目后没有应用这些初始 Django 迁移，所以所有这些初始迁移也将被应用。
- en: 'Switch back to PyCharm and open the `reviews` app''s `forms.py` file. Rename
    the existing `ImageField` from `file_upload` to `image_upload`. Then, add a new
    `FileField` named `file_upload`. After making these changes, your `UploadForm`
    code should look like this:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回 PyCharm 并打开 `reviews` 应用程序的 `forms.py` 文件。将现有的 `ImageField` 从 `file_upload`
    重命名为 `image_upload`。然后，添加一个新的 `FileField`，命名为 `file_upload`。在做出这些更改后，你的 `UploadForm`
    代码应该看起来像这样：
- en: '[PRE99]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You can save and close the file. It should look like this: [http://packt.live/37RZcaG](http://packt.live/37RZcaG).'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以保存并关闭文件。它应该看起来像这样：[http://packt.live/37RZcaG](http://packt.live/37RZcaG)。
- en: 'Open the `media_example` app''s `views.py` file. First, import `ExampleModel`
    into the file. To do this, add this line at the top of the file after the existing
    `import` statements:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `media_example` 应用程序的 `views.py` 文件。首先，将 `ExampleModel` 导入到文件中。为此，在文件顶部现有
    `import` 语句之后添加此行：
- en: '[PRE100]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Some imports will no longer be required, so you can remove these lines:'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些导入将不再需要，因此你可以删除这些行：
- en: '[PRE101]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In the `media_example` view, set a default for the instance that you will render,
    in case one is not created. After the function definition, define a variable called
    `instance`, and set it to `None`:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `media_example` 视图中，为将要渲染的实例设置一个默认值，以防没有创建实例。在函数定义之后，定义一个名为 `instance` 的变量，并将其设置为
    `None`：
- en: '[PRE102]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: You can completely remove the contents of the `form.is_valid()` branch as you
    no longer need to manually save the file. Instead, it will automatically be saved
    when the `ExampleModel` instance is saved. You will instantiate an `ExampleModel`
    instance and set the `file` and `image` fields from the uploaded form.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以完全删除 `form.is_valid()` 分支的内容，因为你不再需要手动保存文件。相反，当 `ExampleModel` 实例被保存时，它将自动保存。你将实例化一个
    `ExampleModel` 实例，并从上传的表单中设置 `file` 和 `image` 字段。
- en: 'Add this code under the `if form.is_valid():` line:'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `if form.is_valid():` 行下添加此代码：
- en: '[PRE103]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Pass the instance through to the template in the context dictionary that is
    passed to `render`. Use the key `instance`:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例通过上下文字典传递给`render`。使用键`instance`：
- en: '[PRE104]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, your completed `media_example` view should look like this: [http://packt.live/3hqyYz7](http://packt.live/3hqyYz7).'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您的完成后的`media_example`视图应该看起来像这样：[http://packt.live/3hqyYz7](http://packt.live/3hqyYz7)。
- en: You can now save and close this file.
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您现在可以保存并关闭此文件。
- en: 'Open the `media-example.html` template. Add an `<img>` element that displays
    the last uploaded image. Under the closing `</form>` tag, add an `if` template
    tag that checks if an `instance` has been provided. If so, display an `<img>`
    with a `src` attribute of `instance.image_field.url`:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`media-example.html`模板。添加一个`<img>`元素来显示最后上传的图像。在`</form>`标签下方，添加一个`if`模板标签来检查是否提供了`instance`。如果是，显示一个具有`src`属性为`instance.image_field.url`的`<img>`：
- en: '[PRE105]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can save and close this file. It should now look like this: [http://packt.live/2X5d5w9](http://packt.live/2X5d5w9).'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以保存并关闭此文件。现在它应该看起来像这样：[http://packt.live/2X5d5w9](http://packt.live/2X5d5w9)。
- en: 'Start the Django dev server if it is not already running, then navigate to
    `http://127.0.0.1:8000/media-example/`. You should see the form rendered with
    two fields:![Figure 8.20: UploadForm with two fields'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Django开发服务器尚未运行，请启动它，然后导航到`http://127.0.0.1:8000/media-example/`。您应该看到带有两个字段的表单被渲染：![图8.20：带有两个字段的UploadForm
- en: '](img/B15509_08_20.jpg)'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_20.jpg)'
- en: 'Figure 8.20: UploadForm with two fields'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.20：带有两个字段的UploadForm
- en: 'Select a file for each field – for the `ImageField` you must select an image,
    but any type of file is allowed for the `FileField`. See *Figure 8.21*, which
    shows the fields with files selected:![Figure 8.21: ImageField and FileField with
    files selected'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个字段选择一个文件——对于`ImageField`，您必须选择一个图像，但`FileField`允许任何类型的文件。参见*图8.21*，它显示了已选择文件的字段：![图8.21：已选择文件的ImageField和FileField
- en: '](img/B15509_08_21.jpg)'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_21.jpg)'
- en: 'Figure 8.21: ImageField and FileField with files selected'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.21：已选择文件的ImageField和FileField
- en: 'Then, submit the form. If the submission was successful, the page will reload
    and the last image you uploaded will be displayed (*Figure 8.22*):'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，提交表单。如果提交成功，页面将重新加载，并显示您最后上传的图像（*图8.22*）：
- en: '![Figure 8.22: The last image that was uploaded is displayed'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.22：显示最后上传的图像'
- en: '](img/B15509_08_22.jpg)'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_22.jpg)'
- en: 'Figure 8.22: The last image that was uploaded is displayed'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.22：显示最后上传的图像
- en: 'You can see how Django stores the files by looking in the `MEDIA_ROOT` directory.
    *Figure 8.23* shows the directory layout in PyCharm:![Figure 8.23: Uploaded files
    that Django has created'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过查看`MEDIA_ROOT`目录来了解Django如何存储文件。*图8.23*显示了PyCharm中的目录布局：![图8.23：Django创建的上传文件
- en: '](img/B15509_08_23.jpg)'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_23.jpg)'
- en: 'Figure 8.23: Uploaded files that Django has created'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23：Django创建的上传文件
- en: You can see that Django has created the `files` and `images` directories. These
    were what you set in the `upload_to` arguments on the `ImageField` and `FileField`
    of the model. You could also verify these uploads by attempting to download them,
    for example, at `http://127.0.0.1:8000/media/files/sample.txt` or `http://127.0.0.1:8000/media/images/cover.jpg`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到Django已经创建了`files`和`images`目录。这些目录就是您在模型的`ImageField`和`FileField`的`upload_to`参数中设置的。您也可以通过尝试下载它们来验证这些上传，例如，在`http://127.0.0.1:8000/media/files/sample.txt`或`http://127.0.0.1:8000/media/images/cover.jpg`。
- en: In this exercise, we created `ExampleModel` with `FileField` and `ImageField`
    and saw how to store uploaded files in it. We saw how to generate a URL to an
    uploaded file for use in a template. We tried uploading some files and saw that
    Django automatically created the `upload_to` directories (`media/files` and `media/images`),
    then stored the files inside.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了带有`FileField`和`ImageField`的`ExampleModel`，并看到了如何在其中存储上传的文件。我们看到了如何生成一个上传文件的URL，以便在模板中使用。我们尝试上传了一些文件，并看到Django自动创建了`upload_to`目录（`media/files`和`media/images`），然后在这些目录中存储了文件。
- en: In the next section, we will look at how we can simplify the process even further
    by using a `ModelForm` to generate the form and save the model without having
    to manually set the files in the view.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何通过使用`ModelForm`来生成表单并保存模型，从而进一步简化这个过程，而无需在视图中手动设置文件。
- en: ModelForms and File Uploads
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型表单和文件上传
- en: 'We have seen how using a `form.ImageField` on a form can prevent non-images
    being uploaded. We have also seen how `models.ImageField` makes it easy to store
    an image for a model. But we need to be aware that Django does not stop you from
    setting a non-image file to an `ImageField`. For example, consider a form that
    has both a `FileField` and `ImageField`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在表单上使用 `form.ImageField` 可以防止上传非图像。我们还看到 `models.ImageField` 如何使为模型存储图像变得容易。但我们需要意识到
    Django 不会阻止你将非图像文件设置为 `ImageField`。例如，考虑一个既有 `FileField` 又有 `ImageField` 的表单：
- en: '[PRE106]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In the following view, the form would not validate if the `uploaded_image`
    field on the form was not an image, so some data validity is ensured for uploaded
    data. For example:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下视图中，如果表单上的 `uploaded_image` 字段不是图像，则表单将无法验证，因此确保上传数据的数据有效性。例如：
- en: '[PRE107]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Since we are sure the form is valid, we know that `forms.cleaned_data["uploaded_image"]`
    must contain an image. Therefore, we would never assign a non-image to the model
    instance's `image_field`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们确信表单是有效的，我们知道 `forms.cleaned_data["uploaded_image"]` 必须包含一个图像。因此，我们永远不会将非图像分配给模型实例的
    `image_field`。
- en: 'However, say we made a mistake in our code and wrote something like this:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们代码中出了错，写成了这样：
- en: '[PRE108]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: That is, if we accidentally reference the `FileField` by mistake, Django does
    not validate that a (potential) non-image is being assigned to an `ImageField`,
    and so it does not throw an exception or generate any kind of error. We can mitigate
    the potential for issues like this by using a `ModelForm`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们不小心错误地引用了 `FileField`，Django 不会验证是否将（潜在的）非图像分配给了 `ImageField`，因此它不会抛出异常或生成任何类型的错误。我们可以通过使用
    `ModelForm` 来减轻这种问题的可能性。
- en: We introduced `ModelForm` in *Chapter 7*, *Advanced Form Validation and Model
    Forms* – these are forms whose fields are automatically defined from a model.
    We saw that a `ModelForm` has a `save` method that automatically creates or updates
    the model data in the database. When used with a model that has a `FileFIeld`
    or `ImageField`, then the `ModelForm` `save` method will also save uploaded files.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第 7 章*，*高级表单验证和模型表单* 中介绍了 `ModelForm` —— 这些表单的字段会自动从模型中定义。我们了解到 `ModelForm`
    有一个 `save` 方法，它会自动在数据库中创建或更新模型数据。当与具有 `FileFIeld` 或 `ImageField` 的模型一起使用时，`ModelForm`
    的 `save` 方法也会保存上传的文件。
- en: 'Here is an example of using a `ModelForm` to save a new model instance in a
    view. Here, we are just making sure to pass `request.FILES` to the `ModelForm` constructor:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `ModelForm` 在视图中保存新模型实例的示例。在这里，我们只是确保将 `request.FILES` 传递给 `ModelForm`
    构造函数：
- en: '[PRE109]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'As with any `ModelForm`, the `save` method can be called with the `commit`
    argument set to `False`. Then the model instance will not be saved to the database,
    and the `FileField`/`ImageField` files will not be saved to disk. The `save` method
    should be called on the model instance itself – this will commit changes to the
    database and save the files. In this next short example, we set a value on the
    model instance before saving it:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何 `ModelForm` 一样，可以通过将 `commit` 参数设置为 `False` 来调用 `save` 方法。然后模型实例将不会保存到数据库中，`FileField`/`ImageField`
    文件也不会保存到磁盘。应该在模型实例本身上调用 `save` 方法——这将提交更改到数据库并保存文件。在接下来的简短示例中，我们在保存模型实例之前给它设置了一个值：
- en: '[PRE110]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Calling the `save` method on the model instance both saves the model data to
    the database and the uploaded files to disk. In the next exercise, we will build
    a `ModelForm` from `ExampleModel`, which we created in *Exercise 8.06*, *FileField
    and ImageField on Models*, then test uploading files with it.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型实例上调用 `save` 方法既将模型数据保存到数据库，也将上传的文件保存到磁盘。在下一个练习中，我们将从我们在 *练习 8.06* 中创建的 `ExampleModel`
    构建一个 `ModelForm`，然后使用它测试上传文件。
- en: 'Exercise 8.07: File and Image Uploads Using a ModelForm'
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.07：使用 ModelForm 进行文件和图像上传
- en: 'In this exercise, you will update `UploadForm` to be a subclass of `ModelForm`
    and have it built automatically from `ExampleModel`. You will then change the
    `media_example` view to save the instance automatically from the form, so you
    can see how the amount of code can be reduced:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将更新 `UploadForm` 使其成为 `ModelForm` 的子类，并自动从 `ExampleModel` 中构建它。然后你将更改
    `media_example` 视图以自动从表单保存实例，这样你就可以看到代码量可以减少多少：
- en: 'In PyCharm, open the `media_example` apps'' `forms.py` file. You need to use
    `ExampleModel` in this chapter, so `import` it at the top of the file after the
    `from django import forms` statement. Insert this line:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，打开 `media_example` 应用程序的 `forms.py` 文件。在本章中，你需要使用 `ExampleModel`，因此请在
    `from django import forms` 语句之后在文件顶部 `import` 它。插入以下行：
- en: '[PRE111]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Change `UploadForm` to be a subclass of `forms.ModelForm`. Remove the `class`
    body and replace it with a `class Meta` definition; its `model` should be `ExampleModel`.
    Set the `fields` attribute to `__all__`. After completing this step, your `UploadForm`
    should look like this:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`UploadForm`改为`forms.ModelForm`的子类。移除`class`体，并用`class Meta`定义替换它；其`model`应该是`ExampleModel`。将`fields`属性设置为`__all__`。完成此步骤后，您的`UploadForm`应如下所示：
- en: '[PRE112]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Save and close the file. It should now look like this: [http://packt.live/37X49ig](http://packt.live/37X49ig).'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存并关闭文件。现在它应该如下所示：[http://packt.live/37X49ig](http://packt.live/37X49ig)。
- en: 'Open the `media_example` app''s `views.py` file. Since you no longer need to
    reference the `ExampleModel` directly, you can remove its `import` at the top
    of the file. Remove the following line:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`media_example`应用的`views.py`文件。由于您不再需要直接引用`ExampleModel`，您可以从文件顶部移除它的`import`。移除以下行：
- en: '[PRE113]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In the `media_example` view, remove the entirety of the `form.is_valid()` branch
    and replace it with a single line:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`media_example`视图中，移除整个`form.is_valid()`分支，并用一行代码替换它：
- en: '[PRE114]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The form's `save` method will handle persisting the instance to the database
    and saving the files. It will return an instance of `ExampleModel`, the same as
    the other instances of `ModelForm` we have worked with in *Chapter 7*, *Advanced
    Form Validation and Model Forms*.
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表单的`save`方法将处理将实例持久化到数据库并保存文件。它将返回一个`ExampleModel`的实例，这与我们在*第7章*、*高级表单验证和模型表单*中使用的其他`ModelForm`实例相同。
- en: 'After completing this step, your `media_example` function should look like
    this: [http://packt.live/37V0ly2](http://packt.live/37V0ly2). Save and close `views.py`.'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成此步骤后，您的`media_example`函数应如下所示：[http://packt.live/37V0ly2](http://packt.live/37V0ly2)。保存并关闭`views.py`。
- en: 'Start the Django dev server if it is not already running, then navigate to
    `http://127.0.0.1:8000/media-example/`. You should see the form rendered with
    two fields, `Image field` and `File field` (*Figure 8.24*):![Figure 8.24: UploadForm
    as a ModelForm rendered in the browser'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Django开发服务器尚未运行，请启动它，然后导航到`http://127.0.0.1:8000/media-example/`。您应该看到带有两个字段`Image
    field`和`File field`的表单渲染（*图8.24*）：![图8.24：在浏览器中渲染的UploadForm作为ModelForm
- en: '](img/B15509_08_24.jpg)'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_24.jpg)'
- en: 'Figure 8.24: UploadForm as a ModelForm rendered in the browser'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.24：在浏览器中渲染的UploadForm作为ModelForm
- en: Note that the names of these fields now match those of the model rather than
    the form, as the form just uses the model's fields.
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这些字段的名称现在与模型而不是表单匹配，因为表单只是使用模型的字段。
- en: 'Browse and select an image and file (*Figure 8.25*), then submit the form:![Figure
    8.25: Image and file selected'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览并选择一个图像和文件（*图8.25*），然后提交表单：![图8.25：选择图像和文件
- en: '](img/B15509_08_25.jpg)'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_25.jpg)'
- en: 'Figure 8.25: Image and file selected'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.25：选择图像和文件
- en: 'The page will reload, and as in *Exercise 8.06*, *FileField and ImageField
    on Models*, you will see the previously uploaded image (*Figure 8.26*):![Figure
    8.26: Image being displayed after upload'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面将重新加载，并且与*练习8.06*、*模型上的FileField和ImageField*一样，您将看到之前上传的图像（*图8.26*）：![图8.26：上传后显示的图像
- en: '](img/B15509_08_26.jpg)'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_26.jpg)'
- en: 'Figure 8.26: Image being displayed after upload'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.26：上传后显示的图像
- en: 'Finally, examine the contents of the `media` directory. You should see the
    directory layout matches that of *Exercise 8.06*, *FileField and ImageField on
    Models*, with images inside the `images` directory, and files inside the `files`
    directory:![Figure 8.27: The uploaded files directory matches Exercise 8.06'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查`media`目录的内容。您应该看到目录布局与*练习8.06*、*模型上的FileField和ImageField*相匹配，图像位于`images`目录中，文件位于`files`目录中：![图8.27：上传文件目录与练习8.06匹配
- en: '](img/B15509_08_27.jpg)'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_08_27.jpg)'
- en: 'Figure 8.27: The uploaded files directory matches Exercise 8.06'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27：上传文件目录与练习8.06匹配
- en: In this exercise, we changed `UploadForm` to be a `ModelForm` subclass, which
    allowed us to automatically generate the upload fields. We could replace the code
    that stored the uploaded files on the models with a call to the form's `save`
    method.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将`UploadForm`改为`ModelForm`的子类，这使得我们能够自动生成上传字段。我们可以用对表单的`save`方法的调用替换存储上传文件到模型中的代码。
- en: We have now covered everything you need to start enhancing Bookr with file uploads.
    In the activity for this chapter, we will add support for uploading a cover image
    and sample document (PDF, text file, and more) for a book. The book cover will
    be resized using PIL before it is saved.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了您需要开始通过文件上传来增强Bookr的所有内容。在本章的活动里，我们将添加支持上传封面图片和样本文档（PDF、文本文件等）的功能。在保存之前，书的封面将使用PIL进行缩放。
- en: 'Activity 8.01: Image and PDF Uploads of Books'
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.01：书籍的图像和 PDF 上传
- en: In this activity, you will start by cleaning up (deleting) the example views,
    templates, forms, models, and URL maps that we have used throughout the exercises
    in this chapter. You will then need to generate and apply a migration to delete
    `ExampleModel` from the database.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将首先清理（删除）我们在本章练习中使用的示例视图、模板、表单、模型和 URL 映射。然后你需要生成并应用一个迁移来从数据库中删除 `ExampleModel`。
- en: You can then start adding the Bookr enhancements, first by adding an `ImageField`
    and `FileField` to the `Book` model to store the book `cover` and `sample`. Then
    you will create a migration and apply it to add these fields to the database.
    You can then build a form that will display just these new fields. You will add
    a view that uses this form to save the model instance with the uploaded files,
    after first resizing the image to thumbnail size. You will be able to reuse the
    `instance-form.html` template from *Chapter 7*, *Advanced Form Validation and
    Model Forms*, with a minor change to allow file uploads.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以开始添加 Bookr 增强，首先向 `Book` 模型添加 `ImageField` 和 `FileField` 以存储书籍的 `cover`
    和 `sample`。然后你将创建一个迁移并将其应用到数据库中添加这些字段。然后你可以构建一个表单，它将仅显示这些新字段。你将添加一个视图，使用此表单保存带有上传文件的模型实例，在首先将图像缩放到缩略图大小之后。你可以重用
    *第 7 章*、*高级表单验证和模型表单* 中的 `instance-form.html` 模板，并进行一些小的修改以允许文件上传。
- en: 'These steps will help you complete the activity:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成活动：
- en: Update the Django settings to add the settings `MEDIA_ROOT` and `MEDIA_URL`.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 Django 设置以添加设置 `MEDIA_ROOT` 和 `MEDIA_URL`。
- en: The `/media/` URL mapping should be added to `urls.py`. Use the `static` view
    and utilize `MEDIA_ROOT` and `MEDIA_URL` from Django settings. Remember, this
    mapping should only be added if `DEBUG` is true.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应将 `/media/` URL 映射添加到 `urls.py`。使用 `static` 视图并利用 Django 设置中的 `MEDIA_ROOT`
    和 `MEDIA_URL`。记住，只有当 `DEBUG` 为真时，才应该添加此映射。
- en: Add an `ImageField` (named `cover`) and `FileField` (named `sample`) to the
    `Book` model. The fields should upload to `book_covers/` and `book_samples/`,
    respectively. They should both allow `null` and `blank` values.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Book` 模型添加一个 `ImageField`（命名为 `cover`）和一个 `FileField`（命名为 `sample`）。这些字段应分别上传到
    `book_covers/` 和 `book_samples/`。它们都应该允许 `null` 和 `blank` 值。
- en: Run `makemigrations` and `migrate` again to apply the `Book` model changes to
    the database.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行 `makemigrations` 和 `migrate` 以将 `Book` 模型更改应用到数据库。
- en: Create a `BookMediaForm` as a subclass of `ModelForm`. Its model should be `Book`,
    and the fields should only be the fields you added in *step 3*.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `BookMediaForm` 作为 `ModelForm` 的子类。它的模型应该是 `Book`，字段应该只包含你在 *步骤 3* 中添加的字段。
- en: Add a `book_media` view. This will not allow you to create a `Book`, instead,
    it will only allow you to add media to an existing `Book` (so it must take `pk`
    as a required argument).
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `book_media` 视图。这个视图将不允许你创建 `Book`，而是只允许你向现有的 `Book` 添加媒体（因此它必须接受 `pk`
    作为必选参数）。
- en: The `book_media` view should validate the form, and `save` it, but not `commit`
    the instance. The uploaded cover should first be resized using the `thumbnail`
    method as demonstrated in the *Writing PIL Images to ImageField* section. The
    maximum size should be 300 by 300 pixels. It should then be stored on the instance
    and the instance saved. Remember that the `cover` field is not required so you
    should check this before trying to manipulate the image. On a successful `POST`,
    register a success message that the `Book` was updated, then redirect to the `book_detail`
    view.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`book_media` 视图应该验证表单，并保存它，但不提交实例。上传的封面首先应该使用 *写入 PIL 图像到 ImageField* 部分中演示的
    `thumbnail` 方法进行缩放。最大尺寸应为 300 x 300 像素。然后应该将其存储在实例中，并保存实例。记住，`cover` 字段不是必需的，所以在尝试操作图像之前你应该检查这一点。在成功的
    `POST` 请求后，注册一条成功消息，说明 `Book` 已更新，然后重定向到 `book_detail` 视图。'
- en: Render the `instance-form.html`, passing a context dictionary containing `form`,
    `model_type,` and `instance`, as you did in *Chapter 6*, *Forms*. Also pass another
    item, `is_file_upload`, set to `True`. This variable will be used in the next
    step.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染 `instance-form.html`，传递一个包含 `form`、`model_type` 和 `instance` 的上下文字典，就像你在
    *第 6 章*、*表单* 中做的那样。还要传递另一个项目，`is_file_upload` 设置为 `True`。这个变量将在下一步中使用。
- en: In the `instance-form.html` template, use the `is_file_upload` variable to add
    the correct `enctype` attribute to the form. This will allow you to switch the
    modes for the form to enable file uploads when required.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `instance-form.html` 模板中，使用 `is_file_upload` 变量向表单添加正确的 `enctype` 属性。这将允许你在需要时切换表单模式以启用文件上传。
- en: Finally, add a URL map that maps `/books/<pk>/media/` to the `book_media` view.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you are finished, you should be able to start the Django dev server and
    load the `book_media` view at `http://127.0.0.1:8000/books/<pk>/media/`, for example,
    `http://127.0.0.1:8000/books/2/media/`. You should see the `BookMediaForm` rendered
    in the browser, like in *Figure 8.28*:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28: BookMediaForm in the browser'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_08_28.jpg)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.28: BookMediaForm in the browser'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Select a cover image and sample file for the book. You can use the image at
    [http://packt.live/2KyIapl](http://packt.live/2KyIapl) and PDF at [http://packt.live/37VycHn](http://packt.live/37VycHn)
    (or you can use any other image/PDF of your choosing).
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29: Book Cover image and Sample selected'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_08_29.jpg)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.29: Book Cover image and Sample selected'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'After submitting the form, you will be redirected to the `Book Details` view
    and see the success message (*Figure 8.30*):'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30: Success message on the Book Details page'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_08_30.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.30: Success message on the Book Details page'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go back to the same book''s media page, you should see the fields are
    now filled in, with an option to clear the data from them:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.31: BookMediaForm with existing values'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_08_31.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.31: BookMediaForm with existing values'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Activity 8.02*, *Displaying Cover and Sample Links*, you will add these
    uploaded files to the `Book Details` view, but for now, if you want to check that
    uploads have worked, you can look inside the `media` directory in the Bookr project:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.32: Book media'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_08_32.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.32: Book media'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: You should see the directories that were created and the uploaded files, as
    per *Figure 8.32*. Open an uploaded image, and you should see its maximum dimension
    is 300 pixels.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.02: Displaying Cover and Sample Links'
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will update the `book_detail.html` template to show the
    cover for the `Book` (if one is set). You will also add a link to download the
    sample, again, only if one is set. You will use the `FileField` and `ImageField`
    `url` attributes to generate the URLs to the media files.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Book Details` display in the `book_detail.html` view, add an `<img>`
    element if the book has a `cover` image. Then, display the cover of the book inside
    it. Use `<br>` after the `<img>` tag so the image is on its own line.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `Publication Date` display, add a link to the sample file. It should
    only be displayed if a `sample` file has been uploaded. Make sure you add another
    `<br>` tag so it displays correctly.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the section that has a link to add a review, add another link that goes to
    the media page for the book. Follow the same styling as the `Add Review` link.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you have completed these steps, you should be able to load a book detail
    page. If the book has no `cover` or `sample`, then the page should look very similar
    to what it did before, except you should see the new link to the `Media` page
    at the bottom (*Figure 8.33*):'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这些步骤后，你应该能够加载一个书籍详情页。如果书籍没有`封面`或`样本`，那么页面应该看起来与之前非常相似，除了你应该在底部看到新的`媒体`页面链接（*图8.33*）：
- en: '![Figure 8.33: New Media button visible on the book detail page'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.33：在书籍详情页上可见的新媒体按钮'
- en: '](img/B15509_08_33.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_08_33.jpg)'
- en: 'Figure 8.33: New Media button visible on the book detail page'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.33：在书籍详情页上可见的新媒体按钮
- en: 'Once you have uploaded a `cover` and/or a `sample` for a `Book`, the cover
    image and sample link should be displayed (*Figure 8.34*):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为`Book`上传了`封面`和/或`样本`，封面图像和样本链接应该会显示出来（*图8.34*）：
- en: '![Figure 8.34: Book cover and sample link displayed'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.34：显示的书籍封面和示例链接'
- en: '](img/B15509_08_34.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_08_34.jpg)'
- en: 'Figure 8.34: Book cover and sample link displayed'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34：显示的书籍封面和示例链接
- en: Note
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在[http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ)找到。
- en: Summary
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added the `MEDIA_ROOT` and `MEDIA_URL` settings and a special
    URL map to serve media files. We then created a form and a view to upload files
    and save them to the `media` directory. We saw how to add the media context processor
    to automatically have access to the `MEDIA_URL` setting in all our templates.
    We then enhanced and simplified our form code by using a Django form with a `FileField`
    or `ImageField`, instead of manually defining one in HTML.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们添加了`MEDIA_ROOT`和`MEDIA_URL`设置以及一个特殊的URL映射来服务媒体文件。然后我们创建了一个表单和一个视图来上传文件并将它们保存到`media`目录中。我们看到了如何添加媒体上下文处理器以自动在所有模板中访问`MEDIA_URL`设置。然后，我们通过使用带有`FileField`或`ImageField`的Django表单来增强和简化我们的表单代码，而不是在HTML中手动定义一个。
- en: We looked at some of the enhancements Django provides for images with the `ImageField`,
    and how to interact with an image using Pillow. We showed an example view that
    would be able to serve files that required authentication, using the `FileResponse`
    class. Then, we saw how to store files on models using the `FileField` and `ImageField`
    and refer to them in a template using the `FileField.url` attribute. We were able
    to reduce the amount of code we had to write by automatically building a `ModelForm`
    from a `model` instance. Finally, in the two activities at the end, we enhanced
    Bookr by adding a cover image and sample file to the `Book` model. In *Chapter
    9*, *Sessions and Authentication*, we will learn how to add authentication to
    a Django application to protect it from unauthorized users.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了Django为`ImageField`提供的图像增强功能，以及如何使用Pillow与图像交互。我们展示了一个示例视图，该视图能够使用`FileResponse`类提供需要认证的文件。然后，我们看到了如何使用`FileField`和`ImageField`在模型上存储文件，并在模板中使用`FileField.url`属性引用它们。我们通过自动从`model`实例构建`ModelForm`来减少必须编写的代码量。最后，在最后的两个活动中，我们通过向`Book`模型添加封面图像和示例文件来增强Bookr。在*第9章*，*会话和认证*中，我们将学习如何向Django应用程序添加认证以保护它免受未经授权的用户。
