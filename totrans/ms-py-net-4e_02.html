<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer033">
    <h1 class="chapterNumber">2</h1>
    <h1 class="chapterTitle" id="_idParaDest-48">Low-Level Network Device Interactions</h1>
    <p class="normal">In <em class="chapterRef">Ch</em><em class="chapterRef">apter 1</em>, <em class="italic">Review of TCP/IP Protocol Suite and Python</em>, we looked at the theories and specifications behind network communication protocols. We also took a quick tour of the Python language. In this chapter, we will start to dive deeper into the management of network devices using Python. In particular, we will examine the different ways in which we can use Python to programmatically communicate with legacy network routers and switches.</p>
    <p class="normal">What do I mean by legacy network routers and switches? While it’s hard to imagine any networking device coming <a id="_idIndexMarker108"/>out today without an <strong class="keyWord">application programming interface</strong> (<strong class="keyWord">API</strong>) for programmatic communication, it is a known fact that many of the network devices deployed in previous years did not contain API interfaces. The intended method of management <a id="_idIndexMarker109"/>for those devices was through <strong class="keyWord">command-line interfaces</strong> (<strong class="keyWord">CLIs</strong>) using terminal programs, which were originally developed with a human engineer in mind. The management relied on the engineer’s interpretation of the data returned from the device for appropriate action. As one can imagine, as the number of network devices and the complexity of the network grew, it became increasingly difficult to manually manage them one by one.</p>
    <p class="normal">Python has several great libraries and frameworks that can help with these tasks, such as Pexpect, Paramiko, Netmiko, NAPALM, and Nornir, amongst others. It is worth noting that there are several overlaps between these libraries in terms of code, dependencies, and the maintainers of the projects. For example, the Netmiko library was created by Kirk Byers in 2014 based on the Paramiko SSH library. Carl Montanari created the Scrapli library to take advantage of the latest Python 3 asyncio concurrency features. In recent years, Kirk, Carl, David Barroso from the NAPALM project, and others teamed up to create the awesome Nornir framework to provide a pure Python network automation framework.</p>
    <p class="normal">For the most part, the libraries are flexible enough to be used together or separately. For example, Ansible (covered in <em class="chapterRef">Chapter 4</em>, <em class="italic">The Python Automation Framework – Ansible</em>) uses both Paramiko and Ansible-NAPALM as the underlying libraries for its network modules. </p>
    <p class="normal">With so many libraries in existence today, it’s not possible to cover all of them in a reasonable number of pages. In this chapter, we will cover Pexpect first, then move on with examples from Paramiko. Once we understand the basics and operations of Paramiko, it is easy to branch out to other libraries, such as Netmiko and NAPALM. In this chapter, we will take a look at the following topics:</p>
    <ul>
      <li class="bulletList">The challenges of the CLI</li>
      <li class="bulletList">Constructing a virtual lab</li>
      <li class="bulletList">The Python Pexpect library</li>
      <li class="bulletList">The Python Paramiko library</li>
      <li class="bulletList">Examples from other libraries</li>
      <li class="bulletList">The downsides of Pexpect and Paramiko</li>
    </ul>
    <p class="normal">We have briefly discussed the shortfalls of managing network devices via the command-line interface. It has proven to be ineffective in network management with even moderate-sized networks. This chapter will introduce Python libraries that can work with that limitation. First, let us discuss some of the challenges with the CLI in more detail.</p>
    <h1 class="heading-1" id="_idParaDest-49">The challenges of the CLI</h1>
    <p class="normal">I started my IT career at an ISP help desk back in the early 2000s. I remember watching the network engineers typing in what seemed like cryptic commands into a text terminal. Like magic, the network devices would <a id="_idIndexMarker110"/>then bend to their will and behave in the way they intended. In time, I got to learn and embrace these magic commands that I could type into the terminal. As network engineers, these CLI-based commands are like secret codes we share with each other in this world we call network engineering. Manually typing in the command was just something we all had to do to get the job done, no harm, no foul. </p>
    <p class="normal">However, it was right around the year 2014 when we started to see the industry coming to a consensus about the clear need to move away from manual, human-driven CLIs toward an automatic, computer-centric automation API. Make no mistake, we still need to directly communicate with the device when making network designs, bringing up an initial proof of concept, and deploying the topology for the first time. However, once the network is deployed, the network management requirement is now to consistently make the same changes reliably across all network devices. </p>
    <p class="normal">These changes need to be error-free, and the engineers need to repeat the steps without being distracted or feeling tired. This requirement sounds like an ideal job for computers and our favorite programming language, Python.</p>
    <p class="normal">Of course, if the network devices can only be managed with the command line, the main challenge becomes how we can replicate the previous manual interactions between the router and the administrator automatically with a computer program. In the command line, the router will output a series of <a id="_idIndexMarker111"/>information and will expect the administrator to enter a series of manual commands based on the engineer’s interpretation of the output. For example, in a Cisco <strong class="keyWord">Internetwork Operating System</strong> (<strong class="keyWord">IOS</strong>) device, you have to type in <em class="italic">enable</em> to get into a privileged mode, and upon receiving the returned prompt with the <code class="inlineCode">#</code> sign, you then type in <code class="inlineCode">configure terminal</code> in order to go into the configuration mode. The same process can further be expanded into the interface configuration mode and routing protocol configuration mode. This is in sharp contrast to a computer-driven, programmatic mindset. When the computer wants to accomplish a single task, say, put an IP address on an interface, it wants to structurally give all the information to the router at once, and it would expect a single <em class="italic">yes</em> or <em class="italic">no</em> answer from the router to indicate the success or failure of the task.</p>
    <p class="normal">The solution, as implemented by both Pexpect and Paramiko, is to treat the interactive process as a child process and watch over the interaction between the child process and the destination device. Based on the returned value, the parent process will decide the subsequent action, if any.</p>
    <p class="normal">I am sure we are all anxious to get started on using the Python libraries, but first, we will need to construct our network lab in order to have a network to test our code against. We will begin by looking at different ways we can build our network labs.</p>
    <h1 class="heading-1" id="_idParaDest-50">Constructing a Virtual lab</h1>
    <p class="normal">Before we dive into the Python libraries and frameworks, let’s examine the options of putting together <a id="_idIndexMarker112"/>a lab for the benefit of learning. As the old saying goes, “practice makes perfect” – we need an isolated sandbox to safely make mistakes, try out new ways of doing things, and repeat some of the steps to reinforce concepts that were not clear on the first try. </p>
    <p class="normal">To put together a network lab, we basically have two options: physical devices or virtual devices. Let’s look at the advantages and disadvantages of the respective options.</p>
    <h2 class="heading-2" id="_idParaDest-51">Physical devices</h2>
    <p class="normal">This option <a id="_idIndexMarker113"/>consists of putting together a lab with physical network <a id="_idIndexMarker114"/>devices that you can see and touch. If you are lucky enough, you might even be able to construct a lab that is an exact replication of your production environment. The advantages and disadvantages of a physical lab are as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Advantages</strong>: It is <a id="_idIndexMarker115"/>an easy transition from lab to production. The topology is easier to understand for managers and fellow engineers who can look at and work on the devices if need be. The comfort level with physical devices is extremely high because of familiarity.</li>
      <li class="bulletList"><strong class="keyWord">Disadvantages</strong>: It is <a id="_idIndexMarker116"/>relatively expensive to pay for devices that will only be used in a lab. Also, physical devices require engineering hours to rack and stack and are not very flexible once constructed.</li>
    </ul>
    <h2 class="heading-2" id="_idParaDest-52">Virtual devices</h2>
    <p class="normal">Virtual devices <a id="_idIndexMarker117"/>are emulations or simulations of actual network devices. They are either <a id="_idIndexMarker118"/>provided by the vendors or by the open source community. The advantages and disadvantages of virtual devices are as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Advantages</strong>: Virtual <a id="_idIndexMarker119"/>devices are easier to set up, relatively cheap, and can make changes to the topology quickly.</li>
      <li class="bulletList"><strong class="keyWord">Disadvantages</strong>: They <a id="_idIndexMarker120"/>are usually scaled-down versions of their physical counterparts. Sometimes there are feature gaps between the virtual and the physical device.</li>
    </ul>
    <p class="normal">Of course, deciding on a virtual or physical lab is a personal decision derived from a trade-off between the cost, ease of implementation, and the risk of having a gap between lab and production environments. In some of the places I have worked, the virtual lab was used when doing an initial proof-of-concept, while the physical lab was used when we moved closer to the final design.</p>
    <p class="normal">In my opinion, as more and more vendors decide to produce virtual appliances, the virtual lab is the way to proceed in a learning environment. The feature gap of the virtual appliance is relatively small and specifically documented, especially when the virtual instance is provided by the vendor. The cost of the virtual appliance is relatively small compared to buying physical devices. The time to build using virtual devices is much shorter because they are just software programs.</p>
    <p class="normal">For this book, I will use a combination of physical and virtual devices for concept demonstration, with a preference for virtual devices. For the examples we will see, the differences should be transparent. If there are any known differences between the virtual and physical devices pertaining to our objectives, I will make sure to list them.</p>
    <p class="normal">For the code <a id="_idIndexMarker121"/>examples in the book, I will try to make the network topology as simple as <a id="_idIndexMarker122"/>possible while still being able to demonstrate the concept at hand. Each virtual network usually consists of not more than a few nodes, and we will reuse the same virtual network for multiple labs if possible.</p>
    <p class="normal">For the <a id="_idIndexMarker123"/>examples in this book, I will utilize Cisco Modeling Labs, <a href="https://www.cisco.com/c/en/us/products/cloud-systems-management/modeling-labs/index.html"><span class="url">https://www.cisco.com/c/en/us/products/cloud-systems-management/modeling-labs/index.html</span></a>, as well as other virtual platforms, such as Arista vEOS. As we will see in the next section, Cisco provides <a id="_idIndexMarker124"/>CML in both a paid version and a free, hosted version on Cisco DevNet (<a href="https://developer.cisco.com/site/devnet/"><span class="url">https://developer.cisco.com/site/devnet/</span></a>) based on availability. The use of CML is optional. You can use any lab devices you have, but it might make it easier to follow along with the book examples. Also worth noting is that Cisco has strict software license requirements for device images, so by purchasing or using the free hosted CML, you will be less likely to violate their software license requirements. </p>
    <h2 class="heading-2" id="_idParaDest-53">Cisco modeling labs</h2>
    <p class="normal">I remember <a id="_idIndexMarker125"/>when I first started to study for my <strong class="keyWord">Cisco Certified Internetwork Expert</strong> (<strong class="keyWord">CCIE</strong>) lab exam, I purchased some used Cisco equipment from eBay to study with. Even <a id="_idIndexMarker126"/>with a used equipment discount, each router and switch still cost hundreds of US dollars. To save money, I purchased some really outdated Cisco routers from the 1980s (search for Cisco AGS routers in your favorite search engine for a good chuckle), which significantly lacked features and horsepower, even for lab standards. As much as it made for an interesting conversation with family members when I turned them on (they were really loud), putting the physical devices together was not fun. They were heavy and clunky, and it was a pain to connect all the cables, and to introduce link failure, I would literally have to unplug a cable.</p>
    <p class="normal">Fast-forward a few years. Dynamips was created, and I fell in love with how easy it was to create different <a id="_idIndexMarker127"/>network scenarios. This was especially important when trying to learn a new concept. All I needed was the IOS images from Cisco and a few carefully constructed topology files, and I could easily build a virtual network to test my knowledge on. I had a whole folder of network topologies, pre-saved configurations, and different versions of images, as called for by different scenarios. The addition of a GNS3 frontend gave the whole setup a beautiful GUI facelift. With GNS3, you can just click and drop your links and devices; you can even print out the network topology for your manager or client right out of the GNS3 design panel. The only disadvantage of GNS3 was the tool not being officially blessed by Cisco, and the perceived lack of credibility because of it.</p>
    <p class="normal">In 2015, the Cisco <a id="_idIndexMarker128"/>community decided to fulfill this need by releasing the Cisco <strong class="keyWord">Virtual Internet Routing Lab</strong> (<strong class="keyWord">VIRL</strong>), <a href="https://learningnetwork.cisco.com/s/virl"><span class="url">https://learningnetwork.cisco.com/s/virl</span></a>. This quickly became my go-to tool as the network lab when developing, learning, and practicing network automation code. </p>
    <p class="normal">A few years after the introduction of VIRL, Cisco released <strong class="keyWord">Cisco Modeling Labs</strong> (<strong class="keyWord">CML</strong>), <a href="https://developer.cisco.com/modeling-labs/"><span class="url">https://developer.cisco.com/modeling-labs/</span></a>. It is a great network simulation platform with an easy-to-use HTML UI and a comprehensive API. </p>
    <p class="normal">At the time <a id="_idIndexMarker129"/>of writing, the single-user license for CML is 199 USD (keep in mind that there is a free, hosted version on Cisco DevNet). In my opinion, the CML platform offers <a id="_idIndexMarker130"/>a few advantages over other alternatives and the cost is a bargain:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Ease of use</strong>: As mentioned, all the images for IOSv, IOS-XRv, NX-OSv, ASAv, and other images are included in a single download.</li>
      <li class="bulletList"><strong class="keyWord">Official</strong>: CML is a widely used tool internally at Cisco and within the network engineering community. In fact, CML is used extensively for the new Cisco DevNet Expert Lab exam. Because of its popularity, bugs get fixed quickly, new features are carefully documented, and useful knowledge is widely shared among its users.</li>
      <li class="bulletList"><strong class="keyWord">Third-party KVM images integration</strong>: CML permits users to upload third-party VM images, such as Windows VM, that are not bundled by default.</li>
      <li class="bulletList"><strong class="keyWord">Others</strong>: The CML tool offers many other features, such as dashboard list view, multiuser grouping, Ansible integration, and pyATS integration.</li>
    </ul>
    <p class="normal">We will not use all of the CML features in this book, but it is nice to know the tool is so feature-rich and is constantly being updated. Again, I want to stress the importance of having a lab to follow along for the book examples but it does not need to be Cisco CML. The code examples provided in this book should work across any lab device, as long as it runs the same software type and version.</p>
    <h3 class="heading-3" id="_idParaDest-54">CML tips</h3>
    <p class="normal">The CML <a id="_idIndexMarker131"/>website (<a href="https://developer.cisco.com/modeling-labs/"><span class="url">https://developer.cisco.com/modeling-labs/</span></a>) and documentation (<a href="https://developer.cisco.com/docs/modeling-labs/"><span class="url">https://developer.cisco.com/docs/modeling-labs/</span></a>) offer lots of guidance and information, from installation to usage. The lab topology will be included in the respective chapters in the book’s GitHub repository (<a href="https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition"><span class="url">https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition</span></a>). The lab images can be directly imported to the lab via the <strong class="screenText">Import</strong> button: </p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_02_01.png"/></figure>
    <p class="packt_figref">Figure 2.1: CML Console Image Lab Image</p>
    <p class="normal">For the labs, each of the devices will have its management interface connected to an unmanaged switch, which in turn connects to an external connection for access: </p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_02_02.png"/></figure>
    <p class="packt_figref">Figure 2.2: Unmanaged Switch for Management Interface Access</p>
    <p class="normal">You will need to change the IP address of the management interface to fit your own lab’s schema. For example, in the <code class="inlineCode">2_DC_Topology.yaml</code> file in <em class="chapterRef">Chapter 2</em>, the IP address of <code class="inlineCode">lax-edg-r1 GigabitEthernet0/0 0</code> is <code class="inlineCode">192.168.2.51</code>. You will need to change this IP address according to your own lab. </p>
    <p class="normal">If you are <a id="_idIndexMarker132"/>using virtual lab software other than CML, you can open the topology file with any text editor (such as Sublime Text, shown below) and see each of the devices’ configurations. You can then copy and paste the configuration into your own lab devices: </p>
    <figure class="mediaobject"><img alt="Text  Description automatically generated" src="../Images/B18403_02_03.png"/></figure>
    <p class="packt_figref">Figure 2.3: Topology File Viewed with Text Editor</p>
    <p class="normal">We talked about Cisco DevNet briefly earlier in this section. Let us explore more about DevNet in the next section. </p>
    <h2 class="heading-2" id="_idParaDest-55">Cisco DevNet</h2>
    <p class="normal">Cisco DevNet (<a href="https://developer.cisco.com/site/devnet/"><span class="url">https://developer.cisco.com/site/devnet/</span></a>) is the premier, all-in-one website when it <a id="_idIndexMarker133"/>comes to network automation resources at Cisco. It is free to sign up and provides <a id="_idIndexMarker134"/>free remote labs, free video courses, guided learning tracks, documentation, and much more. </p>
    <p class="normal">The Cisco <a id="_idIndexMarker135"/>DevNet Sandbox (<a href="https://developer.cisco.com/site/sandbox/"><span class="url">https://developer.cisco.com/site/sandbox/</span></a>) is a great alternative if you do not already have a lab at your own disposal or want to try out new technologies. Some of the labs are always on, while others you need to reserve. The lab availability will depend on usage. </p>
    <figure class="mediaobject"><img alt="Graphical user interface, website  Description automatically generated" src="../Images/B18403_02_04.png"/></figure>
    <figure class="mediaobject">Figure 2.4: Cisco DevNet Sandbox</figure>
    <div class="note">
      <p class="normal">Since its inception, Cisco DevNet has become the de facto destination for all things related to network programmability and automation at Cisco. If you are interested in pursuing Cisco certifications in automation, DevNet offers different tracks from associate to expert level of validation; more information can be found at <a href="https://developer.cisco.com/certification/"><span class="url">https://developer.cisco.com/certification/</span></a>.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-56">GNS3 and others</h2>
    <p class="normal">There <a id="_idIndexMarker136"/>are a few other <a id="_idIndexMarker137"/>virtual labs that I have used and would recommend. GNS3 is one of them:</p>
    <figure class="mediaobject"><img alt="Graphical user interface, website  Description automatically generated" src="../Images/B18403_02_05.png"/></figure>
    <p class="packt_figref">Figure 2.5: GNS3 Website</p>
    <p class="normal">As mentioned <a id="_idIndexMarker138"/>previously, GNS3 is what a lot of us use to study for certification tests and to practice for labs. The tool has really grown up from the early days of being the simple frontend for <a id="_idIndexMarker139"/>Dynamips into a viable commercial product. GNS3 is vendor-neutral, which can be helpful if we want to build a multi-vendor lab. This is typically done either by making a clone of the image (such as Arista vEOS) or by directly launching the network device image via other hypervisors (such as KVM).</p>
    <p class="normal">Another <a id="_idIndexMarker140"/>multi-vendor network emulation environment that has gotten a lot of great reviews is the <strong class="keyWord">Emulated Virtual Environment Next Generation</strong> (<strong class="keyWord">Eve-NG</strong>): <a href="http://www.eve-ng.net/"><span class="url">http://www.eve-ng.net/</span></a>. I personally do not have enough experience with the tool, but many of my colleagues and friends in the industry use it for their network labs. If you are <a id="_idIndexMarker141"/>familiar with containers, containerlab (<a href="https://containerlab.dev/"><span class="url">https://containerlab.dev/</span></a>) can also be an alternative for you. </p>
    <p class="normal">There are <a id="_idIndexMarker142"/>also other standalone virtualized platforms, such as Arista <a id="_idIndexMarker143"/>vEOS (<a href="https://www.arista.com/en/cg-veos-router/veos-router-overview"><span class="url">https://www.arista.com/en/cg-veos-router/veos-router-overview</span></a>), Juniper vMX (<a href="https://www.juniper.net/us/en/products/routers/mx-series/vmx-virtual-router-software.html"><span class="url">https://www.juniper.net/us/en/products/routers/mx-series/vmx-virtual-router-software.html</span></a>), and Nokia <a id="_idIndexMarker144"/>SR-Linux (<a href="https://www.nokia.com/networks/data-center/service-router-linux-NOS/"><span class="url">https://www.nokia.com/networks/data-center/service-router-linux-NOS/</span></a>), which you can use as standalone virtual appliances during testing. </p>
    <p class="normal">They are great complementary tools for testing platform-specific features. Many of them are offered as paid products on public cloud provider marketplaces for easier access.</p>
    <p class="normal">Now that we have built our network lab, we can start to experiment with Python libraries that can help with management and automation. We will begin with enabling the Python virtual environment. Then we will install and use the Pexpect library for some examples.</p>
    <h1 class="heading-1" id="_idParaDest-57">Python virtual environment</h1>
    <p class="normal">Let us start by using the Python virtual environment. The Python virtual environment allows us to manage <a id="_idIndexMarker145"/>separate package installations for different projects by creating a “virtual” isolated Python installation and installing packages into that virtual installation. By using a virtual environment, we do not need to worry about breaking the packages installed globally or from other virtual environments. We will start by installing the <code class="inlineCode">python3.10-venv</code> package, then create the virtual environment itself:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo apt update
<span class="hljs-con-meta">$ </span>sudo apt install python3.10-venv
<span class="hljs-con-meta">$ </span>python3 -m venv venv 
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">source</span> venv/bin/activate
(venv) $
(venv) $ deactivate
</code></pre>
    <p class="normal">From the output, we saw that we use the <code class="inlineCode">venv</code> module from our installation, create a virtual environment called “venv” and then activate it. While the virtual environment is activated, you will see the (<code class="inlineCode">venv</code>) label in front of your hostname, indicating that you are in that virtual environment. When finished, you can use the <code class="inlineCode">deactivate</code> command to exit the virtual environment. If interested, you can <a id="_idIndexMarker146"/>learn more about Python virtual environments here: <a href="https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#installing-virtualenv"><span class="url">https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/#installing-virtualenv</span></a>.</p>
    <div class="packt_tip">
      <p class="normal">Always activate the virtual environment before you work on the code to isolate environments.</p>
    </div>
    <p class="normal">Once we have activated the virtual environment, we can move on to install the Pexpect library.</p>
    <h1 class="heading-1" id="_idParaDest-58">Python pexpect library</h1>
    <p class="normal">Pexpect is <a id="_idIndexMarker147"/>a pure Python module for spawning child applications, controlling them, and responding to expected patterns in their output. Pexpect works like Don Libes’ <code class="inlineCode">Expect</code>. Pexpect allows our script to spawn a child application and control it as if a human were typing <a id="_idIndexMarker148"/>commands; more information can be found on Pexpect’s documentation page: <a href="https://pexpect.readthedocs.io/en/stable/index.html"><span class="url">https://pexpect.readthedocs.io/en/stable/index.html</span></a>.</p>
    <div class="packt_tip">
      <p class="normal">Nowadays, we typically use libraries, such as Nornir, that abstract this line-by-line, low-level interaction. However, it is still useful to understand the interaction at least at a high level. If you are the impatient kind, just skim through the following Pexpect and Paramiko sections.</p>
    </div>
    <p class="normal">Similar to <a id="_idIndexMarker149"/>the original <strong class="keyWord">Tool Command Language</strong> (<strong class="keyWord">TCL</strong>) <code class="inlineCode">Expect</code> module by Don Libes, Pexpect launches, or spawns, another process and watches over it in order to control the interaction. The Expect tool was originally developed to automate interactive processes such as FTP, Telnet, and rlogin, and was later expanded to include network automation. Unlike the original Expect, Pexpect is entirely written in Python, which does not require TCL or C extensions to be compiled. This allows us to use the familiar Python syntax and its rich standard library in our code.</p>
    <h2 class="heading-2" id="_idParaDest-59">Pexpect installation</h2>
    <p class="normal">The Pexpect <a id="_idIndexMarker150"/>installation process is straightforward:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ pip install pexpect
</code></pre>
    <p class="normal">Let’s do a quick test to make sure the package is usable; make sure we start the Python interactive shell from the virtual environment:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ python
Python 3.10.4 (main, Jun 29 2022, 12:14:53) [GCC 11.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pexpect
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">dir</span>(pexpect)
['EOF', 'ExceptionPexpect', 'Expecter', 'PY3', 'TIMEOUT', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__revision__', '__spec__', '__version__', 'exceptions', 'expect', 'is_executable_file', 'pty_spawn', 'run', 'runu', 'searcher_re', 'searcher_string', 'spawn', 'spawnbase',
 'spawnu', 'split_command_line', 'sys', 'utils', 'which']
    &gt;&gt;&gt; exit()
</code></pre>
    <h2 class="heading-2" id="_idParaDest-60">Pexpect overview</h2>
    <p class="normal">For this <a id="_idIndexMarker151"/>chapter, we will use the <code class="inlineCode">2_DC_Topology</code> and work on the two IOSv devices, <strong class="screenText">lax-edg-r1</strong> and <strong class="screenText">lax-edg-r2</strong>:</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B18403_02_06.png"/></figure>
    <p class="packt_figref">Figure 2.6: lax-edg-r1 and lax-edg-r2</p>
    <p class="normal">The devices will each have a management address in the <code class="inlineCode">192.16.2.x/24</code> range. In the example, <code class="inlineCode">lax-edg-r1</code> will have <code class="inlineCode">192.168.2.51</code> and <code class="inlineCode">lax-edg-r2</code> will have <code class="inlineCode">192.168.2.52</code> as the management IP. If this is the first time the device is powered up, it will need to generate an RSA key for SSH: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">lax-edg-r2(config)#</span>crypto key generate rsa
</code></pre>
    <p class="normal">For older IOSv software images, we might also need to add the following lines to the <code class="inlineCode">ssh</code> configuration <code class="inlineCode">(~/.ssh/config)</code> depending on your platform: </p>
    <pre class="programlisting con"><code class="hljs-con">Host 192.168.2.51
  HostKeyAlgorithms +ssh-rsa
  KexAlgorithms +diffie-hellman-group-exchange-sha1
Host 192.168.2.52
  HostKeyAlgorithms +ssh-rsa
  KexAlgorithms +diffie-hellman-group-exchange-sha1
</code></pre>
    <p class="normal">With the devices ready, let’s take a look at how you would interact with the router if you were to telnet into the device:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ $ telnet 192.168.2.51
Trying 192.168.2.51...
Connected to 192.168.2.51.
Escape character is '^]'.
&lt;skip&gt;
User Access Verification
Username: cisco
Password:
</code></pre>
    <p class="normal">The device <a id="_idIndexMarker152"/>configuration uses the username of <code class="inlineCode">cisco</code>, and the password is also <code class="inlineCode">cisco</code>. Notice that the user is already in the privileged mode because of the privilege assigned in the configuration:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">lax-edg-r1#</span>sh run | i cisco
enable password cisco
username cisco privilege 15 secret 5 $1$SXY7$Hk6z8OmtloIzFpyw6as2G.
 password cisco
 password cisco
</code></pre>
    <p class="normal">The auto-config also generated <code class="inlineCode">vty</code> access for both telnet and SSH:</p>
    <pre class="programlisting con"><code class="hljs-con">line con 0
 password cisco
line aux 0
line vty 0 4
 exec-timeout 720 0
 password cisco
 login local
 transport input telnet ssh
</code></pre>
    <p class="normal">Let’s see a Pexpect example using the Python interactive shell:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pexpect
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child = pexpect.spawn(<span class="hljs-con-string">'telnet 192.168.2.51'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'Username'</span>)
0
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.sendline(<span class="hljs-con-string">'cisco'</span>)
6
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'Password'</span>)
0
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.sendline(<span class="hljs-con-string">'cisco'</span>)
6
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'lax-edg-r1#'</span>)
0
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.sendline(<span class="hljs-con-string">'show version | i V'</span>)
19
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.before
b": \r\n************************************************************************\r\n* IOSv is strictly limited to use for evaluation, demonstration and IOS  *\r\n* education. IOSv is provided as-is and is not supported by Cisco's      *\r\n* Technical Advisory Center. Any use or disclosure, in whole or in part, *\r\n* of the IOSv Software or Documentation to any third party for any       *\r\n* purposes is expressly prohibited except as otherwise authorized by     *\r\n* Cisco in writing.                                                      *\r\n***********************************************************************\r\n"
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.sendline(<span class="hljs-con-string">'exit'</span>)
5
<span class="hljs-con-meta">&gt;&gt;&gt;</span> exit()
</code></pre>
    <div class="note">
      <p class="normal">Starting from Pexpect version 4.0, you can run Pexpect on the Windows platform. But, as noted in the Pexpect documentation, running Pexpect on Windows should be considered experimental for now.</p>
    </div>
    <p class="normal">In the previous <a id="_idIndexMarker153"/>interactive example, Pexpect spawns off a child process and watches over it in an interactive fashion. There are two important methods shown in the example, <code class="inlineCode">expect()</code> and <code class="inlineCode">sendline()</code>. The <code class="inlineCode">expect()</code> line indicates the string in the Pexpect process looks for when the returned string is considered done. This is the expected pattern. In our example, we knew the router had sent us all the information when the hostname prompt (<code class="inlineCode">lax-edg-r1#) </code>was returned. The <code class="inlineCode">sendline()</code> method indicates which words should be sent to the remote device as the command. There is also a method called <code class="inlineCode">send()</code>, but <code class="inlineCode">sendline()</code> includes a linefeed, which is similar to pressing the <em class="keystroke">Enter</em> key at the end of the words you sent in the previous telnet session. From the router’s perspective, it is just as if someone typed in the text from a Terminal. In other words, we are tricking the routers into thinking they are interfacing with a human being when they are actually communicating with a computer.</p>
    <p class="normal">The <code class="inlineCode">before</code> and <code class="inlineCode">after</code> properties will be set to the text printed by the child application. The <code class="inlineCode">before</code> properties will be set to the text printed by the child application up to the expected pattern. The <code class="inlineCode">after</code> string will contain the text that was matched by the expected pattern. In our case, the <code class="inlineCode">before</code> text will be set to the output between the two expected matches (<code class="inlineCode">lax-edg-r1#</code>), including the <code class="inlineCode">show version</code> command. The <code class="inlineCode">after</code> text is the router hostname prompt:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> child.sendline(<span class="hljs-con-string">'show version | i V'</span>)
19
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'lax-edg-r1#'</span>)
0
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.before
b'show version | i V\r\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.6(3)M2, RELEASE SOFTWARE (fc2)\r\nProcessor board ID 9Y0KJ2ZL98EQQVUED5T2Q\r\n'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.after
b'iosv-1#'
</code></pre>
    <p class="normal">If you are wondering about the <code class="inlineCode">b'</code> in front of the return, it is a Python byte string (<a href="https://docs.python.org/3.10/library/stdtypes.html"><span class="url">https://docs.python.org/3.10/library/stdtypes.html</span></a>).</p>
    <p class="normal">What would happen if you expected the wrong term? For example, if we typed in <code class="inlineCode">username</code> with the lowercase “u” instead of <code class="inlineCode">Username</code> after spawning the child application, the Pexpect process would look for a string of <code class="inlineCode">username</code> from the child process. In that case, the Pexpect process would just hang because the word <code class="inlineCode">username</code> would never be returned by the router. The session would eventually time out, or we could manually exit out via <em class="keystroke">Ctrl</em> +<em class="keystroke"> C</em>.</p>
    <p class="normal">The <code class="inlineCode">expect()</code> method waits for the child application to return a given string, so in the previous example, if you wanted to accommodate both lowercase and uppercase <code class="inlineCode">u</code>, you could use the following term:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'[Uu]sername'</span>)
</code></pre>
    <p class="normal">The square <a id="_idIndexMarker154"/>bracket serves as an <code class="inlineCode">or</code> operation that tells the child application to expect a lowercase or uppercase “u” followed by <code class="inlineCode">sername</code> as the string. What we are telling the process is that we will accept either <code class="inlineCode">Username</code> or <code class="inlineCode">username</code> as the expected string. For more information on these different types of matching using a regular expression, go to: <a href="https://docs.python.org/3.10/library/re.html"><span class="url">https://docs.python.org/3.10/library/re.html</span></a>. </p>
    <p class="normal">The <code class="inlineCode">expect()</code> method can also contain a list of options instead of just a single string; these options can also be regular expressions themselves. Going back to the previous example, we can use the following list of options to accommodate the two different possible strings:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect([<span class="hljs-con-string">'Username'</span>, <span class="hljs-con-string">'username'</span>])
</code></pre>
    <p class="normal">Generally speaking, use the regular expression for a single <code class="inlineCode">expect</code> string when we can fit the different letters in a regular expression, whereas use the possible options if we need to catch completely different responses from the device, such as a password rejection. For example, if we use several different passwords for our login, we want to catch <code class="inlineCode">% Login invalid</code> as well as the device prompt.</p>
    <p class="normal">One important difference between Pexpect regular expressions and Python regular expressions is that Pexpect matching is non-greedy, which means they will match as little as possible when using special characters. Because Pexpect performs regular expressions on a stream, it cannot look ahead, as the child process generating the stream may not be finished. This means the special dollar sign character <code class="inlineCode">$</code> typically matching the end of the line is useless because <code class="inlineCode">.+</code> will always return no characters, and the <code class="inlineCode">.*</code> pattern will match as little as possible. In general, just keep this in mind and be as specific as you can be on the <code class="inlineCode">expect</code> match strings.</p>
    <p class="normal">Let’s consider the following scenario:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> child.sendline(<span class="hljs-con-string">'show run | i hostname'</span>)
22
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'lax-edg-r1'</span>)
0
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.before
b'show version | i V\r\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.6(3)M2, RELEASE SOFTWARE (fc2)\r\nProcessor board ID 9Y0KJ2ZL98EQQVUED5T2Q\r\n'
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">Hmm... Something is not quite right here. Compare it to the Terminal output before; the output you expect would be <code class="inlineCode">hostname lax-edg-r1</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">iosv-1#</span>sh run | i hostname
hostname lax-edg-r1
</code></pre>
    <p class="normal">Taking a closer look at the expected string will reveal the mistake. In this case, we were missing the hash (<code class="inlineCode">#</code>) sign behind the <code class="inlineCode">lax-edg-r1</code> hostname. Therefore, the child application treated the second part of the return string as the expected string:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> child.sendline(<span class="hljs-con-string">'show run | i hostname'</span>)
22
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'lax-edg-r1#'</span>)
0
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.before
b'#show run | i hostname\r\nhostname lax-edg-r1\r\n'
</code></pre>
    <p class="normal">You can see <a id="_idIndexMarker155"/>a pattern emerging from the usage of Pexpect after a few examples. The user maps out the sequence of interactions between the Pexpect process and the child application. With some Python variables and loops, we can start to construct a useful program that will help us gather information and make changes to network devices.</p>
    <h2 class="heading-2" id="_idParaDest-61">Our first Pexpect program</h2>
    <p class="normal">Our first <a id="_idIndexMarker156"/>program, <code class="inlineCode">chapter2_1.py</code>, extends what we did in the last section with some additional code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-keyword">import</span> pexpect
devices = {<span class="hljs-string">'iosv-1'</span>: {<span class="hljs-string">'prompt'</span>: <span class="hljs-string">'lax-edg-r1#'</span>, <span class="hljs-string">'ip'</span>: <span class="hljs-string">'192.168.2.51'</span>},
           <span class="hljs-string">'</span><span class="hljs-string">iosv-2'</span>: {<span class="hljs-string">'prompt'</span>: <span class="hljs-string">'lax-edg-r2#'</span>, <span class="hljs-string">'ip'</span>: <span class="hljs-string">'192.168.2.52'</span>}}
username = <span class="hljs-string">'cisco'</span>
password = <span class="hljs-string">'cisco'</span>
<span class="hljs-keyword">for</span> device <span class="hljs-keyword">in</span> devices<span class="hljs-selector-class">.keys</span>():
    device_prompt = devices<span class="hljs-selector-attr">[device][</span><span class="hljs-string">'prompt'</span><span class="hljs-selector-attr">]</span>
    child = pexpect<span class="hljs-selector-class">.spawn</span>(<span class="hljs-string">'telnet '</span> + devices<span class="hljs-selector-attr">[device][</span><span class="hljs-string">'ip'</span><span class="hljs-selector-attr">]</span>)
    child<span class="hljs-selector-class">.expect</span>(<span class="hljs-string">'Username:'</span>)
    child<span class="hljs-selector-class">.sendline</span>(username)
    child<span class="hljs-selector-class">.expect</span>(<span class="hljs-string">'</span><span class="hljs-string">Password:'</span>)
    child<span class="hljs-selector-class">.sendline</span>(password)
    child<span class="hljs-selector-class">.expect</span>(device_prompt)
    child<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">'show version | i V'</span>)
    child<span class="hljs-selector-class">.expect</span>(device_prompt)
    <span class="hljs-built_in">print</span>(child.before)
    child<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">'exit'</span>)
</code></pre>
    <p class="normal">We used a nested dictionary in line 5:</p>
    <pre class="programlisting code"><code class="hljs-code">devices = {<span class="hljs-string">'</span><span class="hljs-string">iosv-1'</span>: {<span class="hljs-string">'prompt'</span>: <span class="hljs-string">'lax-edg-r1#'</span>, <span class="hljs-string">'ip'</span>: <span class="hljs-string">'192.168.2.51'</span>},
           <span class="hljs-string">'iosv-2'</span>: {<span class="hljs-string">'prompt'</span>: <span class="hljs-string">'lax-edg-r2#'</span>, <span class="hljs-string">'ip'</span>: <span class="hljs-string">'192.168.2.52'</span>}}
</code></pre>
    <p class="normal">The nested dictionary allows us to refer to the same device (such as <code class="inlineCode">lax-edg-r1</code>) with the appropriate IP address and prompt symbol. We can then use those values for the <code class="inlineCode">expect()</code> method later on in the loop.</p>
    <p class="normal">The output prints out the <code class="inlineCode">show version | i V</code> output on the screen for each of the devices:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python chapter2_1.py 
b'show version | i V\r\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\r\nProcessor board ID 98U40DKV403INHIULHYHB\r\n'
b'show version | i V\r\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\r\n'
</code></pre>
    <p class="normal">Now that <a id="_idIndexMarker157"/>we have seen a basic example of Pexpect, let us go deeper into more features of the library.</p>
    <h2 class="heading-2" id="_idParaDest-62">More Pexpect Features</h2>
    <p class="normal">In this section, we will look at more Pexpect features that might come in handy when certain situations arise.</p>
    <p class="normal">If you <a id="_idIndexMarker158"/>have a slow or fast link to your remote device, the default <code class="inlineCode">expect()</code> method timeout is 30 seconds, which can be increased or decreased via the <code class="inlineCode">timeout</code> argument:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'</span><span class="hljs-con-string">Username'</span>, timeout=<span class="hljs-con-number">5</span>)
</code></pre>
    <p class="normal">You can choose to pass the command back to the user using the <code class="inlineCode">interact()</code> method. This is useful when you just want to automate certain parts of the initial task:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> child.sendline(<span class="hljs-con-string">'show version | i V'</span>)
19
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'lax-edg-r1#'</span>)
0
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.before
b'show version | i V\r\nCisco IOS Software, IOSv Software (VIOS-
-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\r\nProcessor board ID 98U40DKV403INHIULHYHB\r\n'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.interact()
show version | i V
Cisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)
Processor board ID 98U40DKV403INHIULHYHB
lax-edg-r1#exit
Connection closed by foreign host.
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">You can get a lot of information about the <code class="inlineCode">child.spawn</code> object by printing it out in string format:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">str</span>(child)
"&lt;pexpect.pty_spawn.spawn object at 0x7f068a9bf370&gt;\ncommand: /usr/bin/telnet\nargs: ['/usr/bin/telnet', '192.168.2.51']\nbuffer (last 100 chars): b''\nbefore (last 100 chars): b'TERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\\r\\nProcessor board ID 98U40DKV403INHIULHYHB\\r\\n'\nafter: b'lax-edg-r1#'\nmatch: &lt;re.Match object; span=(165, 176), match=b'lax-edg-r1#'&gt;\nmatch_index: 0\nexitstatus: 1\nflag_eof: False\npid: 25510\nchild_fd: 5\nclosed: False\ntimeout: 30\ndelimiter: &lt;class 'pexpect.exceptions.EOF'&gt;\nlogfile: None\nlogfile_read: None\nlogfile_send: None\nmaxread: 2000\nignorecase: False\nsearchwindowsize: None\ndelaybeforesend: 0.05\ndelayafterclose: 0.1\ndelayafterterminate: 0.1"
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">The most useful debug tool for Pexpect is to log the output in a file:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> child = pexpect.spawn(<span class="hljs-con-string">'telnet 192.168.2.51'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.logfile = <span class="hljs-con-built_in">open</span>(<span class="hljs-con-string">'debug'</span>, <span class="hljs-con-string">'wb'</span>)
</code></pre>
    <p class="normal">For more information on Pexpect features, check out: <a href="https://pexpect.readthedocs.io/en/stable/api/index.html"><span class="url">https://pexpect.readthedocs.io/en/stable/api/index.html</span></a></p>
    <p class="normal">We have <a id="_idIndexMarker159"/>been working with Telnet so far in our examples, which leaves our communication in clear text during the session. In modern networks, we typically use <strong class="keyWord">secure shell</strong> (<strong class="keyWord">SSH</strong>) for <a id="_idIndexMarker160"/>management. In the next section, we will take a look at Pexpect with SSH.</p>
    <h2 class="heading-2" id="_idParaDest-63">Pexpect and SSH</h2>
    <p class="normal">Pexpect has a <a id="_idIndexMarker161"/>subclass called <code class="inlineCode">pxssh</code>, which specializes in setting up SSH connections. The class adds methods for login, logout, and various tricky things to handle the different <a id="_idIndexMarker162"/>situations in the <code class="inlineCode">ssh</code> login process. The procedures are mostly the same, with the exception of <code class="inlineCode">login()</code> and <code class="inlineCode">logout()</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> pexpect <span class="hljs-con-keyword">import</span> pxssh
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child = pxssh.pxssh()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.login(<span class="hljs-con-string">'192.168.2.51'</span>, <span class="hljs-con-string">'cisco'</span>, <span class="hljs-con-string">'cisco'</span>, auto_prompt_reset=<span class="hljs-con-literal">False</span>) 
True
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.sendline(<span class="hljs-con-string">'</span><span class="hljs-con-string">show version | i V'</span>)
19
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.expect(<span class="hljs-con-string">'lax-edg-r1#'</span>)
0
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.before
b'show version | i V\r\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\r\nProcessor board ID 98U40DKV403INHIULHYHB\r\n'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> child.logout()
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">Notice the <code class="inlineCode">auto_prompt_reset=False</code> argument in the <code class="inlineCode">login()</code> method. By default, <code class="inlineCode">pxssh</code> uses the shell prompt to synchronize the output. But since it uses the PS1 option for most of bash-shell or c-shell, they will error out on Cisco or other network devices.</p>
    <h2 class="heading-2" id="_idParaDest-64">Pexpect complete example</h2>
    <p class="normal">As the final step, let’s put everything you have learned so far about Pexpect into a script. Putting code into <a id="_idIndexMarker163"/>a script makes it easier to use in a production environment, as well as easier to share with your colleagues. We will write our second script, <code class="inlineCode">chapter2_2.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-keyword">import</span> getpass
<span class="hljs-keyword">from</span> pexpect <span class="hljs-keyword">import</span> pxssh
devices = {<span class="hljs-string">'lax-edg-r1'</span>: {<span class="hljs-string">'</span><span class="hljs-string">prompt'</span>: <span class="hljs-string">'lax-edg-r1#'</span>, <span class="hljs-string">'ip'</span>: <span class="hljs-string">'192.168.2.51'</span>},
           <span class="hljs-string">'lax-edg-r2'</span>: {<span class="hljs-string">'prompt'</span>: <span class="hljs-string">'lax-edg-r2#'</span>, <span class="hljs-string">'ip'</span>: <span class="hljs-string">'192.168.2.52'</span>}}
commands = [<span class="hljs-string">'term length 0'</span>, <span class="hljs-string">'</span><span class="hljs-string">show version'</span>, <span class="hljs-string">'show run'</span>]
username = <span class="hljs-built_in">input</span>(<span class="hljs-string">'Username: '</span>)
password = getpass.getpass(<span class="hljs-string">'Password: '</span>)
<span class="hljs-comment"># Starts the loop for devices</span>
<span class="hljs-keyword">for</span> device <span class="hljs-keyword">in</span> devices.keys():
    outputFileName = device + <span class="hljs-string">'_output.txt'</span>
    device_prompt = devices[device][<span class="hljs-string">'prompt'</span>]
    child = pxssh.pxssh()
    child.login(devices[device][<span class="hljs-string">'</span><span class="hljs-string">ip'</span>], username.strip(), password.strip(), auto_prompt_reset=<span class="hljs-literal">False</span>)
    <span class="hljs-comment"># Starts the loop for commands and write to output</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(outputFileName, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> command <span class="hljs-keyword">in</span> commands:
            child.sendline(command)
            child.expect(device_prompt)
            f.write(child.before)
    child.logout()
</code></pre>
    <p class="normal">The script <a id="_idIndexMarker164"/>further expands from our first Pexpect program with the following additional features:</p>
    <ul>
      <li class="bulletList">It uses SSH instead of Telnet.</li>
      <li class="bulletList">It supports multiple commands instead of just one by making the commands into a list (line 8) and loops through the commands (starting at line 20).</li>
      <li class="bulletList">It prompts the user for their username and password instead of hardcoding them in the script for better security posture. </li>
      <li class="bulletList">It writes the output in two files, <code class="inlineCode">lax-edg-r1_output.txt</code> and <code class="inlineCode">lax-edg-r2_output.txt</code>.</li>
    </ul>
    <p class="normal">After the code is executed, we should see the two output files in the same directory. Besides Pexpect, Paramiko is another popular Python library used to handle interactive sessions. </p>
    <h1 class="heading-1" id="_idParaDest-65">The Python Paramiko library</h1>
    <p class="normal">Paramiko is a Python implementation of the SSHv2 protocol. Just like the <code class="inlineCode">pxssh</code> subclass of Pexpect, Paramiko <a id="_idIndexMarker165"/>simplifies the SSHv2 interaction between the host and the remote device. Unlike <code class="inlineCode">pxssh</code>, Paramiko focuses only on SSHv2 with no Telnet support. It also provides both client and server operations.</p>
    <p class="normal">Paramiko is the low-level SSH client behind the high-level automation framework Ansible for its network modules. We will cover Ansible in <em class="chapterRef">Chapter 4</em>, <em class="italic">The Python Automation Framework – Ansible</em>. Let’s take a look at the Paramiko library.</p>
    <h2 class="heading-2" id="_idParaDest-66">Installation of Paramiko</h2>
    <p class="normal">Installing Paramiko is pretty straightforward with Python <code class="inlineCode">pip</code>. However, there is a hard dependency on the <a id="_idIndexMarker166"/>cryptography library. The library provides low-level, C-based encryption algorithms for the SSH protocol.</p>
    <p class="normal">The installation instruction for Windows, macOS, and other flavors of Linux can be found at: <a href="https://cryptography.io/en/latest/installation/"><span class="url">https://cryptography.io/en/latest/installation/</span></a>.</p>
    <p class="normal">We will show the Paramiko installation steps for our Ubuntu 22.04 virtual machine:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo apt-get install build-essential libssl-dev libffi-dev python3-dev 
pip install cryptography
pip install paramiko
</code></pre>
    <p class="normal">Let us <a id="_idIndexMarker167"/>test the library’s usage by importing it with the Python interpreter:</p>
    <pre class="programlisting con"><code class="hljs-con">$ python
Python 3.10.4 (main, Jun 29 2022, 12:14:53) [GCC 11.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> paramiko
<span class="hljs-con-meta">&gt;&gt;&gt;</span> exit()
</code></pre>
    <p class="normal">Now we are ready to take a look at Paramiko in the next section.</p>
    <h2 class="heading-2" id="_idParaDest-67">Paramiko overview</h2>
    <p class="normal">Let’s look <a id="_idIndexMarker168"/>at a quick Paramiko example using the Python 3 interactive shell:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> paramiko, time
<span class="hljs-con-meta">&gt;&gt;&gt;</span> connection = paramiko.SSHClient()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> connection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
<span class="hljs-con-meta">&gt;&gt;&gt;</span> connection.connect(<span class="hljs-con-string">'192.168.2.51'</span>, username=<span class="hljs-con-string">'cisco'</span>, password=<span class="hljs-con-string">'cisco'</span>, look_for_keys=<span class="hljs-con-literal">False</span>, allow_agent=<span class="hljs-con-literal">False</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> new_connection = connection.invoke_shell()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> output = new_connection.recv(<span class="hljs-con-number">5000</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(output) <span class="hljs-con-string">b"\r\n*************************************************************************\</span>
<span class="hljs-con-string">r\n* IOSv is strictly limited to use for evaluation, demonstration and IOS  *\r\n* education. IOSv is provided as-is and is not supported by Cisco's      *\r\n* Technical Advisory Center. Any use or disclosure, in whole or in part, *\r\n* of the IOSv Software or Documentation to any third party for any       *\r\n* purposes is expressly prohibited except as otherwise authorized by     *\r\n* Cisco in writing.                                                      *\r\n***********************************************************************\r\nlax-edg-r1#"</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> new_connection.send(<span class="hljs-con-string">"show version | i V\n"</span>)
19
<span class="hljs-con-meta">&gt;&gt;&gt;</span> time.sleep(<span class="hljs-con-number">3</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> output = new_connection.recv(<span class="hljs-con-number">5000</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(output)
b'show version | i V\r\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\r\nProcessor board ID 98U40DKV403INHIULHYHB\r\nlax-edg-r1#'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> new_connection.close()
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">time.sleep()</code> function inserts a time delay to ensure all the outputs were captured. This is particularly useful on a slower network connection or a busy device. This command is not required but is recommended depending on your situation.</p>
    <p class="normal">Even if we are seeing the Paramiko operation for the first time, the beauty of Python and its clear syntax means that we can make a pretty good educated guess at what the program is trying to do:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> paramiko
<span class="hljs-con-meta">&gt;&gt;&gt;</span> connection = paramiko.SSHClient()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> connection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
<span class="hljs-con-meta">&gt;&gt;&gt;</span> connection.connect(<span class="hljs-con-string">'192.168.2.51'</span>, username=<span class="hljs-con-string">'cisco'</span>, password=<span class="hljs-con-string">'cisco'</span>,
look_for_keys=False, allow_agent=False)
</code></pre>
    <p class="normal">The first four lines create an instance of the <code class="inlineCode">SSHClient</code> class from Paramiko. The next line sets the policy that the client should use regarding keys; in this case, <code class="inlineCode">lax-edg-r1</code> might not be in either the system host keys or the application’s keys. In our scenario, we will automatically add the key to the application’s <code class="inlineCode">HostKeys</code> object. At this point, if you log on to the router, you will see all the login sessions from Paramiko.</p>
    <p class="normal">The next few lines invoke a new interactive shell from the connection and a repeatable pattern of sending a command and retrieving the output. Finally, we close the connection.</p>
    <p class="normal">Some readers <a id="_idIndexMarker169"/>who have used Paramiko before might be familiar with the <code class="inlineCode">exec_command()</code> method instead of invoking a shell. Why do we need to invoke an interactive shell instead of using <code class="inlineCode">exec_command()</code> directly? Unfortunately, <code class="inlineCode">exec_command()</code> on Cisco IOS only allows a single command. Consider the following example with <code class="inlineCode">exec_command()</code> for the connection:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> connection.connect(<span class="hljs-con-string">'192.168.2.51'</span>, username=<span class="hljs-con-string">'cisco'</span>, password=<span class="hljs-con-string">'cisco'</span>, look_for_keys=<span class="hljs-con-literal">False</span>, allow_agent=<span class="hljs-con-literal">False</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> stdin, stdout, stderr = connection.exec_command(<span class="hljs-con-string">'show version | i V\n'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> stdout.read()
b'Cisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)rnProcessor board ID 98U40DKV403INHIULHYHBrn'
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">Everything works great; however, if you look at the number of sessions on the Cisco device, you will notice that the connection is dropped by the Cisco device without you closing the connection. Because the SSH session is no longer active, <code class="inlineCode">exec_command()</code> will return an error if you want to send more commands to the remote device:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> stdin, stdout, stderr = connection.exec_command(<span class="hljs-con-string">'show version | i V\n'</span>) 
Traceback (most recent call last):
&lt;skip&gt;
raise SSHException('SSH session not active') paramiko.ssh_exception.SSHException: SSH session not active
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">In the previous example, the <code class="inlineCode">new_connection.recv()</code> command displayed what was in the buffer and implicitly cleared it out for us. What would happen if you did not clear out the received buffer? The output would just keep on filling up the buffer and would overwrite it:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> new_connection.send(<span class="hljs-con-string">"show version | i V\n"</span>)
 19
<span class="hljs-con-meta">&gt;&gt;&gt;</span> new_connection.send(<span class="hljs-con-string">"show version | i V\n"</span>) 
19
<span class="hljs-con-meta">&gt;&gt;&gt;</span> new_connection.send(<span class="hljs-con-string">"show version | i V\n"</span>) 
19
<span class="hljs-con-meta">&gt;&gt;&gt;</span> new_connection.recv(<span class="hljs-con-number">5000</span>)
b'show version | i VrnCisco IOS Software, IOSv Software (VIOS- ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)rnProcessor
board ID 98U40DKV403INHIULHYHBrnlax-edg-r1#show version | i VrnCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)rnProcessor board ID 98U40DKV403INHIULHYHBrnlax-edg-r1#show version | i VrnCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)rnProcessor board ID 98U40DKV403INHIULHYHBrnlax-edg-r1#'
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">For consistency of the deterministic output, we will retrieve the output from the buffer each time we execute a command.</p>
    <h2 class="heading-2" id="_idParaDest-68">First Paramiko program</h2>
    <p class="normal">Our first program will use the same general structure as the Pexpect program we have put together. We will loop <a id="_idIndexMarker170"/>over a list of devices and commands while using Paramiko instead of Pexpect. This will give us a good compare and contrast of the differences between Paramiko and Pexpect.</p>
    <p class="normal">If you have not done so already, you can download the code, <code class="inlineCode">chapter2_3.py</code>, from the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition"><span class="url">https://github.com/PacktPublishing/Mastering-Python-Networking-Fourth-Edition</span></a>. I will list the notable differences here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute">devices</span> = {<span class="hljs-string">'lax-edg-r1'</span>: {<span class="hljs-string">'ip'</span>: <span class="hljs-string">'192.168.2.51'</span>},
           <span class="hljs-string">'lax-edg-r2'</span>: {<span class="hljs-string">'ip'</span>: <span class="hljs-string">'192.168.2.52'</span>}}
</code></pre>
    <p class="normal">We no longer need to match the device prompt using Paramiko; therefore, the device dictionary can be simplified:</p>
    <pre class="programlisting code"><code class="hljs-code">commands = [<span class="hljs-string">'show version'</span>, <span class="hljs-string">'show run'</span>]
</code></pre>
    <p class="normal">There is no sendline equivalent in Paramiko; instead, we manually include the newline break in each of the commands:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">clear_buffer</span>(<span class="hljs-params">connection</span>):
    <span class="hljs-keyword">if</span> connection.recv_ready():
        <span class="hljs-keyword">return</span> connection.recv(max_buffer)
</code></pre>
    <p class="normal">We include a new method to clear the buffer for sending commands, such as <code class="inlineCode">terminal length 0</code> or <code class="inlineCode">enable</code>, because we do not need the output for those commands. We simply want to clear the buffer and get to the execution prompt. This function will later be used in the loop, such as in line 25 of the script:</p>
    <pre class="programlisting code"><code class="hljs-code">output = clear_buffer(new_connection)
</code></pre>
    <p class="normal">The rest of the program should be pretty self-explanatory, similar to what we have seen in this chapter. The last thing I would like to point out is that since this is an interactive program, we place a buffer and wait for the command to be finished on the remote device before retrieving the output:</p>
    <pre class="programlisting code"><code class="hljs-code">time.sleep(<span class="hljs-number">5</span>)
</code></pre>
    <p class="normal">After we clear the buffer, we will wait five seconds between the execution of commands. This will give the device adequate time to respond if it is busy.</p>
    <h2 class="heading-2" id="_idParaDest-69">More Paramiko features</h2>
    <p class="normal">We will <a id="_idIndexMarker171"/>look at Paramiko a bit later in <em class="chapterRef">Chapter 4</em>, <em class="italic">The Python Automation Framework – Ansible</em><em class="chapterRef">,</em> when we discuss Ansible, as Paramiko is the underlying transport for many of the network modules. In this section, we will take a look at some of the other features of Paramiko.</p>
    <h3 class="heading-3" id="_idParaDest-70">Paramiko for servers</h3>
    <p class="normal">Paramiko can be used to manage servers through SSHv2 as well. Let’s look at an example of how we can use <a id="_idIndexMarker172"/>Paramiko to manage servers. We will use key-based authentication for the SSHv2 session.</p>
    <p class="normal">In this example, I used another Ubuntu virtual machine on the same hypervisor as the destination server. You can also use a server on the CML simulator or an instance in one of the public cloud providers, such as Amazon AWS EC2.</p>
    <p class="normal">We will generate a public-private key pair for our Paramiko host:</p>
    <pre class="programlisting con"><code class="hljs-con">ssh-keygen -t rsa
</code></pre>
    <p class="normal">This command, by default, will generate a public key named <code class="inlineCode">id_rsa.pub</code>, as the public key under the user home directory <code class="inlineCode">~/.ssh</code> along with a private key named <code class="inlineCode">id_rsa</code>. Treat the private key with the same attention as you would for private passwords that you do not want to share with anybody else. </p>
    <p class="normal">You can think of the public key as a business card that identifies who you are. Using the private and public keys, the message will be encrypted by your private key locally and decrypted by the remote host using the public key. We should copy the public key to the remote host. In production, we can do this via out-of-band using a USB drive; in our lab, we can simply copy the public key to the remote host’s <code class="inlineCode">~/.ssh/authorized_keys</code> file. Open up a Terminal window for the remote server so you can paste in the public key.</p>
    <p class="normal">Copy the content of <code class="inlineCode">~/.ssh/id_rsa.pub</code> on your management host with Paramiko:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> ~/.ssh/id_rsa.pub 
ssh-rsa &lt;your public key&gt;
</code></pre>
    <p class="normal">Then, paste it to the remote host under the <code class="inlineCode">user</code> directory; in this case, I am using <code class="inlineCode">echou</code> for both sides:</p>
    <pre class="programlisting con"><code class="hljs-con">&lt;Remote Host&gt;$ vim ~/.ssh/authorized_keys
ssh-rsa &lt;your public key&gt;
</code></pre>
    <p class="normal">You are now ready to use Paramiko to manage the remote host. Notice in this example that we will use the private key for authentication as well as the <code class="inlineCode">exec_command()</code> method for sending commands:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> paramiko
<span class="hljs-con-meta">&gt;&gt;&gt;</span> key = paramiko.RSAKey.from_private_key_file(<span class="hljs-con-string">'/home/echou/.ssh/id_rsa'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> client = paramiko.SSHClient()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
<span class="hljs-con-meta">&gt;&gt;&gt;</span> client.connect(<span class="hljs-con-string">'192.168.199.182'</span>, username=<span class="hljs-con-string">'echou'</span>, pkey=key)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> stdin, stdout, stderr = client.exec_command(<span class="hljs-con-string">'ls -l'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> stdout.read()
b'total 44ndrwxr-xr-x 2 echou echou 4096 Jan 7 10:14 Desktopndrwxr-xr-x 2
echou echou 4096 Jan 7 10:14 Documentsndrwxr-xr-x 2 echou echou 4096 Jan 7
10:14 Downloadsn-rw-r--r-- 1 echou echou 8980 Jan 7 10:03
examples.desktopndrwxr-xr-x 2 echou echou 4096 Jan 7 10:14 Musicndrwxr-xr-x
echou echou 4096 Jan 7 10:14 Picturesndrwxr-xr-x 2 echou echou 4096 Jan 7 10:14 Publicndrwxr-xr-x 2 echou echou 4096 Jan 7 10:14 Templatesndrwxr-xr-x
2 echou echou 4096 Jan 7 10:14 Videosn'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> stdin, stdout, stderr = client.exec_command(<span class="hljs-con-string">'pwd'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> stdout.read()
b'/home/echou'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> client.close()
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">Notice that <a id="_idIndexMarker173"/>in the server example, we do not need to create an interactive session to execute multiple commands. You can now turn off password-based authentication in your remote host’s SSHv2 configuration for more secure key-based authentication with automation enabled. </p>
    <p class="normal">Why do we want to know about using private keys as authentication methods? More and more network devices, such as Cumulus and Vyatta switches, are moving toward using Linux shell and public-private key authentication as a security mechanism. For some operations, we will use a combination of SSH session and key-based authentication for authentication. </p>
    <h2 class="heading-2" id="_idParaDest-71">More Paramiko examples</h2>
    <p class="normal">In this section, let’s make the Paramiko program more reusable. There is one downside of our existing script: we need to open up the script every time we want to add or delete a host, or whenever we need to change the commands we want to execute on the remote host.</p>
    <p class="normal">This is due <a id="_idIndexMarker174"/>to the fact that both the host and command information are statically entered inside the script. Hardcoding the host and command has a higher chance of making mistakes when making a change. By making both the host and command files read in as parameters for the script, we can make the script more flexible. Users (and future us) can simply modify these text files when you need to make host or command changes.</p>
    <p class="normal">We have incorporated the change in the script named <code class="inlineCode">chapter2_4.py</code>.</p>
    <p class="normal">Instead of hardcoding the commands, we broke the commands into a separate <code class="inlineCode">commands.txt</code> file. Up to this point, we have been using <code class="inlineCode">show</code> commands; in this example, we will make configuration changes. In particular, we will change the logging buffer size to <code class="inlineCode">30000</code> bytes:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> commands.txt 
config t
logging buffered 30000 
end
copy run start
</code></pre>
    <p class="normal">The device’s information is written into a <code class="inlineCode">devices.json</code> file. We chose JSON format for the device’s information because JSON data types can be easily translated into Python dictionary data types: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> devices.json 
{
    "lax-edg-r1": {
        "ip": "192.168.2.51"
    },
    "lax-edg-r2": {
        "ip": "192.168.2.52"
    }
}
</code></pre>
    <p class="normal">In the script, we made the following changes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'devices.json'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
    devices = json.load(f)
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'commands.txt'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
    commands = f.readlines()
</code></pre>
    <p class="normal">Here is an abbreviated output from the script execution:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python chapter2_4.py 
Username: cisco
Password: 
b'terminal length 0\r\nlax-edg-r1#config t\r\nEnter configuration commands, one per line.  End with CNTL/Z.\r\nlax-edg-r1(config)#'
b'logging buffered 30000\r\nlax-edg-r1(config)#'
b'end\r\nlax-edg-r1#'
b'copy run start'
&lt;skip&gt;
</code></pre>
    <p class="normal">Do a quick <a id="_idIndexMarker175"/>check to make sure the change has taken place in both <code class="inlineCode">running-config</code> and <code class="inlineCode">startup-config</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">lax-edg-r1#</span>sh run | i logging
logging buffered 30000
</code></pre>
    <p class="normal">The Paramiko library is a general-purpose library intended for working with interactive command-line programs. For network management, there is another library, Netmiko, a fork from Paramiko, that is purpose-built for network device management. We will take a look at it in the upcoming section.</p>
    <h1 class="heading-1" id="_idParaDest-72">The Netmiko library</h1>
    <p class="normal">Paramiko is a great library to do low-level interactions with Cisco IOS and other vendor devices. But as you have <a id="_idIndexMarker176"/>noticed from previous examples, we are repeating many of the same steps between <code class="inlineCode">lax-edg-r1</code> and <code class="inlineCode">lax-edg-r2</code> for device login and execution. Once we start to develop more automation commands, we also start to repeat ourselves in capturing terminal outputs and formatting them into a usable format. Wouldn’t it be great if somebody could write a Python library that simplifies these low-level steps and share it with other network engineers?</p>
    <p class="normal">Ever since 2014, Kirk Byers (<a href="https://github.com/ktbyers"><span class="url">https://github.com/ktbyers</span></a>) has been working on open-source initiatives to simplify the management of network devices. In this section, we will take a look at an example of the Netmiko (<a href="https://github.com/ktbyers/netmiko"><span class="url">https://github.com/ktbyers/netmiko</span></a>) library that he created.</p>
    <p class="normal">First, we will install the <code class="inlineCode">netmiko</code> library using <code class="inlineCode">pip</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ pip install netmiko
</code></pre>
    <p class="normal">We can use the example published on Kirk’s website, <a href="https://pynet.twb-tech.com/blog/automation/netmiko.html"><span class="url">https://pynet.twb-tech.com/blog/automation/netmiko.html</span></a>, and apply it to our labs. We will start by importing the library and its <code class="inlineCode">ConnectHandler</code> class. Then we will define our <code class="inlineCode">device</code> parameter as a Python dictionary and pass it to the <code class="inlineCode">ConnectHandler</code>. Notice that we are defining a <code class="inlineCode">device_type</code> of <code class="inlineCode">cisco_ios</code> in the <code class="inlineCode">device</code> parameter:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> netmiko <span class="hljs-con-keyword">import</span> ConnectHandler
<span class="hljs-con-meta">&gt;&gt;&gt;</span> net_connect = ConnectHandler(
<span class="hljs-con-meta">...</span>     device_type=<span class="hljs-con-string">"cisco_ios"</span>,
<span class="hljs-con-meta">...</span>     host=<span class="hljs-con-string">"192.168.2.51"</span>,
<span class="hljs-con-meta">...</span>     username=<span class="hljs-con-string">"cisco"</span>,
<span class="hljs-con-meta">...</span>     password=<span class="hljs-con-string">"cisco"</span>,
<span class="hljs-con-meta">...</span> )
</code></pre>
    <p class="normal">This is where the simplification begins. Notice that the library automatically determines the device prompt as well as formatting the returned output from the <code class="inlineCode">show</code> command:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> net_connect.find_prompt()
'lax-edg-r1#'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> output = net_connect.send_command(<span class="hljs-con-string">'show ip int brief'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(output)
Interface                  IP-Address      OK? Method Status                Protocol
GigabitEthernet0/0         192.168.2.51    YES NVRAM  up                    up      
GigabitEthernet0/1         10.0.0.1        YES NVRAM  up                    up      
Loopback0                  192.168.0.10    YES NVRAM  up                    up    
</code></pre>
    <p class="normal">Let’s see <a id="_idIndexMarker177"/>another example for the second Cisco IOS device in our lab and send a <code class="inlineCode">configuration</code> command instead of a <code class="inlineCode">show</code> command. Note that the <code class="inlineCode">command</code> attribute is a list that can contain multiple commands:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> net_connect_2 = ConnectHandler(
<span class="hljs-con-meta">...</span>     device_type=<span class="hljs-con-string">"cisco_ios"</span>,
<span class="hljs-con-meta">...</span>     host=<span class="hljs-con-string">"192.168.2.52"</span>,
<span class="hljs-con-meta">...</span>     username=<span class="hljs-con-string">"cisco"</span>,
<span class="hljs-con-meta">...</span>     password=<span class="hljs-con-string">"cisco"</span>,
<span class="hljs-con-meta">...</span> )
<span class="hljs-con-meta">&gt;&gt;&gt;</span> output = net_connect_2.send_config_set([<span class="hljs-con-string">'logging buffered 19999'</span>])
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(output)
configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
lax-edg-r2(config)#logging buffered 19999
lax-edg-r2(config)#end
lax-edg-r2#
<span class="hljs-con-meta">&gt;&gt;&gt;</span> exit()
</code></pre>
    <p class="normal">How cool is that? Netmiko automatically took care of the nitty-gritty stuff for us, allowing us to focus on the commands themselves. The <code class="inlineCode">netmiko</code> library is a great time saver and is used by many network engineers. In the next section, we will take a look at the Nornir (<a href="https://github.com/nornir-automation/nornir"><span class="url">https://github.com/nornir-automation/nornir</span></a>) framework, which also aims to simplify low-level interactions.</p>
    <h1 class="heading-1" id="_idParaDest-73">The Nornir framework</h1>
    <p class="normal">Nornir (<a href="https://nornir.readthedocs.io/en/latest/"><span class="url">https://nornir.readthedocs.io/en/latest/</span></a>) is a pure Python automation framework intended <a id="_idIndexMarker178"/>to be used directly from Python. We will start with installing <code class="inlineCode">nornir</code> in our environment:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">(venv)$ </span>pip install nornir nornir_utils nornir_netmiko
</code></pre>
    <p class="normal">Nornir expects <a id="_idIndexMarker179"/>us to define an inventory file, <code class="inlineCode">hosts.yaml</code>, consisting of the device information in a YAML format. The information specified in this file is no different than what we have previously defined using the Python dictionary in the Netmiko example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-attr">lax-edg-r1:</span>
    <span class="hljs-attr">hostname:</span> <span class="hljs-string">'192.168.2.51'</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">22</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">'</span><span class="hljs-string">cisco'</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">'cisco'</span>
    <span class="hljs-attr">platform:</span> <span class="hljs-string">'cisco_ios'</span>
<span class="hljs-attr">lax-edg-r2:</span>
    <span class="hljs-attr">hostname:</span> <span class="hljs-string">'192.168.2.52'</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">22</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">'cisco'</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">'cisco'</span>
    <span class="hljs-attr">platform:</span> <span class="hljs-string">'cisco_ios'</span>
</code></pre>
    <p class="normal">We can <a id="_idIndexMarker180"/>use the <code class="inlineCode">netmiko</code> plugin from the <code class="inlineCode">nornir</code> library to interact with our device, as illustrated in the <code class="inlineCode">chapter2_5.py</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#!/usr/bin/env python</span>
<span class="hljs-keyword">from</span> nornir <span class="hljs-keyword">import</span> InitNornir
<span class="hljs-keyword">from</span> nornir_utils.plugins.functions <span class="hljs-keyword">import</span> print_result
<span class="hljs-keyword">from</span> nornir_netmiko <span class="hljs-keyword">import</span> netmiko_send_command
nr = InitNornir()
result = nr.run(
    task=netmiko_send_command,
    command_string=<span class="hljs-string">"show arp"</span>
)
print_result(result)
</code></pre>
    <p class="normal">The execution output is shown as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ python chapter2_5.py 
netmiko_send_command************************************************************
* lax-edg-r1 ** changed : False ************************************************
vvvv netmiko_send_command ** changed : False vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv INFO
Protocol  Address          Age (min)  Hardware Addr   Type   Interface
Internet  10.0.0.1                -   5254.001e.e911  ARPA   GigabitEthernet0/1
Internet  10.0.0.2               17   fa16.3e00.0001  ARPA   GigabitEthernet0/1
^^^^ END netmiko_send_command ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
* lax-edg-r2 ** changed : False ************************************************
vvvv netmiko_send_command ** changed : False vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv INFO
Protocol  Address          Age (min)  Hardware Addr   Type   Interface
Internet  10.0.128.1             17   fa16.3e00.0002  ARPA   GigabitEthernet0/1
Internet  10.0.128.2              -   5254.0014.e052  ARPA   GigabitEthernet0/1
^^^^ END netmiko_send_command ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
    <div class="packt_tip">
      <p class="normal">There are other plugins in Nornir besides Netmiko, such as the popular NAPALM library (<a href="https://github.com/napalm-automation/napalm"><span class="url">https://github.com/napalm-automation/napalm</span></a>). Please feel free to check out Nornir’s project page for the latest plugins: <a href="https://nornir.readthedocs.io/en/latest/plugins/index.html"><span class="url">https://nornir.readthedocs.io/en/latest/plugins/index.html</span></a>.</p>
    </div>
    <p class="normal">We have taken a pretty huge leap forward in this chapter in automating our network using Python. However, some of the methods we have used feel like workarounds for automation. We attempted to trick the <a id="_idIndexMarker181"/>remote devices into thinking they were interacting with a human on the other end. Even if we use libraries such as Netmiko or the Nornir framework, the underlying approach remains the same. Just because somebody else has done the work to help abstract the grunt work of the low-level interaction, we are still susceptible to the downsides of dealing with CLI-only devices.</p>
    <p class="normal">Looking ahead, let us discuss some of the downsides of Pexpect and Paramiko compared to other tools in preparation for our discussion on API-driven methods in the next chapters.</p>
    <h2 class="heading-2" id="_idParaDest-74">Downsides of Pexpect and Paramiko compared to other tools</h2>
    <p class="normal">The biggest downside of our current method for automating CLI-only devices is that the remote devices do <a id="_idIndexMarker182"/>not return structured data. They return data that is <a id="_idIndexMarker183"/>ideal for fitting on a terminal to be interpreted by a human, not by a computer program. The human eye can easily interpret a space, while a computer only sees a return character.</p>
    <p class="normal">We will take a look at a better way in the upcoming chapter. As a prelude to <em class="chapterRef">Chapter 3</em>, <em class="italic">APIs and Intent-Driven Networking</em><em class="chapterRef">,</em> let’s discuss the idea of idempotency.</p>
    <h3 class="heading-3" id="_idParaDest-75">Idempotent network device interaction</h3>
    <p class="normal">The term <em class="italic">idempotency</em> has different meanings, depending on its context. But in this book’s context, the <a id="_idIndexMarker184"/>term means that when a client makes the same call to a remote device, the result should always be the same. I believe we can all agree that this is necessary. Imagine a scenario where each time you execute the same script, you get a different result back. I find that scenario very scary. How can you trust your script if that is the case? It would render our automation effort useless because we need to be prepared to handle different returns.</p>
    <p class="normal">Since Pexpect and Paramiko are blasting out a series of commands interactively, the chance of having a non-idempotent interaction is higher. Going back to the fact that the return results needed to be screen scraped for useful elements, the risk of difference is much higher. Something on the remote end might have changed between the time we wrote the script and the time when the script is executed for the 100th time. For example, if the vendor makes a screen output change between releases without us updating the script, the script might break our network.</p>
    <p class="normal">If we need to rely on the script for production, we need the script to be idempotent as much as possible.</p>
    <h3 class="heading-3" id="_idParaDest-76">Bad automation speeds up bad things</h3>
    <p class="normal">Bad automation allows you to poke yourself in the eye a lot faster, it is as simple as that. Computers are <a id="_idIndexMarker185"/>much faster at executing tasks than human engineers. If we had the same set of operating procedures executed by a human versus a script, the script would finish faster than humans, sometimes without the benefit of having a solid feedback loop between steps. The internet is full of horror stories of when someone pressed the <em class="keystroke">Enter</em> key and immediately regretted it.</p>
    <p class="normal">We need to minimize the chances of bad automation scripts screwing things up. We all make mistakes; carefully testing your script before any production work and having a small blast radius are two <a id="_idIndexMarker186"/>keys to making sure you can catch your mistake before it comes back and bites you. No tool or human can eliminate mistakes completely, but we can strive to minimize the mistakes. As we have seen, as great as some of the libraries we have used in this chapter are, the underlying CLI-based method is inherently faulty and error-prone. We will introduce the API-driven method in the next chapter, which addresses some of the CLI-driven management deficiencies.</p>
    <h1 class="heading-1" id="_idParaDest-77">Summary</h1>
    <p class="normal">In this chapter, we covered low-level ways to communicate directly with network devices. Without a way to programmatically communicate and make changes to network devices, there is no automation. We looked at several libraries in Python that allow us to manage devices that were meant to be managed by the CLI. Although useful, it is easy to see how the process can be somewhat fragile. This is mostly due to the fact that the network gear in question was meant to be managed by human beings and not computers.</p>
    <p class="normal">In <em class="chapterRef">Chapter 3</em>, <em class="italic">APIs and Intent-Driven Networking</em>, we will look at network devices supporting API and intent-driven networking.</p>
    <h1 class="heading-1">Join our book community</h1>
    <p class="normal">To join our community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/networkautomationcommunity"><span class="url">https://packt.link/networkautomationcommunity</span></a></p>
    <p class="normal"><img alt="" src="../Images/QR_Code2903617220506617062.png"/></p>
  </div>
</body></html>