- en: 'Chapter 3. Tasklist I: Persistence'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to deliver content to the user. This
    content consisted of HTML markup to structure the information together with a
    number of JavaScript libraries and code to create a user interface.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We noted that this was not a full-fledged web application yet; it lacked the
    functionality to store information on the server and there was no way to identify
    different users or any way to authenticate them. In this chapter, we will address
    both these issues when we design a simple tasklist application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This tasklist application will be able to serve multiple users and store the
    list of tasks for each user on the server.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Specifically, we will look at:'
  prefs: []
  type: TYPE_NORMAL
- en: How to design a tasklist application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a logon screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a session is and how this allows us to work with different users at the
    same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to interact with the server and add or delete tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make entering dates attractive and simple with jQuery UI's datapicker
    widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to style button elements and provide tooltips and inline labels to input
    elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a tasklist application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing an application should start with a clear idea of what is expected.
    Not only to determine what is technically required, but almost as important, to
    define clear boundaries so that we don't lose time on things that are just nice
    to have. Nice to have features are something to be added if there is time left
    in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s draw up a shortlist of the relevant features of our tasklist application.
    Some of these may seem obvious, but as we will see, these have a direct impact
    on some implementation choices that we have to make, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The application will be used by multiple users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task lists should be stored indefinitely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A task list may contain an unlimited number of tasks but the user interface
    is designed for optimal performance for up to 25 tasks or so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks may be added, deleted, and marked as done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although this list isn't exhaustive, it has some important implications.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the tasklist application will be used by more than one user means
    that we have to identify and authorize people who want to use it. In other words,
    we will need some sort of logon screen and a way to check people against some
    sort of password database. Because we do not want to burden the user with identifying
    himself/herself each and every time a task list is refreshed or altered, we need
    some way of implementing the concept of a **session**.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications use the stateless HTTP protocol. This means, from the server's
    point of view, every request is a single, unrelated event, and no information
    is retained at the server. This obviously presents us with a problem if we want
    to perform a set of related actions. The solution is to ask the web browser to
    send a small piece of information along with every request it makes to the application
    after the application has identified the user.
  prefs: []
  type: TYPE_NORMAL
- en: This might be accomplished in a number of ways. The server may add an extra
    parameter to all links inside any web page it generates, commonly referred to
    as a **session id**, or use the even more general concept of a **cookie**.
  prefs: []
  type: TYPE_NORMAL
- en: Once the server asks the web browser to store a cookie, this cookie is sent
    with every following request to the same website. The advantage of cookies is
    that common web application frameworks (like CherryPy) are already equipped to
    deal with them and implementing sessions with cookies is much simpler than designing
    the application to alter all hyperlinks it generates to include a proper session
    ID. The disadvantage might be that people may block their browser from storing
    cookies because some websites use them to track their clicking behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We let the simplicity of implementation prevail and opt for cookies. If users
    want to block cookies this is not much of a problem as most browsers also have
    the option to selectively allow cookies from designated websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image illustrates the way CherryPy manages sessions with the
    help of cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing a tasklist application](img/3746OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It starts when the client (the web browser) sends a request to CherryPy. Upon
    receiving the request, the first check is to see if the web browser has sent along
    a cookie with a session ID. If it didn't, a new session idea is generated. Also,
    if there was a cookie with a session ID, if this ID is no longer valid (because
    it has expired, for example, or is a remnant from a very old interaction and doesn't
    exist in the current cache of session IDs) CherryPy also generates a new session
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, no persistent information is stored if this is a new session,
    but if it's an existing session there might be persistent data available. If there
    is, CherryPy creates a `Session` object and initializes it with the available
    persistent data. If not, it creates an empty `Session` object. This object is
    available as a global variable `cherrypy.session`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step for CherryPy is to pass control to the function that will handle
    the request. This handler has access to the `Session` object and may change it,
    for example, by storing additional information for later reuse. (Note that the
    `Session` object acts like a dictionary so you can simply associate values with
    keys with `cherrypy.session['key']=value`. The only restriction to the keys and
    values is that they must be serializable if the persistent storage is on disk).
  prefs: []
  type: TYPE_NORMAL
- en: Then before returning the results generated by the handler, CherryPy checks
    if the `Session` object has changed. If (and only if) it has, are the contents
    of the `Session` object saved to a more permanent storage.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the response is returned accompanied by a cookie with the session ID.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action creating a logon screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first task is to create a small application that does little more than present
    the user with a logon screen. It will be the starting point of our tasklist application
    and many others as well.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this example as well as most other examples in this book is available
    from the Packt website. If you have not downloaded it yet, this might be a good
    time to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following pieces of code and save it in a file called `logonapp.py`
    in the same directory as the other files distributed with this chapter ([Chapter
    3](ch03.html "Chapter 3. Tasklist I: Persistence") in the sample code):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/logonapp.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run `logonapp.py`, a very simple application is available on port
    8080\. It presents the user with a logon screen when the top level page `http://localhost:8080/`
    is accessed. An example is shown in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action creating a logon screen](img/3746_3_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If a correct username/password combination is entered, a welcome message is
    shown. If an unknown username or wrong password is entered, the user is redirected
    to `http://localhost:8080/goaway`.
  prefs: []
  type: TYPE_NORMAL
- en: The `somepage()` method (highlighted) returns a page with (presumably) some
    useful content. If the user is not yet authenticated, the logon screen is shown
    and upon entering the correct credentials, the user is directed back to `http://localhost:8080/somepage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete tree of web pages within the logon sample application and the
    possible paths the user may pick through is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action creating a logon screen](img/3746OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logon + session ID vs. HTTP basic authentication
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may wonder why we choose not to reuse CherryPy's bundled `auth_basic` tool
    that offers basic authentication (for more information on this tool, see [http://www.cherrypy.org/wiki/BuiltinTools#tools.auth_basic)](http://www.cherrypy.org/wiki/BuiltinTools#tools.auth_basic)).
    If all we wanted was to check whether a user is allowed access to a single page,
    this would be a good choice. The basic authentication is sufficient to authenticate
    a user, but has no concept of a session. This means we lack a way to store data
    that needs to be accessible when we process subsequent requests by the same user.
    The `sessions` tool we use here does provide this additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part of the magic of `logonapp.py` is achieved by enabling the 'sessions' tool
    in CherryPy. This is what is done by passing the `tools.sessions.on` key with
    `True` as a value to the configuration dictionary for the `quickstart()` function.
  prefs: []
  type: TYPE_NORMAL
- en: However, most of the hard work in `logonapp.py` is actually performed by the
    module `logon:`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/logon.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The logon module implements a utility function `checkauth()` (highlighted).
    This function is designed to be called from anywhere inside a CherryPy application.
    If the user is already authenticated, it will return the username; otherwise it
    will redirect the user to a URL that should present the user with a logon screen.
    If the `returnpage` parameter is true, this URL is augmented with an extra parameter
    `returnpage` containing the URL of the page that invoked `checkauth()`. The logon
    page (or rather the handler implementing it) should be designed to redirect the
    user to the URL in this parameter if the authentication is successful.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, typical use for the `checkauth()` function would be to call
    it from every page handler that serves content that requires authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '`checkauth()` itself does just two things: First it determines the page to
    return to (if necessary) by concatenating the `script_name` and `path_info` attributes
    from the `cherrypy.request` object that CherryPy makes available. The first one
    contains the path where a CherryPy tree is mounted, the last one contains the
    path within that tree. Together they form the complete path to the handler that
    invoked this `checkauth()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The second thing that `checkauth()` does is it determines whether `cherrypy.session`
    (a dictionary like Session object) contains an `authenticated` key. If it does,
    it returns the associated value, if not, it redirects to the logon page.
  prefs: []
  type: TYPE_NORMAL
- en: The `cherrypy.session` variable is a `cherrypy.lib.sessions.Session` object
    available to each request. It acts like a dictionary and initially it is devoid
    of any keys. When a value is assigned to the first new key, a persistent object
    is created that is associated with the session ID and upon finishing a request,
    the `Session` object is stored and its session ID is passed as the value of a
    `session_id` cookie in the response headers. If a subsequent request contains
    a request header with a `session_id` cookie, a `Session` object with the corresponding
    session ID is retrieved from storage, making any saved key/value pairs available
    again.
  prefs: []
  type: TYPE_NORMAL
- en: The default storage scheme is to keep data in memory. This is fast and simple
    but has the disadvantage that restarting the CherryPy server will discard this
    data, effectively expiring all sessions. This might be ok for short-lived sessions,
    but if you need a more persistent solution, it is possible to store the session
    information as files (by setting the `tools.sessions.storage_type` configuration
    key to `"file")` or even to a database backend. For more about sessions, see CherryPy's
    online documentation on the subject at [http://cherrypy.org/wiki/CherryPySessions](http://cherrypy.org/wiki/CherryPySessions).
  prefs: []
  type: TYPE_NORMAL
- en: 'The various steps in the communication between the client and the server during
    a session are shown in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/3746OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The bulk of the `logon` module is provided by the `Logon` class. It implements
    several methods (these methods are highlighted in the code listed on the previous
    pages as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__()` will initialize a `Logon` instance to hold the path to the point
    where this `Logon` instance is mounted on the tree of handlers, together with
    the default URLs to redirect to successful and unsuccessful authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkpass()` is a static function that takes a username and a password and
    returns `True` if these are a matching pair. It is designed to be overridden by
    a more suitable definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Logon` also exposes three handler methods to the CherryPy engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index()` is a method that will serve the actual logon screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logon()` is passed the username and password when the user clicks on the logon
    button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logoff()` will expire a session, causing subsequent calls to `checkauth()`
    to redirect the user to the logon screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Logon` class also contains a number of class variables to hold the HTML
    presented by the `index()` method. Let's look at the methods in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'And what about security? The `Logon` class we design here has no facilities
    to prevent people from eavesdropping if they have access to the wire that transports
    the HTTP traffic. This is because we transmit the passwords unencrypted. We may
    implement some sort of encryption scheme ourselves, but if your design requires
    some form of protection, it is probably better and easier to communicate over
    a secure HTTPS channel. CherryPy may be configured to use HTTPS instead of HTTP.
    More on it can be found at: [http://cherrypy.org/wiki/ServerObject](http://cherrypy.org/wiki/ServerObject).'
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz session IDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the client sends a new session ID again and again, wouldn't that fill up
    all storage on the server eventually?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the client has cookies disabled, what happens to the generation of session
    IDs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. The server will stop generating new session IDs, returning the same ID repeatedly
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. The server will stop returning new session IDs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. The server will keep generating and returning new session IDs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serving a logon screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `index()` method serves the HTML to present the user with a logon screen.
    At its core, this HTML is a`<form>` element with three`<input>` elements: a regular
    text input where the user may enter his/her username, a password input (that will
    hide the characters that are entered in this field), and an`<input>` element that
    has a `hidden` attribute. The`<form>` element has an `action` attribute that holds
    the URL of the script that will process the variables in the form when the user
    clicks the logon button. This URL is constructed to point to the `logon()` method
    of our `Logon` class by appending `/logon` to the path that the `Logon` instance
    was mounted on in the CherryPy tree.'
  prefs: []
  type: TYPE_NORMAL
- en: The`<input>` element we marked as hidden is initialized to hold the URL that
    the user will be redirected to when `logon()` authenticates the user successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form that makes up the logon screen also contains a tiny piece of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It uses jQuery to select the input element that will receive the username and
    gives it focus. By placing the cursor in this field, we save the user the effort
    of pointing and clicking on the username field first before the username can be
    entered. Now he can start typing right away. Note that this code snippet is not
    placed near the end of the document, but right after the`<input>` element to ensure
    execution as soon as the`<input>` element is defined. The logon page is so small
    that this might be irrelevant, but on slow loading pages, key presses might be
    misdirected if we waited to shift the focus until the whole page had loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Be aware that the logon form we construct here has a`<form>` element with an
    `action="GET`" attribute. This works fine, but has a disadvantage: parameters
    passed with a `GET` method are appended to the URL and may end up in the log files
    of the server. This is convenient when debugging, but you might not want that
    for a production environment, as this might leave passwords exposed. The `action`
    attribute can be changed to `POST` though without any change to the Python code
    handling the request as CherryPy takes care of the details. Parameters passed
    to a `POST` method are not logged, so a `POST` method might be better suited to
    a password verification request.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `logon()` method is passed the contents of all the`<input>` elements in
    the form as parameters. The `username` and `password` parameters are passed to
    the `checkpass()` method and if the user's credentials are right, we establish
    a session by associating the username with the authenticated key in our session
    storage with `cherrypy.session['authenticated']=username`.
  prefs: []
  type: TYPE_NORMAL
- en: This will have the effect that every response sent to the browser will contain
    a cookie with a session ID and any subsequent request to CherryPy that contains
    this cookie again will cause the handler for that request to have access to this
    same session storage.
  prefs: []
  type: TYPE_NORMAL
- en: After successful authentication, `logon()` redirects the user to the return
    page if one was passed to it or to the default page passed to it upon initialization
    of the `Logon` instance. If authentication fails, the user is redirected to a
    non-authorized page.
  prefs: []
  type: TYPE_NORMAL
- en: Expiring a session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `logoff()` method is provided to offer a possibility to actively expire
    a session. By default, a session expires after 60 minutes, but the user might
    want to sign off explicitly, either to make sure that no one sneaks behind his
    keyboard and continues in his name or to log on as a different persona. Therefore,
    you will find, in most applications, a discrete logoff button, often positioned
    in the upper-right corner. This button (or just a link) must point to the URL
    that is handled by the `logoff()` method and will cause the session to be invalidated
    immediately by removing all session data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we have to take special precautions to prevent the browser from caching
    the response from the `logoff()` method, otherwise it may simply redisplay the
    response from the last time the logoff button was pressed without actually causing
    `logoff()` to be called. Because `logoff()` always raises an `InternalRedirect`
    exception, the actual response comes from a different source. This source, for
    example, the `goaway()` method in the `Root` class must be configured to return
    the correct response headers in order to prevent the web browser from caching
    the result. This is accomplished by configuring the `goaway()` method in `logonapp.py`
    with CherryPy''s expires tool like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/logonapp.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line is where we configure the handler (the `goaway()` method)
    to set expiration headers in the response by assigning a configuration dictionary
    to the `_cp_config` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assigning to a variable that is part of a function might seem odd, but functions
    and methods in Python are just objects and any object may have variables. New
    variables might be assigned to an object even after its definition. Upon calling
    a handler, CherryPy checks if that handler has a `_cp_config` variable and acts
    accordingly. Note that the `@cherrypy.expose` decorator also merely sets the `expose`
    variable on the handler to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero adding a logon screen to the spreadsheet application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we had created an application that serves a spreadsheet.
    If you wanted to serve this spreadsheet only to authenticated users, what would
    we have to change to use the logon module presented in the previous section?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: You need to do three things, one involves mounting an instance of the
    `Logon` class on the CherryPy tree, the other is changing the handler that serves
    the spreadsheet to check for authentication, and finally you need to enable sessions.'
  prefs: []
  type: TYPE_NORMAL
- en: An example implementation is available as `spreadsheet3.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a task list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have looked at ways to authenticate the users, let's look at the
    implementation of the task list itself.
  prefs: []
  type: TYPE_NORMAL
- en: A task list would be unusable if its contents evaporated once the browser was
    closed. We therefore need some way to persistently store these task lists. We
    could use a database and many of the example applications in this book do use
    a database to store data. For this application, we will opt to use the filesystem
    as a storage medium, simply storing tasks as files containing information about
    a task, with separate directories for each user. If we dealt with huge amounts
    of users or very long task lists, the performance of such an implementation probably
    wouldn't suffice, but by using simple files for storage, we won't have to design
    a database schema which saves us quite some time.
  prefs: []
  type: TYPE_NORMAL
- en: By limiting ourselves to fairly short task lists, our user interface may be
    kept relatively simple as there will be no need for pagination or searching. This
    doesn't mean the user interface shouldn't be easy to use! We will incorporate
    jQuery UI's **datepicker** widget to assist the user with choosing dates and will
    add tooltips to user interface components to provide a shallow learning curve
    of our task list application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final requirements more or less define what we understand a task to be
    and what we are supposed to do with it: A task has a description and a due date
    and because it can be marked as done, it should be able to store that fact as
    well. Furthermore, we limit this application to adding and deleting tasks. We
    explicitly do not provide any way to alter a task, except for marking it as done.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action running tasklist.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first have a look at what the application looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: Start up `tasklist.py` from the code directory of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point your browser to `http://localhost:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the logon screen, enter **user** as the username and **secret** as the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now presented with a rather stark looking and empty task list:![Time
    for action running tasklist.py](img/3746_3_005.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should be able to add a new task by entering a date and a description in
    the input boxes and pressing the add button. Entering a date is facilitated by
    jQuery UI''s datepicker widget that will pop up once you click the input field
    for the date, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action running tasklist.py](img/3746_3_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have added one or more tasks, you can now either delete those tasks
    by clicking the button with the little trash can icon or mark it as done by clicking
    the button with the check icon. Tasks marked as done have a slightly different
    background color depending on the chosen theme. If you mark a task as done, its
    completion date will be today. You can select a different date by clicking on
    the completion date of a task (displayed as **None** for an unfinished task).
    It will present you with yet another datepicker, after which the selected date
    will be stored as the completion date once the done button is clicked. The following
    screenshot gives an impression of a task list with numerous items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action running tasklist.py](img/3746_3_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is some hidden magic that might not be immediately obvious. First of all,
    all the tasks are sorted according to their **Due date**. This is done on the
    client-side with the help of some JavaScript and a jQuery plugin, as we will see
    in the section on JavaScript. Also accomplished with some JavaScript are the tooltips.
    Both hovering tooltips on every button and the inline help text inside the`<input>`
    elements are added with the same script. We will examine this in depth.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tasklist.py` is rather straightforward as it delegates most work to two modules:
    the `logon` module that we encountered in the previous sections and a `task` module
    that deals with displaying and manipulating task lists.'
  prefs: []
  type: TYPE_NORMAL
- en: The highlighted line in the following code shows the core of the application.
    It starts up CherryPy with a suitable configuration. Note that we enabled the
    sessions tool, so that we can actually use the `logon` module. Also, we construct
    the path to jQuery UI's theme stylesheet in such a way that it depends on the
    `theme` variable to make changing the application's theme simple (second highlight).
  prefs: []
  type: TYPE_NORMAL
- en: 'The instance of the `Root` class that we pass to `quickstart()` creates a simple
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The top level URL `/` returns the same content as `/login` by calling the `index()`
    method of the `Logon` instance. We could have used an `InternalRedirect` exception,
    but this is just as simple. The paths starting with `/task` are all handled by
    an instance of the `Task` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/tasklist.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Python: the task module'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `task` module is implemented in the file `task.py`. Let's look at the parts
    that make up this file.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action implementing the task module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a look at the Python code in `task.py:`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/task.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This first part illustrates Python''s "batteries included" philosophy nicely:
    besides the `cherrypy` module and our own `logon` module, we need quite a bit
    of specific functionality. For example, to generate unique identifiers, we use
    the `uuid` module and to manipulate dates, we use the `datetime` module. All of
    this functionality is already bundled with Python, saving us an enormous amount
    of development time. The next part is the definition of the basic HTML structure
    that will hold our task list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/task.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Again the structure is simple, but besides the themed stylesheet needed by jQuery
    UI (and reused by the elements we add to the page), we need an additional stylesheet
    specific to our task list application. It defines specific layout properties for
    the elements that make up our task list (first highlight). The highlighted`<script>`
    elements show that besides the jQuery and jQuery UI libraries, we need some additional
    libraries. Each of them deserves some explanation.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first JavaScript library is `sort.js,` a code snippet from James Padolsey
    (http://james.padolsey.com/tag/plugins/) that provides us with a plugin that allows
    us to sort HTML elements. We need this to present the list of tasks sorted by
    their due date.
  prefs: []
  type: TYPE_NORMAL
- en: The second is `tooltip.js` that combines a number of techniques from various
    sources to implement tooltips for our buttons and inline labels for our`<input>`
    elements. There are a number of tooltip plugins available for jQuery, but writing
    our own provides us with some valuable insights so we will examine this file in
    depth in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: The last one is `tasklist.js`. It employs all the JavaScript libraries and plugins
    to actually style and sort the elements in the task list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of `task.py` determines the directory we''re running the application
    from. We will need this bit of information because we store individual tasks as
    files located relative to this directory. The `gettaskdir()` function takes care
    of determining the exact path for a given username (highlighted). It also creates
    the `taskdir` directory and a sub directory with a name equal to username, if
    these do not yet exist with the `os.makedirs()` function (notice the final ''s''
    in the function name: this one will create all intermediate directories as well
    if they do not yet exist):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/task.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Task` class is where the handlers are defined that CherryPy may use to
    show and manipulate the task list. The `__init__()` method stores a path to a
    location that provides the user with a possibility to end a session. This path
    is used by other methods to create a suitable logoff button.
  prefs: []
  type: TYPE_NORMAL
- en: The `index()` method will present the user with an overview of all his/her tasks
    plus an extra line where a new task can be defined. As we have seen, each task
    is adorned with buttons to delete a task or mark it as done. The first thing we
    do is check whether the user is authenticated by calling the `checkauth()` function
    from our `logon` module (highlighted). If this call returns, we have a valid username,
    and with that username, we figure out where to store the tasks for this user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know this directory, we use the `glob()` function from the Python `glob`
    module to retrieve a list of files with a `.task` extension. We store that list
    in the `tasklist` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/task.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a `tasks` variable that will hold a list of strings that we
    will construct when we iterate over the list of tasks. It is initialized with
    some elements that together form the header of our task list. It contains, for
    example, a small form with a logoff button and the headers for the columns above
    the list of tasks. The next step is to iterate over all files that represent a
    task (highlighted) and create a form with suitable content together with delete
    and done buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `.task` file is structured in a way that is consistent with Microsoft
    Windows `.ini` files. Such files can be manipulated with Python''s `configparser`
    module. The `.task` file is structured as a single `[task]` section with three
    possible keys. This is an example of the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we initialize a `configparser` object, we pass it a dictionary with default
    values in case any of these keys is missing. The `configparser` will read a file
    when we pass an open file descriptor to its `readfp()` method. The value associated
    with any key in a given section may then be retrieved with the `get()` method
    that will take a section and a key as parameters. If the key is missing, it supplies
    the default if that was provided upon initialization. The second highlighted line
    shows how this is used to retrieve the values for the `description` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we construct a form for each `.task` file. It contains read-only`<input>`
    elements to display the **Due date, Description**, and the completion date plus
    buttons to delete the task or mark it as done. When these buttons are clicked
    the contents of the form are passed to the `/task/mark` URL (handled by the `mark()`
    method). The method needs to know which file to update. Therefore, it is passed
    a hidden value: the basename of the file. That is, the filename without any leading
    directories and stripped of its `.task` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/task.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we append one extra form with the same type of input fields for **Due
    date** and **Description** but this time, not marked as read-only. This form has
    a single button that will submit the contents to the `/task/add` URL. These will
    be handled by the `add()` method. The actual content returned by the `index()`
    method consists of all these generated lines joined together and embedded in the
    HTML of the `base_page` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New tasks are created by the `add()` method. Besides the value of the add button
    (which is not relevant), it will take a `description` and a `duedate` as parameters.
    To prevent accidents, it first checks if the user is authenticated, and if so,
    it determines what the `taskdir` for this user is.
  prefs: []
  type: TYPE_NORMAL
- en: We are adding a new task so we want to create a new file in this directory.
    To guarantee that it has a unique name, we construct this filename from the path
    to this directory and a globally unique ID object provided by Python's `uuid()`
    function from the `uuid` module. The `.hex()` method of a `uuid` object returns
    the ID as a long string of hexadecimal numbers that we may use as a valid filename.
    To make the file recognizable to us as a task file, we append the `.task` extension
    (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want our file to be readable by a `configparser` object, we will
    create it with a `configparser` object to which we add a `task` section with the
    `add_section()` method and `description` and `duedate` keys with the `set()` method.
    Then we open a file for writing and use the open file handle to this file within
    a context manager (the `with` clause), thereby ensuring that if anything goes
    wrong when accessing this file, it will be closed and we will proceed to redirect
    the user to that list of tasks again. Note that we use a relative URL consisting
    of a single dot to get us the index page. Because the `add()` method handles a
    URL like `/task/add` redirecting to ''.'' (the single dot), will mean the user
    is redirected to `/task/`, which is handled by the `index()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/task.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting or marking a task as done are both handled by the `mark()` method.
    Besides an ID (the basename of an existing `.task` file), it takes `duedate, description`,
    and `completed` parameters. It also takes optional `done` and `delete` parameters,
    which are set depending on whether the done or delete buttons are clicked respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the first actions are to establish whether the user is authenticated
    and what the corresponding task directory is. With this information, we can construct
    the filename we will act on. We take care to check the validity of the `id` argument.
    We expect it to be a string of hexadecimal characters only and one way to verify
    this is to convert it using the `int()` function with 16 as the base argument.
    This way, we prevent malicious users from passing a file path to another user's
    directory. Even though it is unlikely that a 32 character random string can be
    guessed, it never hurts to be careful.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to see if we are acting on a click on the done button (highlighted
    in the following code). If we are, we read the file with a `configparser` object
    and update its `completed` key.
  prefs: []
  type: TYPE_NORMAL
- en: The `completed` key is either the date that we were passed as the `completed`
    parameter or the current date if that parameter was either empty or `None`. Once
    we have updated the `configparser` object, we write it back again to the file
    with the `write()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibility is that we are acting on a click on the delete button;
    in that case, the `delete` parameter is set. If so, we simply delete the file
    with the `unlink()` function from Python''s `os` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/task.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript: tasklist.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The buttons we present the end user need to be configured to respond to clicks
    in an appropriate manner and it would be nice if these buttons showed some intuitive
    icons as well. This is what we will take care of in `tasklist.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action styling the buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The work done by `tasklist.js` is mainly concerned with styling the`<button>`
    elements and adding tooltips and inline labels to`<input>` elements. The results
    so far are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action styling the buttons](img/3746_3_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As can be seen in the first line of `tasklist.js` (code starts on the next page),
    the work to be done is scheduled after loading the complete document by passing
    it to jQuery's `$(document).ready()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to add to any element with a `header` class the `ui-widget`
    and `ui-widget-header` classes as well. This will cause these elements to be styled
    in a way that is consistent with the chosen theme.
  prefs: []
  type: TYPE_NORMAL
- en: Then we configure the add button (or rather any element with the `add-button`
    class) as a jQuery UI button widget. The option object passed to it will configure
    it to show no text, but just a single icon depicting a thick plus sign. We also
    add an extra function to the click handler of the button that checks any element
    marked with the `inline-label` class to see if its contents are identical to the
    contents of its title attribute. If that is the case, we set the contents to the
    empty string, as this indicates that the user hasn't filled in anything in this
    element and we do not want to store the text of the inline label as the content
    of our new task (more about this in the section on tooltips). Note that we do
    nothing to prevent propagation of the click event, so if this button is of the
    `submit` type (and our add button is) the `submit` action will still be performed.
  prefs: []
  type: TYPE_NORMAL
- en: All elements with the `del-button` class (highlighted) are then styled with
    an icon of a trash can. The buttons also receive an extra click handler that will
    remove the disabled attribute from their siblings (the input fields in the same
    form) to make sure the submit action will receive the contents even from fields
    that are marked as disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the other`<button>` elements are adorned with an appropriate icon and
    to any text or password`<input>` element we add a `textinput` class to mark it
    for the tooltip library.
  prefs: []
  type: TYPE_NORMAL
- en: In the second highlighted line, we encounter jQuery UI's datepicker widget.
    The datepicker widget greatly simplifies entering dates for the user and is now
    more or less a staple item in any web application or website that asks the user
    to enter a date. jQuery UI's datepicker is very straightforward to use, yet comes
    with a host of configuration options (all of them documented at [http://jqueryui.com/demos/datepicker/)](http://jqueryui.com/demos/datepicker/)).
  prefs: []
  type: TYPE_NORMAL
- en: We use the `dateFormat` option to configure the datepicker to store dates as
    YYYY-MM-DD. Datepicker has a number of predefined formats and this one happens
    to be an international standard as well as a suitable format to sort dates in
    a simple way. We also configure the datepicker to call a function when the user
    closes the datepicker. This function removes any `inline-label` class, preventing
    the newly entered date to appear in the colors associated with any inline label
    (as we see later, when we look at `tasklist.css`, we style the colors of any element
    with an `inline-label` class in a distinct way).
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we indicated that we wanted to present the list of tasks ordered by
    their due date. We therefore apply the `sort()` plugin from `sort.js` to all`<input>`
    elements with a `duedate` class. `sort()` takes two arguments. The first one is
    a comparison function that is passed two elements to compare. In our case, that
    will be`<input>` elements that contain a date in the YYYY-MM-DD format, so we
    can simply compare the values of these elements as text and return plus or minus
    one. The second argument is a function that takes no arguments and should return
    the element to be sorted. The input element with the due date is available as
    the `this` variable within this function and we use it to return the parent of
    the input element. This parent will be the`<form>` element that encloses it and
    because we represent each task as a form, we want those forms to be sorted, not
    just the`<input>` elements inside these forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last set of actions in `tasklist.js` adds a `disabled` attribute to any`<input>`
    element within an element that has a `done` class and disables any done button.
    This will ensure that tasks marked as done cannot be altered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/tasklist.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript: tooltip.js'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`tooltip.js` is a bit of a misnomer as its most interesting part is not about
    tooltips but inline labels. Inline labels are a way to convey helpful information
    not by means of a hovering tooltip, but by putting text inside text input elements.
    This text then disappears when the user clicks the input field and starts typing.
    There are many implementations to be found on the web, but the most clear and
    concise one I found is from [http://trevordavis.net/blog/tutorial/jquery-inline-form-labels/](http://trevordavis.net/blog/tutorial/jquery-inline-form-labels/).'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action implementing inline labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look again at the screenshot of the list of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action implementing inline labels](img/3746_3_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The highlighted parts show what we mean by inline labels. The input fields display
    some helpful text to indicate their use and when we click such a field, this text
    will disappear and we can enter our own text. If we abort the input by clicking
    outside the input field when we have not yet entered any text, the inline label
    is shown again.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`tooltip.js` shows a number of important concepts: First how to apply a function
    to each member of a selection (highlighted). In this case, we apply the function
    to all`<input>` elements that have a `title` attribute. Within the function passed
    to the `each()` method, the selected`<input>` element is available in the `this`
    variable. If the content of an`<input>` element is completely empty, we change
    its content to that of the `title` attribute and add the class `inline-label`
    to the`<input>` element. That way, we can style the text of an inline label differently
    than the regular input text if we like, for example, a bit lighter to make it
    stand out less.'
  prefs: []
  type: TYPE_NORMAL
- en: The second concept shown is binding to the **focus** and **blur** events. When
    the user clicks an`<input>` element or uses the *Tab* key to navigate to it, it
    gains focus. We can act upon this event by passing a function to the `focus()`
    method. In this function, the`<input>` element that gains focus is again available
    in the `this` variable and we check if the content of this`<input>` element is
    equal to the content of its `title` attribute. If this is true, the user hasn't
    yet changed the content, so we empty this element by assigning an empty string
    to it (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: The same line shows another important concept in jQuery, that of **chaining**.
    Most jQuery methods (like `val()` in this example) return the selection they act
    upon, allowing additional methods to be applied to the same selection. Here we
    apply `removeClass()` to remove the `inline-label` class to show the text the
    user is typing in the regular font and color for this`<input>` element.
  prefs: []
  type: TYPE_NORMAL
- en: We also act on losing focus (commonly referred to as *blurring)*, for example,
    when the user clicks outside the`<input>` element or uses the *Tab* key to navigate
    to another element. We therefore pass a function to the `blur()` method. This
    function checks whether the content of the`<input>` element is empty. If so, then
    the user hasn't entered anything and we insert the content of the `title` attribute
    again and mark the element with an `inline-label` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/tooltip.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'CSS: tasklist.css'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without some additional styling to tweak the layout, our tasklist application
    would look a bit disheveled, as seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Our main challenges are aligning all columns and moving all buttons consistently
    to the right. All elements in our HTML markup that make up the columns are marked
    with a class to indicate that they belong in the left, middle, or right column.
    All we have to do to align these columns is to set their width based on their
    class (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: 'The largest part of the rest of `tasklist.css` is concerned with either floating
    elements to the right (like buttons) or to the left (containers, like the`<div>`
    element with the `id` attribute `content)`. Most containers are not only floated
    to the left, but also explicitly set to a width of 100 percent to make sure they
    fill the element they are contained in themselves. This is not always necessary
    to position them correctly, but if we do not take care, the background color of
    the enclosing element might show if an element doesn''t fill its enclosing element:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter3/tasklist.css**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that our stylesheet only deals with measurements and font sizes. Any coloring
    is applied by the chosen jQuery UI theme. With the styles applied, the application
    looks a fair bit tidier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS: tasklist.css](img/3746_3_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pop quiz styling screen elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `tasklist.js`, we explicitly configured all buttons to show just an icon
    without any text. But what if we wanted to show both an icon and some text, what
    would we do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we didn't set the width of the form that makes up a task explicitly to 100
    percent, what would the biggest disadvantage be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero changing the date format of a datepicker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display the date as ISO 8701 (or YYYY-MM-DD) isn''t everybody''s idea of
    a readable date format. For many people, the default mm/dd/yy is far more readable.
    How would you change `tasklist.js` to display the tasks with this default date
    format? Hint: it isn''t enough to leave out the `dateFormat` option when calling
    the `datepicker()` plugin, you also need to change the comparator function to
    sort the tasks in a suitable manner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the impatient or curious readers: a sample implementation is available
    as `tasklist2.js` (start up `tasklist2.py` to see the effect).'
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero serving a task list from a different URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to measure how reusable a piece of code is, is by using it in a situation
    that you did not yet have in mind when you designed it. Of course, that doesn't
    mean our task module should be able to function as a control application for an
    automobile construction plant, but what if we would like it to be part of a larger
    suite of applications served from the same root? Would we have to change anything?
  prefs: []
  type: TYPE_NORMAL
- en: Say we want to serve the tasklist application from the URL [/apps/task](http:///apps/task)
    instead of [/task](http:///task), what would we have to change?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: In CherryPy, you can create a tree of URLs by assigning object instances
    to class variables of the object instance that is passed to the `quickstart()`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: A possible implementation can be found in `tasklistapp.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned a lot in this chapter about session management and storing persistent
    information on the server. Specifically, we saw how to design a tasklist application
    and implement a logon screen. What a session is and how this allows us to work
    with different users at the same time and how to interact with the server, and
    add or delete tasks. We also learned how to make entering dates attractive and
    simple with jQuery UI's datepicker widget and how to style button elements and
    provide tooltips and inline labels to input elements.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know a little bit more about storing data on the server, you might
    wonder if storing information in plain files on the server filesystem is the most
    convenient solution. In many cases, it isn't and a database might be more suitable
    which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
