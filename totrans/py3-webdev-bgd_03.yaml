- en: 'Chapter 3. Tasklist I: Persistence'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。任务列表 I：持久性
- en: In the previous chapter, we learned how to deliver content to the user. This
    content consisted of HTML markup to structure the information together with a
    number of JavaScript libraries and code to create a user interface.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何向用户传递内容。这些内容包括用于结构化信息的 HTML 标记以及一些 JavaScript 库和代码来创建用户界面。
- en: We noted that this was not a full-fledged web application yet; it lacked the
    functionality to store information on the server and there was no way to identify
    different users or any way to authenticate them. In this chapter, we will address
    both these issues when we design a simple tasklist application.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们注意到这还不是一款完整的网络应用程序；它缺少在服务器上存储信息的功能，也没有识别不同用户或验证他们的方法。在本章中，我们将设计一个简单的任务列表应用程序时解决这两个问题。
- en: This tasklist application will be able to serve multiple users and store the
    list of tasks for each user on the server.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个任务列表应用程序将能够为多个用户提供服务，并在服务器上存储每个用户的任务列表。
- en: 'Specifically, we will look at:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将探讨：
- en: How to design a tasklist application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计任务列表应用程序
- en: How to implement a logon screen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现登录界面
- en: What a session is and how this allows us to work with different users at the
    same time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话是什么以及它是如何使我们能够同时与不同用户一起工作的
- en: How to interact with the server and add or delete tasks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与服务器交互并添加或删除任务
- en: How to make entering dates attractive and simple with jQuery UI's datapicker
    widget
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 jQuery UI 的日期选择器小部件使输入日期变得吸引人且简单
- en: How to style button elements and provide tooltips and inline labels to input
    elements
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置按钮元素的样式并提供工具提示和内联标签给输入元素
- en: Designing a tasklist application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计任务列表应用程序
- en: Designing an application should start with a clear idea of what is expected.
    Not only to determine what is technically required, but almost as important, to
    define clear boundaries so that we don't lose time on things that are just nice
    to have. Nice to have features are something to be added if there is time left
    in the project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用程序应该从对预期的明确想法开始。这不仅是为了确定技术需求，而且同样重要的是，为了定义清晰的边界，这样我们就不至于在那些只是“锦上添花”的事情上浪费时间。如果项目中有剩余时间，锦上添花的功能是可以添加的。
- en: 'So let''s draw up a shortlist of the relevant features of our tasklist application.
    Some of these may seem obvious, but as we will see, these have a direct impact
    on some implementation choices that we have to make, such as:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们列出我们任务列表应用程序的相关功能清单。其中一些可能看起来很明显，但正如我们将看到的，这些直接影响了我们必须做出的某些实现选择，例如：
- en: The application will be used by multiple users
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序将由多个用户使用
- en: Task lists should be stored indefinitely
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务列表应该无限期地存储
- en: A task list may contain an unlimited number of tasks but the user interface
    is designed for optimal performance for up to 25 tasks or so
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务列表可能包含无限数量的任务，但用户界面是为最多 25 个任务左右的最佳性能设计的
- en: Tasks may be added, deleted, and marked as done
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可以添加、删除和标记为完成
- en: Although this list isn't exhaustive, it has some important implications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这份列表并不详尽，但它有一些重要的含义。
- en: The fact that the tasklist application will be used by more than one user means
    that we have to identify and authorize people who want to use it. In other words,
    we will need some sort of logon screen and a way to check people against some
    sort of password database. Because we do not want to burden the user with identifying
    himself/herself each and every time a task list is refreshed or altered, we need
    some way of implementing the concept of a **session**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任务列表应用程序将由多个用户使用，这意味着我们必须识别和授权想要使用它的人。换句话说，我们需要某种登录界面和一种检查人们是否与某种密码数据库匹配的方法。因为我们不希望用户每次刷新或更改任务列表时都要进行身份验证，所以我们需要一种实现**会话**概念的方法。
- en: Web applications use the stateless HTTP protocol. This means, from the server's
    point of view, every request is a single, unrelated event, and no information
    is retained at the server. This obviously presents us with a problem if we want
    to perform a set of related actions. The solution is to ask the web browser to
    send a small piece of information along with every request it makes to the application
    after the application has identified the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序使用无状态的 HTTP 协议。这意味着，从服务器的角度来看，每个请求都是一个单独的、无关的事件，并且服务器不会保留任何信息。如果我们想执行一系列相关操作，这显然会给我们带来问题。解决方案是要求网络浏览器在应用程序识别用户后，将一小块信息随每个请求一起发送给应用程序。
- en: This might be accomplished in a number of ways. The server may add an extra
    parameter to all links inside any web page it generates, commonly referred to
    as a **session id**, or use the even more general concept of a **cookie**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能通过多种方式实现。服务器可能在其生成的任何网页中的所有链接中添加一个额外的参数，通常称为**会话ID**，或者使用更通用的**cookie**概念。
- en: Once the server asks the web browser to store a cookie, this cookie is sent
    with every following request to the same website. The advantage of cookies is
    that common web application frameworks (like CherryPy) are already equipped to
    deal with them and implementing sessions with cookies is much simpler than designing
    the application to alter all hyperlinks it generates to include a proper session
    ID. The disadvantage might be that people may block their browser from storing
    cookies because some websites use them to track their clicking behavior.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器要求网页浏览器存储cookie，这个cookie就会随后续对同一网站的每个请求一起发送。cookie的优势在于，常见的Web应用框架（如CherryPy）已经配备了处理它们的功能，使用cookie实现会话比设计应用程序以更改它生成的所有超链接以包含适当的会话ID要简单得多。劣势可能在于，人们可能会阻止浏览器存储cookie，因为一些网站使用它们来跟踪他们的点击行为。
- en: We let the simplicity of implementation prevail and opt for cookies. If users
    want to block cookies this is not much of a problem as most browsers also have
    the option to selectively allow cookies from designated websites.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们优先考虑实现的简单性，并选择使用cookie。如果用户想要阻止cookie，这并不是一个大问题，因为大多数浏览器也提供了选择性地允许来自指定网站的cookie的选项。
- en: 'The following image illustrates the way CherryPy manages sessions with the
    help of cookies:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了CherryPy如何借助cookie管理会话：
- en: '![Designing a tasklist application](img/3746OS_03_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![设计任务列表应用程序](img/3746OS_03_01.jpg)'
- en: It starts when the client (the web browser) sends a request to CherryPy. Upon
    receiving the request, the first check is to see if the web browser has sent along
    a cookie with a session ID. If it didn't, a new session idea is generated. Also,
    if there was a cookie with a session ID, if this ID is no longer valid (because
    it has expired, for example, or is a remnant from a very old interaction and doesn't
    exist in the current cache of session IDs) CherryPy also generates a new session
    ID.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切始于客户端（网页浏览器）向CherryPy发送请求。在收到请求后，首先检查的是网页浏览器是否发送了一个带有会话ID的cookie。如果没有，将生成一个新的会话ID。此外，如果有一个带有会话ID的cookie，如果这个ID不再有效（例如，因为已过期，或者是一个来自非常旧的交互的残留物，且不存在于当前的会话ID缓存中），CherryPy也会生成一个新的会话ID。
- en: At this point, no persistent information is stored if this is a new session,
    but if it's an existing session there might be persistent data available. If there
    is, CherryPy creates a `Session` object and initializes it with the available
    persistent data. If not, it creates an empty `Session` object. This object is
    available as a global variable `cherrypy.session`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，如果这是一个新的会话，则不会存储任何持久信息，但如果是一个现有的会话，则可能存在可用的持久数据。如果有，CherryPy会创建一个`Session`对象，并用可用的持久数据初始化它。如果没有，它将创建一个空的`Session`对象。这个对象作为全局变量`cherrypy.session`可用。
- en: The next step for CherryPy is to pass control to the function that will handle
    the request. This handler has access to the `Session` object and may change it,
    for example, by storing additional information for later reuse. (Note that the
    `Session` object acts like a dictionary so you can simply associate values with
    keys with `cherrypy.session['key']=value`. The only restriction to the keys and
    values is that they must be serializable if the persistent storage is on disk).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy的下一步是传递控制权到将处理请求的函数。这个处理程序可以访问`Session`对象，并可能对其进行更改，例如，通过存储额外的信息以供以后重用。（注意，`Session`对象的行为类似于字典，因此您可以使用`cherrypy.session['key']=value`简单地使用键将值关联起来。对键和值的唯一限制是，如果持久存储在磁盘上，它们必须是可序列化的）。
- en: Then before returning the results generated by the handler, CherryPy checks
    if the `Session` object has changed. If (and only if) it has, are the contents
    of the `Session` object saved to a more permanent storage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在返回处理程序生成的结果之前，CherryPy会检查`Session`对象是否已更改。如果（并且仅当）它已更改，则将`Session`对象的内容保存到更持久的存储中。
- en: Finally, the response is returned accompanied by a cookie with the session ID.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，返回响应，并附带一个带有会话ID的cookie。
- en: Time for action creating a logon screen
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录界面的操作时间
- en: Our first task is to create a small application that does little more than present
    the user with a logon screen. It will be the starting point of our tasklist application
    and many others as well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是创建一个简单的应用程序，它所做的不仅仅是向用户提供登录界面。它将成为我们的任务列表应用程序以及许多其他应用程序的起点。
- en: The code for this example as well as most other examples in this book is available
    from the Packt website. If you have not downloaded it yet, this might be a good
    time to do so.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本例代码以及本书中的大多数其他示例代码均可在Packt网站找到。如果您尚未下载，这可能是一个下载的好时机。
- en: 'Enter the following pieces of code and save it in a file called `logonapp.py`
    in the same directory as the other files distributed with this chapter ([Chapter
    3](ch03.html "Chapter 3. Tasklist I: Persistence") in the sample code):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码片段输入并保存到与本章其他文件相同的目录中（[第3章](ch03.html "第3章。任务列表I：持久性")中的示例代码）的名为`logonapp.py`的文件中：
- en: '**Chapter3/logonapp.py**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter3/logonapp.py**'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you now run `logonapp.py`, a very simple application is available on port
    8080\. It presents the user with a logon screen when the top level page `http://localhost:8080/`
    is accessed. An example is shown in the following illustration:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行`logonapp.py`，一个非常简单的应用程序将在端口8080上可用。当访问顶级页面`http://localhost:8080/`时，它会向用户展示登录界面。以下是一个示例：
- en: '![Time for action creating a logon screen](img/3746_3_003.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![创建登录界面的行动时间](img/3746_3_003.jpg)'
- en: If a correct username/password combination is entered, a welcome message is
    shown. If an unknown username or wrong password is entered, the user is redirected
    to `http://localhost:8080/goaway`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入了正确的用户名/密码组合，将显示欢迎信息。如果输入了未知用户名或错误的密码，用户将被重定向到`http://localhost:8080/goaway`。
- en: The `somepage()` method (highlighted) returns a page with (presumably) some
    useful content. If the user is not yet authenticated, the logon screen is shown
    and upon entering the correct credentials, the user is directed back to `http://localhost:8080/somepage`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`somepage()`方法（突出显示）返回一个包含（可能）一些有用内容的页面。如果用户尚未认证，将显示登录界面，并在输入正确的凭据后，用户将被引导回`http://localhost:8080/somepage`。'
- en: 'The complete tree of web pages within the logon sample application and the
    possible paths the user may pick through is shown next:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下文展示了登录示例应用程序中的完整网页树以及用户可能选择的可能路径：
- en: '![Time for action creating a logon screen](img/3746OS_03_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![创建登录界面的行动时间](img/3746OS_03_02.jpg)'
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Logon + session ID vs. HTTP basic authentication
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 登录 + 会话ID 与 HTTP基本认证
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may wonder why we choose not to reuse CherryPy's bundled `auth_basic` tool
    that offers basic authentication (for more information on this tool, see [http://www.cherrypy.org/wiki/BuiltinTools#tools.auth_basic)](http://www.cherrypy.org/wiki/BuiltinTools#tools.auth_basic)).
    If all we wanted was to check whether a user is allowed access to a single page,
    this would be a good choice. The basic authentication is sufficient to authenticate
    a user, but has no concept of a session. This means we lack a way to store data
    that needs to be accessible when we process subsequent requests by the same user.
    The `sessions` tool we use here does provide this additional functionality.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么我们选择不重用CherryPy捆绑的`auth_basic`工具，该工具提供基本认证（有关此工具的更多信息，请参阅[http://www.cherrypy.org/wiki/BuiltinTools#tools.auth_basic](http://www.cherrypy.org/wiki/BuiltinTools#tools.auth_basic)）。如果我们只想检查用户是否有权访问单个页面，这将是一个不错的选择。基本认证足以验证用户身份，但没有会话的概念。这意味着我们在处理同一用户的后续请求时，缺乏存储需要访问的数据的方法。我们在这里使用的`sessions`工具确实提供了这项附加功能。
- en: What just happened?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Part of the magic of `logonapp.py` is achieved by enabling the 'sessions' tool
    in CherryPy. This is what is done by passing the `tools.sessions.on` key with
    `True` as a value to the configuration dictionary for the `quickstart()` function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`logonapp.py`的魔法之一是通过在CherryPy中启用''sessions''工具实现的。这是通过将`tools.sessions.on`键与值为`True`传递给`quickstart()`函数的配置字典来完成的。'
- en: However, most of the hard work in `logonapp.py` is actually performed by the
    module `logon:`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`logonapp.py`中的大部分艰苦工作实际上是由模块`logon:`完成的
- en: '**Chapter3/logon.py**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter3/logon.py**'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The logon module implements a utility function `checkauth()` (highlighted).
    This function is designed to be called from anywhere inside a CherryPy application.
    If the user is already authenticated, it will return the username; otherwise it
    will redirect the user to a URL that should present the user with a logon screen.
    If the `returnpage` parameter is true, this URL is augmented with an extra parameter
    `returnpage` containing the URL of the page that invoked `checkauth()`. The logon
    page (or rather the handler implementing it) should be designed to redirect the
    user to the URL in this parameter if the authentication is successful.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 登录模块实现了一个实用函数 `checkauth()`（突出显示）。此函数设计为可以从 CherryPy 应用程序的任何位置调用。如果用户已经认证，它将返回用户名；否则，它将重定向用户到应显示登录界面的
    URL。如果 `returnpage` 参数为真，则此 URL 将增加一个额外的参数 `returnpage`，包含调用 `checkauth()` 的页面的
    URL。登录页面（或者更确切地说，实现它的处理程序）应该设计为在认证成功时将用户重定向到该参数中的 URL。
- en: As we have seen, typical use for the `checkauth()` function would be to call
    it from every page handler that serves content that requires authentication.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`checkauth()` 函数的典型用途是在每个处理需要认证内容的页面调用它。
- en: '`checkauth()` itself does just two things: First it determines the page to
    return to (if necessary) by concatenating the `script_name` and `path_info` attributes
    from the `cherrypy.request` object that CherryPy makes available. The first one
    contains the path where a CherryPy tree is mounted, the last one contains the
    path within that tree. Together they form the complete path to the handler that
    invoked this `checkauth()` function.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkauth()` 本身只做两件事：首先，它通过连接 `cherrypy.request` 对象中可用的 `script_name` 和 `path_info`
    属性来确定要返回的页面（如果需要）。第一个包含 CherryPy 树挂载的路径，最后一个包含该树中的路径。它们共同形成了调用此 `checkauth()`
    函数的处理器的完整路径。'
- en: The second thing that `checkauth()` does is it determines whether `cherrypy.session`
    (a dictionary like Session object) contains an `authenticated` key. If it does,
    it returns the associated value, if not, it redirects to the logon page.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkauth()` 函数的第二个作用是确定 `cherrypy.session`（一个类似于 Session 对象的字典）是否包含一个 `authenticated`
    键。如果包含，则返回关联的值；如果不包含，则重定向到登录页面。'
- en: The `cherrypy.session` variable is a `cherrypy.lib.sessions.Session` object
    available to each request. It acts like a dictionary and initially it is devoid
    of any keys. When a value is assigned to the first new key, a persistent object
    is created that is associated with the session ID and upon finishing a request,
    the `Session` object is stored and its session ID is passed as the value of a
    `session_id` cookie in the response headers. If a subsequent request contains
    a request header with a `session_id` cookie, a `Session` object with the corresponding
    session ID is retrieved from storage, making any saved key/value pairs available
    again.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`cherrypy.session` 变量是一个 `cherrypy.lib.sessions.Session` 对象，对每个请求都可用。它像字典一样工作，并且最初它没有任何键。当为第一个新键分配值时，会创建一个与会话
    ID 关联的持久对象。在完成请求后，`Session` 对象被存储，其会话 ID 作为响应头中的 `session_id` cookie 的值传递。如果后续请求包含带有
    `session_id` cookie 的请求头，则从存储中检索具有相应会话 ID 的 `Session` 对象，使任何保存的键/值对再次可用。'
- en: The default storage scheme is to keep data in memory. This is fast and simple
    but has the disadvantage that restarting the CherryPy server will discard this
    data, effectively expiring all sessions. This might be ok for short-lived sessions,
    but if you need a more persistent solution, it is possible to store the session
    information as files (by setting the `tools.sessions.storage_type` configuration
    key to `"file")` or even to a database backend. For more about sessions, see CherryPy's
    online documentation on the subject at [http://cherrypy.org/wiki/CherryPySessions](http://cherrypy.org/wiki/CherryPySessions).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的存储方案是将数据保存在内存中。这既快又简单，但缺点是重启 CherryPy 服务器将丢弃这些数据，实际上会过期所有会话。这可能适用于短暂的会话，但如果需要更持久的解决方案，可以将会话信息存储为文件（通过设置
    `tools.sessions.storage_type` 配置键为 `"file"`）或者甚至存储到数据库后端。有关会话的更多信息，请参阅 CherryPy
    在线文档中的相关内容，网址为 [http://cherrypy.org/wiki/CherryPySessions](http://cherrypy.org/wiki/CherryPySessions)。
- en: 'The various steps in the communication between the client and the server during
    a session are shown in the following illustration:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 会话期间客户端和服务器之间通信的各个步骤在以下插图中有展示：
- en: '![What just happened?](img/3746OS_03_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/3746OS_03_04.jpg)'
- en: 'The bulk of the `logon` module is provided by the `Logon` class. It implements
    several methods (these methods are highlighted in the code listed on the previous
    pages as well):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`logon` 模块的大部分功能由 `Logon` 类提供。它实现了几个方法（这些方法在上一页列出的代码中也被突出显示）：'
- en: '`__init__()` will initialize a `Logon` instance to hold the path to the point
    where this `Logon` instance is mounted on the tree of handlers, together with
    the default URLs to redirect to successful and unsuccessful authentication.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()` 将初始化一个 `Logon` 实例，以保存此 `Logon` 实例在处理程序树中挂载的路径，以及重定向到成功和失败认证的默认URL。'
- en: '`checkpass()` is a static function that takes a username and a password and
    returns `True` if these are a matching pair. It is designed to be overridden by
    a more suitable definition.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkpass()` 是一个静态函数，它接受一个用户名和一个密码，如果这些是匹配的配对，则返回 `True`。它被设计为可以通过更合适的定义来覆盖。'
- en: '`Logon` also exposes three handler methods to the CherryPy engine:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logon` 还向 CherryPy 引擎公开了三个处理程序方法：'
- en: '`index()` is a method that will serve the actual logon screen'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index()` 是一个将实际登录屏幕提供给用户的方法'
- en: '`logon()` is passed the username and password when the user clicks on the logon
    button'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击登录按钮时，`logon()` 会传递用户名和密码
- en: '`logoff()` will expire a session, causing subsequent calls to `checkauth()`
    to redirect the user to the logon screen'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logoff()` 将使会话过期，导致后续对 `checkauth()` 的调用将用户重定向到登录屏幕'
- en: The `Logon` class also contains a number of class variables to hold the HTML
    presented by the `index()` method. Let's look at the methods in detail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logon` 类还包含一些类变量，用于保存 `index()` 方法显示的HTML。让我们详细看看这些方法。'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'And what about security? The `Logon` class we design here has no facilities
    to prevent people from eavesdropping if they have access to the wire that transports
    the HTTP traffic. This is because we transmit the passwords unencrypted. We may
    implement some sort of encryption scheme ourselves, but if your design requires
    some form of protection, it is probably better and easier to communicate over
    a secure HTTPS channel. CherryPy may be configured to use HTTPS instead of HTTP.
    More on it can be found at: [http://cherrypy.org/wiki/ServerObject](http://cherrypy.org/wiki/ServerObject).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于安全性呢？我们在这里设计的 `Logon` 类没有防止人们窃听传输HTTP流量的线缆的设施，如果他们有权访问这些线缆。这是因为我们未加密地传输密码。我们可能自己实现某种加密方案，但如果你的设计需要某种保护形式，通过安全的HTTPS通道进行通信可能更好、更简单。CherryPy
    可以配置为使用HTTPS而不是HTTP。更多相关信息可以在：[http://cherrypy.org/wiki/ServerObject](http://cherrypy.org/wiki/ServerObject)
    找到。
- en: Pop quiz session IDs
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验会话ID
- en: If the client sends a new session ID again and again, wouldn't that fill up
    all storage on the server eventually?
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果客户端不断发送新的会话ID，最终不会填满服务器上的所有存储空间吗？
- en: If the client has cookies disabled, what happens to the generation of session
    IDs?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果客户端禁用了cookie，会话ID的生成会发生什么？
- en: a. The server will stop generating new session IDs, returning the same ID repeatedly
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 服务器将停止生成新的会话ID，反复返回相同的ID
- en: b. The server will stop returning new session IDs
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 服务器将停止返回新的会话ID
- en: c. The server will keep generating and returning new session IDs
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 服务器将继续生成并返回新的会话ID
- en: Serving a logon screen
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供登录屏幕
- en: 'The `index()` method serves the HTML to present the user with a logon screen.
    At its core, this HTML is a`<form>` element with three`<input>` elements: a regular
    text input where the user may enter his/her username, a password input (that will
    hide the characters that are entered in this field), and an`<input>` element that
    has a `hidden` attribute. The`<form>` element has an `action` attribute that holds
    the URL of the script that will process the variables in the form when the user
    clicks the logon button. This URL is constructed to point to the `logon()` method
    of our `Logon` class by appending `/logon` to the path that the `Logon` instance
    was mounted on in the CherryPy tree.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()` 方法将HTML提供给用户，以显示登录屏幕。在其核心，这个HTML是一个 `<form>` 元素，包含三个 `<input>` 元素：一个常规文本输入，用户可以输入他的/她的用户名；一个密码输入（将隐藏在此字段中输入的字符）；以及一个具有
    `hidden` 属性的 `<input>` 元素。《form》元素有一个 `action` 属性，它包含当用户点击登录按钮时将处理表单变量的脚本的URL。此URL通过将
    `/logon` 添加到 `Logon` 实例在CherryPy树中挂载的路径来构造，以指向我们的 `Logon` 类的 `logon()` 方法。'
- en: The`<input>` element we marked as hidden is initialized to hold the URL that
    the user will be redirected to when `logon()` authenticates the user successfully.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标记为隐藏的 `<input>` 元素被初始化为保存用户在 `logon()` 成功验证用户时将被重定向到的URL。
- en: 'The form that makes up the logon screen also contains a tiny piece of JavaScript:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 构成登录界面的表单还包含一小段JavaScript：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It uses jQuery to select the input element that will receive the username and
    gives it focus. By placing the cursor in this field, we save the user the effort
    of pointing and clicking on the username field first before the username can be
    entered. Now he can start typing right away. Note that this code snippet is not
    placed near the end of the document, but right after the`<input>` element to ensure
    execution as soon as the`<input>` element is defined. The logon page is so small
    that this might be irrelevant, but on slow loading pages, key presses might be
    misdirected if we waited to shift the focus until the whole page had loaded.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用jQuery选择将接收用户名的输入元素，并给它聚焦。通过将光标放在这个字段中，我们节省了用户在输入用户名之前先指向并点击用户名字段的努力。现在他可以立即开始输入。请注意，此代码片段不是放在文档的末尾，而是在`<input>`元素之后，以确保在`<input>`元素定义后立即执行。登录页面如此之小，这可能无关紧要，但在页面加载缓慢的情况下，如果等到整个页面加载完毕才切换焦点，按键可能会被误导向。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Be aware that the logon form we construct here has a`<form>` element with an
    `action="GET`" attribute. This works fine, but has a disadvantage: parameters
    passed with a `GET` method are appended to the URL and may end up in the log files
    of the server. This is convenient when debugging, but you might not want that
    for a production environment, as this might leave passwords exposed. The `action`
    attribute can be changed to `POST` though without any change to the Python code
    handling the request as CherryPy takes care of the details. Parameters passed
    to a `POST` method are not logged, so a `POST` method might be better suited to
    a password verification request.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们构建的登录表单有一个带有`action="GET"`属性的`<form>`元素。这没问题，但有一个缺点：使用`GET`方法传递的参数会被附加到URL上，并可能出现在服务器的日志文件中。这在调试时很方便，但可能不适合生产环境，因为这可能会使密码暴露。不过，可以将`action`属性更改为`POST`，而无需更改处理请求的Python代码，因为CherryPy会处理这些细节。传递给`POST`方法的参数不会被记录，因此`POST`方法可能更适合密码验证请求。
- en: Setting up a session
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置会话
- en: The `logon()` method is passed the contents of all the`<input>` elements in
    the form as parameters. The `username` and `password` parameters are passed to
    the `checkpass()` method and if the user's credentials are right, we establish
    a session by associating the username with the authenticated key in our session
    storage with `cherrypy.session['authenticated']=username`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`logon()`方法将表单中所有`<input>`元素的值作为参数传递。`username`和`password`参数传递给`checkpass()`方法，如果用户的凭据正确，我们通过将用户名与我们的会话存储中的认证密钥关联来建立会话，即`cherrypy.session[''authenticated'']=username`。'
- en: This will have the effect that every response sent to the browser will contain
    a cookie with a session ID and any subsequent request to CherryPy that contains
    this cookie again will cause the handler for that request to have access to this
    same session storage.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生这样的效果，即发送到浏览器的每个响应都将包含一个带有会话ID的cookie，并且任何包含此cookie的后续对CherryPy的请求都将导致该请求的处理程序能够访问相同的会话存储。
- en: After successful authentication, `logon()` redirects the user to the return
    page if one was passed to it or to the default page passed to it upon initialization
    of the `Logon` instance. If authentication fails, the user is redirected to a
    non-authorized page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功认证后，`logon()`会将用户重定向到传递给它的返回页面，如果没有传递，则重定向到`Logon`实例初始化时传递的默认页面。如果认证失败，用户将被重定向到非授权页面。
- en: Expiring a session
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过期会话
- en: The `logoff()` method is provided to offer a possibility to actively expire
    a session. By default, a session expires after 60 minutes, but the user might
    want to sign off explicitly, either to make sure that no one sneaks behind his
    keyboard and continues in his name or to log on as a different persona. Therefore,
    you will find, in most applications, a discrete logoff button, often positioned
    in the upper-right corner. This button (or just a link) must point to the URL
    that is handled by the `logoff()` method and will cause the session to be invalidated
    immediately by removing all session data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了`logoff()`方法，以提供主动过期会话的可能性。默认情况下，会话在60分钟后过期，但用户可能希望明确注销，无论是为了确保没有人偷偷摸摸地坐在他的键盘后面继续以他的名义操作，还是为了以不同的身份登录。因此，在大多数应用程序中，你都会找到一个独立的注销按钮，通常位于右上角。此按钮（或只是一个链接）必须指向由`logoff()`方法处理的URL，并且将立即通过删除所有会话数据来使会话无效。
- en: 'Note that we have to take special precautions to prevent the browser from caching
    the response from the `logoff()` method, otherwise it may simply redisplay the
    response from the last time the logoff button was pressed without actually causing
    `logoff()` to be called. Because `logoff()` always raises an `InternalRedirect`
    exception, the actual response comes from a different source. This source, for
    example, the `goaway()` method in the `Root` class must be configured to return
    the correct response headers in order to prevent the web browser from caching
    the result. This is accomplished by configuring the `goaway()` method in `logonapp.py`
    with CherryPy''s expires tool like the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须采取特殊预防措施以防止浏览器缓存 `logoff()` 方法的响应，否则它可能只是简单地重新显示上一次按下注销按钮时的响应，而没有实际上调用
    `logoff()`。因为 `logoff()` 总是引发一个 `InternalRedirect` 异常，实际的响应来自不同的来源。例如，这个来源，`Root`
    类中的 `goaway()` 方法必须配置为返回正确的响应头，以防止网络浏览器缓存结果。这是通过在 `logonapp.py` 中配置 `goaway()`
    方法并使用 CherryPy 的 expires 工具来实现的，如下所示：
- en: '**Chapter3/logonapp.py**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter3/logonapp.py**'
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The highlighted line is where we configure the handler (the `goaway()` method)
    to set expiration headers in the response by assigning a configuration dictionary
    to the `_cp_config` variable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行是我们配置处理程序（`goaway()` 方法）通过将配置字典分配给 `_cp_config` 变量来在响应中设置过期头。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Assigning to a variable that is part of a function might seem odd, but functions
    and methods in Python are just objects and any object may have variables. New
    variables might be assigned to an object even after its definition. Upon calling
    a handler, CherryPy checks if that handler has a `_cp_config` variable and acts
    accordingly. Note that the `@cherrypy.expose` decorator also merely sets the `expose`
    variable on the handler to `true`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量分配给函数的一部分可能看起来很奇怪，但 Python 中的函数和方法只是对象，任何对象都可以有变量。对象定义后，还可以为新变量分配对象。在调用处理程序时，CherryPy
    会检查该处理程序是否有 `_cp_config` 变量，并相应地执行。注意，`@cherrypy.expose` 装饰器也仅仅是将处理程序的 `expose`
    变量设置为 `true`。
- en: Have a go hero adding a logon screen to the spreadsheet application
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让英雄尝试在电子表格应用程序中添加一个登录界面
- en: In the previous chapter, we had created an application that serves a spreadsheet.
    If you wanted to serve this spreadsheet only to authenticated users, what would
    we have to change to use the logon module presented in the previous section?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个提供电子表格的应用程序。如果你只想向经过身份验证的用户提供这个电子表格，我们使用上一节中介绍的登录模块需要做哪些更改？
- en: 'Hint: You need to do three things, one involves mounting an instance of the
    `Logon` class on the CherryPy tree, the other is changing the handler that serves
    the spreadsheet to check for authentication, and finally you need to enable sessions.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你需要做三件事，其中一件涉及到在 CherryPy 树上挂载 `Logon` 类的实例，另一件是更改提供电子表格的处理程序以检查身份验证，最后你需要启用会话。
- en: An example implementation is available as `spreadsheet3.py`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例实现可以作为 `spreadsheet3.py` 提供。
- en: Designing a task list
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计任务列表
- en: Now that we have looked at ways to authenticate the users, let's look at the
    implementation of the task list itself.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了用户身份验证的方法，让我们来看看任务列表本身的实现。
- en: A task list would be unusable if its contents evaporated once the browser was
    closed. We therefore need some way to persistently store these task lists. We
    could use a database and many of the example applications in this book do use
    a database to store data. For this application, we will opt to use the filesystem
    as a storage medium, simply storing tasks as files containing information about
    a task, with separate directories for each user. If we dealt with huge amounts
    of users or very long task lists, the performance of such an implementation probably
    wouldn't suffice, but by using simple files for storage, we won't have to design
    a database schema which saves us quite some time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务列表的内容在浏览器关闭后消失，那么这个任务列表将无法使用。因此，我们需要某种方法来持久化存储这些任务列表。我们可以使用数据库，本书中的许多示例应用程序确实使用数据库来存储数据。对于这个应用程序，我们将选择使用文件系统作为存储介质，简单地将任务存储为包含任务信息的文件，并为每个用户设置单独的目录。如果我们处理大量的用户或非常长的任务列表，这种实现的性能可能不足以满足需求，但通过使用简单的文件进行存储，我们不需要设计数据库模式，这可以节省我们很多时间。
- en: By limiting ourselves to fairly short task lists, our user interface may be
    kept relatively simple as there will be no need for pagination or searching. This
    doesn't mean the user interface shouldn't be easy to use! We will incorporate
    jQuery UI's **datepicker** widget to assist the user with choosing dates and will
    add tooltips to user interface components to provide a shallow learning curve
    of our task list application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制任务列表的长度，我们的用户界面可以保持相对简单，因为不需要分页或搜索。这并不意味着用户界面不应该易于使用！我们将集成jQuery UI的**日期选择器**小部件来帮助用户选择日期，并将工具提示添加到用户界面组件中，以提供我们任务列表应用程序的浅学习曲线。
- en: 'The final requirements more or less define what we understand a task to be
    and what we are supposed to do with it: A task has a description and a due date
    and because it can be marked as done, it should be able to store that fact as
    well. Furthermore, we limit this application to adding and deleting tasks. We
    explicitly do not provide any way to alter a task, except for marking it as done.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最终要求大致定义了我们理解的任务是什么以及我们打算如何处理它：任务有一个描述和一个截止日期，因为它可以被标记为完成，所以它应该能够存储这一事实。此外，我们将此应用程序限制在添加和删除任务。我们明确不提供任何修改任务的方法，除了将其标记为完成。
- en: Time for action running tasklist.py
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行tasklist.py时的行动时间
- en: 'Let''s first have a look at what the application looks like:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看应用程序的外观：
- en: Start up `tasklist.py` from the code directory of this chapter.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本章的代码目录启动`tasklist.py`。
- en: Point your browser to `http://localhost:8080`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的浏览器指向`http://localhost:8080`。
- en: In the logon screen, enter **user** as the username and **secret** as the password.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在登录屏幕上，输入**用户**作为用户名，输入**秘密**作为密码。
- en: You are now presented with a rather stark looking and empty task list:![Time
    for action running tasklist.py](img/3746_3_005.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在看到的是一个看起来相当简陋且空的任务列表：![运行tasklist.py时的行动时间](img/3746_3_005.jpg)
- en: 'You should be able to add a new task by entering a date and a description in
    the input boxes and pressing the add button. Entering a date is facilitated by
    jQuery UI''s datepicker widget that will pop up once you click the input field
    for the date, as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在输入框中输入日期和描述，然后按下添加按钮来添加一个新任务。输入日期可以通过jQuery UI的日期选择器小部件来实现，一旦你点击日期输入字段，它就会弹出，如下截图所示：
- en: '![Time for action running tasklist.py](img/3746_3_006.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![运行tasklist.py时的行动时间](img/3746_3_006.jpg)'
- en: 'Once you have added one or more tasks, you can now either delete those tasks
    by clicking the button with the little trash can icon or mark it as done by clicking
    the button with the check icon. Tasks marked as done have a slightly different
    background color depending on the chosen theme. If you mark a task as done, its
    completion date will be today. You can select a different date by clicking on
    the completion date of a task (displayed as **None** for an unfinished task).
    It will present you with yet another datepicker, after which the selected date
    will be stored as the completion date once the done button is clicked. The following
    screenshot gives an impression of a task list with numerous items:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了一个或多个任务，你现在可以通过点击带有小垃圾桶图标按钮来删除这些任务，或者通过点击带有勾选图标按钮来标记它为完成。标记为完成的任务根据所选主题会有略微不同的背景颜色。如果你将任务标记为完成，其完成日期将会是今天。你可以通过点击任务的完成日期（对于未完成的任务显示为**None**）来选择不同的日期。选择日期后，点击完成按钮，所选日期将被存储为完成日期。以下截图展示了带有众多条目的任务列表：
- en: '![Time for action running tasklist.py](img/3746_3_007.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![运行tasklist.py时的行动时间](img/3746_3_007.jpg)'
- en: There is some hidden magic that might not be immediately obvious. First of all,
    all the tasks are sorted according to their **Due date**. This is done on the
    client-side with the help of some JavaScript and a jQuery plugin, as we will see
    in the section on JavaScript. Also accomplished with some JavaScript are the tooltips.
    Both hovering tooltips on every button and the inline help text inside the`<input>`
    elements are added with the same script. We will examine this in depth.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些隐藏的魔法可能不会立即明显。首先，所有任务都是根据它们的**截止日期**进行排序的。这是通过一些JavaScript和一个jQuery插件在客户端完成的，正如我们将在JavaScript部分看到的那样。同样，工具提示也是通过一些JavaScript完成的。在每个按钮上的悬停工具提示以及`<input>`元素内的内联帮助文本都是通过相同的脚本添加的。我们将对此进行深入探讨。
- en: What just happened?
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: '`tasklist.py` is rather straightforward as it delegates most work to two modules:
    the `logon` module that we encountered in the previous sections and a `task` module
    that deals with displaying and manipulating task lists.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasklist.py`相当直接，因为它将大部分工作委托给了两个模块：我们在前面的章节中遇到的`logon`模块和一个处理显示和操作任务列表的`task`模块。'
- en: The highlighted line in the following code shows the core of the application.
    It starts up CherryPy with a suitable configuration. Note that we enabled the
    sessions tool, so that we can actually use the `logon` module. Also, we construct
    the path to jQuery UI's theme stylesheet in such a way that it depends on the
    `theme` variable to make changing the application's theme simple (second highlight).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中突出显示的行显示了应用程序的核心。它使用合适的配置启动CherryPy。请注意，我们启用了会话工具，这样我们就可以实际使用`logon`模块。此外，我们以这种方式构建jQuery
    UI主题样式表的路径，使其依赖于`theme`变量，以便简化应用程序主题的更改（第二次突出显示）。
- en: 'The instance of the `Root` class that we pass to `quickstart()` creates a simple
    tree:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`quickstart()`的`Root`类实例创建了一个简单的树：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The top level URL `/` returns the same content as `/login` by calling the `index()`
    method of the `Logon` instance. We could have used an `InternalRedirect` exception,
    but this is just as simple. The paths starting with `/task` are all handled by
    an instance of the `Task` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最高级URL `/`通过调用`Logon`实例的`index()`方法返回与`/login`相同的内文。我们本可以使用`InternalRedirect`异常，但这同样简单。以`/task`开头的路径都由`Task`类的一个实例处理：
- en: '**Chapter3/tasklist.py**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/tasklist.py**'
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Python: the task module'
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python：任务模块
- en: The `task` module is implemented in the file `task.py`. Let's look at the parts
    that make up this file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`task`模块在`task.py`文件中实现。让我们看看构成这个文件的各个部分。'
- en: Time for action implementing the task module
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现任务模块的行动时间
- en: Have a look at the Python code in `task.py:`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`task.py`中的Python代码：
- en: '**Chapter3/task.py**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/task.py**'
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This first part illustrates Python''s "batteries included" philosophy nicely:
    besides the `cherrypy` module and our own `logon` module, we need quite a bit
    of specific functionality. For example, to generate unique identifiers, we use
    the `uuid` module and to manipulate dates, we use the `datetime` module. All of
    this functionality is already bundled with Python, saving us an enormous amount
    of development time. The next part is the definition of the basic HTML structure
    that will hold our task list:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分很好地展示了Python的“内置电池”哲学：除了`cherrypy`模块和我们的`logon`模块之外，我们还需要相当多的特定功能。例如，为了生成唯一的标识符，我们使用`uuid`模块，为了操作日期，我们使用`datetime`模块。所有这些功能都已经包含在Python中，为我们节省了大量的开发时间。下一部分是定义将包含我们的任务列表的基本HTML结构：
- en: '**Chapter3/task.py**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/task.py**'
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again the structure is simple, but besides the themed stylesheet needed by jQuery
    UI (and reused by the elements we add to the page), we need an additional stylesheet
    specific to our task list application. It defines specific layout properties for
    the elements that make up our task list (first highlight). The highlighted`<script>`
    elements show that besides the jQuery and jQuery UI libraries, we need some additional
    libraries. Each of them deserves some explanation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结构再次很简单，但除了jQuery UI所需的主题样式表（以及我们添加到页面上的元素重用的样式表）之外，我们还需要一个针对我们的任务列表应用程序的特定样式表。它定义了构成我们的任务列表的元素的具体布局属性（首先突出显示）。突出显示的`<script>`元素表明，除了jQuery和jQuery
    UI库之外，我们还需要一些额外的库。每个库都值得解释。
- en: What just happened?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The first JavaScript library is `sort.js,` a code snippet from James Padolsey
    (http://james.padolsey.com/tag/plugins/) that provides us with a plugin that allows
    us to sort HTML elements. We need this to present the list of tasks sorted by
    their due date.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个JavaScript库是`sort.js`，这是James Padolsey（http://james.padolsey.com/tag/plugins/）的一个代码片段，它为我们提供了一个插件，允许我们排序HTML元素。我们需要这个插件来按截止日期排序任务列表。
- en: The second is `tooltip.js` that combines a number of techniques from various
    sources to implement tooltips for our buttons and inline labels for our`<input>`
    elements. There are a number of tooltip plugins available for jQuery, but writing
    our own provides us with some valuable insights so we will examine this file in
    depth in a later section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是 `tooltip.js`，它结合了来自多个来源的多种技术来实现我们的按钮的提示框以及`<input>`元素的行内标签。jQuery有很多可用的提示框插件，但编写我们自己的插件可以给我们提供一些有价值的见解，因此我们将在后面的部分深入探讨这个文件。
- en: The last one is `tasklist.js`. It employs all the JavaScript libraries and plugins
    to actually style and sort the elements in the task list.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是 `tasklist.js`。它使用了所有的 JavaScript 库和插件来实际样式化和排序任务列表中的元素。
- en: 'The next part of `task.py` determines the directory we''re running the application
    from. We will need this bit of information because we store individual tasks as
    files located relative to this directory. The `gettaskdir()` function takes care
    of determining the exact path for a given username (highlighted). It also creates
    the `taskdir` directory and a sub directory with a name equal to username, if
    these do not yet exist with the `os.makedirs()` function (notice the final ''s''
    in the function name: this one will create all intermediate directories as well
    if they do not yet exist):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`task.py` 的下一部分确定了我们从哪里运行应用程序的目录。我们需要这部分信息，因为我们把单个任务作为文件存储在这个目录的相对位置。`gettaskdir()`
    函数负责确定给定用户名的确切路径（突出显示）。如果这些目录还不存在，它还会使用 `os.makedirs()` 函数创建 `taskdir` 目录和以用户名命名的子目录（注意函数名中的最后一个
    ''s''：如果它们还不存在，这个函数将创建所有中间目录）：'
- en: '**Chapter3/task.py**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/task.py**'
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Task` class is where the handlers are defined that CherryPy may use to
    show and manipulate the task list. The `__init__()` method stores a path to a
    location that provides the user with a possibility to end a session. This path
    is used by other methods to create a suitable logoff button.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 类定义了 CherryPy 可能用来显示和操作任务列表的处理程序。`__init__()` 方法存储了一个位置路径，用户可以通过它结束会话。这个路径被其他方法用来创建合适的注销按钮。'
- en: The `index()` method will present the user with an overview of all his/her tasks
    plus an extra line where a new task can be defined. As we have seen, each task
    is adorned with buttons to delete a task or mark it as done. The first thing we
    do is check whether the user is authenticated by calling the `checkauth()` function
    from our `logon` module (highlighted). If this call returns, we have a valid username,
    and with that username, we figure out where to store the tasks for this user.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()` 方法将向用户展示所有任务以及一个额外行，可以在其中定义新任务。正如我们所看到的，每个任务都附有删除任务或将其标记为完成的按钮。我们首先通过调用
    `logon` 模块中的 `checkauth()` 函数来检查用户是否已认证（突出显示）。如果这个调用返回，我们就有一个有效的用户名，然后我们可以确定存储该用户任务的位置。'
- en: 'Once we know this directory, we use the `glob()` function from the Python `glob`
    module to retrieve a list of files with a `.task` extension. We store that list
    in the `tasklist` variable:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道这个目录，我们就使用 Python `glob` 模块的 `glob()` 函数检索具有 `.task` 扩展名的文件列表。我们将这个列表存储在
    `tasklist` 变量中：
- en: '**Chapter3/task.py**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/task.py**'
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we create a `tasks` variable that will hold a list of strings that we
    will construct when we iterate over the list of tasks. It is initialized with
    some elements that together form the header of our task list. It contains, for
    example, a small form with a logoff button and the headers for the columns above
    the list of tasks. The next step is to iterate over all files that represent a
    task (highlighted) and create a form with suitable content together with delete
    and done buttons.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `tasks` 变量，它将保存我们在遍历任务列表时构建的字符串列表。它使用一些元素初始化，这些元素共同构成了任务列表的标题。例如，它包含一个带有注销按钮的小表单以及列表上方列的标题。下一步是遍历表示任务的全部文件（突出显示），并创建一个带有适当内容以及删除和完成按钮的表单。
- en: 'Each `.task` file is structured in a way that is consistent with Microsoft
    Windows `.ini` files. Such files can be manipulated with Python''s `configparser`
    module. The `.task` file is structured as a single `[task]` section with three
    possible keys. This is an example of the format:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `.task` 文件的结构与 Microsoft Windows 的 `.ini` 文件一致。这些文件可以使用 Python 的 `configparser`
    模块进行操作。`.task` 文件结构为一个 `[task]` 部分，包含三个可能的键。这是一个格式示例：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we initialize a `configparser` object, we pass it a dictionary with default
    values in case any of these keys is missing. The `configparser` will read a file
    when we pass an open file descriptor to its `readfp()` method. The value associated
    with any key in a given section may then be retrieved with the `get()` method
    that will take a section and a key as parameters. If the key is missing, it supplies
    the default if that was provided upon initialization. The second highlighted line
    shows how this is used to retrieve the values for the `description` key.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化一个`configparser`对象时，我们传递给它一个包含默认值的字典，以防任何这些键缺失。当我们将打开的文件描述符传递给其`readfp()`方法时，`configparser`会读取一个文件。然后，可以使用`get()`方法检索给定部分中任何键的值，该方法将部分和键作为参数。如果键缺失，它将提供初始化时提供的默认值。第二个突出显示的行显示了如何使用它来检索`description`键的值。
- en: 'Next, we construct a form for each `.task` file. It contains read-only`<input>`
    elements to display the **Due date, Description**, and the completion date plus
    buttons to delete the task or mark it as done. When these buttons are clicked
    the contents of the form are passed to the `/task/mark` URL (handled by the `mark()`
    method). The method needs to know which file to update. Therefore, it is passed
    a hidden value: the basename of the file. That is, the filename without any leading
    directories and stripped of its `.task` extension:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个`.task`文件构建一个表单。它包含只读`<input>`元素来显示**截止日期、描述**和完成日期，以及删除任务或标记为完成的按钮。当点击这些按钮时，表单的内容会传递到`/task/mark`
    URL（由`mark()`方法处理）。该方法需要知道要更新哪个文件。因此，它被传递一个隐藏值：文件的基名。也就是说，没有前导目录的文件名，并且去除了其`.task`扩展名：
- en: '**Chapter3/task.py**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter3/task.py**'
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, we append one extra form with the same type of input fields for **Due
    date** and **Description** but this time, not marked as read-only. This form has
    a single button that will submit the contents to the `/task/add` URL. These will
    be handled by the `add()` method. The actual content returned by the `index()`
    method consists of all these generated lines joined together and embedded in the
    HTML of the `base_page` variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个具有相同类型输入字段（**截止日期**和**描述**）的额外表单，但这次没有标记为只读。这个表单有一个单独的按钮，会将内容提交到`/task/add`
    URL。这些将通过`add()`方法处理。`index()`方法实际返回的内容是由所有这些生成的行连接在一起，并嵌入到`base_page`变量的HTML中。
- en: Adding new tasks
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新任务
- en: New tasks are created by the `add()` method. Besides the value of the add button
    (which is not relevant), it will take a `description` and a `duedate` as parameters.
    To prevent accidents, it first checks if the user is authenticated, and if so,
    it determines what the `taskdir` for this user is.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 新任务是通过`add()`方法创建的。除了添加按钮的值（这并不相关）之外，它还将接受一个`description`和一个`duedate`作为参数。为了防止意外，它首先检查用户是否已认证，如果是，它确定这个用户的`taskdir`是什么。
- en: We are adding a new task so we want to create a new file in this directory.
    To guarantee that it has a unique name, we construct this filename from the path
    to this directory and a globally unique ID object provided by Python's `uuid()`
    function from the `uuid` module. The `.hex()` method of a `uuid` object returns
    the ID as a long string of hexadecimal numbers that we may use as a valid filename.
    To make the file recognizable to us as a task file, we append the `.task` extension
    (highlighted).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在添加一个新任务，因此我们想要在这个目录中创建一个新文件。为了保证它有一个唯一的名称，我们从这个目录的路径和Python的`uuid()`函数从`uuid`模块提供的全局唯一ID对象构造这个文件名。`uuid`对象的`.hex()`方法返回一个由十六进制数字组成的长字符串ID，我们可以将其用作有效的文件名。为了使我们能够识别这个文件为任务文件，我们添加了`.task`扩展名（已突出显示）。
- en: 'Because we want our file to be readable by a `configparser` object, we will
    create it with a `configparser` object to which we add a `task` section with the
    `add_section()` method and `description` and `duedate` keys with the `set()` method.
    Then we open a file for writing and use the open file handle to this file within
    a context manager (the `with` clause), thereby ensuring that if anything goes
    wrong when accessing this file, it will be closed and we will proceed to redirect
    the user to that list of tasks again. Note that we use a relative URL consisting
    of a single dot to get us the index page. Because the `add()` method handles a
    URL like `/task/add` redirecting to ''.'' (the single dot), will mean the user
    is redirected to `/task/`, which is handled by the `index()` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望我们的文件可以被`configparser`对象读取，我们将使用`configparser`对象创建它，并向其中添加一个`task`部分，使用`add_section()`方法，并使用`set()`方法添加`description`和`duedate`键。然后我们打开一个用于写入的文件，并使用上下文管理器（`with`子句）中的文件句柄来操作该文件，从而确保如果在访问此文件时发生任何错误，它将被关闭，我们将再次将用户重定向到那个任务列表。请注意，我们使用由单个点组成的相对URL来获取索引页面。因为`add()`方法处理类似`/task/add`的URL，重定向到`.`（单个点）将意味着用户将被重定向到`/task/`，这由`index()`方法处理：
- en: '**Chapter3/task.py**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/task.py**'
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Deleting a task
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除任务
- en: Deleting or marking a task as done are both handled by the `mark()` method.
    Besides an ID (the basename of an existing `.task` file), it takes `duedate, description`,
    and `completed` parameters. It also takes optional `done` and `delete` parameters,
    which are set depending on whether the done or delete buttons are clicked respectively.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 删除或标记任务为完成都由`mark()`方法处理。除了ID（现有`.task`文件的基名）外，它还接受`duedate`、`description`和`completed`参数。它还接受可选的`done`和`delete`参数，这些参数根据是否点击了完成或删除按钮而设置。
- en: Again, the first actions are to establish whether the user is authenticated
    and what the corresponding task directory is. With this information, we can construct
    the filename we will act on. We take care to check the validity of the `id` argument.
    We expect it to be a string of hexadecimal characters only and one way to verify
    this is to convert it using the `int()` function with 16 as the base argument.
    This way, we prevent malicious users from passing a file path to another user's
    directory. Even though it is unlikely that a 32 character random string can be
    guessed, it never hurts to be careful.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，首先的行动是确定用户是否已认证以及相应的任务目录是什么。有了这些信息，我们可以构建我们将要操作的文件名。我们注意检查`id`参数的有效性。我们期望它只包含十六进制字符的字符串，一种验证方法是将它使用`int()`函数转换，以16为基数参数。这样，我们防止恶意用户将文件路径传递给另一个用户的目录。尽管32个字符的随机字符串很难猜测，但小心总是好的。
- en: The next step is to see if we are acting on a click on the done button (highlighted
    in the following code). If we are, we read the file with a `configparser` object
    and update its `completed` key.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是查看我们是否正在对完成按钮的点击进行操作（以下代码中突出显示）。如果是，我们使用`configparser`对象读取文件，并更新其`completed`键。
- en: The `completed` key is either the date that we were passed as the `completed`
    parameter or the current date if that parameter was either empty or `None`. Once
    we have updated the `configparser` object, we write it back again to the file
    with the `write()` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`completed`键要么是我们作为`completed`参数传递的日期，要么是如果该参数为空或`None`时的当前日期。一旦我们更新了`configparser`对象，我们再次使用`write()`方法将其写回文件。'
- en: 'Another possibility is that we are acting on a click on the delete button;
    in that case, the `delete` parameter is set. If so, we simply delete the file
    with the `unlink()` function from Python''s `os` module:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是我们正在对删除按钮的点击进行操作；在这种情况下，将设置`delete`参数。如果是这样，我们只需使用Python的`os`模块中的`unlink()`函数删除文件：
- en: '**Chapter3/task.py**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/task.py**'
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'JavaScript: tasklist.js'
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'JavaScript: tasklist.js'
- en: The buttons we present the end user need to be configured to respond to clicks
    in an appropriate manner and it would be nice if these buttons showed some intuitive
    icons as well. This is what we will take care of in `tasklist.js`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供给最终用户的按钮需要配置为以适当的方式响应用户的点击，并且如果这些按钮显示一些直观的图标那就更好了。这就是我们在`tasklist.js`中要处理的事情。
- en: Time for action styling the buttons
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为按钮添加样式的时间
- en: 'The work done by `tasklist.js` is mainly concerned with styling the`<button>`
    elements and adding tooltips and inline labels to`<input>` elements. The results
    so far are shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasklist.js`完成的工作主要涉及样式化`<button>`元素，并为`<input>`元素添加工具提示和内联标签。到目前为止的结果如下截图所示：'
- en: '![Time for action styling the buttons](img/3746_3_009.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间：按钮样式化](img/3746_3_009.jpg)'
- en: What just happened?
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: As can be seen in the first line of `tasklist.js` (code starts on the next page),
    the work to be done is scheduled after loading the complete document by passing
    it to jQuery's `$(document).ready()` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如`tasklist.js`的第一行所示（代码从下一页开始），要完成的工作是在加载完整文档后通过传递给jQuery的`$(document).ready()`函数来安排。
- en: The first step is to add to any element with a `header` class the `ui-widget`
    and `ui-widget-header` classes as well. This will cause these elements to be styled
    in a way that is consistent with the chosen theme.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是向任何带有`header`类的元素添加`ui-widget`和`ui-widget-header`类。这将使这些元素以与所选主题一致的方式被样式化。
- en: Then we configure the add button (or rather any element with the `add-button`
    class) as a jQuery UI button widget. The option object passed to it will configure
    it to show no text, but just a single icon depicting a thick plus sign. We also
    add an extra function to the click handler of the button that checks any element
    marked with the `inline-label` class to see if its contents are identical to the
    contents of its title attribute. If that is the case, we set the contents to the
    empty string, as this indicates that the user hasn't filled in anything in this
    element and we do not want to store the text of the inline label as the content
    of our new task (more about this in the section on tooltips). Note that we do
    nothing to prevent propagation of the click event, so if this button is of the
    `submit` type (and our add button is) the `submit` action will still be performed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们配置添加按钮（或者更确切地说，任何带有`add-button`类的元素）作为jQuery UI按钮小部件。传递给它的选项对象将配置它不显示文本，而只显示一个表示粗加号的单一图标。我们还向按钮的点击处理器中添加了一个额外的函数，该函数检查任何带有`inline-label`类的元素，看其内容是否与其`title`属性的内容相同。如果是这样，我们将内容设置为空字符串，因为这表示用户没有在这个元素中填写任何内容，我们不希望将内联标签的文本存储为我们新任务的（关于这一点，请参阅关于提示的章节）。请注意，我们没有做任何防止点击事件传播的事情，所以如果这个按钮是`submit`类型（并且我们的添加按钮是），`submit`操作仍然会被执行。
- en: All elements with the `del-button` class (highlighted) are then styled with
    an icon of a trash can. The buttons also receive an extra click handler that will
    remove the disabled attribute from their siblings (the input fields in the same
    form) to make sure the submit action will receive the contents even from fields
    that are marked as disabled.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所有带有`del-button`类（突出显示）的元素随后被应用了一个垃圾桶的图标。按钮还接收一个额外的点击处理器，该处理器将从它们的兄弟元素（同一表单中的输入字段）中移除禁用属性，以确保提交操作能够接收到标记为禁用的字段的内容。
- en: Next, the other`<button>` elements are adorned with an appropriate icon and
    to any text or password`<input>` element we add a `textinput` class to mark it
    for the tooltip library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，其他`<button>`元素被添加了适当的图标，并且对于任何文本或密码`<input>`元素，我们添加一个`textinput`类来标记它以便于提示库使用。
- en: In the second highlighted line, we encounter jQuery UI's datepicker widget.
    The datepicker widget greatly simplifies entering dates for the user and is now
    more or less a staple item in any web application or website that asks the user
    to enter a date. jQuery UI's datepicker is very straightforward to use, yet comes
    with a host of configuration options (all of them documented at [http://jqueryui.com/demos/datepicker/)](http://jqueryui.com/demos/datepicker/)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行突出显示的代码中，我们遇到了jQuery UI的日期选择器小部件。日期选择器小部件极大地简化了用户输入日期的过程，并且现在在要求用户输入日期的任何Web应用程序或网站上几乎是标准配置。jQuery
    UI的日期选择器使用起来非常简单，但提供了大量的配置选项（所有这些选项都有文档记录在[http://jqueryui.com/demos/datepicker/](http://jqueryui.com/demos/datepicker/)）。
- en: We use the `dateFormat` option to configure the datepicker to store dates as
    YYYY-MM-DD. Datepicker has a number of predefined formats and this one happens
    to be an international standard as well as a suitable format to sort dates in
    a simple way. We also configure the datepicker to call a function when the user
    closes the datepicker. This function removes any `inline-label` class, preventing
    the newly entered date to appear in the colors associated with any inline label
    (as we see later, when we look at `tasklist.css`, we style the colors of any element
    with an `inline-label` class in a distinct way).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`dateFormat`选项来配置日期选择器，以便将日期存储为YYYY-MM-DD格式。日期选择器有许多预定义的格式，而这个格式恰好是一个国际标准，并且适合以简单的方式排序日期。我们还配置了日期选择器，当用户关闭日期选择器时调用一个函数。这个函数会移除任何`inline-label`类，防止新输入的日期出现在与任何内联标签相关的颜色中（正如我们稍后看到的，当查看`tasklist.css`时，我们以独特的方式为带有`inline-label`类的任何元素的样式设置颜色）。
- en: Earlier, we indicated that we wanted to present the list of tasks ordered by
    their due date. We therefore apply the `sort()` plugin from `sort.js` to all`<input>`
    elements with a `duedate` class. `sort()` takes two arguments. The first one is
    a comparison function that is passed two elements to compare. In our case, that
    will be`<input>` elements that contain a date in the YYYY-MM-DD format, so we
    can simply compare the values of these elements as text and return plus or minus
    one. The second argument is a function that takes no arguments and should return
    the element to be sorted. The input element with the due date is available as
    the `this` variable within this function and we use it to return the parent of
    the input element. This parent will be the`<form>` element that encloses it and
    because we represent each task as a form, we want those forms to be sorted, not
    just the`<input>` elements inside these forms.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到过我们想要按截止日期顺序展示任务列表。因此，我们将 `sort.js` 中的 `sort()` 插件应用于所有具有 `duedate` 类的
    `<input>` 元素。`sort()` 函数接受两个参数。第一个参数是一个比较函数，它接收两个元素进行比较。在我们的情况下，那将是包含 YYYY-MM-DD
    格式日期的 `<input>` 元素，因此我们可以简单地比较这些元素的值作为文本，并返回正负一。第二个参数是一个不接受任何参数的函数，应该返回要排序的元素。具有截止日期的输入元素作为该函数内的
    `this` 变量可用，我们使用它来返回输入元素的父元素。这个父元素将是包含它的 `<form>` 元素，因为我们把每个任务表示为一个表单，我们希望这些表单被排序，而不仅仅是这些表单内的
    `<input>` 元素。
- en: 'The last set of actions in `tasklist.js` adds a `disabled` attribute to any`<input>`
    element within an element that has a `done` class and disables any done button.
    This will ensure that tasks marked as done cannot be altered:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasklist.js` 中的最后一组操作将 `disabled` 属性添加到具有 `done` 类的元素内的任何 `<input>` 元素，并禁用任何完成按钮。这将确保标记为完成的任务不能被更改：'
- en: '**Chapter3/tasklist.js**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/tasklist.js**'
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'JavaScript: tooltip.js'
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'JavaScript: tooltip.js'
- en: '`tooltip.js` is a bit of a misnomer as its most interesting part is not about
    tooltips but inline labels. Inline labels are a way to convey helpful information
    not by means of a hovering tooltip, but by putting text inside text input elements.
    This text then disappears when the user clicks the input field and starts typing.
    There are many implementations to be found on the web, but the most clear and
    concise one I found is from [http://trevordavis.net/blog/tutorial/jquery-inline-form-labels/](http://trevordavis.net/blog/tutorial/jquery-inline-form-labels/).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`tooltip.js` 这个名字有点误导，因为它最有趣的部分并不是关于工具提示，而是内联标签。内联标签是一种通过将文本放在文本输入元素内部来传达有用信息的方式，而不是通过悬停工具提示。当用户点击输入字段并开始输入时，这些文本就会消失。网上可以找到许多实现方式，但我找到的最清晰、最简洁的一个来自[http://trevordavis.net/blog/tutorial/jquery-inline-form-labels/](http://trevordavis.net/blog/tutorial/jquery-inline-form-labels/)。'
- en: Time for action implementing inline labels
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现内联标签的时间
- en: 'Take a look again at the screenshot of the list of tasks:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看任务列表的截图：
- en: '![Time for action implementing inline labels](img/3746_3_011.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![实现内联标签的时间](img/3746_3_011.jpg)'
- en: The highlighted parts show what we mean by inline labels. The input fields display
    some helpful text to indicate their use and when we click such a field, this text
    will disappear and we can enter our own text. If we abort the input by clicking
    outside the input field when we have not yet entered any text, the inline label
    is shown again.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮部分显示了我们所指的内联标签。输入字段显示一些有用的文本来指示其用途，当我们点击这样的字段时，这些文本将消失，我们可以输入自己的文本。如果我们点击输入字段外的地方而没有输入任何文本就取消输入，内联标签将再次显示。
- en: What just happened?
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: '`tooltip.js` shows a number of important concepts: First how to apply a function
    to each member of a selection (highlighted). In this case, we apply the function
    to all`<input>` elements that have a `title` attribute. Within the function passed
    to the `each()` method, the selected`<input>` element is available in the `this`
    variable. If the content of an`<input>` element is completely empty, we change
    its content to that of the `title` attribute and add the class `inline-label`
    to the`<input>` element. That way, we can style the text of an inline label differently
    than the regular input text if we like, for example, a bit lighter to make it
    stand out less.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`tooltip.js` 展示了一些重要的概念：首先是如何将一个函数应用于选择集的每个成员（高亮显示）。在这种情况下，我们将该函数应用于所有具有 `title`
    属性的 `<input>` 元素。在传递给 `each()` 方法的函数中，选中的 `<input>` 元素在 `this` 变量中可用。如果一个 `<input>`
    元素的全部内容为空，我们将其内容更改为 `title` 属性的内容，并给 `<input>` 元素添加 `inline-label` 类。这样，如果我们愿意，我们可以以不同的方式样式化内联标签的文本，例如，使其稍微轻一些，以便不那么突出。'
- en: The second concept shown is binding to the **focus** and **blur** events. When
    the user clicks an`<input>` element or uses the *Tab* key to navigate to it, it
    gains focus. We can act upon this event by passing a function to the `focus()`
    method. In this function, the`<input>` element that gains focus is again available
    in the `this` variable and we check if the content of this`<input>` element is
    equal to the content of its `title` attribute. If this is true, the user hasn't
    yet changed the content, so we empty this element by assigning an empty string
    to it (highlighted).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的第二个概念是绑定到**焦点**和**模糊**事件。当用户点击`<input>`元素或使用*Tab*键导航到它时，它会获得焦点。我们可以通过向`focus()`方法传递一个函数来对此事件进行操作。在这个函数中，获得焦点的`<input>`元素再次在`this`变量中可用，我们检查这个`<input>`元素的内容是否与其`title`属性的内容相等。如果是这样，那么用户尚未更改内容，因此我们通过将空字符串分配给它来清空这个元素（突出显示）。
- en: The same line shows another important concept in jQuery, that of **chaining**.
    Most jQuery methods (like `val()` in this example) return the selection they act
    upon, allowing additional methods to be applied to the same selection. Here we
    apply `removeClass()` to remove the `inline-label` class to show the text the
    user is typing in the regular font and color for this`<input>` element.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同一行还展示了jQuery中的另一个重要概念，即**链式调用**。大多数jQuery方法（如本例中的`val()`）返回它们所作用的选择，允许对同一选择应用其他方法。在这里，我们应用`removeClass()`来移除`inline-label`类，以显示用户在此`<input>`元素中输入的文本，并使用常规字体和颜色。
- en: We also act on losing focus (commonly referred to as *blurring)*, for example,
    when the user clicks outside the`<input>` element or uses the *Tab* key to navigate
    to another element. We therefore pass a function to the `blur()` method. This
    function checks whether the content of the`<input>` element is empty. If so, then
    the user hasn't entered anything and we insert the content of the `title` attribute
    again and mark the element with an `inline-label` class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还处理失去焦点的情况（通常称为*模糊*），例如，当用户点击`<input>`元素外部或使用*Tab*键导航到另一个元素时。因此，我们向`blur()`方法传递一个函数。这个函数检查`<input>`元素的内容是否为空。如果是这样，那么用户没有输入任何内容，我们再次插入`title`属性的内容，并用`inline-label`类标记该元素。
- en: '**Chapter3/tooltip.js**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/tooltip.js**'
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'CSS: tasklist.css'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'CSS: tasklist.css'
- en: Without some additional styling to tweak the layout, our tasklist application
    would look a bit disheveled, as seen before.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一些额外的样式来调整布局，我们的任务列表应用程序看起来可能会有些杂乱，就像之前看到的那样。
- en: Our main challenges are aligning all columns and moving all buttons consistently
    to the right. All elements in our HTML markup that make up the columns are marked
    with a class to indicate that they belong in the left, middle, or right column.
    All we have to do to align these columns is to set their width based on their
    class (highlighted).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要挑战是对齐所有列并将所有按钮一致地移动到右侧。构成HTML标记中列的所有元素都带有类来表示它们属于左侧、中间或右侧列。我们只需根据它们的类设置它们的宽度（突出显示）即可对齐这些列。
- en: 'The largest part of the rest of `tasklist.css` is concerned with either floating
    elements to the right (like buttons) or to the left (containers, like the`<div>`
    element with the `id` attribute `content)`. Most containers are not only floated
    to the left, but also explicitly set to a width of 100 percent to make sure they
    fill the element they are contained in themselves. This is not always necessary
    to position them correctly, but if we do not take care, the background color of
    the enclosing element might show if an element doesn''t fill its enclosing element:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasklist.css`的其余大部分内容涉及将元素浮动到右侧（如按钮）或左侧（容器，如具有`id`属性`content`的`<div>`元素）。大多数容器不仅向左浮动，而且明确设置为100%的宽度，以确保它们填充它们所包含的元素。这并不总是必要的，但如果我们不加以注意，如果元素没有填满其包含的元素，包围元素的背景色可能会显示出来：'
- en: '**Chapter3/tasklist.css**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3章/tasklist.css**'
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that our stylesheet only deals with measurements and font sizes. Any coloring
    is applied by the chosen jQuery UI theme. With the styles applied, the application
    looks a fair bit tidier:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的样式表仅处理测量和字体大小。任何着色都是通过选择的jQuery UI主题应用的。应用了样式后，应用程序看起来整洁多了：
- en: '![CSS: tasklist.css](img/3746_3_010.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![CSS: tasklist.css](img/3746_3_010.jpg)'
- en: Pop quiz styling screen elements
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验样式屏幕元素
- en: In `tasklist.js`, we explicitly configured all buttons to show just an icon
    without any text. But what if we wanted to show both an icon and some text, what
    would we do?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasklist.js`中，我们明确配置了所有按钮仅显示图标而不显示任何文本。但如果我们想同时显示图标和一些文本，我们该怎么办？
- en: If we didn't set the width of the form that makes up a task explicitly to 100
    percent, what would the biggest disadvantage be?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们没有明确设置组成任务的表单的宽度为100%，最大的缺点会是什么？
- en: Have a go hero changing the date format of a datepicker
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下：更改日期选择器的日期格式
- en: 'To display the date as ISO 8701 (or YYYY-MM-DD) isn''t everybody''s idea of
    a readable date format. For many people, the default mm/dd/yy is far more readable.
    How would you change `tasklist.js` to display the tasks with this default date
    format? Hint: it isn''t enough to leave out the `dateFormat` option when calling
    the `datepicker()` plugin, you also need to change the comparator function to
    sort the tasks in a suitable manner.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将日期显示为ISO 8701（或YYYY-MM-DD）并不是所有人的可读日期格式。对许多人来说，默认的mm/dd/yy格式要容易阅读得多。你将如何修改
    `tasklist.js` 以使用这种默认日期格式显示任务？提示：仅当调用 `datepicker()` 插件时省略 `dateFormat` 选项是不够的，你还需要更改比较函数以适当地排序任务。
- en: 'For the impatient or curious readers: a sample implementation is available
    as `tasklist2.js` (start up `tasklist2.py` to see the effect).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不耐烦或好奇的读者：一个示例实现作为 `tasklist2.js` 提供（启动 `tasklist2.py` 以查看效果）。
- en: Have a go hero serving a task list from a different URL
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下：从一个不同的URL提供任务列表
- en: One way to measure how reusable a piece of code is, is by using it in a situation
    that you did not yet have in mind when you designed it. Of course, that doesn't
    mean our task module should be able to function as a control application for an
    automobile construction plant, but what if we would like it to be part of a larger
    suite of applications served from the same root? Would we have to change anything?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量一段代码的可重用性的一个方法，是在你设计它时还没有考虑到的情境中使用它。当然，这并不意味着我们的任务模块应该能够作为一个汽车制造厂的控制系统应用程序，但如果我们希望它成为从同一根目录提供的一组应用程序的一部分，我们需要做些什么改变吗？
- en: Say we want to serve the tasklist application from the URL [/apps/task](http:///apps/task)
    instead of [/task](http:///task), what would we have to change?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从URL [/apps/task](http:///apps/task) 而不是 [/task](http:///task) 提供任务列表应用程序，我们需要做哪些更改？
- en: 'Hint: In CherryPy, you can create a tree of URLs by assigning object instances
    to class variables of the object instance that is passed to the `quickstart()`
    method.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在CherryPy中，你可以通过将对象实例分配给传递给 `quickstart()` 方法的对象实例的类变量来创建一个URL树。
- en: A possible implementation can be found in `tasklistapp.py`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的实现可以在 `tasklistapp.py` 中找到。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned a lot in this chapter about session management and storing persistent
    information on the server. Specifically, we saw how to design a tasklist application
    and implement a logon screen. What a session is and how this allows us to work
    with different users at the same time and how to interact with the server, and
    add or delete tasks. We also learned how to make entering dates attractive and
    simple with jQuery UI's datepicker widget and how to style button elements and
    provide tooltips and inline labels to input elements.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于会话管理和在服务器上存储持久信息的大量内容。具体来说，我们看到了如何设计任务列表应用程序并实现登录界面。我们了解了会话是什么，以及它是如何使我们能够同时与不同用户工作的，以及如何与服务器交互、添加或删除任务。我们还学习了如何使用jQuery
    UI的日期选择器小部件使输入日期变得吸引人且简单，以及如何对按钮元素进行样式化，并为输入元素提供工具提示和内联标签。
- en: Now that you know a little bit more about storing data on the server, you might
    wonder if storing information in plain files on the server filesystem is the most
    convenient solution. In many cases, it isn't and a database might be more suitable
    which is the topic of the next chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对在服务器上存储数据有了更多了解，你可能想知道在服务器文件系统上以纯文件形式存储信息是否是最方便的解决方案。在许多情况下，这并不是最佳选择，可能需要一个数据库，这正是下一章的主题。
