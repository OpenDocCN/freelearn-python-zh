<html><head></head><body><div><div><div><div><h1 class="title"><a id="appA"/>Appendix A. Answers to Pop Quizes</h1></div></div></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec97"/>Chapter 2</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec122"/>Pop quiz – doctest syntax</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Test expression always start with <code class="literal">&gt;&gt;&gt;</code>.</li><li class="listitem">Continuation on lines always start with ...</li><li class="listitem">The expected output begins immediately after the expression, and continues until the next blank line.</li><li class="listitem">By using the normalize whitespace directive.</li><li class="listitem">doctest ignores everything between the <code class="literal">Traceback (most recent last call)</code>.</li><li class="listitem">All of the later code within the same text file can see the variable.</li><li class="listitem">We care because tests are supposed to be isolated from each other, and if two tests use the same variable, they can influence each others' results.</li><li class="listitem">We can represent that section with an ellipsis(<code class="literal">...</code>) in the expected output.</li></ol></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec98"/>Chapter 3</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec123"/>Pop quiz – understanding units</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">3 units exist: <code class="literal">__init__</code>, <code class="literal">method1</code> and <code class="literal">method2</code>.</li><li class="listitem">Both <code class="literal">method1</code> and <code class="literal">method2</code> assume the correct operation of <code class="literal">__init__</code>, and additionally <code class="literal">method2</code> assumes the correct operation of <code class="literal">method1</code>.</li><li class="listitem">Tests for <code class="literal">method2</code> would need to use a fake <code class="literal">method1</code>.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec124"/>Pop quiz – unit testing during design</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The tests we're building now are the foundation of the whole development process. The choices we make here affect everything that comes after; it's important to do it right.</li><li class="listitem">If the people who write the specification aren't the same people who are writing the code, then it's important for the coders to start involving themselves as soon as possible, to keep the whole process within the bounds of what can usefully be done. If the specifiers are the coders, then the question is academic.</li><li class="listitem">The big advantage is that the tests allow the code's interfaces to be test-driven, before the effort gets put into actually implementing them. The primary disadvantage is that the tests can lock in a design which might have benefitted from further evolution.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec125"/>Pop quiz – unit testing</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The test should be written before the code that will be tested, based on the expectations for that code.</li><li class="listitem">True.</li><li class="listitem">Tests should be run as often as possible. It is very useful to run the tests regularly while coding, as well as just before storing the code into a version control system.</li><li class="listitem">You will spend most of you time using the output of the tests as a tool to guide you in finding and fixing errors in the code.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec99"/>Chapter 4</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec126"/>Pop quiz – Mocker usage</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">IN</code>.</li><li class="listitem">Pass <code class="literal">None</code> as the upper bound.</li><li class="listitem">It checks that the mocked objects were actually used in the way that we described.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec100"/>Chapter 5</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec127"/>Pop quiz – basic unittest knowledge</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem"><div><pre class="programlisting">class test_exceptions(TestCase):
 def test_ValueError(self):
  self.assertRaises(ValueError, int, '123')</pre></div></li><li class="listitem">Use the <code class="literal">assertAlmostEqual</code> method.</li><li class="listitem">You would use <code class="literal">assertTrue</code> if none of the more specialized assertions suited your needs. You would use <code class="literal">fail</code> if you needed to express the conditions for test failure, so complex that they don't fit comfortably into a single Boolean expression.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec128"/>Pop quiz – text fixtures</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">To provide each test with an identical, isolated environment.</li><li class="listitem">Add <code class="literal">setUp</code> and/or <code class="literal">tearDown</code> methods to a <code class="literal">TestCase</code> subclass.</li><li class="listitem">A test fixture can consist of either or both methods, so the answer is yes.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec101"/>Chapter 6</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec129"/>Pop quiz – testing with Nose</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">put <code class="literal">processes=4</code> in your Nose configuration file.</li><li class="listitem">add <code class="literal">--include="specs"</code> to the Nose command line.</li><li class="listitem"><code class="literal">unit_tests</code>, <code class="literal">TestFiles</code>, and <code class="literal">test_files</code> will be recognized.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec102"/>Chapter 7</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec130"/>Pop quiz – test-driven development</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Because the testable specification didn't follow unit testing discipline, it didn't satisfy my need for unit tests. I had to write additional tests to fill that need. It's fine to do that, as long as I don't skimp on the real unit tests.</li><li class="listitem">In no way. It's actually desirable to run your tests as often as possible.</li><li class="listitem">You've lost the opportunity to give your code's planned interface a test drive before you set it in stone. You've lost the opportunity to write down your expectations without having them contaminated by the actual behavior of your first implementation. You've lost the opportunity to have the computer tell you what needs to be done to create a working implementation.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec103"/>Chapter 8</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec131"/>Pop quiz – the Twill language</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Whatever form was last touched by the <code class="literal">formvalue</code> command is submitted.</li><li class="listitem">The <code class="literal">notfind</code> command.</li><li class="listitem">Twill will report that the entire script failed, and not execute any of the later commands.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec132"/>Pop quiz – browser methods</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The value you pass as a parameter is matched against the form's name, number, and ID.</li><li class="listitem">The <code class="literal">clicked</code> method moves the simulated input focus to a new control on the web page.</li><li class="listitem">The <code class="literal">code</code> command checks the response code and raises an exception if it doesn't match an expected value. The <code class="literal">get_code</code> method simply returns the response code.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec104"/>Chapter 9</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec133"/>Pop quiz – diagramming integration</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Those units wouldn't exist within the same class if they weren't related to each other. By grouping them into their classes visually, we can take advantage of that relationship to make our diagrams more easily.</li><li class="listitem">Usually, it saves us trouble later on. Things that are related to each other at one level are often part of the same thing at a higher level.</li><li class="listitem">In testing, as in chemistry, it's important to change only one thing at a time. If we pull together more than two things in a single step, we've changed more than one thing, and so we can lose track of where any problems we find came from.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec134"/>Pop quiz – writing integration tests</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The ones in the smallest circles, especially if they don't have any lines pointing from themselves to other circles.</li><li class="listitem">Start from the smallest circles involving that code, and build up step by step until you're ready to integrate it with your earlier code.</li><li class="listitem">When we were doing unit testing, even other instances of the same class were mocked; we were concerned that this code did what it was supposed to, without involving anything else. Now that we're doing integration testing, we need to test that instances of the same class interact correctly with each other, or with themselves when they're allowed to retain state from one operation to the next. The two kinds of tests cover different things, so it makes sense that we would need both.</li><li class="listitem">A system test is the final stage of integration testing. It's a test that involves the whole code base.</li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec105"/>Chapter 10</h1></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec135"/>Pop quiz – code coverage</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">It means that most of the code base was executed while running the tests.</li><li class="listitem">That would be a bad idea, because coverage doesn't tell you anything about the quality of your tests. It's for helping you find things that need to be tested, not for telling you whether your tests are any good.</li><li class="listitem">The most useful information that the coverage report provides is the list of lines that weren't executed, because that's what allows you to know what new tests you might want to add.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec136"/>Pop quiz – version control hooks</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">It can ensure that your tests are executed frequently, and can make you immediately aware when you're checking in broken code.</li><li class="listitem">Don't make it impossible to check in broken code. Don't make version control hooks a matter of company policy.</li><li class="listitem">In a centralized version control system, the hooks are usually under the control of a system administrator, and executed on a server. In a distributed version control system, the hooks are usually under the control of the user, and executed on the user's computer.</li></ol></div></div></div></body></html>