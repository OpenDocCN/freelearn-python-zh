- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating Deployment on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we successfully deployed the Django application on
    an EC2 instance. However, most of the deployment is done manually, and we don’t
    check for regression when pushing a new version of the application. Interestingly,
    all the deploying can be automated using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use GitHub Actions to automatically deploy on an AWS
    EC2 instance so that you don’t have to do it manually. We will explore how to
    write a configuration file that will run tests on the code to avoid regressions,
    and finally connect via **Secure Socket Shell** (**SSH**) to a server and execute
    the script to pull and build the recent version of the code and up the container.
    To recapitulate, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining **continuous integration and continuous** **deployment** (**CI/CD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the CI/CD workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is GitHub Actions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the backend for automated deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap14](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap14).
    If you are using a Windows machine, ensure that you have the OpenSSH client installed
    on your machine as we will generate SSH key pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going deeper into GitHub Actions, we must understand the terms *CI* and
    *CD*. In this section, we will understand each term and explain the differences.
  prefs: []
  type: TYPE_NORMAL
- en: CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CI** is a practice of automating the integration of code changes from multiple
    collaborators into a single project. It also concerns the ability to reliably
    release changes made to an application at any time. Without CI, we should have
    to manually coordinate the deployment, the integration of changes into an application,
    and security and regression checks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a typical CI workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: A developer creates a new branch from the main branch, makes changes, commits,
    and then pushes it to the branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the push is done, the code is built, and then automated tests are run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the automated tests fail, the developer team is notified, and the next steps
    (usually deployment) are canceled. If the tests succeed, then the code is ready
    to be deployed in a staging or production environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find many tools for CI pipeline configurations. You have tools such
    as GitHub Actions, Semaphore, Travis CI, and a lot more. In this book, we will
    use GitHub Actions to build the CI pipeline, and if the CI pipeline passes, we
    can deploy it on AWS. Let’s now learn more about CD.
  prefs: []
  type: TYPE_NORMAL
- en: CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CD** is related to CI but most of the time represents the next step after
    a successful CI pipeline passes. The quality of the CI pipeline (builds and tests)
    will determine the quality of the releases made. With CD, the software is automatically
    deployed to a staging or production environment once it passes the CI step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a CD pipeline could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: A developer writes a branch, makes changes and pushes the changes, and then
    creates a merge request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tests and builds are done to make sure there is no regression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code is reviewed by another developer, and if the review is done, the merge
    request is validated and then another suite of tests and builds are done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, the changes are deployed to a staging or production environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GitHub Actions and the other tools mentioned for CI also support CD. With a
    better understanding of CI and CD, let’s define the workflow that we will configure
    for the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You will also hear about *continuous delivery* if you are diving deeper into
    CI/CD; it is a further extension of *continuous deployment*. Continuous deployment
    focuses on the deployment of the servers while continuous delivery focuses on
    the release and release strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the CI/CD workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before deploying an application as we did in the previous chapter, we need to
    write off the steps we will follow, along with the tools needed for the deployment.
    In this chapter, we will automate the deployment of the backend on AWS. Basically,
    each time we have a push made on the main branch of the repository, the code should
    be updated on the server and the containers should be updated and restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let’s define the flow, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A push is made on the principal branch of the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker containers are built and started to run tests. If the tests fail, the
    following steps are ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect via SSH to the server and run a script to pull the new changes from
    the remote repository, build the containers, and restart the services using `docker-compose`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a typical CI/CD workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – CI/CD workflow](img/Figure_14.01_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – CI/CD workflow
  prefs: []
  type: TYPE_NORMAL
- en: That is a lot of things to do manually, and thankfully, GitHub provides an interesting
    feature called GitHub Actions. Now that we have a better idea about the deployment
    strategy, let’s explore this feature more.
  prefs: []
  type: TYPE_NORMAL
- en: What is GitHub Actions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub Actions is a service built and developed by GitHub for automating builds,
    testing, and deployment pipelines. Using GitHub Actions, we can easily implement
    the CI/CD workflow shown in *Figure 14**.1*. Before continuing, make sure that
    your project is hosted on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions configurations are made in a file that must be stored in a dedicated
    directory in the repository called `.github/workflows`. For a better workflow,
    we will also use GitHub secrets to store deployment information such as the IP
    address of the server, the SSH passphrase, and the server username. Let’s start
    by understanding how to write a GitHub Actions workflow file.
  prefs: []
  type: TYPE_NORMAL
- en: How to write a GitHub Actions workflow file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Workflow files are stored in a dedicated directory called `.github/workflows`.
    The syntax used for these files is YAML syntax, hence workflow files have the
    `.``yml` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive deeper into the syntax of a workflow file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This represents the name of the workflow. This name is set by placing
    the following line at the beginning of the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`on`: This specifies the events that will trigger the workflow automatically.
    An example of an event is a push, a pull request, or a fork:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`jobs`: This specifies the actions that the workflow will perform. You can
    have multiple jobs and even have some jobs depending on each other:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our GitHub Actions workflow, we will have two jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: A job named `build-test` to build the Docker containers and run the tests inside
    those containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A job named `deploy` to deploy the application to the AWS server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment of the application will depend on the failure or success of the
    `build-test` job. It’s a good way to prevent code from failing and crashing in
    the production environment. Now that we understand the GitHub Actions workflow,
    YAML syntax, and the jobs we want to write for our workflow, let’s write the GitHub
    Actions file and configure the server for automatic deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the backend for automated deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we discussed more about the syntax of a GitHub Actions
    file and the jobs we must write to add CI and CD to the Django application. Let’s
    write the GitHub Action file and configure the backend for automatic deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the GitHub Actions file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the root of the project, create a directory called `.github`, and inside
    this directory create another directory called `workflows`. Inside the `workflows`
    directory, create a file called `ci-cd.yml`. This file will contain the YAML configuration
    for the GitHub action. Let’s start by defining the name and the events that will
    trigger the running of the workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: .github/workflows/ci-cd.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The workflow will run every time there is a push on the main branch. Let’s
    go on to write a `build-test` job. For this job, we will follow three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting environment variables into a file. Docker will need a `.env` file
    to build the images and start the containers. We’ll inject dummy environment variables
    into the Ubuntu environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we will build the containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, we run the tests on the `api` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s get started with the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by writing the job and injecting the environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .github/workflows/ci-cd.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The tests will probably fail because we haven’t defined the Github Secret called
    `TEST_SECRETS`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Testing Github secrets](img/Figure_14.02_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Testing Github secrets
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s add the command to build the containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .github/workflows/ci-cd.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let’s run the `pytest` command in the `api` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .github/workflows/ci-cd.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Great! We have the first job of the workflow fully written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s push the code by running the following command and see how it runs on
    the GitHub side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to GitHub to check your repository. You will see an orange badge on the
    details of the repository, meaning that the workflow is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Running GitHub Actions](img/Figure_14.03_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Running GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the orange badge to have more details about the running workflows.
    The workflow should pass, and you will have a green status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Successful GitHub Action job](img/Figure_14.04_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Successful GitHub Action job
  prefs: []
  type: TYPE_NORMAL
- en: Great! We have the `build-test` job running successfully, which means that our
    code can be deployed in a production environment. Before writing the `deploy`
    job, let’s configure the server first for automatic deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the EC2 instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to go back to the EC2 instance and make some configurations to ease
    the automatic deployment. Here’s the list of tasks to do so that GitHub Actions
    can automatically handle the deployment for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a pair of SSH keys (private and public keys) with a passphrase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the public key to `authorized_keys` on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the private key to GitHub Secrets to reuse it for the SSH connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register the username used on the OS of the EC2 instance, the IP address, and
    the SSH passphrase to GitHub Secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a deploying script on the server. Basically, the script will pull code from
    GitHub, check for changes, and eventually build and rerun the containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap everything and add the `deploy` job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This looks like a lot of steps, but here’s the good thing: you just need to
    do that once. Let’s start by generating SSH credentials.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating SSH credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best practice for generating SSH keys is to generate the keys on the local
    machine and not the remote machine. In the next lines, we will use terminal commands.
    If you are working on a Windows machine, make sure you have the OpenSSH client
    installed. The following commands are executed on a Linux machine. Let’s get started
    with the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and enter the following command to generate an RSA key pair:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 14.5 – Generating SSH keys](img/Figure_14.05_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Generating SSH keys
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, copy the content of the public key and add it to the `.ssh/authorized_keys`
    file of the remote EC2 instance. You can just do a copy and paste using the mouse,
    or you can type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, copy the content of the private key and add it to GitHub Secrets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 14.6 – Registering \uFEFFthe private key into GitHub \uFEFFSecrets](img/Figure_14.06_B18221.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Registering the private key into GitHub Secrets
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to do the same for the passphrase, EC2 server IP address, and
    username for the OS of the EC2 machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Repository secrets](img/Figure_14.07_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Repository secrets
  prefs: []
  type: TYPE_NORMAL
- en: Great! We have the secrets configured on the repository; we can now write the
    `deploy` job on the GitHub action.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a deploying script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The benefit of using GitHub Actions is that you can already find preconfigured
    GitHub Actions on GitHub Marketplace and just use them instead of reinventing
    the wheel. For the deployment, we will use the `ssh-action` GitHub action, which
    is developed to allow developers to execute remote commands via SSH. This perfectly
    fits our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the `deploy` job inside our GitHub action workflow and write a
    deployment script on the EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `.github/workflows/ci-cd.yml` file, add the following code at the
    end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: .github/workflows/ci-cd.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The script run on the EC2 instance is the execution of a file called `docker-ec2-deploy.sh`.
    This file will contain Bash code for pulling code from the GitHub repository and
    building the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s connect to the EC2 instance and add the `docker-ec2-deploy.sh` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the home directory, create a file called `docker-ec2-deploy.sh`. The process
    for deployment using Git and Docker will follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must ensure that there are effective changes in the GitHub repository to
    continue with building and running the containers. It will be a waste of resources
    and memory to rebuild the containers if the Git pull hasn’t brought new changes.
    Here’s how we can check this:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next step, we will do a `git fetch` command to download content from the GitHub
    repository:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once this is done, we will then check the repository is up to date by comparing
    the `HEAD` hash and the `UPSTREAM` hash. If they are the same, then the repository
    is up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `HEAD` and the `UPSTREAM` hashes are not the same, we pull the latest
    changes, build the containers, and run the containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We can now give execution permission to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: And we are done. You can push the changes made on the GitHub workflow and the
    automatic deployment job will start.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of repository (private or public), you might need to enter
    your GitHub credentials on every remote git command executed such as `git push`
    or `git pull` for example. Ensure you have your credentials configured using SSH
    or HTTPS. You can check how to do it [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure to have a `.env` file at the root of the project in the AWS server.
    Here is an example of a `.env` file you can use for deployment. Don’t forget to
    change the values of database credentials or secret keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Ensure to replace the `EC2_IP_ADDRESS` and the `EC2_INSTANCE_URL` with the values
    of your EC2 instance. You will also need to allow TCP connections on port **80**
    to allow HTTP requests on the EC2 instances for the whole configuration to work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Allowing HTTP requests](img/Figure_14.08_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Allowing HTTP requests
  prefs: []
  type: TYPE_NORMAL
- en: You can also remove the **8000** configurations as NGINX handles the redirection
    of HTTP requests to **0.0.0.0:8000** automatically.
  prefs: []
  type: TYPE_NORMAL
- en: With the concept of CI/CD understood and GitHub Actions explained and written,
    you have all the tools you need now to automate deployment on EC2 instances and
    any server. Now that the backend is deployed, we can move on to deploying the
    React frontend, not on an EC2 instance but on AWS **Simple Storage** **Service**
    (**S3**).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have finally automated the deployment of the Django application
    on AWS using GitHub Actions. We have explored the concepts of CI and CD and how
    GitHub Actions allow the configuration of such concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We have written a GitHub action file with jobs to build and run the test suites,
    and if these steps are successful, we run the `deploy` job, which is just connecting
    to the EC2 instance, and run a script to pull changes, build new images, and run
    the containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to deploy the React application using
    a service such as AWS S3.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between CI and CD?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are GitHub Actions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is continuous delivery?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
