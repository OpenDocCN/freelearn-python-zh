["```py\n pip install flask-gladiator\n```", "```py\n<st c=\"5458\">import gladiator as glv</st>\n<st c=\"5482\">from gladiator.core import ValidationResult</st> def validate_form(form_data):\n    field_validations = (\n        ('adminid', <st c=\"5591\">glv.required</st>, <st c=\"5605\">glv.length_max(12)</st>),\n        ('username', glv.required, <st c=\"5654\">glv.type_(str)</st>),\n        ('firstname', glv.required, glv.length_max(50), <st c=\"5720\">glv.regex_('[a-zA-Z][a-zA-Z ]+')</st>),\n        ('midname', glv.required, glv.length_max(50), glv.regex_('[a-zA-Z][a-zA-Z ]+')),\n        ('lastname', glv.required, glv.length_max(50), glv.regex_('[a-zA-Z][a-zA-Z ]+')),\n        ('email', glv.required, glv.length_max(25), <st c=\"5963\">glv.format_email</st>),\n        ('mobile', glv.required, glv.length_max(15)),\n        ('position', glv.required,  glv.length_max(100)),\n        ('status', glv.required, <st c=\"6103\">glv.in_(['true', 'false'])</st>),\n        ('gender', glv.required, glv.in_(['male', 'female'])),\n    ) <st c=\"6190\">result:ValidationResult = glv.validate(field_validations, form_data)</st> return <st c=\"6317\">gladiator</st> module is the <st c=\"6341\">validate()</st> method, which has two required parameters: <st c=\"6395\">form_data</st> and <st c=\"6409\">validators</st>. The validators are placed in a tuple of tuples, as shown in the preceding code, wherein each tuple contains the request parameter name followed by all its validators. Our <st c=\"6592\">ch09-web-passphrase</st> project uses the following validators:\n\n\t\t\t\t*   `<st c=\"6650\">required()</st>`<st c=\"6661\">: Requires the parameter to have</st> <st c=\"6695\">a value.</st>\n\t\t\t\t*   `<st c=\"6703\">length_max()</st>`<st c=\"6716\">: Checks whether the given string length is lower than or equal to a</st> <st c=\"6786\">maximum value.</st>\n\t\t\t\t*   `<st c=\"6800\">type_()</st>`<st c=\"6808\">: Checks the type of the request data (e.g., a form parameter is always</st> <st c=\"6881\">a string).</st>\n\t\t\t\t*   `<st c=\"6891\">regex_ ()</st>`<st c=\"6901\">: Matches the string to a</st> <st c=\"6928\">regular expression.</st>\n\t\t\t\t*   `<st c=\"6947\">format_email()</st>`<st c=\"6962\">: Checks whether the request data follows the</st> <st c=\"7009\">email regex.</st>\n\t\t\t\t*   `<st c=\"7021\">in_()</st>`<st c=\"7027\">: Checks whether the value is within the list</st> <st c=\"7074\">of options.</st>\n\n\t\t\t<st c=\"7085\">The list shows only a few of the many validator functions that the</st> `<st c=\"7153\">gladiator</st>` <st c=\"7162\">module can provide to establish the validation</st> <st c=\"7209\">rules.</st> <st c=\"7217\">Now, the</st> `<st c=\"7226\">validate()</st>` <st c=\"7236\">method returns a</st> `<st c=\"7254\">ValidationResult</st>` <st c=\"7270\">object, which has a boolean</st> `<st c=\"7299\">success</st>` <st c=\"7306\">variable that yields</st> `<st c=\"7328\">True</st>` <st c=\"7332\">if all the validators have no</st> <st c=\"7362\">hits.</st> <st c=\"7369\">Otherwise, it yields</st> `<st c=\"7390\">False</st>`<st c=\"7395\">. The following code shows how the</st> `<st c=\"7430\">ch09-web-passphrase</st>`<st c=\"7449\">’s</st> `<st c=\"7453\">add_admin_profile()</st>` <st c=\"7472\">method utilizes the given</st> `<st c=\"7499\">validate_form()</st>` <st c=\"7514\">view function:</st>\n\n```", "```py\n\n\t\t\t<st c=\"8070\">Now, filtering malicious text can be effective if we combine the validation and sanitation of this form data.</st> <st c=\"8181\">Sanitizing inputs</st> <st c=\"8199\">means encoding special</st> <st c=\"8221\">characters that might trigger the execution of malicious scripts from</st> <st c=\"8292\">the browser.</st>\n\t\t\t<st c=\"8304\">Sanitizing form inputs</st>\n\t\t\t<st c=\"8327\">Aside from validation, view or API functions must also sanitize incoming request data by converting special characters and suspicious</st> <st c=\"8462\">symbols to purely text so that XML- and HTML-based templates can render them without side effects.</st> <st c=\"8561\">This process is</st> <st c=\"8576\">known as</st> `<st c=\"8600\">markupsafe</st>` <st c=\"8610\">module has an</st> `<st c=\"8625\">escape()</st>` <st c=\"8633\">method that can normalize request data with query strings that intend to control the JavaScript codes, modify the UI experience, or tamper browser cookies when Jinja2 templates render them.</st> <st c=\"8824\">The following snippet is a portion of the</st> `<st c=\"8866\">add_admin_profile()</st>` <st c=\"8885\">view function that sanitizes the form data after</st> `<st c=\"8935\">gladiator</st>` <st c=\"8944\">validation:</st>\n\n```", "```py\n\n\t\t\t<st c=\"9792\">Removing leading and trailing whitespaces or defined suspicious characters using Python’s</st> `<st c=\"9883\">strip()</st>` <st c=\"9890\">method with the escaping process may lower the risk of injection and XSS attacks.</st> <st c=\"9973\">However, be sure that the validation rules and sanitation techniques combined will neither ruin the performance of the view or API function nor change the actual request data.</st> <st c=\"10149\">Also, tight</st> <st c=\"10161\">validation rules can affect the overall runtime performance, so choose the appropriate number and types of validators for</st> <st c=\"10283\">every form.</st>\n\t\t\t<st c=\"10294\">To avoid SQL injection, use</st> <st c=\"10323\">an ORM such as</st> **<st c=\"10338\">SQLAlchemy</st>**<st c=\"10348\">,</st> **<st c=\"10350\">Pony</st>**<st c=\"10354\">, or</st> **<st c=\"10359\">Peewee</st>** <st c=\"10365\">that can provide a</st> <st c=\"10384\">more abstract form of SQL transactions and even escape utilities to sanitize column</st> <st c=\"10469\">values before persistence.</st> <st c=\"10496\">Avoid using native and dynamic queries where the field values are concatenated to the query string because they are prone to manipulation</st> <st c=\"10634\">and exploitation.</st>\n\t\t\t<st c=\"10651\">Sanitation can also be applied to response data to</st> <st c=\"10703\">avoid another type of attack called the</st> **<st c=\"10743\">Server-Side Template Injection</st>** <st c=\"10773\">(</st>**<st c=\"10775\">SSTI</st>**<st c=\"10779\">).</st> <st c=\"10783\">Let us now discuss how to protect the application from SSTIs by managing the</st> <st c=\"10859\">response data.</st>\n\t\t\t<st c=\"10874\">Securing response data</st>\n\t\t\t<st c=\"10897\">Jinja2 has a built-in escaping mechanism to avoid SSTIs.</st> <st c=\"10955\">SSTIs allow attackers to inject malicious template scripts or fragments that can run in the background.</st> <st c=\"11059\">These then ruin the response or perform unwanted</st> <st c=\"11107\">executions that can ruin server-side operations.</st> <st c=\"11157\">Thus, applying the</st> `<st c=\"11176\">safe</st>` <st c=\"11180\">filter in Jinja templates to perform dynamic content augmentation is not a good practice.</st> <st c=\"11271\">The</st> `<st c=\"11275\">safe</st>` <st c=\"11279\">filter turns off the Jinja2’s escaping mechanism and allows for running these malicious attacks.</st> <st c=\"11377\">In connection with this, avoid</st> <st c=\"11408\">using</st> `<st c=\"11448\"><a></st>` <st c=\"11451\">tag in templates (e.g.,</st> `<st c=\"11476\"><a href=\"{{ var_link }}\">Click Me</a></st>`<st c=\"11513\">).</st> <st c=\"11517\">Instead, utilize the</st> `<st c=\"11538\">url_for()</st>` <st c=\"11547\">utility method to call dynamic view functions because it validates and checks whether the Jinja variable in the expression is a valid view name.</st> [*<st c=\"11693\">Chapter 1</st>*](B19383_01.xhtml#_idTextAnchor014) <st c=\"11702\">discusses how to apply</st> `<st c=\"11726\">url_for()</st>` <st c=\"11735\">for hyperlinks.</st>\n\t\t\t<st c=\"11751\">On the other hand, there are also issues in Flask that need handling to prevent injection attacks on the Jinja templates, such as managing how the view functions will render the context data and add security</st> <st c=\"11960\">response headers.</st>\n\t\t\t<st c=\"11977\">Rendering Jinja2 variables</st>\n\t\t\t<st c=\"12004\">There is no ultimate solution to avoid injection but to</st> <st c=\"12060\">apply escaping to context data before rendering them to Jinja2 templates.</st> <st c=\"12135\">Moreover, avoid using</st> `<st c=\"12157\">render_template_string()</st>` <st c=\"12181\">even if this is part of the Flask framework.</st> <st c=\"12227\">Rendering HTML page-generated content may accidentally run malicious data from inputs overlooked by</st> <st c=\"12326\">filtering and escaping.</st> <st c=\"12351\">It is always good practice to place all HTML content in a file with an</st>`<st c=\"12421\">.html</st>` <st c=\"12426\">extension, or XML content in a</st> `<st c=\"12458\">.xml</st>` <st c=\"12462\">file, to enable Jinja2’s default escaping feature.</st> <st c=\"12514\">Then, render them using the</st> `<st c=\"12542\">render_template()</st>` <st c=\"12559\">method with or without the escaped and validated context data.</st> <st c=\"12623\">All our projects use</st> `<st c=\"12644\">render_template()</st>` <st c=\"12661\">in rendering</st> <st c=\"12675\">Jinja2 templates.</st>\n\t\t\t<st c=\"12692\">Security response headers must also be part of the response object when rendering every view template.</st> <st c=\"12796\">Let us explore these security response headers and learn where to</st> <st c=\"12862\">build them.</st>\n\t\t\t<st c=\"12873\">Adding security response headers</st>\n\t\t\t<st c=\"12906\">HTTP security response headers are directives used by many web applications to mitigate vulnerability attacks, such as XXS and public exposure of user details.</st> <st c=\"13067\">They are headers added in the response object</st> <st c=\"13113\">during the rendition</st> <st c=\"13133\">of the Jinja2 templates or JSON results.</st> <st c=\"13175\">Some of these headers include</st> <st c=\"13205\">the following:</st>\n\n\t\t\t\t*   `<st c=\"13371\">UTF-8</st>` <st c=\"13376\">charset to</st> <st c=\"13388\">avoid XSS.</st>\n\t\t\t\t*   `<st c=\"13471\">content-type</st>`<st c=\"13483\">. It also blocks the browser’s</st> `<st c=\"13514\">media-type</st>` <st c=\"13524\">sniffing, so its value should</st> <st c=\"13555\">be</st> `<st c=\"13558\">nosniff</st>`<st c=\"13565\">.</st>\n\t\t\t\t*   `<st c=\"13653\"><frame></st>`<st c=\"13660\">,</st> `<st c=\"13662\"><iframe></st>`<st c=\"13670\">,</st> `<st c=\"13672\"><embed></st>`<st c=\"13679\">, or</st> `<st c=\"13684\"><objects></st>`<st c=\"13693\">. Possible values include</st> `<st c=\"13719\">DENY</st>` <st c=\"13723\">and</st> `<st c=\"13728\">SAMEORIGIN</st>`<st c=\"13738\">. The</st> `<st c=\"13744\">DENY</st>` <st c=\"13748\">option disallows rending pages on a frame, while</st> `<st c=\"13798\">SAMEORIGIN</st>` <st c=\"13808\">allows rendering a page on a frame with the same URL site as</st> <st c=\"13870\">the page.</st>\n\t\t\t\t*   **<st c=\"13879\">Strict-Transport-Security</st>**<st c=\"13905\">: This indicates that the browser can only access the page through the</st> <st c=\"13977\">HTTPS protocol.</st>\n\n\t\t\t<st c=\"13992\">In our</st> `<st c=\"14000\">ch09-web-passphrase</st>` <st c=\"14019\">project, the global</st> `<st c=\"14040\">@after_request</st>` <st c=\"14054\">function creates a list of security response headers for every view function call.</st> <st c=\"14138\">The following code snippet in the</st> `<st c=\"14172\">main.py</st>` <st c=\"14179\">module shows this</st> <st c=\"14198\">function implementation:</st>\n\n```", "```py\n\n\t\t\t<st c=\"14586\">Here,</st> `<st c=\"14593\">Content-Type</st>`<st c=\"14605\">,</st> `<st c=\"14607\">X-Content-Type-Options</st>`<st c=\"14629\">,</st> `<st c=\"14631\">X-Frame-Options</st>`<st c=\"14646\">, and</st> `<st c=\"14652\">Strict-Transport-Security</st>` <st c=\"14677\">are the most essential response headers for web applications.</st> <st c=\"14740\">By the way,</st> `<st c=\"14752\">SAMEORIGIN</st>` <st c=\"14762\">is the ideal value for</st> `<st c=\"14786\">X-Frame-Options</st>` <st c=\"14801\">because it prevents view pages from</st> <st c=\"14838\">displaying outside the site domain of the</st> <st c=\"14880\">project, mitigating</st> `<st c=\"15007\">/</st>``<st c=\"15008\">admin/profile/add</st>` <st c=\"15025\">view.</st>\n\t\t\t![Figure 9.1 – The response headers when running the view function](img/B19383_09_001.jpg)\n\n\t\t\t<st c=\"15768\">Figure 9.1 – The response headers when running the view function</st>\n\t\t\t<st c=\"15832\">On the other hand, another</st> <st c=\"15859\">way to manage security response headers is</st> <st c=\"15903\">through the Flask module</st> `<st c=\"15990\">flask-talisman</st>` <st c=\"16004\">module using the following</st> `<st c=\"16032\">pip</st>` <st c=\"16035\">command:</st>\n\n```", "```py\n\n\t\t\t<st c=\"16071\">Afterward, instantiate the</st> `<st c=\"16099\">Talisman</st>` <st c=\"16107\">class in the</st> `<st c=\"16121\">create_app()</st>` <st c=\"16133\">method and integrate the module into the Flask application by adding and configuring the web application’s security response headers using Talisman libraries, as shown in the</st> <st c=\"16309\">following snippet:</st>\n\n```", "```py\n pip install pyopenssl\n```", "```py\n app, celery_app, auth = create_app('../config_dev.toml')\n… … … … … …\nif __name__ == '__main__': <st c=\"19398\">python main.py</st> command with the <st c=\"19430\">ssl_context</st> parameter will show a log on the terminal console, as shown in *<st c=\"19505\">Figure 9</st>**<st c=\"19513\">.2</st>*:\n\t\t\t![Figure 9.2 – The server log when running on HTTPS](img/B19383_09_002.jpg)\n\n\t\t\t<st c=\"19742\">Figure 9.2 – The server log when running on HTTPS</st>\n\t\t\t<st c=\"19791\">When opening the</st> `<st c=\"19809\">https://127.0.0.1:5000/</st>` <st c=\"19832\">link on a browser, a warning page will pop up on the screen, such as the one depicted in</st> *<st c=\"19922\">Figure 9</st>**<st c=\"19930\">.3</st>*<st c=\"19932\">, indicating that we are entering a secured page from a</st> <st c=\"19988\">non-secured browser.</st>\n\t\t\t![Figure 9.3 – A warning page on opening secured links](img/B19383_09_003.jpg)\n\n\t\t\t<st c=\"20319\">Figure 9.3 – A warning page on opening secured links</st>\n\t\t\t<st c=\"20371\">Another way to run Flask applications</st> <st c=\"20409\">on an HTTP protocol is to include the key files in the command line, such as</st> `<st c=\"20487\">python main.py --cert=cert.pem --key=key.pem</st>`<st c=\"20531\">. In the production environment, we run Flask applications according to the procedure followed by the</st> <st c=\"20633\">secured</st> <st c=\"20641\">production server.</st>\n\t\t\t<st c=\"20659\">Encryption does not apply only when establishing an HTTP connection but also when securing sensitive user information such as usernames and passwords.</st> <st c=\"20811\">In the next section, we will discuss the</st> <st c=\"20851\">different ways of</st> **<st c=\"20870\">hashing</st>** <st c=\"20877\">and encrypting</st> <st c=\"20893\">user credentials.</st>\n\t\t\t<st c=\"20910\">Managing user credentials</st>\n\t\t\t<st c=\"20936\">The most common procedure for protecting any application from attacks is to control access to the user’s sensitive details, such as their username and password.</st> <st c=\"21098\">Direct use of saved raw user credentials for login</st> <st c=\"21149\">validation will not protect the application from attacks unless the application derives passphrases from the passwords, saves them into the database, and applies them for user</st> <st c=\"21325\">validation instead.</st>\n\t\t\t<st c=\"21344\">This topic will</st> <st c=\"21360\">cover password</st> <st c=\"21375\">hashing using</st> `<st c=\"21478\">sqlalchemy_utils</st>` <st c=\"21494\">module for the seamless and automatic encryption of</st> <st c=\"21547\">sensitive data.</st>\n\t\t\t<st c=\"21562\">Encrypting user passwords</st>\n\t\t\t<st c=\"21588\">Generating a passphrase from the username and password of the user is the typical and easiest way to protect the</st> <st c=\"21702\">application from attackers who want to crack down or hack a user account.</st> <st c=\"21776\">In Flask, there are two ways to generate a passphrase from</st> <st c=\"21835\">user credentials:</st>\n\n\t\t\t\t*   **<st c=\"21852\">The hashing process</st>**<st c=\"21872\">: A one-way</st> <st c=\"21885\">approach that involves generating a fixed-length passphrase of the</st> <st c=\"21952\">original text.</st>\n\t\t\t\t*   **<st c=\"21966\">The encryption process</st>**<st c=\"21989\">: A two-way</st> <st c=\"22002\">approach that involves generating a variable-length text using random symbols that can be traced back to its</st> <st c=\"22111\">original text.</st>\n\n\t\t\t<st c=\"22125\">The</st> `<st c=\"22130\">ch09-api-bcrypt</st>` <st c=\"22145\">and</st> `<st c=\"22150\">ch09-auth-basic</st>` <st c=\"22165\">projects use hashing to manage the passwords of a user.</st> <st c=\"22222\">The</st> `<st c=\"22226\">ch09-auth-basic</st>` <st c=\"22241\">project utilizes Hashlib as its primary hashing library for passphrase generation.</st> <st c=\"22325\">Flask has the</st> `<st c=\"22339\">werkzeug.security</st>` <st c=\"22356\">module that provides</st> `<st c=\"22378\">generate_password_hash()</st>`<st c=\"22402\">, a function that uses Hashlib’s</st> `<st c=\"22435\">scrypt</st>` <st c=\"22441\">algorithm to generate a passphrase from a text.</st> <st c=\"22490\">The project’s</st> `<st c=\"22504\">add_signup()</st>` <st c=\"22516\">API endpoint function that utilizes the</st> `<st c=\"22557\">werkzeug.security</st>` <st c=\"22574\">module in generating the passphrase from the user’s password is</st> <st c=\"22639\">as follows:</st>\n\n```", "```py\n\n\t\t\t<st c=\"23200\">The</st> `<st c=\"23205\">generate_password_hash()</st>` <st c=\"23229\">method has</st> <st c=\"23241\">three parameters:</st>\n\n\t\t\t\t*   <st c=\"23258\">The actual password is</st> <st c=\"23281\">the</st> <st c=\"23286\">first parameter.</st>\n\t\t\t\t*   <st c=\"23302\">The hashing method is the second parameter with a default value</st> <st c=\"23367\">of</st> `<st c=\"23370\">scrypt</st>`<st c=\"23376\">.</st>\n\t\t\t\t*   <st c=\"23377\">The</st> **<st c=\"23382\">salt</st>** <st c=\"23386\">length is the</st> <st c=\"23401\">third parameter.</st>\n\n\t\t\t<st c=\"23417\">The salt length will determine the number of alphanumerics that the method will use to generate a salt.</st> <st c=\"23522\">A salt is the additional alphanumerics with a fixed length that are added to the end of the password to make the passphrase more unbreachable or uncrackable.</st> <st c=\"23680\">The process of adding salt to hashing</st> <st c=\"23717\">is</st> <st c=\"23721\">called</st> **<st c=\"23728\">salting</st>**<st c=\"23735\">.</st>\n\t\t\t<st c=\"23736\">On the other hand, the</st> `<st c=\"23760\">werkzeug.security</st>` <st c=\"23777\">module also supports</st> `<st c=\"23799\">pbkdf2</st>` <st c=\"23805\">as an option for the hashing method parameter.</st> <st c=\"23853\">However, it is less secure than the Scrypt algorithm.</st> <st c=\"23907\">Scrypt is a simple and effective hashing algorithm that requires salt to hash a password.</st> <st c=\"23997\">The</st> `<st c=\"24001\">generate_password_hash()</st>` <st c=\"24025\">method defaults the salt length to</st> `<st c=\"24061\">16</st>`<st c=\"24063\">, which can be replaced anytime by passing any preferred length.</st> <st c=\"24128\">Moreover, Scrypt is memory intensive, since it needs storage to temporarily hold all the initial salted random alphanumerics</st> <st c=\"24252\">until it returns the</st> <st c=\"24274\">final passphrase.</st>\n\t\t\t<st c=\"24291\">Since there is no way to re-assemble the passphrase to extract the original text, the</st> `<st c=\"24378\">werkzeug.security</st>` <st c=\"24395\">module has a</st> `<st c=\"24409\">check_password_hash()</st>` <st c=\"24430\">method that returns</st> `<st c=\"24451\">True</st>` <st c=\"24455\">if the given text value matches the hashed value.</st> <st c=\"24506\">The following snippet validates the password of an authenticated user if it matches an account in the database with the same username but a</st> <st c=\"24646\">hashed password:</st>\n\n```", "```py\n\n\t\t\t<st c=\"24978\">The</st> `<st c=\"24983\">check_password_hash()</st>` <st c=\"25004\">method requires two parameters, namely the passphrase as the first and the original password as the second.</st> <st c=\"25113\">If the</st> `<st c=\"25120\">werkzeug.security</st>` <st c=\"25137\">module is not the option for your requirement due to its slowness, the</st> `<st c=\"25317\">hashlib</st>` <st c=\"25324\">module using the following</st> `<st c=\"25352\">pip</st>` <st c=\"25355\">command before</st> <st c=\"25371\">applying it:</st>\n\n```", "```py\n\n\t\t\t<st c=\"25403\">On the other hand,</st> `<st c=\"25423\">ch09-api-bcrypt</st>` <st c=\"25438\">uses the Bcrypt algorithm to generate a passphrase for a password.</st> <st c=\"25506\">Since</st> `<st c=\"25597\">pip</st>` <st c=\"25600\">command:</st>\n\n```", "```py\n\n\t\t\t<st c=\"25628\">Afterward, instantiate the</st> `<st c=\"25656\">Bcrypt</st>` <st c=\"25662\">class container in the</st> `<st c=\"25686\">create_app()</st>` <st c=\"25698\">factory method and integrate the</st> <st c=\"25731\">module into the Flask application through the</st> `<st c=\"25778\">app</st>` <st c=\"25781\">instance.</st> <st c=\"25792\">The following snippet shows the setup of the Bcrypt module in the</st> <st c=\"25858\">Flask application:</st>\n\n```", "```py\n\n\t\t\t<st c=\"26171\">The</st> `<st c=\"26176\">bcrypt</st>` <st c=\"26182\">object will provide every module component with the utility methods to hash credential details such as passwords.</st> <st c=\"26297\">The following</st> `<st c=\"26311\">ch09-api-bcrypt</st>`<st c=\"26326\">’s version of the</st> `<st c=\"26345\">add_signup()</st>` <st c=\"26357\">endpoint</st> <st c=\"26366\">hashes the password of an account using the imported</st> `<st c=\"26420\">bcrypt</st>` <st c=\"26426\">object before saving the user’s credentials into</st> <st c=\"26476\">the database:</st>\n\n```", "```py\n\n\t\t\t<st c=\"26955\">Like Hashlib algorithms (e.g.,</st> `<st c=\"26987\">scrypt</st>` <st c=\"26993\">or</st> `<st c=\"26997\">pbkdf2</st>`<st c=\"27003\">), Bcrypt is not capable of extracting the original password from the passphrase.</st> <st c=\"27086\">However, it also has a</st> `<st c=\"27109\">check_password_hash()</st>` <st c=\"27130\">method, which validates whether a password has the correct passphrase.</st> <st c=\"27202\">However, compared to</st> <st c=\"27223\">Hashlib, Bcrypt is more secure and modern because it uses the</st> **<st c=\"27285\">Blowfish Cipher</st>** <st c=\"27300\">algorithm.</st> <st c=\"27312\">Its only drawback is its slow</st> <st c=\"27342\">hashing process, which may affect the application’s</st> <st c=\"27394\">overall performance.</st>\n\t\t\t<st c=\"27414\">Aside from hashing, the encryption algorithms can also help secure the internal data of any Flask application, especially passwords.</st> <st c=\"27548\">A well-known module that can provide reliable encryption methods is the</st> `<st c=\"27620\">cryptography</st>` <st c=\"27632\">module.</st> <st c=\"27641\">So, let us first install the module using the following</st> `<st c=\"27697\">pip</st>` <st c=\"27700\">command before using its cryptographic recipes</st> <st c=\"27748\">and utilities:</st>\n\n```", "```py\n\n\t\t\t<st c=\"27787\">The</st> `<st c=\"27792\">cryptography</st>` <st c=\"27804\">module offers both symmetric and asymmetric cryptography.</st> <st c=\"27863\">The former uses one key to initiate the encryption and decryption algorithms, while the latter uses two keys: the public and private keys.</st> <st c=\"28002\">Since our application only needs one key to encrypt user credentials, it will use symmetric cryptography through the</st> `<st c=\"28119\">Fernet</st>` <st c=\"28125\">class, the utility class that implements symmetric cryptography for the module.</st> <st c=\"28206\">Now, after the installation, call</st> `<st c=\"28240\">Fernet</st>` <st c=\"28246\">in the</st> `<st c=\"28254\">create_app()</st>` <st c=\"28266\">method to generate a key through its</st> `<st c=\"28304\">generate_key()</st>` <st c=\"28318\">class</st> <st c=\"28325\">method.</st> <st c=\"28333\">The following snippet in the factory method shows how the application created and kept the key for the</st> <st c=\"28436\">entire runtime:</st>\n\n```", "```py\n<st c=\"29387\">from cryptography.fernet import Fernet</st> @current_app.post('/login/signup')\nasync def add_signup():\n     … … … … … …\n     password = login_json[\"password\"] <st c=\"29531\">with open(\"enc_key.txt\", mode=\"r\") as file:</st><st c=\"29574\">enc_key = bytes(file.read(), \"utf-8\")</st><st c=\"29612\">fernet = Fernet(enc_key)</st><st c=\"29637\">passphrase = fernet.encrypt(bytes(password, 'utf-8'))</st> async with db_session() as sess:\n         async with sess.begin():\n           … … … … … …\n           result = await repo.insert_login(login)\n           … … … … …\n           return jsonify(record=login_json), 200\n```", "```py\n @auth.get_password\ndef get_passwd(username):\n    task = get_user_task_wrapper.apply_async( args=[username])\n    login:Login = task.get() <st c=\"30590\">with open(\"enc_key.txt\", mode=\"r\") as file:</st><st c=\"30633\">enc_key = bytes(file.read(), \"utf-8\")</st><st c=\"30671\">fernet = Fernet(enc_key)</st><st c=\"30696\">password = fernet.decrypt(login.password)</st><st c=\"30738\">.decode('utf-8')</st> if login == None:\n        return None\n    else:\n        return password\n```", "```py\n pip install cryptography sqlalchemy_utils\n```", "```py\n<st c=\"32152\">from sqlalchemy_utils import StringEncryptedType</st>\n<st c=\"32200\">enc_key = \"packt_pazzword\"</st> class Login(Base):\n   __tablename__ = 'login'\n   id = Column(Integer, Sequence('login_id_seq', increment=1), primary_key = True) <st c=\"32351\">username = Column(StringEncryptedType(String(20), enc_key), nullable=False, unique=True)</st><st c=\"32439\">password = Column(StringEncryptedType(String(50), enc_key), nullable=False)</st> role = Column(Integer, nullable=False)\n   … … … … … …\n```", "```py\n (env.py)\nimport logging\nfrom logging.config import fileConfig\nfrom flask import current_app\nfrom alembic import context <st c=\"33629\">import sqlalchemy_utils</st> … … … … … …\n(script.py.mako)\n\"\"\"${message}\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa <st c=\"33838\">import sqlalchemy_utils</st> ${imports if imports else \"\"}\n… … … … … …\n```", "```py\n @current_app.route('/login/auth', methods=['GET', 'POST'])\nasync def login_user():\n    if request.method == 'GET':\n        return render_template('login/authenticate.html'), 200\n    username = request.form['username'].strip()\n    password = request.form['password'].strip()\n    async with db_session() as sess:\n        async with sess.begin():\n            repo = LoginRepository(sess)\n            records = await repo.select_login_username_passwd(username, password)\n            login_rec = [rec.to_json() for rec in records]\n            if len(login_rec) >= 1:\n                session[\"user\"] = username\n                return redirect('/menu')\n            else:\n                … … … … … …\n                return render_template('login/authenticate.html'), 200\n```", "```py\n @current_app.route('/logout', methods=['GET'])\nasync def logout(): <st c=\"36420\">session[\"user\"] = None</st> return redirect('/login/auth')\n```", "```py\n pip install flask-login\n```", "```py\n<st c=\"37792\">from flask_login import LoginManager</st> def create_app(config_file):\n    app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')\n    app.config.from_file(config_file, toml.load)\n    app.config.from_prefixed_env()\n    … … … … … … <st c=\"38224\">Login</st> model class to the model layer through your desired ORM and sub-class it with the <st c=\"38312\">UserMixin</st> helper class of the <st c=\"38342\">flask-login</st> module. The following is the <st c=\"38383\">Login</st> model of our project that will persist the user’s <st c=\"38439\">id</st>, <st c=\"38443\">username</st>, <st c=\"38453\">passphrase</st>, and <st c=\"38469\">role</st>:\n\n```", "```py\n\n\t\t\t<st c=\"38934\">Instead of utilizing the Flask-Bcrypt module, our application uses the built-in</st> `<st c=\"39015\">StringEncryptedType</st>` <st c=\"39034\">hashing mechanism from the</st> `<st c=\"39062\">sqlalchemy_utils</st>` <st c=\"39078\">module.</st> <st c=\"39087\">Now, the use of the</st> `<st c=\"39107\">UserMixin</st>` <st c=\"39116\">superclass allows the use of some properties, such as</st> `<st c=\"39171\">is_authenticated</st>`<st c=\"39187\">,</st> `<st c=\"39189\">is_active</st>`<st c=\"39198\">, and</st> `<st c=\"39204\">is_anonymous</st>`<st c=\"39216\">, as well as some utility methods, such</st> <st c=\"39255\">as</st> `<st c=\"39259\">get_id ()</st>`<st c=\"39268\">, provided by the</st> `<st c=\"39286\">current_user</st>` <st c=\"39298\">object from the</st> `<st c=\"39315\">flask_login</st>` <st c=\"39326\">module.</st>\n\t\t\t<st c=\"39334\">Flask-Login stores the</st> `<st c=\"39358\">id</st>` <st c=\"39360\">of a user in the session after a successful login authentication.</st> <st c=\"39427\">With</st> `<st c=\"39432\">Flask-Session</st>`<st c=\"39445\">, it will store the</st> `<st c=\"39465\">id</st>` <st c=\"39467\">somewhere that has been secured.</st> <st c=\"39501\">The</st> `<st c=\"39505\">id</st>` <st c=\"39507\">is vital to the</st> `<st c=\"39702\">id</st>` <st c=\"39704\">from the session, retrieves the object using its</st> `<st c=\"39754\">id</st>` <st c=\"39756\">parameter and a repository class, and returns the</st> `<st c=\"39807\">Login</st>` <st c=\"39812\">object to the application.</st> <st c=\"39840\">Here is</st> `<st c=\"39848\">ch09-web-login</st>`<st c=\"39862\">’s implementation for the</st> <st c=\"39889\">user loader:</st>\n\n```", "```py\n<st c=\"40940\">from flask_login import login_user</st> @current_app.route('/login/auth', methods=['GET', 'POST']) <st c=\"41035\">async def login_valid_user():</st> if request.method == 'GET':\n     return render_template('login/authenticate.html'), 200\n  username = request.form['username'].strip()\n  password = request.form['password'].strip()\n  async with db_session() as sess:\n      async with sess.begin():\n         repo = LoginRepository(sess)\n         records = await repo.select_login_username_passwd( username, password)\n         if(len(records) >= 1): <st c=\"41417\">login_user(records[0])</st> return render_template('login/signup.html'), 200\n         else:\n            … … … … … …\n           return render_template( 'login/authenticate.html'), 200\n```", "```py\n from flask_login import login_required\n@current_app.route('/doctor/profile/add', methods=['GET', 'POST'])\n@login_required\nasync def add_doctor_profile():\n    if request.method == 'GET':\n        async with db_session() as sess:\n            async with sess.begin():\n                repo = LoginRepository(sess)\n                records = await repo.select_all_doctor()\n                doc_rec = [rec.to_json() for rec in records]\n                return render_template('doctor/add_doctor_profile.html', docs=doc_rec), 200\n    else:\n        username = request.form['username']\n        … … … … … …\n        return render_template('doctor/add_doctor_profile.html', doctors=doc_rec), 200\n```", "```py\n<st c=\"43586\">from flask_login import logout_user</st> @current_app.route(\"/logout\") <st c=\"43653\">async def logout():</st><st c=\"43672\">logout_user()</st> return <st c=\"43694\">redirect(url_for('login_valid_user'))</st>\n```", "```py\n<st c=\"44989\">from flask_wtf.csrf import CSRFProtect</st> def create_app(config_file):\n    app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')\n    … … … … … … <st c=\"45223\">SECRET_KEY</st> or <st c=\"45237\">WTF_CSRF_SECRET_KEY</st> to be defined in the configuration file. Now, after integrating it into the application through the <st c=\"45357\">app</st> instance, all <st c=\"45375\"><form></st> in Jinja templates must have the <st c=\"45415\">{{ csrf_token() }}</st> component or a <st c=\"45449\"><input type=\"hidden\" name=\"csrf_token\" value = \"{{ csrf_token() }}\" /></st> component to impose CSRF protection.\n\t\t\t<st c=\"45556\">If there is no plan to use the entire</st> `<st c=\"45595\">Flask-WTF</st>`<st c=\"45604\">, another</st> <st c=\"45614\">option is to apply</st> **<st c=\"45633\">Flask-Seasurf</st>** <st c=\"45646\">instead.</st>\n\t\t\t<st c=\"45655\">After showcasing the web-based authentication strategies, it is now time to discuss the different authentication types</st> <st c=\"45774\">for</st> <st c=\"45779\">API-based applications.</st>\n\t\t\t<st c=\"45802\">Implementing user authentication and authorization</st>\n\t\t\t<st c=\"45853\">There is a strong foundation of extension modules that can secure API services from unwanted access, such as the</st> `<st c=\"46426\">Flask-HTTPAuth</st>` <st c=\"46440\">module in</st> <st c=\"46451\">our application.</st>\n\t\t\t<st c=\"46467\">Utilizing the Flask-HTTPAuth module</st>\n\t\t\t<st c=\"46503\">After you have installed the</st> `<st c=\"46533\">Flask-HTTPAuth</st>` <st c=\"46547\">module and its extensions, it can provide its</st> `<st c=\"46594\">HTTPBasicAuth</st>` <st c=\"46607\">class to</st> <st c=\"46617\">build Basic authentication, the</st> `<st c=\"46649\">HTTPDigestAuth</st>` <st c=\"46663\">class to implement Digest authentication, and the</st> `<st c=\"46714\">HTTPTokenAuth</st>` <st c=\"46727\">class for the Bearer token</st> <st c=\"46755\">authentication scheme.</st>\n\t\t\t<st c=\"46777\">Basic authentication</st>\n\t\t\t<st c=\"46798\">Basic authentication requires</st> <st c=\"46829\">an unencrypted base64 format of the user’s</st> `<st c=\"46872\">username</st>` <st c=\"46880\">and</st> `<st c=\"46885\">password</st>` <st c=\"46893\">credentials through the</st> `<st c=\"46918\">Authorization</st>` <st c=\"46931\">request</st> <st c=\"46939\">header.</st> <st c=\"46948\">To implement this authentication type in Flask, instantiate the module’s</st> `<st c=\"47021\">HTTPBasicAuth</st>` <st c=\"47034\">in</st> `<st c=\"47038\">create_app()</st>` <st c=\"47050\">and register the instance to the Flask</st> `<st c=\"47090\">app</st>` <st c=\"47093\">instance, as shown in the</st> <st c=\"47120\">following snippet:</st>\n\n```", "```py\n app, celery_app, <st c=\"47681\">auth</st> = <st c=\"47688\">create_app('../config_dev.toml')</st> … … … … … … <st c=\"47732\">@auth.verify_password</st> def verify_password(<st c=\"47774\">username, password</st>): <st c=\"47797\">task = get_user_task_wrapper.apply_async( args=[username])</st><st c=\"47855\">login:Login = task.get()</st> if login == None: <st c=\"47899\">abort(403)</st><st c=\"47909\">if check_password_hash(login.password,password) == True:</st><st c=\"47966\">return login.username</st> else: <st c=\"48012\">HTTPBasicAuth</st>’s callback function, the given <st c=\"48058\">check_password()</st> must have the <st c=\"48089\">username</st> and <st c=\"48102\">password</st> parameters and should be annotated with <st c=\"48151\">HTTPBasicAuth</st>’s <st c=\"48168\">verify_password()</st> decorator. Our callback uses the Celery task to search and retrieve the <st c=\"48258\">Login</st> object containing the <st c=\"48286\">username</st> and <st c=\"48299\">password</st> details and raises <st c=\"48481\">HTTPBasicAuth</st>’s <st c=\"48498\">login_required()</st> decorator.\n\t\t\t<st c=\"48525\">The</st> `<st c=\"48530\">Flask-HTTPAuth</st>` <st c=\"48544\">module has built-in authorization</st> <st c=\"48579\">support.</st> <st c=\"48588\">If the basic authentication needs a</st> <st c=\"48623\">role-based authorization, the application only needs to have a separate callback function decorated by</st> `<st c=\"48727\">get_user_roles()</st>` <st c=\"48743\">from the</st> `<st c=\"48753\">HTTPBasicAuth</st>` <st c=\"48766\">class.</st> <st c=\"48774\">The following is</st> `<st c=\"48791\">ch09-auth-basic</st>`<st c=\"48806\">’s callback function for retrieving user roles from</st> <st c=\"48859\">its users:</st>\n\n```", "```py\n @current_app.delete('/doctor/profile/delete/<int:id>') <st c=\"49802\">@auth.login_required(role=\"1\")</st> async def del_doctor_profile_id(id:int):\n    async with db_session() as sess:\n      async with sess.begin():\n          repo = DoctorRepository(sess)\n          … … … … … …\n          return jsonify(record=\"deleted record\"), 200\n```", "```py\n<st c=\"50634\">from flask_httpauth import HTTPDigestAuth</st> def create_app(config_file):\n    app = Flask(__name__,template_folder= '../modules/pages', static_folder= '../modules/resources')\n    app.config.from_file(config_file, toml.load)\n    … … … … … … <st c=\"50900\">HTTPDigestAuth</st>’s constructors have five parameters, two of which have default values, namely <st c=\"50994\">qop</st> and <st c=\"51002\">algorithm</st>. The <st c=\"51061\">auth</st> value, which means that the application is at the basic protection level of the digest scheme. So far, the highest protection level is <st c=\"51201\">auth-int</st>, which is, at the time of writing this book, not yet functional in the <st c=\"51281\">Flask-HTTPAuth</st> module. The other parameter, <st c=\"51325\">algorithm</st>, has the <st c=\"51344\">md5</st> default value for the encryption, but the requirement can change it to <st c=\"51419\">md5-sess</st> or any supported encryption method. Now, the three other optional parameters are the following:\n\n\t\t\t\t*   `<st c=\"51523\">realm</st>`<st c=\"51529\">: This contains the</st> `<st c=\"51550\">username</st>` <st c=\"51558\">of the user and the name of the</st> <st c=\"51591\">application’s host.</st>\n\t\t\t\t*   `<st c=\"51610\">scheme</st>`<st c=\"51617\">: This is a replacement to the default value of the</st> `<st c=\"51670\">Digest scheme</st>` <st c=\"51683\">header in the</st> `<st c=\"51698\">WWW-Authenticate</st>` <st c=\"51714\">response.</st>\n\t\t\t\t*   `<st c=\"51724\">use_hw1_pw</st>`<st c=\"51735\">: If this is set to</st> `<st c=\"51756\">True</st>`<st c=\"51760\">, the</st> `<st c=\"51766\">get_password()</st>` <st c=\"51780\">callback function must return a</st> <st c=\"51813\">hashed password.</st>\n\n\t\t\t<st c=\"51829\">In digest authentication, the user must submit their username, password, nonce, opaque, and nonce count to the application for verification.</st> *<st c=\"51971\">Figure 9</st>**<st c=\"51979\">.4</st>* <st c=\"51981\">shows a postman client submitting the header information to the</st> `<st c=\"52046\">ch09-auth-digest</st>` <st c=\"52062\">app:</st>\n\t\t\t![Figure 9.4 – The Digest authentication scheme’s additional headers](img/B19383_09_004.jpg)\n\n\t\t\t<st c=\"52864\">Figure 9.4 – The Digest authentication scheme’s additional headers</st>\n\t\t\t<st c=\"52930\">A nonce is a unique base64 or hexadecimal string that the server generates for every</st> **<st c=\"53016\">HTTP status code 401</st>** <st c=\"53036\">response.</st> <st c=\"53047\">The content of the compressed string, usually the estimated timestamp when the client</st> <st c=\"53133\">received the response, must be unique to</st> <st c=\"53174\">every access.</st>\n\t\t\t<st c=\"53187\">Also specified by the server is</st> **<st c=\"53220\">opaque</st>**<st c=\"53226\">, a base64 or hexadecimal string value that the client needs to return to the</st> <st c=\"53304\">server for validation if it is the same value as</st> <st c=\"53353\">generated before.</st>\n\t\t\t<st c=\"53370\">The nonce count value or</st> `<st c=\"53463\">0000001</st>`<st c=\"53470\">, that checks the integrity of the user credentials and protects data from playback attacks.</st> <st c=\"53563\">The server increments its copy of the nc-value when it receives the same nonce value from a new request.</st> <st c=\"53668\">Every authentication request must bear a new nonce value.</st> <st c=\"53726\">Otherwise, it is</st> <st c=\"53743\">a replay.</st>\n\t\t\t`<st c=\"53752\">Flask-HTTPAuth</st>`<st c=\"53767\">’s digest authentication scheme will only work if our API application provides the following</st> <st c=\"53861\">callback implementations:</st>\n\n```", "```py\n\n\t\t\t<st c=\"54135\">The application must generate the nonce and opaque values using the likes of the</st> `<st c=\"54217\">gen_nonce()</st>` <st c=\"54228\">and</st> `<st c=\"54233\">gen_opaque()</st>` <st c=\"54245\">callbacks.</st> <st c=\"54257\">These are just trivial implementations of the methods in our</st> `<st c=\"54318\">ch09-auth-digest</st>` <st c=\"54334\">application and need better solutions that use a UUID generator</st> <st c=\"54398\">or a</st> `<st c=\"54404\">secrets</st>` <st c=\"54411\">module to generate the values.</st> <st c=\"54443\">The nonce generator callback must have a</st> `<st c=\"54484\">generate_nonce()</st>` <st c=\"54500\">decorator, while the opaque generator must be decorated by the</st> `<st c=\"54564\">generate_opaque()</st>` <st c=\"54581\">annotation.</st>\n\t\t\t<st c=\"54593\">Aside from these generators, the authentication scheme also needs the following validators of nonce and opaque values that the server needs from the</st> <st c=\"54743\">client request:</st>\n\n```", "```py\n\n\t\t\t<st c=\"54964\">The validators check whether the values from the request are correct based on the server’s corresponding values.</st> <st c=\"55078\">Now, the last</st> <st c=\"55092\">requirement for the digest authentication to work is the</st> `<st c=\"55149\">get_password()</st>` <st c=\"55163\">callback that</st> <st c=\"55178\">retrieves the password from the client for database validation of the user’s existence, as shown in the</st> <st c=\"55282\">following snippet:</st>\n\n```", "```py\n<st c=\"55933\">from flask_httpauth import HTTPTokenAuth</st> def create_app(config_file):\n    app = Flask(__name__,template_folder= '../modules/pages', static_folder=   '../modules/resources')\n    app.config.from_file(config_file, toml.load)\n    … … … … … … <st c=\"56236\">token</st> column field of the <st c=\"56262\">string</st> type in the <st c=\"56281\">Login</st> model to persist the token associated with the user. The application generates the token after the user signs up for login credentials. Our application uses the <st c=\"56448\">PyJWT</st> module for token generation, as depicted in the following endpoint function:\n\n```", "```py\n\n\t\t\t<st c=\"57141\">The token’s</st> `<st c=\"57175\">username</st>` <st c=\"57183\">and the token’s supposed expiration time in seconds.</st> <st c=\"57237\">The encoding indicated in the given</st> `<st c=\"57273\">add_signup()</st>` <st c=\"57285\">API method is the</st> `<st c=\"57371\">SECRET_KEY</st>`<st c=\"57381\">. The token is always part of the</st> <st c=\"57414\">request’s</st> `<st c=\"57425\">Authorization</st>` <st c=\"57438\">header with the</st> `<st c=\"57455\">Bearer</st>` <st c=\"57461\">value.</st> <st c=\"57469\">Now, a callback function retrieves the bearer token from the request and checks whether it is the saved token of the user.</st> <st c=\"57592\">The</st> <st c=\"57596\">following is</st> `<st c=\"57609\">ch09-auth-token</st>`<st c=\"57624\">’s callback</st> <st c=\"57637\">function implementation:</st>\n\n```", "```py\n\n\t\t\t<st c=\"57870\">The Bearer token’s callback function must have the</st> `<st c=\"57922\">verify_token()</st>` <st c=\"57936\">method decorator.</st> <st c=\"57955\">It has the</st> `<st c=\"57966\">token</st>` <st c=\"57971\">parameter and it returns either a boolean value or the username.</st> <st c=\"58037\">It must use the same</st> `<st c=\"58155\">PyJWT</st>` <st c=\"58160\">module encodes and decodes</st> <st c=\"58188\">the token.</st>\n\t\t\t<st c=\"58198\">Like basic, the digest and bearer token</st> <st c=\"58239\">authentication schemes use the</st> `<st c=\"58270\">login_required()</st>` <st c=\"58286\">decorator to impose restrictions on API endpoints.</st> <st c=\"58338\">Also, both can implement role-based authorization</st> <st c=\"58388\">with the</st> `<st c=\"58397\">get_user_roles()</st>` <st c=\"58413\">callback.</st>\n\t\t\t<st c=\"58423\">The next Flask module,</st> `<st c=\"58447\">Authlib</st>`<st c=\"58454\">, has core classes and methods for implementing OAuth2, OpenID Connect, and JWT Token-based authentication schemes.</st> <st c=\"58570\">Let us now</st> <st c=\"58581\">showcase it.</st>\n\t\t\t<st c=\"58593\">Utilizing the Authlib module</st>\n\t\t\t`<st c=\"59046\">authlib</st>` <st c=\"59053\">module, install its module using the following</st> `<st c=\"59101\">pip</st>` <st c=\"59104\">command:</st>\n\n```", "```py\n\n\t\t\t<st c=\"59133\">If the application to secure is not running on an HTTPS protocol, set the</st> `<st c=\"59208\">AUTHLIB_INSECURE_TRANSPORT</st>` <st c=\"59234\">environment variable to</st> `<st c=\"59259\">1</st>` <st c=\"59260\">or</st> `<st c=\"59264\">True</st>` <st c=\"59268\">for Authlib to work because it is for a</st> <st c=\"59309\">secured environment.</st>\n\t\t\t<st c=\"59329\">Unlike the HTTP Basic, Digest, and Bearer Token authentication schemes, the OAuth2.0 scheme uses an authorization server that provides several endpoints for authorization procedures, as well as issuing tokens, refreshing tokens, and revoking tokens.</st> <st c=\"59580\">The authorization server is always part of an application that protects its resources from malicious access and attacks.</st> <st c=\"59701\">Our</st> `<st c=\"59705\">ch09-oauth2-password</st>` <st c=\"59725\">project implements the Vaccine and Reports applications with the OAuth2 Resource Owner Password authorization scheme using Authlib.</st> <st c=\"59858\">The following</st> `<st c=\"59872\">create_app()</st>` <st c=\"59884\">factory method shows how to set up</st> <st c=\"59920\">this scheme:</st>\n\n```", "```py\n<st c=\"61353\">from authlib.oauth2.rfc6749.grants import</st> <st c=\"61395\">ResourceOwnerPasswordCredentialsGrant</st> class PasswordGrant(<st c=\"61454\">ResourceOwnerPasswordCredentialsGrant</st>): <st c=\"61496\">TOKEN_ENDPOINT_AUTH_METHODS</st> = [\n      'client_secret_basic', 'client_secret_post' ]\n    def authenticate_user(self, <st c=\"61602\">username</st>, <st c=\"61612\">password</st>):\n         task = get_user_task_wrapper.apply_async(args=[username])\n         login:Login = task.get()\n         if login is not None and check_password_hash( login.password, password) == True: <st c=\"61805\">PasswordGrant</st> custom class is in the <st c=\"61842\">/modules/security/oauth2_config.py</st> module with the <st c=\"61893\">query_client()</st> and <st c=\"61912\">save_token()</st> authorization server methods. The first component of <st c=\"61978\">PasswordGrant</st> to configure is its <st c=\"62012\">TOKEN_ENDPOINT_AUTH_METHODS</st>, which, from its default <st c=\"62065\">public</st> value, needs to be set to <st c=\"62098\">client_secret_basic</st>, <st c=\"62119\">client_secret_post</st>, or both. The <st c=\"62152\">client_secret_basic</st> is a client authentication that passes client secrets through a basic authentication scheme, while <st c=\"62271\">client_secret_post</st> utilizes form parameters to pass client secrets to the authorization server. On the other hand, the overridden <st c=\"62401\">authenticate_user()</st> retrieves the <st c=\"62435\">username</st> and <st c=\"62448\">password</st> from the token generator endpoint through basic authentication or form submission. It also retrieves the <st c=\"62562\">Login</st> record object from the database through a <st c=\"62610\">get_user_task_wrapper()</st> Celery task and validates the <st c=\"62664\">Login</st>’s hashed password with the retrieved password from the client. The method returns the <st c=\"62757\">Login</st> object that will signal the execution of the <st c=\"62808\">query_client()</st> method. The following snippet shows our <st c=\"62863\">query_client()</st> implementation:\n\n```", "```py\n\n\t\t\t<st c=\"63029\">The</st> `<st c=\"63034\">query_client()</st>` <st c=\"63048\">is a necessary method of the</st> `<st c=\"63078\">AuthorizationServer</st>` <st c=\"63097\">instance.</st> <st c=\"63108\">Its goal is to find the client who requested the authentication and return the</st> `<st c=\"63187\">Client</st>` <st c=\"63193\">object.</st> <st c=\"63202\">It retrieves</st> <st c=\"63215\">the</st> `<st c=\"63219\">client_id</st>` <st c=\"63228\">from the</st> `<st c=\"63238\">AuthorizationServer</st>` <st c=\"63258\">endpoint and uses it to search for the</st> `<st c=\"63297\">Client</st>` <st c=\"63303\">object from the database.</st> <st c=\"63330\">The following snippet shows how to build the</st> `<st c=\"63375\">Client</st>` <st c=\"63381\">blueprint with</st> `<st c=\"63397\">Authlib</st>`<st c=\"63404\">’s</st> `<st c=\"63408\">OAuth2ClientMixin</st>`<st c=\"63425\">:</st>\n\n```", "```py\n\n\t\t\t<st c=\"63788\">Authlib’s</st> `<st c=\"63799\">OAuth2ClientMixin</st>` <st c=\"63816\">will pad all the necessary column fields to the model class, including those that are optional.</st> <st c=\"63913\">The required pre-tokenization fields, such as</st> `<st c=\"63959\">id</st>`<st c=\"63961\">,</st> `<st c=\"63963\">user_id</st>` <st c=\"63970\">or</st> `<st c=\"63974\">username</st>`<st c=\"63982\">,</st> `<st c=\"63984\">client_id</st>`<st c=\"63993\">,</st> `<st c=\"63995\">client_id_issued_at</st>`<st c=\"64014\">, and</st> `<st c=\"64020\">client_secret</st>`<st c=\"64033\">, must be submitted to the database during client signup before the authentication starts.</st> <st c=\"64124\">Now, if the client is valid, the</st> `<st c=\"64157\">save_token()</st>` <st c=\"64169\">will execute to retrieve the</st> `<st c=\"64199\">access_token</st>` <st c=\"64211\">from the authorization server and save it to the database.</st> <st c=\"64271\">The following snippet is our</st> <st c=\"64299\">implementation</st> <st c=\"64315\">for</st> `<st c=\"64319\">save_token()</st>`<st c=\"64331\">:</st>\n\n```", "```py\n<st c=\"65319\">from authlib.integrations.sqla_oauth2 import OAuth2TokenMixin</st> class Token(Base, <st c=\"65400\">OAuth2TokenMixin</st>):\n    __tablename__ = 'oauth2_token'\n    id = Column(Integer, Sequence('oauth2_token_id_seq', increment=1), primary_key=True)\n    user_id = Column(String(40), ForeignKey('login.username'), nullable=False)\n    login = relationship('Login', back_populates=\"token\")\n    … … … … … …\n```", "```py\n from flask import current_app, request <st c=\"66218\">from modules import oauth_server</st> @current_app.route('/oauth/token', <st c=\"66286\">methods=['POST']</st>)\nasync def issue_token(): <st c=\"66443\">POST</st> transaction mode. The <st c=\"66470\">Authorization</st> <st c=\"66483\">Server</st> object from the <st c=\"66507\">create_app()</st> provides the <st c=\"66533\">create_token_response()</st> with details that the method needs to return for the user to capture the <st c=\"66630\">access_token()</st>. Given the <st c=\"66656\">client_id</st> of <st c=\"66669\">Xd3LH9mveF524LOscPq4MzLY</st> and <st c=\"66698\">client_secret</st> <st c=\"66711\">t8w56Y9OBRsxdVV9vrNwdtMzQ8gY4hkKLKf4b6F6RQZlT2zI</st> with the <st c=\"66770\">sjctrags</st> username, the following <st c=\"66803\">curl</st> command shows how to run the <st c=\"66837\">/</st><st c=\"66838\">oauth/token</st> endpoint:\n\n```", "```py\n\n\t\t\t<st c=\"67118\">A sample result of executing</st> <st c=\"67148\">the preceding command will contain the following details aside from</st> <st c=\"67216\">the</st> `<st c=\"67220\">access_token</st>`<st c=\"67232\">:</st>\n\n```", "```py\n\n\t\t\t<st c=\"67366\">As indicated in the result, the</st> `<st c=\"67399\">token_type</st>` <st c=\"67409\">is</st> `<st c=\"67413\">Bearer</st>`<st c=\"67419\">, so we can use the</st> `<st c=\"67439\">access_token</st>` <st c=\"67451\">to access or run an API endpoint through a bearer Token authentication, like in the following</st> `<st c=\"67546\">curl</st>` <st c=\"67550\">command:</st>\n\n```", "```py\n\n\t\t\t<st c=\"67676\">A secured API endpoint must have the</st> `<st c=\"67714\">require_oauth(\"user_admin\")</st>` <st c=\"67741\">method decorator, wherein</st> `<st c=\"67768\">require_oath</st>` <st c=\"67780\">is the</st> `<st c=\"67788\">ResourceProtector</st>` <st c=\"67805\">instance from the</st> `<st c=\"67824\">create_app()</st>`<st c=\"67836\">. A sample secured endpoint is the following</st> `<st c=\"67881\">add_doctor_profile()</st>` <st c=\"67901\">API function:</st>\n\n```", "```py\n\n\t\t\t<st c=\"68298\">Aside from the Resource Owner Password grant, Authlib has an</st> `<st c=\"68360\">AuthorizationCodeGrant</st>` <st c=\"68382\">class to</st> <st c=\"68391\">implement an</st> `<st c=\"68449\">JWTBearerGrant</st>` <st c=\"68463\">for implementing the</st> `<st c=\"68559\">ch09-oauth-code</st>` <st c=\"68574\">project will</st> <st c=\"68588\">showcase the full implementation</st> <st c=\"68620\">of the OAuth2 authorization code flow, while</st> `<st c=\"68666\">ch09-oauth2-jwt</st>` <st c=\"68681\">will implement the JWT authorization scheme (</st>`<st c=\"68749\">pyjwt</st>` <st c=\"68754\">module.</st>\n\t\t\t<st c=\"68762\">If Flask supports popular and ultimate authentication and authorization modules, like Authlib, it also supports unpopular but reliable extension modules that can secure web-based and API-based Flask applications.</st> <st c=\"68976\">One of</st> <st c=\"68983\">these modules is</st> *<st c=\"69000\">Flask-Limiter</st>*<st c=\"69013\">, which can prevent</st> `<st c=\"69103\">ch09-web-passphrase</st>` <st c=\"69122\">project.</st>\n\t\t\t<st c=\"69131\">Controlling the view or API access</st>\n\t\t\t<st c=\"69166\">DoS attacks happen when a user maliciously accesses a web page or API multiple times to disrupt the traffic and make the</st> <st c=\"69287\">resources inaccessible to others.</st> `<st c=\"69322\">Flask-Limiter</st>` <st c=\"69335\">can provide an immediate solution by managing the number of access of a user to an API endpoint.</st> <st c=\"69433\">First, install the</st> `<st c=\"69452\">Flask-Limiter</st>` <st c=\"69465\">module using the following</st> `<st c=\"69493\">pip</st>` <st c=\"69496\">command:</st>\n\n```", "```py\n\n\t\t\t<st c=\"69531\">Also, install the module dependency for caching its configuration details to the</st> <st c=\"69613\">Redis server:</st>\n\n```", "```py\n\n\t\t\t<st c=\"69659\">Now, we can set up the module’s</st> `<st c=\"69692\">Limiter</st>` <st c=\"69699\">class in the</st> `<st c=\"69713\">create_app()</st>` <st c=\"69725\">factory method, like in the</st> <st c=\"69754\">following snippet:</st>\n\n```", "```py\n\n\t\t\t<st c=\"70139\">Instantiating the</st> `<st c=\"70158\">Limiter</st>` <st c=\"70165\">class requires at least the</st> `<st c=\"70194\">app</st>` <st c=\"70197\">instance, the host of the application through the</st> `<st c=\"70248\">get_remote_address()</st>`<st c=\"70268\">, the</st> `<st c=\"70274\">default_limits</st>` <st c=\"70288\">(e.g.,</st> `<st c=\"70296\">10 per hour</st>`<st c=\"70307\">,</st> `<st c=\"70309\">10 per 2 hours</st>`<st c=\"70323\">, or</st> `<st c=\"70328\">10/hour</st>`<st c=\"70335\">), and the storage URI for the Redis server.</st> <st c=\"70381\">The</st> `<st c=\"70385\">Limiter</st>` <st c=\"70392\">instance will</st> <st c=\"70407\">provide each protected API with the</st> `<st c=\"70443\">limit()</st>` <st c=\"70450\">decorator that specifies the number of accesses not lower than the set default limit.</st> <st c=\"70537\">The following API is restricted not to be accessed by a user more than a</st> *<st c=\"70610\">maximum count of 5 times</st>* *<st c=\"70635\">per minute</st>*<st c=\"70645\">:</st>\n\n```", "```py\n\n\t\t\t<st c=\"71115\">Running</st> `<st c=\"71124\">login_user()</st>` <st c=\"71136\">more than the</st> <st c=\"71151\">limit will give us the message shown in</st> *<st c=\"71191\">Figure 9</st>**<st c=\"71199\">.5</st>*<st c=\"71201\">.</st>\n\t\t\t![Figure 9.5 – Accessing /login/auth more than the limit](img/B19383_09_005.jpg)\n\n\t\t\t<st c=\"71287\">Figure 9.5 – Accessing /login/auth more than the limit</st>\n\t\t\t<st c=\"71341\">Violating the number of access rules set by Talisman will lead users to its built-in error handling mechanism: the application rendering an error page with its</st> <st c=\"71502\">error message.</st>\n\t\t\t<st c=\"71516\">Summary</st>\n\t\t\t<st c=\"71524\">In this chapter, we learned that compared to FastAPI and Tornado, there is quite a list of extension modules that provide solutions to secure a Flask application against various attacks.</st> <st c=\"71712\">For instance, Flask-Seasurf and Flask-WTF can help minimize CSRF attacks.</st> <st c=\"71786\">When pursuing web authentication, Flask-Login can provide a reliable authentication mechanism with added password hashing and encryption mechanisms, as we learned in</st> <st c=\"71952\">this chapter.</st>\n\t\t\t<st c=\"71965\">On the other hand, Flask-HTTPAuth can provide API-based applications with HTTP basic, digest, and bearer token authentication schemes.</st> <st c=\"72101\">We learned that OAuth2 Authorization server grants and OAuth2 JWT Token-based types can also protect Flask applications from other</st> <st c=\"72232\">applications’ access.</st>\n\t\t\t<st c=\"72253\">The Flask-Talisman ensures security rules on response headers to filter the outgoing response of every API endpoint.</st> <st c=\"72371\">Meanwhile, the Flask-Session module saves Flask sessions in the filesystem to avoid browser-based attacks.</st> <st c=\"72478\">Escaping, stripping of whitespaces, and form validation of incoming inputs using modules like Gladiator and Flask-WTF helps prevent injection attacks by eliminating suspicious text or alphanumerics in</st> <st c=\"72679\">the inputs.</st>\n\t\t\t<st c=\"72690\">This chapter proved that several updated and version-compatible modules can help protect our applications from malicious and unwanted attacks.</st> <st c=\"72834\">These modules can save time and effort compared to ground-up solutions in securing</st> <st c=\"72917\">our applications.</st>\n\t\t\t<st c=\"72934\">The next chapter will be about testing Flask components before running and deploying them to</st> <st c=\"73028\">production servers.</st>\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```"]