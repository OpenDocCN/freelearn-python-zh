- en: Chapter 9. Design Approaches and Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 设计方法和技巧
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating Singletons
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单例
- en: Implementing an observer pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现观察者模式
- en: Strategy pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: Model View Controller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器
- en: Using mixin classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混合类
- en: Using decorators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Programming is all about patterns. There are patterns at every level, from the
    programming language itself, to the toolkit, to the application. Being able to
    discern and choose the optimal approach to use to solve the problem at hand can
    at times be a difficult task. The more patterns you know, the bigger your toolbox,
    and the easier it will become to be able to choose the right tool for the job.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编程全在于模式。从编程语言本身，到工具集，再到应用，每个层面都有模式。能够辨别并选择最合适的解决方案来处理当前问题，有时可能是一项艰巨的任务。你了解的模式越多，你的工具箱就越丰富，选择正确工具来完成工作的难度也就越小。
- en: Different programming languages and toolkits often lend themselves to certain
    patterns and approaches to problem solving. The Python programming language and
    wxPython are no different, so let's jump in and take a look at how to apply some
    common design approaches and techniques to wxPython applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言和工具包通常倾向于某些模式和解决问题的方法。Python 编程语言和 wxPython 也毫不例外，因此让我们深入探讨一下如何将一些常见的设计方法和技巧应用到
    wxPython 应用程序中。
- en: Creating Singletons
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单例模式
- en: In object oriented programming, the Singleton pattern is a fairly simple concept
    of only allowing exactly one instance of a given object to exist at a given time.
    This means that it only allows for only one instance of the object to be in memory
    at any given time, so that all references to the object are shared throughout
    the application. Singletons are often used to maintain a global state in an application
    since all occurances of one in an application reference the same exact instance
    of the object. Within the core wxPython library, there are a number of singleton
    objects, such as `ArtProvider, ColourDatabase`, and `SystemSettings`. This recipe
    shows how to make a singleton `Dialog` class, which can be useful for creating
    non-modal dialogs that should only have a single instance present at a given time,
    such as a settings dialog or a special tool window.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，单例模式是一个相对简单的概念，它只允许在给定时间只有一个给定对象的实例存在。这意味着在任何给定时间，它只允许对象的一个实例存在于内存中，因此应用程序中所有对该对象的引用都是共享的。单例通常用于在应用程序中维护全局状态，因为应用程序中所有单例的实例都引用了该对象完全相同的实例。在wxPython核心库中，存在许多单例对象，例如`ArtProvider`、`ColourDatabase`和`SystemSettings`。本菜谱展示了如何创建一个单例`Dialog`类，这对于创建在给定时间只应有一个实例存在的非模态对话框非常有用，例如设置对话框或特殊工具窗口。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To get started, we will define a metaclass that can be reused on any class that
    needs to be turned into a singleton. We will get into more detail later in the
    *How it works* section. A metaclass is a class that creates a class. It is passed
    a class to it's `__init__` and `__call__` methods when someone tries to create
    an instance of the class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将定义一个元类，它可以被任何需要转换为单例的类重复使用。我们将在“如何工作”部分后面详细介绍。元类是一个创建类的类。当有人尝试创建类的实例时，它会将一个类传递给它的`__init__`和`__call__`方法。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we have an example of the use of our metaclass, which shows how easy it
    is to turn the following class into a singleton class by simply assigning the
    `Singleton` class as the `__metaclass__` of `SingletonDialog`. The only other
    requirement is to define the `SetupWindow` method that the `Singleton` metaclass
    uses as an initialization hook to set up the window the first time an instance
    of the class is created.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用我们元类的例子，它展示了如何通过简单地将`Singleton`类指定为`SingletonDialog`的`__metaclass__`，轻松地将以下类转换为单例类。唯一的另一个要求是定义`Singleton`元类使用的`SetupWindow`方法，作为初始化钩子，在创建类的第一个实例时设置窗口。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Note that in Python 3+ the `__metaclass__` attribute has been replaced with
    a metaclass keyword argument in the class definition.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Python 3+ 中，`__metaclass__` 属性已被替换为类定义中的元类关键字参数。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a number of ways to implement a Singleton in Python. In this recipe,
    we used a metaclass to accomplish the task. This is a nicely contained and easily
    reusable pattern to accomplish this task. The `Singleton` class that we defined
    can be used by any class that has a `SetupWindow` method defined for it. So now
    that we have done it, let's take a quick look at how a singleton works.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中实现单例模式有多种方法。在这个菜谱中，我们使用元类来完成这个任务。这是一个很好地封装且易于重用的模式来完成这项任务。我们定义的 `Singleton`
    类可以被任何定义了 `SetupWindow` 方法的类使用。所以，既然我们已经完成了这个任务，让我们快速看一下单例是如何工作的。
- en: 'The Singleton metaclass dynamically creates and adds a class variable called
    `instance` to the passed in class. So just to get a picture of what is going on,
    the metaclass would generate the following code in our example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单例元类动态地为传入的类创建并添加一个名为 `instance` 的类变量。为了更清楚地了解这个过程，元类在我们的示例中会生成以下代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then the first time the metaclass''s `__call__` method is invoked, it will
    then assign the instance of the class object returned by the super class''s `__call__`
    method, which in this recipe is an instance of our `SingletonDialog`. So basically,
    it is the equivalent of the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么第一次调用元类的 `__call__` 方法时，它将分配由超类的 `__call__` 方法返回的类对象实例，在这个菜谱中是一个我们的 `SingletonDialog`
    的实例。所以基本上，它等同于以下内容：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Any subsequent initializations will cause the previously-created one to be returned,
    instead of creating a new one since the class definition maintains the lifetime
    of the object and not an individual reference created in the user code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续的初始化都将导致返回之前创建的那个，而不是创建一个新的，因为类定义维护的是对象的生存期，而不是用户代码中创建的单独引用。
- en: Our `SingletonDialog` class is a very simple Dialog that has `TextCtrl, CheckBox`,
    and `Ok Button` objects on it. Instead of invoking initialization in the dialog's
    `__init__` method, we instead defined an interface method called `SetupWindow`
    that will be called by the Singleton metaclass when the object is initially created.
    In this method, we just perform a simple layout of our controls in the dialog.
    If you run the sample application that accompanies this topic, you can see that
    no matter how many times the show dialog button is clicked, it will only cause
    the existing instance of the dialog to be brought to the front. Also, if you make
    changes in the dialog's `TextCtrl` or `CheckBox`, and then close and reopen the
    dialog, the changes will be retained since the same instance of the dialog will
    be re-shown instead of creating a new one.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `SingletonDialog` 类是一个非常简单的对话框，它上面有 `TextCtrl`、`CheckBox` 和 `Ok Button`
    对象。我们不是在对话框的 `__init__` 方法中调用初始化，而是定义了一个名为 `SetupWindow` 的接口方法，当对象最初创建时，由 Singleton
    元类调用该方法。在这个方法中，我们只是简单地对对话框中的控件进行布局。如果你运行与这个主题相关的示例应用程序，你会发现无论点击显示对话框按钮多少次，它只会导致现有对话框实例被带到前台。此外，如果你在对话框的
    `TextCtrl` 或 `CheckBox` 中进行更改，然后关闭并重新打开对话框，更改将被保留，因为相同的对话框实例将被重新显示，而不是创建一个新的实例。
- en: Implementing an observer pattern
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现观察者模式
- en: The observer pattern is a design approach where objects can subscribe as observers
    of events that other objects are publishing. The publisher(s) of the events then
    just broadcasts the events to all of the subscribers. This allows the creation
    of an extensible, loosely-coupled framework of notifications, since the publisher(s)
    don't require any specific knowledge of the observers. The `pubsub` module provided
    by the `wx.lib` package provides an easy-to-use implementation of the observer
    pattern through a publisher/subscriber approach. Any arbitrary number of objects
    can subscribe their own callback methods to messages that the publishers will
    send to make their notifications. This recipe shows how to use the `pubsub` module
    to send configuration notifications in an application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是一种设计方法，其中对象可以作为其他对象发布事件的观察者进行订阅。事件的发布者（们）随后只需将事件广播给所有订阅者。这允许创建一个可扩展的、松散耦合的通知框架，因为发布者（们）不需要对观察者有任何特定的了解。由`wx.lib`包提供的`pubsub`模块通过发布者/订阅者方法提供了一个易于使用的观察者模式实现。任意数量的对象都可以将自己的回调方法订阅到发布者将发送的消息，以便进行通知。这个配方展示了如何使用`pubsub`模块在应用程序中发送配置通知。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, we will create our application configuration object that stores runtime
    configuration variables for an application and provides a notification mechanism
    for whenever a value is added or modified in the configuration, through an interface
    that uses the observer pattern:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建我们的应用程序配置对象，该对象存储应用程序的运行时配置变量，并提供一个通知机制，以便在配置中添加或修改值时，通过使用观察者模式的一个接口来通知：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we will create a very simple application to show how to subscribe observers
    to configuration changes in the `Configuration` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个非常简单的应用程序来展示如何将观察者订阅到`Configuration`类中的配置更改：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This dialog will have one configuration option on it to allow the user to change
    the applications font:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框将包含一个配置选项，允许用户更改应用程序的字体：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, in the `FontPicker''s` event handler, we get the newly-selected font
    and call `SetValue` on the `Configuration` object owned by the `App` object in
    order to change the configuration, which will then cause the `(''config'', ''font'')`
    message to be published:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，在`FontPicker`的事件处理程序中，我们获取新选定的字体，并调用`App`对象拥有的`Configuration`对象的`SetValue`方法来更改配置，这将导致发布`('config',
    'font')`消息：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, here, we define the application''s main window that will subscribe it''s
    `OnConfigMsg` method as an observer of all `(''config'',)` messages, so that it
    will be called whenever the configuration is modified:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这里，我们定义应用程序的主窗口，使其`OnConfigMsg`方法作为所有`('config',)`消息的观察者，这样每当配置被修改时，它就会被调用：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the observer method that will be called when any message beginning
    with`''config''` is sent by the `pubsub Publisher`. In this sample application,
    we just check for the `(''config'', ''font'')` message and update the font of
    the `TextCtrl` object to use the newly-configured one:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是当`pubsub Publisher`发送以`'config'`开头的任何消息时将被调用的观察者方法。在这个示例应用中，我们仅检查`('config',
    'font')`消息，并将`TextCtrl`对象的字体更新为新配置的字体：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe shows a convenient way to manage an application's configuration
    by allowing the interested parts of an application to subscribe to updates when
    certain parts of the configuration are modified. Let's start with a quick walkthrough
    of how pubsub works.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了一种通过允许应用程序感兴趣的部分在配置的某些部分被修改时订阅更新来管理应用程序配置的便捷方法。让我们快速了解一下pubsub是如何工作的。
- en: Pubsub messages use a tree structure to organize the categories of different
    messages. A message type can be defined either as a tuple `('root', 'child1',
    'grandchild1')` or as a dot-separated string (`'root.child1.grandchild1'`). Subscribing
    a callback to `('root',)` will cause your callback method to be called for all
    messages that start with `('root',)`. This means that if a component publishes
    `('root', 'child1', 'grandchild1')` or `('root', 'child1')`, then any method that
    is subscribed to `('root',)` will also be called.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Pubsub消息使用树状结构来组织不同消息的分类。一个消息类型可以被定义为元组`('root', 'child1', 'grandchild1')`，或者定义为点分隔的字符串`'root.child1.grandchild1'`。将回调函数订阅到`('root',)`将会导致您的回调方法对所有以`('root',)`开头的消息被调用。这意味着如果一个组件发布了`('root',
    'child1', 'grandchild1')`或`('root', 'child1')`，那么所有订阅到`('root',)`的方法也将被调用。
- en: Pubsub basically works by storing the mapping of message types to callbacks
    in static memory in the `pubsub` module. In Python, modules are only imported
    once any other part of your application that uses the `pubsub` module shares the
    same singleton `Publisher` object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pubsub基本上是通过在`pubsub`模块的静态内存中存储消息类型到回调的映射来工作的。在Python中，模块只会在你的应用程序的任何其他部分使用`pubsub`模块并且共享相同的单例`Publisher`对象时才导入一次。
- en: In our recipe, the `Configuration` object is a simple object for storing data
    about the configuration of our application. Its `SetValue` method is the important
    part to look at. This is the method that will be called whenever a configuration
    change is made in the application. In turn, when this is called, it will send
    a pubsub message of `('config',) + (key,)` that will allow any observers to subscribe
    to either the root item or more specific topics determined by the exact configuration
    item.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，`Configuration` 对象是一个用于存储关于我们应用程序配置数据的简单对象。它的 `SetValue` 方法是重要的部分，需要关注。这是每当应用程序中发生配置更改时将被调用的方法。反过来，当这个方法被调用时，它将发送一个
    `('config',) + (key,)` 的 pubsub 消息，这将允许任何观察者订阅根项或由确切配置项确定的更具体的主题。
- en: Next, we have our simple `ConfigDialog` class. This is just a simple example
    that only has an option for configuring the application's font. When a change
    is made in the `FontPickerCtrl` in the `ConfigPanel`, the `Configuration` object
    will be retrieved from the `App` and will be updated to store the newly-selected
    `Font`. When this happens, the `Configuration` object will publish an update message
    to all subscribed observers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个简单的 `ConfigDialog` 类。这只是一个简单的示例，它只提供了一个配置应用程序字体的选项。当在 `ConfigPanel`
    中的 `FontPickerCtrl` 发生更改时，将从 `App` 中检索 `Configuration` 对象，并将其更新以存储新选择的 `Font`。当这种情况发生时，`Configuration`
    对象将向所有已订阅的观察者发布一个更新消息。
- en: Our `ObserverFrame` is an observer of all `('config',)` messages by subscribing
    its `OnConfigMsg` method to `MSG_CONFIG_ROOT. OnConfigMsg` will be called any
    time the `Configuration` object's `SetValue` method is called. The `msg` parameter
    of the callback will contain a `Message` object that has a `topic` and `data`
    attribute. The `topic` attribute will contain the tuple that represents the message
    that triggered the callback and the `data` attribute will contain any data that
    was associated with the `topic` by the publisher of the message. In the case of
    a `('config', 'font')` message, our handler will update the `Font` of the `Frame`
    and its `TextCtrl`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ObserverFrame` 通过将其 `OnConfigMsg` 方法订阅到 `MSG_CONFIG_ROOT` 上，成为所有 `('config',)`
    消息的观察者。每当调用 `Configuration` 对象的 `SetValue` 方法时，都会调用 `OnConfigMsg`。回调的 `msg` 参数将包含一个具有
    `topic` 和 `data` 属性的 `Message` 对象。`topic` 属性将包含触发回调的消息的元组，而 `data` 属性将包含消息发布者与
    `topic` 关联的任何数据。在 `('config', 'font')` 消息的情况下，我们的处理程序将更新 `Frame` 的 `Font` 和其 `TextCtrl`。
- en: See also
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Creating Singletons* recipe in this chapter for an explanation of how
    singleton objects like the Publisher from this recipe work.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的 *创建单例* 菜谱，以了解像本菜谱中的 Publisher 这样的单例对象是如何工作的。
- en: See the *Making a tool window* recipe in [Chapter 10](ch10.html "Chapter 10. Creating
    Components and Extending Functionality"), *Creating Components and Extending Functionality*
    for another example of the publisher pattern in action.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第10章中的*创建工具窗口*配方，[第10章](ch10.html "第10章。创建组件和扩展功能")，以了解*创建组件和扩展功能*中另一个使用发布者模式的示例。
- en: Strategy pattern
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: The strategy pattern is an approach that allows for an application to choose
    the strategy or behavior that will be used at run time. It accomplishes this by
    encapsulating different algorithms and making them usable by the client regardless
    of what the underlying behavior of the algorithm is. This is probably one of the
    most fundamental design patterns in programming, and you're probably already using
    it in one form or another without even knowing it. This recipe shows how to create
    a reusable `Dialog` class that uses the strategy pattern to allow for the main
    content to vary depending on the strategy used.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是一种允许应用程序在运行时选择将使用的策略或行为的途径。它通过封装不同的算法并使客户能够使用它们，而不管算法的底层行为是什么来实现这一点。这可能是编程中最基本的设计模式之一，你可能已经在不知情的情况下以某种形式使用过它。这个配方展示了如何创建一个可重用的`Dialog`类，该类使用策略模式来允许主要内容根据所使用的策略而变化。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we will start by defining a base interface with all of the strategies
    that our dialog class will use:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从定义一个包含我们对话类将使用所有策略的基本接口开始：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let''s define our simple Ok/Cancel dialog, which will use a strategy derived
    from our `BaseDialogStrategy` class to allow its main content area to vary depending
    on the strategy used:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来定义我们的简单“确定/取消”对话框，它将使用从我们的`BaseDialogStrategy`类派生出的策略，以便其主内容区域可以根据所使用的策略而变化：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, in the following methods of our `StrategyDialog`, we just delegate to
    the current strategy to allow it to define the behavior of the dialog:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下我们的`StrategyDialog`方法的实现中，我们只是委托给当前策略，以便它能够定义对话框的行为：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s implement a simple strategy that can be used to get the dialog to
    display a control for selecting a file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现一个简单的策略，该策略可以用来让对话框显示一个用于选择文件的控件：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, in an application, all that needs to be done to create a dialog that
    uses this strategy would be the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在应用中，要创建一个使用此策略的对话框，所需进行的操作如下：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since all strategies that our dialog will use must be interchangeable, it is
    important to define an interface that they will implement. So, in our `BaseDialogStrategy`
    class, we defined a simple three-method interface that our `StrategyDialog` will
    delegate to.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对话将使用的所有策略都必须可互换，因此定义一个它们将实现的接口非常重要。因此，在我们的`BaseDialogStrategy`类中，我们定义了一个简单的三方法接口，我们的`StrategyDialog`将委托给这个接口。
- en: The `StrategyDialog` is basically just a simple generic shell that delegates
    all decisions regarding its appearance and behavior to the strategy. When the
    dialog is initialized, it asks the strategy for a window object that will be used
    as the main content area of the dialog. The dialog then creates and adds some
    standard OK/Cancel buttons to the interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`StrategyDialog`基本上只是一个简单的通用外壳，将有关其外观和行为的所有决策委托给策略。当对话框初始化时，它会向策略请求一个窗口对象，该对象将用作对话框的主要内容区域。然后，对话框在界面中创建并添加一些标准的确定/取消按钮。'
- en: When a user clicks on one of these buttons, the `StrategyDialog` will then simply
    delegate to its strategy, to allow the strategy to handle the user action. This
    allows us to reuse this dialog class in many different ways, by simply implementing
    different strategies.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击这些按钮之一时，`StrategyDialog` 将简单地委托给其策略，以便策略处理用户操作。这使我们能够通过简单地实现不同的策略，以多种不同的方式重用这个对话框类。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Model View Controller* recipe in this chapter for some more examples
    of a strategy pattern.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的*模型-视图-控制器*配方，以获取策略模式的一些更多示例。
- en: Model View Controller
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（Model View Controller）
- en: '**Model View Controller** (**MVC**) is a design pattern that creates a clear
    separation of concerns within a program''s architecture. It breaks down into three
    layers: the **Model**, which is the application''s data objects and business logic
    at the bottom, the **View** at the top, which typically consists of controls for
    displaying and editing data, and finally the **Controller** in the middle, which
    is responsible for mediating the flow of data from the Model to the View and vice
    versa:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）是一种设计模式，它在一个程序的架构中创建了一个清晰的关注点分离。它分为三个层次：底层的**模型**，其中包含应用程序的数据对象和业务逻辑，顶层的**视图**，通常由用于显示和编辑数据的控件组成，最后是中间的**控制器**，它负责在模型和视图之间以及反之亦然的数据流的中介：'
- en: '![Model View Controller](img/1780OS_09_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-控制器](img/1780OS_09_01.jpg)'
- en: MVC is really one big monster pattern made up of other, simpler patterns working
    together. The Model implements an observer pattern to keep interested parties
    updated on changes, which allows it to be implemented separately from the View
    and Controller. The View and the Controller, on the other hand, implement a strategy
    pattern where the Controller is a strategy that implements the behavior of the
    View.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: MVC实际上是由其他更简单的模式组合而成的一个大怪物模式。模型（Model）实现了一个观察者模式（observer pattern），以便在变化时更新感兴趣的各方，这使得它可以从视图（View）和控制器（Controller）中独立实现。另一方面，视图（View）和控制器（Controller）实现了一个策略模式（strategy
    pattern），其中控制器（Controller）是一个实现视图行为的策略。
- en: In this recipe, we explore how to create a simple number generator application
    that implements this pattern in wxPython.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们探讨如何创建一个简单的数字生成器应用程序，该程序在wxPython中实现了这个模式。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Since there are multiple components that need to work together, having defined
    interfaces is an important step in the process, so first let us define some base
    classes that define the interface for our number generator's model and controller.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在多个需要协同工作的组件，定义接口是这个过程的重要一步，因此首先让我们定义一些基类，这些基类将定义我们数字生成器模型和控制器接口。
- en: 'Beginning with our Model''s interface, we provide a class that simply requires
    its `Generate` method to be overridden in order to provide the implementation-specific
    behavior. We have also built in a simple observer pattern mechanism to allow the
    view to subscribe to update notifications in the model:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们模型的界面开始，我们提供了一个类，该类只需重写其`Generate`方法即可提供特定实现的行怍。我们还内置了一个简单的观察者模式机制，允许视图订阅模型中的更新通知：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next we have the base interface definition for the controllers of our framework''s
    view to derive from. This just defines one simple `DoGenerateNext` method that
    must be overridden by the specific implementation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有框架视图控制器的基本接口定义，我们的控制器需要从中继承。这仅仅定义了一个简单的`DoGenerateNext`方法，该方法必须由具体的实现类重写：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now let's define some subclasses that implement the interface and provide the
    specialization.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来定义一些实现接口并提供特殊化的子类。
- en: 'Beginning with our `FibonacciModel` class, we define a model that will generate
    Fibonacci numbers:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`FibonacciModel`类开始，我们定义了一个将生成斐波那契数的模型：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then our `FibonacciController` provides the controller specialization, which
    in this example just makes one update to the user interface, to disable the button
    while the model is calculating the next value:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的 `FibonacciController` 提供了控制器特殊化，在这个例子中，它只是对用户界面进行了一次更新，即在模型计算下一个值时禁用按钮：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that the model and controller have been defined, let''s take a look at
    our view, which is composed of a `Frame`, a `Panel` that has a `TextCtrl` for
    displaying the current value stored in the model, and a `Button` for retrieving
    the next value in the sequence defined by the model:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型和控制器已经定义好了，让我们来看看我们的视图，它由一个`Frame`、一个包含用于显示模型中存储的当前值的`TextCtrl`的`Panel`以及一个用于检索模型定义的序列中下一个值的`Button`组成：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the `ViewPanel` is where we interface with the model and controller.
    We retrieve the initial value from the model on initialization and then register
    as an observer of changes in the model:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ViewPanel` 是我们与模型和控制器交互的地方。我们在初始化时从模型中检索初始值，然后注册为模型变化的观察者：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is our observer method that will be called when the model is updated with
    a new value:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的观察者方法，当模型更新为新值时将会被调用：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This event handler is for the `Button`, and it delegates to the controller
    in order to allow the controller to perform the implementation-specific action:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件处理器用于`按钮`，并且将其委托给控制器，以便允许控制器执行特定实现的动作：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we put it all together and implement an application:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有内容整合并实现一个应用程序：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Using MVC to design an application''s framework takes a fair amount of discipline.
    As can be seen in this simple example, there is quite a bit of extra "stuff" that
    needs to be done. As described before, MVC separates concerns into three main
    roles:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MVC设计应用程序框架需要相当多的自律。正如这个简单的例子所示，需要做很多额外的“事情”。正如之前所描述的，MVC将关注点分为三个主要角色：
- en: The Model
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型
- en: The View
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图
- en: The Controller
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器
- en: So let's take a look at how these roles came together in our sample recipe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看这些角色是如何在我们的示例食谱中结合在一起的。
- en: 'First the Model: This has the ability to store a value and to generate the
    next one in the sequence when its `Generate` method is called. In this recipe,
    we implemented a Model that calculates and stores Fibonacci numbers. The important
    part to take away from this is that the Model does not have any direct knowledge
    of the View or the Controller.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是模型：它具有存储值和在其`Generate`方法被调用时生成序列中下一个值的能力。在这个菜谱中，我们实现了一个模型，用于计算和存储斐波那契数。从这个例子中要吸取的重要部分是，模型对视图或控制器没有任何直接的知识。
- en: Next let's jump to the View, which just displays a `TextCtrl` field and a `Button`.
    It does not know any of the details of how the Controller or Model works. It only
    interacts with them through a defined interface. When the user clicks the `Button`,
    it asks the Controller to decide what to do. In order to know when the Model has
    changed, it registers a callback function with the Model, as an observer of when
    the Model's `SetValue` method is called.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们跳转到视图部分，它仅仅显示一个`TextCtrl`字段和一个`Button`。它并不了解控制器或模型如何工作的任何细节。它只通过定义好的接口与它们进行交互。当用户点击`Button`时，它会请求控制器决定要做什么。为了知道模型何时发生变化，它会在模型上注册一个回调函数，作为观察者来监听模型`SetValue`方法的调用。
- en: Now to the Controller which is the glue that holds the Model and View together.
    The Controller is primarily charged with implementing the View's behavior in regards
    to the Model's state. Our simple Controller for this recipe only has one interface
    method that is called in response to a `Button` click in the View. This action
    first disables the `Button`, and then tells the Model to generate the next number
    in the sequence.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到控制器，它是将模型和视图粘合在一起的中介。控制器主要负责根据模型的状态实现视图的行为。我们这个菜谱的简单控制器只有一个接口方法，这个方法是在视图中的“按钮”点击事件响应时被调用的。这个动作首先禁用“按钮”，然后告诉模型生成序列中的下一个数字。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You may be wondering "what's the point?" of all that extra rigmarole to create
    such a simple application. Well since the Model is completely separate from the
    View, it can be more easily unit tested in an automated test suite. In addition
    to this, since the View is just simply a view and does not implement any behavior,
    it can easily be reused if, for example, we wanted to add a Prime Number generator
    model to our application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道“这一切额外的繁琐有什么意义？”创建这样一个简单应用。嗯，由于模型（Model）与视图（View）完全分离，它可以在自动测试套件中更容易地进行单元测试。除此之外，由于视图（View）仅仅是一个视图，并不实现任何行为，因此如果，例如，我们想要向我们的应用中添加一个素数生成器模型，它就可以很容易地被重用。
- en: Maintainability is also improved since all three parts are separated and can
    be worked on individually without interfering with the other components. Because
    of these benefits, many other toolkits, such as Django and web2py make use of
    this pattern.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性也得到了提升，因为这三个部分是分离的，可以单独工作而不会干扰其他组件。由于这些优点，许多其他工具包，如Django和web2py，都采用了这种模式。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Implementing an observer pattern* recipe in this chapter for another
    approach to using an observer pattern.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的 *实现观察者模式* 菜单，了解另一种使用观察者模式的方法。
- en: See the *Strategy pattern* recipe in this chapter for more information on using
    strategies.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用策略的更多信息，请参阅本章中的*策略模式*配方。
- en: Using mixin classes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用混合类
- en: A mixin class is a design approach that is similar to the strategy pattern,
    but directly uses inheritance in order to add extended/common functionality to
    a new class. This recipe shows how to create a mixin class that adds debug logging
    facilities to any class that uses it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类是一种类似于策略模式的设计方法，但它直接使用继承来向新类添加扩展/通用功能。本食谱展示了如何创建一个混合类，该类可以为使用它的任何类添加调试日志功能。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, let''s start by creating our `LoggerMixin` class, which will provide
    the logging functionality to classes that need to have logging. It simply provides
    a `Log` method that will write the passed in string to a file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的`LoggerMixin`类，它将为需要日志功能的类提供日志功能。它简单地提供了一个`Log`方法，该方法将传入的字符串写入文件：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, to use the `LoggerMixin` in an application, it can simply be mixed in
    to any class to give it a `Log` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要在应用程序中使用`LoggerMixin`，只需将其混合到任何类中即可为其添加`Log`方法：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The mixin class in this recipe is the `LoggerMixin` class. It will add a `Log`
    method to the classes that use it, which will take a simple string as an argument
    and write it to the specified log file with a timestamp and ID that shows where
    the message came from.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的混合类是`LoggerMixin`类。它将为使用它的类添加一个`Log`方法，该方法将接受一个简单的字符串作为参数，并将其写入指定的日志文件，同时包含一个时间戳和一个ID，以显示消息的来源。
- en: 'A mixin works by using multiple inheritance in order to add additional functionality
    to a class. The `LoggerMixin` mixin class can be used with any Python class, but
    it expects (but doesn''t require) that the class it is being mixed into has a
    `GetName` method to use for getting the ID portion of the log message:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 混入（mixin）通过使用多重继承来为类添加额外的功能。`LoggerMixin` 混入类可以与任何 Python 类一起使用，但它期望（但不要求）被混合的类有一个
    `GetName` 方法，用于获取日志消息的 ID 部分：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: There are a number of handy mixin classes provided by the `wx.lib.mixins` package.
    Here is a quick rundown on some of the mixins that are available and what functionality
    they provide.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`wx.lib.mixins` 包提供了一系列实用的混合类。以下是一些可用的混合类及其提供的功能简介。'
- en: ListCtrl mixins
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ListCtrl 混合
- en: 'All of the following mixins classes are intended for use with a `ListCtrl`
    subclass and are provided by the `wx.lib.mixins.listctrl` module:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有混合类都是为了与`ListCtrl`子类一起使用，并由`wx.lib.mixins.listctrl`模块提供：
- en: '| Mixins classes | Description |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 混合类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CheckListCtrlMixin` | Adds `CheckBox` functionality to the first column
    of a `ListCtrl` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `CheckListCtrlMixin` | 为 `ListCtrl` 的第一列添加 `CheckBox` 功能 |'
- en: '| `ColumnSorterMixin` | Handles sorting of items in the `ListCtrl` when its
    column header is clicked |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `ColumnSorterMixin` | 处理在点击`ListCtrl`的列标题时对项目进行排序 |'
- en: '| `ListCtrlAutoWidthMixin` | Automatically resizes the last column of a `ListCtrl`
    to fill any remaining space |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `ListCtrlAutoWidthMixin` | 自动调整 `ListCtrl` 的最后一列大小以填充任何剩余空间 |'
- en: '| `ListRowHighlighter` | Automatically changes the background color on alternating
    rows in the `ListCtrl` to give it a stripped appearance |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `ListRowHighlighter` | 自动在 `ListCtrl` 的交替行上更改背景颜色，以使其呈现条纹外观 |'
- en: '| `TextEditMixin` | Adds the ability to show an editable text field in any
    column of a `ListCtrl` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `TextEditMixin` | 为 `ListCtrl` 的任何列添加显示可编辑文本字段的能力 |'
- en: TreeCtrl mixins
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TreeCtrl 混合
- en: 'All of the following mixin classes are for use with a `TreeCtrl` subclass,
    and are provided by the `wx.lib.mixins.treectrl` module:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有混合类都是用于与`TreeCtrl`子类一起使用，并由`wx.lib.mixins.treectrl`模块提供：
- en: '| Mixins classes | Description |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 混合类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DragAndDrop` | Helps to simplify the addition of Drag and Drop support to
    a `TreeCtrl` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `DragAndDrop` | 帮助简化向 `TreeCtrl` 添加拖放支持 |'
- en: '| `ExpansionState` | Helper to save and restore the expansion state of nodes
    in a `TreeCtrl` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `ExpansionState` | 用于在 `TreeCtrl` 中保存和恢复节点展开状态的辅助工具 |'
- en: '| `VirtualTree` | Allow the `TreeCtrl` to be virtualized so that nodes are
    added and removed on demand, instead of having to construct the whole tree up
    front |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `VirtualTree` | 允许 `TreeCtrl` 被虚拟化，以便按需添加和删除节点，而不是必须在前端构建整个树结构 |'
- en: Using decorators
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器
- en: 'Due to the window hierarchy, there are some architectural issues that can be
    presented to the programmer that lead to some tedious and unnecessary code duplication
    due to the need to have delegate accessor methods or properties at each level
    of the containment hierarchy. Typically, any Frame or Dialog in an application
    is structured as shown in the following diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于窗口层次结构，可能会向程序员展示一些架构问题，这些问题会导致一些繁琐且不必要的代码重复，因为需要在包含层次结构的每一级都拥有代理访问器方法或属性。通常，应用程序中的任何框架或对话框都按照以下图示的结构组织：
- en: '![Using decorators](img/1780OS_09_02.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用装饰器](img/1780OS_09_02.jpg)'
- en: When needing to retrieve or modify the data that is shown in the window, it
    is the widgets and **Controls** that need to be accessed. These are contained
    by the **Panel** which is in turn contained by the **Top Level Window**. Since
    the Panel is responsible for its children, it will often have methods for modifying
    and accessing the data that is maintained by its children's controls. Because
    of this, the top-level window class often needs to have duplicate methods that
    simply delegate to the Panel's methods for getting and setting the window's data.
    These delegate methods are needed because the top-level window is the object that
    is instantiated at the application level and the application should not need to
    know the details of the top-level window's `Panel` in order to use it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要检索或修改窗口中显示的数据时，需要访问的是小部件和**控件**。这些控件包含在**面板**中，而面板又包含在**顶级窗口**中。由于面板负责其子控件，它通常会提供修改和访问其子控件维护的数据的方法。因此，顶级窗口类通常需要具有重复的方法，这些方法只是委托给面板的方法来获取和设置窗口的数据。这些委托方法之所以需要，是因为顶级窗口是在应用程序级别实例化的对象，应用程序在使用它时不应需要知道顶级窗口的`Panel`的详细信息。
- en: This recipe shows how to create a simple decorator method that takes advantage
    of Python's dynamic nature in order to expose a select method of a custom Panel
    class to its top-level window container.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了如何创建一个简单的装饰器方法，该方法利用Python的动态特性，以便将自定义面板类的一个选择方法暴露给其顶级窗口容器。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This decorator class takes the name of a class as an argument and will dynamically
    define the `delegate` method in the targeted child `Panel` of the top level window:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器类接受一个类的名称作为参数，并将动态地在顶级窗口的目标子`Panel`中定义`delegate`方法：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is where the magic occurs. We use `setattr` to dynamically add a function
    with the same name as the function being decorated to the targeted class. When
    called from the targeted class, the new method will walk through the window''s
    children to find its `Panel`, and will delegate the call to the child class''s
    method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了魔法。我们使用 `setattr` 动态地向目标类添加一个与被装饰函数同名的新函数。当从目标类调用时，新方法将遍历窗口的子元素以找到其 `Panel`，并将调用委托给子类的函数：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The example code that accompanies this chapter has a sample application that
    shows how to use this decorator.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节附带的示例代码包含一个示例应用程序，展示了如何使用这个装饰器。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe isn't so much a design pattern as it is a technique to help make
    writing new `Dialog` and `Frame` classes quicker and also to reduce code duplication.
    To do this, we created a decorator class for exposing methods from child `Panel`
    classes to their parent top-level window. Let's start with a look at the `expose`
    decorator to see how it works its magic.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方与其说是一个设计模式，不如说是一种帮助快速编写新的 `Dialog` 和 `Frame` 类以及减少代码重复的技术。为了做到这一点，我们创建了一个装饰器类，用于将子
    `Panel` 类的方法暴露给它们的父级顶级窗口。让我们先看看 `expose` 装饰器，看看它是如何施展魔法的。
- en: The `expose` decorator takes a single argument, which is the class that the
    method should be exposed to. A reference to this is saved in the constructor for
    later use when the decorator is applied in its `__call__` method. The `__call__`
    method creates a method called `delegate` which will search for the first child
    panel that has a method with the same name as the one that is being exposed. If
    it finds an appropriate panel, then it simply calls the panel's method and returns
    its value. Next, it uses `setattr` to insert the newly-generated `delegate` method
    with an alias matching the `Panel's` method into the namespace of the class specified
    in the decorator's constructor. At this point, the method is available for use
    in the top-level window that `expose` was called with. Finally, we just return
    the unaltered original function to the `Panel` class it belongs to.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`expose` 装饰器接受一个单一参数，即方法应该暴露给该类。在构造函数中保存对这个参数的引用，以便在装饰器应用其 `__call__` 方法时后续使用。`__call__`
    方法创建一个名为 `delegate` 的方法，它将搜索第一个具有与正在暴露的方法相同名称的子面板。如果找到合适的面板，它将简单地调用面板的方法并返回其值。接下来，它使用
    `setattr` 将新创建的 `delegate` 方法（具有与 `Panel` 的方法匹配的别名）插入到装饰器构造函数中指定的类的命名空间中。此时，该方法即可在调用
    `expose` 时使用的顶层窗口中使用。最后，我们只需将未修改的原始函数返回给它所属的 `Panel` 类。'
- en: Just to be clear, this decorator, as it is defined in this recipe, can only
    be used by `Panel` subclasses that have a known relationship of being the only
    child of their parent window. This is typical of how most `Frame` and `Dialog`
    subclasses are constructed, as can be seen in the example `CommentDialog` class
    that is included in this chapter's sample code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，这个装饰器，正如在这个菜谱中定义的那样，只能由具有已知关系的`Panel`子类使用，即它们是它们父窗口的唯一子窗口。这通常是大多数`Frame`和`Dialog`子类构建的方式，正如在本章示例代码中包含的`CommentDialog`类所示。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Understanding the window hierarchy* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* for
    an additional explanation of the containment hierarchy of different objects.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第1章](ch01.html "第1章. 使用wxPython入门")中的*理解窗口层次结构*配方，以获取对不同对象包含层次结构的额外解释。
