- en: Chapter 9. Design Approaches and Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Singletons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model View Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mixin classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming is all about patterns. There are patterns at every level, from the
    programming language itself, to the toolkit, to the application. Being able to
    discern and choose the optimal approach to use to solve the problem at hand can
    at times be a difficult task. The more patterns you know, the bigger your toolbox,
    and the easier it will become to be able to choose the right tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: Different programming languages and toolkits often lend themselves to certain
    patterns and approaches to problem solving. The Python programming language and
    wxPython are no different, so let's jump in and take a look at how to apply some
    common design approaches and techniques to wxPython applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Singletons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object oriented programming, the Singleton pattern is a fairly simple concept
    of only allowing exactly one instance of a given object to exist at a given time.
    This means that it only allows for only one instance of the object to be in memory
    at any given time, so that all references to the object are shared throughout
    the application. Singletons are often used to maintain a global state in an application
    since all occurances of one in an application reference the same exact instance
    of the object. Within the core wxPython library, there are a number of singleton
    objects, such as `ArtProvider, ColourDatabase`, and `SystemSettings`. This recipe
    shows how to make a singleton `Dialog` class, which can be useful for creating
    non-modal dialogs that should only have a single instance present at a given time,
    such as a settings dialog or a special tool window.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we will define a metaclass that can be reused on any class that
    needs to be turned into a singleton. We will get into more detail later in the
    *How it works* section. A metaclass is a class that creates a class. It is passed
    a class to it's `__init__` and `__call__` methods when someone tries to create
    an instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we have an example of the use of our metaclass, which shows how easy it
    is to turn the following class into a singleton class by simply assigning the
    `Singleton` class as the `__metaclass__` of `SingletonDialog`. The only other
    requirement is to define the `SetupWindow` method that the `Singleton` metaclass
    uses as an initialization hook to set up the window the first time an instance
    of the class is created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in Python 3+ the `__metaclass__` attribute has been replaced with
    a metaclass keyword argument in the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of ways to implement a Singleton in Python. In this recipe,
    we used a metaclass to accomplish the task. This is a nicely contained and easily
    reusable pattern to accomplish this task. The `Singleton` class that we defined
    can be used by any class that has a `SetupWindow` method defined for it. So now
    that we have done it, let's take a quick look at how a singleton works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Singleton metaclass dynamically creates and adds a class variable called
    `instance` to the passed in class. So just to get a picture of what is going on,
    the metaclass would generate the following code in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the first time the metaclass''s `__call__` method is invoked, it will
    then assign the instance of the class object returned by the super class''s `__call__`
    method, which in this recipe is an instance of our `SingletonDialog`. So basically,
    it is the equivalent of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Any subsequent initializations will cause the previously-created one to be returned,
    instead of creating a new one since the class definition maintains the lifetime
    of the object and not an individual reference created in the user code.
  prefs: []
  type: TYPE_NORMAL
- en: Our `SingletonDialog` class is a very simple Dialog that has `TextCtrl, CheckBox`,
    and `Ok Button` objects on it. Instead of invoking initialization in the dialog's
    `__init__` method, we instead defined an interface method called `SetupWindow`
    that will be called by the Singleton metaclass when the object is initially created.
    In this method, we just perform a simple layout of our controls in the dialog.
    If you run the sample application that accompanies this topic, you can see that
    no matter how many times the show dialog button is clicked, it will only cause
    the existing instance of the dialog to be brought to the front. Also, if you make
    changes in the dialog's `TextCtrl` or `CheckBox`, and then close and reopen the
    dialog, the changes will be retained since the same instance of the dialog will
    be re-shown instead of creating a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer pattern is a design approach where objects can subscribe as observers
    of events that other objects are publishing. The publisher(s) of the events then
    just broadcasts the events to all of the subscribers. This allows the creation
    of an extensible, loosely-coupled framework of notifications, since the publisher(s)
    don't require any specific knowledge of the observers. The `pubsub` module provided
    by the `wx.lib` package provides an easy-to-use implementation of the observer
    pattern through a publisher/subscriber approach. Any arbitrary number of objects
    can subscribe their own callback methods to messages that the publishers will
    send to make their notifications. This recipe shows how to use the `pubsub` module
    to send configuration notifications in an application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will create our application configuration object that stores runtime
    configuration variables for an application and provides a notification mechanism
    for whenever a value is added or modified in the configuration, through an interface
    that uses the observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create a very simple application to show how to subscribe observers
    to configuration changes in the `Configuration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This dialog will have one configuration option on it to allow the user to change
    the applications font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the `FontPicker''s` event handler, we get the newly-selected font
    and call `SetValue` on the `Configuration` object owned by the `App` object in
    order to change the configuration, which will then cause the `(''config'', ''font'')`
    message to be published:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here, we define the application''s main window that will subscribe it''s
    `OnConfigMsg` method as an observer of all `(''config'',)` messages, so that it
    will be called whenever the configuration is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the observer method that will be called when any message beginning
    with`''config''` is sent by the `pubsub Publisher`. In this sample application,
    we just check for the `(''config'', ''font'')` message and update the font of
    the `TextCtrl` object to use the newly-configured one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows a convenient way to manage an application's configuration
    by allowing the interested parts of an application to subscribe to updates when
    certain parts of the configuration are modified. Let's start with a quick walkthrough
    of how pubsub works.
  prefs: []
  type: TYPE_NORMAL
- en: Pubsub messages use a tree structure to organize the categories of different
    messages. A message type can be defined either as a tuple `('root', 'child1',
    'grandchild1')` or as a dot-separated string (`'root.child1.grandchild1'`). Subscribing
    a callback to `('root',)` will cause your callback method to be called for all
    messages that start with `('root',)`. This means that if a component publishes
    `('root', 'child1', 'grandchild1')` or `('root', 'child1')`, then any method that
    is subscribed to `('root',)` will also be called.
  prefs: []
  type: TYPE_NORMAL
- en: Pubsub basically works by storing the mapping of message types to callbacks
    in static memory in the `pubsub` module. In Python, modules are only imported
    once any other part of your application that uses the `pubsub` module shares the
    same singleton `Publisher` object.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, the `Configuration` object is a simple object for storing data
    about the configuration of our application. Its `SetValue` method is the important
    part to look at. This is the method that will be called whenever a configuration
    change is made in the application. In turn, when this is called, it will send
    a pubsub message of `('config',) + (key,)` that will allow any observers to subscribe
    to either the root item or more specific topics determined by the exact configuration
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have our simple `ConfigDialog` class. This is just a simple example
    that only has an option for configuring the application's font. When a change
    is made in the `FontPickerCtrl` in the `ConfigPanel`, the `Configuration` object
    will be retrieved from the `App` and will be updated to store the newly-selected
    `Font`. When this happens, the `Configuration` object will publish an update message
    to all subscribed observers.
  prefs: []
  type: TYPE_NORMAL
- en: Our `ObserverFrame` is an observer of all `('config',)` messages by subscribing
    its `OnConfigMsg` method to `MSG_CONFIG_ROOT. OnConfigMsg` will be called any
    time the `Configuration` object's `SetValue` method is called. The `msg` parameter
    of the callback will contain a `Message` object that has a `topic` and `data`
    attribute. The `topic` attribute will contain the tuple that represents the message
    that triggered the callback and the `data` attribute will contain any data that
    was associated with the `topic` by the publisher of the message. In the case of
    a `('config', 'font')` message, our handler will update the `Font` of the `Frame`
    and its `TextCtrl`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Creating Singletons* recipe in this chapter for an explanation of how
    singleton objects like the Publisher from this recipe work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Making a tool window* recipe in [Chapter 10](ch10.html "Chapter 10. Creating
    Components and Extending Functionality"), *Creating Components and Extending Functionality*
    for another example of the publisher pattern in action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strategy pattern is an approach that allows for an application to choose
    the strategy or behavior that will be used at run time. It accomplishes this by
    encapsulating different algorithms and making them usable by the client regardless
    of what the underlying behavior of the algorithm is. This is probably one of the
    most fundamental design patterns in programming, and you're probably already using
    it in one form or another without even knowing it. This recipe shows how to create
    a reusable `Dialog` class that uses the strategy pattern to allow for the main
    content to vary depending on the strategy used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will start by defining a base interface with all of the strategies
    that our dialog class will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define our simple Ok/Cancel dialog, which will use a strategy derived
    from our `BaseDialogStrategy` class to allow its main content area to vary depending
    on the strategy used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the following methods of our `StrategyDialog`, we just delegate to
    the current strategy to allow it to define the behavior of the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s implement a simple strategy that can be used to get the dialog to
    display a control for selecting a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in an application, all that needs to be done to create a dialog that
    uses this strategy would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since all strategies that our dialog will use must be interchangeable, it is
    important to define an interface that they will implement. So, in our `BaseDialogStrategy`
    class, we defined a simple three-method interface that our `StrategyDialog` will
    delegate to.
  prefs: []
  type: TYPE_NORMAL
- en: The `StrategyDialog` is basically just a simple generic shell that delegates
    all decisions regarding its appearance and behavior to the strategy. When the
    dialog is initialized, it asks the strategy for a window object that will be used
    as the main content area of the dialog. The dialog then creates and adds some
    standard OK/Cancel buttons to the interface.
  prefs: []
  type: TYPE_NORMAL
- en: When a user clicks on one of these buttons, the `StrategyDialog` will then simply
    delegate to its strategy, to allow the strategy to handle the user action. This
    allows us to reuse this dialog class in many different ways, by simply implementing
    different strategies.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Model View Controller* recipe in this chapter for some more examples
    of a strategy pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model View Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Model View Controller** (**MVC**) is a design pattern that creates a clear
    separation of concerns within a program''s architecture. It breaks down into three
    layers: the **Model**, which is the application''s data objects and business logic
    at the bottom, the **View** at the top, which typically consists of controls for
    displaying and editing data, and finally the **Controller** in the middle, which
    is responsible for mediating the flow of data from the Model to the View and vice
    versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View Controller](img/1780OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: MVC is really one big monster pattern made up of other, simpler patterns working
    together. The Model implements an observer pattern to keep interested parties
    updated on changes, which allows it to be implemented separately from the View
    and Controller. The View and the Controller, on the other hand, implement a strategy
    pattern where the Controller is a strategy that implements the behavior of the
    View.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we explore how to create a simple number generator application
    that implements this pattern in wxPython.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since there are multiple components that need to work together, having defined
    interfaces is an important step in the process, so first let us define some base
    classes that define the interface for our number generator's model and controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning with our Model''s interface, we provide a class that simply requires
    its `Generate` method to be overridden in order to provide the implementation-specific
    behavior. We have also built in a simple observer pattern mechanism to allow the
    view to subscribe to update notifications in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have the base interface definition for the controllers of our framework''s
    view to derive from. This just defines one simple `DoGenerateNext` method that
    must be overridden by the specific implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now let's define some subclasses that implement the interface and provide the
    specialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning with our `FibonacciModel` class, we define a model that will generate
    Fibonacci numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then our `FibonacciController` provides the controller specialization, which
    in this example just makes one update to the user interface, to disable the button
    while the model is calculating the next value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the model and controller have been defined, let''s take a look at
    our view, which is composed of a `Frame`, a `Panel` that has a `TextCtrl` for
    displaying the current value stored in the model, and a `Button` for retrieving
    the next value in the sequence defined by the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `ViewPanel` is where we interface with the model and controller.
    We retrieve the initial value from the model on initialization and then register
    as an observer of changes in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our observer method that will be called when the model is updated with
    a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This event handler is for the `Button`, and it delegates to the controller
    in order to allow the controller to perform the implementation-specific action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we put it all together and implement an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using MVC to design an application''s framework takes a fair amount of discipline.
    As can be seen in this simple example, there is quite a bit of extra "stuff" that
    needs to be done. As described before, MVC separates concerns into three main
    roles:'
  prefs: []
  type: TYPE_NORMAL
- en: The Model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The View
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Controller
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So let's take a look at how these roles came together in our sample recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'First the Model: This has the ability to store a value and to generate the
    next one in the sequence when its `Generate` method is called. In this recipe,
    we implemented a Model that calculates and stores Fibonacci numbers. The important
    part to take away from this is that the Model does not have any direct knowledge
    of the View or the Controller.'
  prefs: []
  type: TYPE_NORMAL
- en: Next let's jump to the View, which just displays a `TextCtrl` field and a `Button`.
    It does not know any of the details of how the Controller or Model works. It only
    interacts with them through a defined interface. When the user clicks the `Button`,
    it asks the Controller to decide what to do. In order to know when the Model has
    changed, it registers a callback function with the Model, as an observer of when
    the Model's `SetValue` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Now to the Controller which is the glue that holds the Model and View together.
    The Controller is primarily charged with implementing the View's behavior in regards
    to the Model's state. Our simple Controller for this recipe only has one interface
    method that is called in response to a `Button` click in the View. This action
    first disables the `Button`, and then tells the Model to generate the next number
    in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering "what's the point?" of all that extra rigmarole to create
    such a simple application. Well since the Model is completely separate from the
    View, it can be more easily unit tested in an automated test suite. In addition
    to this, since the View is just simply a view and does not implement any behavior,
    it can easily be reused if, for example, we wanted to add a Prime Number generator
    model to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability is also improved since all three parts are separated and can
    be worked on individually without interfering with the other components. Because
    of these benefits, many other toolkits, such as Django and web2py make use of
    this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Implementing an observer pattern* recipe in this chapter for another
    approach to using an observer pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Strategy pattern* recipe in this chapter for more information on using
    strategies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mixin classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mixin class is a design approach that is similar to the strategy pattern,
    but directly uses inheritance in order to add extended/common functionality to
    a new class. This recipe shows how to create a mixin class that adds debug logging
    facilities to any class that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s start by creating our `LoggerMixin` class, which will provide
    the logging functionality to classes that need to have logging. It simply provides
    a `Log` method that will write the passed in string to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to use the `LoggerMixin` in an application, it can simply be mixed in
    to any class to give it a `Log` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mixin class in this recipe is the `LoggerMixin` class. It will add a `Log`
    method to the classes that use it, which will take a simple string as an argument
    and write it to the specified log file with a timestamp and ID that shows where
    the message came from.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mixin works by using multiple inheritance in order to add additional functionality
    to a class. The `LoggerMixin` mixin class can be used with any Python class, but
    it expects (but doesn''t require) that the class it is being mixed into has a
    `GetName` method to use for getting the ID portion of the log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of handy mixin classes provided by the `wx.lib.mixins` package.
    Here is a quick rundown on some of the mixins that are available and what functionality
    they provide.
  prefs: []
  type: TYPE_NORMAL
- en: ListCtrl mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the following mixins classes are intended for use with a `ListCtrl`
    subclass and are provided by the `wx.lib.mixins.listctrl` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mixins classes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CheckListCtrlMixin` | Adds `CheckBox` functionality to the first column
    of a `ListCtrl` |'
  prefs: []
  type: TYPE_TB
- en: '| `ColumnSorterMixin` | Handles sorting of items in the `ListCtrl` when its
    column header is clicked |'
  prefs: []
  type: TYPE_TB
- en: '| `ListCtrlAutoWidthMixin` | Automatically resizes the last column of a `ListCtrl`
    to fill any remaining space |'
  prefs: []
  type: TYPE_TB
- en: '| `ListRowHighlighter` | Automatically changes the background color on alternating
    rows in the `ListCtrl` to give it a stripped appearance |'
  prefs: []
  type: TYPE_TB
- en: '| `TextEditMixin` | Adds the ability to show an editable text field in any
    column of a `ListCtrl` |'
  prefs: []
  type: TYPE_TB
- en: TreeCtrl mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the following mixin classes are for use with a `TreeCtrl` subclass,
    and are provided by the `wx.lib.mixins.treectrl` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mixins classes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DragAndDrop` | Helps to simplify the addition of Drag and Drop support to
    a `TreeCtrl` |'
  prefs: []
  type: TYPE_TB
- en: '| `ExpansionState` | Helper to save and restore the expansion state of nodes
    in a `TreeCtrl` |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualTree` | Allow the `TreeCtrl` to be virtualized so that nodes are
    added and removed on demand, instead of having to construct the whole tree up
    front |'
  prefs: []
  type: TYPE_TB
- en: Using decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Due to the window hierarchy, there are some architectural issues that can be
    presented to the programmer that lead to some tedious and unnecessary code duplication
    due to the need to have delegate accessor methods or properties at each level
    of the containment hierarchy. Typically, any Frame or Dialog in an application
    is structured as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using decorators](img/1780OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When needing to retrieve or modify the data that is shown in the window, it
    is the widgets and **Controls** that need to be accessed. These are contained
    by the **Panel** which is in turn contained by the **Top Level Window**. Since
    the Panel is responsible for its children, it will often have methods for modifying
    and accessing the data that is maintained by its children's controls. Because
    of this, the top-level window class often needs to have duplicate methods that
    simply delegate to the Panel's methods for getting and setting the window's data.
    These delegate methods are needed because the top-level window is the object that
    is instantiated at the application level and the application should not need to
    know the details of the top-level window's `Panel` in order to use it.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how to create a simple decorator method that takes advantage
    of Python's dynamic nature in order to expose a select method of a custom Panel
    class to its top-level window container.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This decorator class takes the name of a class as an argument and will dynamically
    define the `delegate` method in the targeted child `Panel` of the top level window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is where the magic occurs. We use `setattr` to dynamically add a function
    with the same name as the function being decorated to the targeted class. When
    called from the targeted class, the new method will walk through the window''s
    children to find its `Panel`, and will delegate the call to the child class''s
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The example code that accompanies this chapter has a sample application that
    shows how to use this decorator.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe isn't so much a design pattern as it is a technique to help make
    writing new `Dialog` and `Frame` classes quicker and also to reduce code duplication.
    To do this, we created a decorator class for exposing methods from child `Panel`
    classes to their parent top-level window. Let's start with a look at the `expose`
    decorator to see how it works its magic.
  prefs: []
  type: TYPE_NORMAL
- en: The `expose` decorator takes a single argument, which is the class that the
    method should be exposed to. A reference to this is saved in the constructor for
    later use when the decorator is applied in its `__call__` method. The `__call__`
    method creates a method called `delegate` which will search for the first child
    panel that has a method with the same name as the one that is being exposed. If
    it finds an appropriate panel, then it simply calls the panel's method and returns
    its value. Next, it uses `setattr` to insert the newly-generated `delegate` method
    with an alias matching the `Panel's` method into the namespace of the class specified
    in the decorator's constructor. At this point, the method is available for use
    in the top-level window that `expose` was called with. Finally, we just return
    the unaltered original function to the `Panel` class it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: Just to be clear, this decorator, as it is defined in this recipe, can only
    be used by `Panel` subclasses that have a known relationship of being the only
    child of their parent window. This is typical of how most `Frame` and `Dialog`
    subclasses are constructed, as can be seen in the example `CommentDialog` class
    that is included in this chapter's sample code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Understanding the window hierarchy* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* for
    an additional explanation of the containment hierarchy of different objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
