- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String Matching Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many popular string matching algorithms. String matching algorithms
    have very important applications, such as searching for an element in a text document,
    plagiarism detection, text editing programs, and so on. In this chapter, we will
    study the pattern matching algorithms that find the locations of a given pattern
    or substring in any given text. We will discuss the **brute force algorithm**,
    along with the **Rabin-Karp**, **Knuth-Morris-Pratt** (**KMP**), and **Boyer-Moore
    pattern matching algorithms**. This chapter aims to discuss algorithms that are
    related to strings. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning pattern matching algorithms and their implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing the **Rabin-Karp pattern matching algorithm**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing the **Knuth-Morris-Pratt** (**KMP**) **algorithm**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing the **Boyer-Moore pattern matching algorithm**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the programs based on the concepts and algorithms discussed in this
    chapter are provided in the book as well as in the GitHub repository at the following
    link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter13).'
  prefs: []
  type: TYPE_NORMAL
- en: String notations and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are sequences of characters. Python provides a rich set of operations
    and functions that can be applied to the string data type. Strings are textual
    data and are handled very efficiently in Python. The following is an example of
    a string `(s)`—`"packt publishing"`.
  prefs: []
  type: TYPE_NORMAL
- en: A substring is a sequence of characters that’s part of the given string, i.e.,
    specified indices in the string in a continuous order. For example, “`packt`"
    is a substring of the string “`packt publishing`". On the other hand, a subsequence
    is also a sequence of characters that can be obtained from the given string by
    removing some of the characters from the string by keeping the order of occurrence
    of the characters. For example, “`pct pblishing`" is a valid subsequence for the
    string “`packt publishing`" that is obtained by removing the characters `a`, `k`,
    and `u`. However, this is not a substring since “`pct pblishing`" is not a continuous
    sequence of characters. Hence, a subsequence is different from a substring, and
    it can be considered a generalization of substrings.
  prefs: []
  type: TYPE_NORMAL
- en: The prefix `(p)` is a substring of the string `(s)` in that it is present at
    the start of the string. There is also another string `(u)` that exists in the
    string `(s)` after the prefix. For example, the substring “`pack`" is a prefix
    for the string `(s) = "packt publishing"` as it is the starting substring and
    there is another substring `u = "publishing"` after it. Thus, the prefix plus
    string `(u)` makes “`packt publishing`", which is the whole string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The suffix `(d)` is a substring that is present at the end of the string `(s)`.
    For example, the substring “`shing`" is one of the many possible suffixes for
    the string “`packt publishing`". Python has built-in functions to check whether
    a string starts or ends with a specific string, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the above example of the given string, we can see that the given text string
    ends with another substring “`publisher`", which is a valid suffix, and that also
    has another substring “`this`", which is a substring of the string start and is
    also a valid prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the pattern matching algorithms discussed here are not to be confused
    with the matching statements of Python 3.10\.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching algorithms are the most important string processing algorithms
    and we will discuss them in the subsequent sections, starting with pattern matching
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pattern matching algorithm is used to determine the index positions where
    a given pattern string (`P`) is matched in a text string (`T`). Thus, the pattern
    matching algorithm finds and returns the index where a given string pattern appears
    in a text string. It returns `"pattern not found"` if the pattern does not have
    a match in the text string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for the given text string `(s) = "packt publisher"` and the pattern
    string `(p) = "publisher"`, the pattern-matching algorithm returns the index position
    where the pattern string is matched in the text string. An example of a string
    matching problem is shown in *Figure 13.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: An example of a string matching problem'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss four pattern matching algorithms, that is, the brute force method,
    Rabin-Karp algorithm, and the **Knuth-Morris-Pratt** (**KMP**) and Boyer-Moore
    pattern-matching algorithms. We start with the brute force pattern matching algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The brute force algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The brute force algorithm is also called the naive approach to pattern matching
    algorithms. Naive approach means that it is a very basic and simple algorithm.
    In this approach, we match all the possible combinations of the input pattern
    in the given text string to find the position of the occurrence of the pattern.
    This algorithm is very naive and is not suitable if the text is very long.
  prefs: []
  type: TYPE_NORMAL
- en: In this algorithm, we start by comparing the characters of the pattern string
    and the text string one by one, and if all the characters of the pattern are matched
    with the text, we return the index position of the text where the first character
    of the pattern is located. If any character of the pattern is mismatched with
    the text string, we shift the pattern by one position to check if the pattern
    appears at the next index position. We continue comparing the pattern and text
    string by shifting the pattern by one index position.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how the brute force algorithm works, let’s look at an
    example. Suppose we have a text string `(T)` = “**acbcabccababcaacbcac**”, and
    the pattern string `(P)` is “**acbcac**”. Now, the objective of the pattern matching
    algorithm is to determine the index position of the pattern string in the given
    text, `T`, as shown in *Figure 13.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: An example of the brute force algorithm for string matching'
  prefs: []
  type: TYPE_NORMAL
- en: We start by comparing the first character of the text, that is, **a**, and the
    first character of the pattern. Here, the initial five characters of the pattern
    are matched, and then there is a mismatch in the last character of the pattern.
    This is a mismatch, so we shift the pattern by one place. We again start comparing
    the first character of the pattern and the second character of the text string
    one by one. Here, character **c** of the text string does not match with the character
    **a** of the pattern. So, this is also a mismatch, and we shift the pattern by
    one space, as shown in *Figure 13.2*. We continue comparing the characters of
    the pattern and the text string until we traverse the whole text string. In this
    example, we find a match at index position `14`, which is shown in *Figure 13.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the Python implementation of the brute force algorithm for pattern
    matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above function call is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code for the brute force approach, we start by computing the
    length of the given text strings and pattern. We also initialize the looping variables
    with `0` and set the flag to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: This variable is used to continue searching for a match of the pattern in the
    string. If the `flag` variable is `False` by the end of the text string, it means
    that there is no match for the pattern at all in the text string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we start the searching loop from the `0`^(th) index to the end of the
    text string. In this loop, we have a `count` variable that is used to keep track
    of the length up to which the pattern and the text have been matched. Next, we
    have another nested loop that runs from the `0`^(th) index to the length of the
    pattern. Here, the variable `i` keeps track of the index position in the text
    string and the variable `j` keeps track of the characters in the pattern. Next,
    we compare the characters of the patterns and the text string using the following
    code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, we increment the `count` variable after every match of the character
    of the pattern in the text string. Then, we continue matching the characters of
    the pattern and text string. If the length of the pattern becomes equal to the
    `count` variable, it means there is a match.
  prefs: []
  type: TYPE_NORMAL
- en: We print the index position of the text string if there is a match for the pattern
    string in the text string and keep the `flag` variable as to `True` as we wish
    to continue searching for more matches of the patterns in the text string. Finally,
    if the value of the variable `flag` is `False`, it means that there was not a
    match for the pattern in the text string at all.
  prefs: []
  type: TYPE_NORMAL
- en: The best-case and worst-case time complexities for the naive string matching
    algorithms are `O(n)` and `O(m*(n-m+1))`, respectively. The best-case scenario
    occurs when the pattern is not found in the text and the first character of the
    pattern is not present in the text at all, for example, if the text string is
    `ABAACEBCCDAAEE`, and the pattern is `FAA`. Here, as the first character of the
    pattern will not find a match anywhere in the text, it will have comparisons equal
    to the length of the text (`n`).
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case scenario occurs when all characters of the text string and the
    pattern are the same and we want to find out all the occurrences of the given
    pattern string in the text string, for example, if the text string is `AAAAAAAAAAAAAAAA`,
    and the pattern string is `AAAA`. Another worst-case scenario occurs when only
    the last character is different, for example, if the text string is `AAAAAAAAAAAAAAAF`
    and the pattern is `AAAAF`. Thus, the total number of comparisons will be `m*(n-m+1)`
    and the worst-case time complexity will be `O(m*(n-m+1))`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss the Rabin-Karp pattern matching algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Rabin-Karp algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rabin-Karp pattern matching algorithm is an improved version of the brute
    force approach to find the location of the given pattern in the text string. The
    performance of the Rabin-Karp algorithm is improved by reducing the number of
    comparisons with the help of hashing. We discussed the concept of hashing in *Chapter
    8*, *Hash Tables*. The hashing function returns a unique numeric value for a given
    string.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is faster than the brute force approach as it avoids unnecessary
    comparisons. In this algorithm, we compare the hash value of the pattern with
    the hash value of the substring of the text string. If the hash values are not
    matched, the pattern is shifted forward one position. This is a better algorithm
    as compared to the brute-force algorithm since there is no need to compare all
    the characters of the pattern one by one.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is based on the concept that if the hash values of the two strings
    are equal, then it is assumed that both the strings are also equal. However, it
    is also possible that there can be two different strings whose hash values are
    equal. In that case, the algorithm will not work; this situation is known as a
    spurious hit and happens due to a collision in hashing. To avoid this with the
    Rabin-Karp algorithm, after matching the hash values of the pattern and the substring,
    we ensure that the pattern is actually matched in the string by comparing the
    pattern and the substring character by character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rabin-Karp pattern matching algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we preprocess the pattern before starting the search, that is, we compute
    the hash value of the pattern of length `m` and the hash values of all the possible
    substrings of the text of length `m`. The total number of possible substrings
    would be (`n-m+1`). Here, `n` is the length of the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We compare the hash value of the pattern with the hash value of the substrings
    of the text one by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the hash values are not matched, then we shift the pattern by one position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the hash value of the pattern and the hash value of the substring of the
    text match, then we compare the pattern and substring character by character to
    ensure that the pattern is actually matched in the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We continue the process of *steps 2-5* until we reach the end of the given text
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this algorithm, we compute the numerical hash values using Horner’s rule
    (any other hashing function can also be used) that returns a unique value for
    the given string. We also compute the hash value using the sum of the ordinal
    values of all the characters of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example to understand the **Rabin-Karp algorithm**. Let’s
    say we have a text string `(T) = "publisher paakt packt"`, and the pattern `(P)
    = "packt"`. First, we compute the hash values of the pattern (length `m`) and
    all the substrings (of length `m`) of the text string. The functionality of the
    **Rabin-Karp algorithm** is shown in *Figure 13.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: An example of the Rabin-Karp algorithm for string matching'
  prefs: []
  type: TYPE_NORMAL
- en: We start comparing the hash value of the pattern `"packt"` with the first substring
    `"publi"`. Since the hash values do not match, we shift the pattern by one position,
    and then we compare the hash value of pattern with the hash value of the next
    substring of the text, i.e. `"ublis"`. As these hash values also do not match,
    we again shift the pattern by one position. We shift the pattern by one position
    at a time if the hash values do not match. And, if the hash value of the pattern
    and the hash value of the substring match, we compare the pattern and substring
    character by character and we return the location of the text string if they match.
  prefs: []
  type: TYPE_NORMAL
- en: In the example shown in *Figure 13.3*, hash values of the pattern and the substring
    of the text are matched at location `17`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that there can be a different string whose hash value
    can match with the hash of the pattern, i.e. a spurious hit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us discuss the implementation of the **Rabin-Karp pattern matching
    algorithm**.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Rabin-Karp algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of the **Rabin-Karp algorithm** is done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We implement the `generate_hash()` method, which is used to compute the hash
    value of the pattern and all the possible combinations of the substrings of length
    equal to the length of the pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement the **Rabin-Karp algorithm**, which uses the `generate_hash()`
    method to identify the substring whose hash value matches the hash value of the
    pattern. Finally, we match them character by character to ensure we have correctly
    found the pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us first discuss the implementation of generating hash values for the patterns
    and substrings of the text. For this, we need to first decide on the hash function.
    Here, we use the sum of all the ordinal values of all the characters of the string
    as the hashing function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete Python implementation to compute the hashing values is given below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we start by storing the ordinal values of all the characters
    of the text and the pattern in the `ord_text` and `ord_pattern` variables. Next,
    we store the length of the text and the pattern in the `len_text` and `len_pattern`
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a variable called `len_hash_array` that stores the number of
    all the possible substrings of length (equal to the length of the pattern) using
    `len_text - len_pattern + 1`, and we create an array called `hash_text` that stores
    the hash value for all the possible substrings. This is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we compute the hash value for the pattern by summing up the ordinal values
    of all the characters in the pattern using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we start a loop that executes for all the possible substrings of the
    text. For this, initially, we compute the hash value for the first substring by
    summing the ordinal values of all of its characters using `sum(ord_text[:len_pattern])`.
    Further, the hash values for all of the substrings are computed using the hash
    value of the previous substrings as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, we have precomputed the hash values for the pattern and all the substrings
    of the text that we will use for comparing the pattern and the text in the implementation
    of the **Rabin-Karp algorithm**. The **Rabin-Karp algorithm** works as follows.
    Firstly, we compare the hash values of the pattern and substrings of the text.
    Next, we take the substring for which the hash matches with the hash of the pattern
    and compare them both character by character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete Python implementation of the **Rabin-Karp algorithm** is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, firstly, we convert the given text and pattern into string
    format as the ordinal values can only be computed for strings. Next, we use the
    `generate_hash` function to compute the hash values of patterns and texts. We
    store the length of the text and patterns in the `len_text` and `len_pattern`
    variables. We also initialize the `flag` variable to `False` so that it keeps
    track of whether the pattern is present in the text at least once.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start a loop that implements the main concept of the algorithm. This
    loop executes for the length of `hash_text`, which is the total number of possible
    substrings. Initially, we compare the hash value of the first substring with the
    hash of the pattern by using `if hash_text[i] == hash_pattern`. If they do not
    match; we move one index position and look for another substring. We iteratively
    move further until we get a match.
  prefs: []
  type: TYPE_NORMAL
- en: If we find a match, we compare the substring and the pattern character by character
    through a loop by using `if pattern[j] == text[i+j]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a `count` variable to keep track of how many characters match
    in the pattern and the substring. If the length of the count and the length of
    the pattern are equal, this means that all of the characters match, and the index
    location where the pattern was found is returned. Finally, if the `flag` variable
    remains `False`, this means that the pattern does not match at all with the text.
    The following code snippets can be used to execute the **Rabin-Karp matching algorithm**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we first check whether the pattern “`1011`" appears in the
    given text string “`101110000011010010101101`". The output shows that the given
    pattern occurs at index position `0` and `18`. Next, the pattern “`ACCE`" occurs
    at index position `11` in the text string “`ABBACCADABBACCEDF`".
  prefs: []
  type: TYPE_NORMAL
- en: The Rabin-Karp pattern matching algorithm preprocesses the pattern before the
    searching; that is, it computes the hash value for the pattern that has the complexity
    of `O(m)`. Also, the worst-case running time complexity of the Rabin-Karp algorithm
    is `O(m *(n-m+1))`. The worst-case scenario is when the pattern does not occur
    in the text at all. The average-case scenario is when the pattern occurs at least
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the KMP string matching algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Knuth-Morris-Pratt algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The KMP algorithm is a pattern matching algorithm based on the idea that the
    overlapping text in the pattern itself can be used to immediately know at the
    time of any mismatch how much the pattern should be shifted to skip unnecessary
    comparisons. In this algorithm, we will precompute the `prefix` function that
    indicates the required number of shifts of the pattern whenever we get a mismatch.
    The KMP algorithm preprocesses the pattern to avoid unnecessary comparisons using
    the `prefix` function. So, the algorithm utilizes the `prefix` function to estimate
    how much the pattern should be shifted to search the pattern in the text string
    whenever we get a mismatch. The **KMP algorithm** is efficient as it minimizes
    the number of comparisons of the given patterns with respect to the text string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The motivation behind the **KMP algorithm** can be observed in *Figure 13.4*.
    In this example, it can be seen that the mismatch occurred at the 6^(th) position
    with the last character “d” after matching the initial 5 characters. It is also
    known from the `prefix` function that the character “d” did not appear before
    in the pattern, and utilizing this information, the pattern can be shifted by
    six places:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Example of the KMP algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this example, the pattern has shifted six positions instead of one.
    Let us discuss another example to understand the concept of the **KMP algorithm**,
    as shown in *Figure 13.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_05.png)Figure 13.5: Second example of the KMP algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: In the above example, the mismatch occurs at the last character of the pattern.
    Since the pattern at the location of the mismatch has a partial match of the prefix
    **bc**, this information is given by the `prefix` function. Here, the pattern
    can be shifted to align with the other occurrence of the matched prefix **bc**
    in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We will look into the `prefix` function next for a better understanding of how
    we use it to know by how much we should shift the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The prefix function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `prefix` function (also known as the failure function) finds the pattern
    within the pattern. It finds out how much the previous comparisons can be reused
    due to repetition in the pattern itself when there is a mismatch. The `prefix`
    function returns a value for each position wherever we get a mismatch, which tells
    us by how much the pattern should be shifted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us understand how we use the `prefix` function to find the required shift
    amount with the following examples. Consider the first example: if we had a `prefix`
    function for a pattern where all of the characters are different, the `prefix`
    function would have a value of `0`. This means that if we find any mismatch, the
    pattern will be shifted by the number of characters compared up to that position
    in the pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example with the pattern **abcde**, which contains all different
    characters. We start comparing the first character of the pattern with the first
    character of the text string, as shown in *Figure 13.6*. As shown in the figure,
    the mismatch occurs at the 4^(th) character in the pattern. Since the prefix function
    has the value 0, it means that there is no overlap in the pattern and no previous
    comparisons would be reused, so the pattern will be shifted to the number of characters
    compared up until that point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Prefix function in the KMP algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another example to better understand how the `prefix` function
    works for the pattern `(P)` **abcabbcab** as shown in *Figure 13.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Example of the prefix function in the KMP algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 13.7*, we start calculating the values of the `prefix` function
    starting from index `1`. We assign the value **0** if there is no repetition of
    the characters in the pattern. So, in this example, we assign **0** to the `prefix`
    function for index positions 1 to 3\. Next, at index position `4`, we can see
    that there is a character, **a**, which is a repetition of the first character
    of the pattern itself, so we assign the value **1** here, as shown in *Figure
    13.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Value of the prefix function at index 4 in the KMP algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we look at the next character at position 5\. It has the longest suffix
    pattern, **ab**, and so it would have a value of **2**, as shown in *Figure 13.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: Value of the prefix function at index 5 in the KMP algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we look at the next index position of `6`. Here, the character is
    **b**. This character does not have the longest suffix in the pattern, so it has
    the value **0**. Next, we assign value **0** at index position `7`. Then, we look
    at the index position `8`, and we assign the value **1** as it has the longest
    suffix of length **1**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at the index position of `9`, we have the longest suffix of **2**.
    This is shown in *Figure 13.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: Value of the prefix function at index 6 to 9 in the KMP algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `prefix` function shows how much of the start of the string
    can be reused if there is a mismatch. For example, if the comparison fails at
    index position `5`, the `prefix` function value is **2**, which means that the
    two starting characters don’t need to be compared, and the pattern can be shifted
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discuss the details of the **KMP algorithm**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the KMP algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **KMP pattern matching algorithm** detects overlaps in the pattern itself
    so that it avoids unnecessary comparisons. The main idea behind the **KMP algorithm**
    is to detect how much the pattern should be shifted, based on the overlaps in
    the patterns. The algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we precompute the `prefix` function for the given pattern and initialize
    a counter **q** that represents the number of characters that matched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start by comparing the first character of the pattern with the first character
    of the text string, and if this matches, then we increment the counter **q** for
    the pattern and the counter for the text string, and we compare the next character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is a mismatch, then we assign the value of the precomputed `prefix`
    function for `q` to the index value of `q`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We continue searching the pattern in the text string until we reach the end
    of the text, that is, if we do not find any matches. If all of the characters
    in the pattern are matched in the text string, we return the position where the
    pattern is matched in the text and continue to search for another match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s consider the following example to understand the working of the **KMP
    algorithm**. We have a pattern `acacac` along with index positions from `1` to
    `6` (just for simplicity, we have index positions starting from 1 instead of 0),
    shown in *Figure 13.11*. The `prefix` function for the given pattern is constructed
    as shown in *Figure 13.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: The prefix function for pattern “acacac”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take an example to understand how we use the `prefix` function to shift
    the pattern according to the **KMP algorithm** for the text string and pattern
    given in *Figure 13.12*. We start comparing the pattern and the text character
    by character. When we mismatch at index position `6`, we see the prefix value
    for this position is **2**. Then we shift the pattern according to the return
    value of the `prefix` function. Next, we start comparing the pattern and text
    string from the index position of `2` on the pattern (character **c**), and the
    character **b** of the text string. Since this is a mismatch, the pattern will
    be shifted according to the value of the `prefix` function at this position. This
    description is depicted in *Figure 13.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: The pattern is shifted according to the return value of the prefix
    function'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take another example shown in *Figure 13.13* where the position of
    the pattern over the text is shown. When we start comparing the characters **b**
    and **a**, these do not match, and we see the `prefix` function for index position
    `1` shows a value of **0**, meaning no overlapping of text in the pattern has
    occurred. Therefore, we shift the pattern by **1** place as shown in *Figure 13.12*.
    Next, we compare the pattern and text string character by character, and we find
    a mismatch at index position 10 in the text between characters **b** and **c**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the precomputed `prefix` function to shift the pattern – as the
    `prefix_function(4)` is **2**, we shift the pattern to align over the text at
    index position `2` of the pattern. After that, we compare characters **b** and
    **c** at index position `10`, and since they do not match, we shift the pattern
    by one place. This process is shown in *Figure 13.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: Shifting of the pattern according to the return value of the
    prefix function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us continue our searching from index position `11`, as shown in *Figure
    13.14*. Next, we compare the characters at index `11` in the text and continue
    until a mismatch is found. We find a mismatch between characters **b** and **c**
    at index position `12`, as shown in *Figure 13.14*. We shift the pattern and move
    it next to the mismatched character since the `prefix_function(2)` is `0`. We
    repeat the same process until we reach the end of the string. We find a match
    of the pattern in the text string at index location **13** in the text string,
    as in *Figure 13.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Shifting of the pattern for index positions of 11 to 18'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **KMP algorithm** has two phases: first, the preprocessing phase, which
    is where we compute the `prefix` function, which has the space and time complexity
    of `O(m)`. Further, the second phase involves searching, for which the **KMP algorithm**
    has a time complexity of `O(n)`. So, the worst-case time complexity of the **KMP
    algorithm** is `O(m +n)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will discuss the implementation of the **KMP algorithm** using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KMP algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python implementation of the KMP algorithm is explained here. We start
    by implementing the `prefix` function for the given pattern. The code for the
    `prefix` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we first compute the length of the pattern using the `len()`
    function, and then we initialize a list to store the values computed by the `prefix`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start the loop that executes from 2 to the length of the pattern. Then,
    we have a nested loop that is executed until we have processed the whole pattern.
    The variable `k` is initialized to `0`, which is the `prefix` function for the
    first element of the pattern. If the `k`^(th) element of the pattern is equal
    to the `q`^(th) element, then we increment the value of `k` by `1`. The value
    of `k` is the value computed by the `prefix` function, and so we assign it at
    the index position of `q` in the pattern. Finally, we return the list of the `prefix`
    function that has the computed value for each character of the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created the `prefix` function, we implement the main **KMP matching
    algorithm**. The following code shows this in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we start by computing the length of the text string and the
    pattern, which are stored in the variables `m` and `n`, respectively. Next, we
    define a variable `flag` to indicate whether the pattern has found a match or
    not. Further, we add a dummy character `-` in the text and pattern to make the
    indexing start from index `1` instead of index `0`. Next, we call the `pfun()`
    method to construct the array containing the prefix values for all the positions
    of the pattern using `prefix_fun = pfun(pattern)`. Next, we execute a loop starting
    from `1` to `m+1`, where `m` is the length of the pattern. Further, for each iteration
    of the `for` loop, we compare the pattern and text in a `while` loop until we
    finish searching the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If we get a mismatch, we use the value of the `prefix` function at index `q`
    (here, `q` is the index where the mismatch occurs) to find out by how much we
    have to shift the pattern. If the pattern and text are equal, then the value of
    `1` and `n` will be equal, and we can return the index where the pattern was matched
    in the text. Further, we update the `flag` variable to `True` when the pattern
    is found in the text. If we finished searching the whole text string and still
    the variable `flag` was `False`, it would mean the pattern was not present in
    the given text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet can be used to execute the KMP algorithm for string
    matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the above output, we see that the pattern is present at index positions 0
    and 9 in the given text string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss another pattern matching algorithm, the Boyer-Moore algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Boyer-Moore algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already discussed, the main objective of the string pattern matching
    algorithm is to find ways of skipping comparisons as much as possible by avoiding
    unnecessary comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Boyer-Moore pattern matching algorithm is another such algorithm (along
    with the KMP algorithm) that further improves the performance of pattern matching
    by skipping comparisons using different methods. We have to understand the following
    concepts in order to understand the Boyer-Moore algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: In this algorithm, we shift the pattern in the direction from left to right,
    similar to the KMP algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We compare the characters of the pattern and the text string from right to left,
    which is the opposite of what we do in the case of the KMP algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm skips the unnecessary comparisons by using the good suffix and
    bad character shift heuristics. These heuristics themselves find the possible
    number of comparisons that can be skipped. We slide the pattern over the given
    text with the greatest offsets suggested by both of these heuristics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us understand all about these heuristics and the details of how the Boyer-Moore
    pattern matching algorithm works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Boyer-Moore algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Boyer-Moore algorithm compares the pattern with the text from right to left,
    meaning that in this algorithm if the end of the pattern does not match with the
    text, the pattern can be shifted rather than checking every character of the text.
    The key idea is that the pattern is aligned with the text and the last character
    of the pattern is compared with the text, and if they do not match, then it is
    not required to continue comparing each character and we can rather shift the
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Here, how much we shift the pattern depends upon the mismatched character. If
    the mismatched character of the text does not appear in the pattern, it means
    we can shift the pattern by the whole length of the pattern, whereas if the mismatched
    character appears in the pattern somewhere, then we partially shift the pattern
    in such a way that the mismatched character is aligned with the other occurrence
    of that character in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, in this algorithm, we can also see what portion of the pattern
    has matched (with the matched suffix), so we utilize this information and align
    the text and pattern by skipping any unnecessary comparisons. Making the pattern
    jump along the text to reduce the number of comparisons rather than checking every
    character of the pattern with the text is the main idea of an efficient string
    matching algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept behind the Boyer-Moore algorithm is demonstrated in *Figure 13.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: A example to demonstrate the concept of the Boyer-Moore algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: In the example shown in *Figure 13.15*, where character **b** of the pattern
    mismatches with character **d** of the text, we can shift the entire pattern since
    the mismatched character **d** is not present in the pattern anywhere. In the
    second mismatch, we can see that the mismatched character **a** in the text is
    present in the pattern, so we shift the pattern to align with that character.
    This example shows how we can skip unnecessary comparisons. Next, we will discuss
    further the details of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Boyer-Moore algorithm has two heuristics to determine the maximum shift
    possible for the pattern when we find a mismatch:'
  prefs: []
  type: TYPE_NORMAL
- en: Bad character heuristic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good suffix heuristic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of a mismatch, each of these heuristics suggests possible shifts,
    and the Boyer-Moore algorithm shifts the pattern over the text string by a longer
    distance considering the maximum shift given by bad character and good suffix
    heuristics. The details of the bad character and good suffix heuristics are explained
    in detail with examples in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Bad character heuristic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Boyer-Moore algorithm compares the pattern and the text string in the direction
    of right to left. It uses the bad character heuristic to shift the pattern, where
    we start comparing character by character from the end of the pattern, and if
    they match then we compare the second to-last character, and if that also matches,
    then the process is repeated until the entire pattern is matched or we get a mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mismatched character of the text is also known as a bad character. If we
    get any mismatch in this process, we shift the pattern according to one of the
    following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If the mismatched character of the text does not occur in the pattern, then
    we shift the pattern next to the mismatched character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the mismatched character has one occurrence in the pattern, then we shift
    the pattern in such a way that we align with the mismatched character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the mismatched character has more than one occurrence in the pattern, then
    we make the most minimal shift possible to align the pattern with that character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us understand these three cases with examples. Consider a text string (`T`)
    and the pattern = {**acacac**}. We start by comparing the characters from right
    to left, that is, character **c** of the pattern and character **b** of the text
    string. Since they do not match, we look for the mismatched character of the text
    string (that is **b**) in the pattern. Since the bad character **b** does not
    appear in the pattern, we shift the pattern next to the mismatched character,
    as shown in *Figure 13.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: Example of the bad character heuristic in the Boyer-Moore algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another example with a given text string and the pattern = {**acacac**}
    as shown in *Figure 13.17*. For the given example, we compare the characters of
    the text string and the pattern from right to left, and we get a mismatch for
    the character **d** of the text. Here, the suffix **ac** is matched, but the characters
    **d** and **c** do not match, and the mismatched character **d** does not appear
    in the pattern. Therefore, we shift the pattern next to the mismatched character,
    as shown in *Figure 13.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.17: Second example of the bad character heuristic in the Boyer-Moore
    algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example to understand the second and third cases of the bad
    character heuristic for the given text string and the pattern as shown in *Figure
    13.18*. Here, the suffix **ac** is matched, but the next characters, **a** and
    **c**, do not match, so we search for the occurrences of the mismatched character
    **a** in the pattern. Since it has two occurrences in the pattern, we have two
    options for shifting the pattern to align it with the mismatched character. Both
    of these options are shown in *Figure 13.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In such situations where we have more than one option to shift the pattern,
    we apply the least possible number of shifts to prevent missing any possible match.
    If on the other hand we have only one occurrence of the mismatched character in
    the pattern, we can easily shift the pattern in such a way that the mismatched
    character is aligned. So, in this example, we would prefer option 1 to shift the
    pattern as shown in *Figure 13.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.18: Third example of the bad character heuristic in the Boyer-Moore
    algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the bad character heuristic so far, and we consider the good
    suffix heuristic in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Good suffix heuristic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bad character heuristic does not always provide good suggestions for shifting
    the pattern. The Boyer-Moore algorithm also uses the good suffix heuristic to
    shift the pattern over the text string, which is based on the matched suffix.
    In this method, we shift the pattern to the right in such a way that the matched
    suffix of the pattern is aligned with another occurrence of the same suffix in
    the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'It works like this: we start by comparing the pattern and the text string from
    right to left, and if we find any mismatch, then we check the occurrence of the
    suffix in the pattern that has been matched so far, which is known as a good suffix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In such situations, we shift the pattern in such a way that we align another
    occurrence of the good suffix to the text. The good suffix heuristic has two main
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The matching suffix has one or more occurrences in the pattern
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some part of the matching suffix is present at the start of the pattern (this
    means that the suffix of the matched suffix exists as the prefix of the pattern)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s understand these cases with the following examples. Suppose we have a
    given text string and the pattern **acabac** as shown in *Figure 13.19*. We start
    comparing the characters from right to left, and we get a mismatch with the character
    **a** of the text string and **b** of the pattern. By the point of this mismatch,
    we have already matched the suffix **ac**, which is called the “good suffix.”
    Now, we search for another occurrence of the good suffix **ac** in the pattern
    (which is present at the starting position of the pattern in this example) and
    we shift the pattern to align it with that suffix, as shown in *Figure 13.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.19: Example of the good suffix heuristic in the Boyer-Moore algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take another example to understand the good suffix heuristic. Consider
    the text string and pattern given in *Figure 13.18*. Here, we get a mismatch between
    characters **a** and **c**, and we get a good suffix **ac**. Here, we have two
    options for shifting the pattern to align it with the good suffix string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a situation where we have more than one option to shift the pattern, we
    take the option with the lower number of shifts. For this reason, we take option
    1 in this example, as shown in *Figure 13.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.20: Second example of the good suffix heuristic in the Boyer-Moore
    algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at another example of the text string and pattern shown in
    *Figure 13.19*. In this example, we get a good suffix string **aac**, and we get
    a mismatch for the characters **b** of the text string and **a** of the pattern.
    Now, we search for the good suffix **aac** in the pattern, but we do not find
    another occurrence of it. When this happens, we check whether the prefix of the
    pattern matches the suffix of the good suffix, and if so, we shift the pattern
    to align with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we find that the prefix **ac** at the start of the pattern
    does not match with the full good suffix, but does match the suffix **ac** of
    the good suffix **aac**. In such a situation, we shift the pattern by aligning
    with the suffix of **aac** that is also a prefix of the pattern as shown in *Figure
    13.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.21: Third example of the good suffix heuristic in the Boyer-Moore
    algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Another case for the good suffix heuristic for the given text string and pattern
    is shown in *Figure 13.22*. In this example, we compare the text and pattern and
    find the good suffix **aac**, and we get a mismatch with character **b** of the
    text and **a** of the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we search for the matched good suffix in the pattern, but there is no
    occurrence of the suffix in the pattern, nor does any prefix of the pattern match
    the suffix of the good suffix. So, in this kind of situation, we shift the pattern
    after the matched good suffix as shown in *Figure 13.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_13_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.22: Fourth example of the good suffix heuristic in the Boyer-Moore
    algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: In the Boyer-Moore algorithm, we compute the shifts given by the bad character
    and good suffix heuristics. Further, we shift the pattern by the longer of the
    distances given by the bad character and good suffix heuristics.
  prefs: []
  type: TYPE_NORMAL
- en: The Boyer-Moore algorithm has a time complexity of `O(m)` for the preprocessing
    of the pattern, and the searching has a time complexity of `O(mn)`, where `m`
    is the length of the pattern and `n` is the length of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us discuss the implementation of the Boyer-Moore algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Boyer-Moore algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s understand the implementation of the Boyer-Moore algorithm. The complete
    implementation of the Boyer-Moore algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An explanation of each of the statements of the preceding code is presented
    here. Initially, we have the text string and the pattern. After initializing the
    variables, we start with a `while` loop that starts by comparing the last character
    of the pattern with the corresponding character of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the characters are compared from right to left by the use of the nested
    loop from the last index of the pattern to the first character of the pattern.
    This uses `range(len(pattern)-1, -1, -1)`.
  prefs: []
  type: TYPE_NORMAL
- en: The outer `while` loop keeps track of the index in the text string while the
    inner `for` loop keeps track of the index position in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start comparing the characters by using `pattern[j] != text[i+j]`.
    If they are mismatched, we make the `flag` variable `False`, denoting that there
    is a mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we check whether the good suffix is present using the condition `j == len(pattern)-1`.
    If this condition is true, it means that there is no good suffix possible, so
    we check for the bad character heuristics, that is, whether a mismatched character
    is present in the pattern using the condition `text[i+j] in pattern[0:j]`, and
    if the condition is true, then it means that the bad character is present in the
    pattern. In this case, we move the pattern to align this bad character to the
    other occurrence of this character in the pattern by using `i=i+j-pattern[0:j].rfind(text[i+j])`.
    Here, `(i+j)` is the index of the bad character.
  prefs: []
  type: TYPE_NORMAL
- en: If the bad character is not present in the pattern (it isn’t in the `else` part
    of it), we move the whole pattern next to the mismatched character by using the
    index `i=i+j+1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we go into the `else` part of the condition to check the good suffix.
    When we find the mismatch, we further test to see whether we have any subpart
    of a good suffix present in the prefix of the pattern. We do this using the following
    condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, we check whether the length of the good suffix is `1` or not. If
    the length of the good suffix is `1`, we do not consider this shift. If the good
    suffix is more than `1`, we find out the number of shifts by using the good suffix
    heuristics and store this in the `gsshift` variable. This is the pattern, which
    leads to a position where the good suffix of the pattern matches the good suffix
    in the text using the instruction `gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)])`.
    Furthermore, we computed the number of shifts possible due to the bad character
    heuristic and stored this in the `bcshift` variable. The number of shifts possible
    is `i+j-pattern[0:j].rfind(text[i+j])` when the bad character is present in the
    pattern, and the number of shifts possible would be `i+j+1` in the case of the
    bad character not being present in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we shift the pattern on the text string by the maximum number of moves
    given by the bad character and good suffix heuristics by using the instruction
    `i=max((bcshift, gsshift))`. Finally, we check whether the `flag` variable is
    `True` or not. If it is `True`, this means that the pattern has been found and
    that the matched index has been stored in the `matched_indexes` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the concept of the Boyer-Moore pattern matching algorithm,
    which is an efficient algorithm that skips unnecessary comparisons using the bad
    character and good suffix heuristics.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the most popular and important string matching
    algorithms that have a wide range of applications in real-time scenarios. We discussed
    the brute force, Rabin-Karp, KMP, and Boyer-Moore pattern matching algorithms.
    In string matching algorithms, we try to uncover ways to skip unnecessary comparisons
    and move the pattern over the text as fast as possible. The **KMP algorithm**
    detects unnecessary comparisons by looking at the overlapping substrings in the
    pattern itself to avoid redundant comparisons. Furthermore, we discussed the **Boyer-Moore
    algorithm**, which is very efficient when the text and pattern are long. It is
    the most popular algorithm used for string matching in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Show the KMP `prefix` function for the pattern `"aabaabcab"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the expected number of valid shifts is small and the modulus is larger than
    the length of the pattern, then what is the matching time of the Rabin-Karp algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Theta (m)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Big O (n+m)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Theta (n-m)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Big O (n)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How many spurious hits does the Rabin-Karp string matching algorithm encounter
    in the text `T = "3141512653849792"` when looking for all occurrences of the pattern
    `P = "26"`, working modulo `q = 11`, and over the alphabet set `Σ = {0, 1, 2,...,
    9}`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the basic formula applied in the Rabin-Karp algorithm to get the computation
    time as Theta (m)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Halving rule
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Horner’s rule
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summation lemma
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cancellation lemma
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The Rabin-Karp algorithm can be used for discovering plagiarism in text documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1421249772551223062.png)'
  prefs: []
  type: TYPE_IMG
