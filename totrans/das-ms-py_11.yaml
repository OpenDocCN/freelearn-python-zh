- en: Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: In the previous chapter, we looked at reactive programming and the ReactiveX
    framework. In this chapter, we're going to take a look at what a microservice
    is, why we might want to structure our programs as microservices, and how to use
    some common Python tools to create them. You'll learn how to use the Flask package
    to quickly and easily construct a microservice that uses HTTP and **representational
    state transfer**, (**REST**), to provide its interface. We're also going to look
    at using the nameko package to create microservices that communicate using remote
    procedure calls instead of HTTP methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了响应式编程和ReactiveX框架。在本章中，我们将探讨什么是微服务，为什么我们可能想要将我们的程序结构化为微服务，以及如何使用一些常见的Python工具来创建它们。你将学习如何使用Flask包快速轻松地构建一个使用HTTP和**表示状态传输**（**REST**）来提供其接口的微服务。我们还将探讨使用nameko包来创建使用远程过程调用而不是HTTP方法进行通信的微服务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Microservices and the advantages of process isolation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与进程隔离的优势
- en: Building high-level microservices with Flask
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask构建高级微服务
- en: Building high-level microservices with nameko
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用nameko构建高级微服务
- en: Microservices and the advantages of process isolation
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务与进程隔离的优势
- en: In this section, we'll look at microservices from a conceptual perspective.
    When we need a new feature for a project, there's a temptation to just add it
    to the project's main program and continue on from there. Sometimes, that's entirely
    appropriate, but in many cases, it's actually better to make the feature a distinct
    program in its own right.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从概念角度探讨微服务。当我们需要一个项目的新功能时，有一种诱惑就是直接将其添加到项目的主程序中并继续下去。有时，这样做是完全合适的，但在许多情况下，实际上更好的做法是将该功能作为一个独立的程序。
- en: Advantages of the microservice architecture
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的优势
- en: There are several reasons why a feature might be better off when less tightly
    integrated into the system. The most important ones are **flexibility**, **scalability**,
    and **durability**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因说明为什么一个功能在系统集成不那么紧密时可能更好。其中最重要的原因是**灵活性**、**可伸缩性**和**耐久性**。
- en: Understanding the flexibility benefit is easy. Modular programs inherently consist
    of a bunch of modules that we can reuse in the future. So, every time we write
    our code as an independent module with a well-defined interface, we're making
    an investment that will make it easier to adapt to the changes that come in the
    future.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 理解灵活性优势很容易。模块化程序本质上由许多模块组成，我们可以在未来重用它们。因此，每次我们将代码编写为具有良好定义接口的独立模块时，我们都在进行一项投资，这将使它更容易适应未来的变化。
- en: The scalability advantage comes into play when our modules are actually separate
    processes, allowing separate instances to be run on multiple processors, with
    the load balanced across them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的模块实际上是单独的进程时，可伸缩性的优势就会发挥作用，允许在多个处理器上运行单独的实例，并在它们之间进行负载均衡。
- en: The durability advantage also comes into play when the modules are processes
    because processes are mostly safe from the bugs that crop up in other processes,
    also because a failed process can often be restarted without needing to take down
    the whole system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块是进程时，耐久性的优势也发挥作用，因为进程大多可以免受其他进程中出现的问题的影响，也因为一个失败的进程通常可以在不需要关闭整个系统的情况下重新启动。
- en: Applying the microservice architecture to web servers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务架构应用于Web服务器
- en: 'Flexibility, scalability and durability are the same advantages that drove
    the development of microkernel operating systems back in the 1980s, but the term
    microservice (refer to following image) specifically refers to applying them to
    web applications:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活性、可伸缩性和耐久性是推动20世纪80年代微内核操作系统发展的相同优势，但术语微服务（参见图）具体指的是将它们应用于Web应用程序：
- en: '![](img/74e911f5-e824-4b73-8503-80081817c880.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74e911f5-e824-4b73-8503-80081817c880.jpg)'
- en: This means that instead of writing one server program that handles all the logic
    of our web application, we'll write one or more servers that handle most of the
    frontend work and call on a bunch of different special-purpose servers to handle
    all the backend work and any remaining parts of the frontend.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不会编写一个处理我们Web应用程序所有逻辑的服务器程序，而是编写一个或多个服务器，它们处理大部分前端工作，并调用一些不同的专用服务器来处理所有后端工作以及前端剩余的部分。
- en: Each special-purpose server should do a single well-defined job as well as possible
    and not care about anything. Those special-purpose servers are microservices,
    and using a microservice design gives us better uptime. Uptime lets us scale up
    to take advantage of a server farm or a cloud hosting system and helps us adapt
    to the ever-changing web more quickly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个专用服务器都应该尽可能做好一个明确定义的工作，而不关心其他任何事情。这些专用服务器是微服务，采用微服务设计可以给我们带来更好的正常运行时间。正常运行时间让我们能够扩展到利用服务器农场或云托管系统，并帮助我们更快地适应不断变化的网络。
- en: So, to recap, when our server is actually a collection of servers, each of which
    has a narrow and well-defined job to do, and does only that, we're using a microservice
    architecture. As an added benefit, the interfaces between our microservices constitute
    an application programming interface. So, if we get to a place where we want to
    expose an API for the world to use, all we have to do is adjust our authentication
    and authorization code, and possibly our routers, to allow external entities to
    access some of those interfaces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了总结，当我们的服务器实际上是一组服务器，每个服务器都有明确和狭窄的工作要做，并且只做那件事时，我们正在使用微服务架构。作为额外的优势，我们的微服务之间的接口构成了应用程序编程接口。因此，如果我们达到一个想要向世界公开API的位置，我们只需要调整我们的身份验证和授权代码，以及可能的路由器，以允许外部实体访问这些接口的一些接口。
- en: Building high-level microservices with Flask
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask构建高级微服务
- en: So, we had a look at what a microservice is and why structuring our servers
    as collection of microservices is helpful. Now, let's take a look at the practicalities
    and use Flask to construct a functioning microservice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经了解了微服务是什么以及为什么将我们的服务器结构化为微服务集合是有帮助的。现在，让我们看看实际操作，并使用Flask构建一个功能性的微服务。
- en: Microservices can be pretty easily divided into those that use web technologies,
    such as HTTP, to communicate with each other and those that use a dedicated inter-process
    communication or a remote-procedure-called mechanism to communicate.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以很容易地分为那些使用Web技术（如HTTP）相互通信的微服务，以及那些使用专用进程间通信或远程过程调用机制进行通信的微服务。
- en: There are advantages to each, depending on the specific needs of a project and
    neither is inherently easier to work with. However, I'm going to refer to microservices
    that use web technologies to communicate as *high level* because they are inherently
    closer to the level at which users operate. Conversely, I'll refer to microservices
    that use specialized protocols as *low level*. In this section, we'll look at
    high-level microservices, which usually use HTTP to communicate and provide REST-based
    programming interfaces.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每种框架都有其优势，这取决于项目的具体需求，并且它们在本质上并不容易使用。然而，我将把使用Web技术进行通信的微服务称为*高级*，因为它们本质上更接近用户操作的水平。相反，我将把使用专用协议的微服务称为*低级*。在本节中，我们将探讨高级微服务，这些服务通常使用HTTP进行通信，并提供基于REST的编程接口。
- en: Using stateless protocols for communication makes these microservices easy to
    load balance and easy to swap in and out for maintenance. For this type of microservice,
    we can use any of Python's several production quality web application frameworks
    or toolkits, but we're going to use Flask.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无状态协议进行通信使得这些微服务易于负载均衡，也便于在维护时进行替换。对于这类微服务，我们可以使用Python的多个生产级Web应用程序框架或工具包，但我们将使用Flask。
- en: Installing Flask
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Flask
- en: Flask is laser-focused on making it easy to write handlers for HTTP requests
    and doesn't really do anything else. That makes it very well-suited for writing
    a microservice that processes a few specific requests while using minimal resources.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Flask专注于使编写HTTP请求处理程序变得容易，实际上并不做其他任何事情。这使得它非常适合编写处理少量特定请求的微服务，同时使用最少的资源。
- en: 'Flask isn''t part of a Python standard library, but it''s easily installed
    using `pip`, as shown in the following command line:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Flask不是Python标准库的一部分，但可以通过`pip`轻松安装，如下面的命令行所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As always, you can add `--user` to the command to install Flask into your personal
    Python package library, or you can install it into a virtual environment if you
    prefer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，您可以在命令中添加`--user`以将Flask安装到您的个人Python包库中，或者如果您愿意，可以将其安装到虚拟环境中。
- en: Creating endpoints for a RESTful API in Flask
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flask中创建RESTful API的端点
- en: Flask is designed to interface with a frontend web server or proxy using the
    **Web Server Gateway Interface** (**WSGI**), which is standard for Python web
    applications. However, we'll just use its built-in development server for our
    simple little demonstration. So, what shall we build?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Flask被设计用来通过**Web Server Gateway Interface**（**WSGI**）与前端Web服务器或代理进行接口交互，这是Python
    Web应用程序的标准。然而，在我们的简单演示中，我们只会使用其内置的开发服务器。那么，我们应该构建什么呢？
- en: Building a microservice to maintain a database
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个维护数据库的微服务
- en: Let's build a microservice that maintains a database of information about people-first
    name, last name, age, and for interest's sake, whether or not they are members
    of a particular club.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个维护有关人员信息的数据库的微服务——首先名字、姓氏、年龄，以及出于兴趣，他们是否是某个特定俱乐部的成员。
- en: We'll use the `POST`, `GET`, `PUT`, and `DELETE` methods of HTTP to allow the
    clients of the microservice to create, access, update, and remove records from
    the database. Also, we'll provide the data in JSON format, but accept the input
    using the normal HTTP form encoding.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用HTTP的`POST`、`GET`、`PUT`和`DELETE`方法，允许微服务的客户端创建、访问、更新和从数据库中删除记录。此外，我们将以JSON格式提供数据，但使用正常的HTTP表单编码来接收输入。
- en: These choices are all very normal. The only, slightly-less-common choice would
    be to have incoming data in JSON format as well, which we accommodate by calling
    the `request.get_json` function of Flask when we need the data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择都非常正常。唯一稍微不那么常见的选项是，我们还需要将传入的数据格式化为JSON，我们可以通过在需要数据时调用Flask的`request.get_json`函数来满足这一需求。
- en: 'So, which boilerplate code do we need to get a Flask microservice on its feet?
    Not much, as it turns out. The following two command lines are sufficient to get
    the Flask system in place:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们需要哪些样板代码才能让Flask微服务启动运行？实际上并不多。以下两个命令行就足以将Flask系统设置到位：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These lines don't actually do anything except return *404 Not Found* errors
    in response to any request, but they'll respond. So, how do we make Flask handle
    a request? Let's take a look.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行实际上并没有做任何事情，除了对任何请求返回*404 Not Found*错误，但它们会响应。那么，我们如何让Flask处理请求呢？让我们看看。
- en: Making Flask handle a request
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让Flask处理请求
- en: 'There are actually two ways to make Flask handle a request: one way is incredibly
    simple and the other is more flexible and better encapsulated.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有两种方法可以让Flask处理请求：一种方法非常简单，另一种则更加灵活且封装得更好。
- en: 'The simpler way is to use the `@app.route` decorator to tell Flask that a particular
    function will handle requests for a given path, as shown in the following code
    example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的方法是使用`@app.route`装饰器告诉Flask，特定的函数将处理给定路径的请求，如下面的代码示例所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's all that's needed, apart from making the function actually do something
    useful.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让函数真正做一些有用的事情之外，这就足够了。
- en: 'However, for our microservice, we want to use HTTP methods on the same path
    to produce different results. We can use an `app.route` decorator and a bunch
    of `if` and `else if` blocks in the function to handle that, but there''s a better
    way, which is explained using the following code example and that you can find
    in the `endpoint.py` file in the download pack:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的微服务，我们希望在同一路径上使用HTTP方法来产生不同的结果。我们可以使用`app.route`装饰器和函数中的多个`if`和`else
    if`块来处理这个问题，但有一个更好的方法，这将在以下代码示例中解释，你可以在下载包中的`endpoint.py`文件中找到：
- en: '![](img/8b9ccad3-130f-4a89-8118-77ef0d2ada4a.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b9ccad3-130f-4a89-8118-77ef0d2ada4a.jpg)'
- en: Flask supports pluggable view classes and specifically has a `MethodView` class
    that has a different handler function for each HTTP method, as you can see in
    the first four function definitions in our class. The appropriate function processes
    each request based on which HTTP method was used.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Flask支持可插拔视图类，并且特别有一个`MethodView`类，它为每个HTTP方法都有一个不同的处理函数，正如你在我们类中的前四个函数定义中可以看到的那样。适当的函数根据使用的HTTP方法处理每个请求。
- en: There's a slight complication to this because we don't actually always want
    to use the same path. Sometimes, we want an object `id` in the path and sometimes
    we don't. This is only a small complication though, because we can register the
    same pluggable view on several different combinations of path and method, which
    is exactly what the `endpoint.register` function in `endpoint.py` does, as you
    can see in the code example.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一点复杂，因为我们并不总是想使用相同的路径。有时，我们想在路径中有一个对象`id`，有时则不需要。但这只是一个小的复杂问题，因为我们可以在多个不同的路径和方法组合上注册相同的可插拔视图，这正是`endpoint.py`中的`endpoint.register`函数所做的事情，正如你在代码示例中可以看到的那样。
- en: 'Each registration of `view` consists of one call to `app.add_url_rule`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`view`的每个注册都包含对`app.add_url_rule`的一个调用：'
- en: The first one registers the `GET` method with no object `id` and fills in values
    to use for the `id` parameter when calling the `GET` function
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个注册了没有对象`id`的`GET`方法，并在调用`GET`函数时填充用于`id`参数的值。
- en: The second one registers the `POST` method with no `id` and no default because
    our `POST` function doesn't accept an `id` parameter at all
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个注册了没有`id`和默认值的`POST`方法，因为我们的`POST`函数根本不接受`id`参数。
- en: The third one registers the `GET`, `PUT`, and `DELETE` methods when there is
    an `id` parameter
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个注册了当存在`id`参数时的`GET`、`PUT`和`DELETE`方法。
- en: These registrations cover all the use cases common to a single programming interface
    endpoint in REST.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注册涵盖了REST单个编程接口端点常见的所有用例。
- en: Running and connecting to our microservice using Flask
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask运行和连接到我们的微服务
- en: 'Now that we have our method dispatching ready, how about we put together our
    actual handlers for manipulating person objects? We can do it using the following
    code found in the `service.py` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了方法分发，那么我们如何组合实际处理人员对象的处理器呢？我们可以使用`service.py`文件中的以下代码来完成：
- en: '![](img/166cafd1-dcad-4d22-a525-457023618911.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/166cafd1-dcad-4d22-a525-457023618911.jpg)'
- en: For the detailed code, please refer to the code files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于详细的代码，请参阅代码文件。
- en: 'From the preceding code example, we find the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码示例中，我们发现以下内容：
- en: We see our `PersonAPI` class, which has one function for each of the operations
    we want to enable on our `person` database.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到我们的`PersonAPI`类，它为我们在`person`数据库上想要启用的每个操作都有一个函数。
- en: For the `POST` and `PUT` functions, we get data from the request using the `request.form`
    object, which is a dictionary-like object containing the decoded data from the
    request body.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`POST`和`PUT`函数，我们使用`request.form`对象从请求中获取数据，这是一个类似于字典的对象，包含从请求体中解码的数据。
- en: This looks like it's not thread-safe, but it actually is. Everything in Flask
    is multithread and multiprocess safe; it's just wrapped in a simplifying semantic
    layer that simulates a single-threaded single-process system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎不是线程安全的，但实际上它是。Flask中的所有内容都是多线程和多进程安全的；它只是被一个简化语义层所包装，模拟了一个单线程单进程系统。
- en: The `POST` function doesn't have any code to handle missing data, except for
    the member value. This is because if we try to access a missing value from `request.form`,
    an exception is raised that causes Flask to return a *400 Bad Request* error,
    which is exactly the right thing to do in this case.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`函数没有处理缺失数据的代码，除了成员值。这是因为如果我们尝试从`request.form`访问缺失的值，将引发异常，导致Flask返回一个*400
    Bad Request*错误，这正是这种情况下的正确做法。'
- en: The `PUT` function, on the other hand, handles those exceptions itself, so that
    it can decide which values to update and which to leave alone.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`PUT`函数会自行处理这些异常，因此它可以决定哪些值需要更新，哪些可以保持不变。
- en: The `GET` function might be called with an integer `id` or with `None` for the
    `id` parameter and needs to handle both cases. This is easily done with an `if`
    statement.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`函数可能被一个整数`id`或`None`作为`id`参数调用，并需要处理这两种情况。这可以通过一个`if`语句轻松完成。'
- en: In the case where the `id` parameter is a number, the `GET` function is supposed
    to return the state of the object with that `id` parameter. If `id` is `None`,
    it is supposed to return a list of all of the objects.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`id`参数是数字的情况下，`GET`函数应该返回具有该`id`参数的对象的状态。如果`id`是`None`，它应该返回所有对象的列表。
- en: All the methods return JSON-formatted data, which is done using Python's standard
    `json` package and specifically the `json.dumps` function, which transforms Python
    data structures into JSON-formatted strings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法都返回JSON格式的数据，这是通过使用Python的内置`json`包和特定的`json.dumps`函数来实现的，该函数将Python数据结构转换为JSON格式的字符串。
- en: We also need to provide the content type header with the value of application
    JSON as a matter of good practice. Between these two things in the return statement,
    we're also providing the HTTP status. This could be omitted, but since we're returning
    error codes in some places, it makes sense to include the status code even when
    it's not an error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供内容类型头，其值为`application/json`，这是良好的实践。在返回语句中的这两件事之间，我们还提供了HTTP状态码。这可以省略，但由于我们在某些地方返回错误代码，所以在不是错误的情况下包含状态码也是有意义的。
- en: Test running the microservice
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试运行微服务
- en: 'To do a test run of our microservice, we need to start up Flask (using the
    following command) and tell it to serve our microservice:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要对我们的微服务进行测试运行，我们需要启动 Flask（使用以下命令）并告诉它为我们提供微服务：
- en: 'For Unix/Linux and macOS, run the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Unix/Linux 和 macOS，运行以下命令：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For Windows, run the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，运行以下命令：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `demo_flask` package also contains a module called `test.py` that we can
    use as a client that connects to our microservice and put it through its paces.
    It will add, delete, list, and modify a couple of database entries and also try
    out a bad post request to show that the error handling is working.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`demo_flask` 包还包含一个名为 `test.py` 的模块，我们可以将其用作连接到我们的微服务并对其进行测试的客户端。它将添加、删除、列出和修改一些数据库条目，并尝试一个错误的
    POST 请求以显示错误处理正在工作。'
- en: There's one more part of the Flask demo microservice that we haven't talked
    about and won't in detail. That is the `person.py` file, which contains a simple
    interface with a SQLite3 database for actually storing and retrieving objects.
    Feel free to look at it, of course, but it's not particularly relevant to the
    topics of the chapter, and a production system should probably use SQLAlchemy,
    Redis, CouchDB, and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个 Flask 示例微服务的一部分我们没有讨论，也不会详细讨论。那就是 `person.py` 文件，它包含一个与 SQLite3 数据库的简单接口，用于实际存储和检索对象。当然，您可以随意查看它，但它与本章的主题并不特别相关，并且生产系统可能应该使用
    SQLAlchemy、Redis、CouchDB 等等。
- en: Building high-level microservices with nameko
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nameko 构建高级微服务
- en: In this section, we'll take a look at **nameko**, which will help us put together
    a microservice that communicates using the **Advanced Message Queuing Protocol**
    (**AMQP**), which we can safely think of as a **Remote Procedure Call** (**RPC**)
    protocol, though that's actually only a part of what it does.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 **nameko**，它将帮助我们构建一个使用 **高级消息队列协议**（**AMQP**）进行通信的微服务，我们可以安全地将其视为
    **远程过程调用**（**RPC**）协议，尽管它实际上只做了其中的一部分。
- en: Installing nameko
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 nameko
- en: Using HTTP to define the interface for our microservice has the advantages of
    familiarity and good integration with web technologies, but there's a certain
    amount of overhead involved in mapping the request and input data onto the functions
    and parameters that are actually meaningful to us.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTP 定义我们的微服务接口具有熟悉性和与网络技术的良好集成优势，但将请求和输入数据映射到对我们真正有意义的函数和参数上涉及一定量的开销。
- en: We can come up with abstractions that hide that part of the process, of course.
    That's essentially what the authors of nameko did, although they use AMQP instead
    of HTTP to transport data and events.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以想出一些抽象来隐藏这个过程的一部分。这正是 nameko 的作者所做的事情，尽管他们使用 AMQP 而不是 HTTP 来传输数据和事件。
- en: 'Installing nameko itself is easy. Use pretty much the same `pip` command we
    always use, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 nameko 本身很简单。使用我们通常使用的几乎相同的 `pip` 命令，如下所示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/62ac1754-7bc5-4178-8d09-9ff6508c9216.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62ac1754-7bc5-4178-8d09-9ff6508c9216.jpg)'
- en: Be aware though that nameko won't actually work until we install some other
    software as well. More on that is covered in the *Things to know before using
    nameko* section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，nameko 除非我们安装其他一些软件，否则实际上不会工作。更多关于这一点的内容在 *使用 nameko 之前需要了解的事项* 部分有所涉及。
- en: Running and connecting a microservice using nameko
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nameko 运行和连接微服务
- en: 'Looking at the nameko version of our `person` service, it''s clear that the
    effort paid off. Our service is defined by a class with the `name` attribute and
    several member functions decorated with `RPC`, as shown in the following code
    example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们的 `person` 服务的 nameko 版本，很明显，我们的努力得到了回报。我们的服务由一个具有 `name` 属性的类定义，并且有几个用
    `RPC` 装饰的成员函数，如下面的代码示例所示：
- en: '![](img/5524cd49-ae11-44bc-b14d-be71ea350057.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5524cd49-ae11-44bc-b14d-be71ea350057.jpg)'
- en: The member functions interface with the same database interface class we used
    in the previous section. In a very straightforward way, it would even be reasonable
    to combine the two into one class, and that's it-the complete definition of our
    microservice using nameko. Pretty sweet, right? It really is, but every cloud
    has a silver lining, as we'll soon see.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数与我们在上一节中使用过的相同的数据库接口类进行接口。以一种非常直接的方式，甚至可以将这两个合并为一个类，这就是我们使用 nameko 的微服务的完整定义。听起来很棒，对吧？确实如此，但每朵云都有银边，我们很快就会看到。
- en: Things to know before using nameko
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nameko 之前需要了解的事项
- en: Nameko is great, but there are things we need to be aware of before we choose
    nameko or any similar tool.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Nameko很棒，但在选择nameko或任何类似工具之前，我们需要注意一些事情。
- en: The first thing to be aware of is that nameko doesn't provide the complete AMQP
    infrastructure, it just connects to it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，nameko不提供完整的AMQP基础设施，它只是连接到它。
- en: The AMQP infrastructure is responsible for conveying messages between connected
    programs in a way that is quick and reliable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP基础设施负责以快速和可靠的方式在连接的程序之间传递消息。
- en: This means that we need an AMQP server running somewhere that nameko can find
    it and an AMQP server accessible to the microservice's users, and those servers
    need to be connected to each other.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要一个Nameko可以找到的AMQP服务器，以及一个微服务用户可以访问的AMQP服务器，并且这些服务器需要相互连接。
- en: They could be the same server, of course, but they don't have to be. Nameko
    recommends the RabbitMQ AMQP server, which can be downloaded from its own website
    ([www.rabbitmq.com](http://www.rabbitmq.com)). The installation is relatively
    uncomplicated and there are detailed instructions on the site.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它们可以是同一个服务器，但不必是。Nameko推荐使用RabbitMQ AMQP服务器，可以从其官方网站下载（[www.rabbitmq.com](http://www.rabbitmq.com)）。安装相对简单，网站上还有详细的说明。
- en: Interacting with our microservice
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与我们的微服务交互
- en: Now that we have an AMQP server installed and running, can we connect or service
    and manipulate person objects? Technically yes, but we need to use nameko to write
    the client too.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装并运行了AMQP服务器，我们能否连接或服务并操作人员对象？技术上是可以的，但我们需要使用nameko来编写客户端。
- en: AMQP isn't as simple to work with as HTTP, and the RPC mechanism adds an additional
    layer of complexity. We don't want to work with that raw.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP不像HTTP那样简单易用，RPC机制增加了额外的复杂性层。我们不希望直接处理这些原始数据。
- en: There are two ways to interact with our microservice. Let's examine them in
    a bit more detail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的微服务交互有两种方式。让我们更详细地考察它们。
- en: Interacting with a microservice manually using the nameko shell
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nameko shell手动与微服务交互
- en: 'The first way we can interact with our microservice is manually using the nameko
    shell, which is an enhanced Python shell. First, we have to run the microservice,
    which we''ll do in its own command window, running the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与微服务交互的第一种方式是手动使用nameko shell，这是一个增强的Python shell。首先，我们必须运行微服务，我们将在它的命令窗口中运行以下命令：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we''ll start the `nameko` shell and use the end `RPC` object to access
    the functions of our microservice, as shown in the following code example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将启动`nameko` shell，并使用末端的`RPC`对象来访问我们的微服务的功能，如下面的代码示例所示：
- en: '![](img/3af9b037-72e6-4ed9-95bc-8464fcfa3921.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3af9b037-72e6-4ed9-95bc-8464fcfa3921.jpg)'
- en: Here, it looks like we're just calling the functions, but actually we're communicating
    with the microservice through the AMQP protocol.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，看起来我们只是在调用函数，但实际上我们是通过AMQP协议与微服务进行通信的。
- en: Interacting with a microservice by creating another microservice
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过创建另一个微服务与微服务交互
- en: 'The second way we can interact with our microservice is to create another microservice
    that depends on it, as shown in the following code example found in the `test.py`
    file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与微服务交互的第二种方式是创建另一个依赖于它的微服务，如下面的代码示例所示，该示例位于`test.py`文件中：
- en: '![](img/94de294f-8a56-4753-99a0-8b2b4c8c2beb.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94de294f-8a56-4753-99a0-8b2b4c8c2beb.jpg)'
- en: 'The `TestService` class periodically exercises the `person`service. It also
    demonstrates how to link one service to another, so that one of them is able to
    access the other. The key is this line, which creates an `RpcProxy` instance on
    the class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestService`类定期对`person`服务进行测试。它还演示了如何将一个服务链接到另一个服务，以便其中一个能够访问另一个。关键是这一行，它在类上创建了一个`RpcProxy`实例：'
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the service runs, it''s able to access the functions of the specified
    remote service through that object. To run our tests, we need to start both the
    `person` microservice and the `test` microservice, which we can do with a single
    command, as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务运行时，它能够通过该对象访问指定远程服务的功能。为了运行我们的测试，我们需要启动`person`微服务和`test`微服务，我们可以使用单个命令完成，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You may have noticed that we return the object `id` from the `create` function,
    rather than create a `person` object itself. That's because we can't return the
    `person` object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们从`create`函数返回对象`id`，而不是创建一个`person`对象。这是因为我们不能返回`person`对象。
- en: Nameko functions can return any data that can be represented as JSON, but that
    doesn't include instances of arbitrary classes. The same goes for parameters that
    are passed into the functions of a microservice; they need to be within the limits
    of JSON.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Nameko函数可以返回任何可以表示为JSON的数据，但这不包括任意类的实例。对于传递给微服务函数的参数也是如此；它们需要限制在JSON的范围内。
- en: This isn't actually a more stringent restriction than what we saw in the Flask
    microservice (in the previous section). It's just that with Flask it was obvious
    we were sending data across the network in JSON format, so that limitation was
    obvious. With nameko, the requirement is the same, but the reason for it is easier
    to miss.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不比我们在Flask微服务（在上一节中）看到的限制更严格。只是在使用Flask时，很明显我们正在以JSON格式通过网络发送数据，因此这种限制是显而易见的。在nameko中，要求是相同的，但原因更容易被忽视。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the start of the chapter, we looked at what microservices are philosophically
    and what their advantages are, and implemented an HTTP-oriented microservice using
    Flask.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们探讨了微服务的哲学意义及其优势，并使用Flask实现了一个面向HTTP的微服务。
- en: We then looked at some of the advantages of process-based modularity and saw
    how applying those principles to web applications results in a microservice architecture.
    We looked at the details needed to use Flask to create a RESTful microservice
    and put that knowledge to use by building a simple person management microservice.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后探讨了基于流程的模块化的优势，并了解了将这些原则应用于Web应用将如何导致微服务架构。我们研究了使用Flask创建RESTful微服务所需的细节，并通过构建一个简单的个人管理微服务来应用这些知识。
- en: Next, we looked at using nameko's RPC mechanism to implement a microservice,
    which simplifies the code significantly, at the cost of requiring that we set
    up an AMQP infrastructure and a more difficult interface with systems outside
    the AMQP network.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了使用nameko的RPC机制来实现微服务，这显著简化了代码，但代价是需要我们设置AMQP基础设施，并且与AMQP网络外部的系统接口更加困难。
- en: In the next chapter, we'll look at how to interface between Python and compiled
    code to optimize performance bottlenecks in our code and access libraries written
    in other programming languages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将Python与编译代码接口，以优化代码中的性能瓶颈，并访问用其他编程语言编写的库。
