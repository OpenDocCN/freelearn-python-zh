- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at reactive programming and the ReactiveX
    framework. In this chapter, we're going to take a look at what a microservice
    is, why we might want to structure our programs as microservices, and how to use
    some common Python tools to create them. You'll learn how to use the Flask package
    to quickly and easily construct a microservice that uses HTTP and **representational
    state transfer**, (**REST**), to provide its interface. We're also going to look
    at using the nameko package to create microservices that communicate using remote
    procedure calls instead of HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices and the advantages of process isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building high-level microservices with Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building high-level microservices with nameko
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices and the advantages of process isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at microservices from a conceptual perspective.
    When we need a new feature for a project, there's a temptation to just add it
    to the project's main program and continue on from there. Sometimes, that's entirely
    appropriate, but in many cases, it's actually better to make the feature a distinct
    program in its own right.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the microservice architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several reasons why a feature might be better off when less tightly
    integrated into the system. The most important ones are **flexibility**, **scalability**,
    and **durability**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the flexibility benefit is easy. Modular programs inherently consist
    of a bunch of modules that we can reuse in the future. So, every time we write
    our code as an independent module with a well-defined interface, we're making
    an investment that will make it easier to adapt to the changes that come in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: The scalability advantage comes into play when our modules are actually separate
    processes, allowing separate instances to be run on multiple processors, with
    the load balanced across them.
  prefs: []
  type: TYPE_NORMAL
- en: The durability advantage also comes into play when the modules are processes
    because processes are mostly safe from the bugs that crop up in other processes,
    also because a failed process can often be restarted without needing to take down
    the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the microservice architecture to web servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flexibility, scalability and durability are the same advantages that drove
    the development of microkernel operating systems back in the 1980s, but the term
    microservice (refer to following image) specifically refers to applying them to
    web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74e911f5-e824-4b73-8503-80081817c880.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This means that instead of writing one server program that handles all the logic
    of our web application, we'll write one or more servers that handle most of the
    frontend work and call on a bunch of different special-purpose servers to handle
    all the backend work and any remaining parts of the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Each special-purpose server should do a single well-defined job as well as possible
    and not care about anything. Those special-purpose servers are microservices,
    and using a microservice design gives us better uptime. Uptime lets us scale up
    to take advantage of a server farm or a cloud hosting system and helps us adapt
    to the ever-changing web more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: So, to recap, when our server is actually a collection of servers, each of which
    has a narrow and well-defined job to do, and does only that, we're using a microservice
    architecture. As an added benefit, the interfaces between our microservices constitute
    an application programming interface. So, if we get to a place where we want to
    expose an API for the world to use, all we have to do is adjust our authentication
    and authorization code, and possibly our routers, to allow external entities to
    access some of those interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Building high-level microservices with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we had a look at what a microservice is and why structuring our servers
    as collection of microservices is helpful. Now, let's take a look at the practicalities
    and use Flask to construct a functioning microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices can be pretty easily divided into those that use web technologies,
    such as HTTP, to communicate with each other and those that use a dedicated inter-process
    communication or a remote-procedure-called mechanism to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: There are advantages to each, depending on the specific needs of a project and
    neither is inherently easier to work with. However, I'm going to refer to microservices
    that use web technologies to communicate as *high level* because they are inherently
    closer to the level at which users operate. Conversely, I'll refer to microservices
    that use specialized protocols as *low level*. In this section, we'll look at
    high-level microservices, which usually use HTTP to communicate and provide REST-based
    programming interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Using stateless protocols for communication makes these microservices easy to
    load balance and easy to swap in and out for maintenance. For this type of microservice,
    we can use any of Python's several production quality web application frameworks
    or toolkits, but we're going to use Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is laser-focused on making it easy to write handlers for HTTP requests
    and doesn't really do anything else. That makes it very well-suited for writing
    a microservice that processes a few specific requests while using minimal resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask isn''t part of a Python standard library, but it''s easily installed
    using `pip`, as shown in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As always, you can add `--user` to the command to install Flask into your personal
    Python package library, or you can install it into a virtual environment if you
    prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating endpoints for a RESTful API in Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask is designed to interface with a frontend web server or proxy using the
    **Web Server Gateway Interface** (**WSGI**), which is standard for Python web
    applications. However, we'll just use its built-in development server for our
    simple little demonstration. So, what shall we build?
  prefs: []
  type: TYPE_NORMAL
- en: Building a microservice to maintain a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build a microservice that maintains a database of information about people-first
    name, last name, age, and for interest's sake, whether or not they are members
    of a particular club.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the `POST`, `GET`, `PUT`, and `DELETE` methods of HTTP to allow the
    clients of the microservice to create, access, update, and remove records from
    the database. Also, we'll provide the data in JSON format, but accept the input
    using the normal HTTP form encoding.
  prefs: []
  type: TYPE_NORMAL
- en: These choices are all very normal. The only, slightly-less-common choice would
    be to have incoming data in JSON format as well, which we accommodate by calling
    the `request.get_json` function of Flask when we need the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, which boilerplate code do we need to get a Flask microservice on its feet?
    Not much, as it turns out. The following two command lines are sufficient to get
    the Flask system in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These lines don't actually do anything except return *404 Not Found* errors
    in response to any request, but they'll respond. So, how do we make Flask handle
    a request? Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Making Flask handle a request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are actually two ways to make Flask handle a request: one way is incredibly
    simple and the other is more flexible and better encapsulated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simpler way is to use the `@app.route` decorator to tell Flask that a particular
    function will handle requests for a given path, as shown in the following code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's all that's needed, apart from making the function actually do something
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for our microservice, we want to use HTTP methods on the same path
    to produce different results. We can use an `app.route` decorator and a bunch
    of `if` and `else if` blocks in the function to handle that, but there''s a better
    way, which is explained using the following code example and that you can find
    in the `endpoint.py` file in the download pack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b9ccad3-130f-4a89-8118-77ef0d2ada4a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Flask supports pluggable view classes and specifically has a `MethodView` class
    that has a different handler function for each HTTP method, as you can see in
    the first four function definitions in our class. The appropriate function processes
    each request based on which HTTP method was used.
  prefs: []
  type: TYPE_NORMAL
- en: There's a slight complication to this because we don't actually always want
    to use the same path. Sometimes, we want an object `id` in the path and sometimes
    we don't. This is only a small complication though, because we can register the
    same pluggable view on several different combinations of path and method, which
    is exactly what the `endpoint.register` function in `endpoint.py` does, as you
    can see in the code example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each registration of `view` consists of one call to `app.add_url_rule`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one registers the `GET` method with no object `id` and fills in values
    to use for the `id` parameter when calling the `GET` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one registers the `POST` method with no `id` and no default because
    our `POST` function doesn't accept an `id` parameter at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third one registers the `GET`, `PUT`, and `DELETE` methods when there is
    an `id` parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These registrations cover all the use cases common to a single programming interface
    endpoint in REST.
  prefs: []
  type: TYPE_NORMAL
- en: Running and connecting to our microservice using Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our method dispatching ready, how about we put together our
    actual handlers for manipulating person objects? We can do it using the following
    code found in the `service.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/166cafd1-dcad-4d22-a525-457023618911.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the detailed code, please refer to the code files.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding code example, we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We see our `PersonAPI` class, which has one function for each of the operations
    we want to enable on our `person` database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `POST` and `PUT` functions, we get data from the request using the `request.form`
    object, which is a dictionary-like object containing the decoded data from the
    request body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This looks like it's not thread-safe, but it actually is. Everything in Flask
    is multithread and multiprocess safe; it's just wrapped in a simplifying semantic
    layer that simulates a single-threaded single-process system.
  prefs: []
  type: TYPE_NORMAL
- en: The `POST` function doesn't have any code to handle missing data, except for
    the member value. This is because if we try to access a missing value from `request.form`,
    an exception is raised that causes Flask to return a *400 Bad Request* error,
    which is exactly the right thing to do in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PUT` function, on the other hand, handles those exceptions itself, so that
    it can decide which values to update and which to leave alone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GET` function might be called with an integer `id` or with `None` for the
    `id` parameter and needs to handle both cases. This is easily done with an `if`
    statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case where the `id` parameter is a number, the `GET` function is supposed
    to return the state of the object with that `id` parameter. If `id` is `None`,
    it is supposed to return a list of all of the objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the methods return JSON-formatted data, which is done using Python's standard
    `json` package and specifically the `json.dumps` function, which transforms Python
    data structures into JSON-formatted strings.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to provide the content type header with the value of application
    JSON as a matter of good practice. Between these two things in the return statement,
    we're also providing the HTTP status. This could be omitted, but since we're returning
    error codes in some places, it makes sense to include the status code even when
    it's not an error.
  prefs: []
  type: TYPE_NORMAL
- en: Test running the microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do a test run of our microservice, we need to start up Flask (using the
    following command) and tell it to serve our microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Unix/Linux and macOS, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `demo_flask` package also contains a module called `test.py` that we can
    use as a client that connects to our microservice and put it through its paces.
    It will add, delete, list, and modify a couple of database entries and also try
    out a bad post request to show that the error handling is working.
  prefs: []
  type: TYPE_NORMAL
- en: There's one more part of the Flask demo microservice that we haven't talked
    about and won't in detail. That is the `person.py` file, which contains a simple
    interface with a SQLite3 database for actually storing and retrieving objects.
    Feel free to look at it, of course, but it's not particularly relevant to the
    topics of the chapter, and a production system should probably use SQLAlchemy,
    Redis, CouchDB, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Building high-level microservices with nameko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take a look at **nameko**, which will help us put together
    a microservice that communicates using the **Advanced Message Queuing Protocol**
    (**AMQP**), which we can safely think of as a **Remote Procedure Call** (**RPC**)
    protocol, though that's actually only a part of what it does.
  prefs: []
  type: TYPE_NORMAL
- en: Installing nameko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using HTTP to define the interface for our microservice has the advantages of
    familiarity and good integration with web technologies, but there's a certain
    amount of overhead involved in mapping the request and input data onto the functions
    and parameters that are actually meaningful to us.
  prefs: []
  type: TYPE_NORMAL
- en: We can come up with abstractions that hide that part of the process, of course.
    That's essentially what the authors of nameko did, although they use AMQP instead
    of HTTP to transport data and events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing nameko itself is easy. Use pretty much the same `pip` command we
    always use, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62ac1754-7bc5-4178-8d09-9ff6508c9216.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Be aware though that nameko won't actually work until we install some other
    software as well. More on that is covered in the *Things to know before using
    nameko* section.
  prefs: []
  type: TYPE_NORMAL
- en: Running and connecting a microservice using nameko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking at the nameko version of our `person` service, it''s clear that the
    effort paid off. Our service is defined by a class with the `name` attribute and
    several member functions decorated with `RPC`, as shown in the following code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5524cd49-ae11-44bc-b14d-be71ea350057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The member functions interface with the same database interface class we used
    in the previous section. In a very straightforward way, it would even be reasonable
    to combine the two into one class, and that's it-the complete definition of our
    microservice using nameko. Pretty sweet, right? It really is, but every cloud
    has a silver lining, as we'll soon see.
  prefs: []
  type: TYPE_NORMAL
- en: Things to know before using nameko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nameko is great, but there are things we need to be aware of before we choose
    nameko or any similar tool.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to be aware of is that nameko doesn't provide the complete AMQP
    infrastructure, it just connects to it.
  prefs: []
  type: TYPE_NORMAL
- en: The AMQP infrastructure is responsible for conveying messages between connected
    programs in a way that is quick and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we need an AMQP server running somewhere that nameko can find
    it and an AMQP server accessible to the microservice's users, and those servers
    need to be connected to each other.
  prefs: []
  type: TYPE_NORMAL
- en: They could be the same server, of course, but they don't have to be. Nameko
    recommends the RabbitMQ AMQP server, which can be downloaded from its own website
    ([www.rabbitmq.com](http://www.rabbitmq.com)). The installation is relatively
    uncomplicated and there are detailed instructions on the site.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with our microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an AMQP server installed and running, can we connect or service
    and manipulate person objects? Technically yes, but we need to use nameko to write
    the client too.
  prefs: []
  type: TYPE_NORMAL
- en: AMQP isn't as simple to work with as HTTP, and the RPC mechanism adds an additional
    layer of complexity. We don't want to work with that raw.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to interact with our microservice. Let's examine them in
    a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with a microservice manually using the nameko shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first way we can interact with our microservice is manually using the nameko
    shell, which is an enhanced Python shell. First, we have to run the microservice,
    which we''ll do in its own command window, running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll start the `nameko` shell and use the end `RPC` object to access
    the functions of our microservice, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3af9b037-72e6-4ed9-95bc-8464fcfa3921.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, it looks like we're just calling the functions, but actually we're communicating
    with the microservice through the AMQP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with a microservice by creating another microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second way we can interact with our microservice is to create another microservice
    that depends on it, as shown in the following code example found in the `test.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94de294f-8a56-4753-99a0-8b2b4c8c2beb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `TestService` class periodically exercises the `person`service. It also
    demonstrates how to link one service to another, so that one of them is able to
    access the other. The key is this line, which creates an `RpcProxy` instance on
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the service runs, it''s able to access the functions of the specified
    remote service through that object. To run our tests, we need to start both the
    `person` microservice and the `test` microservice, which we can do with a single
    command, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that we return the object `id` from the `create` function,
    rather than create a `person` object itself. That's because we can't return the
    `person` object.
  prefs: []
  type: TYPE_NORMAL
- en: Nameko functions can return any data that can be represented as JSON, but that
    doesn't include instances of arbitrary classes. The same goes for parameters that
    are passed into the functions of a microservice; they need to be within the limits
    of JSON.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't actually a more stringent restriction than what we saw in the Flask
    microservice (in the previous section). It's just that with Flask it was obvious
    we were sending data across the network in JSON format, so that limitation was
    obvious. With nameko, the requirement is the same, but the reason for it is easier
    to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of the chapter, we looked at what microservices are philosophically
    and what their advantages are, and implemented an HTTP-oriented microservice using
    Flask.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at some of the advantages of process-based modularity and saw
    how applying those principles to web applications results in a microservice architecture.
    We looked at the details needed to use Flask to create a RESTful microservice
    and put that knowledge to use by building a simple person management microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at using nameko's RPC mechanism to implement a microservice,
    which simplifies the code significantly, at the cost of requiring that we set
    up an AMQP infrastructure and a more difficult interface with systems outside
    the AMQP network.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how to interface between Python and compiled
    code to optimize performance bottlenecks in our code and access libraries written
    in other programming languages.
  prefs: []
  type: TYPE_NORMAL
