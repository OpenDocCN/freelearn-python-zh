- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Publishing TFs and Packaging the URDF
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布TFs和打包URDF
- en: So far, in *Part 3* of this book, you’ve had an introduction to TFs and have
    learned how to write a URDF, which will be used to generate the TFs for your robotics
    application. There are now two things we need to do to go further.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书的**第3部分**中，你已经对TFs进行了介绍，并学习了如何编写URDF，这将用于生成你的机器人应用程序的TFs。现在我们需要做两件事来进一步学习。
- en: 'First, to be quicker, we have used the **urdf_tutorial** package to publish
    the TFs. This is great to get started and visualize the robot model, but we won’t
    use this package in a real application. The question is this then: Using the URDF
    we have created, how do we generate the TFs for our application? What nodes do
    we need to start? We will first understand, through experimentation, what nodes
    and parameters we need to start to correctly generate the TFs for our application.
    From this, we will be able to create our own launch file.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了更快，我们使用了**urdf_tutorial**包来发布TFs。这对于开始和可视化机器人模型来说很棒，但我们在实际应用中不会使用这个包。问题是：使用我们创建的URDF，我们如何为我们的应用程序生成TFs？我们需要启动哪些节点？我们将首先通过实验了解我们需要启动哪些节点和参数，以便正确地为我们的应用程序生成TFs。从这一点出发，我们将能够创建我们自己的启动文件。
- en: Second, the URDF is now a series of three Xacro files placed inside the home
    directory. To start a proper ROS 2 application, we will create a package to organize
    and install the URDF, the launch file, and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，URDF现在是一系列三个Xacro文件，放置在主目录中。为了启动一个合适的ROS 2应用程序，我们将创建一个包来组织和安装URDF、启动文件等。
- en: By the end of this chapter, you will be able to correctly package your URDF
    and publish the TFs for a ROS 2 application. This process is the same for any
    robot, and this package you create here will be the base for any further development,
    including the Gazebo simulation that we will cover later in this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够正确地打包你的URDF并发布ROS 2应用程序的TFs。这个过程适用于任何机器人，你在这里创建的包将成为任何进一步开发的基础，包括本书后面将要介绍的Gazebo仿真。
- en: As a starting point for this chapter, we will use the code inside the **ch11**
    folder from the book’s GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
    You can find the final code in the **ch12** folder.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的起点，我们将使用书籍GitHub仓库中**ch11**文件夹内的代码([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))。你可以在**ch12**文件夹中找到最终代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding how to publish TFs with our URDF
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用我们的URDF发布TFs
- en: Starting all nodes from the terminal
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从终端启动所有节点
- en: Creating a package to install the URDF
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包来安装URDF
- en: Writing a launch file to publish TFs and visualize the robot
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个启动文件来发布TFs并可视化机器人
- en: Understanding how to publish TFs with our URDF
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何使用我们的URDF发布TFs
- en: We will start this chapter by understanding what nodes and parameters we need
    to start in order to publish the TFs for our application. Then, with this knowledge,
    we will be able to start the required nodes, package the application, and write
    a launch file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解我们需要启动哪些节点和参数，以便为我们的应用程序发布TFs。然后，有了这些知识，我们将能够启动所需的节点，打包应用程序，并编写一个启动文件。
- en: As we often did in this book, we will start with a discovery phase, through
    experimentation. I recommend that you run all the commands as you read the section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这本书中经常做的那样，我们将从一个发现阶段开始，通过实验。我建议你在阅读本节时运行所有命令。
- en: The robot_state_publisher node
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: robot_state_publisher节点
- en: 'Basically, in this chapter, we want to replicate what was done with the **urdf_tutorial**
    package so we can publish the TFs by ourselves. Let’s then start the **display.launch.py**
    launch file again, using the URDF from the previous chapter, and do some introspection:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在本章中，我们想要复制**urdf_tutorial**包中所做的工作，以便我们可以自己发布TFs。那么，让我们再次启动**display.launch.py**启动文件，使用上一章中的URDF，并进行一些自我检查：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a second terminal, start **rqt_graph** to visualize the nodes that are currently
    running. Refresh the view if the screen is empty. You will see something like
    this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个终端中，启动**rqt_graph**来可视化当前正在运行的节点。如果屏幕为空，请刷新视图。你会看到类似这样的内容：
- en: '![Figure 12.1 – Nodes running with urdf_tutorial](img/B22403_12_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 使用urdf_tutorial运行的节点](img/B22403_12_1.jpg)'
- en: Figure 12.1 – Nodes running with urdf_tutorial
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 使用urdf_tutorial运行的节点
- en: We see the **/tf** topic, which is the most important thing here. This is what’s
    needed for any ROS application to work properly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 **/tf** 主题，这是这里最重要的东西。这是任何 ROS 应用程序正常工作所必需的。
- en: Now, what is publishing on the **/tf** topic? As you can see, there is a node
    called **/robot_state_publisher** (in the text, we will write **robot_state_publisher**,
    without the leading slash). Where does this node come from? **robot_state_publisher**
    is a core node already available for you to use. It is a part of the collection
    of packages that you installed with ROS 2\. This node will publish the TFs for
    your robot. You will start it in any ROS 2 application where you need TFs. Most
    of the time, you won’t have to publish any TF by yourself, as this will be handled
    by the **robot_state_publisher** node.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**/tf** 主题上发布了什么内容？正如你所见，有一个名为 **/robot_state_publisher**（在文本中，我们将写作 **robot_state_publisher**，不带前面的斜杠）。这个节点从哪里来？**robot_state_publisher**
    是一个已经为你准备好的核心节点，你可以使用它。它是你用 ROS 2 安装的软件包集合的一部分。这个节点将发布你机器人的 TFs。你将在任何需要 TFs 的
    ROS 2 应用程序中启动它。大多数时候，你不需要自己发布任何 TF，因为这将由 **robot_state_publisher** 节点处理。
- en: Now that we know we have to start this node, what inputs are required?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们必须启动这个节点，需要哪些输入？
- en: Inputs for the robot_state_publisher
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: robot_state_publisher 的输入
- en: 'There are two things you need to provide for the **robot_state_publisher**
    node to work correctly: URDF and joint states. Let’s start with the first one.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 **robot_state_publisher** 节点正确工作，你需要提供两样东西：URDF 和关节状态。让我们从第一样开始。
- en: URDF as a parameter
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URDF 作为参数
- en: 'At this point, you might wonder: Where did the URDF go? We just saw some nodes
    and topics on **rqt_graph**, but we didn’t see the use of the URDF we created.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道：URDF 去哪里了？我们在 **rqt_graph** 中看到了一些节点和主题，但我们没有看到我们创建的 URDF 的使用。
- en: 'Keep **display.launch.py** from **urdf_tutorial** running, and in another terminal,
    list all parameters for the **robot_state_publisher** node:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 **urdf_tutorial** 中的 **display.launch.py** 运行，并在另一个终端中列出 **robot_state_publisher**
    节点的所有参数：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see quite a few, but the one that we care about here is named **robot_description**.
    Then, you can read the value from this parameter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到很多主题，但我们这里关心的是名为 **robot_description** 的主题。然后，你可以从这个参数中读取值：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this, you will see the entire URDF in the terminal (or more precisely,
    the generated URDF from the Xacro file you have provided).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你将在终端中看到整个 URDF（或者更准确地说，从你提供的 Xacro 文件生成的 URDF）。
- en: So, when you start the **robot_state_publisher** node, you will need to give
    the URDF inside a parameter named **robot_description**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你启动 **robot_state_publisher** 节点时，你需要提供一个名为 **robot_description** 的参数内的
    URDF。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In `rqt_graph`, you can see that the `robot_state_publisher` is publishing on
    the `/robot_description` topic. The message you get from this topic also contains
    the URDF content. This can be useful to retrieve the URDF from any other node,
    using a subscriber.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `rqt_graph` 中，你可以看到 `robot_state_publisher` 正在发布到 `/robot_description` 主题。从这个主题获得的消息也包含了
    URDF 内容。这可以用来从任何其他节点检索 URDF，使用订阅者。
- en: That’s it for the first input; let’s see the second one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第一个输入的全部内容；让我们看看第二个。
- en: Joint states topic
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关节状态主题
- en: In order to publish the TFs, the **robot_state_publisher** node will need the
    URDF, but also the current state for each joint.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布 TFs，**robot_state_publisher** 节点需要 URDF，但也需要每个关节的当前状态。
- en: You can see the **/joint_states** topic in **rqt_graph** in *Figure 12**.1*.
    This topic contains what you would read from encoders or control feedback in a
    real robot. For example, if you have some wheels, you will get to know the speed
    and/or position of those wheels. You will feed this into the **/joint_states**
    topic. If you have a robotic arm, you usually have encoders on each axis reading
    the current position for the axis.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 **rqt_graph** 中看到 **/joint_states** 主题，如图 **12**.1 所示。这个主题包含了你在真实机器人中从编码器或控制反馈中读取的内容。例如，如果你有一些轮子，你会知道这些轮子的速度和/或位置。你将把这些信息喂入
    **/joint_states** 主题。如果你有一个机械臂，你通常在每个轴上都有编码器来读取轴的当前位置。
- en: When we simulate the robot with Gazebo, we will use a plugin that automatically
    publishes the joint states. In fact, either in simulation mode or for a real robot,
    you will usually have nodes doing this for you (to go further on this, check out
    ros2_control after reading this book—you can find extra resources about that in
    the last chapter of this book). So, all you need to know is that this **/joint_states**
    topic is important, as it’s required by **robot_state_publisher**. Publishing
    on this topic is done by existing ROS 2 plugins.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Gazebo 模拟机器人时，我们将使用一个插件来自动发布关节状态。实际上，无论是在模拟模式还是对于真实机器人，你通常都会有节点为你做这件事（要进一步了解这一点，阅读完这本书后请查看
    ros2_control——你可以在本书的最后一章找到关于它的额外资源）。所以，你需要知道的是，这个 **/joint_states** 主题非常重要，因为它被
    **robot_state_publisher** 所需要。在这个主题上的发布是由现有的 ROS 2 插件完成的。
- en: For now, as we don’t have any real robot or Gazebo simulation, we will use the
    **joint_state_publisher** node (with the **Joint State Publisher** window), which
    will publish whatever values we select on the cursors. For example, if you select
    **1.0** radian for **base_right_wheel_joint**, then **1.0** will be published
    on the **/joint_states** topic for that joint and will be received and used by
    **robot_state_publisher**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，因为我们没有真实的机器人或 Gazebo 模拟，我们将使用 **joint_state_publisher** 节点（带有 **Joint State
    Publisher** 窗口），它将发布我们在光标上选择的任何值。例如，如果你为 **base_right_wheel_joint** 选择 **1.0**
    弧度，那么 **1.0** 将被发布在该关节的 **/joint_states** 主题上，并被 **robot_state_publisher** 接收和使用。
- en: 'Here, it’s important to clarify the difference between joint states and TFs.
    A joint state is simply the *current state* of a joint. For example, for a wheel:
    what is the current velocity? For an axis in a robotic arm: what is the current
    angular position of the motor? The state is one data point, at one specific time,
    for one joint in your robot. It doesn’t specify anything about the relationship
    between joints, nor where they are located relative to each other—this is what
    a TF is.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，重要的是要明确关节状态和 TF 之间的区别。关节状态仅仅是关节的 *当前状态*。例如，对于一个轮子：当前的速率是多少？对于一个机械臂的轴：电机的当前角位置是多少？状态是一个数据点，在特定时间，对于你机器人中的一个关节。它不指定关节之间的关系，也不指定它们相对于彼此的位置——这就是
    TF 的作用。
- en: Recap – how to publish TFs
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾 – 如何发布 TF
- en: Let’s do a quick recap of what is required to publish TFs. This is what **urdf_tutorial**
    was doing for us, and what we will be doing by ourselves from now on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下发布 TF 所需的内容。这是 **urdf_tutorial** 为我们做的事情，也是从现在起我们将自己做的事情。
- en: '![Figure 12.2 – The required node and inputs to publish TFs](img/B22403_12_2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 发布 TF 所需的节点和输入](img/B22403_12_2.jpg)'
- en: Figure 12.2 – The required node and inputs to publish TFs
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 发布 TF 所需的节点和输入
- en: 'Here is what we need to do:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要做的事情：
- en: Start the `robot_state_publisher` node. This node is already installed. We give
    the URDF as the `robot_description` parameter.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `robot_state_publisher` 节点。这个节点已经安装好了。我们提供 URDF 作为 `robot_description` 参数。
- en: Publish the current state for all joints on the `/joint_states` topic. This
    is usually done automatically for you, either with data from encoders, a simulator
    such as Gazebo, or *fake* data from the `joint_state_publisher` node.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/joint_states` 主题上发布所有关节的当前状态。这通常由编码器、模拟器（如 Gazebo）或来自 `joint_state_publisher`
    节点的 *虚假* 数据自动为你完成。
- en: That’s all you have to do to correctly publish the TFs for your application.
    Those TFs will then be used by other nodes, plugins, and stacks, for example,
    the Navigation 2 or MoveIt 2 stacks (we won’t cover those in this book, but they
    would be a good topic to study afterward—more resources will be given in the last
    chapter of this book).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你正确发布应用程序 TF 所需要做的所有事情。这些 TF 将随后被其他节点、插件和堆栈使用，例如，Navigation 2 或 MoveIt 2
    堆栈（我们不会在本书中涵盖这些，但它们是之后一个好的学习主题——本书最后一章将提供更多资源）。
- en: Starting all nodes from the terminal
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从终端启动所有节点
- en: Before we package the application and write a launch file, let’s start all the
    nodes we need in the terminal. Doing this is a best practice so that you can make
    sure your application is working properly. Then, creating the package and the
    launch file will be easier, as you already know all the elements you need to include.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打包应用程序并编写启动文件之前，让我们在终端中启动所有需要的节点。这样做是一个最佳实践，这样你可以确保你的应用程序运行正常。然后，创建包和启动文件会更容易，因为你已经知道你需要包含的所有元素。
- en: We will use the result from the previous section and start the **robot_state_publisher**
    node, as well as the **joint_state_publisher** node. In addition to that, we will
    start RViz (this is optional and only used to visualize the robot model).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一节的结果并启动 **robot_state_publisher** 节点以及 **joint_state_publisher** 节点。除此之外，我们还将启动
    RViz（这是可选的，仅用于可视化机器人模型）。
- en: Publishing the TFs from the terminal
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从终端发布 TFs
- en: Let’s publish the TFs. For that, we will open two terminals.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发布 TFs。为此，我们将打开两个终端。
- en: 'In the first one, start the **robot_state_publisher** node. The package and
    executable names for this node are identical. To provide the **robot_description**
    parameter, you will have to use this syntax: **"$(****xacro <path_to_urdf>)"**.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个步骤中，启动 **robot_state_publisher** 节点。此节点的包和可执行文件名相同。要提供 **robot_description**
    参数，你必须使用以下语法：**"$(****xacro <path_to_urdf>)"**。
- en: 'In Terminal 1, run the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 1 中，运行以下命令：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you see this, everything is working fine. **robot_state_publisher** has been
    started with the URDF, and it’s ready to publish on the **/tf** topic. Now, we
    need to add a publisher on the **/joint_states** topic. We will use the **joint_state_publisher_gui**
    executable from the same package (note the extra **_gui** suffix, which means
    **graphical** **user interface**).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个，那么一切正常。**robot_state_publisher** 已经启动了 URDF，并且它已准备好在 **/tf** 主题上发布。现在，我们需要在
    **/joint_states** 主题上添加一个发布者。我们将使用来自同一包的 **joint_state_publisher_gui** 可执行文件（注意额外的
    **_gui** 后缀，表示 **图形** **用户界面**）。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a reminder, the executable name and node name are two different things. The
    executable name is the one you define in `setup.py` (for Python) or `CMakeLists.txt`
    (for C++). The node name is defined in the code and can be different. Here, we
    start the `joint_state_publisher_gui` executable, but the node name is `joint_state_publisher`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：可执行文件名和节点名是两回事。可执行文件名是在 `setup.py`（对于 Python）或 `CMakeLists.txt`（对于 C++）中定义的。节点名在代码中定义，可能不同。在这里，我们启动了
    `joint_state_publisher_gui` 可执行文件，但节点名是 `joint_state_publisher`。
- en: 'In Terminal 2, run the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 2 中，运行以下命令：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will open the **Joint State Publisher** window that we previously used
    when experimenting with TFs and URDF. The values you see on the cursors will be
    published on the **/joint_states** topic and will be received by **robot_state_publisher**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开我们之前在实验 TFs 和 URDF 时使用的 **Joint State Publisher** 窗口。你将在光标上看到的值将被发布到 **/joint_states**
    主题，并由 **robot_state_publisher** 接收。
- en: That’s basically all we need. This will become the backbone of your ROS 2 application—of
    course, we will need to package this nicely and start it from a launch file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是我们需要做的。这将成为你的 ROS 2 应用程序的核心——当然，我们还需要将其打包并从启动文件中启动。
- en: If you run **rqt_graph**, you will see the same nodes and topics as in *Figure
    12**.1*. You can also print the TF tree (**ros2 run tf2_tools view_frames**) and
    listen to the **/tf** topic in the terminal (**ros2 topic** **echo /tf**).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 **rqt_graph**，你将看到与 *图 12.1* 中相同的节点和主题。你还可以打印 TF 树（**ros2 run tf2_tools
    view_frames**）并监听终端中的 **/tf** 主题（**ros2 topic echo /tf**）。
- en: Visualizing the robot model in RViz
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 RViz 中可视化机器人模型
- en: On top of what we did, we can visualize the robot in RViz. This is optional,
    and it’s something you will do mostly when you develop your application. After
    everything is working correctly and you switch to production mode, you won’t need
    to start RViz.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前所做的基础上，我们可以在 RViz 中可视化机器人。这是可选的，你将在开发应用程序时主要做这件事。当一切正常并且你切换到生产模式后，你将不需要启动
    RViz。
- en: Starting and configuring RViz
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动和配置 RViz
- en: Let’s start RViz and see how to visualize the robot model as well as the TFs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 RViz 并看看如何可视化机器人模型以及 TFs。
- en: 'Keep the **robot_state_publisher** and **joint_state_publisher** nodes running.
    Then, in Terminal 3, run the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 **robot_state_publisher** 和 **joint_state_publisher** 节点运行。然后，在终端 3 中，运行以下命令：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will open RViz, but, as you can see, there is no robot model, and we have
    some errors on the left menu:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 RViz，但正如你所看到的，没有机器人模型，左侧菜单中也有一些错误：
- en: '![Figure 12.3 – Rviz with no robot model and some errors](img/B22403_12_3.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – Rviz 没有机器人模型和一些错误](img/B22403_12_3.jpg)'
- en: Figure 12.3 – RViz with no robot model and some errors
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – RViz 没有机器人模型和一些错误
- en: We need to do a bit of configuration to correctly visualize the robot model
    and the TFs. Then, we will be able to save this configuration and reuse it the
    next time we start RViz.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些配置才能正确地可视化机器人模型和 TFs。然后，我们将能够保存此配置并在下次启动 RViz 时重用它。
- en: 'Follow these steps to configure RViz:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置 RViz：
- en: 'In the left menu, `map` to `base_footprint`. After that, `Global Status: Error`
    should change to `Global` `Status: OK`.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，将 `map` 滚动到 `base_footprint`。之后，`全局状态：错误` 应该更改为 `全局` `状态：OK`。
- en: Click on the **Add** button on the left, scroll down, and double-click on **RobotModel**.
    You will have a new menu on the left side of RViz.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧单击 **添加** 按钮，向下滚动，然后双击 **RobotModel**。你将在 RViz 的左侧出现一个新菜单。
- en: Open this new `/robot_description`. After this, the robot model should appear
    on the screen.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个新的 `/robot_description`。之后，机器人模型应该出现在屏幕上。
- en: Click on the **Add** button again, scroll down, and double-click on **TF**.
    This will open a new menu, and you will see the TFs appear on the screen.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击 **添加** 按钮，向下滚动，然后双击 **TF**。这将打开一个新菜单，你将在屏幕上看到 TFs。
- en: If you want to see through the model, like we did before, open `1` to `0.8,`
    for example.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要像之前一样透过模型查看，可以将 `1` 更改为 `0.8`，例如。
- en: You can remove the extra menus on the right (**Views**) and at the bottom (**Time**)
    to get more space for the robot.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以移除右侧的额外菜单（**视图**）和底部的菜单（**时间**），以便为机器人腾出更多空间。
- en: 'With all those settings, you should see the robot model and TFs the same way
    we did when we previously visualized the URDF with the **urdf_tutorial** package:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些设置下，你应该会看到机器人模型和 TFs，就像我们之前使用 **urdf_tutorial** 包可视化 URDF 时的样子：
- en: "![Figure 12.4 – RViz with the robo\uFEFFt model and TFs](img/B22403_12_4.jpg)"
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 带有机器人模型和 TFs 的 RViz](img/B22403_12_4.jpg)'
- en: Figure 12.4 – RViz with the robot model and TFs
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 带有机器人模型和 TFs 的 RViz
- en: Saving the RViz configuration
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存 RViz 配置
- en: You will need to repeat those steps every time you start RViz. To avoid doing
    this, we will save the configuration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你启动 RViz 时，你都需要重复这些步骤。为了避免这样做，我们将保存配置。
- en: Click on **File** | **Save Config As**. Let’s name the file **urdf_config.rviz**
    (for these files, use the **.rviz** extension), and place it inside your home
    directory for now.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 单击 **文件** | **另存为配置**。让我们将文件命名为 **urdf_config.rviz**（对于这些文件，使用 **.rviz** 扩展名），并将其暂时放置在你的家目录中。
- en: Make sure you can see the file, using a file manager or the terminal. If you
    didn’t save the file correctly, you will need to manually do the full configuration
    again. Once the file is saved, you can stop RViz (*Ctrl + C* in the terminal).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你可以看到文件，使用文件管理器或终端。如果你没有正确保存文件，你需要手动重新进行完整配置。一旦文件保存，你就可以停止 RViz（在终端中按 *Ctrl
    + C*）。
- en: 'Then, when you start RViz again, you can add an extra **-d** argument with
    the path to the configuration file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你再次启动 RViz 时，你可以添加一个额外的 **-d** 参数，并指定配置文件的路径：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will start RViz exactly like you saved it: same menus, same view, same
    zoom, and so on. We will reuse this configuration file throughout this chapter.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动 RViz，就像你保存的那样：相同的菜单，相同的视图，相同的缩放，等等。我们将在本章中重复使用此配置文件。
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you wish to change the configuration, all you have to do is modify whichever
    settings you want in RViz, save a new configuration file, and use this one instead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望更改配置，你只需要在 RViz 中修改你想要的任何设置，保存一个新的配置文件，并使用这个文件。
- en: 'We now have everything we need: the URDF files and the RViz config file, and
    we know what nodes and parameters we have to start, and how to start them.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有所需的一切：URDF 文件和 RViz 配置文件，我们知道必须启动哪些节点以及如何启动它们。
- en: Let’s now organize everything properly into a ROS 2 package. We will first create
    the package, and then add a launch file to start all the nodes at once.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在将所有内容正确地组织到一个 ROS 2 包中。我们首先创建包，然后添加一个启动文件以一次性启动所有节点。
- en: Creating a package to install the URDF
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个包来安装 URDF
- en: All the files we have created are now in our home directory. It’s time to create
    a ROS 2 package and move all the files into the right place so that they can be
    installed and used in our ROS 2 workspace.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的所有文件现在都在我们的家目录中。是时候创建一个 ROS 2 包并将所有文件移动到正确的位置，以便它们可以在我们的 ROS 2 工作空间中安装和使用。
- en: We will start by creating a package dedicated to the robot model. Then, we will
    install all the files required for this application. This will allow us to use
    the URDF and RViz files when we write a launch file, to start all the nodes we
    have seen previously.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个专门用于机器人模型的包。然后，我们将安装此应用程序所需的所有文件。这将允许我们在编写启动文件时使用 URDF 和 RViz 文件，以启动我们之前看到的所有节点。
- en: Let’s create a new package, but before we do that, it could be a good idea to
    create a new ROS 2 workspace.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的包，但在我们这样做之前，创建一个新的 ROS 2 工作空间可能是个好主意。
- en: Adding a new workspace
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个新的工作空间
- en: As of now, our **ros2_ws** workspace contains all the code used in *Part 2*
    of this book, including various examples to illustrate the core concepts, a robot
    controller for the Turtlesim, some custom interfaces, and launch files. We don’t
    need any of those for the *Part 3* project; so, instead of continuing to add more
    things to this workspace, we will create a new one. As a general rule, if you
    have two different applications, you will have two different workspaces.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 **ros2_ws** 工作区包含了本书 *第2部分* 中使用的所有代码，包括各种示例来阐述核心概念，Turtlesim 的机器人控制器，一些自定义接口和启动文件。对于
    *第3部分* 项目，我们不需要这些；因此，我们不会继续向这个工作区添加更多内容，而是创建一个新的工作区。作为一个一般规则，如果你有两个不同的应用程序，你将有两个不同的工作区。
- en: Let’s then create a new workspace named **my_robot_ws**. A good practice is
    to name the workspace as per your application or robot name. This will help you
    avoid confusion in the long term.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为 **my_robot_ws** 的新工作区。一个好的做法是将工作区命名为你的应用程序或机器人名称。这将在长期内帮助你避免混淆。
- en: 'Create a new workspace in your home directory:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的家目录中创建一个新的工作区：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, inside this workspace, create a **src** directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这个工作区内部创建一个 **src** 目录：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, and this is super important, you can have as many ROS 2 workspaces as you
    want, but you should not work with two workspaces for two different applications
    at the same time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，并且这非常重要，你可以拥有任意多的 ROS 2 工作区，但你不应该同时使用两个不同应用程序的工作区。
- en: 'You are currently sourcing the **ros2_ws** workspace every time you open a
    terminal. If you remember, you added an extra line in **.bashrc** to do that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你目前每次打开终端时都在源化 **ros2_ws** 工作区。如果你记得，你在 **.bashrc** 中添加了一行额外的代码来做这件事：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open the **.bashrc** file again and comment that line (add **#** in front of
    the line). Now, close all terminals, open a new one, and let’s build and source
    our new workspace:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开 **.bashrc** 文件并注释掉那一行（在行前添加 **#**）。现在，关闭所有终端，打开一个新的终端，然后构建并源化我们的新工作区：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the **.bashrc** again and add a line to source this new workspace. The
    end of **.bashrc** will look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开 **.bashrc** 并添加一行来源化这个新的工作区。**.bashrc** 的末尾将看起来像这样：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As a reminder, we first source the global ROS 2 installation. Then, we source
    our workspace. Commenting the workspaces you don’t use is very practical. This
    way, if you want to switch between two workspaces, you just have to uncomment/comment
    the two lines, close all terminals, and open a new terminal to source the workspace
    you want to use.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我们首先源化全局 ROS 2 安装。然后，我们源化我们的工作区。注释掉不使用的工作区是非常实用的。这样，如果你想在这两个工作区之间切换，你只需要取消注释/注释这两行，关闭所有终端，然后打开一个新的终端来源化你想要使用的工作区。
- en: Creating a _description package
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 _description 包
- en: Now that we have this new empty workspace correctly configured and sourced,
    let’s add a new package inside.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确配置并源化了这个新的空工作区，让我们在里面添加一个新的包。
- en: To name the package, we use the robot’s name, followed by **_description**.
    This is a common convention used by lots of ROS developers. By using this naming
    format, you make it clear that this package will contain the URDF files for your
    robot. This will make collaboration easier.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了命名包，我们使用机器人的名称，后面跟着 **_description**。这是许多 ROS 开发者使用的一个常见约定。通过使用这种命名格式，你可以清楚地知道这个包将包含你的机器人的
    URDF 文件。这将使协作变得更加容易。
- en: 'To create this new package, we use the **ament_cmake** build type, just as
    if we were creating a C++ package, and we don’t specify any dependencies. Let’s
    create the package:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个新包，我们使用 **ament_cmake** 构建类型，就像我们创建一个 C++ 包一样，并且我们不指定任何依赖项。让我们创建这个包：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For now, this package is a standard C++ ROS 2 package. However, we won’t write
    any nodes inside. We just need the package to install our robot model. Thus, you
    can remove the **src** and **include** directories:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个包是一个标准的 C++ ROS 2 包。然而，我们不会在其中编写任何节点。我们只需要这个包来安装我们的机器人模型。因此，你可以删除 **src**
    和 **include** 目录：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, your package will only contain two files: **package.xml** and
    **CMakeLists.txt**.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的包将只包含两个文件：**package.xml** 和 **CMakeLists.txt**。
- en: 'Open the workspace with an IDE. If you’re using VS code, run the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDE 打开工作区。如果你使用 VS code，运行以下命令：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To clean things a bit more, we will simplify the **CMakeLists.txt** file. Remove
    the comments after the **find_package(ament_cmake REQUIRED)** line, and, as we
    don’t need that now, remove the **if(BUILD_TESTING)** block. Make sure you keep
    the **ament_package()** instruction, which should be the last line of the file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加简洁，我们将简化 **CMakeLists.txt** 文件。删除 **find_package(ament_cmake REQUIRED)**
    行后面的注释，并且，因为我们现在不需要它，所以删除 **if(BUILD_TESTING)** 块。确保你保留 **ament_package()** 指令，它应该是文件的最后一行。
- en: Installing the URDF and other files
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 URDF 和其他文件
- en: 'Now that we have our **robot_description** package, let’s install all the files
    we need. To install a file, we will follow this process:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 **robot_description** 包，让我们安装我们需要的所有文件。要安装一个文件，我们将遵循以下过程：
- en: Create a folder to host the files.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件夹来存放文件。
- en: Add an instruction in `CMakeLists.txt` to install the folder.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CMakeLists.txt` 中添加一个指令来安装文件夹。
- en: Here, we will see how to install the URDF files, custom meshes, and the RViz
    configuration.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到如何安装 URDF 文件、自定义网格和 RViz 配置。
- en: Installing Xacro and URDF files
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Xacro 和 URDF 文件
- en: 'To install our Xacro and URDF files, go inside the **my_robot_description**
    package and create a new folder named **urdf**:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装我们的 Xacro 和 URDF 文件，请进入 **my_robot_description** 包并创建一个名为 **urdf** 的新文件夹：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can now move all three Xacro files inside this **urdf** folder: **common_properties.xacro,
    mobile_base.xacro**, and **my_robot.urdf.xacro**.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将所有三个 Xacro 文件放入这个 **urdf** 文件夹中：**common_properties.xacro, mobile_base.xacro**,
    和 **my_robot.urdf.xacro**。
- en: 'Everything should work fine, but to make the **include** paths more robust,
    let’s modify the **<xacro:include>** tags inside **my_robot.urdf.xacro**:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都应该正常工作，但为了使 **include** 路径更加健壮，让我们修改 **my_robot.urdf.xacro** 内的 **<xacro:include>**
    标签：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instead of providing only the relative path (which should still work in this
    case), we provide the absolute path to where the files will be installed, using
    the **find** keyword before the package name.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是只提供相对路径（在这种情况下仍然应该可以工作），我们使用包名前的 **find** 关键字提供文件的绝对路径，以安装文件。
- en: 'Now, open **CMakeLists.txt**, and add those instructions to install the **urdf**
    folder:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 **CMakeLists.txt**，并添加安装 **urdf** 文件的指令：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will install the **urdf** folder inside a **share** directory when you
    build the package. It will allow any package from the workspace to find the URDF
    for your robot. This is actually very similar to what we’ve done in [*Chapter
    9*](B22403_09.xhtml#_idTextAnchor443) when installing launch files and param files.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在构建包时在 **share** 目录内安装 **urdf** 文件夹。它将允许工作空间中的任何包找到你的机器人的 URDF。这实际上与我们之前在
    [*第9章*](B22403_09.xhtml#_idTextAnchor443) 安装启动文件和参数文件时所做的非常相似。
- en: Let’s now continue with custom meshes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论自定义网格。
- en: Installing custom meshes
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装自定义网格
- en: If you are not using any custom mesh for now (which is probably the case if
    you are learning ROS 2 from scratch with this book), you can skip this small section
    and go to the RViz configuration directly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在没有使用任何自定义网格（如果你是使用这本书从头开始学习 ROS 2，这可能是情况），你可以跳过这个小节，直接转到 RViz 配置。
- en: I briefly mentioned custom meshes in [*Chapter 11*](B22403_11.xhtml#_idTextAnchor519),
    when we were creating links for the URDF. If you happen to include custom meshes
    with the **<mesh>** tag, inside the **<visual>** tag of a link, you will have
    to install the corresponding mesh files (with the **.stl** or **.****dae** extension).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 URDF 的链接时，我在 [*第11章*](B22403_11.xhtml#_idTextAnchor519) 简要提到了自定义网格，那时我们正在创建链接。如果你意外地使用
    **<mesh>** 标签在链接的 **<visual>** 标签内包含自定义网格，你将不得不安装相应的网格文件（具有 **.stl** 或 **.dae**
    扩展名）。
- en: 'In this case, in **my_robot_description**, you would create a new folder named
    **meshes**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，在 **my_robot_description** 中，你会创建一个名为 **meshes** 的新文件夹：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this folder, you would add all the **.stl** and **.dae** files you want
    to use in your URDF. Then, let’s say you have added a file named **base.stl**.
    In the URDF, you will use this syntax to include it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，你会添加所有你想要在 URDF 中使用的 **.stl** 和 **.dae** 文件。然后，比如说，你添加了一个名为 **base.stl**
    的文件。在 URDF 中，你将使用以下语法来包含它：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To install the **meshes** folder, you also have to add an instruction in **CMakeLists.txt**.
    As we already added the **install()** block previously, you just need to add the
    name of the new folder you want to install:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 **meshes** 文件夹，你也需要在 **CMakeLists.txt** 中添加一个指令。因为我们之前已经添加了 **install()**
    块，你只需要添加你想要安装的新文件夹的名称：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When adding new folder names after `DIRECTORY`, you can either separate them
    with a space or put them on a new line; it won’t make a difference.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `DIRECTORY` 后添加新的文件夹名称时，你可以用空格分隔它们，或者将它们放在新的一行上；这不会产生影响。
- en: That’s it for custom meshes. Even though we don’t use them now, I wanted to
    include this, so that you have all the required knowledge to create a complete
    URDF with custom shapes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义网格，这就是全部内容。即使我们现在不使用它们，我也想包括这个，这样你就有所有创建具有自定义形状的完整 URDF 所需的知识。
- en: Installing the RViz configuration
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 RViz 配置
- en: Let’s finish this section by installing the RViz configuration we previously
    saved. This way, when we start RViz later on from a launch file, we can use this
    configuration directly from the package.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过安装我们之前保存的 RViz 配置来结束本节。这样，当我们稍后从启动文件启动 RViz 时，我们可以直接从包中使用这个配置。
- en: 'Create an **rviz** folder inside the package:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在包内创建一个 **rviz** 文件夹：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Move the **urdf_config.rviz** file into this new **rviz** folder.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **urdf_config.rviz** 文件移动到这个新的 **rviz** 文件夹中。
- en: 'Now, to install the folder, add its name to the **install()** instruction,
    inside **CMakeLists.txt**:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了安装文件夹，将文件夹名称添加到 **install()** 指令中，在 **CMakeLists.txt** 内部：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We now have all the files we need for this package. Before we install them (with
    **colcon build**), let’s add a launch file so we can start all the required nodes
    to publish the TFs as well as visualize the robot model in RViz.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了这个包所需的所有文件。在我们使用 **colcon build** 安装它们之前，让我们添加一个启动文件，这样我们就可以启动所有必要的节点来发布
    TFs 以及在 RViz 中可视化机器人模型。
- en: Writing a launch file to publish TFs and visualize the robot
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写用于发布 TFs 和可视化机器人的启动文件
- en: The **my_robot_description** package is finished, but we will add a launch file
    so we can start all the nodes and parameters that we discovered at the beginning
    of this chapter. This way, we can publish TFs and visualize the robot in RViz.
    This will also be a good practice exercise on launch files, and we will reuse
    part of the code in the next chapter when we build the Gazebo simulation for the
    robot.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**my_robot_description** 包已经完成，但我们将添加一个启动文件，这样我们就可以启动我们在本章开头发现的节点和参数。这样，我们就可以在
    RViz 中发布 TFs 并可视化机器人。这也会是一个关于启动文件的很好的实践练习，我们将在下一章构建机器人的 Gazebo 模拟时重用部分代码。'
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Usually, we add all launch files inside a `_bringup` package (dedicated package
    used for launch and configuration files). Here, we make an exception, because
    this launch file will be used only for visualization and development. Any other
    launch file that we write for this application will be placed inside the `my_robot_bringup`
    package (which we will create in the next chapter).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将所有启动文件添加到 `_bringup` 包中（用于启动和配置文件的专用包）。这里，我们做一个例外，因为这个启动文件将仅用于可视化和开发。我们将为这个应用程序编写的任何其他启动文件都将放置在
    `my_robot_bringup` 包中（我们将在下一章创建）。
- en: We will write the launch file first with XML, and then with Python. This will
    be another example of how XML launch files can be easier to write than Python
    ones.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使用 XML 编写启动文件，然后使用 Python。这将是 XML 启动文件比 Python 启动文件更容易编写的一个例子。
- en: The XML launch file
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 启动文件
- en: Before writing any launch file, we first need to create a **launch** folder,
    where we will put all our launch files for the **my_robot_description** package.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何启动文件之前，我们首先需要创建一个 **launch** 文件夹，我们将把所有我们的启动文件放在这个文件夹中，用于 **my_robot_description**
    包。
- en: Creating and installing a launch folder
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和安装启动文件夹
- en: 'To create and install a **launch** folder, we will follow the same process
    as before. First, create the folder:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和安装一个 **launch** 文件夹，我们将遵循之前的过程。首先，创建文件夹：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, to specify the instructions to install this folder, it’s as easy as adding
    the folder name inside **CMakeLists.txt**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了指定安装此文件夹的指令，只需在 **CMakeLists.txt** 中添加文件夹名称即可：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As the **install()** instruction was already configured, if we want to install
    a new folder, we just add its name after the other ones. For now, we are installing
    four folders in this package.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **install()** 指令已经配置好了，如果我们想安装一个新的文件夹，我们只需在其后添加其名称。目前，我们在这个包中安装了四个文件夹。
- en: 'Once this is done, create a new launch file inside the folder. We will name
    it **display.launch.xml**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，在文件夹内创建一个新的启动文件。我们将将其命名为 **display.launch.xml**：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let’s write the content for this launch file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这个启动文件编写内容。
- en: Writing the launch file
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写启动文件
- en: 'In this launch file, we will simply start the nodes and parameters that we
    discovered and listed at the beginning of this chapter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个启动文件中，我们将简单地启动我们在本章开头发现和列出的节点和参数：
- en: '`robot_state_publisher` with the URDF as the `robot_description` parameter.
    This node will publish on the `/``tf` topic.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_state_publisher` 使用 URDF 作为 `robot_description` 参数。此节点将在 `/``tf` 主题上发布。'
- en: '`joint_state_publisher` to publish on the `/``joint_states` topic.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joint_state_publisher` 用于在 `/``joint_states` 主题上发布。'
- en: '`rviz2`, as we also want to visualize the robot model.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rviz2`，因为我们还想可视化机器人模型。'
- en: We already know how to start those nodes from the terminal; now, all we have
    to do is add them inside one launch file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何从终端启动这些节点；现在，我们只需要将它们添加到一个启动文件中。
- en: 'In the launch file, first open and close a **<****launch>** tag:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动文件中，首先打开并关闭一个 **<****launch>** 标签：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, make sure to write all the following lines inside this **<launch>** tag.
    You can also add an indentation (four spaces) for those lines.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请确保将以下所有行都写入此 **<launch>** 标签内。你也可以为这些行添加缩进（四个空格）。
- en: As we will need to find the path of the URDF file and the RViz configuration
    file, we add two variables at the beginning of the launch file, to make the file
    cleaner and more readable. Also, if you have to modify those values later, you
    know that you just have to modify the variables at the top of the file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要找到 URDF 文件和 RViz 配置文件的路径，我们在启动文件的开头添加了两个变量，使文件更干净、更易读。此外，如果你以后需要修改这些值，你知道你只需要修改文件顶部的变量。
- en: 'We haven’t seen how to add (constant) variables yet in a launch file, but it’s
    not too complicated. You will use the **<let>** tag with two arguments: **name**
    and **value**. Let’s add the two variables we need:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到如何在启动文件中添加（常量）变量，但这并不复杂。你将使用 **<let>** 标签，并带有两个参数：**name** 和 **value**。让我们添加我们需要的两个变量：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then, to use a variable, you can write **$(****var name)**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要使用变量，你可以写 **$(****var name)**。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although the XML syntax looks similar between launch files and Xacro files,
    make sure not to mix things up: *To find a package*, you use `find-pkg-share`
    in a launch file and `find` with Xacro. *To use a variable*, you use `$(var name)`
    in a launch file and `${name}` with Xacro.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然启动文件和 Xacro 文件之间的 XML 语法看起来很相似，但请确保不要混淆：*要查找一个包*，你在启动文件中使用 `find-pkg-share`，而在
    Xacro 中使用 `find`。*要使用变量*，你在启动文件中使用 `$(var name)`，而在 Xacro 中使用 `${name}`。
- en: 'Now, let’s start all the nodes we need, one by one. Here is the code for the
    **robot_state_publisher** node:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐个启动我们需要的所有节点。以下是 **robot_state_publisher** 节点的代码：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Nothing special here; we use the same values as in the command we previously
    ran in the terminal. To specify a command to run in an XML launch file, you can
    use **$(****command '...')**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的；我们使用与我们在终端中之前运行的命令相同的值。要在 XML 启动文件中指定要运行的命令，你可以使用 **$(****command
    '...')**。
- en: 'Next, we can start the **joint_state_publisher** node. Here, we use the executable
    with the **_gui** suffix to get a graphical window with cursors to move the joints:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以启动 **joint_state_publisher** 节点。在这里，我们使用带有 **_gui** 后缀的可执行文件来获取一个带有光标的图形窗口，可以移动关节：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This node is easy to write, as we don’t need to provide anything else except
    the package and executable. Let’s finish with the RViz node:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点很容易编写，因为我们不需要提供任何其他东西，除了包和可执行文件。让我们以 RViz 节点结束：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this node, we provide the saved RViz configuration file, using the **-****d**
    option.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在此节点中，我们使用 **-****d** 选项提供保存的 RViz 配置文件。
- en: Starting the launch file
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动启动文件
- en: 'The launch file is now complete. We can build the workspace to install all
    the files and folders that we’ve added:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 启动文件现在已经完成。我们可以构建工作空间来安装我们添加的所有文件和文件夹：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, don’t forget to source the workspace (**source install/setup.bash**),
    and you can start your new launch file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，别忘了源工作空间（**source install/setup.bash**），然后你可以启动你的新启动文件：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After running this command, you should see your robot model in RViz with the
    TFs. If you list nodes and topics on the terminal, you should be able to find
    everything that we have started. With **rqt_graph**, you should also get the same
    result as when we started all three nodes from the terminal.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你应该能在 RViz 中看到你的机器人模型以及 TF。如果你在终端上列出节点和主题，你应该能找到我们启动的所有内容。使用 **rqt_graph**，你也应该得到与我们在终端中启动所有三个节点相同的结果。
- en: 'The **my_robot_description** package is now complete. We have installed all
    the files that we need: URDF, custom meshes, RViz configuration, and a launch
    file to publish TFs and visualize the robot model. Before we wrap things up, let’s
    talk briefly about the Python version of the launch file.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**my_robot_description** 包现在已经完成。我们已经安装了我们需要的所有文件：URDF、自定义网格、RViz 配置和一个用于发布
    TF 和可视化机器人模型的启动文件。在我们结束之前，让我们简要谈谈启动文件的 Python 版本。'
- en: The Python launch file
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 启动文件
- en: 'We will finish this chapter with the Python launch file to do the same thing:
    start the **robot_state_publisher**, **joint_state_publisher**, and RViz. The
    main reason I do this here is to provide another example to emphasize the difference
    between Python and XML launch files. You can see this as an extension of what
    we discussed during [*Chapter 9*](B22403_09.xhtml#_idTextAnchor443), *XML versus
    Python for* *launch files*.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以Python启动文件结束本章，以执行相同的事情：启动**robot_state_publisher**、**joint_state_publisher**和RViz。我在这里这样做的主要原因是为了提供一个额外的例子，强调Python和XML启动文件之间的差异。您可以将这看作是[*第9章*](B22403_09.xhtml#_idTextAnchor443)中我们讨论的内容的扩展，即*XML与Python的*
    *启动文件*。
- en: 'This is also the last time I use Python for launch files, as in the next chapter
    on Gazebo, we will focus only on XML (as a reminder: If you ever need to use an
    existing Python launch file, you can include it inside an XML launch file, so
    there is no problem here).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我最后一次使用Python来编写启动文件，因为在下一章关于Gazebo的内容中，我们将只关注XML（提醒一下：如果您需要使用现有的Python启动文件，您可以在XML启动文件中包含它，所以这里没有问题）。
- en: Let’s now create the Python launch file. To do that, create a new file inside
    the **launch** folder of the **my_robot_description** package. You can name this
    file **display.launch.py**—the same name as for the XML launch file, but with
    a Python extension.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个Python启动文件。为此，在**my_robot_description**包的**launch**文件夹中创建一个新文件。您可以将其命名为**display.launch.py**——与XML启动文件同名，但带有Python扩展名。
- en: There is no need to add any extra configuration in the package, as **CMakeLists.txt**
    already contains the instructions to install the **launch** folder.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在包中不需要添加任何额外的配置，因为**CMakeLists.txt**已经包含了安装**launch**文件夹的指令。
- en: 'Let’s start to analyze this Python file (you can find the full code for this
    file in the book’s GitHub repository) with the import lines:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始分析这个Python文件（您可以在本书的GitHub仓库中找到这个文件的完整代码）从导入行开始：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see, that’s a lot of things to import, and it could be easy to make
    mistakes here. After the imports, we start the **generate_launch_description**
    function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里有很多东西需要导入，很容易在这里出错。导入之后，我们开始执行**generate_launch_description**函数：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All the code we have from now on will be inside this function (with an indentation).
    We create the two variables for the URDF and RViz path:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们所有的代码都将在这个函数内部（带有缩进）。我们创建了两个变量用于URDF和RViz路径：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To make things a bit more readable, we also create a variable for the **robot_description**
    parameter:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使内容更易读，我们还创建了一个用于**robot_description**参数的变量：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we start the three nodes:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们开始启动三个节点：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we need to return a **LaunchDescription** object with all the nodes
    we want to start:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要返回一个包含我们想要启动的所有节点的**LaunchDescription**对象：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, the code is much longer: 38 lines for Python versus 15 lines
    for XML. We could optimize the spaces, but even with that, there would still be
    a factor of two. Also, I personally find the Python syntax more complex and not
    really intuitive. To be honest with you, the only way I manage to write Python
    launch files is just by scrapping bits of code from existing projects I find on
    GitHub and seeing if it works.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码更长：Python有38行，而XML有15行。我们可以优化空格，但即使如此，仍然会有两倍之多。此外，我个人认为Python语法更复杂，并不太直观。说实话，我写Python启动文件的唯一方法就是从GitHub上找到的现有项目中摘取代码片段，看看它是否可行。
- en: I’m not going to provide much more details than that, as this code was here
    mainly so we can have another example of what we discussed back in [*Chapter 9*](B22403_09.xhtml#_idTextAnchor443).
    We will continue with XML launch files going forward.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会提供比这更多的细节，因为这段代码主要在这里是为了让我们有另一个例子，说明我们之前在[*第9章*](B22403_09.xhtml#_idTextAnchor443)中讨论的内容。我们将继续使用XML启动文件。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have published the TFs for your robot and properly packaged
    your application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经发布了机器人的TFs，并且正确地打包了您的应用程序。
- en: 'You first discovered that the most important node to start is **robot_state_publisher**,
    with two inputs: the URDF in the **robot_description** parameter, and the current
    states for each joint on the **/****joint_states** topic.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先发现，最重要的节点是**robot_state_publisher**，它有两个输入：**robot_description**参数中的URDF和**/****joint_states**主题上每个关节的当前状态。
- en: From this, you started all the nodes and parameters from the terminal so that
    you could reproduce the output we previously had with the **urdf_tutorial** package.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您从终端启动了所有节点和参数，以便能够重现我们之前使用**urdf_tutorial**包所得到的输出。
- en: 'Then, you created your own package to correctly organize your application.
    Here is the final architecture for this package, with all the files and folders:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你创建了自己的包来正确组织你的应用程序。以下是这个包的最终架构，包括所有文件和文件夹：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This organization is very standard. If you look at the code for almost any robot
    powered by ROS, you will find this **_description** package using more or less
    the same architecture. Thus, creating this package was not only helpful for the
    process we follow in this book but also for you to easily start working on any
    other project made by ROS developers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织方式非常标准。如果你查看几乎任何由ROS驱动的机器人的代码，你都会发现这个**_描述**包使用的是或多或少相同的架构。因此，创建这个包不仅对我们在这本书中遵循的过程有帮助，而且对你轻松开始任何由ROS开发者制作的其他项目的工作也有帮助。
- en: We will now use this package as the base for the next chapter, where we will
    learn how to create a simulation for the robot using Gazebo.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个包作为下一章的基础，我们将学习如何使用Gazebo为机器人创建模拟。
