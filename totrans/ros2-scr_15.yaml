- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publishing TFs and Packaging the URDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in *Part 3* of this book, you’ve had an introduction to TFs and have
    learned how to write a URDF, which will be used to generate the TFs for your robotics
    application. There are now two things we need to do to go further.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to be quicker, we have used the **urdf_tutorial** package to publish
    the TFs. This is great to get started and visualize the robot model, but we won’t
    use this package in a real application. The question is this then: Using the URDF
    we have created, how do we generate the TFs for our application? What nodes do
    we need to start? We will first understand, through experimentation, what nodes
    and parameters we need to start to correctly generate the TFs for our application.
    From this, we will be able to create our own launch file.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, the URDF is now a series of three Xacro files placed inside the home
    directory. To start a proper ROS 2 application, we will create a package to organize
    and install the URDF, the launch file, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to correctly package your URDF
    and publish the TFs for a ROS 2 application. This process is the same for any
    robot, and this package you create here will be the base for any further development,
    including the Gazebo simulation that we will cover later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: As a starting point for this chapter, we will use the code inside the **ch11**
    folder from the book’s GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
    You can find the final code in the **ch12** folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to publish TFs with our URDF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting all nodes from the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a package to install the URDF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a launch file to publish TFs and visualize the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to publish TFs with our URDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start this chapter by understanding what nodes and parameters we need
    to start in order to publish the TFs for our application. Then, with this knowledge,
    we will be able to start the required nodes, package the application, and write
    a launch file.
  prefs: []
  type: TYPE_NORMAL
- en: As we often did in this book, we will start with a discovery phase, through
    experimentation. I recommend that you run all the commands as you read the section.
  prefs: []
  type: TYPE_NORMAL
- en: The robot_state_publisher node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basically, in this chapter, we want to replicate what was done with the **urdf_tutorial**
    package so we can publish the TFs by ourselves. Let’s then start the **display.launch.py**
    launch file again, using the URDF from the previous chapter, and do some introspection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In a second terminal, start **rqt_graph** to visualize the nodes that are currently
    running. Refresh the view if the screen is empty. You will see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Nodes running with urdf_tutorial](img/B22403_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Nodes running with urdf_tutorial
  prefs: []
  type: TYPE_NORMAL
- en: We see the **/tf** topic, which is the most important thing here. This is what’s
    needed for any ROS application to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is publishing on the **/tf** topic? As you can see, there is a node
    called **/robot_state_publisher** (in the text, we will write **robot_state_publisher**,
    without the leading slash). Where does this node come from? **robot_state_publisher**
    is a core node already available for you to use. It is a part of the collection
    of packages that you installed with ROS 2\. This node will publish the TFs for
    your robot. You will start it in any ROS 2 application where you need TFs. Most
    of the time, you won’t have to publish any TF by yourself, as this will be handled
    by the **robot_state_publisher** node.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know we have to start this node, what inputs are required?
  prefs: []
  type: TYPE_NORMAL
- en: Inputs for the robot_state_publisher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two things you need to provide for the **robot_state_publisher**
    node to work correctly: URDF and joint states. Let’s start with the first one.'
  prefs: []
  type: TYPE_NORMAL
- en: URDF as a parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, you might wonder: Where did the URDF go? We just saw some nodes
    and topics on **rqt_graph**, but we didn’t see the use of the URDF we created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep **display.launch.py** from **urdf_tutorial** running, and in another terminal,
    list all parameters for the **robot_state_publisher** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see quite a few, but the one that we care about here is named **robot_description**.
    Then, you can read the value from this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this, you will see the entire URDF in the terminal (or more precisely,
    the generated URDF from the Xacro file you have provided).
  prefs: []
  type: TYPE_NORMAL
- en: So, when you start the **robot_state_publisher** node, you will need to give
    the URDF inside a parameter named **robot_description**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In `rqt_graph`, you can see that the `robot_state_publisher` is publishing on
    the `/robot_description` topic. The message you get from this topic also contains
    the URDF content. This can be useful to retrieve the URDF from any other node,
    using a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the first input; let’s see the second one.
  prefs: []
  type: TYPE_NORMAL
- en: Joint states topic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to publish the TFs, the **robot_state_publisher** node will need the
    URDF, but also the current state for each joint.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the **/joint_states** topic in **rqt_graph** in *Figure 12**.1*.
    This topic contains what you would read from encoders or control feedback in a
    real robot. For example, if you have some wheels, you will get to know the speed
    and/or position of those wheels. You will feed this into the **/joint_states**
    topic. If you have a robotic arm, you usually have encoders on each axis reading
    the current position for the axis.
  prefs: []
  type: TYPE_NORMAL
- en: When we simulate the robot with Gazebo, we will use a plugin that automatically
    publishes the joint states. In fact, either in simulation mode or for a real robot,
    you will usually have nodes doing this for you (to go further on this, check out
    ros2_control after reading this book—you can find extra resources about that in
    the last chapter of this book). So, all you need to know is that this **/joint_states**
    topic is important, as it’s required by **robot_state_publisher**. Publishing
    on this topic is done by existing ROS 2 plugins.
  prefs: []
  type: TYPE_NORMAL
- en: For now, as we don’t have any real robot or Gazebo simulation, we will use the
    **joint_state_publisher** node (with the **Joint State Publisher** window), which
    will publish whatever values we select on the cursors. For example, if you select
    **1.0** radian for **base_right_wheel_joint**, then **1.0** will be published
    on the **/joint_states** topic for that joint and will be received and used by
    **robot_state_publisher**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, it’s important to clarify the difference between joint states and TFs.
    A joint state is simply the *current state* of a joint. For example, for a wheel:
    what is the current velocity? For an axis in a robotic arm: what is the current
    angular position of the motor? The state is one data point, at one specific time,
    for one joint in your robot. It doesn’t specify anything about the relationship
    between joints, nor where they are located relative to each other—this is what
    a TF is.'
  prefs: []
  type: TYPE_NORMAL
- en: Recap – how to publish TFs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s do a quick recap of what is required to publish TFs. This is what **urdf_tutorial**
    was doing for us, and what we will be doing by ourselves from now on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The required node and inputs to publish TFs](img/B22403_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – The required node and inputs to publish TFs
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the `robot_state_publisher` node. This node is already installed. We give
    the URDF as the `robot_description` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the current state for all joints on the `/joint_states` topic. This
    is usually done automatically for you, either with data from encoders, a simulator
    such as Gazebo, or *fake* data from the `joint_state_publisher` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s all you have to do to correctly publish the TFs for your application.
    Those TFs will then be used by other nodes, plugins, and stacks, for example,
    the Navigation 2 or MoveIt 2 stacks (we won’t cover those in this book, but they
    would be a good topic to study afterward—more resources will be given in the last
    chapter of this book).
  prefs: []
  type: TYPE_NORMAL
- en: Starting all nodes from the terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we package the application and write a launch file, let’s start all the
    nodes we need in the terminal. Doing this is a best practice so that you can make
    sure your application is working properly. Then, creating the package and the
    launch file will be easier, as you already know all the elements you need to include.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the result from the previous section and start the **robot_state_publisher**
    node, as well as the **joint_state_publisher** node. In addition to that, we will
    start RViz (this is optional and only used to visualize the robot model).
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the TFs from the terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s publish the TFs. For that, we will open two terminals.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first one, start the **robot_state_publisher** node. The package and
    executable names for this node are identical. To provide the **robot_description**
    parameter, you will have to use this syntax: **"$(****xacro <path_to_urdf>)"**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 1, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you see this, everything is working fine. **robot_state_publisher** has been
    started with the URDF, and it’s ready to publish on the **/tf** topic. Now, we
    need to add a publisher on the **/joint_states** topic. We will use the **joint_state_publisher_gui**
    executable from the same package (note the extra **_gui** suffix, which means
    **graphical** **user interface**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the executable name and node name are two different things. The
    executable name is the one you define in `setup.py` (for Python) or `CMakeLists.txt`
    (for C++). The node name is defined in the code and can be different. Here, we
    start the `joint_state_publisher_gui` executable, but the node name is `joint_state_publisher`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal 2, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will open the **Joint State Publisher** window that we previously used
    when experimenting with TFs and URDF. The values you see on the cursors will be
    published on the **/joint_states** topic and will be received by **robot_state_publisher**.
  prefs: []
  type: TYPE_NORMAL
- en: That’s basically all we need. This will become the backbone of your ROS 2 application—of
    course, we will need to package this nicely and start it from a launch file.
  prefs: []
  type: TYPE_NORMAL
- en: If you run **rqt_graph**, you will see the same nodes and topics as in *Figure
    12**.1*. You can also print the TF tree (**ros2 run tf2_tools view_frames**) and
    listen to the **/tf** topic in the terminal (**ros2 topic** **echo /tf**).
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the robot model in RViz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On top of what we did, we can visualize the robot in RViz. This is optional,
    and it’s something you will do mostly when you develop your application. After
    everything is working correctly and you switch to production mode, you won’t need
    to start RViz.
  prefs: []
  type: TYPE_NORMAL
- en: Starting and configuring RViz
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start RViz and see how to visualize the robot model as well as the TFs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep the **robot_state_publisher** and **joint_state_publisher** nodes running.
    Then, in Terminal 3, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open RViz, but, as you can see, there is no robot model, and we have
    some errors on the left menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Rviz with no robot model and some errors](img/B22403_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – RViz with no robot model and some errors
  prefs: []
  type: TYPE_NORMAL
- en: We need to do a bit of configuration to correctly visualize the robot model
    and the TFs. Then, we will be able to save this configuration and reuse it the
    next time we start RViz.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure RViz:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the left menu, `map` to `base_footprint`. After that, `Global Status: Error`
    should change to `Global` `Status: OK`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** button on the left, scroll down, and double-click on **RobotModel**.
    You will have a new menu on the left side of RViz.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open this new `/robot_description`. After this, the robot model should appear
    on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** button again, scroll down, and double-click on **TF**.
    This will open a new menu, and you will see the TFs appear on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to see through the model, like we did before, open `1` to `0.8,`
    for example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can remove the extra menus on the right (**Views**) and at the bottom (**Time**)
    to get more space for the robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With all those settings, you should see the robot model and TFs the same way
    we did when we previously visualized the URDF with the **urdf_tutorial** package:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.4 – RViz with the robo\uFEFFt model and TFs](img/B22403_12_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – RViz with the robot model and TFs
  prefs: []
  type: TYPE_NORMAL
- en: Saving the RViz configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to repeat those steps every time you start RViz. To avoid doing
    this, we will save the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **File** | **Save Config As**. Let’s name the file **urdf_config.rviz**
    (for these files, use the **.rviz** extension), and place it inside your home
    directory for now.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you can see the file, using a file manager or the terminal. If you
    didn’t save the file correctly, you will need to manually do the full configuration
    again. Once the file is saved, you can stop RViz (*Ctrl + C* in the terminal).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when you start RViz again, you can add an extra **-d** argument with
    the path to the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start RViz exactly like you saved it: same menus, same view, same
    zoom, and so on. We will reuse this configuration file throughout this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to change the configuration, all you have to do is modify whichever
    settings you want in RViz, save a new configuration file, and use this one instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have everything we need: the URDF files and the RViz config file, and
    we know what nodes and parameters we have to start, and how to start them.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now organize everything properly into a ROS 2 package. We will first create
    the package, and then add a launch file to start all the nodes at once.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a package to install the URDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the files we have created are now in our home directory. It’s time to create
    a ROS 2 package and move all the files into the right place so that they can be
    installed and used in our ROS 2 workspace.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a package dedicated to the robot model. Then, we will
    install all the files required for this application. This will allow us to use
    the URDF and RViz files when we write a launch file, to start all the nodes we
    have seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a new package, but before we do that, it could be a good idea to
    create a new ROS 2 workspace.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of now, our **ros2_ws** workspace contains all the code used in *Part 2*
    of this book, including various examples to illustrate the core concepts, a robot
    controller for the Turtlesim, some custom interfaces, and launch files. We don’t
    need any of those for the *Part 3* project; so, instead of continuing to add more
    things to this workspace, we will create a new one. As a general rule, if you
    have two different applications, you will have two different workspaces.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s then create a new workspace named **my_robot_ws**. A good practice is
    to name the workspace as per your application or robot name. This will help you
    avoid confusion in the long term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new workspace in your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside this workspace, create a **src** directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, and this is super important, you can have as many ROS 2 workspaces as you
    want, but you should not work with two workspaces for two different applications
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are currently sourcing the **ros2_ws** workspace every time you open a
    terminal. If you remember, you added an extra line in **.bashrc** to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the **.bashrc** file again and comment that line (add **#** in front of
    the line). Now, close all terminals, open a new one, and let’s build and source
    our new workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the **.bashrc** again and add a line to source this new workspace. The
    end of **.bashrc** will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, we first source the global ROS 2 installation. Then, we source
    our workspace. Commenting the workspaces you don’t use is very practical. This
    way, if you want to switch between two workspaces, you just have to uncomment/comment
    the two lines, close all terminals, and open a new terminal to source the workspace
    you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a _description package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have this new empty workspace correctly configured and sourced,
    let’s add a new package inside.
  prefs: []
  type: TYPE_NORMAL
- en: To name the package, we use the robot’s name, followed by **_description**.
    This is a common convention used by lots of ROS developers. By using this naming
    format, you make it clear that this package will contain the URDF files for your
    robot. This will make collaboration easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this new package, we use the **ament_cmake** build type, just as
    if we were creating a C++ package, and we don’t specify any dependencies. Let’s
    create the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, this package is a standard C++ ROS 2 package. However, we won’t write
    any nodes inside. We just need the package to install our robot model. Thus, you
    can remove the **src** and **include** directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, your package will only contain two files: **package.xml** and
    **CMakeLists.txt**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the workspace with an IDE. If you’re using VS code, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To clean things a bit more, we will simplify the **CMakeLists.txt** file. Remove
    the comments after the **find_package(ament_cmake REQUIRED)** line, and, as we
    don’t need that now, remove the **if(BUILD_TESTING)** block. Make sure you keep
    the **ament_package()** instruction, which should be the last line of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the URDF and other files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our **robot_description** package, let’s install all the files
    we need. To install a file, we will follow this process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder to host the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instruction in `CMakeLists.txt` to install the folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we will see how to install the URDF files, custom meshes, and the RViz
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Xacro and URDF files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install our Xacro and URDF files, go inside the **my_robot_description**
    package and create a new folder named **urdf**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now move all three Xacro files inside this **urdf** folder: **common_properties.xacro,
    mobile_base.xacro**, and **my_robot.urdf.xacro**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything should work fine, but to make the **include** paths more robust,
    let’s modify the **<xacro:include>** tags inside **my_robot.urdf.xacro**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Instead of providing only the relative path (which should still work in this
    case), we provide the absolute path to where the files will be installed, using
    the **find** keyword before the package name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open **CMakeLists.txt**, and add those instructions to install the **urdf**
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will install the **urdf** folder inside a **share** directory when you
    build the package. It will allow any package from the workspace to find the URDF
    for your robot. This is actually very similar to what we’ve done in [*Chapter
    9*](B22403_09.xhtml#_idTextAnchor443) when installing launch files and param files.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now continue with custom meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing custom meshes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not using any custom mesh for now (which is probably the case if
    you are learning ROS 2 from scratch with this book), you can skip this small section
    and go to the RViz configuration directly.
  prefs: []
  type: TYPE_NORMAL
- en: I briefly mentioned custom meshes in [*Chapter 11*](B22403_11.xhtml#_idTextAnchor519),
    when we were creating links for the URDF. If you happen to include custom meshes
    with the **<mesh>** tag, inside the **<visual>** tag of a link, you will have
    to install the corresponding mesh files (with the **.stl** or **.****dae** extension).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, in **my_robot_description**, you would create a new folder named
    **meshes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this folder, you would add all the **.stl** and **.dae** files you want
    to use in your URDF. Then, let’s say you have added a file named **base.stl**.
    In the URDF, you will use this syntax to include it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the **meshes** folder, you also have to add an instruction in **CMakeLists.txt**.
    As we already added the **install()** block previously, you just need to add the
    name of the new folder you want to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When adding new folder names after `DIRECTORY`, you can either separate them
    with a space or put them on a new line; it won’t make a difference.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for custom meshes. Even though we don’t use them now, I wanted to
    include this, so that you have all the required knowledge to create a complete
    URDF with custom shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the RViz configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s finish this section by installing the RViz configuration we previously
    saved. This way, when we start RViz later on from a launch file, we can use this
    configuration directly from the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **rviz** folder inside the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Move the **urdf_config.rviz** file into this new **rviz** folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to install the folder, add its name to the **install()** instruction,
    inside **CMakeLists.txt**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We now have all the files we need for this package. Before we install them (with
    **colcon build**), let’s add a launch file so we can start all the required nodes
    to publish the TFs as well as visualize the robot model in RViz.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a launch file to publish TFs and visualize the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **my_robot_description** package is finished, but we will add a launch file
    so we can start all the nodes and parameters that we discovered at the beginning
    of this chapter. This way, we can publish TFs and visualize the robot in RViz.
    This will also be a good practice exercise on launch files, and we will reuse
    part of the code in the next chapter when we build the Gazebo simulation for the
    robot.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we add all launch files inside a `_bringup` package (dedicated package
    used for launch and configuration files). Here, we make an exception, because
    this launch file will be used only for visualization and development. Any other
    launch file that we write for this application will be placed inside the `my_robot_bringup`
    package (which we will create in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: We will write the launch file first with XML, and then with Python. This will
    be another example of how XML launch files can be easier to write than Python
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: The XML launch file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before writing any launch file, we first need to create a **launch** folder,
    where we will put all our launch files for the **my_robot_description** package.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and installing a launch folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create and install a **launch** folder, we will follow the same process
    as before. First, create the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to specify the instructions to install this folder, it’s as easy as adding
    the folder name inside **CMakeLists.txt**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As the **install()** instruction was already configured, if we want to install
    a new folder, we just add its name after the other ones. For now, we are installing
    four folders in this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, create a new launch file inside the folder. We will name
    it **display.launch.xml**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s write the content for this launch file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the launch file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this launch file, we will simply start the nodes and parameters that we
    discovered and listed at the beginning of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`robot_state_publisher` with the URDF as the `robot_description` parameter.
    This node will publish on the `/``tf` topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`joint_state_publisher` to publish on the `/``joint_states` topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rviz2`, as we also want to visualize the robot model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already know how to start those nodes from the terminal; now, all we have
    to do is add them inside one launch file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the launch file, first open and close a **<****launch>** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, make sure to write all the following lines inside this **<launch>** tag.
    You can also add an indentation (four spaces) for those lines.
  prefs: []
  type: TYPE_NORMAL
- en: As we will need to find the path of the URDF file and the RViz configuration
    file, we add two variables at the beginning of the launch file, to make the file
    cleaner and more readable. Also, if you have to modify those values later, you
    know that you just have to modify the variables at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven’t seen how to add (constant) variables yet in a launch file, but it’s
    not too complicated. You will use the **<let>** tag with two arguments: **name**
    and **value**. Let’s add the two variables we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then, to use a variable, you can write **$(****var name)**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the XML syntax looks similar between launch files and Xacro files,
    make sure not to mix things up: *To find a package*, you use `find-pkg-share`
    in a launch file and `find` with Xacro. *To use a variable*, you use `$(var name)`
    in a launch file and `${name}` with Xacro.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start all the nodes we need, one by one. Here is the code for the
    **robot_state_publisher** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special here; we use the same values as in the command we previously
    ran in the terminal. To specify a command to run in an XML launch file, you can
    use **$(****command '...')**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can start the **joint_state_publisher** node. Here, we use the executable
    with the **_gui** suffix to get a graphical window with cursors to move the joints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This node is easy to write, as we don’t need to provide anything else except
    the package and executable. Let’s finish with the RViz node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this node, we provide the saved RViz configuration file, using the **-****d**
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the launch file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The launch file is now complete. We can build the workspace to install all
    the files and folders that we’ve added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, don’t forget to source the workspace (**source install/setup.bash**),
    and you can start your new launch file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, you should see your robot model in RViz with the
    TFs. If you list nodes and topics on the terminal, you should be able to find
    everything that we have started. With **rqt_graph**, you should also get the same
    result as when we started all three nodes from the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **my_robot_description** package is now complete. We have installed all
    the files that we need: URDF, custom meshes, RViz configuration, and a launch
    file to publish TFs and visualize the robot model. Before we wrap things up, let’s
    talk briefly about the Python version of the launch file.'
  prefs: []
  type: TYPE_NORMAL
- en: The Python launch file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will finish this chapter with the Python launch file to do the same thing:
    start the **robot_state_publisher**, **joint_state_publisher**, and RViz. The
    main reason I do this here is to provide another example to emphasize the difference
    between Python and XML launch files. You can see this as an extension of what
    we discussed during [*Chapter 9*](B22403_09.xhtml#_idTextAnchor443), *XML versus
    Python for* *launch files*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also the last time I use Python for launch files, as in the next chapter
    on Gazebo, we will focus only on XML (as a reminder: If you ever need to use an
    existing Python launch file, you can include it inside an XML launch file, so
    there is no problem here).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now create the Python launch file. To do that, create a new file inside
    the **launch** folder of the **my_robot_description** package. You can name this
    file **display.launch.py**—the same name as for the XML launch file, but with
    a Python extension.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to add any extra configuration in the package, as **CMakeLists.txt**
    already contains the instructions to install the **launch** folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start to analyze this Python file (you can find the full code for this
    file in the book’s GitHub repository) with the import lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, that’s a lot of things to import, and it could be easy to make
    mistakes here. After the imports, we start the **generate_launch_description**
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'All the code we have from now on will be inside this function (with an indentation).
    We create the two variables for the URDF and RViz path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To make things a bit more readable, we also create a variable for the **robot_description**
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we start the three nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to return a **LaunchDescription** object with all the nodes
    we want to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code is much longer: 38 lines for Python versus 15 lines
    for XML. We could optimize the spaces, but even with that, there would still be
    a factor of two. Also, I personally find the Python syntax more complex and not
    really intuitive. To be honest with you, the only way I manage to write Python
    launch files is just by scrapping bits of code from existing projects I find on
    GitHub and seeing if it works.'
  prefs: []
  type: TYPE_NORMAL
- en: I’m not going to provide much more details than that, as this code was here
    mainly so we can have another example of what we discussed back in [*Chapter 9*](B22403_09.xhtml#_idTextAnchor443).
    We will continue with XML launch files going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have published the TFs for your robot and properly packaged
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You first discovered that the most important node to start is **robot_state_publisher**,
    with two inputs: the URDF in the **robot_description** parameter, and the current
    states for each joint on the **/****joint_states** topic.'
  prefs: []
  type: TYPE_NORMAL
- en: From this, you started all the nodes and parameters from the terminal so that
    you could reproduce the output we previously had with the **urdf_tutorial** package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you created your own package to correctly organize your application.
    Here is the final architecture for this package, with all the files and folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This organization is very standard. If you look at the code for almost any robot
    powered by ROS, you will find this **_description** package using more or less
    the same architecture. Thus, creating this package was not only helpful for the
    process we follow in this book but also for you to easily start working on any
    other project made by ROS developers.
  prefs: []
  type: TYPE_NORMAL
- en: We will now use this package as the base for the next chapter, where we will
    learn how to create a simulation for the robot using Gazebo.
  prefs: []
  type: TYPE_NORMAL
