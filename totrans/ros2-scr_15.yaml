- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publishing TFs and Packaging the URDF
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in *Part 3* of this book, you’ve had an introduction to TFs and have
    learned how to write a URDF, which will be used to generate the TFs for your robotics
    application. There are now two things we need to do to go further.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to be quicker, we have used the **urdf_tutorial** package to publish
    the TFs. This is great to get started and visualize the robot model, but we won’t
    use this package in a real application. The question is this then: Using the URDF
    we have created, how do we generate the TFs for our application? What nodes do
    we need to start? We will first understand, through experimentation, what nodes
    and parameters we need to start to correctly generate the TFs for our application.
    From this, we will be able to create our own launch file.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Second, the URDF is now a series of three Xacro files placed inside the home
    directory. To start a proper ROS 2 application, we will create a package to organize
    and install the URDF, the launch file, and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to correctly package your URDF
    and publish the TFs for a ROS 2 application. This process is the same for any
    robot, and this package you create here will be the base for any further development,
    including the Gazebo simulation that we will cover later in this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: As a starting point for this chapter, we will use the code inside the **ch11**
    folder from the book’s GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
    You can find the final code in the **ch12** folder.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to publish TFs with our URDF
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting all nodes from the terminal
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a package to install the URDF
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a launch file to publish TFs and visualize the robot
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to publish TFs with our URDF
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start this chapter by understanding what nodes and parameters we need
    to start in order to publish the TFs for our application. Then, with this knowledge,
    we will be able to start the required nodes, package the application, and write
    a launch file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: As we often did in this book, we will start with a discovery phase, through
    experimentation. I recommend that you run all the commands as you read the section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The robot_state_publisher node
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basically, in this chapter, we want to replicate what was done with the **urdf_tutorial**
    package so we can publish the TFs by ourselves. Let’s then start the **display.launch.py**
    launch file again, using the URDF from the previous chapter, and do some introspection:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a second terminal, start **rqt_graph** to visualize the nodes that are currently
    running. Refresh the view if the screen is empty. You will see something like
    this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Nodes running with urdf_tutorial](img/B22403_12_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Nodes running with urdf_tutorial
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: We see the **/tf** topic, which is the most important thing here. This is what’s
    needed for any ROS application to work properly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 **/tf** 主题，这是这里最重要的东西。这是任何 ROS 应用程序正常工作所必需的。
- en: Now, what is publishing on the **/tf** topic? As you can see, there is a node
    called **/robot_state_publisher** (in the text, we will write **robot_state_publisher**,
    without the leading slash). Where does this node come from? **robot_state_publisher**
    is a core node already available for you to use. It is a part of the collection
    of packages that you installed with ROS 2\. This node will publish the TFs for
    your robot. You will start it in any ROS 2 application where you need TFs. Most
    of the time, you won’t have to publish any TF by yourself, as this will be handled
    by the **robot_state_publisher** node.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**/tf** 主题上发布了什么内容？正如你所见，有一个名为 **/robot_state_publisher**（在文本中，我们将写作 **robot_state_publisher**，不带前面的斜杠）。这个节点从哪里来？**robot_state_publisher**
    是一个已经为你准备好的核心节点，你可以使用它。它是你用 ROS 2 安装的软件包集合的一部分。这个节点将发布你机器人的 TFs。你将在任何需要 TFs 的
    ROS 2 应用程序中启动它。大多数时候，你不需要自己发布任何 TF，因为这将由 **robot_state_publisher** 节点处理。
- en: Now that we know we have to start this node, what inputs are required?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们必须启动这个节点，需要哪些输入？
- en: Inputs for the robot_state_publisher
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: robot_state_publisher 的输入
- en: 'There are two things you need to provide for the **robot_state_publisher**
    node to work correctly: URDF and joint states. Let’s start with the first one.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 **robot_state_publisher** 节点正确工作，你需要提供两样东西：URDF 和关节状态。让我们从第一样开始。
- en: URDF as a parameter
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URDF 作为参数
- en: 'At this point, you might wonder: Where did the URDF go? We just saw some nodes
    and topics on **rqt_graph**, but we didn’t see the use of the URDF we created.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道：URDF 去哪里了？我们在 **rqt_graph** 中看到了一些节点和主题，但我们没有看到我们创建的 URDF 的使用。
- en: 'Keep **display.launch.py** from **urdf_tutorial** running, and in another terminal,
    list all parameters for the **robot_state_publisher** node:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 **urdf_tutorial** 中的 **display.launch.py** 运行，并在另一个终端中列出 **robot_state_publisher**
    节点的所有参数：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see quite a few, but the one that we care about here is named **robot_description**.
    Then, you can read the value from this parameter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到很多主题，但我们这里关心的是名为 **robot_description** 的主题。然后，你可以从这个参数中读取值：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this, you will see the entire URDF in the terminal (or more precisely,
    the generated URDF from the Xacro file you have provided).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你将在终端中看到整个 URDF（或者更准确地说，从你提供的 Xacro 文件生成的 URDF）。
- en: So, when you start the **robot_state_publisher** node, you will need to give
    the URDF inside a parameter named **robot_description**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你启动 **robot_state_publisher** 节点时，你需要提供一个名为 **robot_description** 的参数内的
    URDF。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In `rqt_graph`, you can see that the `robot_state_publisher` is publishing on
    the `/robot_description` topic. The message you get from this topic also contains
    the URDF content. This can be useful to retrieve the URDF from any other node,
    using a subscriber.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `rqt_graph` 中，你可以看到 `robot_state_publisher` 正在发布到 `/robot_description` 主题。从这个主题获得的消息也包含了
    URDF 内容。这可以用来从任何其他节点检索 URDF，使用订阅者。
- en: That’s it for the first input; let’s see the second one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第一个输入的全部内容；让我们看看第二个。
- en: Joint states topic
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关节状态主题
- en: In order to publish the TFs, the **robot_state_publisher** node will need the
    URDF, but also the current state for each joint.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布 TFs，**robot_state_publisher** 节点需要 URDF，但也需要每个关节的当前状态。
- en: You can see the **/joint_states** topic in **rqt_graph** in *Figure 12**.1*.
    This topic contains what you would read from encoders or control feedback in a
    real robot. For example, if you have some wheels, you will get to know the speed
    and/or position of those wheels. You will feed this into the **/joint_states**
    topic. If you have a robotic arm, you usually have encoders on each axis reading
    the current position for the axis.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 **rqt_graph** 中看到 **/joint_states** 主题，如图 **12**.1 所示。这个主题包含了你在真实机器人中从编码器或控制反馈中读取的内容。例如，如果你有一些轮子，你会知道这些轮子的速度和/或位置。你将把这些信息喂入
    **/joint_states** 主题。如果你有一个机械臂，你通常在每个轴上都有编码器来读取轴的当前位置。
- en: When we simulate the robot with Gazebo, we will use a plugin that automatically
    publishes the joint states. In fact, either in simulation mode or for a real robot,
    you will usually have nodes doing this for you (to go further on this, check out
    ros2_control after reading this book—you can find extra resources about that in
    the last chapter of this book). So, all you need to know is that this **/joint_states**
    topic is important, as it’s required by **robot_state_publisher**. Publishing
    on this topic is done by existing ROS 2 plugins.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Gazebo 模拟机器人时，我们将使用一个插件来自动发布关节状态。实际上，无论是在模拟模式还是对于真实机器人，你通常都会有节点为你做这件事（要进一步了解这一点，阅读完这本书后请查看
    ros2_control——你可以在本书的最后一章找到关于它的额外资源）。所以，你需要知道的是，这个 **/joint_states** 主题非常重要，因为它被
    **robot_state_publisher** 所需要。在这个主题上的发布是由现有的 ROS 2 插件完成的。
- en: For now, as we don’t have any real robot or Gazebo simulation, we will use the
    **joint_state_publisher** node (with the **Joint State Publisher** window), which
    will publish whatever values we select on the cursors. For example, if you select
    **1.0** radian for **base_right_wheel_joint**, then **1.0** will be published
    on the **/joint_states** topic for that joint and will be received and used by
    **robot_state_publisher**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，因为我们没有真实的机器人或 Gazebo 模拟，我们将使用 **joint_state_publisher** 节点（带有 **Joint State
    Publisher** 窗口），它将发布我们在光标上选择的任何值。例如，如果你为 **base_right_wheel_joint** 选择 **1.0**
    弧度，那么 **1.0** 将被发布在该关节的 **/joint_states** 主题上，并被 **robot_state_publisher** 接收和使用。
- en: 'Here, it’s important to clarify the difference between joint states and TFs.
    A joint state is simply the *current state* of a joint. For example, for a wheel:
    what is the current velocity? For an axis in a robotic arm: what is the current
    angular position of the motor? The state is one data point, at one specific time,
    for one joint in your robot. It doesn’t specify anything about the relationship
    between joints, nor where they are located relative to each other—this is what
    a TF is.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，重要的是要明确关节状态和 TF 之间的区别。关节状态仅仅是关节的 *当前状态*。例如，对于一个轮子：当前的速率是多少？对于一个机械臂的轴：电机的当前角位置是多少？状态是一个数据点，在特定时间，对于你机器人中的一个关节。它不指定关节之间的关系，也不指定它们相对于彼此的位置——这就是
    TF 的作用。
- en: Recap – how to publish TFs
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾 – 如何发布 TF
- en: Let’s do a quick recap of what is required to publish TFs. This is what **urdf_tutorial**
    was doing for us, and what we will be doing by ourselves from now on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下发布 TF 所需的内容。这是 **urdf_tutorial** 为我们做的事情，也是从现在起我们将自己做的事情。
- en: '![Figure 12.2 – The required node and inputs to publish TFs](img/B22403_12_2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 发布 TF 所需的节点和输入](img/B22403_12_2.jpg)'
- en: Figure 12.2 – The required node and inputs to publish TFs
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 发布 TF 所需的节点和输入
- en: 'Here is what we need to do:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要做的事情：
- en: Start the `robot_state_publisher` node. This node is already installed. We give
    the URDF as the `robot_description` parameter.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `robot_state_publisher` 节点。这个节点已经安装好了。我们提供 URDF 作为 `robot_description` 参数。
- en: Publish the current state for all joints on the `/joint_states` topic. This
    is usually done automatically for you, either with data from encoders, a simulator
    such as Gazebo, or *fake* data from the `joint_state_publisher` node.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/joint_states` 主题上发布所有关节的当前状态。这通常由编码器、模拟器（如 Gazebo）或来自 `joint_state_publisher`
    节点的 *虚假* 数据自动为你完成。
- en: That’s all you have to do to correctly publish the TFs for your application.
    Those TFs will then be used by other nodes, plugins, and stacks, for example,
    the Navigation 2 or MoveIt 2 stacks (we won’t cover those in this book, but they
    would be a good topic to study afterward—more resources will be given in the last
    chapter of this book).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你正确发布应用程序 TF 所需要做的所有事情。这些 TF 将随后被其他节点、插件和堆栈使用，例如，Navigation 2 或 MoveIt 2
    堆栈（我们不会在本书中涵盖这些，但它们是之后一个好的学习主题——本书最后一章将提供更多资源）。
- en: Starting all nodes from the terminal
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从终端启动所有节点
- en: Before we package the application and write a launch file, let’s start all the
    nodes we need in the terminal. Doing this is a best practice so that you can make
    sure your application is working properly. Then, creating the package and the
    launch file will be easier, as you already know all the elements you need to include.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打包应用程序并编写启动文件之前，让我们在终端中启动所有需要的节点。这样做是一个最佳实践，这样你可以确保你的应用程序运行正常。然后，创建包和启动文件会更容易，因为你已经知道你需要包含的所有元素。
- en: We will use the result from the previous section and start the **robot_state_publisher**
    node, as well as the **joint_state_publisher** node. In addition to that, we will
    start RViz (this is optional and only used to visualize the robot model).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一节的结果并启动 **robot_state_publisher** 节点以及 **joint_state_publisher** 节点。除此之外，我们还将启动
    RViz（这是可选的，仅用于可视化机器人模型）。
- en: Publishing the TFs from the terminal
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从终端发布 TFs
- en: Let’s publish the TFs. For that, we will open two terminals.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发布 TFs。为此，我们将打开两个终端。
- en: 'In the first one, start the **robot_state_publisher** node. The package and
    executable names for this node are identical. To provide the **robot_description**
    parameter, you will have to use this syntax: **"$(****xacro <path_to_urdf>)"**.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个步骤中，启动 **robot_state_publisher** 节点。此节点的包和可执行文件名相同。要提供 **robot_description**
    参数，你必须使用以下语法：**"$(****xacro <path_to_urdf>)"**。
- en: 'In Terminal 1, run the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 1 中，运行以下命令：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you see this, everything is working fine. **robot_state_publisher** has been
    started with the URDF, and it’s ready to publish on the **/tf** topic. Now, we
    need to add a publisher on the **/joint_states** topic. We will use the **joint_state_publisher_gui**
    executable from the same package (note the extra **_gui** suffix, which means
    **graphical** **user interface**).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个，那么一切正常。**robot_state_publisher** 已经启动了 URDF，并且它已准备好在 **/tf** 主题上发布。现在，我们需要在
    **/joint_states** 主题上添加一个发布者。我们将使用来自同一包的 **joint_state_publisher_gui** 可执行文件（注意额外的
    **_gui** 后缀，表示 **图形** **用户界面**）。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a reminder, the executable name and node name are two different things. The
    executable name is the one you define in `setup.py` (for Python) or `CMakeLists.txt`
    (for C++). The node name is defined in the code and can be different. Here, we
    start the `joint_state_publisher_gui` executable, but the node name is `joint_state_publisher`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：可执行文件名和节点名是两回事。可执行文件名是在 `setup.py`（对于 Python）或 `CMakeLists.txt`（对于 C++）中定义的。节点名在代码中定义，可能不同。在这里，我们启动了
    `joint_state_publisher_gui` 可执行文件，但节点名是 `joint_state_publisher`。
- en: 'In Terminal 2, run the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端 2 中，运行以下命令：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will open the **Joint State Publisher** window that we previously used
    when experimenting with TFs and URDF. The values you see on the cursors will be
    published on the **/joint_states** topic and will be received by **robot_state_publisher**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开我们之前在实验 TFs 和 URDF 时使用的 **Joint State Publisher** 窗口。你将在光标上看到的值将被发布到 **/joint_states**
    主题，并由 **robot_state_publisher** 接收。
- en: That’s basically all we need. This will become the backbone of your ROS 2 application—of
    course, we will need to package this nicely and start it from a launch file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是我们需要做的。这将成为你的 ROS 2 应用程序的核心——当然，我们还需要将其打包并从启动文件中启动。
- en: If you run **rqt_graph**, you will see the same nodes and topics as in *Figure
    12**.1*. You can also print the TF tree (**ros2 run tf2_tools view_frames**) and
    listen to the **/tf** topic in the terminal (**ros2 topic** **echo /tf**).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 **rqt_graph**，你将看到与 *图 12.1* 中相同的节点和主题。你还可以打印 TF 树（**ros2 run tf2_tools
    view_frames**）并监听终端中的 **/tf** 主题（**ros2 topic echo /tf**）。
- en: Visualizing the robot model in RViz
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 RViz 中可视化机器人模型
- en: On top of what we did, we can visualize the robot in RViz. This is optional,
    and it’s something you will do mostly when you develop your application. After
    everything is working correctly and you switch to production mode, you won’t need
    to start RViz.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前所做的基础上，我们可以在 RViz 中可视化机器人。这是可选的，你将在开发应用程序时主要做这件事。当一切正常并且你切换到生产模式后，你将不需要启动
    RViz。
- en: Starting and configuring RViz
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动和配置 RViz
- en: Let’s start RViz and see how to visualize the robot model as well as the TFs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 RViz 并看看如何可视化机器人模型以及 TFs。
- en: 'Keep the **robot_state_publisher** and **joint_state_publisher** nodes running.
    Then, in Terminal 3, run the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 **robot_state_publisher** 和 **joint_state_publisher** 节点运行。然后，在终端 3 中，运行以下命令：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will open RViz, but, as you can see, there is no robot model, and we have
    some errors on the left menu:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 RViz，但正如你所看到的，没有机器人模型，左侧菜单中也有一些错误：
- en: '![Figure 12.3 – Rviz with no robot model and some errors](img/B22403_12_3.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – Rviz 没有机器人模型和一些错误](img/B22403_12_3.jpg)'
- en: Figure 12.3 – RViz with no robot model and some errors
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – RViz 没有机器人模型和一些错误
- en: We need to do a bit of configuration to correctly visualize the robot model
    and the TFs. Then, we will be able to save this configuration and reuse it the
    next time we start RViz.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些配置才能正确地可视化机器人模型和 TFs。然后，我们将能够保存此配置并在下次启动 RViz 时重用它。
- en: 'Follow these steps to configure RViz:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'In the left menu, `map` to `base_footprint`. After that, `Global Status: Error`
    should change to `Global` `Status: OK`.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** button on the left, scroll down, and double-click on **RobotModel**.
    You will have a new menu on the left side of RViz.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open this new `/robot_description`. After this, the robot model should appear
    on the screen.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add** button again, scroll down, and double-click on **TF**.
    This will open a new menu, and you will see the TFs appear on the screen.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to see through the model, like we did before, open `1` to `0.8,`
    for example.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can remove the extra menus on the right (**Views**) and at the bottom (**Time**)
    to get more space for the robot.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With all those settings, you should see the robot model and TFs the same way
    we did when we previously visualized the URDF with the **urdf_tutorial** package:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.4 – RViz with the robo\uFEFFt model and TFs](img/B22403_12_4.jpg)"
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – RViz with the robot model and TFs
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Saving the RViz configuration
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to repeat those steps every time you start RViz. To avoid doing
    this, we will save the configuration.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Click on **File** | **Save Config As**. Let’s name the file **urdf_config.rviz**
    (for these files, use the **.rviz** extension), and place it inside your home
    directory for now.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you can see the file, using a file manager or the terminal. If you
    didn’t save the file correctly, you will need to manually do the full configuration
    again. Once the file is saved, you can stop RViz (*Ctrl + C* in the terminal).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when you start RViz again, you can add an extra **-d** argument with
    the path to the configuration file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will start RViz exactly like you saved it: same menus, same view, same
    zoom, and so on. We will reuse this configuration file throughout this chapter.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to change the configuration, all you have to do is modify whichever
    settings you want in RViz, save a new configuration file, and use this one instead.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have everything we need: the URDF files and the RViz config file, and
    we know what nodes and parameters we have to start, and how to start them.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now organize everything properly into a ROS 2 package. We will first create
    the package, and then add a launch file to start all the nodes at once.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Creating a package to install the URDF
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the files we have created are now in our home directory. It’s time to create
    a ROS 2 package and move all the files into the right place so that they can be
    installed and used in our ROS 2 workspace.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a package dedicated to the robot model. Then, we will
    install all the files required for this application. This will allow us to use
    the URDF and RViz files when we write a launch file, to start all the nodes we
    have seen previously.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a new package, but before we do that, it could be a good idea to
    create a new ROS 2 workspace.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new workspace
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of now, our **ros2_ws** workspace contains all the code used in *Part 2*
    of this book, including various examples to illustrate the core concepts, a robot
    controller for the Turtlesim, some custom interfaces, and launch files. We don’t
    need any of those for the *Part 3* project; so, instead of continuing to add more
    things to this workspace, we will create a new one. As a general rule, if you
    have two different applications, you will have two different workspaces.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 **ros2_ws** 工作区包含了本书 *第2部分* 中使用的所有代码，包括各种示例来阐述核心概念，Turtlesim 的机器人控制器，一些自定义接口和启动文件。对于
    *第3部分* 项目，我们不需要这些；因此，我们不会继续向这个工作区添加更多内容，而是创建一个新的工作区。作为一个一般规则，如果你有两个不同的应用程序，你将有两个不同的工作区。
- en: Let’s then create a new workspace named **my_robot_ws**. A good practice is
    to name the workspace as per your application or robot name. This will help you
    avoid confusion in the long term.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为 **my_robot_ws** 的新工作区。一个好的做法是将工作区命名为你的应用程序或机器人名称。这将在长期内帮助你避免混淆。
- en: 'Create a new workspace in your home directory:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的家目录中创建一个新的工作区：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, inside this workspace, create a **src** directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这个工作区内部创建一个 **src** 目录：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, and this is super important, you can have as many ROS 2 workspaces as you
    want, but you should not work with two workspaces for two different applications
    at the same time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，并且这非常重要，你可以拥有任意多的 ROS 2 工作区，但你不应该同时使用两个不同应用程序的工作区。
- en: 'You are currently sourcing the **ros2_ws** workspace every time you open a
    terminal. If you remember, you added an extra line in **.bashrc** to do that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你目前每次打开终端时都在源化 **ros2_ws** 工作区。如果你记得，你在 **.bashrc** 中添加了一行额外的代码来做这件事：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open the **.bashrc** file again and comment that line (add **#** in front of
    the line). Now, close all terminals, open a new one, and let’s build and source
    our new workspace:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开 **.bashrc** 文件并注释掉那一行（在行前添加 **#**）。现在，关闭所有终端，打开一个新的终端，然后构建并源化我们的新工作区：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the **.bashrc** again and add a line to source this new workspace. The
    end of **.bashrc** will look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开 **.bashrc** 并添加一行来源化这个新的工作区。**.bashrc** 的末尾将看起来像这样：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As a reminder, we first source the global ROS 2 installation. Then, we source
    our workspace. Commenting the workspaces you don’t use is very practical. This
    way, if you want to switch between two workspaces, you just have to uncomment/comment
    the two lines, close all terminals, and open a new terminal to source the workspace
    you want to use.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我们首先源化全局 ROS 2 安装。然后，我们源化我们的工作区。注释掉不使用的工作区是非常实用的。这样，如果你想在这两个工作区之间切换，你只需要取消注释/注释这两行，关闭所有终端，然后打开一个新的终端来源化你想要使用的工作区。
- en: Creating a _description package
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 _description 包
- en: Now that we have this new empty workspace correctly configured and sourced,
    let’s add a new package inside.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确配置并源化了这个新的空工作区，让我们在里面添加一个新的包。
- en: To name the package, we use the robot’s name, followed by **_description**.
    This is a common convention used by lots of ROS developers. By using this naming
    format, you make it clear that this package will contain the URDF files for your
    robot. This will make collaboration easier.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了命名包，我们使用机器人的名称，后面跟着 **_description**。这是许多 ROS 开发者使用的一个常见约定。通过使用这种命名格式，你可以清楚地知道这个包将包含你的机器人的
    URDF 文件。这将使协作变得更加容易。
- en: 'To create this new package, we use the **ament_cmake** build type, just as
    if we were creating a C++ package, and we don’t specify any dependencies. Let’s
    create the package:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个新包，我们使用 **ament_cmake** 构建类型，就像我们创建一个 C++ 包一样，并且我们不指定任何依赖项。让我们创建这个包：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For now, this package is a standard C++ ROS 2 package. However, we won’t write
    any nodes inside. We just need the package to install our robot model. Thus, you
    can remove the **src** and **include** directories:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个包是一个标准的 C++ ROS 2 包。然而，我们不会在其中编写任何节点。我们只需要这个包来安装我们的机器人模型。因此，你可以删除 **src**
    和 **include** 目录：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, your package will only contain two files: **package.xml** and
    **CMakeLists.txt**.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的包将只包含两个文件：**package.xml** 和 **CMakeLists.txt**。
- en: 'Open the workspace with an IDE. If you’re using VS code, run the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDE 打开工作区。如果你使用 VS code，运行以下命令：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To clean things a bit more, we will simplify the **CMakeLists.txt** file. Remove
    the comments after the **find_package(ament_cmake REQUIRED)** line, and, as we
    don’t need that now, remove the **if(BUILD_TESTING)** block. Make sure you keep
    the **ament_package()** instruction, which should be the last line of the file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Installing the URDF and other files
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our **robot_description** package, let’s install all the files
    we need. To install a file, we will follow this process:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder to host the files.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instruction in `CMakeLists.txt` to install the folder.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we will see how to install the URDF files, custom meshes, and the RViz
    configuration.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Installing Xacro and URDF files
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install our Xacro and URDF files, go inside the **my_robot_description**
    package and create a new folder named **urdf**:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can now move all three Xacro files inside this **urdf** folder: **common_properties.xacro,
    mobile_base.xacro**, and **my_robot.urdf.xacro**.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything should work fine, but to make the **include** paths more robust,
    let’s modify the **<xacro:include>** tags inside **my_robot.urdf.xacro**:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instead of providing only the relative path (which should still work in this
    case), we provide the absolute path to where the files will be installed, using
    the **find** keyword before the package name.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open **CMakeLists.txt**, and add those instructions to install the **urdf**
    folder:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will install the **urdf** folder inside a **share** directory when you
    build the package. It will allow any package from the workspace to find the URDF
    for your robot. This is actually very similar to what we’ve done in [*Chapter
    9*](B22403_09.xhtml#_idTextAnchor443) when installing launch files and param files.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now continue with custom meshes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Installing custom meshes
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not using any custom mesh for now (which is probably the case if
    you are learning ROS 2 from scratch with this book), you can skip this small section
    and go to the RViz configuration directly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: I briefly mentioned custom meshes in [*Chapter 11*](B22403_11.xhtml#_idTextAnchor519),
    when we were creating links for the URDF. If you happen to include custom meshes
    with the **<mesh>** tag, inside the **<visual>** tag of a link, you will have
    to install the corresponding mesh files (with the **.stl** or **.****dae** extension).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, in **my_robot_description**, you would create a new folder named
    **meshes**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this folder, you would add all the **.stl** and **.dae** files you want
    to use in your URDF. Then, let’s say you have added a file named **base.stl**.
    In the URDF, you will use this syntax to include it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To install the **meshes** folder, you also have to add an instruction in **CMakeLists.txt**.
    As we already added the **install()** block previously, you just need to add the
    name of the new folder you want to install:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: When adding new folder names after `DIRECTORY`, you can either separate them
    with a space or put them on a new line; it won’t make a difference.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for custom meshes. Even though we don’t use them now, I wanted to
    include this, so that you have all the required knowledge to create a complete
    URDF with custom shapes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Installing the RViz configuration
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s finish this section by installing the RViz configuration we previously
    saved. This way, when we start RViz later on from a launch file, we can use this
    configuration directly from the package.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an **rviz** folder inside the package:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Move the **urdf_config.rviz** file into this new **rviz** folder.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to install the folder, add its name to the **install()** instruction,
    inside **CMakeLists.txt**:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We now have all the files we need for this package. Before we install them (with
    **colcon build**), let’s add a launch file so we can start all the required nodes
    to publish the TFs as well as visualize the robot model in RViz.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Writing a launch file to publish TFs and visualize the robot
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **my_robot_description** package is finished, but we will add a launch file
    so we can start all the nodes and parameters that we discovered at the beginning
    of this chapter. This way, we can publish TFs and visualize the robot in RViz.
    This will also be a good practice exercise on launch files, and we will reuse
    part of the code in the next chapter when we build the Gazebo simulation for the
    robot.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we add all launch files inside a `_bringup` package (dedicated package
    used for launch and configuration files). Here, we make an exception, because
    this launch file will be used only for visualization and development. Any other
    launch file that we write for this application will be placed inside the `my_robot_bringup`
    package (which we will create in the next chapter).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: We will write the launch file first with XML, and then with Python. This will
    be another example of how XML launch files can be easier to write than Python
    ones.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The XML launch file
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before writing any launch file, we first need to create a **launch** folder,
    where we will put all our launch files for the **my_robot_description** package.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Creating and installing a launch folder
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create and install a **launch** folder, we will follow the same process
    as before. First, create the folder:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, to specify the instructions to install this folder, it’s as easy as adding
    the folder name inside **CMakeLists.txt**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As the **install()** instruction was already configured, if we want to install
    a new folder, we just add its name after the other ones. For now, we are installing
    four folders in this package.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, create a new launch file inside the folder. We will name
    it **display.launch.xml**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let’s write the content for this launch file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Writing the launch file
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this launch file, we will simply start the nodes and parameters that we
    discovered and listed at the beginning of this chapter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '`robot_state_publisher` with the URDF as the `robot_description` parameter.
    This node will publish on the `/``tf` topic.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`joint_state_publisher` to publish on the `/``joint_states` topic.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rviz2`, as we also want to visualize the robot model.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already know how to start those nodes from the terminal; now, all we have
    to do is add them inside one launch file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'In the launch file, first open and close a **<****launch>** tag:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, make sure to write all the following lines inside this **<launch>** tag.
    You can also add an indentation (four spaces) for those lines.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: As we will need to find the path of the URDF file and the RViz configuration
    file, we add two variables at the beginning of the launch file, to make the file
    cleaner and more readable. Also, if you have to modify those values later, you
    know that you just have to modify the variables at the top of the file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven’t seen how to add (constant) variables yet in a launch file, but it’s
    not too complicated. You will use the **<let>** tag with two arguments: **name**
    and **value**. Let’s add the two variables we need:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then, to use a variable, you can write **$(****var name)**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the XML syntax looks similar between launch files and Xacro files,
    make sure not to mix things up: *To find a package*, you use `find-pkg-share`
    in a launch file and `find` with Xacro. *To use a variable*, you use `$(var name)`
    in a launch file and `${name}` with Xacro.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start all the nodes we need, one by one. Here is the code for the
    **robot_state_publisher** node:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Nothing special here; we use the same values as in the command we previously
    ran in the terminal. To specify a command to run in an XML launch file, you can
    use **$(****command '...')**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can start the **joint_state_publisher** node. Here, we use the executable
    with the **_gui** suffix to get a graphical window with cursors to move the joints:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This node is easy to write, as we don’t need to provide anything else except
    the package and executable. Let’s finish with the RViz node:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this node, we provide the saved RViz configuration file, using the **-****d**
    option.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Starting the launch file
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The launch file is now complete. We can build the workspace to install all
    the files and folders that we’ve added:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, don’t forget to source the workspace (**source install/setup.bash**),
    and you can start your new launch file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After running this command, you should see your robot model in RViz with the
    TFs. If you list nodes and topics on the terminal, you should be able to find
    everything that we have started. With **rqt_graph**, you should also get the same
    result as when we started all three nodes from the terminal.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The **my_robot_description** package is now complete. We have installed all
    the files that we need: URDF, custom meshes, RViz configuration, and a launch
    file to publish TFs and visualize the robot model. Before we wrap things up, let’s
    talk briefly about the Python version of the launch file.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The Python launch file
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will finish this chapter with the Python launch file to do the same thing:
    start the **robot_state_publisher**, **joint_state_publisher**, and RViz. The
    main reason I do this here is to provide another example to emphasize the difference
    between Python and XML launch files. You can see this as an extension of what
    we discussed during [*Chapter 9*](B22403_09.xhtml#_idTextAnchor443), *XML versus
    Python for* *launch files*.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also the last time I use Python for launch files, as in the next chapter
    on Gazebo, we will focus only on XML (as a reminder: If you ever need to use an
    existing Python launch file, you can include it inside an XML launch file, so
    there is no problem here).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now create the Python launch file. To do that, create a new file inside
    the **launch** folder of the **my_robot_description** package. You can name this
    file **display.launch.py**—the same name as for the XML launch file, but with
    a Python extension.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to add any extra configuration in the package, as **CMakeLists.txt**
    already contains the instructions to install the **launch** folder.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start to analyze this Python file (you can find the full code for this
    file in the book’s GitHub repository) with the import lines:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see, that’s a lot of things to import, and it could be easy to make
    mistakes here. After the imports, we start the **generate_launch_description**
    function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All the code we have from now on will be inside this function (with an indentation).
    We create the two variables for the URDF and RViz path:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To make things a bit more readable, we also create a variable for the **robot_description**
    parameter:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we start the three nodes:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we need to return a **LaunchDescription** object with all the nodes
    we want to start:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, the code is much longer: 38 lines for Python versus 15 lines
    for XML. We could optimize the spaces, but even with that, there would still be
    a factor of two. Also, I personally find the Python syntax more complex and not
    really intuitive. To be honest with you, the only way I manage to write Python
    launch files is just by scrapping bits of code from existing projects I find on
    GitHub and seeing if it works.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: I’m not going to provide much more details than that, as this code was here
    mainly so we can have another example of what we discussed back in [*Chapter 9*](B22403_09.xhtml#_idTextAnchor443).
    We will continue with XML launch files going forward.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have published the TFs for your robot and properly packaged
    your application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'You first discovered that the most important node to start is **robot_state_publisher**,
    with two inputs: the URDF in the **robot_description** parameter, and the current
    states for each joint on the **/****joint_states** topic.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: From this, you started all the nodes and parameters from the terminal so that
    you could reproduce the output we previously had with the **urdf_tutorial** package.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you created your own package to correctly organize your application.
    Here is the final architecture for this package, with all the files and folders:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This organization is very standard. If you look at the code for almost any robot
    powered by ROS, you will find this **_description** package using more or less
    the same architecture. Thus, creating this package was not only helpful for the
    process we follow in this book but also for you to easily start working on any
    other project made by ROS developers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: We will now use this package as the base for the next chapter, where we will
    learn how to create a simulation for the robot using Gazebo.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
