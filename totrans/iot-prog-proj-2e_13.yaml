- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Advanced Robotic Eyes for Security (A.R.E.S.)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will convert our TurtleSim virtual robot to a real-life
    robot we will call A.R.E.S. (short for Advanced Robotic Eyes for Security). A.R.E.S.
    will feature a video feed that we view over our local network using the VLC media
    player. We will control A.R.E.S. using the IoT joystick we created in [*Chapter
    12*](B21282_12.xhtml#_idTextAnchor195).
  prefs: []
  type: TYPE_NORMAL
- en: We will construct A.R.E.S. using a Raspberry Pi as the brain or sensory input
    and a Raspberry Pi Pico for control of the motors, LEDs, and buzzer. We will use
    standard motors and a robotics board with our Raspberry Pi Pico H for motor control.
    We will 3D print the frame using the `.stl` files located in the `Build Files`
    directory of this chapter’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring our A.R.E.S. application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing A.R.E.S.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software setup and configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming A.R.E.S. with ROS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will require the following to learn comprehensively from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of the Linux command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CloudAMQP account for the MQTT server instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IoT joystick from [*Chapter 12*](B21282_12.xhtml#_idTextAnchor195)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 3D printer or 3D printing service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build files for custom cases may be found in our GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Constructing A.R.E.S.* section for hardware components required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter may be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter13
  prefs: []
  type: TYPE_NORMAL
- en: Exploring our A.R.E.S. application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The A.R.E.S. robot presents an integration of various IoT components. It’s
    operated via the IoT joystick we created in [*Chapter 12*](B21282_12.xhtml#_idTextAnchor195)
    and communicates commands through MQTT to the Raspberry Pi. Our design will incorporate
    both a Raspberry Pi 3B+ and a Raspberry Pi Pico H. In the following diagram, we
    see the outline of the A.R.E.S. robot, including the connection from the IoT joystick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The A.R.E.S. robot application](img/B21282_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – The A.R.E.S. robot application
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 3B+, serving as the brain, uses **UART** (short for **Universal
    Asynchronous Receiver/Transmitter**) communication to relay commands to a Raspberry
    Pi Pico H, which in turn controls the car’s movements, LEDs, and buzzer, responding
    dynamically to inputs. Equipped with a VL53L0X sensor, A.R.E.S. can measure distances,
    allowing it to avoid obstacles. Additionally, an M5Stack camera mounted on A.R.E.S.
    streams real-time video, which can be viewed on any computer using a VLC media
    player via the **Real-Time Streaming** **Protocol** (**RTSP**).
  prefs: []
  type: TYPE_NORMAL
- en: Using a Raspberry Pi 3B+ for A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
- en: For A.R.E.S., we’re selecting the Raspberry Pi 3B+ over newer models such as
    the 4 or 5 due to its power efficiency and cost. Its ability to run on standard
    cell phone battery packs makes it ideal for our needs, while its lower price and
    availability as a current model ensure both economic and practical benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Kicking off the A.R.E.S. robot project, we’ll first assemble the 3D-printed
    frame and install the necessary components. A.R.E.S. is engineered for compactness,
    making it an ideal robotic platform for educational purposes. Once the frame is
    complete, we’ll move on to software, configuring the operating system on our Raspberry
    Pi 3B+ and programming the Raspberry Pi Pico H. Let’s begin with constructing
    the frame.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing A.R.E.S.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A.R.E.S. consists of a frame made with 3D-printed parts and common components
    such as DC motors, LEDs, a Raspberry Pi 3B+, a Raspberry Pi Pico H, **ToF** (short
    for **time of flight**), a sensor, a Wi-Fi camera, battery packs, and various
    bolts and screws.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our construction of A.R.E.S. by identifying the 3D-printed parts.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the 3D-printed frame parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We may find the `.stl` files of these parts under the `Build Files` directory
    of this chapter’s GitHub repository. In the following figure, we see the parts
    printed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – A.R.E.S. 3D-printed parts](img/B21282_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – A.R.E.S. 3D-printed parts
  prefs: []
  type: TYPE_NORMAL
- en: 'The 3D-printed parts that make up the frame of A.R.E.S. are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A*: Base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*B*: Shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C*: Face'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: Battery pack riser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E*: Motor bracket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F*: Testing stand (optional base used for testing purposes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the 3D-printed frame parts identified, let’s look at the components used
    to construct A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the components used to create A.R.E.S.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The components we use to construct A.R.E.S. are standard electronic components
    and may be easily purchased online from vendors such as Amazon or AliExpress.
    The following figure outlines the components we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Components that make up the A.R.E.S. robot](img/B21282_13_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Components that make up the A.R.E.S. robot
  prefs: []
  type: TYPE_NORMAL
- en: 'The components to construct A.R.E.S. are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A*: 2 x LED with 220 Ohm resistor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*B*: 2 x 5 mm (8 mm wide) LED holder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C*: 2 x TT DC robot motor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: M5Stack Timer Camera X with mount (not shown)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E*: Adafruit VL53L0X ToF sensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F*: 2 x TT robot car wheel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*G*: SFM-27 buzzer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*H*: Raspberry Pi 3B+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I*: Battery pack for 4 AA batteries (with batteries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*J*: Cell phone USB battery pack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*K*: Raspberry Pi Pico H with Kitronik Simply Robotics Motor Driver Board'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*L*: micro-USB to USB cable (short)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*M*: Grove connector to female jumper wire connectors for connecting the camera
    to the GPIO ports of the Raspberry Pi 3B+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N*: 4 x 2 mm thick, 18 mm diameter magnets with double-sided adhesive pads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*O*: Caster (32 mm width)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NOT SHOWN*: 18 x M3 10 mm bolts, 4 x M3 20 mm bolts, 8 x M3 nuts, 6 x M2.5
    10 mm bolts, 2 x M4 10 mm bolts, 4 x M2.5 40 mm standoffs, 3 x M3 20 mm standoffs,
    jumper wires, crimping kit with connectors and wires (optional but recommended),
    hot glue gun, soldering iron'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our components in place, let’s start to build our A.R.E.S. robot.
  prefs: []
  type: TYPE_NORMAL
- en: Building A.R.E.S.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using our 3D-printed frame parts and electronic components, it is now time
    to build A.R.E.S. To construct A.R.E.S., we use the following diagram as a guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Building the A.R.E.S. robot](img/B21282_13_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Building the A.R.E.S. robot
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows (the numbered steps also correspond to the numbered
    components in the figure):'
  prefs: []
  type: TYPE_NORMAL
- en: Using double-sided adhesive tape (usually packaged with the product), we secure
    two magnets (*N* from *Figure 13**.3*) to the shell (*B* from *Figure 13**.2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the opposite polarity magnets (*N* from *Figure 13**.3*), we attach the
    magnets (be sure to test before fastening) to the base (*A* from *Figure 13**.2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using two M4 10 mm bolts, we fasten the SFM-27 buzzer (*G* from *Figure 13**.3*)
    to the base (*A* from *Figure 13**.2*). The bolts should tap into the buzzer base;
    however, M4 nuts may be required. In this step, we also secure the caster (*O*
    from *Figure 13**.3*) to the base (*A* from *Figure 13**.2*) using two M3 bolts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We solder 20 cm wires to each of the terminals of the TT motor (*C* from *Figure
    13**.3*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the motor bracket (*E* from *Figure 13**.2*), we fasten the TT motors
    (*C* from *Figure 13**.3*) with the TT robot car wheel (*F* from *Figure 13**.3*)
    to the base (*A* from *Figure 13**.2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using two M3 10 mm bolts, we fasten the camera mount that comes with the M5Stack
    Timer Camera X (*D* from *Figure 13**.3*) to the face (*C* from *Figure 13**.2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the LED holders (*B* from *Figure 13**.3*) and LEDs with resistors (*A*
    from *Figure 13**.3*), we thread the LEDs through the appropriate holes in the
    face (*C* from *Figure 13**.2*). We secure the VL53L0X ToF sensor (*E* from *Figure
    13**.3*) to the face (*C* from *Figure 13**.2*) using glue from a hot glue gun.
    We may also glue the LEDs in place to keep them from moving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access to the GP pins on the Raspberry Pi Pico H is required, but they are engaged
    within the motor board’s **DIP** (short for **Dual Inline Package**) socket, rendering
    them inaccessible. To overcome this, we need to solder header pins to the underside
    of the motor board, enabling us to connect the SFM-27 buzzer (*G* from *Figure
    13**.3*) and LEDs with resistors (*A* from *Figure 13**.3*) to the Raspberry Pi
    Pico H.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We secure four M2.5 40 mm standoffs to the front of the base (*A* from *Figure
    13**.2*) and three M3 20 mm standoffs to the back of the base (*A* from *Figure
    13**.2*) using 10 mm M2.5 and 10 mm M3 bolts respectively. We may secure the Raspberry
    Pi 3B+ (*H* from *Figure 13**.3*) and Pico H with the motor board (*K* from *Figure
    13**.3*) to the standoffs; however, this will only be temporary as these components
    will be moved around as we wire up A.R.E.S. We may also temporarily place the
    battery pack riser (*D* from *Figure 13**.2*) in place. We use the riser to cover
    the wires and provide a flat surface to place the battery pack (*I* from *Figure*
    *13**.3*) on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the frame assembled and components in place, it is now time to wire our
    components to the Raspberry Pi and Pico H.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up A.R.E.S.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wiring up A.R.E.S. requires connections to the Raspberry Pi 3B+ and Kitronik
    motor board. Using *Figure 13**.1* as a reference, we can see that we connect
    the VL53L0X ToF sensor and M5Stack Timer Camera X to the Raspberry Pi 3B+, and
    the TT DC robot motors, LEDs with resistors, and buzzer to the Raspberry Pi Pico
    H using the motor board. We also wire the Raspberry Pi 3B+ to the Raspberry Pi
    Pico H to each other for use with UART communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start our wiring with robot motors. In the following figure, we see a closeup
    of the motor board with the terminals to connect the battery pack and motors highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Kitronik motor board for the Raspberry Pi Pico H](img/B21282_13_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Kitronik motor board for the Raspberry Pi Pico H
  prefs: []
  type: TYPE_NORMAL
- en: 'To wire up our motors, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Attach the wires from the right motor, as depicted in *Step 9* of *Figure 13**.4*,
    to **Motor0** on the motor board. The polarity of the wires is not critical at
    this stage since we can correct their orientation later if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the wires from the left motor to **Motor1** on the motor board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the wires from the AA battery pack to the battery terminals on the motor
    board, taking polarity into account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the robot motors and battery wires attached, it is now time to wire up
    the rest of the components. We will be using standard female jumper wires to make
    the connections. Although not required, having the ability to create our own jumper
    wires using a crimping kit makes for a clean and organized wiring setup. We use
    the wiring diagram in *Figure 13**.6* for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Component wiring diagram for A.R.E.S.](img/B21282_13_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Component wiring diagram for A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wire up the rest of our components, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a grove connector to the female jumper wire connectors (*M* from *Figure
    13**.3*), we connect the M5Stack Timer Camera X to the Raspberry Pi 3B+ by attaching
    5V from the Raspberry Pi to the V connector on the camera, and GND from the Raspberry
    Pi to G on the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect VIN on the ToF sensor to 3.3V on the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect SDA on the ToF sensor to SDA (GPIO 2) on the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect SCL on the ToF sensor to SCL (GPIO 3) on the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect GND on the ToF sensor to GND on the Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect TX (GPIO 14) on the Raspberry Pi to RX (GP5) on the Raspberry Pi
    Pico H or pin 7 on the motor board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect RX (GPIO 15) on the Raspberry Pi to TX (GP4) on the Raspberry Pi
    Pico H or pin 6 on the motor board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect GND on the Raspberry Pi to GND on the Raspberry Pi Pico H or a GND
    (0V) pin on the motor board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect the positive wire on the SFM-27 buzzer to GP0 on the Raspberry Pi
    Pico H or pin 1 on the motor board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect the negative wire on the SFM-27 buzzer to a GND (0V) pin on the motor
    board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect the positive ends of the LEDs with resistors to GP1 and GP2 or pins
    2 and 4 on the motor board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect the negative ends of the LEDs with resistors to a GND (0V) pin on
    the motor board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We may need to move the Raspberry Pi and motor board around as we make the connections.
    Also, it is advisable that we do not attach the face (*C* from *Figure 13**.2*)
    to the base (*A* from *Figure 13**.2*) initially as we require access to the microSD
    port on the Raspberry Pi 3B+.
  prefs: []
  type: TYPE_NORMAL
- en: With the wiring in place, let’s set up the software for A.R.E.S. We will start
    by installing Ubuntu onto our Raspberry Pi 3B+.
  prefs: []
  type: TYPE_NORMAL
- en: Software setup and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up the software architecture of A.R.E.S., we will run a script from this
    chapter’s GitHub repository. The script starts by ensuring that it is run with
    root privileges, updates and upgrades the system, and installs essential utilities
    and interfaces such as **I2C** (short for **Inter-Integrated Circuit**) and UART.
    It then proceeds to install Adafruit Blinka to support CircuitPython libraries,
    set up ROS Humble Hawksbill for robotics programming, and install the Colcon build
    system for software compilation.
  prefs: []
  type: TYPE_NORMAL
- en: The script also takes care of dependency management through `rosdep` and adds
    the ROS 2 environment setup to the `bashrc` file for easy access. By the end of
    the process, our Raspberry Pi 3B+ is fully configured for A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the script, we will use the Raspberry Pi Imager to burn Ubuntu
    onto a microSD card and install the card onto our Raspberry Pi 3B+. As the slot
    for the microSD card is in the front of the A.R.E.S. robot, the face will cover
    it. Thus, we will keep the face disconnected from the base while we install Ubuntu,
    as we see in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Side view of A.R.E.S. with the face detached to allow access
    to the microSD card](img/B21282_13_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Side view of A.R.E.S. with the face detached to allow access to
    the microSD card
  prefs: []
  type: TYPE_NORMAL
- en: We will run the Raspberry Pi Imager from a computer of our choice. For the examples
    in this chapter, we will install it on a Windows computer.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ubuntu onto our Raspberry Pi 3B+
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Raspberry Pi Imager is a versatile tool designed to simplify the process
    of installing operating systems on Raspberry Pi devices. Developed by the Raspberry
    Pi Foundation, this utility allows us to flash various operating systems onto
    an SD card, which can then be used to boot and run on a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: While the Raspberry Pi Imager primarily supports the installation of Raspberry
    Pi OS (formerly known as Raspbian), its capabilities extend to a range of other
    operating systems. This allows us to experiment with different environments or
    require specific functionalities that are better supported by alternative OSs.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Raspberry Pi Imager, we simply download and install the application
    on our computer, select the desired operating system from its extensive list,
    and then choose the target SD card for installation. The Raspberry Pi Imager can
    be installed on various operating systems, including Windows, macOS, and Linux.
    For example, in this chapter, we will install it onto a Windows machine. We will
    burn a command-line version of Ubuntu 22.04 to correspond to the Humble Hawksbill
    version of ROS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Raspberry Pi Imager to install Ubuntu onto the Raspberry Pi 3B+
    on our A.R.E.S. robot, we navigate to the URL and download the imager for the
    OS we are using ([https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/))
    and proceed to install the tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We insert our microSD into a port on our computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After installation, we open the tool and select **RASPBERRY PI 3** for **Raspberry
    Pi Device**, **UBUNTU SERVER 22.04.4 LTS (64-BIT)** for **Operating System**,
    and the microSD card we inserted for the **Storage** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Setting up the Raspberry Pi Imager](img/B21282_13_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Setting up the Raspberry Pi Imager
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed, we click on the **NEXT** button. This will bring us to the **Use
    OS** **customisation?** dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Imager customization dialog](img/B21282_13_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Imager customization dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'As we would like to set the name of the computer and the network, we click
    on the **EDIT SETTINGS** button and get the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.10 – OS Customisation screen](img/B21282_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – OS Customisation screen
  prefs: []
  type: TYPE_NORMAL
- en: We set both the hostname and username to `ares`. We provide a password for the
    username and enter our SSID (LAN network) and SSID password.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable remote access through SSH, we click on the **SERVICES** tab at the
    top and select **Enable SSH**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21282_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – Enable SSH
  prefs: []
  type: TYPE_NORMAL
- en: To save our settings, we click on the **SAVE** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To apply the settings, we click on the **YES** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will then be presented with a warning:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B21282_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – Warning message
  prefs: []
  type: TYPE_NORMAL
- en: We click on **YES** as we want to erase any data on our microSD card and replace
    it with the Ubuntu operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Raspberry Pi Imager will then proceed to install the Ubuntu 22.04 operating
    system onto our microSD card, which we will install onto the Raspberry Pi 3B+
    on A.R.E.S. We will not need to set up a Wi-Fi network or enable SSH.
  prefs: []
  type: TYPE_NORMAL
- en: With Ubuntu installed, it is now time to install ROS and the Python libraries
    we need for A.R.E.S. We will automate this with a specialized script stored in
    our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Running the installation script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous chapters, we manually installed development libraries, a thorough
    yet time-intensive process. Now, leveraging our familiarity with Python libraries,
    we will streamline the setup of A.R.E.S. with ROS and necessary libraries through
    a script from our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Executed with root privileges on Ubuntu, this script automates the installation,
    including ROS. Despite the direct installation into the OS diverging from *best
    practices*, it simplifies the process. For future projects, it is suggested that
    readers explore containerization with tools such as Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the A.R.E.S. installation script, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using *Figure 13**.7* as a reference, we ensure that we have access to the ports
    on the Raspberry Pi 3B+.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We connect a monitor, keyboard, and mouse to our Raspberry Pi and insert the
    freshly imaged microSD card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the server version of Ubuntu is command-line based, we will not be presented
    with a GUI when we boot up our Raspberry Pi. We log in using the credentials set
    during the imaging process. We should be in the `home` directory once logged in.
    We may verify this with the `pwd` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Verifying current directory](img/B21282_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – Verifying current directory
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup script is in the book’s GitHub repository. To download the script
    and the Python code we use for the A.R.E.S. robot, we clone the repository onto
    our Raspberry Pi with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/B21282_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.14 – Cloning repository
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is located inside subdirectories of the `code` directory. We copy
    it to our current directory (`.`) with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We verify that our script was copied over successfully with the `ls` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21282_13_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.15 – Verifying successful copy of setup script
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute the script with admin privileges with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the script with admin privileges ensures it has the necessary permissions
    to perform system-level changes and installations without encountering access
    restrictions. Our script initially updates our system before installing ROS and
    the necessary Python libraries. It should take several minutes to complete. After
    completion, we should be presented with the IP address of our machine so that
    we may log in remotely with SSH. This will be necessary when A.R.E.S. is running
    remotely:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.16 – Result of running the setup script](img/B21282_13_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.16 – Result of running the setup script
  prefs: []
  type: TYPE_NORMAL
- en: 'With the completion of our setup script, we are now able to fasten the robot
    face to the base plate of A.R.E.S.:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21282_13_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.17 – Front view of A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
- en: With the construction of A.R.E.S. and the OS on our Raspberry Pi 3B+ installed,
    it is time to install the code on our Raspberry Pi Pico H. Referring to *Figure
    13**.1*, we can see that A.R.E.S. uses the Pico H to control the motors, LEDs,
    and buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by writing code to control the LED and buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating alarm code for the Pico H
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To program our Pico H, we will need to connect a micro-USB cable to the USB
    port on the Pico H. Despite our intentions to stagger the heights of the Pico
    H and Raspberry Pi 3B+, we may need to temporarily dismount the Raspberry Pi 3B+
    from its standoffs to attach the micro-USB cable to the Pico H.
  prefs: []
  type: TYPE_NORMAL
- en: Once the micro-USB cable is attached, we may plug our Pico H into a computer
    of our choice and run Thonny. We will create a class called `Alarm` inside a file
    called `device_alarm.py` on our Pico H to encapsulate the alarm functionality.
    For simplicity’s sake, we will couple the flashing of the LEDs with the activation
    of the buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to the *Setting up our Raspberry Pi Pico WH* section from [*Chapter
    12*](B21282_12.xhtml#_idTextAnchor195), we install CircuitPython onto our Raspberry
    Pi Pico although we select **Raspberry Pi • Pico / Pico H** for the **CircuitPython**
    **variant** option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21282_13_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.18 – Installing CircuitPython onto our Raspberry Pi Pico H
  prefs: []
  type: TYPE_NORMAL
- en: We then activate the CircuitPython environment on our Pico H by selecting it
    from the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new editor, we start our code with the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import time`: Provides time-related functions, enabling tasks such as introducing
    delays in the program execution, which is useful for controlling the flow and
    timing of operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import board`: Accesses board-specific pins and hardware interfaces, crucial
    for interfacing with the GPIO pins on the Raspberry Pi Pico W.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import pwmio`: We use this library to enable precise control over the buzzer
    by manipulating the frequency and duty cycle of `import digitalio`: Manages digital
    input and output, such as reading the state of buttons or controlling LEDs, which
    is essential for digital signal interactions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then define an `Alarm` class and create an initialization method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We define a class named `Alarm`. The `__init__()` method takes optional parameters
    for the buzzer pin, two LED pins, and buzzer frequency with default values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then initialize the buzzer on the specified pin as a PWM output with the
    given frequency and a duty cycle of `0` (off state).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code sets up two LEDs on the specified pins as digital outputs, ready to
    be turned on or off.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our class contains only one method, `activate_alarm()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We define an `activate_alarm()` method within the `Alarm` class to activate
    the alarm a specified number of times (default is `5`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the method, we set the `blink_rate` variable to `0.5` seconds, then loop
    for the specified number of times, toggling the buzzer and LEDs on and off according
    to the `blink_rate` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test our code and wiring, we use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To save the file, we click on `device_alarm.py` to our Raspberry Pi Pico H.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe the buzzer and LEDs blink for 10 repetitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the execution of test code within our application, we either delete
    or comment out this code segment.
  prefs: []
  type: TYPE_NORMAL
- en: With the alarm code written and tested, it is now time to test the motors.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and controlling the motors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To encapsulate the motor control functionality, we create a class called `Wheel`
    inside a file called `wheel.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code requires the `PicoRobotics.py` library that may be found in this chapter’s
    GitHub repository under `code` | `PicoH`. To download the library to our Pico
    H using Thonny, we first find the `lib` directory on our computer. We then right-click
    on the `lib` directory and select **Upload** **to /**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Uploading the lib directory to our Pico H from our computer](img/B21282_13_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.19 – Uploading the lib directory to our Pico H from our computer
  prefs: []
  type: TYPE_NORMAL
- en: 'We open a new editor in Thonny and start our coding by importing the `KitronikPicoRobotics`
    and `time` libraries into our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These libraries will allow us to interface with the Pico robotics board. We
    then define our class and methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We define a `Wheel` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `__init__()` constructor initializes the class, setting instance variables
    including `motor_board`, which encapsulates the functionality of the Pico robotics
    motor board, and the `speed` parameter to control motor speed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement a `forward()` method to move both wheels forward at the specified
    speed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement a `reverse()` method to move both wheels in reverse at the specified
    speed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then implement a `turn_right()` method to rotate the robot right by running
    the left wheel forward and the right wheel in reverse at the specified speed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We implement a `turn_left()` method to rotate the robot left by running the
    right wheel in reverse and the left wheel forward at the specified speed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then implement a `stop()` method to stop both motors, halting the robot’s
    movement.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test our code and wiring, we use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we run the code, we must ensure that the power switch on the motor board
    is turned on and the AA battery pack is connected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.20 – Closeup of the motor board and AA battery pack](img/B21282_13_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.20 – Closeup of the motor board and AA battery pack
  prefs: []
  type: TYPE_NORMAL
- en: For testing purposes, we place A.R.E.S. on the testing stand to keep its wheels
    off the ground (*Figure 13**.17*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To save the file, we click on `wheel.py` to our Raspberry Pi Pico H.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe the wheels on A.R.E.S. go through a sequence of moving forward,
    moving in reverse, moving right, and moving left, before stopping.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To avoid having our test code run outside of our test, we comment or delete
    it and save `wheel.py` onto our Pico H again.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we ensure the wheels move in the desired direction by adjusting
    the motor wiring on the motor board, which may involve rearranging the wires at
    the motor wire terminals.
  prefs: []
  type: TYPE_NORMAL
- en: Having correctly configured and tested the LEDs, buzzer, and motors connected
    to the Pico H, we will now proceed to test communications between the Raspberry
    Pi Pico H and the Raspberry Pi 3B+ onboard A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
- en: Testing communication between Pi and Pico
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Figure 13**.1*, we observe that communication between the Raspberry Pi 3B+
    and the Raspberry Pi Pico H on A.R.E.S. is done through UART. Specifically, messages
    are sent from the Raspberry Pi 3B+ to the Pico H to control the LEDs, buzzer,
    and motors connected to the Pico H. We wired up the two devices through their
    respective GPIO ports when we built A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will test communication using a Python test script located
    in this chapter’s GitHub repository and a new file we will create on our Pico
    H. We will start with our Pico H.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Pico H script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the code on our Pico H that will await commands from the Raspberry
    Pi 3B+, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We open a new editor in Thonny and start our coding by importing the libraries
    we need for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing the `board` module for accessing physical pin definitions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then import the `busio` module for bus communication (UART) functionalities.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `time` module for performing delays.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We import our `Wheel` class from our `wheel` module.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then import the `Alarm` class from the `device_alarm` module we created.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With our imports in place, we set our variable declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`wheel = Wheel(20)`: Creates an instance of the `Wheel` class with a speed
    parameter set to `20`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alarm = Alarm()`: Initializes an instance of the `Alarm` class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uart = busio.UART(board.GP4, board.GP5, baudrate=115200)`: Establishes a UART
    communication link using pins `GP4` and `GP5` on the Pico H, setting the baud
    rate to `115200`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then create a function to clear out our UART buffer by continuously reading
    it until no data remains (to ensure accurate and current data communication by
    removing old or irrelevant data that could lead to errors):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our code then runs in a continuous loop waiting for messages over UART:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We continuously read up to 32 bytes of data from the UART connection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We strip away the enclosing angle brackets.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We print out the received message for debugging purposes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use an `if` statement to execute a specific action based on the message
    content:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The robot moves forward if the message is `'f'`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot moves in reverse if the message is `'b'`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot turns left if the message is `'l'`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot turns right if the message is `'r'`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot activates an alarm and stops movement if the message is `'a'`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot stops any movement if the message doesn’t match any of the specified
    commands.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our code then clears the UART buffer to remove any remaining data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then introduce a brief delay of 0.1 seconds to prevent overwhelming the CPU.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To save the file, we click on `code.py` to our Raspberry Pi Pico H.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After executing `code.py`, it is expected that our code will not produce any
    output in the Shell, indicating it is in a state of waiting for communication
    from the Raspberry Pi. With the Pico H set up and waiting for messages it is now
    time to execute our test script from the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Running UART test code from the Raspberry Pi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside this chapter’s GitHub repository, we have a file named `uart-test.py`
    that we may use to test the connection between the Raspberry Pi and Pico H on
    our A.R.E.S. robot. In this section, we will SSH into our Raspberry Pi from a
    Windows computer using PuTTY and run the test, all the while keeping our Pico
    connected through Thonny.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a program such as PuTTY on Windows, or a Terminal on a Linux-based system,
    we log in to our Raspberry Pi 3B+ using the IP address (as the hostname) we obtained
    after running the setup script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Using PuTTY in Windows to log in to our Raspberry Pi 3B+](img/B21282_13_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.21 – Using PuTTY in Windows to log in to our Raspberry Pi 3B+
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time logging in through PuTTY, we may get a security alert.
    We click **Accept** to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To copy our test program to the current directory, we run the following command
    (we must not forget the dot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: vi uart-test.py
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 13.22 – Viewing uart-test.py in the vi editor](img/B21282_13_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.22 – Viewing uart-test.py in the vi editor
  prefs: []
  type: TYPE_NORMAL
- en: 'We close the editor with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo python3 uart-test.py
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should observe the LEDs and buzzer activating in two pulses, with Thonny’s
    output confirming receipt of an alarm message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Results from running the uart-test.py test script](img/B21282_13_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.23 – Results from running the uart-test.py test script
  prefs: []
  type: TYPE_NORMAL
- en: With the successful testing of the UART connection between the Raspberry Pi
    and Raspberry Pi Pico H on our A.R.E.S. robot, it is now time to test the distance
    sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the ToF sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To measure distances in front of A.R.E.S., we will use the VL53L0X ToF sensor
    from Adafruit. The sensor is capable of measuring distances from 30 mm to 1.2
    meters with high accuracy, using a tiny laser to detect light’s travel time. Its
    narrow beam overcomes the limitations of sonar or **infrared** (**IR**) sensors,
    making it ideal for precision tasks in robotics and interactive projects. Compatible
    with 3-5V and I2C communication, it’s designed for easy use with various microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: For A.R.E.S., we have the VL53L0X connected to our Raspberry Pi 3B+. We will
    use it in our design to stop our robot from moving forward once it detects an
    object less than 10 cm away.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the sensor, we run a test script available in this chapter’s GitHub
    repository. To run the test, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a program such as PuTTY on Windows, or a Terminal on a Linux-based system,
    we log in to our Raspberry Pi 3B+ using the IP address we obtained after running
    the setup script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To copy our test program to the current directory, we run the following command
    (we must not forget the dot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the test, we execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By positioning a hand at varying distances from the sensor, which is integrated
    into A.R.E.S.’s mouth, we should observe corresponding variations in the sensor’s
    output values displayed in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Output from the testing of the VL53L0X ToF sensor](img/B21282_13_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.24 – Output from the testing of the VL53L0X ToF sensor
  prefs: []
  type: TYPE_NORMAL
- en: Are ToF sensors the same as distance sensors?
  prefs: []
  type: TYPE_NORMAL
- en: A ToF sensor, measuring the time for light to bounce back from an object, provides
    precise distance readings. In contrast, traditional distance sensors, often using
    ultrasonic or IR technology, gauge distances based on sound waves or light intensity.
    ToF sensors typically offer higher accuracy and reliability across various ranges
    compared to these common distance sensors.
  prefs: []
  type: TYPE_NORMAL
- en: With the ToF sensor operational, we’re set to configure A.R.E.S.’s camera, which,
    unlike the Raspberry Pi and Pico H, streams video outside the ROS environment,
    accessible by any network device.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Arduino IDE to program the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming video from A.R.E.S.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For video streaming, we’ll use the M5Stack Timer Camera X, powered by an ESP32
    chip with a 3-million-pixel (ov3660) sensor for up to 2048x1536 pixel images.
    Although it supports I2C for configuration, we’ll directly power it with the Raspberry
    Pi 3B+’s 5V supply, bypassing the I2C setup. The camera serves as the nose of
    our A.R.E.S. robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Arduino IDE and a program provided by M5Stack to set up the
    camera. To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a web browser, navigate to the Arduino website and download the latest
    Arduino IDE from [https://www.arduino.cc/en/software](https://www.arduino.cc/en/software).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once downloaded, we install the Arduino IDE and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To add our M5Stack Timer Camera X library and example code to the Arduino IDE,
    we select **File** | **Preferences** (in Windows) and add the following URL to
    the **Additional boards manager URLs** box: [https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/arduino/package_m5stack_index.json](https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/arduino/package_m5stack_index.json).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The dialog box should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Adding M5Stack boards to the Arduino IDE](img/B21282_13_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.25 – Adding M5Stack boards to the Arduino IDE
  prefs: []
  type: TYPE_NORMAL
- en: We click **OK** to close the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a USB-C cable, we connect our Timer Camera X to the computer running the
    Arduino IDE. We may remove the camera from the face of A.R.E.S. to make it easier
    to access the USB-C port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To set **M5TimerCAM** as the device, we click on **Tools** | **Board** | **M5Stack**
    | **M5TimerCAM**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.26 – Selecting M5TimerCAM](img/B21282_13_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.26 – Selecting M5TimerCAM
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to select the port our camera is connected to. To do this, we
    click on **Tools** | **Port** and select the port our camera is connected to (it
    helps to only have the camera connected to our computer as there will be only
    one option).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To access the M5Stack Timer Camera example code, we click on **Tools** | **Manage
    Libraries…** and search for **Timer-CAM**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then hover our mouse beside the title of the section until three dots appear
    and select **Examples** | **rtsp_stream**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.27 – Selecting the rtsp_stream example code](img/B21282_13_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.27 – Selecting the rtsp_stream example code
  prefs: []
  type: TYPE_NORMAL
- en: This will open another Arduino window with the example code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need the Serial Monitor to find the address where the video will be broadcast.
    To load the Serial Monitor, we click on **Tools** | **Serial Monitor**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.28 – Viewing the Serial Monitor](img/B21282_13_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.28 – Viewing the Serial Monitor
  prefs: []
  type: TYPE_NORMAL
- en: We set the baud rate to `115200` and enter the SSID name and password into the
    code (areas annotated in the previous figure).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To upload the code to our camera, we click on the **Upload** button, which
    looks like this: ![](img/B21282_13_29.png).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After compilation, the code is uploaded to our camera. We may view the `rtsp`
    address in the Serial Monitor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21282_13_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.29 – Output to the Serial Monitor
  prefs: []
  type: TYPE_NORMAL
- en: 'We copy the `rtsp` URL and paste it into a VLC media player by clicking on
    **Media** | **Open Network Stream…** in the VLC media player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.30 – Video streaming using the VLC media player](img/B21282_13_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.30 – Video streaming using the VLC media player
  prefs: []
  type: TYPE_NORMAL
- en: To begin streaming, we click on the **Play** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should observe a feed from our camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.31 – Video feed from our camera as shown in the VLC media player](img/B21282_13_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.31 – Video feed from our camera as shown in the VLC media player
  prefs: []
  type: TYPE_NORMAL
- en: A.R.E.S. is currently missing its nose, but after testing the camera, we can
    disconnect the USB-C cable and reattach it to A.R.E.S.’s face. This completes
    the testing phase for A.R.E.S.’s components, paving the way for us to develop
    a ROS node and enable control of A.R.E.S. over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Programming A.R.E.S. with ROS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that A.R.E.S. has been assembled and the essential software and firmware
    have been installed, we are ready to employ ROS for remote control over the internet.
    During our setup, we installed ROS along with all the necessary libraries. Along
    with our setup script, we downloaded test scripts from our GitHub repository,
    which we ran to ensure everything was functioning correctly.
  prefs: []
  type: TYPE_NORMAL
- en: A pre-existing ROS workspace also exists in our GitHub repository. To create
    a ROS node with this code, simply transfer the pre-existing workspace to our `home`
    directory and execute a `colcon` `build` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a program such as PuTTY on Windows, or a Terminal on a Linux-based system,
    we log in to our Raspberry Pi 3B+ using the IP address we obtained after running
    the setup script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To copy our ROS workspace to the current directory, we run the following command
    (we must not forget the dot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then navigate into our workspace with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We source the ROS environment with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'robot_control.py file from *Chapter 12*, we will explore only certain parts
    of the code. We start with code located inside the initialization method we use
    to give us the permissions to use the serial0 port:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is highly advisable not to put the admin password inside a file due to security
    concerns. However, with our application operating in a strictly controlled development
    environment where access is tightly restricted, we bypass this guideline. We require
    this password so that we may change permissions on the `serial0` port. Without
    it, we would not have access and thus could not send commands to the Pico H.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: We store a `sudo` user’s password in the `password` variable. We set the command
    to change permissions of `/dev/serial0` to read and write for all users in the
    `command` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code then executes the command using `sudo` without manual password entry
    by piping the password into `sudo -S`, utilizing `subprocess.run` with shell execution
    enabled and enforcing command success with `check=True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the initialization method, we also set the `ser` instance variable to
    be equal to `serial0`, the port we connect our Pico H to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `send_message()` method formats a command to sit within open (`<`) and
    closed (`>`) angle brackets and sends out messages over the serial port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, the following happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We check if the current command is `'s'` and if the last sent command was also
    `'s'` to prevent sending `'s'` consecutively. This is done as the stop command
    is the default command when there is no engagement with the IoT joystick and thus
    can flood the communication channel with redundant signals, potentially causing
    unnecessary processing and response delays in the system.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the preceding condition is met, our code skips sending the command and logs
    a message about it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then format `command` with opening (`<`) and closing (`>`) angle brackets,
    followed by a newline.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We log the framed command being sent. Our code then sends the framed command
    over the serial port using `.encode()` to convert it to bytes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We log the original command (stripped of whitespace) as sent. Our code then
    updates `self.last_command_sent` with the current command (stripped of whitespace)
    for future checks.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build our code, we execute the `colcon` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After building our node, we source it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to run our node to have our robot controlled by our IoT Joystick.
    We do so with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It is advisable to have A.R.E.S. up on the test stand before we send it commands.
    With our node running, we may control A.R.E.S. using the IoT joystick we built
    in [*Chapter 12*](B21282_12.xhtml#_idTextAnchor195).
  prefs: []
  type: TYPE_NORMAL
- en: We have just controlled a robot over the internet using MQTT and ROS. Controlling
    a robot over the internet using MQTT and ROS not only demonstrates the technical
    feasibility of remote robotic operations but also highlights the potential for
    use cases where remote monitoring and intervention are critical, such as in **disaster
    recovery** (**DR**), hazardous environment exploration, and healthcare support.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we integrated MQTT and ROS and created the A.R.E.S. robot.
    Using MQTT, a lightweight messaging protocol, enabled us to have efficient and
    reliable communication between the robot and our IoT joystick. ROS offers us a
    robust framework for developing complex robotic applications. By choosing ROS
    to build A.R.E.S., we leverage its vast ecosystem of tools and libraries, ensuring
    our robot is not only capable of performing advanced tasks but is also scalable
    and adaptable for future enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: As we built and programmed A.R.E.S., we could easily imagine using our knowledge
    to build more advanced robots capable of performing complex tasks, interacting
    seamlessly with humans, and adapting to various environments and challenges autonomously.
  prefs: []
  type: TYPE_NORMAL
- en: In our next and final chapter, we will add vision recognition to A.R.E.S.
  prefs: []
  type: TYPE_NORMAL
