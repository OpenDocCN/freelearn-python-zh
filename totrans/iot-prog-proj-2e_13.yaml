- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Introducing Advanced Robotic Eyes for Security (A.R.E.S.)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍用于安全的先进机器人眼睛（A.R.E.S.）
- en: In this chapter, we will convert our TurtleSim virtual robot to a real-life
    robot we will call A.R.E.S. (short for Advanced Robotic Eyes for Security). A.R.E.S.
    will feature a video feed that we view over our local network using the VLC media
    player. We will control A.R.E.S. using the IoT joystick we created in [*Chapter
    12*](B21282_12.xhtml#_idTextAnchor195).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把我们的TurtleSim虚拟机器人转换为现实生活中的机器人，我们将称之为A.R.E.S.（即Advanced Robotic Eyes
    for Security）。A.R.E.S.将具有视频流，我们可以通过VLC媒体播放器在我们的本地网络中查看。我们将使用我们在[*第12章*](B21282_12.xhtml#_idTextAnchor195)中创建的物联网摇杆来控制A.R.E.S.。
- en: We will construct A.R.E.S. using a Raspberry Pi as the brain or sensory input
    and a Raspberry Pi Pico for control of the motors, LEDs, and buzzer. We will use
    standard motors and a robotics board with our Raspberry Pi Pico H for motor control.
    We will 3D print the frame using the `.stl` files located in the `Build Files`
    directory of this chapter’s GitHub repository.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用树莓派作为大脑或感官输入，以及树莓派Pico来控制电机、LED和蜂鸣器来构建A.R.E.S.。我们将使用标准电机和我们的树莓派Pico H上的机器人板来控制电机。我们将使用位于本章GitHub仓库“构建文件”目录中的`.stl`文件来3D打印框架。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Exploring our A.R.E.S. application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索我们的A.R.E.S.应用程序
- en: Constructing A.R.E.S.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建A.R.E.S.
- en: Software setup and configuration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件设置和配置
- en: Programming A.R.E.S. with ROS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ROS编程A.R.E.S.
- en: Let’s begin!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will require the following to learn comprehensively from this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面学习本章内容，你需要以下条件：
- en: Intermediate knowledge of Python programming
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python编程的中级知识
- en: Basic knowledge of the Linux command line
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux命令行的基本知识
- en: A CloudAMQP account for the MQTT server instance
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于MQTT服务器实例的CloudAMQP账户
- en: IoT joystick from [*Chapter 12*](B21282_12.xhtml#_idTextAnchor195)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[*第12章*](B21282_12.xhtml#_idTextAnchor195)的物联网摇杆
- en: Access to a 3D printer or 3D printing service
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D打印机或3D打印服务的访问权限
- en: Build files for custom cases may be found in our GitHub repository
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义情况的构建文件可以在我们的GitHub仓库中找到
- en: Refer to the *Constructing A.R.E.S.* section for hardware components required.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅“构建A.R.E.S.”部分以了解所需的硬件组件。
- en: 'The code for this chapter may be found here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下链接找到：
- en: https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter13
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter13
- en: Exploring our A.R.E.S. application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索我们的A.R.E.S.应用程序
- en: 'The A.R.E.S. robot presents an integration of various IoT components. It’s
    operated via the IoT joystick we created in [*Chapter 12*](B21282_12.xhtml#_idTextAnchor195)
    and communicates commands through MQTT to the Raspberry Pi. Our design will incorporate
    both a Raspberry Pi 3B+ and a Raspberry Pi Pico H. In the following diagram, we
    see the outline of the A.R.E.S. robot, including the connection from the IoT joystick:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: A.R.E.S.机器人展示了各种物联网组件的集成。它通过我们在[*第12章*](B21282_12.xhtml#_idTextAnchor195)中创建的物联网摇杆进行操作，并通过MQTT与树莓派通信命令。我们的设计将包含树莓派3B+和树莓派Pico
    H。在下面的图中，我们可以看到A.R.E.S.机器人的轮廓，包括从物联网摇杆的连接：
- en: '![Figure 13.1 – The A.R.E.S. robot application](img/B21282_13_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – A.R.E.S.机器人应用程序](img/B21282_13_1.jpg)'
- en: Figure 13.1 – The A.R.E.S. robot application
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – A.R.E.S.机器人应用程序
- en: The Raspberry Pi 3B+, serving as the brain, uses **UART** (short for **Universal
    Asynchronous Receiver/Transmitter**) communication to relay commands to a Raspberry
    Pi Pico H, which in turn controls the car’s movements, LEDs, and buzzer, responding
    dynamically to inputs. Equipped with a VL53L0X sensor, A.R.E.S. can measure distances,
    allowing it to avoid obstacles. Additionally, an M5Stack camera mounted on A.R.E.S.
    streams real-time video, which can be viewed on any computer using a VLC media
    player via the **Real-Time Streaming** **Protocol** (**RTSP**).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为大脑的树莓派3B+使用**UART**（通用异步收发传输器）通信来中继命令到树莓派Pico H，后者反过来控制汽车的运动、LED和蜂鸣器，对输入做出动态响应。配备有VL53L0X传感器，A.R.E.S.可以测量距离，从而避免障碍物。此外，安装在A.R.E.S.上的M5Stack摄像头可以实时传输视频流，可以通过VLC媒体播放器在任意计算机上查看，使用**实时流协议**（RTSP）。
- en: Using a Raspberry Pi 3B+ for A.R.E.S.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用树莓派3B+为A.R.E.S.编程
- en: For A.R.E.S., we’re selecting the Raspberry Pi 3B+ over newer models such as
    the 4 or 5 due to its power efficiency and cost. Its ability to run on standard
    cell phone battery packs makes it ideal for our needs, while its lower price and
    availability as a current model ensure both economic and practical benefits.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于A.R.E.S.，我们选择Raspberry Pi 3B+而不是4或5等较新型号，因为它具有更高的能效和成本效益。它能够使用标准手机电池组运行，非常适合我们的需求，而其较低的价格和作为当前型号的可用性确保了经济和实用性的双重好处。
- en: Kicking off the A.R.E.S. robot project, we’ll first assemble the 3D-printed
    frame and install the necessary components. A.R.E.S. is engineered for compactness,
    making it an ideal robotic platform for educational purposes. Once the frame is
    complete, we’ll move on to software, configuring the operating system on our Raspberry
    Pi 3B+ and programming the Raspberry Pi Pico H. Let’s begin with constructing
    the frame.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动A.R.E.S.机器人项目时，我们首先组装3D打印的框架并安装必要的组件。A.R.E.S.设计得非常紧凑，使其成为教育用途的理想机器人平台。一旦框架完成，我们将继续进行软件配置，在我们的Raspberry
    Pi 3B+上配置操作系统，并编程Raspberry Pi Pico H。让我们从构建框架开始。
- en: Constructing A.R.E.S.
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建A.R.E.S.
- en: A.R.E.S. consists of a frame made with 3D-printed parts and common components
    such as DC motors, LEDs, a Raspberry Pi 3B+, a Raspberry Pi Pico H, **ToF** (short
    for **time of flight**), a sensor, a Wi-Fi camera, battery packs, and various
    bolts and screws.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: A.R.E.S.由3D打印部件和常见组件组成，如直流电机、LED、Raspberry Pi 3B+、Raspberry Pi Pico H、**ToF**（飞行时间），传感器、Wi-Fi相机、电池组和各种螺栓和螺丝。
- en: We will start our construction of A.R.E.S. by identifying the 3D-printed parts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始构建A.R.E.S.，首先识别3D打印的部件。
- en: Identifying the 3D-printed frame parts
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别3D打印框架部件
- en: 'We may find the `.stl` files of these parts under the `Build Files` directory
    of this chapter’s GitHub repository. In the following figure, we see the parts
    printed out:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本章GitHub仓库的“构建文件”目录下找到这些部件的`.stl`文件。在以下图中，我们可以看到打印出的部件：
- en: '![Figure 13.2 – A.R.E.S. 3D-printed parts](img/B21282_13_2.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – A.R.E.S. 3D打印部件](img/B21282_13_2.jpg)'
- en: Figure 13.2 – A.R.E.S. 3D-printed parts
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – A.R.E.S. 3D打印部件
- en: 'The 3D-printed parts that make up the frame of A.R.E.S. are the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由3D打印部件组成的A.R.E.S.框架部件如下：
- en: '*A*: Base'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*: 底座'
- en: '*B*: Shell'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*: 外壳'
- en: '*C*: Face'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*: 面板'
- en: '*D*: Battery pack riser'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*: 电池组支架'
- en: '*E*: Motor bracket'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*: 电机支架'
- en: '*F*: Testing stand (optional base used for testing purposes)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F*: 测试台（可选的用于测试目的的底座）'
- en: With the 3D-printed frame parts identified, let’s look at the components used
    to construct A.R.E.S.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别了3D打印框架部件后，让我们看看用于构建A.R.E.S.的组件。
- en: Identifying the components used to create A.R.E.S.
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别用于创建A.R.E.S.的组件。
- en: 'The components we use to construct A.R.E.S. are standard electronic components
    and may be easily purchased online from vendors such as Amazon or AliExpress.
    The following figure outlines the components we use:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的构建A.R.E.S.的组件是标准电子组件，可以从亚马逊或AliExpress等在线供应商那里轻松购买。以下图展示了我们使用的组件：
- en: '![Figure 13.3 – Components that make up the A.R.E.S. robot](img/B21282_13_3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 组成A.R.E.S.机器人的部件](img/B21282_13_3.jpg)'
- en: Figure 13.3 – Components that make up the A.R.E.S. robot
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 组成A.R.E.S.机器人的部件
- en: 'The components to construct A.R.E.S. are the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构建A.R.E.S.所需的组件如下：
- en: '*A*: 2 x LED with 220 Ohm resistor'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*: 2 x LED和220欧姆电阻'
- en: '*B*: 2 x 5 mm (8 mm wide) LED holder'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*: 2 x 5毫米（8毫米宽）LED支架'
- en: '*C*: 2 x TT DC robot motor'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*: 2 x TT直流机器人电机'
- en: '*D*: M5Stack Timer Camera X with mount (not shown)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*: M5Stack计时器相机X及其支架（未展示）'
- en: '*E*: Adafruit VL53L0X ToF sensor'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*: Adafruit VL53L0X ToF传感器'
- en: '*F*: 2 x TT robot car wheel'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F*: 2 x TT机器人汽车轮子'
- en: '*G*: SFM-27 buzzer'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*G*: SFM-27蜂鸣器'
- en: '*H*: Raspberry Pi 3B+'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*H*: Raspberry Pi 3B+'
- en: '*I*: Battery pack for 4 AA batteries (with batteries)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*I*: 4节AA电池的电池组（含电池）'
- en: '*J*: Cell phone USB battery pack'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*J*: 手机USB电池组'
- en: '*K*: Raspberry Pi Pico H with Kitronik Simply Robotics Motor Driver Board'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*K*: 带有Kitronik Simply Robotics电机驱动板的Raspberry Pi Pico H'
- en: '*L*: micro-USB to USB cable (short)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*L*: 短微USB到USB线'
- en: '*M*: Grove connector to female jumper wire connectors for connecting the camera
    to the GPIO ports of the Raspberry Pi 3B+'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*M*: Grove连接器到公跳线连接器，用于将相机连接到Raspberry Pi 3B+的GPIO端口'
- en: '*N*: 4 x 2 mm thick, 18 mm diameter magnets with double-sided adhesive pads'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N*: 4 x 2毫米厚，18毫米直径的磁铁，带有双面粘合垫'
- en: '*O*: Caster (32 mm width)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*O*: 轮子（32毫米宽度）'
- en: '*NOT SHOWN*: 18 x M3 10 mm bolts, 4 x M3 20 mm bolts, 8 x M3 nuts, 6 x M2.5
    10 mm bolts, 2 x M4 10 mm bolts, 4 x M2.5 40 mm standoffs, 3 x M3 20 mm standoffs,
    jumper wires, crimping kit with connectors and wires (optional but recommended),
    hot glue gun, soldering iron'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*未显示*：18个M3 10毫米螺栓，4个M3 20毫米螺栓，8个M3螺母，6个M2.5 10毫米螺栓，2个M4 10毫米螺栓，4个M2.5 40毫米支撑柱，3个M3
    20毫米支撑柱，跳线，带有连接器和电线的压接套件（可选但推荐），热胶枪，烙铁'
- en: With our components in place, let’s start to build our A.R.E.S. robot.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件安装到位后，让我们开始构建我们的A.R.E.S.机器人。
- en: Building A.R.E.S.
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建A.R.E.S.
- en: 'Using our 3D-printed frame parts and electronic components, it is now time
    to build A.R.E.S. To construct A.R.E.S., we use the following diagram as a guide:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的3D打印框架部件和电子组件，现在是时候构建A.R.E.S.了。为了构建A.R.E.S.，我们使用以下图作为指南：
- en: '![Figure 13.4 – Building the A.R.E.S. robot](img/B21282_13_4.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 构建A.R.E.S.机器人](img/B21282_13_4.jpg)'
- en: Figure 13.4 – Building the A.R.E.S. robot
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 构建A.R.E.S.机器人
- en: 'The steps are as follows (the numbered steps also correspond to the numbered
    components in the figure):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下（编号步骤也对应图中的编号组件）：
- en: Using double-sided adhesive tape (usually packaged with the product), we secure
    two magnets (*N* from *Figure 13**.3*) to the shell (*B* from *Figure 13**.2*).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用双面胶带（通常与产品一起包装），我们将两个磁铁（*N*来自*图13**.3*）固定在外壳上（*B*来自*图13**.2*）。
- en: Using the opposite polarity magnets (*N* from *Figure 13**.3*), we attach the
    magnets (be sure to test before fastening) to the base (*A* from *Figure 13**.2*).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相反极性的磁铁（*N*来自*图13**.3*），我们将磁铁（在固定前务必测试）固定到底座上（*A*来自*图13**.2*）。
- en: Using two M4 10 mm bolts, we fasten the SFM-27 buzzer (*G* from *Figure 13**.3*)
    to the base (*A* from *Figure 13**.2*). The bolts should tap into the buzzer base;
    however, M4 nuts may be required. In this step, we also secure the caster (*O*
    from *Figure 13**.3*) to the base (*A* from *Figure 13**.2*) using two M3 bolts.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个M4 10毫米螺栓，我们将SFM-27蜂鸣器（*G*来自*图13**.3*）固定到底座上（*A*来自*图13**.2*）。螺栓应插入蜂鸣器底座；然而，可能需要M4螺母。在此步骤中，我们还使用两个M3螺栓将万向轮（*O*来自*图13**.3*）固定到底座上（*A*来自*图13**.2*）。
- en: We solder 20 cm wires to each of the terminals of the TT motor (*C* from *Figure
    13**.3*).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将20厘米长的电线焊接在每个TT电机的端子上（*C*来自*图13**.3*）。
- en: Using the motor bracket (*E* from *Figure 13**.2*), we fasten the TT motors
    (*C* from *Figure 13**.3*) with the TT robot car wheel (*F* from *Figure 13**.3*)
    to the base (*A* from *Figure 13**.2*).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用电机支架（*E*来自*图13**.2*），我们将TT电机（*C*来自*图13**.3*）和TT机器人汽车轮子（*F*来自*图13**.3*）固定在底座上（*A*来自*图13**.2*）。
- en: Using two M3 10 mm bolts, we fasten the camera mount that comes with the M5Stack
    Timer Camera X (*D* from *Figure 13**.3*) to the face (*C* from *Figure 13**.2*).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个M3 10毫米螺栓，我们将M5Stack Timer Camera X（*D*来自*图13**.3*）附带的相机支架固定在面板上（*C*来自*图13**.2*）。
- en: Using the LED holders (*B* from *Figure 13**.3*) and LEDs with resistors (*A*
    from *Figure 13**.3*), we thread the LEDs through the appropriate holes in the
    face (*C* from *Figure 13**.2*). We secure the VL53L0X ToF sensor (*E* from *Figure
    13**.3*) to the face (*C* from *Figure 13**.2*) using glue from a hot glue gun.
    We may also glue the LEDs in place to keep them from moving.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LED支架（*B*来自*图13**.3*）和带有电阻的LED（*A*来自*图13**.3*），我们将LED穿过面板上的适当孔（*C*来自*图13**.2*）。我们使用热胶枪的胶水将VL53L0X
    ToF传感器（*E*来自*图13**.3*）固定在面板上（*C*来自*图13**.2*）。我们还可以将LED固定在原位，以防止它们移动。
- en: Access to the GP pins on the Raspberry Pi Pico H is required, but they are engaged
    within the motor board’s **DIP** (short for **Dual Inline Package**) socket, rendering
    them inaccessible. To overcome this, we need to solder header pins to the underside
    of the motor board, enabling us to connect the SFM-27 buzzer (*G* from *Figure
    13**.3*) and LEDs with resistors (*A* from *Figure 13**.3*) to the Raspberry Pi
    Pico H.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要访问Raspberry Pi Pico H上的GP引脚，但它们位于电机板的**DIP**（即**双列直插式封装**）插座内，因此无法访问。为了克服这个问题，我们需要在电机板的底部焊接引线脚，使我们能够将SFM-27蜂鸣器（*G*来自*图13**.3*）和带有电阻的LED（*A*来自*图13**.3*）连接到Raspberry
    Pi Pico H。
- en: We secure four M2.5 40 mm standoffs to the front of the base (*A* from *Figure
    13**.2*) and three M3 20 mm standoffs to the back of the base (*A* from *Figure
    13**.2*) using 10 mm M2.5 and 10 mm M3 bolts respectively. We may secure the Raspberry
    Pi 3B+ (*H* from *Figure 13**.3*) and Pico H with the motor board (*K* from *Figure
    13**.3*) to the standoffs; however, this will only be temporary as these components
    will be moved around as we wire up A.R.E.S. We may also temporarily place the
    battery pack riser (*D* from *Figure 13**.2*) in place. We use the riser to cover
    the wires and provide a flat surface to place the battery pack (*I* from *Figure*
    *13**.3*) on.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用10毫米M2.5和10毫米M3螺栓，将四个M2.5 40毫米支撑件固定在底座的前面（*图13**.2*中的*A*）和三个M3 20毫米支撑件固定在底座的后面（*图13**.2*中的*A*）。我们可以使用电机板（*图13**.3*中的*K*）将Raspberry
    Pi 3B+（*图13**.3*中的*H*）和Pico H固定在支撑件上；然而，这将是临时的，因为这些组件在我们接线A.R.E.S.时会移动。我们还可以临时放置电池组提升器（*图13**.2*中的*D*）。我们使用提升器来覆盖电线，提供一个平坦的表面放置电池组（*图13**.3*中的*I*）。
- en: With the frame assembled and components in place, it is now time to wire our
    components to the Raspberry Pi and Pico H.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在组装好框架并放置好组件后，现在是时候将我们的组件连接到Raspberry Pi和Pico H上了。
- en: Wiring up A.R.E.S.
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接线A.R.E.S.
- en: Wiring up A.R.E.S. requires connections to the Raspberry Pi 3B+ and Kitronik
    motor board. Using *Figure 13**.1* as a reference, we can see that we connect
    the VL53L0X ToF sensor and M5Stack Timer Camera X to the Raspberry Pi 3B+, and
    the TT DC robot motors, LEDs with resistors, and buzzer to the Raspberry Pi Pico
    H using the motor board. We also wire the Raspberry Pi 3B+ to the Raspberry Pi
    Pico H to each other for use with UART communication.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接线A.R.E.S.需要连接到Raspberry Pi 3B+和Kitronik电机板。使用*图13**.1*作为参考，我们可以看到我们将VL53L0X
    ToF传感器和M5Stack Timer Camera X连接到Raspberry Pi 3B+，将TT DC机器人电机、带电阻的LED和蜂鸣器通过电机板连接到Raspberry
    Pi Pico H。我们还通过UART通信将Raspberry Pi 3B+连接到Raspberry Pi Pico H。
- en: 'We start our wiring with robot motors. In the following figure, we see a closeup
    of the motor board with the terminals to connect the battery pack and motors highlighted:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从机器人电机开始接线。在下面的图中，我们可以看到电机板的高清图，其中连接电池组和电机的端子被突出显示：
- en: '![Figure 13.5 – Kitronik motor board for the Raspberry Pi Pico H](img/B21282_13_5.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – Raspberry Pi Pico H的Kitronik电机板](img/B21282_13_5.jpg)'
- en: Figure 13.5 – Kitronik motor board for the Raspberry Pi Pico H
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – Raspberry Pi Pico H的Kitronik电机板
- en: 'To wire up our motors, we do the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要接线我们的电机，我们执行以下操作：
- en: Attach the wires from the right motor, as depicted in *Step 9* of *Figure 13**.4*,
    to **Motor0** on the motor board. The polarity of the wires is not critical at
    this stage since we can correct their orientation later if necessary.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将右侧电机，如*图13**.4*的第9步所示，连接到电机板上的**Motor0**。在这个阶段，电线的极性不是关键，因为我们可以在必要时纠正它们的方向。
- en: Attach the wires from the left motor to **Motor1** on the motor board.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将左侧电机的电线连接到电机板上的**Motor1**。
- en: Attach the wires from the AA battery pack to the battery terminals on the motor
    board, taking polarity into account.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将AA电池组的电线连接到电机板上的电池端子，注意极性。
- en: 'With the robot motors and battery wires attached, it is now time to wire up
    the rest of the components. We will be using standard female jumper wires to make
    the connections. Although not required, having the ability to create our own jumper
    wires using a crimping kit makes for a clean and organized wiring setup. We use
    the wiring diagram in *Figure 13**.6* for reference:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接好机器人电机和电池线后，现在是时候接线其余的组件了。我们将使用标准的女性跳线来制作连接。虽然不是必需的，但使用压接套件制作自己的跳线可以使接线设置整洁有序。我们使用*图13**.6*中的接线图作为参考：
- en: '![Figure 13.6 – Component wiring diagram for A.R.E.S.](img/B21282_13_6.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – A.R.E.S.的组件接线图](img/B21282_13_6.jpg)'
- en: Figure 13.6 – Component wiring diagram for A.R.E.S.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – A.R.E.S.的组件接线图
- en: 'To wire up the rest of our components, we do the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要接线其余的组件，我们执行以下操作：
- en: Using a grove connector to the female jumper wire connectors (*M* from *Figure
    13**.3*), we connect the M5Stack Timer Camera X to the Raspberry Pi 3B+ by attaching
    5V from the Raspberry Pi to the V connector on the camera, and GND from the Raspberry
    Pi to G on the camera.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Grove连接器连接到女性跳线连接器（*图13**.3*中的*M*），我们将M5Stack Timer Camera X连接到Raspberry Pi
    3B+，将Raspberry Pi的5V连接到摄像机的V连接器，将Raspberry Pi的GND连接到摄像机的G。
- en: We connect VIN on the ToF sensor to 3.3V on the Raspberry Pi.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将ToF传感器的VIN连接到Raspberry Pi的3.3V。
- en: We connect SDA on the ToF sensor to SDA (GPIO 2) on the Raspberry Pi.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 ToF 传感器上的 SDA 连接到树莓派上的 SDA (GPIO 2)。
- en: We connect SCL on the ToF sensor to SCL (GPIO 3) on the Raspberry Pi.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 ToF 传感器上的 SCL 连接到树莓派上的 SCL (GPIO 3)。
- en: We connect GND on the ToF sensor to GND on the Raspberry Pi.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 ToF 传感器上的 GND 连接到树莓派的 GND。
- en: We connect TX (GPIO 14) on the Raspberry Pi to RX (GP5) on the Raspberry Pi
    Pico H or pin 7 on the motor board.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将树莓派上的 TX (GPIO 14) 连接到树莓派 Pico H 的 RX (GP5) 或电机板上的 7 号引脚。
- en: We connect RX (GPIO 15) on the Raspberry Pi to TX (GP4) on the Raspberry Pi
    Pico H or pin 6 on the motor board.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将树莓派上的 RX (GPIO 15) 连接到树莓派 Pico H 的 TX (GP4) 或电机板上的 6 号引脚。
- en: We connect GND on the Raspberry Pi to GND on the Raspberry Pi Pico H or a GND
    (0V) pin on the motor board.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将树莓派上的 GND 连接到树莓派 Pico H 的 GND 或电机板上的 GND (0V) 引脚。
- en: We connect the positive wire on the SFM-27 buzzer to GP0 on the Raspberry Pi
    Pico H or pin 1 on the motor board.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 SFM-27 蜂鸣器的正极线连接到树莓派 Pico H 的 GP0 或电机板上的 1 号引脚。
- en: We connect the negative wire on the SFM-27 buzzer to a GND (0V) pin on the motor
    board.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 SFM-27 蜂鸣器的负极线连接到电机板上的 GND (0V) 引脚。
- en: We connect the positive ends of the LEDs with resistors to GP1 and GP2 or pins
    2 and 4 on the motor board.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 LED 的正极通过电阻连接到 GP1 和 GP2 或电机板上的 2 号和 4 号引脚。
- en: We connect the negative ends of the LEDs with resistors to a GND (0V) pin on
    the motor board.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 LED 的负极通过电阻连接到电机板上的 GND (0V) 引脚。
- en: We may need to move the Raspberry Pi and motor board around as we make the connections.
    Also, it is advisable that we do not attach the face (*C* from *Figure 13**.2*)
    to the base (*A* from *Figure 13**.2*) initially as we require access to the microSD
    port on the Raspberry Pi 3B+.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行连接时，可能需要移动树莓派和电机板。此外，建议我们最初不要将面板（*图 13**.2 中的 *C*）连接到底座（*图 13**.2 中的 *A*），因为我们需要访问树莓派
    3B+ 上的 microSD 端口。
- en: With the wiring in place, let’s set up the software for A.R.E.S. We will start
    by installing Ubuntu onto our Raspberry Pi 3B+.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在布线就绪后，让我们设置 A.R.E.S. 的软件。我们首先将 Ubuntu 安装到我们的树莓派 3B+ 上。
- en: Software setup and configuration
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设置和配置
- en: To set up the software architecture of A.R.E.S., we will run a script from this
    chapter’s GitHub repository. The script starts by ensuring that it is run with
    root privileges, updates and upgrades the system, and installs essential utilities
    and interfaces such as **I2C** (short for **Inter-Integrated Circuit**) and UART.
    It then proceeds to install Adafruit Blinka to support CircuitPython libraries,
    set up ROS Humble Hawksbill for robotics programming, and install the Colcon build
    system for software compilation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置 A.R.E.S. 的软件架构，我们将从这个章节的 GitHub 仓库中运行一个脚本。脚本首先确保以 root 权限运行，更新和升级系统，并安装必要的工具和接口，例如
    **I2C**（代表 **Inter-Integrated Circuit**）和 UART。然后继续安装 Adafruit Blinka 以支持 CircuitPython
    库，设置 ROS Humble Hawksbill 用于机器人编程，并安装 Colcon 构建系统以进行软件编译。
- en: The script also takes care of dependency management through `rosdep` and adds
    the ROS 2 environment setup to the `bashrc` file for easy access. By the end of
    the process, our Raspberry Pi 3B+ is fully configured for A.R.E.S.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还负责通过 `rosdep` 进行依赖管理，并将 ROS 2 环境设置添加到 `bashrc` 文件中以便于访问。到过程结束时，我们的树莓派 3B+
    已完全配置为 A.R.E.S.。
- en: 'Before running the script, we will use the Raspberry Pi Imager to burn Ubuntu
    onto a microSD card and install the card onto our Raspberry Pi 3B+. As the slot
    for the microSD card is in the front of the A.R.E.S. robot, the face will cover
    it. Thus, we will keep the face disconnected from the base while we install Ubuntu,
    as we see in the following figure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行脚本之前，我们将使用 Raspberry Pi Imager 将 Ubuntu 烧录到 microSD 卡上，并将卡安装到我们的树莓派 3B+ 上。由于
    A.R.E.S. 机器人的 microSD 卡插槽位于前面，因此面板将覆盖它。因此，在安装 Ubuntu 时，我们将保持面板与底座断开连接，如图所示：
- en: '![Figure 13.7 – Side view of A.R.E.S. with the face detached to allow access
    to the microSD card](img/B21282_13_7.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – A.R.E.S. 的侧面视图，面板已断开以允许访问 microSD 卡](img/B21282_13_7.jpg)'
- en: Figure 13.7 – Side view of A.R.E.S. with the face detached to allow access to
    the microSD card
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – A.R.E.S. 的侧面视图，面板已断开以允许访问 microSD 卡
- en: We will run the Raspberry Pi Imager from a computer of our choice. For the examples
    in this chapter, we will install it on a Windows computer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们选择的计算机上运行 Raspberry Pi Imager。对于本章的示例，我们将将其安装在 Windows 计算机上。
- en: Installing Ubuntu onto our Raspberry Pi 3B+
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的树莓派 3B+ 上安装 Ubuntu
- en: The Raspberry Pi Imager is a versatile tool designed to simplify the process
    of installing operating systems on Raspberry Pi devices. Developed by the Raspberry
    Pi Foundation, this utility allows us to flash various operating systems onto
    an SD card, which can then be used to boot and run on a Raspberry Pi.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Imager是一个多功能的工具，旨在简化在Raspberry Pi设备上安装操作系统的过程。由Raspberry Pi基金会开发，这个实用程序允许我们将各种操作系统闪存到SD卡上，然后可以在Raspberry
    Pi上启动和运行。
- en: While the Raspberry Pi Imager primarily supports the installation of Raspberry
    Pi OS (formerly known as Raspbian), its capabilities extend to a range of other
    operating systems. This allows us to experiment with different environments or
    require specific functionalities that are better supported by alternative OSs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Raspberry Pi Imager主要支持安装Raspberry Pi OS（以前称为Raspbian），但其功能扩展到一系列其他操作系统。这使我们能够尝试不同的环境或需要由替代操作系统更好地支持的功能。
- en: To use the Raspberry Pi Imager, we simply download and install the application
    on our computer, select the desired operating system from its extensive list,
    and then choose the target SD card for installation. The Raspberry Pi Imager can
    be installed on various operating systems, including Windows, macOS, and Linux.
    For example, in this chapter, we will install it onto a Windows machine. We will
    burn a command-line version of Ubuntu 22.04 to correspond to the Humble Hawksbill
    version of ROS.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Raspberry Pi Imager，我们只需在我们的计算机上下载并安装应用程序，从其广泛的列表中选择所需的操作系统，然后选择安装的目标SD卡。Raspberry
    Pi Imager可以安装在包括Windows、macOS和Linux在内的各种操作系统上。例如，在本章中，我们将将其安装到Windows机器上。我们将烧录Ubuntu
    22.04的命令行版本，以对应Humble Hawksbill版本的ROS。
- en: 'To use the Raspberry Pi Imager to install Ubuntu onto the Raspberry Pi 3B+
    on our A.R.E.S. robot, we navigate to the URL and download the imager for the
    OS we are using ([https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/))
    and proceed to install the tool as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Raspberry Pi Imager将Ubuntu安装到我们的A.R.E.S.机器人上的Raspberry Pi 3B+，我们导航到URL并下载我们正在使用的操作系统的imager（[https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/）），然后按照以下步骤安装工具：
- en: We insert our microSD into a port on our computer.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的microSD卡插入到计算机的端口上。
- en: 'After installation, we open the tool and select **RASPBERRY PI 3** for **Raspberry
    Pi Device**, **UBUNTU SERVER 22.04.4 LTS (64-BIT)** for **Operating System**,
    and the microSD card we inserted for the **Storage** option:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们打开工具，选择**Raspberry Pi 3**作为**Raspberry Pi设备**，选择**UBUNTU SERVER 22.04.4
    LTS (64-BIT)**作为**操作系统**，以及我们插入的microSD卡作为**存储**选项：
- en: '![Figure 13.8 – Setting up the Raspberry Pi Imager](img/B21282_13_8.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图13.8 – 设置Raspberry Pi Imager](img/B21282_13_8.jpg)'
- en: Figure 13.8 – Setting up the Raspberry Pi Imager
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 设置Raspberry Pi Imager
- en: 'To proceed, we click on the **NEXT** button. This will bring us to the **Use
    OS** **customisation?** dialog:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续，我们点击**下一步**按钮。这将带我们到**使用操作系统定制？**对话框：
- en: '![Figure 13.9 – Imager customization dialog](img/B21282_13_9.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – Imager定制对话框](img/B21282_13_9.jpg)'
- en: Figure 13.9 – Imager customization dialog
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – 图像定制对话框
- en: 'As we would like to set the name of the computer and the network, we click
    on the **EDIT SETTINGS** button and get the following screen:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想设置计算机名和网络名，我们点击**编辑设置**按钮，并得到以下屏幕：
- en: '![Figure 13.10 – OS Customisation screen](img/B21282_13_10.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10 – 操作系统定制屏幕](img/B21282_13_10.jpg)'
- en: Figure 13.10 – OS Customisation screen
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 操作系统定制屏幕
- en: We set both the hostname and username to `ares`. We provide a password for the
    username and enter our SSID (LAN network) and SSID password.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主机名和用户名都设置为`ares`。我们为用户名提供了一个密码，并输入我们的SSID（局域网网络）和SSID密码。
- en: 'To enable remote access through SSH, we click on the **SERVICES** tab at the
    top and select **Enable SSH**:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过SSH启用远程访问，我们点击顶部的**服务**选项卡并选择**启用SSH**：
- en: '![](img/B21282_13_11.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21282_13_11.jpg)'
- en: Figure 13.11 – Enable SSH
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – 启用SSH
- en: To save our settings, we click on the **SAVE** button.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存我们的设置，我们点击**保存**按钮。
- en: To apply the settings, we click on the **YES** button.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要应用设置，我们点击**是**按钮。
- en: 'We will then be presented with a warning:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将随后看到一个警告：
- en: '![](img/B21282_13_12.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21282_13_12.jpg)'
- en: Figure 13.12 – Warning message
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 – 警告信息
- en: We click on **YES** as we want to erase any data on our microSD card and replace
    it with the Ubuntu operating system.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击**是**，因为我们想擦除microSD卡上的任何数据，并用Ubuntu操作系统替换它。
- en: The Raspberry Pi Imager will then proceed to install the Ubuntu 22.04 operating
    system onto our microSD card, which we will install onto the Raspberry Pi 3B+
    on A.R.E.S. We will not need to set up a Wi-Fi network or enable SSH.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Imager随后将安装Ubuntu 22.04操作系统到我们的microSD卡上，我们将将其安装到A.R.E.S.上的Raspberry
    Pi 3B+。我们不需要设置Wi-Fi网络或启用SSH。
- en: With Ubuntu installed, it is now time to install ROS and the Python libraries
    we need for A.R.E.S. We will automate this with a specialized script stored in
    our GitHub repository.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Ubuntu后，现在是时候安装ROS以及我们为A.R.E.S.需要的Python库了。我们将使用存储在我们GitHub仓库中的专用脚本来自动化这个过程。
- en: Running the installation script
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行安装脚本
- en: In previous chapters, we manually installed development libraries, a thorough
    yet time-intensive process. Now, leveraging our familiarity with Python libraries,
    we will streamline the setup of A.R.E.S. with ROS and necessary libraries through
    a script from our GitHub repository.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们手动安装了开发库，这是一个详尽但耗时的工作过程。现在，利用我们对Python库的熟悉，我们将通过GitHub仓库中的脚本简化A.R.E.S.与ROS以及必要库的设置。
- en: Executed with root privileges on Ubuntu, this script automates the installation,
    including ROS. Despite the direct installation into the OS diverging from *best
    practices*, it simplifies the process. For future projects, it is suggested that
    readers explore containerization with tools such as Docker.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上以root权限执行，此脚本自动化了包括ROS在内的安装过程。尽管直接安装到操作系统与**最佳实践**相悖，但它简化了过程。对于未来的项目，建议读者探索使用Docker等工具进行容器化。
- en: 'To run the A.R.E.S. installation script, we do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行A.R.E.S.安装脚本，我们执行以下操作：
- en: Using *Figure 13**.7* as a reference, we ensure that we have access to the ports
    on the Raspberry Pi 3B+.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以**图13.7**为参考，我们确保我们能够访问Raspberry Pi 3B+上的端口。
- en: We connect a monitor, keyboard, and mouse to our Raspberry Pi and insert the
    freshly imaged microSD card.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将显示器、键盘和鼠标连接到Raspberry Pi，并插入新镜像的microSD卡。
- en: 'As the server version of Ubuntu is command-line based, we will not be presented
    with a GUI when we boot up our Raspberry Pi. We log in using the credentials set
    during the imaging process. We should be in the `home` directory once logged in.
    We may verify this with the `pwd` command:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于Ubuntu的服务器版本是基于命令行的，因此当我们启动Raspberry Pi时，我们将不会看到一个GUI。我们使用在镜像过程中设置的凭据登录。登录后，我们应该在`home`目录中。我们可以使用`pwd`命令来验证这一点：
- en: '![Figure 13.13 – Verifying current directory](img/B21282_13_13.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图13.13 – 验证当前目录](img/B21282_13_13.jpg)'
- en: Figure 13.13 – Verifying current directory
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**图13.13 – 验证当前目录**'
- en: 'The setup script is in the book’s GitHub repository. To download the script
    and the Python code we use for the A.R.E.S. robot, we clone the repository onto
    our Raspberry Pi with the following command:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置脚本位于本书的GitHub仓库中。要下载脚本以及我们用于A.R.E.S.机器人的Python代码，我们使用以下命令将仓库克隆到我们的Raspberry
    Pi上：
- en: '[PRE0]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/B21282_13_14.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21282_13_14.jpg)'
- en: Figure 13.14 – Cloning repository
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**图13.14 – 克隆仓库**'
- en: 'The script is located inside subdirectories of the `code` directory. We copy
    it to our current directory (`.`) with the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本位于`code`目录的子目录中。我们使用以下命令将其复制到当前目录（`.`）：
- en: '[PRE1]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We verify that our script was copied over successfully with the `ls` command:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`ls`命令验证脚本是否成功复制：
- en: '![](img/B21282_13_15.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21282_13_15.jpg)'
- en: Figure 13.15 – Verifying successful copy of setup script
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**图13.15 – 验证设置脚本成功复制**'
- en: 'We execute the script with admin privileges with the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令以管理员权限执行脚本：
- en: '[PRE2]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Executing the script with admin privileges ensures it has the necessary permissions
    to perform system-level changes and installations without encountering access
    restrictions. Our script initially updates our system before installing ROS and
    the necessary Python libraries. It should take several minutes to complete. After
    completion, we should be presented with the IP address of our machine so that
    we may log in remotely with SSH. This will be necessary when A.R.E.S. is running
    remotely:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以管理员权限执行脚本确保它具有执行系统级更改和安装的必要权限，而不会遇到访问限制。我们的脚本最初会更新我们的系统，然后安装ROS和必要的Python库。这可能需要几分钟才能完成。完成后，我们应该会看到我们机器的IP地址，这样我们就可以通过SSH远程登录。当A.R.E.S.远程运行时，这将很有必要：
- en: '![Figure 13.16 – Result of running the setup script](img/B21282_13_16.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图13.16 – 运行设置脚本的结果](img/B21282_13_16.jpg)'
- en: Figure 13.16 – Result of running the setup script
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**图13.16 – 运行设置脚本的结果**'
- en: 'With the completion of our setup script, we are now able to fasten the robot
    face to the base plate of A.R.E.S.:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成我们的设置脚本后，我们现在可以将机器人面部固定到 A.R.E.S. 的底板上：
- en: '![](img/B21282_13_17.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21282_13_17.jpg)'
- en: Figure 13.17 – Front view of A.R.E.S.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17 – A.R.E.S. 的正面视图
- en: With the construction of A.R.E.S. and the OS on our Raspberry Pi 3B+ installed,
    it is time to install the code on our Raspberry Pi Pico H. Referring to *Figure
    13**.1*, we can see that A.R.E.S. uses the Pico H to control the motors, LEDs,
    and buzzer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 A.R.E.S. 和在 Raspberry Pi 3B+ 上安装操作系统后，现在是时候在我们的 Raspberry Pi Pico H 上安装代码了。参考
    *图 13*.*1*，我们可以看到 A.R.E.S. 使用 Pico H 来控制电机、LED 和蜂鸣器。
- en: We will start by writing code to control the LED and buzzer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写代码来控制 LED 和蜂鸣器。
- en: Creating alarm code for the Pico H
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Pico H 创建警报代码
- en: To program our Pico H, we will need to connect a micro-USB cable to the USB
    port on the Pico H. Despite our intentions to stagger the heights of the Pico
    H and Raspberry Pi 3B+, we may need to temporarily dismount the Raspberry Pi 3B+
    from its standoffs to attach the micro-USB cable to the Pico H.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要编程我们的 Pico H，我们需要将一个微型 USB 线连接到 Pico H 的 USB 端口。尽管我们打算错开 Pico H 和 Raspberry
    Pi 3B+ 的高度，但我们可能需要暂时从支架上卸下 Raspberry Pi 3B+，以便将微型 USB 线连接到 Pico H。
- en: Once the micro-USB cable is attached, we may plug our Pico H into a computer
    of our choice and run Thonny. We will create a class called `Alarm` inside a file
    called `device_alarm.py` on our Pico H to encapsulate the alarm functionality.
    For simplicity’s sake, we will couple the flashing of the LEDs with the activation
    of the buzzer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接了微型 USB 线，我们就可以将 Pico H 连接到我们选择的电脑上并运行 Thonny。我们将在 Pico H 上的一个名为 `device_alarm.py`
    的文件中创建一个名为 `Alarm` 的类，以封装警报功能。为了简单起见，我们将 LED 的闪烁与蜂鸣器的激活结合起来。
- en: 'To do this, we do the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: 'Referring to the *Setting up our Raspberry Pi Pico WH* section from [*Chapter
    12*](B21282_12.xhtml#_idTextAnchor195), we install CircuitPython onto our Raspberry
    Pi Pico although we select **Raspberry Pi • Pico / Pico H** for the **CircuitPython**
    **variant** option:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考第 12 章的 *设置我们的 Raspberry Pi Pico WH* 部分 [(*章节 12*](B21282_12.xhtml#_idTextAnchor195)]，尽管我们选择了
    **Raspberry Pi • Pico / Pico H** 作为 **CircuitPython** **变体**选项，但我们还是在我们的 Raspberry
    Pi Pico 上安装了 CircuitPython：
- en: '![](img/B21282_13_18.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21282_13_18.jpg)'
- en: Figure 13.18 – Installing CircuitPython onto our Raspberry Pi Pico H
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.18 – 在我们的 Raspberry Pi Pico H 上安装 CircuitPython
- en: We then activate the CircuitPython environment on our Pico H by selecting it
    from the bottom right-hand side of the screen.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从屏幕的右下角选择 Pico H，激活其上的 CircuitPython 环境。
- en: 'In a new editor, we start our code with the imports:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的编辑器中，我们以导入开始我们的代码：
- en: '[PRE3]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our code, we have the following:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`import time`: Provides time-related functions, enabling tasks such as introducing
    delays in the program execution, which is useful for controlling the flow and
    timing of operations.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import time`：提供时间相关函数，使任务如引入程序执行延迟成为可能，这对于控制操作流程和时序非常有用。'
- en: '`import board`: Accesses board-specific pins and hardware interfaces, crucial
    for interfacing with the GPIO pins on the Raspberry Pi Pico W.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import board`：访问特定于板的引脚和硬件接口，这对于与 Raspberry Pi Pico W 上的 GPIO 引脚进行接口至关重要。'
- en: '`import pwmio`: We use this library to enable precise control over the buzzer
    by manipulating the frequency and duty cycle of `import digitalio`: Manages digital
    input and output, such as reading the state of buttons or controlling LEDs, which
    is essential for digital signal interactions.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import pwmio`：我们使用这个库通过操作 `import digitalio`：管理数字输入和输出，例如读取按钮的状态或控制 LED，这对于数字信号交互至关重要。'
- en: 'We then define an `Alarm` class and create an initialization method:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个 `Alarm` 类并创建一个初始化方法：
- en: '[PRE4]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our code, the following happens:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下操作发生：
- en: We define a class named `Alarm`. The `__init__()` method takes optional parameters
    for the buzzer pin, two LED pins, and buzzer frequency with default values.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个名为 `Alarm` 的类。`__init__()` 方法接受可选参数，包括蜂鸣器引脚、两个 LED 引脚和蜂鸣器频率，并具有默认值。
- en: We then initialize the buzzer on the specified pin as a PWM output with the
    given frequency and a duty cycle of `0` (off state).
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将指定引脚上的蜂鸣器初始化为 PWM 输出，给定频率，占空比为 `0`（关闭状态）。
- en: Our code sets up two LEDs on the specified pins as digital outputs, ready to
    be turned on or off.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码在指定的引脚上设置了两个 LED 作为数字输出，准备打开或关闭。
- en: 'Our class contains only one method, `activate_alarm()`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的这个类只包含一个方法，`activate_alarm()`：
- en: '[PRE5]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our code, we do the following:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们执行以下操作：
- en: We define an `activate_alarm()` method within the `Alarm` class to activate
    the alarm a specified number of times (default is `5`).
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`Alarm`类中定义了一个`activate_alarm()`方法，用于指定次数（默认为`5`）激活警报。
- en: Inside the method, we set the `blink_rate` variable to `0.5` seconds, then loop
    for the specified number of times, toggling the buzzer and LEDs on and off according
    to the `blink_rate` variable.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法内部，我们将`blink_rate`变量设置为`0.5`秒，然后循环指定次数，根据`blink_rate`变量切换蜂鸣器和LED灯的开关。
- en: 'To test our code and wiring, we use the following code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的代码和接线，我们使用以下代码：
- en: '[PRE6]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To save the file, we click on `device_alarm.py` to our Raspberry Pi Pico H.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们点击`device_alarm.py`到我们的Raspberry Pi Pico H。
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色的**运行**按钮，在键盘上按*F5*，或者点击顶部的**运行**菜单选项，然后点击**运行****当前脚本**。
- en: We should observe the buzzer and LEDs blink for 10 repetitions.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到蜂鸣器和LED灯闪烁10次。
- en: Tip
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To prevent the execution of test code within our application, we either delete
    or comment out this code segment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止在我们的应用程序中执行测试代码，我们要么删除该代码段，要么将其注释掉。
- en: With the alarm code written and tested, it is now time to test the motors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写并测试了警报代码后，现在是时候测试电机了。
- en: Testing and controlling the motors
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和控制电机
- en: To encapsulate the motor control functionality, we create a class called `Wheel`
    inside a file called `wheel.py`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装电机控制功能，我们在一个名为`wheel.py`的文件中创建了一个名为`Wheel`的类。
- en: 'To do this, we do the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: 'Our code requires the `PicoRobotics.py` library that may be found in this chapter’s
    GitHub repository under `code` | `PicoH`. To download the library to our Pico
    H using Thonny, we first find the `lib` directory on our computer. We then right-click
    on the `lib` directory and select **Upload** **to /**:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码需要`PicoRobotics.py`库，该库可能位于本章GitHub仓库的`code` | `PicoH`下。要使用Thonny将库下载到我们的Pico
    H，我们首先在电脑上找到`lib`目录。然后我们右键点击`lib`目录并选择**上传****到/**：
- en: '![Figure 13.19 – Uploading the lib directory to our Pico H from our computer](img/B21282_13_19.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图13.19 – 将lib目录从我们的电脑上传到我们的Pico H](img/B21282_13_19.jpg)'
- en: Figure 13.19 – Uploading the lib directory to our Pico H from our computer
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19 – 将lib目录从我们的电脑上传到我们的Pico H
- en: 'We open a new editor in Thonny and start our coding by importing the `KitronikPicoRobotics`
    and `time` libraries into our program:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Thonny中打开一个新的编辑器，并通过将`KitronikPicoRobotics`和`time`库导入到我们的程序中来开始编码：
- en: '[PRE7]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These libraries will allow us to interface with the Pico robotics board. We
    then define our class and methods:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些库将允许我们与Pico机器人板进行接口。然后我们定义我们的类和方法：
- en: '[PRE8]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In our code, the following happens:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下情况发生：
- en: We define a `Wheel` class.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`Wheel`类。
- en: The `__init__()` constructor initializes the class, setting instance variables
    including `motor_board`, which encapsulates the functionality of the Pico robotics
    motor board, and the `speed` parameter to control motor speed.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__init__()`构造函数初始化类，设置实例变量，包括封装Pico机器人电机板功能的`motor_board`，以及用于控制电机速度的`speed`参数。'
- en: We implement a `forward()` method to move both wheels forward at the specified
    speed.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个`forward()`方法，以指定速度使两个轮子向前移动。
- en: We implement a `reverse()` method to move both wheels in reverse at the specified
    speed.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个`reverse()`方法，以指定速度使两个轮子反向移动。
- en: We then implement a `turn_right()` method to rotate the robot right by running
    the left wheel forward and the right wheel in reverse at the specified speed.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实现了一个`turn_right()`方法，通过以指定速度正向运行左轮和反向运行右轮来使机器人向右旋转。
- en: We implement a `turn_left()` method to rotate the robot left by running the
    right wheel in reverse and the left wheel forward at the specified speed.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个`turn_left()`方法，通过以指定速度反向运行右轮和正向运行左轮来使机器人向左旋转。
- en: We then implement a `stop()` method to stop both motors, halting the robot’s
    movement.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后实现了一个`stop()`方法来停止两个电机，使机器人的移动停止。
- en: 'To test our code and wiring, we use the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的代码和接线，我们使用以下代码：
- en: '[PRE9]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before we run the code, we must ensure that the power switch on the motor board
    is turned on and the AA battery pack is connected:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行代码之前，我们必须确保电机板上的电源开关已打开，并且AA电池组已连接：
- en: '![Figure 13.20 – Closeup of the motor board and AA battery pack](img/B21282_13_20.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图13.20 – 电机板和AA电池组的特写](img/B21282_13_20.jpg)'
- en: Figure 13.20 – Closeup of the motor board and AA battery pack
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20 – 电机板和AA电池组的特写
- en: For testing purposes, we place A.R.E.S. on the testing stand to keep its wheels
    off the ground (*Figure 13**.17*).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试目的，我们将A.R.E.S.放置在测试台上，使其车轮离地（*图13**.17*）。
- en: To save the file, we click on `wheel.py` to our Raspberry Pi Pico H.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们点击`wheel.py`到我们的Raspberry Pi Pico H。
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色的**运行**按钮，在键盘上按*F5*，或者在顶部的**运行**菜单选项中点击**运行** **当前脚本**。
- en: We should observe the wheels on A.R.E.S. go through a sequence of moving forward,
    moving in reverse, moving right, and moving left, before stopping.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在A.R.E.S.上观察车轮完成一系列动作，包括向前移动、向后移动、向右移动和向左移动，然后停止。
- en: Tip
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To avoid having our test code run outside of our test, we comment or delete
    it and save `wheel.py` onto our Pico H again.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免我们的测试代码在测试之外运行，我们将其注释或删除，并将`wheel.py`保存到我们的Pico H上。
- en: At this stage, we ensure the wheels move in the desired direction by adjusting
    the motor wiring on the motor board, which may involve rearranging the wires at
    the motor wire terminals.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们通过调整电机板上的电机接线来确保车轮按预期方向移动，这可能涉及重新排列电机线端子的电线。
- en: Having correctly configured and tested the LEDs, buzzer, and motors connected
    to the Pico H, we will now proceed to test communications between the Raspberry
    Pi Pico H and the Raspberry Pi 3B+ onboard A.R.E.S.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确配置和测试了连接到Pico H的LED、蜂鸣器和电机后，我们现在将进行Raspberry Pi Pico H和板上A.R.E.S.的Raspberry
    Pi 3B+之间的通信测试。
- en: Testing communication between Pi and Pico
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Pi和Pico之间的通信
- en: In *Figure 13**.1*, we observe that communication between the Raspberry Pi 3B+
    and the Raspberry Pi Pico H on A.R.E.S. is done through UART. Specifically, messages
    are sent from the Raspberry Pi 3B+ to the Pico H to control the LEDs, buzzer,
    and motors connected to the Pico H. We wired up the two devices through their
    respective GPIO ports when we built A.R.E.S.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13**.1*中，我们观察到Raspberry Pi 3B+和A.R.E.S.上的Raspberry Pi Pico H之间的通信是通过UART完成的。具体来说，消息是从Raspberry
    Pi 3B+发送到Pico H的，以控制连接到Pico H的LED、蜂鸣器和电机。我们在构建A.R.E.S.时通过各自的GPIO端口连接了这两个设备。
- en: In this section, we will test communication using a Python test script located
    in this chapter’s GitHub repository and a new file we will create on our Pico
    H. We will start with our Pico H.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用位于本章GitHub仓库中的Python测试脚本和我们在Pico H上创建的新文件来测试通信。我们将从Pico H开始。
- en: Creating the Pico H script
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Pico H脚本
- en: 'To create the code on our Pico H that will await commands from the Raspberry
    Pi 3B+, we do the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Pico H上创建将等待Raspberry Pi 3B+命令的代码，我们执行以下操作：
- en: 'We open a new editor in Thonny and start our coding by importing the libraries
    we need for our program:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Thonny中打开一个新的编辑器，并开始通过导入我们程序所需的库来编写代码：
- en: '[PRE10]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our code, we do the following:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们执行以下操作：
- en: We start by importing the `board` module for accessing physical pin definitions.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入`board`模块以访问物理引脚定义。
- en: We then import the `busio` module for bus communication (UART) functionalities.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们导入用于总线通信（UART）功能的`busio`模块。
- en: We use the `time` module for performing delays.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`time`模块来执行延迟。
- en: We import our `Wheel` class from our `wheel` module.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从我们的`wheel`模块中导入`Wheel`类。
- en: We then import the `Alarm` class from the `device_alarm` module we created.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从我们创建的`device_alarm`模块中导入`Alarm`类。
- en: 'With our imports in place, we set our variable declarations:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的导入就绪后，我们设置我们的变量声明：
- en: '[PRE11]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our code, we have the following:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: '`wheel = Wheel(20)`: Creates an instance of the `Wheel` class with a speed
    parameter set to `20`.'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wheel = Wheel(20)`: 创建一个`Wheel`类的实例，其速度参数设置为`20`。'
- en: '`alarm = Alarm()`: Initializes an instance of the `Alarm` class.'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alarm = Alarm()`: 初始化`Alarm`类的一个实例。'
- en: '`uart = busio.UART(board.GP4, board.GP5, baudrate=115200)`: Establishes a UART
    communication link using pins `GP4` and `GP5` on the Pico H, setting the baud
    rate to `115200`.'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uart = busio.UART(board.GP4, board.GP5, baudrate=115200)`: 使用Pico H上的`GP4`和`GP5`引脚建立UART通信链路，并将波特率设置为`115200`。'
- en: 'We then create a function to clear out our UART buffer by continuously reading
    it until no data remains (to ensure accurate and current data communication by
    removing old or irrelevant data that could lead to errors):'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个函数来清除我们的UART缓冲区，通过连续读取直到没有数据剩余（通过移除可能导致错误的旧或不相关的数据来确保准确和最新的数据通信）：
- en: '[PRE12]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our code then runs in a continuous loop waiting for messages over UART:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码随后在一个连续循环中运行，等待通过UART接收消息：
- en: '[PRE13]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In our code, the following happens:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下操作发生：
- en: We continuously read up to 32 bytes of data from the UART connection.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 UART 连接中连续读取最多 32 字节的数据。
- en: We strip away the enclosing angle brackets.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们移除包围的尖括号。
- en: We print out the received message for debugging purposes.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印出接收到的消息以进行调试。
- en: 'We use an `if` statement to execute a specific action based on the message
    content:'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `if` 语句根据消息内容执行特定操作：
- en: The robot moves forward if the message is `'f'`.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息是 `'f'`，机器人会向前移动。
- en: The robot moves in reverse if the message is `'b'`.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息是 `'b'`，机器人会向后移动。
- en: The robot turns left if the message is `'l'`.
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息是 `'l'`，机器人会向左转。
- en: The robot turns right if the message is `'r'`.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息是 `'r'`，机器人会向右转。
- en: The robot activates an alarm and stops movement if the message is `'a'`.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息是 `'a'`，机器人会激活警报并停止移动。
- en: The robot stops any movement if the message doesn’t match any of the specified
    commands.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息不匹配任何指定的命令，机器人会停止任何移动。
- en: Our code then clears the UART buffer to remove any remaining data.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后清除 UART 缓冲区以移除任何剩余的数据。
- en: We then introduce a brief delay of 0.1 seconds to prevent overwhelming the CPU.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们引入一个短暂的 0.1 秒延迟，以防止 CPU 过载。
- en: To save the file, we click on `code.py` to our Raspberry Pi Pico H.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们点击 `code.py` 到我们的 Raspberry Pi Pico H。
- en: To run our code, we click on the green **Run** button, hit *F5* on the keyboard
    or click on the **Run** menu option at the top, and then **Run** **current script**.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色的 **运行** 按钮，在键盘上按 *F5* 或者在顶部点击 **运行** 菜单选项，然后点击 **运行** **当前脚本**。
- en: After executing `code.py`, it is expected that our code will not produce any
    output in the Shell, indicating it is in a state of waiting for communication
    from the Raspberry Pi. With the Pico H set up and waiting for messages it is now
    time to execute our test script from the Raspberry Pi.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `code.py` 后，我们期望我们的代码在 Shell 中不会产生任何输出，这表明它处于等待来自 Raspberry Pi 的通信的状态。在 Pico
    H 设置并等待消息后，现在是时候从 Raspberry Pi 执行我们的测试脚本了。
- en: Running UART test code from the Raspberry Pi
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Raspberry Pi 运行 UART 测试代码
- en: Inside this chapter’s GitHub repository, we have a file named `uart-test.py`
    that we may use to test the connection between the Raspberry Pi and Pico H on
    our A.R.E.S. robot. In this section, we will SSH into our Raspberry Pi from a
    Windows computer using PuTTY and run the test, all the while keeping our Pico
    connected through Thonny.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 GitHub 仓库中，我们有一个名为 `uart-test.py` 的文件，我们可以用它来测试我们的 A.R.E.S. 机器人上 Raspberry
    Pi 和 Pico H 之间的连接。在本节中，我们将使用 PuTTY 从 Windows 计算机登录到我们的 Raspberry Pi 并运行测试，同时保持我们的
    Pico 通过 Thonny 连接。
- en: 'To do this, we do the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: 'Using a program such as PuTTY on Windows, or a Terminal on a Linux-based system,
    we log in to our Raspberry Pi 3B+ using the IP address (as the hostname) we obtained
    after running the setup script:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Windows 上的 PuTTY 等程序，或基于 Linux 的系统上的终端，我们使用运行设置脚本后获得的 IP 地址（作为主机名）登录我们的 Raspberry
    Pi 3B+：
- en: '![Figure 13.21 – Using PuTTY in Windows to log in to our Raspberry Pi 3B+](img/B21282_13_21.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.21 – 在 Windows 中使用 PuTTY 登录我们的 Raspberry Pi 3B+](img/B21282_13_21.jpg)'
- en: Figure 13.21 – Using PuTTY in Windows to log in to our Raspberry Pi 3B+
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.21 – 在 Windows 中使用 PuTTY 登录我们的 Raspberry Pi 3B+
- en: If this is the first time logging in through PuTTY, we may get a security alert.
    We click **Accept** to proceed.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是第一次通过 PuTTY 登录，我们可能会收到安全警报。我们点击 **接受** 以继续。
- en: 'To copy our test program to the current directory, we run the following command
    (we must not forget the dot):'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将我们的测试程序复制到当前目录，我们运行以下命令（我们绝对不能忘记点号）：
- en: '[PRE14]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: vi uart-test.py
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vi uart-test.py
- en: '[PRE15]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Figure 13.22 – Viewing uart-test.py in the vi editor](img/B21282_13_22.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.22 – 在 vi 编辑器中查看 uart-test.py](img/B21282_13_22.jpg)'
- en: Figure 13.22 – Viewing uart-test.py in the vi editor
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.22 – 在 vi 编辑器中查看 uart-test.py
- en: 'We close the editor with the following command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令关闭编辑器：
- en: '[PRE16]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: sudo python3 uart-test.py
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo python3 uart-test.py
- en: '[PRE17]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We should observe the LEDs and buzzer activating in two pulses, with Thonny’s
    output confirming receipt of an alarm message:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到 LED 和蜂鸣器在两个脉冲中激活，同时 Thonny 的输出确认已收到警报消息：
- en: '![Figure 13.23 – Results from running the uart-test.py test script](img/B21282_13_23.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.23 – 运行 uart-test.py 测试脚本的输出结果](img/B21282_13_23.jpg)'
- en: Figure 13.23 – Results from running the uart-test.py test script
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.23 – 运行 uart-test.py 测试脚本的输出结果
- en: With the successful testing of the UART connection between the Raspberry Pi
    and Raspberry Pi Pico H on our A.R.E.S. robot, it is now time to test the distance
    sensor.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 A.R.E.S. 机器人上成功测试了 Raspberry Pi 和 Raspberry Pi Pico H 之间的 UART 连接后，现在是时候测试距离传感器了。
- en: Testing the ToF sensor
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 ToF 传感器
- en: To measure distances in front of A.R.E.S., we will use the VL53L0X ToF sensor
    from Adafruit. The sensor is capable of measuring distances from 30 mm to 1.2
    meters with high accuracy, using a tiny laser to detect light’s travel time. Its
    narrow beam overcomes the limitations of sonar or **infrared** (**IR**) sensors,
    making it ideal for precision tasks in robotics and interactive projects. Compatible
    with 3-5V and I2C communication, it’s designed for easy use with various microcontrollers.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测量A.R.E.S.前方距离，我们将使用Adafruit提供的VL53L0X ToF传感器。该传感器能够以高精度测量从30毫米到1.2米的距离，通过使用微型激光来检测光传播的时间。其窄光束克服了声纳或**红外**（**IR**）传感器的局限性，使其非常适合在机器人和交互式项目中执行精密任务。兼容3-5V和I2C通信，它设计用于与各种微控制器轻松使用。
- en: For A.R.E.S., we have the VL53L0X connected to our Raspberry Pi 3B+. We will
    use it in our design to stop our robot from moving forward once it detects an
    object less than 10 cm away.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于A.R.E.S.，我们将VL53L0X连接到我们的Raspberry Pi 3B+。我们将在设计中使用它，一旦检测到距离小于10厘米的物体，机器人就会停止前进。
- en: 'To test the sensor, we run a test script available in this chapter’s GitHub
    repository. To run the test, we do the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试传感器，我们运行本章GitHub存储库中可用的测试脚本。要运行测试，我们执行以下操作：
- en: Using a program such as PuTTY on Windows, or a Terminal on a Linux-based system,
    we log in to our Raspberry Pi 3B+ using the IP address we obtained after running
    the setup script.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Windows上的PuTTY程序或基于Linux的系统上的终端，我们使用在运行设置脚本后获得的IP地址登录到我们的Raspberry Pi 3B+。
- en: 'To copy our test program to the current directory, we run the following command
    (we must not forget the dot):'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将我们的测试程序复制到当前目录，我们运行以下命令（我们绝对不能忘记点号）：
- en: '[PRE18]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To run the test, we execute the following command:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行测试，我们执行以下命令：
- en: '[PRE19]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By positioning a hand at varying distances from the sensor, which is integrated
    into A.R.E.S.’s mouth, we should observe corresponding variations in the sensor’s
    output values displayed in the terminal:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将手放置在传感器（集成到A.R.E.S.的口中）的不同距离处，我们应该在终端中观察到传感器输出值的相应变化：
- en: '![Figure 13.24 – Output from the testing of the VL53L0X ToF sensor](img/B21282_13_24.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图13.24 – 测试VL53L0X ToF传感器的输出](img/B21282_13_24.jpg)'
- en: Figure 13.24 – Output from the testing of the VL53L0X ToF sensor
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.24 – 测试VL53L0X ToF传感器的输出
- en: Are ToF sensors the same as distance sensors?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ToF传感器与距离传感器是否相同？
- en: A ToF sensor, measuring the time for light to bounce back from an object, provides
    precise distance readings. In contrast, traditional distance sensors, often using
    ultrasonic or IR technology, gauge distances based on sound waves or light intensity.
    ToF sensors typically offer higher accuracy and reliability across various ranges
    compared to these common distance sensors.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ToF传感器，通过测量光从物体反弹回来的时间，提供精确的距离读数。相比之下，传统的距离传感器，通常使用超声波或IR技术，基于声波或光强度来测量距离。ToF传感器通常在各种范围内提供比这些常见距离传感器更高的精度和可靠性。
- en: With the ToF sensor operational, we’re set to configure A.R.E.S.’s camera, which,
    unlike the Raspberry Pi and Pico H, streams video outside the ROS environment,
    accessible by any network device.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在ToF传感器运行后，我们准备配置A.R.E.S.的相机，与Raspberry Pi和Pico H不同，该相机在ROS环境之外流式传输视频，任何网络设备都可以访问。
- en: We will use the Arduino IDE to program the camera.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Arduino IDE来编程相机。
- en: Streaming video from A.R.E.S.
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从A.R.E.S.流式传输视频。
- en: For video streaming, we’ll use the M5Stack Timer Camera X, powered by an ESP32
    chip with a 3-million-pixel (ov3660) sensor for up to 2048x1536 pixel images.
    Although it supports I2C for configuration, we’ll directly power it with the Raspberry
    Pi 3B+’s 5V supply, bypassing the I2C setup. The camera serves as the nose of
    our A.R.E.S. robot.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视频流，我们将使用由ESP32芯片供电的M5Stack Timer Camera X，该芯片配备300万像素（ov3660）传感器，可拍摄高达2048x1536像素的图像。尽管它支持I2C进行配置，但我们将通过Raspberry
    Pi 3B+的5V电源直接为其供电，绕过I2C设置。该相机作为我们A.R.E.S.机器人的“鼻子”。
- en: 'We will use the Arduino IDE and a program provided by M5Stack to set up the
    camera. To do so, we do the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Arduino IDE和M5Stack提供的程序来设置相机。为此，我们执行以下操作：
- en: Using a web browser, navigate to the Arduino website and download the latest
    Arduino IDE from [https://www.arduino.cc/en/software](https://www.arduino.cc/en/software).
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器，导航到Arduino网站，并从[https://www.arduino.cc/en/software](https://www.arduino.cc/en/software)下载最新的Arduino
    IDE。
- en: Once downloaded, we install the Arduino IDE and open it.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，我们安装Arduino IDE并打开它。
- en: 'To add our M5Stack Timer Camera X library and example code to the Arduino IDE,
    we select **File** | **Preferences** (in Windows) and add the following URL to
    the **Additional boards manager URLs** box: [https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/arduino/package_m5stack_index.json](https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/arduino/package_m5stack_index.json).'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将我们的M5Stack Timer Camera X库和示例代码添加到Arduino IDE中，我们选择**文件** | **首选项**（在Windows中）并将以下网址添加到**附加板管理器网址**框中：[https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/arduino/package_m5stack_index.json](https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/arduino/package_m5stack_index.json).
- en: 'The dialog box should look like the following:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话框应如下所示：
- en: '![Figure 13.25 – Adding M5Stack boards to the Arduino IDE](img/B21282_13_25.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图13.25 – 将M5Stack板添加到Arduino IDE](img/B21282_13_25.jpg)'
- en: Figure 13.25 – Adding M5Stack boards to the Arduino IDE
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.25 – 将M5Stack板添加到Arduino IDE
- en: We click **OK** to close the dialog.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们点击**确定**以关闭对话框。
- en: Using a USB-C cable, we connect our Timer Camera X to the computer running the
    Arduino IDE. We may remove the camera from the face of A.R.E.S. to make it easier
    to access the USB-C port.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用USB-C线缆，我们将Timer Camera X连接到运行Arduino IDE的电脑。我们可以从A.R.E.S.的表面移除相机，以便更容易访问USB-C端口。
- en: 'To set **M5TimerCAM** as the device, we click on **Tools** | **Board** | **M5Stack**
    | **M5TimerCAM**:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将**M5TimerCAM**设置为设备，我们点击**工具** | **板** | **M5Stack** | **M5TimerCAM**：
- en: '![Figure 13.26 – Selecting M5TimerCAM](img/B21282_13_26.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图13.26 – 选择M5TimerCAM](img/B21282_13_26.jpg)'
- en: Figure 13.26 – Selecting M5TimerCAM
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26 – 选择M5TimerCAM
- en: Next, we need to select the port our camera is connected to. To do this, we
    click on **Tools** | **Port** and select the port our camera is connected to (it
    helps to only have the camera connected to our computer as there will be only
    one option).
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要选择相机连接的端口。为此，我们点击**工具** | **端口**并选择相机连接的端口（如果只将相机连接到我们的电脑，将只有一个选项）。
- en: To access the M5Stack Timer Camera example code, we click on **Tools** | **Manage
    Libraries…** and search for **Timer-CAM**.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问M5Stack Timer Camera示例代码，我们点击**工具** | **管理库…**并搜索**Timer-CAM**。
- en: 'We then hover our mouse beside the title of the section until three dots appear
    and select **Examples** | **rtsp_stream**:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后将鼠标悬停在章节标题旁边，直到出现三个点，然后选择**示例** | **rtsp_stream**：
- en: '![Figure 13.27 – Selecting the rtsp_stream example code](img/B21282_13_27.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图13.27 – 选择rtsp_stream示例代码](img/B21282_13_27.jpg)'
- en: Figure 13.27 – Selecting the rtsp_stream example code
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27 – 选择rtsp_stream示例代码
- en: This will open another Arduino window with the example code.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开另一个包含示例代码的Arduino窗口。
- en: 'We need the Serial Monitor to find the address where the video will be broadcast.
    To load the Serial Monitor, we click on **Tools** | **Serial Monitor**:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要串行监视器来找到视频将广播的地址。要加载串行监视器，我们点击**工具** | **串行监视器**：
- en: '![Figure 13.28 – Viewing the Serial Monitor](img/B21282_13_28.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图13.28 – 查看串行监视器](img/B21282_13_28.jpg)'
- en: Figure 13.28 – Viewing the Serial Monitor
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28 – 查看串行监视器
- en: We set the baud rate to `115200` and enter the SSID name and password into the
    code (areas annotated in the previous figure).
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将波特率设置为`115200`并将SSID名称和密码输入到代码中（如图中所示的区域）。
- en: 'To upload the code to our camera, we click on the **Upload** button, which
    looks like this: ![](img/B21282_13_29.png).'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将代码上传到我们的相机，我们点击**上传**按钮，其外观如下：![](img/B21282_13_29.png).
- en: 'After compilation, the code is uploaded to our camera. We may view the `rtsp`
    address in the Serial Monitor:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译后，代码将上传到我们的相机。我们可以在串行监视器中查看`rtsp`地址：
- en: '![](img/B21282_13_30.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21282_13_30.jpg)'
- en: Figure 13.29 – Output to the Serial Monitor
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.29 – 输出到串行监视器
- en: 'We copy the `rtsp` URL and paste it into a VLC media player by clicking on
    **Media** | **Open Network Stream…** in the VLC media player:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们复制`rtsp` URL并将其粘贴到VLC媒体播放器中，方法是点击VLC媒体播放器中的**媒体** | **打开网络流…**：
- en: '![Figure 13.30 – Video streaming using the VLC media player](img/B21282_13_31.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图13.30 – 使用VLC媒体播放器进行视频流](img/B21282_13_31.jpg)'
- en: Figure 13.30 – Video streaming using the VLC media player
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.30 – 使用VLC媒体播放器进行视频流
- en: To begin streaming, we click on the **Play** button.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始流式传输，我们点击**播放**按钮。
- en: 'We should observe a feed from our camera:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到来自相机的视频流：
- en: '![Figure 13.31 – Video feed from our camera as shown in the VLC media player](img/B21282_13_32.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图13.31 – 在VLC媒体播放器中显示的相机视频流](img/B21282_13_32.jpg)'
- en: Figure 13.31 – Video feed from our camera as shown in the VLC media player
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.31 – 在VLC媒体播放器中显示的相机视频流
- en: A.R.E.S. is currently missing its nose, but after testing the camera, we can
    disconnect the USB-C cable and reattach it to A.R.E.S.’s face. This completes
    the testing phase for A.R.E.S.’s components, paving the way for us to develop
    a ROS node and enable control of A.R.E.S. over the internet.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: A.R.E.S. 目前缺少鼻子，但在测试了摄像头后，我们可以断开USB-C电缆并将其重新连接到A.R.E.S.的面部。这完成了A.R.E.S.组件的测试阶段，为我们开发ROS节点并允许通过互联网控制A.R.E.S.铺平了道路。
- en: Programming A.R.E.S. with ROS
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ROS编程A.R.E.S.
- en: Now that A.R.E.S. has been assembled and the essential software and firmware
    have been installed, we are ready to employ ROS for remote control over the internet.
    During our setup, we installed ROS along with all the necessary libraries. Along
    with our setup script, we downloaded test scripts from our GitHub repository,
    which we ran to ensure everything was functioning correctly.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，A.R.E.S. 已经组装完成，并且必要的软件和固件已经安装，我们准备使用ROS通过互联网进行远程控制。在我们的设置过程中，我们安装了ROS以及所有必要的库。除了我们的设置脚本外，我们还从GitHub仓库下载了测试脚本，并运行它们以确保一切正常工作。
- en: A pre-existing ROS workspace also exists in our GitHub repository. To create
    a ROS node with this code, simply transfer the pre-existing workspace to our `home`
    directory and execute a `colcon` `build` command.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GitHub仓库中已经存在一个预存在的ROS工作空间。要使用此代码创建一个ROS节点，只需将预存在的工作空间转移到我们的 `home` 目录，并执行一个
    `colcon build` 命令。
- en: 'To do this, we do the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们执行以下操作：
- en: Using a program such as PuTTY on Windows, or a Terminal on a Linux-based system,
    we log in to our Raspberry Pi 3B+ using the IP address we obtained after running
    the setup script.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Windows上的PuTTY程序或基于Linux的系统上的终端，我们使用在运行设置脚本后获得的IP地址登录到我们的Raspberry Pi 3B+。
- en: 'To copy our ROS workspace to the current directory, we run the following command
    (we must not forget the dot):'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将我们的ROS工作空间复制到当前目录，我们运行以下命令（我们绝对不能忘记这个点）：
- en: '[PRE20]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then navigate into our workspace with the following command:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用以下命令进入我们的工作空间：
- en: '[PRE21]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We source the ROS environment with the following command:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令源ROS环境：
- en: '[PRE22]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'robot_control.py file from *Chapter 12*, we will explore only certain parts
    of the code. We start with code located inside the initialization method we use
    to give us the permissions to use the serial0 port:'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *第12章* 的 `robot_control.py` 文件中，我们将仅探索代码的某些部分。我们从初始化方法中的代码开始，该方法是用来给我们使用串行0端口的权限：
- en: '[PRE23]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Important note
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is highly advisable not to put the admin password inside a file due to security
    concerns. However, with our application operating in a strictly controlled development
    environment where access is tightly restricted, we bypass this guideline. We require
    this password so that we may change permissions on the `serial0` port. Without
    it, we would not have access and thus could not send commands to the Pico H.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全考虑，强烈建议不要将管理员密码放在文件中。然而，在我们的应用程序在严格控制的开发环境中运行，且访问受到严格限制的情况下，我们绕过了这一指南。我们需要这个密码，以便我们可以更改
    `serial0` 端口的权限。没有它，我们将无法访问，因此无法向Pico H发送命令。
- en: 'In our code, the following happens:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下操作会发生：
- en: We store a `sudo` user’s password in the `password` variable. We set the command
    to change permissions of `/dev/serial0` to read and write for all users in the
    `command` variable.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `sudo` 用户的密码存储在 `password` 变量中。我们将更改 `/dev/serial0` 权限以供所有用户读写操作的命令存储在 `command`
    变量中。
- en: Our code then executes the command using `sudo` without manual password entry
    by piping the password into `sudo -S`, utilizing `subprocess.run` with shell execution
    enabled and enforcing command success with `check=True`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `sudo` 命令执行操作，无需手动输入密码，通过将密码管道输入到 `sudo -S` 中，利用 `subprocess.run` 并启用shell执行，以及通过
    `check=True` 强制命令成功。
- en: 'Inside the initialization method, we also set the `ser` instance variable to
    be equal to `serial0`, the port we connect our Pico H to:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化方法内部，我们还设置了 `ser` 实例变量等于 `serial0`，这是我们连接Pico H的端口：
- en: '[PRE25]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our `send_message()` method formats a command to sit within open (`<`) and
    closed (`>`) angle brackets and sends out messages over the serial port:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `send_message()` 方法将命令格式化为位于开括号 `<` 和闭括号 `>` 之间，并通过串行端口发送消息：
- en: '[PRE26]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In our code, the following happens:'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下操作会发生：
- en: We check if the current command is `'s'` and if the last sent command was also
    `'s'` to prevent sending `'s'` consecutively. This is done as the stop command
    is the default command when there is no engagement with the IoT joystick and thus
    can flood the communication channel with redundant signals, potentially causing
    unnecessary processing and response delays in the system.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查当前命令是否为 `'s'`，以及上一个发送的命令是否也是 `'s'`，以防止连续发送 `'s'`。这是因为在没有与物联网摇杆交互时，停止命令是默认命令，因此可能会使通信通道充满冗余信号，从而可能导致系统中的不必要的处理和响应延迟。
- en: If the preceding condition is met, our code skips sending the command and logs
    a message about it.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果满足前面的条件，我们的代码将跳过发送命令，并记录相关信息。
- en: We then format `command` with opening (`<`) and closing (`>`) angle brackets,
    followed by a newline.
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后使用开括号（`<`）和闭括号（`>`）格式化 `command`，然后跟一个换行符。
- en: We log the framed command being sent. Our code then sends the framed command
    over the serial port using `.encode()` to convert it to bytes.
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们记录正在发送的封装命令。然后，我们的代码使用 `.encode()` 将封装命令转换为字节，并通过串行端口发送。
- en: We log the original command (stripped of whitespace) as sent. Our code then
    updates `self.last_command_sent` with the current command (stripped of whitespace)
    for future checks.
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们记录原始命令（去除空白字符）的发送情况。然后，我们的代码将当前命令（去除空白字符）更新到 `self.last_command_sent` 中，以供将来检查。
- en: 'To build our code, we execute the `colcon` command:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要构建我们的代码，我们执行 `colcon` 命令：
- en: '[PRE27]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After building our node, we source it with the following command:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建我们的节点后，我们使用以下命令对其进行源码设置：
- en: '[PRE28]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are now ready to run our node to have our robot controlled by our IoT Joystick.
    We do so with the following command:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好运行我们的节点，让我们的机器人通过物联网摇杆进行控制。我们使用以下命令来完成此操作：
- en: '[PRE29]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is advisable to have A.R.E.S. up on the test stand before we send it commands.
    With our node running, we may control A.R.E.S. using the IoT joystick we built
    in [*Chapter 12*](B21282_12.xhtml#_idTextAnchor195).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发送命令之前，建议将 A.R.E.S. 放在测试台上。随着我们的节点运行，我们可以使用我们在 [*第 12 章*](B21282_12.xhtml#_idTextAnchor195)
    中构建的物联网摇杆来控制 A.R.E.S.。
- en: We have just controlled a robot over the internet using MQTT and ROS. Controlling
    a robot over the internet using MQTT and ROS not only demonstrates the technical
    feasibility of remote robotic operations but also highlights the potential for
    use cases where remote monitoring and intervention are critical, such as in **disaster
    recovery** (**DR**), hazardous environment exploration, and healthcare support.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用 MQTT 和 ROS 通过互联网控制了一个机器人。使用 MQTT 和 ROS 通过互联网控制机器人不仅证明了远程机器人操作的技术可行性，而且突出了远程监控和干预的潜在用途，这些用途在
    **灾难恢复**（**DR**）、危险环境探索和医疗保健支持等领域至关重要。
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we integrated MQTT and ROS and created the A.R.E.S. robot.
    Using MQTT, a lightweight messaging protocol, enabled us to have efficient and
    reliable communication between the robot and our IoT joystick. ROS offers us a
    robust framework for developing complex robotic applications. By choosing ROS
    to build A.R.E.S., we leverage its vast ecosystem of tools and libraries, ensuring
    our robot is not only capable of performing advanced tasks but is also scalable
    and adaptable for future enhancements.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们集成了 MQTT 和 ROS，并创建了 A.R.E.S. 机器人。使用 MQTT，一种轻量级消息协议，使我们能够在机器人和我们的物联网摇杆之间实现高效且可靠的通信。ROS
    为我们提供了一个强大的框架，用于开发复杂的机器人应用。通过选择 ROS 构建 A.R.E.S.，我们利用其庞大的工具和库生态系统，确保我们的机器人不仅能够执行高级任务，而且能够适应未来的增强和扩展。
- en: As we built and programmed A.R.E.S., we could easily imagine using our knowledge
    to build more advanced robots capable of performing complex tasks, interacting
    seamlessly with humans, and adapting to various environments and challenges autonomously.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和编程 A.R.E.S. 的过程中，我们很容易想象利用我们的知识来构建更先进的机器人，这些机器人能够执行复杂任务，与人类无缝交互，并能够自主适应各种环境和挑战。
- en: In our next and final chapter, we will add vision recognition to A.R.E.S.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的最后一章中，我们将为 A.R.E.S. 添加视觉识别功能。
