- en: Chapter 6. Maintaining Your Test Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we do TDD regularly, we can easily end up with a large test suite containing
    thousands of tests. This is great—it gives us a lot of confidence to boldly go
    in and add new features without worrying about breaking old features. However,
    it is crucial that we make test maintenance easy, otherwise we will soon be in
    a mess just managing the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Tests that are not written to be maintained will soon bring about a number of
    headaches. Tests that are strewn all over the filesystem will make it impossible
    to locate specific tests. Tests that are difficult to read will be hard to understand
    and fix when the tests need to be changed due to changes in functionality. Long,
    poorly written tests will pose the same challenges that poor production quality
    code does. And brittle tests will ensure that even small changes will break a
    large number of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that test code is still code. And just like any production code, we
    must do our best to keep it readable, maintainable, and easy to change. It is
    easy for us to fall into the trap of hacking out test cases and then forgetting
    about them. A year later, we find that maintaining the tests is a huge headache,
    and it is more difficult to add new features than it was before.
  prefs: []
  type: TYPE_NORMAL
- en: Goals of test maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen throughout this book, unit tests serve a number of different
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serve as a test suite**: This is the most obvious goal of unit tests. A comprehensive
    test suite reduces the number of bugs that can escape into production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serve as documentation**: When we are trying to understand what a class or
    method is trying to do, it is useful to take a look at the test suite. A well-written
    test suite will illustrate how the piece of code is supposed to behave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serve as a safety net**: This frees us from pressure when we refactor or
    clean up the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Illustrate the design**: Using mocks, we can depict the interactions between
    different classes or modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of a well-written suite of unit tests is to enable these purposes as
    well as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to understand what a method does, then we need to work
    out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Can we locate its unit test suite easily?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once located, is it easy to understand the tests and what they are testing for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we understand how this method interacts with other classes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we understand what the method does, then is it easy to refactor it? Does
    making small refactorings break all the tests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it easy to identify which tests have broken due to our refactoring and which
    failures are bugs in the refactoring?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we need to make changes in the test case due to the refactoring, then how
    difficult is it to understand the test and make the required change?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any large, long-term project will involve answering all these questions.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal in this chapter is to look at ways to make it easier to perform the
    preceding activities.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in easing test maintenance is to have a systematic way of organizing
    tests. When we are implementing a new feature, we need to be able to quickly and
    easily locate the existing test code for a given method or class. There are three
    steps to making this easy. We have to decide:'
  prefs: []
  type: TYPE_NORMAL
- en: Where the files are stored on the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the files are called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names of the test classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystem layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main consideration in deciding where to place our test code is the ease
    with which we can locate the tests for a specific class or module. Apart from
    this, there are two other considerations to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: How will this module be packaged and distributed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How will this code be put into production?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first consideration, we have to keep in mind that we will want to distribute
    unit tests along with the main code. For code that goes into production, we might
    not always want tests to be deployed, so we would be looking at a way to separate
    the code and tests.
  prefs: []
  type: TYPE_NORMAL
- en: Given all these considerations, there are two popular ways of laying out the
    test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first pattern, the test code is placed as a submodule of the main code
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to package up both the module and the tests by just zipping up
    the module directory and putting it in an `egg` file. The whole package is self-contained
    and can be used directly. The module is accessed using an `import module` statement,
    and the tests are accessed by using `import module.tests`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests also requires no configuration, as the tests can access the
    classes in the test code with relative imports such as `from ..file import class`.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is excellent for standalone modules that will be packaged in `egg`
    files and distributed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other pattern is to keep tests in a separate folder hierarchy altogether.
    The file layout will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding pattern is suitable for situations where there is a need to separate
    out the tests from the code. This could be because we are making a product and
    don't want to send tests to our customers, or it could be because we don't want
    to deploy tests to the production servers. This pattern is suitable because it
    is easy to zip up the module alone into an `egg` file and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside of the pattern is that if the project involves many modules, then
    it can be troublesome to separate out tests for the different modules. One pattern
    is to use different roots for each directory, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding pattern is commonly seen in languages such as Java, but it is
    overall quite cumbersome and verbose. However, it could be a solution for specific
    needs like the ones mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two patterns we definitely *don''t* want to do are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the tests in the same file as the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place the test files in the same directory as the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing tests in the same file as code is okay for single file scripts, but
    it is messy for anything bigger than that. The problem is that if the file is
    long, then it becomes very difficult to navigate the file. And since tests often
    need to import other classes, it pollutes the namespace. It also increases the
    chances for circular imports. Finally, it makes it difficult to execute all the
    tests at once because the test runners look for patterns in the filename.
  prefs: []
  type: TYPE_NORMAL
- en: As for placing files in the same directory, it once again messes up the module,
    making it difficult to find files in the directory. It doesn't have any specific
    advantages apart from not having to create a separate tests directory. Avoid this
    pattern and create a submodule instead.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to decide on a naming convention for test files, test classes,
    and test methods.
  prefs: []
  type: TYPE_NORMAL
- en: For test files, it is best to go with the `test_` prefix for the file. For example,
    a file called `file1.py` will have its tests in `test_file1.py`. This makes it
    easy for us to locate the corresponding test code when we are looking at some
    production code. Having the `test_` prefix is preferable because this is the default
    pattern that is searched by most test runners. If we use some other prefix, or
    use a suffix like `file1_test.py`, then most probably we will have to pass additional
    configuration into the test runner to find and execute the tests. This extra configuration
    is easily avoidable by just sticking to the default convention that is expected
    from most of the commonly used tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can run the tests with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we were to name our tests with a suffix of `_test`, then we have to
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It works, but it is just extra configuration that can be avoided. We should
    use this only if we have a legacy naming convention that needs to be preserved.
  prefs: []
  type: TYPE_NORMAL
- en: What about test classes and test methods? The `unittest` module looks at all
    classes that inherit from `unittest.TestCase`. So, the class name does not matter.
    However, other test runners such as `nose2` also pick up test classes based on
    the name of the class. The default pattern is to search for classes that end with
    `Test`. It therefore makes sense to name all the test classes to end with `Test`.
    It is also descriptive, so there really is no good reason to do anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, test methods should start with `test`. This is the default pattern
    that test runners search for, and once again it makes sense to just stick to this
    convention. Methods that do not start with `test` can be used as helper methods.
  prefs: []
  type: TYPE_NORMAL
- en: Test suite grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we come to the question of what a class should contain—should one test
    class contain tests for a target class, or should we store all the tests for a
    method in a test class? Here, it is more a question of personal preference. Neither
    is objectively better or worse, it just depends on which is more readable. My
    personal preference is to use both patterns within a single codebase, depending
    on how many tests there are and which pattern makes it easier to find the tests
    that I am looking for. In general, if there are a lot of tests for a single method,
    then I would refactor them into a separate test class.
  prefs: []
  type: TYPE_NORMAL
- en: Making tests readable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at the rather mundane issue of file layout
    and naming conventions. We are now going to take a look at the ways we can improve
    the test cases themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Our first goal is to make it easier to understand the tests themselves. There
    is nothing worse than locating a test case and then having a hard time figuring
    out what the test is trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure I will not be the first to confess that there have been multiple occasions
    where I have returned to a test that I myself wrote a year back, and struggled
    to understand what I was trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: This is an area that is often ignored because when we write the test, it seems
    perfectly obvious what the test does. We will need to put ourselves in the shoes
    of someone who is looking at the test for the first time or after a couple of
    years and trying to understand the test without having the contextual knowledge
    that we had while writing the test. This is a recurring problem when working on
    large codebases.
  prefs: []
  type: TYPE_NORMAL
- en: Using docstrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first line of defense for an unreadable test is to use a docstring. **Docstrings**
    are a great feature of Python because they are available at runtime. Test runners
    typically pick up a docstring and display it during test errors and failures,
    making it easy to see what is failing from the test report itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some people will say that a well-written test has no need for additional explanation.
    In fact, we said something similar in [Chapter 3](ch03.html "Chapter 3. Code Smells
    and Refactoring"), *Code Smells and Refactoring* when we discussed the value of
    comments. To repeat what we said there: there is no value in comments that explain
    what is going on, but there is value in comments that explain why we have implemented
    the code as we have. The same principle applies to docstrings as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `get_closing_price_list` method from the `TimeSeries` class that
    we refactored in [Chapter 3](ch03.html "Chapter 3. Code Smells and Refactoring"),
    *Code Smells and Refactoring*. The following is a test for that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This test checks that an empty list is returned when the date passed is before
    the start of the timeseries. This is quite clear from the test. But why does it
    return an empty list instead of, say, throwing an exception? A docstring provides
    a good place to explain this design decision, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having looked at docstrings, we can now turn our attention to the tests themselves.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the general structure of unit tests, they generally follow the
    Arrange-Act-Assert structure. Of these, the Act section is usually only a couple
    of lines and the Assert section is also a few lines at most. By far the biggest
    part of the test is in the Arrange section. For more complex tests, where a specific
    scenario might take many lines to set up, the Arrange section could easily be
    75 percent to 80 percent of the whole test.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of avoiding repetitive code is to move it all into the appropriate
    `setUp` and `tearDown` methods. As we saw in [Chapter 2](ch02.html "Chapter 2. Red-Green-Refactor
    – The TDD Cycle"), *Red-Green-Refactor – The TDD Cycle*, `unittest` provides three
    levels of setup and teardown methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setUp` and `tearDown` that are run before and after each test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setUpClass` and `tearDownClass` that are run before and after each test class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setUpModule` and `tearDownModule` that are run before and after each test
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method of setting up the data for a test is called a **fixture**. Using
    fixtures is a good idea to reduce common code duplication between tests. However,
    there are some downsides to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, there is a lot of setup to be done, but each of the tests only use
    a small part of the overall fixture. In this case, it can be confusing for a new
    developer to figure out which part of the fixture is used by each test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to be careful when using class- and module-level fixtures. Because the
    fixture is shared between multiple tests, we have to be careful that we don't
    change the state of the fixture. If we do, then there is the possibility that
    the result of one test could alter the fixture state for the next. This could
    lead to very strange bugs when tests are executed in a different order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One thing to be aware of is that if the `setUp` method throws an exception,
    then the `tearDown` method is not called. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If an exception is raised in the `connect_to_server` call, then the `tearDown`
    method will not be called. This will leave the connection to the database hanging
    open. When `setUp` is called for the next test, the first line might fail (because
    the connection is already open), causing all the other tests to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this situation, the `unittest` module provides the `addCleanup` method.
    This method takes a callback function, which is called no matter whether the setup
    passed or failed, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With this structure, how execution will flow is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the database call failed, then no cleanup will be performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the database call succeeded but the server call failed, then `disconnect_database`
    will be called during cleanup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both calls succeeded, then both `disconnect_database` and `disconnect_server`
    will be called during cleanup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When would we use `addCleanup` versus `tearDown`? In general, when accessing
    resources that must be closed, `addCleanup` is the way to go. `tearDown` is a
    good place to put other types of cleanup, or in cases where `setUp` cannot throw
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures and patching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one complication in using patched mocks along with fixtures. Take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the tests for the `EmailAction` class that we looked at earlier.
    The `patch` decorator is used at a class level to patch the `smtplib.SMTP` class
    and pass the mock as a parameter to all the test cases. Because of the way the
    patch decorator works, it only passes the mock to the test case methods, which
    means that we cannot access it in our `setUp` method.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at this test, it uses the `mock_smtp` object, which is derived from
    `mock_smtp_class`. The line that gets the `mock_smtp` object can be moved into
    the `setUp` method, if only we could access `mock_smtp_class` over there. Is there
    a way by which we can apply the patch in the `setUp` method so that we can do
    some common setup with the mock?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the `unittest` module gives us the tools to do just this. Instead
    of using the decorator syntax for patching, we will use the regular object syntax
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is passing the object to be patched—in this case `smtplib.SMTP`—to
    the `patch` function. This returns a patcher object with two methods: `start`
    and `stop`. When we call the `start` method, the patch is applied, and when we
    call the `stop` method, the patch is removed.'
  prefs: []
  type: TYPE_NORMAL
- en: We set the `patcher.stop` method to be executed during the test cleanup phase
    by passing it to the `addCleanup` function. We then start the patch. The `start`
    method returns the mock object, which we use for the rest of the setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this setup, we can use `self.mock_smtp` directly in our tests, without
    having to get it from `mock_smtp_class` in every test. The test would now look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Compare this test with the one earlier in this section. Since we are not using
    the decorator patch syntax, we no longer need the extra parameter. We also don't
    need to derive `mock_smtp` from `mock_smtp_class` in every test. Instead, all
    that work is done in `setUp`. The test can then access `self.mock_smtp` and use
    it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom test case class hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One more way of reducing code duplication is to create our own test class hierarchy.
    For example, if a helper method is used often in many test classes, then we can
    pull it up to a higher class and inherit test classes from that instead. The following
    is an example to make the concept clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a class called `MyTestCase` that inherits from `unittest.TestCase`,
    and we put in some helper methods in this class. The actual test classes inherit
    from `MyTestCase` and can access the helper methods that are in the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Using this technique, we can take common groups of helper methods and put them
    into reusable parent classes. The hierarchy need not be only one level deep; sometimes,
    we might create further subclasses for specific areas of the application that
    we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests closer to the domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other way to make tests easier to read is to write tests in terms of the
    domain language instead of just the generic functions provided by `unittest`.
    In this section, we look at some ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Writing helper methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first technique is to write helper methods. We employed this technique
    earlier in this book. The following are some tests that don''t use a helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'While the tests are short, it isn''t really clear what is happening in the
    tests. Let''s move some of that code into a helper method, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the same two tests using the new helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the tests are a lot clearer now. This is because the helper method
    clearly expresses the intent of the calculation, making it easy for a new developer
    to correlate the steps in the test case with their mental model of the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Writing better asserts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An easy way to enhance test readability is to write our own assert methods
    that are higher level than the generic asserts provided by `unittest`. For example,
    suppose we wanted to write a test to verify the price history of a stock. The
    following is how such a test might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, another way to write the test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have created our own base test class and with a
    custom assert method. The test case inherits from this base test class and uses
    the assert in the test.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the `assert_has_price_history` method gives an idea of
    how simple it is to write our own assert methods. All we have to do is to implement
    our assertion logic, and raise `self.failureException` whenever the assert should
    signal a test failure. `self.failureException` is an attribute of `unittest.TestCase`,
    and it is usually set to the `AssertionError` exception. We could raise `AssertionError`
    ourselves, but the `unittest` module allows us to configure using a different
    exception, so it is best to raise `self.failureException`, which is always set
    to the correct value to be used.
  prefs: []
  type: TYPE_NORMAL
- en: When the same sequence of asserts is made again and again in multiple tests,
    we should see whether there is an opportunity to replace the calls to the built-in
    asserts with a higher level assert that more clearly expresses the intent that
    we want to convey.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom equality checkers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cool feature of the `assertEqual` method is the way it gives custom failure
    messages depending on the type of object being compared. If we try to assert two
    integers, the following is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, asserting lists gives us another message showing the difference
    in the expected and actual lists, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, `assertEqual` delegates to a different function depending on
    the type of object being compared. This is how we get specific and relevant equality
    checks for most common built-in data structures such as strings, sequences, lists,
    tuples, sets, and dicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this flexible system is open to use by developers, which means
    we can add our own equality checkers for our application objects. The following
    is a default scenario where we try to compare two `Stock` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The assertion fails because although both objects contain the same data, they
    are still different objects in memory. Now let''s try to register our own equality
    function for the `Stock` class that just compares the symbol to identify equality
    between `Stock` objects. All we have to do is to register our checker using the
    `addTypeEqualityFunc` method like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The equality checker takes three parameters: the first object, the second object,
    and the optional message that the user passed to `assertEqual`. Once we register
    the function like this, we can call `assertEqual` passing in two `Stock` objects
    and `assertEqual` will delegate the comparison to the function that we registered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using equality functions this way is a nice way to assert application domain
    objects in the unit test code. This method has two limitations though:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to use the same comparison function for a given type. There is no way
    to use one comparison function in some tests and another comparison function in
    other tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both parameters to `assertEqual` have to be objects of that type. There is no
    way we can pass in two objects of differing types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these limitations can be overcome using matchers, which is what we will
    now turn our attention to.
  prefs: []
  type: TYPE_NORMAL
- en: Using matchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A third way to make asserts more readable is to create custom matcher objects
    to make comparisons more readable during assertions. We saw a glimpse of using
    matchers while writing tests for the `EmailAction` class earlier. The following
    is a look at that matcher again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A matcher can be any class that implements the `__eq__` method. The method will
    take the actual object as a parameter and the method can implement any comparison
    logic required. Using this method, we can directly compare domain objects in the
    assertion without cluttering it with a number of separate asserts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The matcher does not need to compare complete domain objects. We can compare
    only the attributes that we are interested in. In fact, we can create different
    matchers to match against specific subsets of objects. For example, we might create
    an `AlertMessageMatcher` like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This matcher will only match alert messages that have the given subject, while
    taking the other parameters from the expected object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you looked a little more in detail at the important but often
    overlooked topic of keeping tests maintainable. You looked at the importance of
    having a consistent test file layout scheme and the pros and cons of various alternatives.
    You looked at naming tests and grouping tests, before moving to the topic of making
    tests easier to understand. Some of the strategies that we discussed were using
    docstrings, creating custom test class hierarchies, and utilizing fixtures. Finally,
    you looked at making code more readable by using helper functions, custom asserts,
    equality functions, and writing custom matchers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will look at incorporating tests in your documentation
    using the `doctest` module.
  prefs: []
  type: TYPE_NORMAL
