- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Additional Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book has covered almost all the areas that need to be known for the creation
    of a web application using Flask. Much has been covered, and a lot more needs
    to be explored. In this final chapter, we will go through some additional recipes
    that can be used to add value to a Flask-based web application if and when needed.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to implement full-text search using Elasticsearch. Full-text
    search becomes important for a web application that offers a lot of content and
    options, such as an e-commerce site. Next, we will catch up on signals that help
    decouple applications by sending notifications (signals) when an action is performed
    somewhere in the application. This signal is caught by a subscriber/receiver that
    can perform an action accordingly. This is followed by implementing caching for
    our Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: We will also see how email support is added to our application and how emails
    can be sent directly from the application by performing different actions. We
    will then see how we can make our application asynchronous. By default, WSGI applications
    are synchronous and blocking – that is, by default, they do not serve multiple
    simultaneous requests together. We will see how to deal with this via a small
    example. We will also integrate Celery with our application and see how a task
    queue can be used to our application’s benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing full-text search with Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using caching with your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing email support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding asynchronous operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Celery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing full-text search with Elasticsearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Full-text search is an essential part of almost all use cases that are catered
    to via web applications. It becomes much more crucial if you intend to build an
    e-commerce platform or something similar where search plays a central role. Full-text
    search means an ability to search some text inside a large amount of textual data
    where the search results can contain full or partial matches as per configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elasticsearch** is a search server based on Lucene, which is an open source
    information-retrieval library. Elasticsearch provides a distributed full-text
    search engine with a RESTful web interface and schema-free JSON documents. In
    this recipe, we will implement full-text search using Elasticsearch for our Flask
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a Python library called `elasticsearch`, which makes dealing with
    Elasticsearch a lot easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to install the Elasticsearch server itself. This can be downloaded
    from [https://www.elastic.co/downloads/elasticsearch](https://www.elastic.co/downloads/elasticsearch).
    Unpack the package at any location of your choice on your machine and run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the Elasticsearch server on `http://localhost:9200/` by default.
    There are a couple of details that you need to make note of before moving ahead:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the `elasticsearch` server using the preceding command, you will
    see some details as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Elasticsearch security details](img/B19111_14_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Elasticsearch security details
  prefs: []
  type: TYPE_NORMAL
- en: Make note of the password for the elastic user here. You can also choose to
    reset the password using the command specified in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the `elasticsearch` server, it generates an HTTP CA certificate,
    which needs to be used while establishing a connection via our Flask application.
    You can find this certificate file in the `config/certs` folder of your `elasticsearch`
    server folder. In most cases, it should be `<path to your` `elasticsearch folder>/config/certs/http_ca.crt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to perform the integration between Elasticsearch and our
    Flask application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the `elasticsearch` object to the application’s configuration
    – that is, `my_app/__init__.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that several configuration settings are used in the preceding
    code. I have used them directly while instantiating an `es` object to make it
    easier for you to understand. In actual applications, these should come from configuration
    settings or configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have created an `es` object from the `Elasticsearch` class, which accepts
    the server URL, HTTP CA certificate, and basic authentication using the username
    and password. The HTTP CA certificate and password were sourced in the steps outlined
    in the *Getting ready* section of this recipe. `verify_certs=False` is required
    because my application is running on HTTP, while Elasticsearch runs on HTTPS.
    If your app also runs on HTTPS, then this flag would not be needed. `ignore=400`
    will ignore any errors related to `resource_already_exists_exception` that are
    raised, as this index has been created already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add a document to our Elasticsearch index. This can be done
    in views or models; however, in my opinion, the best way will be to add it in
    the model layer because it is more closely related to data rather than how it
    is displayed. We will do this in the `my_app/catalog/models.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, in each of the models, we added a new method called `add_index_to_es()`,
    which will add the document that corresponds to the current `Product` or `Category`
    object to the `catalog` index. You might want to index different types of data
    in separate indexes to make the search more accurate. Finally, we refreshed our
    index so that the newly created index is available for searching.
  prefs: []
  type: TYPE_NORMAL
- en: The `add_index_to_es()` method can be called when we create, update, or delete
    a product or category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, for demonstration, just add the statement to index a document (product)
    to the `elasticsearch` index while creating the product in `my_app/catalog/views.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we have also added a `product_search_es()` method to
    allow for searching on the Elasticsearch index we just created. Do the same in
    the `create_category()` method as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The search query we sent to Elasticsearch in the preceding code is pretty basic
    and open-ended. I would urge you to read about Elasticsearch query building and
    apply it to your program. Refer to the following: [https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s say we created a few categories and products in each of the categories.
    If we open `http://127.0.0.1:5000/product-search-es?q=phone`, we will get a response
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I encourage you to try and enhance the formatting and display of the output.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can learn more about connecting to the elasticsearch server at [https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html](https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More about the Python Elasticsearch client can be read at [https://elasticsearch-py.readthedocs.io/en/v8.6.2/index.html](https://elasticsearch-py.readthedocs.io/en/v8.6.2/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Signals** can be thought of as events that happen in our application. These
    events can be subscribed by certain receivers who then invoke a function whenever
    the event occurs. The occurrence of events is broadcasted by senders who can specify
    the arguments that can be used by the function, which will be triggered by the
    receiver.'
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: You should refrain from modifying any application data in the signals because
    signals aren’t executed in a specified order and can easily lead to data corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use a Python library called `blinker`, which provides the signals feature.
    Flask has built-in support for `blinker` and uses signaling itself to a good extent.
    There are certain core signals provided by Flask.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the application from the *Implementing full-text
    search with Elasticsearch* recipe and add the `product` and `category` documents
    to make indexes work via signals.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement and understand how signaling works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create signals for the `product` and `category` creation. This can be
    done in `my_app/catalog/models.py`. However, you can use any file you want since
    signals are created on a global scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have used `Namespace` to create signals, which will create them in a custom
    namespace rather than in the global namespace, thereby helping with the clean
    management of signals. We created two signals, `product-created` and `category-created`,
    where the intent of both is clear by their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will create subscribers to these signals and attach functions to them.
    For this, the `add_index_to_es()` methods have to be removed (if you are building
    over the code from the previous recipe), and new functions on the global scope
    have to be created in `my_app/catalog/models.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we created subscribers for the signals we created
    in *step 1* using `.connect()`. This method accepts the function that should be
    called when the event occurs; it also accepts the sender as an optional argument.
    The `app` object is provided as the sender because we don’t want our function
    to be called every time the event is triggered anywhere in any application. This
    specifically holds true in the case of extensions, which can be used by multiple
    applications. The function that gets called by the receiver (in this case, `add_product_index_to_es`
    and `add_category_index_to_es`) gets the sender as the first argument, which defaults
    to `None` if the sender is not provided. We provided the product/category as the
    second argument for which the record needs to be added to the `elasticsearch`
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, emit the signal that can be caught by the receiver. This needs to be done
    in `my_app/catalog/views.py`. For this, just remove the calls to the `add_index_to_es()`
    methods and replace them with the `.``send()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do the same in the `create_category()` method as well.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever a product is created, the `product_created` signal is emitted, with
    the `app` object as the sender and the `product` as the keyword argument. This
    is then caught in `models.py` and the `add_product_index_to_es()` function is
    called, which adds the document to the catalog index.
  prefs: []
  type: TYPE_NORMAL
- en: The functionality of this recipe is exactly the same as the last recipe, *Implementing
    full-text search* *with Elasticsearch*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read the *Implementing full-text search with Elasticsearch* recipe for a background
    on this recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read about the `blinker` library at [https://pypi.python.org/pypi/blinker](https://pypi.python.org/pypi/blinker)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can view the list of core signals that are supported by Flask at [https://flask.palletsprojects.com/en/2.2.x/api/#core-signals-list](https://flask.palletsprojects.com/en/2.2.x/api/#core-signals-list)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can view the signals that are provided by Flask-SQLAlchemy for tracking
    modifications to models at [https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/api/#module-flask_sqlalchemy.track_modifications](https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/api/#module-flask_sqlalchemy.track_modifications)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using caching with your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Caching** becomes an important and integral part of any web application when
    scaling or increasing the response time of your application becomes a question.
    Caching is the first thing that is implemented in these cases. Flask, by itself,
    does not provide any caching support by default, but **Werkzeug** does. Werkzeug
    has some basic support to cache with multiple backends, such as Memcached and
    Redis. This caching support of Werkzeug is implemented by a package called **Flask-Caching**,
    which we will use in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will install a Flask extension called `flask-caching`, which simplifies
    the process of caching a lot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We will use our catalog application for this purpose and implement caching for
    some methods.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing basic caching is pretty easy. Go through the following steps to
    do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, initialize `Cache` to work with our application. This is done in the
    application’s configuration – that is, `my_app/__init__.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we used `simple` as the `Cache` type, where the cache is stored in the
    memory. This is not advised for production environments. For production, we should
    use something such as Redis, Memcached, filesystem cache, and so on. Flask-Caching
    supports all of them with a couple more backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add caching to the methods that need to be cached. Just add a `@cache.cached(timeout=<time
    in seconds>)` decorator to the view methods. A simple target can be the list of
    categories (we will do this in `my_app/catalog/views.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This way of caching stores the value of the output of this method in the cache
    in the form of a key-value pair, with the key as the request path.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After adding the preceding code, to check whether the cache works as expected,
    fetch the list of categories by pointing the browser to `http://127.0.0.1:5000/categories`.
    This will save a key-value pair for this URL in the cache. Now, create a new category
    quickly and navigate to the same category list page. You will notice that the
    newly added category is not listed. Wait for a couple of minutes and then reload
    the page. The newly added category will be shown now. This is because the first
    time the category list was cached, it expired after 2 minutes (120 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: This might seem to be a fault with the application but, in the case of large
    applications, this becomes a boon where the hits to the database are reduced,
    and the overall application experience improves. Caching is usually implemented
    for those handlers whose results don’t get updated frequently.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of us might think that such caching will fail in the case of a single
    category or product page, where each record has a separate page. The solution
    to this is **memoization**. It is similar to caching, with the difference being
    that it stores the result of a method in the cache, along with the information
    on the parameters that were passed. So, when a method is created with the same
    parameters multiple times, the result is loaded from the cache rather than making
    a database hit. Implementing memoization is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we open a URL (say, `http://127.0.0.1:5000/product/1`) in our browser
    for the first time, it will be loaded after making calls to the database. However,
    if we make the same call again, the page will be loaded from the cache. On the
    other hand, if we open another product (say, `http://127.0.0.1:5000/product/2`),
    then it will be loaded after fetching the product details from the database when
    accessed for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask-Caching at [https://flask-caching.readthedocs.io/en/latest/](https://flask-caching.readthedocs.io/en/latest/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization at [http://en.wikipedia.org/wiki/Memoization](http://en.wikipedia.org/wiki/Memoization)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing email support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to send emails is usually one of the most basic functions of any
    web application. It is usually easy to implement with any application. With Python-based
    applications, it is quite simple to implement with the help of `smtplib`. In the
    case of Flask, this is further simplified by an extension called `Flask-Mail`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Flask-Mail` can be easily installed via `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at a simple case where an email will be sent to a catalog manager
    in the application whenever a new category is added.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, instantiate the `Mail` object in our application’s configuration – that
    is, `my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We also need to do some configuration to set up the email server and sender
    account. The preceding code is a sample configuration for Gmail accounts (without
    two-factor authentication enabled). Any SMTP server can be set up like this. There
    are several other options provided; they can be found in the `Flask-Mail` documentation
    at [https://pythonhosted.org/Flask-Mail](https://pythonhosted.org/Flask-Mail).
  prefs: []
  type: TYPE_NORMAL
- en: 'To send an email on category creation, we need to make the following changes
    in `my_app/catalog/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here, a new email will be sent to the list of recipients from the default sender
    configuration that we did. You will notice that the category creation takes one
    or two seconds to execute. That is the time taken to send the email.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new category by simply making a post request to `http://127.0.0.1:5000/category-create`.
    You can do it using the `requests` library from the `Python` prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: You should receive an email on the recipient email ID(s) provided.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s assume that we need to send a large email with a lot of HTML content.
    Writing all of this in our Python file will make the overall code ugly and unmanageable.
    A simple solution to this is to create templates and render their content while
    sending emails. Here, I created two templates: one for the HTML content and one
    simply for text content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `category-create-email-text.html` template will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `category-create-email-html.html` template will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we need to modify the email message creation procedure that we
    created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, *Understanding asynchronous operations*, will show us how we
    can delegate the time-consuming email-sending process to an asynchronous thread
    and speed up our application experience.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding asynchronous operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the operations in a web application can be time-consuming and make the
    overall application feel slow for the user, even though it’s not actually slow.
    This hampers the user experience significantly. To deal with this, the simplest
    way to implement the asynchronous execution of operations is with the help of
    threads. In this recipe, we will implement this using the `threading` libraries
    of Python. In Python 3, the `thread` package has been deprecated. Although it
    is still available as `_thread`, it is highly recommended to use `threading`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the application from the *Implementing email support for Flask applications*
    recipe. Many of us will have noticed that, while the email is being sent, the
    application waits for the whole process to finish, which is unnecessary. Email
    sending can be easily done in the background, and our application can become available
    to the user instantaneously.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Doing an asynchronous execution with the `threading` package is very simple.
    Just add the following code to `my_app/catalog/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the sending of an email happens in a new thread, which sends
    the message as a parameter to the newly created method. We need to create a new
    `send_mail()` method because our email templates contain `url_for`, which can
    only be executed inside an application context; this won’t be available in the
    newly created thread by default. It provides the flexibility of starting the thread
    whenever it’s needed instead of creating and starting the thread at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is pretty simple to observe how this works. Compare the performance of sending
    an email in this recipe with that of the application in the previous recipe, *Implementing
    email support for Flask applications*. You will notice that the application is
    more responsive. Another way can be to monitor the debug logs, where the newly
    created category page will load before the email is sent.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since I have mentioned multithreading and asynchronous operations, many of you
    must be thinking about Python’s built-in `asyncio` library and its potential here.
    Although it is possible to write Flask methods using `async..await` and they would
    work in a non-blocking fashion, there are no obvious performance gains as WSGI
    would still need to run in a single worker to handle a request. See [https://flask.palletsprojects.com/en/2.2.x/async-await/](https://flask.palletsprojects.com/en/2.2.x/async-await/)
    for more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can look at `asyncio` implementation of Flask or `asyncio` with a very similar
    syntax to Flask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Celery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Celery is a task queue for Python. There used to be an extension to integrate
    Flask and Celery but, with Celery 3.0, it became obsolete. Now, Celery can be
    directly used with Flask by just using a bit of configuration. In the *Understanding
    asynchronous operations* recipe, we implemented asynchronous processing to send
    an email. In this recipe, we will implement the same using Celery.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Celery can be installed simply from PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: To make Celery work with Flask, we will need to modify our Flask app config
    file a bit. In order to do its job, Celery needs a broker to receive and deliver
    tasks. Here, we will use Redis as the broker (thanks to its simplicity).
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you run the Redis server for the connection to happen. To install
    and run a Redis server, refer to [https://redis.io/docs/getting-started/](https://redis.io/docs/getting-started/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You would also need to install the Redis client in your virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ pip` `install Redis`'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the application from the previous recipe and implement Celery in
    the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to understand Celery’s integration with the Flask application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to do a bit of configuration in the application’s configuration
    – that is, `my_app/__init__.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding snippet comes directly from the Flask website and can be used
    as is in your application in most cases. Here, we are essentially configuring
    a task in Celery to have the application context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the Celery process, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `-app` points to the `celery` object that is created in the configuration
    file, and `-l` is the log level that we want to observe.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that Redis is also running on the broker URL, as specified in the
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use this `celery` object in the `my_app/catalog/views.py` file to send
    emails asynchronously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add the `@celery.task` decorator to any method that we wish to use as a Celery
    task. The Celery process will detect these methods automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, when we create a category and an email is sent, we can see a task being
    run on the Celery process logs, which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read the *Understanding asynchronous operations* recipe to see how threads can
    be used for various purposes – in our case, to send emails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about Celery at [http://docs.celeryproject.org/en/latest/index.html](http://docs.celeryproject.org/en/latest/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
