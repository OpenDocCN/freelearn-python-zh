- en: Chapter 5. Working with Legacy Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a solid set of unit tests is critical for a successful project. As you
    have seen so far, not only do unit tests help prevent bugs from getting into the
    code, but they also help in many other ways such as guiding the design, enabling
    us to refactor the code and keep it more maintainable, as well as a reference
    where you can see what the expected behavior is supposed to be.
  prefs: []
  type: TYPE_NORMAL
- en: TDD is the best way to ensure that our code has all the properties mentioned
    in the preceding paragraph. But, as anyone who has worked on larger, more complex
    projects knows, there are always pieces of code that don't have tests. Usually,
    this is the code written many years ago, long before we started practicing TDD.
    Or, it might have been the code that was written in a hurry to meet an urgent
    deadline.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, this is the code that does not have associated tests. The code is
    often messy. It has a ton of dependencies on other classes. And now, we need to
    add a new feature to this code. How do we approach this? Should we just go in
    there and hack in our new feature? Or is there a better way?
  prefs: []
  type: TYPE_NORMAL
- en: What is legacy code?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will use the term **legacy code** to mean any code that
    does not have unit tests. This is a rather broad definition, since it includes
    the code that was written long ago as well as recent code, which, for some reason,
    was written without tests. Although not strictly about the old code, this is a
    popular definition in the TDD community, made mainstream by Michael Feathers'
    excellent book *Working Effectively with Legacy Code* (Prentice Hall, 2004), and
    this is the meaning we will adopt in this book as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five steps to working with the legacy code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the code**: If we are lucky, we will have some great documentation
    that will help us understand the code that we are going to touch. More likely,
    documentation will be scant or not present altogether. Since there are no tests,
    we cannot read the tests to try to understand what the code is supposed to do.
    And for really old code, chances are that the person who wrote the code does not
    work for your organization anymore. It sounds like the perfect storm to mess with
    us, but as anyone who has worked on large production projects can attest, this
    is the norm for the majority of the codebase. So, our first step is to just understand
    the code and figure out what is going on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Breaking dependencies**: Once we start to understand the code, our next step
    would be to write some tests for the code. This is not straightforward for the
    legacy code because the design is often a spaghetti mess of dependencies with
    other files and classes. We need some way to break these dependencies before we
    can write unit tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing tests**: We are now finally in a position to write some unit tests
    for the code we are about to modify.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Refactoring**: Now that we have tests, we can start applying some of the
    refactoring techniques that we saw earlier in this book.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing the new feature**: Having cleaned up the code, we can now implement
    the new feature, with tests, of course.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although the preceding steps are shown as a linear sequence, it is important
    to understand that the steps often take place in a non-linear way. For example,
    while trying to understand a large method, we might take a small piece of code,
    extract it to a method, look at it in greater detail, and then write a couple
    of tests for it, finally going back to the original method and looking at another
    piece of the method. We might then come back to our extracted methods and extract
    them into a new class. The steps go back and forth until we are in a position
    to safely implement the new feature without the risk of breaking stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the code that we are going to be looking at in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a piece of code that does something. All we know is that it takes some
    updates from a file and runs it through some alerts. The following is what the
    `updates.csv` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to add a few features to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to be able to get updates from a network server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be able to send an e-mail when an alert is matched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we can get started, we need to be able to understand the current code.
    We do this by characterization tests.
  prefs: []
  type: TYPE_NORMAL
- en: What are characterization tests?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Characterization tests** are tests that describe the current behavior of
    the code. We aren''t writing the tests against a predefined expectation. Instead,
    we write the tests against the actual behavior. You may ask what this accomplishes
    since the test can''t fail if we are going to look at the current behavior and
    write a test that looks for the same thing. However, the thing to remember is
    that we aren''t trying to find bugs. Instead, by writing tests against the current
    behavior, we are building up a safety net of tests. If we break something during
    the process of refactoring, the test will fail and we will know that we have to
    undo our changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Python interactive shell to understand the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So what does this piece of code do? Let''s open up the Python interactive shell
    and take a look. The interactive shell is a great help because it allows us to
    play around with the code, trying different input values and seeing what kind
    of output we get. Let''s open the class now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, just instantiating the class has caused the code to run and we
    have some output printed on the terminal. This is not surprising given that all
    the code is within the `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a characterization test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okay, we now have something to write a test for. We understand that when the
    input in the `updates.csv` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the output when we instantiate the class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We may not yet know why this is the output or how it was calculated, but this
    is enough to get started with a test. The following is what the test looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All this test does is to mock out the `print` function and then instantiate
    the class. We assert that the required data is printed out.
  prefs: []
  type: TYPE_NORMAL
- en: Is this a great unit test? Probably not. For one, it still takes the input from
    the `updates.csv` file. Ideally, we would have mocked out the file access. But
    it doesn't matter at the moment. This test passes and it will be a safety net
    when we start modifying the code. That is all we need the test to do for now.
  prefs: []
  type: TYPE_NORMAL
- en: Using pdb to understand the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python interactive shell is a great way to understand the code at the boundaries
    of method calls. It allows us to pass in various combinations of input and see
    what kind of output we get. But what if we want to see what is going on within
    a function or method? This is where `pdb` can be extremely useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**pdb** is a Python Debugger, and it supplies as a part of the Python standard
    library. It has a number of features such as being able to step through the execution
    line by line, see how variables change, and set and remove breakpoints. pdb is
    very powerful, and there are a number of good books that cover it in detail. We
    won''t go through all the features in this book, but just give a short example
    of how it can be used to understand the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the code from within `pdb`, run the following lines in the interactive
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `pdb.run` method allows us to specify any string as a parameter. That string
    is executed within the debugger. In this case, we are instantiating the class
    that starts executing all the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we get the `(Pdb)` prompt from where we can walk through the
    execution, line by line. You can get help on the various commands available by
    typing `help`, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can also get help by typing `help <command>` for help on a specific
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Some common pdb commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time, we will use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s`: This executes one line of code (going inside a function call if required)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n`: This executes code until you reach the next line in the current function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`: This executes code until the current function returns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`q`: This quits the debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: This sets a breakpoint on a particular line of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cl`: This clears breakpoints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: This continues execution until a breakpoint is encountered or until the
    end of execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These commands should be enough to move around code and try to inspect what
    is going on. pdb has a ton of other commands that we won't cover here.
  prefs: []
  type: TYPE_NORMAL
- en: Walking through a pdb session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now put this into practice. The following is a walk-through of our code
    using `pdb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we run our command within `pdb` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s step into the first line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'pdb tells us that we are now within the `__init__` method. The `n` command
    will take us through the first few lines of this method, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can examine the initialization that seems to have been done by looking at
    some of the variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even try executing some of the local variables with various input as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This helps us understand the state of various objects during different parts
    of execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section of code is the part where we open the file and read it. Let''s
    skip ahead of this by putting a breakpoint on line 25 and executing right to it
    with the `c` command, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the file reading part is done, we can inspect the format of data that
    was read by examining the updates local variable. The `pp` command does a pretty
    print so that the output is easier to read, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like the file got parsed into a list of tuples, each containing `(stock
    symbol, timestamp, price)`. Let''s see what would happen if we had only the GOOG
    updates, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There we go. As we can see, it is even possible to change the values held by
    local variables midway during execution. The following is the output when we run
    the remainder of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `cl` command clears the breakpoint, and we use the `c` command to run to
    the end of the execution. The output with the modified the updates variable gets
    printed. Since the execution is complete at this point, we are returned back to
    the interactive shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our exploration is done for now. At any point, we could have quit the debugger
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Quitting the debugger takes us back to the interactive shell. At this point,
    we might add a few more characterization tests based on the exploration that we
    just did.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques to break dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve seen some techniques to help us understand the code, our next
    step is to break dependencies. This will help us write further characterization
    tests. To do this, we will *very carefully* start modifying the code. All the
    while, we will try to stick to the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Make small changes that are very unlikely to break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to change the public interface as little as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why these goals? Because we have a lack of tests, we have to be careful with
    the changes we make. Hence, small changes are better. We also need to be careful
    of changing the public interface because we have to go and fix all the other files
    and modules that use this class.
  prefs: []
  type: TYPE_NORMAL
- en: The Rope refactoring library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Rope refactoring library** is a library to perform automated refactoring
    of your code. For example, you could select a few lines and then type the command
    to extract it into a method. The library will automatically create this method
    with the appropriate code, parameters, and return value, and will automatically
    place a call to the newly extracted method in place of the original code. Automated
    refactoring in Python is a little tricky because the dynamic nature of the language
    makes it difficult to identify all the changes correctly. However, it is ideal
    for making small changes, like we are going to do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Since it is a library, Rope doesn't have any UI for performing the refactorings.
    Instead, it is integrated into the development environment, as either an IDE or
    a text editor. Most popular IDEs and text editors have support for integrating
    with Rope. Rope is available at [https://github.com/python-rope/rope](https://github.com/python-rope/rope).
  prefs: []
  type: TYPE_NORMAL
- en: If your IDE or text editor of choice supports integration with Rope, or has
    built-in refactoring capabilities, then use it as far as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Separate initialization from execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the problems that the class we are working with has is that the whole
    execution happens in the `__init__` method. This means that as soon as the class
    is constructed, everything is executed before we have a change to set up mocks
    or make other changes that will help us write characterization tests. Luckily,
    there is a simple solution to this. We will simply move the execution part into
    a separate method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The astute reader would have observed that we have just broken our second goal—to
    minimize changes to the public interface. The change that we've made has changed
    the interface. If there are other modules using this class, they would have only
    constructed the class, assuming all the processing is complete. We have to now
    go and find all the places where we are creating this class and add a call to
    the `run` method. Otherwise, the class will not work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent having to fix all the callers, we can call the run method ourselves
    from within the initializer like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All the tests pass again, but once again, all the codes get executed the moment
    we instantiate the class. Are we back to square one? Let's see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Use default values for parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most useful features of Python is the concept of being able to set
    a default value for a parameter. This allows us to change the interface, while
    making it look just the same for existing callers.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we moved a piece of code into the run method, and we
    called this method from the `__init__` method. It seems like we haven't really
    changed anything, but that is misleading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the next change to the `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is to introduce a new parameter called `autorun` and set the
    default value as `True`. We then wrap the call to the `run` method with a conditional.
    Only if `autorun` is `True` will the `run` method be called.
  prefs: []
  type: TYPE_NORMAL
- en: All the existing callers who use this class will be unchanged—when the constructor
    is called without parameters, the `autorun` parameter will be set to `True` and
    the `run` method will be called. Everything will be as expected.
  prefs: []
  type: TYPE_NORMAL
- en: But adding the parameter gives us the option to explicitly set the `autorun`
    parameter to `False` in our tests, and thus avoid the `run` method from being
    called. We can now instantiate the class, then set up any mocks or other test
    initialization that we want, and then proceed to manually call the `run` method
    in the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the same characterization test that we wrote earlier, rewritten
    to take advantage of this new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Bingo! That one change seems small now, but it is the change that enables us
    to write all the characterization tests that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Extract the method and test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very difficult to test methods that are large. This is because tests can
    only check inputs, outputs, and interactions. It becomes a problem if there are
    just a couple of lines within the whole method that we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `run` method again, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we want to just write characterization tests for the code in the second
    loop. How can do that? A simple way is to extract those lines into a separate
    method, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to call the new method in the original place, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now write characterization tests for this new method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Ideally, we try to extract small groups of code so that the Extract Method refactoring
    is easy to perform without mistakes. Remember, we don't have the safety net of
    existing unit test here.
  prefs: []
  type: TYPE_NORMAL
- en: Inject dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous characterization test, we instantiated the class and then proceeded
    to replace the exchange instance variable with another one in which the Stock
    class was mocked out. Another way of achieving this aim is to use the earlier
    trick of introducing default variables like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to inject in a mock when writing the characterization test,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inherit and test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to achieve this goal is by writing a class that inherits from `AlertProcessor`,
    but includes parameters for the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could create a class like the following in the test file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This class inherits from `AlertProcessor` and takes in the parameters that we
    want to mock out in our characterization tests. The `__init__` method calls the
    original class initializer and then overrides the `exchange` parameter with the
    value passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the unit test, we can instantiate the test class instead of the real one.
    We pass in an exchange that contains mock stock objects. The mocks get set, and
    we can test that the right calls were made, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of this method compared to injecting dependencies via default
    parameters is that it does not require changing any code in the original class.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing local methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time, we use mocks to double for other classes or functions apart
    from the class being tested. For example, we mocked out the `Stock` objects in
    the example from the previous section, and we mocked out the `print` built-in
    function earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, Python does not stop us from mocking out methods of the same class
    that we are testing. This is a powerful way of testing complex classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to test the code in the `run` method that parses the
    file, without executing the part that updates the stock values. The following
    is a test that does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the test above, we stub out the `do_updates` method of the class before executing
    the `run` method. When we execute `run`, it parses the file, then instead of running
    the `do_updates` local method, it executes our mocked out method instead. Since
    the real method is stubbed out, the code does not update the `Stock` or print
    anything to the screen. All that functionality has been stubbed out. We then test
    whether the parsing was correct by checking whether the right parameters were
    passed to the `do_updates` method.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing out a local method is a good way to understand a more complex class
    because it allows us to write characterization tests for small parts of the class
    in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Extract the method and stub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, a method is quite long and we want to stub out a part of the method.
    We can combine the above techniques by extracting the part we want to stub out
    into a local method, and then stub out the method in the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what our `run` method currently looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let's say that we want the tests to skip the part of the method where the file
    is read and parsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first extract the lines into a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we replace the lines in the `run` method with a call to the newly extracted
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the characterization test mocks out the newly extracted method, gives
    it a return value, and calls the `run` method, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With the file parsing lines extracted into a separate method, we can easily
    write a number of different characterization tests for different combinations
    of inputs. For example, the following is another characterization test that checks
    nothing is printed to screen for a different input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can also use this technique to test hard to access code such as `lambda`
    functions. We extract the `lambda` function into a separate function, which enables
    us to write characterization tests for it separately or mock it when writing tests
    for other parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do the following for our code. First, extract the `lambda` function to
    a local method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, replace the `print` lines with a call to the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how we have made the call. We still use a lambda function, but delegate
    to the local method with the appropriate parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now mock out this method when writing the characterization tests for
    the `do_updates` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The cycle continues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the techniques mentioned in the last section help us isolate pieces of code
    and break dependencies with other classes. This allows us to introduce stubs and
    mocks, making it easier to write more detailed characterization tests. The Extract
    Method refactoring is used a lot and is a great technique to isolate small sections
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: The whole process is iterative. In a typical session, we might look at a piece
    of code via `pdb`, and then decide to extract it to a method. We might then experiment
    with passing different inputs to the extracted method in the interactive shell,
    following which we might write a few characterization tests. We would then go
    back to another section of the class and write more tests after mocking or stubbing
    the new method, following which we might go back into `pdb` or the interactive
    shell to take a look at another piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the process, we keep making small changes that are unlikely to break
    and keep running all our existing characterization tests to test that we haven't
    broken anything.
  prefs: []
  type: TYPE_NORMAL
- en: Time to refactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a while, we might end up with a pretty good suite of characterization
    tests for the legacy code. We can now approach this code like any other well-tested
    code and start applying the bigger refactorings with an aim to improve the design
    before adding our new features.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might decide to extract the `print_action` method into a separate
    `Action` class, or the `parse_file` method into a `Reader` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a `FileReader` class where we have moved the contents from
    the `parse_file` local method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the Inject Dependencies pattern to pass the `reader` as a parameter
    to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And change the run method to call the reader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we are setting a default value so that other classes that use this
    class do not need to be changed. This allows us to override the `reader` parameter
    in tests as well as in new code, while the existing code will work fine without
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now write a test for this by passing in a mock object to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can do the same by extracting the `print_action` method into an `Action`
    class and passing it in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Remember our original goals?
  prefs: []
  type: TYPE_NORMAL
- en: 'Right at the start of this chapter, we had said that we wanted to implement
    the following two features:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to be able to get updates from a network server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be able to send an e-mail when an alert is matched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original design didn't make it easy to add this functionality, and we would
    have needed to hack around the code—a dangerous and bug prone proposition.
  prefs: []
  type: TYPE_NORMAL
- en: Our newly refactored design now makes adding these features easy. All we need
    to do is to create new classes, say something like `NetworkReader`, which reads
    input from a server. We pass an instance of this object to the initializer via
    the reader parameter. `AlertProcessor` will then get updates from the server.
  prefs: []
  type: TYPE_NORMAL
- en: We can do the same with by implementing an `EmailAction` class and passing that
    object into this class.
  prefs: []
  type: TYPE_NORMAL
- en: Long-term refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've managed to safely add the new features to our legacy code. But our work
    doesn't stop here. There are places where we added default parameters to the `__init__`
    method so that we didn't break existing code that used this class. Over time,
    we would want to go to each of these places and change them to use the new interface.
    Once we have changed all the places, we can then remove the default parameters
    from the interface and the whole codebase would have migrated to the new interface.
  prefs: []
  type: TYPE_NORMAL
- en: The cool thing about this is that we don't have to do all the changes in one
    go. The codebase never stays broken for any length of time. We can make these
    changes over time, one by one, and the application is always working correctly
    at every point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other thing we need to do is to go back to our characterization tests and
    clean them up. Remember the first characterization test we wrote? It is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of this chapter, we mentioned that this is not a great unit
    test, but it is good enough as a characterization test. Well, now is the time
    to revisit this test and make it better. Having refactored the design, we can
    now pass in a mock object for the reader. The test will no longer depend on the
    existence of the `updates.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: There were also a number of tests where we had patched out the print function.
    Once we refactor the design to take an `Action` class as an input, we would no
    longer need to patch this function as we can just pass in a mock action object
    to the initializer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how to handle the hairy problem of working with the
    legacy code. We defined the legacy code as any code that does not contain tests.
    It is an unfortunate fact of life that we have to deal with such code. Fortunately
    there are a number of techniques available that allow us to safely work with such
    code. The interactive shell as well as the extremely powerful debugger are a huge
    help in understanding typical spaghetti code.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic nature of Python also makes it easy to break dependencies. We can
    use default value parameters to maintain compatibility with existing code while
    refactoring to a better design. Powerful patching features as well as the ability
    to dynamically alter existing instance variables and local methods allow us to
    write characterization tests that would normally have been much more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen many ways to write tests, let's look at ways to keep
    everything maintainable. We will do this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
