- en: Chapter 5. Working with Legacy Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 工作于遗留代码
- en: Having a solid set of unit tests is critical for a successful project. As you
    have seen so far, not only do unit tests help prevent bugs from getting into the
    code, but they also help in many other ways such as guiding the design, enabling
    us to refactor the code and keep it more maintainable, as well as a reference
    where you can see what the expected behavior is supposed to be.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一套稳固的单元测试对于成功的项目至关重要。如您所见，单元测试不仅有助于防止错误进入代码，而且在许多其他方面也有帮助，如指导设计、使我们能够重构代码并保持其可维护性，以及作为参考，让您可以看到预期的行为应该是怎样的。
- en: TDD is the best way to ensure that our code has all the properties mentioned
    in the preceding paragraph. But, as anyone who has worked on larger, more complex
    projects knows, there are always pieces of code that don't have tests. Usually,
    this is the code written many years ago, long before we started practicing TDD.
    Or, it might have been the code that was written in a hurry to meet an urgent
    deadline.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）是确保我们的代码具有前一段所述所有特性的最佳方式。但是，任何参与过更大、更复杂项目的人都知道，总有一些代码片段没有经过测试。通常，这些是多年前编写的代码，在我们开始实践TDD之前就已经存在了。或者，它可能是为了赶在紧急截止日期前匆忙编写的代码。
- en: Either way, this is the code that does not have associated tests. The code is
    often messy. It has a ton of dependencies on other classes. And now, we need to
    add a new feature to this code. How do we approach this? Should we just go in
    there and hack in our new feature? Or is there a better way?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，这都是没有关联测试的代码。代码通常很混乱。它对其他类有大量的依赖。现在，我们需要向这段代码添加一个新功能。我们该如何着手？我们只是直接进去修改新功能吗？还是有一种更好的方法？
- en: What is legacy code?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是遗留代码？
- en: In this chapter, we will use the term **legacy code** to mean any code that
    does not have unit tests. This is a rather broad definition, since it includes
    the code that was written long ago as well as recent code, which, for some reason,
    was written without tests. Although not strictly about the old code, this is a
    popular definition in the TDD community, made mainstream by Michael Feathers'
    excellent book *Working Effectively with Legacy Code* (Prentice Hall, 2004), and
    this is the meaning we will adopt in this book as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用术语**遗留代码**来指代任何没有单元测试的代码。这是一个相当宽泛的定义，因为它包括很久以前编写的代码以及某些原因下没有编写测试的最近代码。虽然这并不是严格意义上的旧代码，但在TDD社区中，这是一个流行的定义，由迈克尔·费瑟斯的优秀著作《与遗留代码有效工作》（Prentice
    Hall，2004）使之流行起来，我们也将在这个书中采用这个含义。
- en: 'There are five steps to working with the legacy code:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与遗留代码工作的五个步骤：
- en: '**Understanding the code**: If we are lucky, we will have some great documentation
    that will help us understand the code that we are going to touch. More likely,
    documentation will be scant or not present altogether. Since there are no tests,
    we cannot read the tests to try to understand what the code is supposed to do.
    And for really old code, chances are that the person who wrote the code does not
    work for your organization anymore. It sounds like the perfect storm to mess with
    us, but as anyone who has worked on large production projects can attest, this
    is the norm for the majority of the codebase. So, our first step is to just understand
    the code and figure out what is going on.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**理解代码**：如果我们很幸运，我们会有一些优秀的文档来帮助我们理解即将接触的代码。更有可能的是，文档会很少，或者根本不存在。由于没有测试，我们无法阅读测试来尝试理解代码应该做什么。而对于非常旧的代码，编写代码的人可能已经不再为您的组织工作了。这听起来就像是一场完美的风暴，会给我们带来麻烦，但正如任何参与过大型生产项目的人都可以证明的那样，这是大多数代码库的常态。因此，我们的第一步就是理解代码，弄清楚发生了什么。'
- en: '**Breaking dependencies**: Once we start to understand the code, our next step
    would be to write some tests for the code. This is not straightforward for the
    legacy code because the design is often a spaghetti mess of dependencies with
    other files and classes. We need some way to break these dependencies before we
    can write unit tests.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**打破依赖关系**：一旦我们开始理解代码，我们的下一步就是为代码编写一些测试。对于遗留代码来说，这并不简单，因为设计通常是与其他文件和类相互依赖的意大利面式的混乱。在我们编写单元测试之前，我们需要某种方法来打破这些依赖关系。'
- en: '**Writing tests**: We are now finally in a position to write some unit tests
    for the code we are about to modify.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写测试**：我们现在终于可以为我们即将修改的代码编写一些单元测试了。'
- en: '**Refactoring**: Now that we have tests, we can start applying some of the
    refactoring techniques that we saw earlier in this book.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构**：现在我们已经有了测试，我们可以开始应用我们在本书前面看到的一些重构技术。'
- en: '**Implementing the new feature**: Having cleaned up the code, we can now implement
    the new feature, with tests, of course.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现新功能**：在清理代码后，我们现在可以实施新功能，当然，包括测试。'
- en: Although the preceding steps are shown as a linear sequence, it is important
    to understand that the steps often take place in a non-linear way. For example,
    while trying to understand a large method, we might take a small piece of code,
    extract it to a method, look at it in greater detail, and then write a couple
    of tests for it, finally going back to the original method and looking at another
    piece of the method. We might then come back to our extracted methods and extract
    them into a new class. The steps go back and forth until we are in a position
    to safely implement the new feature without the risk of breaking stuff.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的步骤被显示为线性序列，但重要的是要理解，步骤往往以非线性的方式进行。例如，当我们试图理解一个大方法时，我们可能会取一小段代码，将其提取为方法，更详细地查看它，然后为它编写几个测试，最后回到原始方法并查看方法的另一部分。然后我们可能回到我们提取的方法并将它们提取到一个新类中。步骤来回进行，直到我们处于一个可以安全实施新功能且没有破坏东西的风险的位置。
- en: Understanding the code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码
- en: 'The following is the code that we are going to be looking at in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中查看的代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a piece of code that does something. All we know is that it takes some
    updates from a file and runs it through some alerts. The following is what the
    `updates.csv` file looks like:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段执行某些操作的代码。我们所知道的是，它从文件中获取一些更新并通过一些警报运行它。以下是如何看起来`updates.csv`文件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We now need to add a few features to this code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要向这段代码添加一些功能：
- en: We need to be able to get updates from a network server
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够从网络服务器获取更新
- en: We need to be able to send an e-mail when an alert is matched
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够在匹配到警报时发送电子邮件
- en: Before we can get started, we need to be able to understand the current code.
    We do this by characterization tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要能够理解当前的代码。我们通过特征测试来实现这一点。
- en: What are characterization tests?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是特征测试？
- en: '**Characterization tests** are tests that describe the current behavior of
    the code. We aren''t writing the tests against a predefined expectation. Instead,
    we write the tests against the actual behavior. You may ask what this accomplishes
    since the test can''t fail if we are going to look at the current behavior and
    write a test that looks for the same thing. However, the thing to remember is
    that we aren''t trying to find bugs. Instead, by writing tests against the current
    behavior, we are building up a safety net of tests. If we break something during
    the process of refactoring, the test will fail and we will know that we have to
    undo our changes.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**特征测试**是描述代码当前行为的测试。我们不是针对预定义的期望来编写测试，而是针对实际行为来编写测试。你可能会问这能完成什么，因为如果我们打算查看当前行为并编写一个寻找相同内容的测试，测试是不可能失败的。然而，需要记住的是，我们并不是试图找到错误。相反，通过针对当前行为编写测试，我们正在构建一个测试的安全网。如果我们重构过程中破坏了某些东西，测试将失败，我们将知道我们必须撤销我们的更改。'
- en: Using the Python interactive shell to understand the code
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python交互式外壳来理解代码
- en: 'So what does this piece of code do? Let''s open up the Python interactive shell
    and take a look. The interactive shell is a great help because it allows us to
    play around with the code, trying different input values and seeing what kind
    of output we get. Let''s open the class now as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这段代码做什么呢？让我们打开Python交互式外壳并看看。交互式外壳是一个很好的帮助工具，因为它允许我们与代码互动，尝试不同的输入值并查看我们得到什么样的输出。现在让我们按照以下方式打开类：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, just instantiating the class has caused the code to run and we
    have some output printed on the terminal. This is not surprising given that all
    the code is within the `__init__` method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，仅仅实例化类就使代码运行，我们在终端上打印了一些输出。考虑到所有代码都在`__init__`方法中，这并不令人惊讶。
- en: Writing a characterization test
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写特征测试
- en: 'Okay, we now have something to write a test for. We understand that when the
    input in the `updates.csv` file is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有了一些可以编写测试的内容。我们理解，当`updates.csv`文件中的输入如下时：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, the output when we instantiate the class is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们实例化类时的输出如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We may not yet know why this is the output or how it was calculated, but this
    is enough to get started with a test. The following is what the test looks like:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还不知道为什么这是输出或它是如何计算的，但这足以开始测试。以下就是测试的样子：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All this test does is to mock out the `print` function and then instantiate
    the class. We assert that the required data is printed out.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些测试所做的只是模拟`print`函数并实例化类。我们断言所需的数据被打印出来。
- en: Is this a great unit test? Probably not. For one, it still takes the input from
    the `updates.csv` file. Ideally, we would have mocked out the file access. But
    it doesn't matter at the moment. This test passes and it will be a safety net
    when we start modifying the code. That is all we need the test to do for now.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个伟大的单元测试吗？可能不是。首先，它仍然从`updates.csv`文件中获取输入。理想情况下，我们会模拟文件访问。但此刻这并不重要。这个测试通过了，并且当开始修改代码时，它将是一个安全网。这就是我们现在需要的测试所做的一切。
- en: Using pdb to understand the code
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pdb理解代码
- en: The Python interactive shell is a great way to understand the code at the boundaries
    of method calls. It allows us to pass in various combinations of input and see
    what kind of output we get. But what if we want to see what is going on within
    a function or method? This is where `pdb` can be extremely useful.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python交互式外壳是理解方法调用边界代码的好方法。它允许我们传入各种输入组合并查看我们得到什么样的输出。但如果我们想看到函数或方法内部发生的事情呢？这就是`pdb`能极其有用的时候。
- en: '**pdb** is a Python Debugger, and it supplies as a part of the Python standard
    library. It has a number of features such as being able to step through the execution
    line by line, see how variables change, and set and remove breakpoints. pdb is
    very powerful, and there are a number of good books that cover it in detail. We
    won''t go through all the features in this book, but just give a short example
    of how it can be used to understand the code.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**pdb**是Python调试器，它是Python标准库的一部分。它有许多功能，例如能够逐行执行代码，查看变量如何变化，以及设置和删除断点。pdb非常强大，有许多好书详细介绍了它。我们不会在这本书中介绍所有功能，但只是给出一个简短的例子，说明如何使用它来理解代码。'
- en: 'To execute the code from within `pdb`, run the following lines in the interactive
    shell:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`pdb`中执行代码，请在交互式外壳中运行以下行：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `pdb.run` method allows us to specify any string as a parameter. That string
    is executed within the debugger. In this case, we are instantiating the class
    that starts executing all the code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb.run`方法允许我们指定任何字符串作为参数。这个字符串将在调试器中执行。在这种情况下，我们正在实例化开始执行所有代码的类。'
- en: 'At this point, we get the `(Pdb)` prompt from where we can walk through the
    execution, line by line. You can get help on the various commands available by
    typing `help`, as shown in the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们得到了`(Pdb)`提示符，从这里我们可以逐行执行代码。你可以通过输入`help`来获取各种命令的帮助，如下所示：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or, you can also get help by typing `help <command>` for help on a specific
    command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过输入`help <command>`来获取特定命令的帮助：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Some common pdb commands
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些常见的pdb命令
- en: 'Most of the time, we will use the following commands:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们会使用以下命令：
- en: '`s`: This executes one line of code (going inside a function call if required)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`: 这将执行一行代码（如果需要，将进入函数调用）'
- en: '`n`: This executes code until you reach the next line in the current function'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`: 这将执行代码直到你达到当前函数的下一行'
- en: '`r`: This executes code until the current function returns'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`: 这将执行代码直到当前函数返回'
- en: '`q`: This quits the debugger'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`q`: 这将退出调试器'
- en: '`b`: This sets a breakpoint on a particular line of a file'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`: 这将在文件的特定行上设置断点'
- en: '`cl`: This clears breakpoints'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cl`: 这将清除断点'
- en: '`c`: This continues execution until a breakpoint is encountered or until the
    end of execution'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`: 这将继续执行直到遇到断点或执行结束'
- en: These commands should be enough to move around code and try to inspect what
    is going on. pdb has a ton of other commands that we won't cover here.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令应该足以在代码中移动并尝试检查正在发生的事情。pdb还有许多其他命令，我们在这里不会介绍。
- en: Walking through a pdb session
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漫步pdb会话
- en: Let's now put this into practice. The following is a walk-through of our code
    using `pdb`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实际操作。以下是我们使用`pdb`遍历代码的过程。
- en: 'First, we run our command within `pdb` as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`pdb`中运行我们的命令，如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s step into the first line as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式进入第一行：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'pdb tells us that we are now within the `__init__` method. The `n` command
    will take us through the first few lines of this method, as shown in the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: pdb告诉我们我们现在在`__init__`方法中。`n`命令将带我们通过这个方法的前几行，如下所示：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can examine the initialization that seems to have been done by looking at
    some of the variables as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看一些变量来检查似乎已经完成的初始化，如下所示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can even try executing some of the local variables with various input as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以尝试用各种输入执行一些局部变量，如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This helps us understand the state of various objects during different parts
    of execution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们了解执行不同部分时各种对象的状态。
- en: 'The next section of code is the part where we open the file and read it. Let''s
    skip ahead of this by putting a breakpoint on line 25 and executing right to it
    with the `c` command, as shown in the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节代码是打开文件并读取的部分。让我们通过在25行设置断点并使用`c`命令直接执行来跳过这部分，如下所示：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that the file reading part is done, we can inspect the format of data that
    was read by examining the updates local variable. The `pp` command does a pretty
    print so that the output is easier to read, as shown in the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件读取部分已经完成，我们可以通过检查更新的局部变量来检查读取的数据格式。`pp`命令进行美化打印，以便输出更容易阅读，如下所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Looks like the file got parsed into a list of tuples, each containing `(stock
    symbol, timestamp, price)`. Let''s see what would happen if we had only the GOOG
    updates, as shown in the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来文件被解析为包含`(股票代码，时间戳，价格)`的元组列表。让我们看看如果我们只有GOOG更新会发生什么，如下所示：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There we go. As we can see, it is even possible to change the values held by
    local variables midway during execution. The following is the output when we run
    the remainder of the code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续。正如我们所见，甚至在执行过程中中途改变局部变量的值也是可能的。以下是我们运行代码剩余部分时的输出：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `cl` command clears the breakpoint, and we use the `c` command to run to
    the end of the execution. The output with the modified the updates variable gets
    printed. Since the execution is complete at this point, we are returned back to
    the interactive shell.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`cl`命令清除断点，我们使用`c`命令运行到执行的末尾。修改后的更新变量输出被打印出来。由于此时执行已经完成，我们被返回到交互式shell。'
- en: 'Our exploration is done for now. At any point, we could have quit the debugger
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的探索已经完成。在任何时候，我们都可以像下面这样退出调试器：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Quitting the debugger takes us back to the interactive shell. At this point,
    we might add a few more characterization tests based on the exploration that we
    just did.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 退出调试器将我们带回到交互式shell。在这个时候，我们可能会根据我们刚刚进行的探索添加一些更多的特征测试。
- en: Techniques to break dependencies
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破依赖关系的技巧
- en: 'Now that we''ve seen some techniques to help us understand the code, our next
    step is to break dependencies. This will help us write further characterization
    tests. To do this, we will *very carefully* start modifying the code. All the
    while, we will try to stick to the following goals:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些帮助我们理解代码的技巧，我们的下一步是打破依赖关系。这将帮助我们编写进一步的特性测试。为此，我们将非常小心地开始修改代码。在此期间，我们将尽量坚持以下目标：
- en: Make small changes that are very unlikely to break
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行非常不可能破坏的小改动
- en: Try to change the public interface as little as possible
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量少改变公共接口
- en: Why these goals? Because we have a lack of tests, we have to be careful with
    the changes we make. Hence, small changes are better. We also need to be careful
    of changing the public interface because we have to go and fix all the other files
    and modules that use this class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有这些目标？因为我们缺乏测试，我们必须对所做的更改保持谨慎。因此，小改动更好。我们还需要注意不要改变公共接口，因为我们必须去修复所有使用这个类的其他文件和模块。
- en: The Rope refactoring library
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线索重构库
- en: The **Rope refactoring library** is a library to perform automated refactoring
    of your code. For example, you could select a few lines and then type the command
    to extract it into a method. The library will automatically create this method
    with the appropriate code, parameters, and return value, and will automatically
    place a call to the newly extracted method in place of the original code. Automated
    refactoring in Python is a little tricky because the dynamic nature of the language
    makes it difficult to identify all the changes correctly. However, it is ideal
    for making small changes, like we are going to do in this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**线索重构库**是一个用于执行代码自动重构的库。例如，你可以选择几行代码，然后输入命令将其提取为方法。库将自动创建这个方法，包括适当的代码、参数和返回值，并将自动在原始代码的位置放置对新提取方法的调用。在Python中自动重构有点棘手，因为语言的动态特性使得正确识别所有更改变得困难。然而，它非常适合进行小改动，就像我们将在本章中做的那样。'
- en: Since it is a library, Rope doesn't have any UI for performing the refactorings.
    Instead, it is integrated into the development environment, as either an IDE or
    a text editor. Most popular IDEs and text editors have support for integrating
    with Rope. Rope is available at [https://github.com/python-rope/rope](https://github.com/python-rope/rope).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个库，Rope没有用于执行重构的UI。相反，它集成到开发环境中，作为IDE或文本编辑器。大多数流行的IDE和文本编辑器都支持与Rope集成。Rope可在[https://github.com/python-rope/rope](https://github.com/python-rope/rope)找到。
- en: If your IDE or text editor of choice supports integration with Rope, or has
    built-in refactoring capabilities, then use it as far as possible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的IDE或你选择的文本编辑器支持与Rope集成，或者有内置的重构功能，那么尽可能使用它。
- en: Separate initialization from execution
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将初始化与执行分离
- en: 'One of the problems that the class we are working with has is that the whole
    execution happens in the `__init__` method. This means that as soon as the class
    is constructed, everything is executed before we have a change to set up mocks
    or make other changes that will help us write characterization tests. Luckily,
    there is a simple solution to this. We will simply move the execution part into
    a separate method as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在工作的班级遇到的一个问题是整个执行过程都发生在`__init__`方法中。这意味着一旦类被构造，所有操作都会在我们有机会设置模拟或进行其他有助于编写特征测试的更改之前执行。幸运的是，这个问题有一个简单的解决方案。我们将简单地将执行部分移动到一个单独的方法中，如下所示：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The astute reader would have observed that we have just broken our second goal—to
    minimize changes to the public interface. The change that we've made has changed
    the interface. If there are other modules using this class, they would have only
    constructed the class, assuming all the processing is complete. We have to now
    go and find all the places where we are creating this class and add a call to
    the `run` method. Otherwise, the class will not work as expected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能会注意到，我们刚刚打破了我们的第二个目标——最小化对公共接口的更改。我们所做的更改已经改变了接口。如果有其他模块使用这个类，它们只会构造这个类，假设所有处理都已经完成。我们现在必须找到所有创建这个类的位置，并添加对`run`方法的调用。否则，这个类将无法按预期工作。
- en: 'To prevent having to fix all the callers, we can call the run method ourselves
    from within the initializer like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要修复所有调用者，我们可以在初始化器内部自己调用`run`方法，如下所示：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All the tests pass again, but once again, all the codes get executed the moment
    we instantiate the class. Are we back to square one? Let's see in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都通过了，但又一次，所有代码在实例化类的那一刻就会执行。我们是不是回到了起点？让我们在下一节中看看。
- en: Use default values for parameters
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为参数使用默认值
- en: One of the most useful features of Python is the concept of being able to set
    a default value for a parameter. This allows us to change the interface, while
    making it look just the same for existing callers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Python最有用的特性之一是能够为参数设置默认值的概念。这允许我们更改接口，同时让现有的调用者看起来没有变化。
- en: In the previous section, we moved a piece of code into the run method, and we
    called this method from the `__init__` method. It seems like we haven't really
    changed anything, but that is misleading.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将一段代码移动到了`run`方法中，并从`__init__`方法中调用了这个方法。这似乎我们没有真正改变什么，但这是一种误导。
- en: 'Here is the next change to the `__init__` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`__init__`方法的下一个更改：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What we have done is to introduce a new parameter called `autorun` and set the
    default value as `True`. We then wrap the call to the `run` method with a conditional.
    Only if `autorun` is `True` will the `run` method be called.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是引入了一个名为`autorun`的新参数，并将其默认值设置为`True`。然后我们用条件语句包装对`run`方法的调用。只有当`autorun`为`True`时，才会调用`run`方法。
- en: All the existing callers who use this class will be unchanged—when the constructor
    is called without parameters, the `autorun` parameter will be set to `True` and
    the `run` method will be called. Everything will be as expected.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现有的调用者使用这个类将保持不变——当不带参数调用构造函数时，`autorun`参数将被设置为`True`，并将调用`run`方法。一切都将如预期。
- en: But adding the parameter gives us the option to explicitly set the `autorun`
    parameter to `False` in our tests, and thus avoid the `run` method from being
    called. We can now instantiate the class, then set up any mocks or other test
    initialization that we want, and then proceed to manually call the `run` method
    in the test.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但添加参数给了我们一个选项，可以在测试中显式地将`autorun`参数设置为`False`，从而避免调用`run`方法。我们现在可以实例化这个类，然后设置我们想要的任何模拟或其他测试初始化，然后手动在测试中调用`run`方法。
- en: 'The following is the same characterization test that we wrote earlier, rewritten
    to take advantage of this new functionality:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的特征测试与之前我们编写的相同，但重写以利用这个新功能：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Bingo! That one change seems small now, but it is the change that enables us
    to write all the characterization tests that follow.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！现在这个变化看起来很小，但它正是使我们能够编写所有后续特征测试的变化。
- en: Extract the method and test
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取方法并测试
- en: It is very difficult to test methods that are large. This is because tests can
    only check inputs, outputs, and interactions. It becomes a problem if there are
    just a couple of lines within the whole method that we want to test.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 测试大的方法非常困难。这是因为测试只能检查输入、输出和交互。如果整个方法中只有几行是我们想要测试的，那么这就会成为一个问题。
- en: 'Let''s take a look at the `run` method again, as shown in the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看`run`方法，如下所示：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Suppose we want to just write characterization tests for the code in the second
    loop. How can do that? A simple way is to extract those lines into a separate
    method, as shown in the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想为第二循环中的代码编写特征测试。如何做到这一点？一个简单的方法是将这些行提取到一个单独的方法中，如下所示：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And we need to call the new method in the original place, as shown in the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在原始位置调用这个新方法，如下所示：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now write characterization tests for this new method as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以按照以下方式为这个新方法编写特征测试：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Ideally, we try to extract small groups of code so that the Extract Method refactoring
    is easy to perform without mistakes. Remember, we don't have the safety net of
    existing unit test here.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们尝试提取小的代码组，以便在不犯错误的情况下轻松执行提取方法重构。记住，我们在这里没有现有单元测试的安全网。
- en: Inject dependencies
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入依赖
- en: 'In the previous characterization test, we instantiated the class and then proceeded
    to replace the exchange instance variable with another one in which the Stock
    class was mocked out. Another way of achieving this aim is to use the earlier
    trick of introducing default variables like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的特征测试中，我们实例化了类，然后继续用另一个实例变量替换交换实例变量，其中`Stock`类被模拟。实现这一目标的另一种方法是使用以下早期技巧引入默认变量：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This allows us to inject in a mock when writing the characterization test,
    as shown in the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在编写特征测试时注入模拟，如下所示：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inherit and test
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承和测试
- en: Another way to achieve this goal is by writing a class that inherits from `AlertProcessor`,
    but includes parameters for the dependencies.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的另一种方法是编写一个从`AlertProcessor`继承的类，但包含依赖参数。
- en: 'For example, we could create a class like the following in the test file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在测试文件中创建一个如下所示的类：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This class inherits from `AlertProcessor` and takes in the parameters that we
    want to mock out in our characterization tests. The `__init__` method calls the
    original class initializer and then overrides the `exchange` parameter with the
    value passed to it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类从`AlertProcessor`继承，并接受我们在特征测试中想要模拟的参数。`__init__`方法调用原始类的初始化器，然后覆盖`exchange`参数为其传递的值。
- en: 'In the unit test, we can instantiate the test class instead of the real one.
    We pass in an exchange that contains mock stock objects. The mocks get set, and
    we can test that the right calls were made, as shown in the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，我们可以实例化测试类而不是真实类。我们传递一个包含模拟股票对象的交换。模拟被设置，我们可以测试是否调用了正确的调用，如下所示：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The advantage of this method compared to injecting dependencies via default
    parameters is that it does not require changing any code in the original class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过默认参数注入依赖相比，这种方法的优势在于它不需要在原始类中更改任何代码。
- en: Stubbing local methods
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟局部方法
- en: Most of the time, we use mocks to double for other classes or functions apart
    from the class being tested. For example, we mocked out the `Stock` objects in
    the example from the previous section, and we mocked out the `print` built-in
    function earlier in the chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们使用模拟来代替被测试类之外的其它类或函数。例如，我们在上一节的例子中模拟了`Stock`对象，并在本章早期模拟了内置的`print`函数。
- en: However, Python does not stop us from mocking out methods of the same class
    that we are testing. This is a powerful way of testing complex classes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python 并不允许我们模拟测试中相同类的成员方法。这是一种测试复杂类的强大方式。
- en: 'Let''s say that we want to test the code in the `run` method that parses the
    file, without executing the part that updates the stock values. The following
    is a test that does just that:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试`run`方法中解析文件的代码，而不执行更新股票价值的部分。以下是一个仅执行此操作的测试：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the test above, we stub out the `do_updates` method of the class before executing
    the `run` method. When we execute `run`, it parses the file, then instead of running
    the `do_updates` local method, it executes our mocked out method instead. Since
    the real method is stubbed out, the code does not update the `Stock` or print
    anything to the screen. All that functionality has been stubbed out. We then test
    whether the parsing was correct by checking whether the right parameters were
    passed to the `do_updates` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的测试中，我们在执行`run`方法之前模拟了类的`do_updates`方法。当我们执行`run`时，它解析文件，然后不是运行`do_updates`局部方法，而是执行我们的模拟方法。由于实际方法被模拟，代码不会更新`Stock`或打印任何内容到屏幕上。所有这些功能都已模拟。然后我们通过检查是否将正确的参数传递给`do_updates`方法来测试解析是否正确。
- en: Stubbing out a local method is a good way to understand a more complex class
    because it allows us to write characterization tests for small parts of the class
    in isolation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟局部方法是一个理解更复杂类的好方法，因为它允许我们单独为类的小部分编写特征测试。
- en: Extract the method and stub
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取方法和存根
- en: Sometimes, a method is quite long and we want to stub out a part of the method.
    We can combine the above techniques by extracting the part we want to stub out
    into a local method, and then stub out the method in the test.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个方法可能相当长，我们希望模拟方法的一部分。我们可以通过将我们想要模拟的部分提取到一个局部方法中，然后在测试中模拟该方法来组合上述技术。
- en: 'The following is what our `run` method currently looks like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们当前的`run`方法的样子：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's say that we want the tests to skip the part of the method where the file
    is read and parsed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望测试跳过方法中读取和解析文件的部分。
- en: 'We first extract the lines into a method as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将行提取为一个方法，如下所示：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we replace the lines in the `run` method with a call to the newly extracted
    method as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`run`方法中的行替换为新提取的方法调用，如下所示：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, the characterization test mocks out the newly extracted method, gives
    it a return value, and calls the `run` method, as shown in the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，特征测试模拟了新提取的方法，给它一个返回值，并调用`run`方法，如下所示：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With the file parsing lines extracted into a separate method, we can easily
    write a number of different characterization tests for different combinations
    of inputs. For example, the following is another characterization test that checks
    nothing is printed to screen for a different input:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件解析行提取到单独的方法后，我们可以轻松地为不同的输入组合编写多个不同的特征测试。例如，以下是一个检查对于不同输入没有打印到屏幕上的另一个特征测试：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can also use this technique to test hard to access code such as `lambda`
    functions. We extract the `lambda` function into a separate function, which enables
    us to write characterization tests for it separately or mock it when writing tests
    for other parts of the code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这项技术来测试难以访问的代码，例如`lambda`函数。我们将`lambda`函数提取到一个单独的函数中，这使得我们可以单独为它编写特征测试，或者在编写其他部分代码的测试时模拟它。
- en: Let's do the following for our code. First, extract the `lambda` function to
    a local method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的代码做以下操作。首先，将`lambda`函数提取到一个局部方法中。
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, replace the `print` lines with a call to the method as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`print`行替换为对方法的调用，如下所示：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how we have made the call. We still use a lambda function, but delegate
    to the local method with the appropriate parameters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的调用方式。我们仍然使用`lambda`函数，但使用适当的参数委托到局部方法。
- en: 'We can now mock out this method when writing the characterization tests for
    the `do_updates` method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在为`do_updates`方法编写特征测试时模拟此方法：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The cycle continues
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环继续
- en: All the techniques mentioned in the last section help us isolate pieces of code
    and break dependencies with other classes. This allows us to introduce stubs and
    mocks, making it easier to write more detailed characterization tests. The Extract
    Method refactoring is used a lot and is a great technique to isolate small sections
    of code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上节中提到的所有技术都有助于我们隔离代码片段，并与其他类断开依赖关系。这使我们能够引入存根和模拟，从而更容易编写更详细的特征测试。提取方法重构被大量使用，是一种隔离代码小部分的好技术。
- en: The whole process is iterative. In a typical session, we might look at a piece
    of code via `pdb`, and then decide to extract it to a method. We might then experiment
    with passing different inputs to the extracted method in the interactive shell,
    following which we might write a few characterization tests. We would then go
    back to another section of the class and write more tests after mocking or stubbing
    the new method, following which we might go back into `pdb` or the interactive
    shell to take a look at another piece of code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程是迭代的。在典型会话中，我们可能会通过`pdb`查看一段代码，然后决定将其提取为方法。我们可能会在交互式外壳中尝试向提取的方法传递不同的输入，之后我们可能会编写一些特征测试。然后我们会回到类的另一部分，在模拟或存根新方法后编写更多测试。之后我们可能会回到`pdb`或交互式外壳，查看另一段代码。
- en: Throughout the process, we keep making small changes that are unlikely to break
    and keep running all our existing characterization tests to test that we haven't
    broken anything.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，我们不断进行小的更改，这些更改不太可能破坏现有系统，并持续运行所有现有的特征测试，以确保我们没有破坏任何东西。
- en: Time to refactor
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构时间
- en: After a while, we might end up with a pretty good suite of characterization
    tests for the legacy code. We can now approach this code like any other well-tested
    code and start applying the bigger refactorings with an aim to improve the design
    before adding our new features.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一段时间，我们可能会为遗留代码获得一套相当不错的特征测试。现在我们可以像对待任何经过良好测试的代码一样处理这段代码，并开始应用更大的重构，目的是在添加新功能之前改进设计。
- en: For example, we might decide to extract the `print_action` method into a separate
    `Action` class, or the `parse_file` method into a `Reader` class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会决定将`print_action`方法提取到一个单独的`Action`类中，或者将`parse_file`方法提取到一个`Reader`类中。
- en: 'The following is a `FileReader` class where we have moved the contents from
    the `parse_file` local method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`FileReader`类，我们将内容从`parse_file`局部方法移动到这里：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We then use the Inject Dependencies pattern to pass the `reader` as a parameter
    to the constructor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用注入依赖模式将`reader`作为参数传递给构造函数：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And change the run method to call the reader:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`run`方法更改为调用读取器：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice how we are setting a default value so that other classes that use this
    class do not need to be changed. This allows us to override the `reader` parameter
    in tests as well as in new code, while the existing code will work fine without
    changes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何设置默认值的，这样使用这个类的其他类就不需要更改。这允许我们在测试以及新代码中覆盖`reader`参数，而现有代码在无需更改的情况下也能正常工作。
- en: 'We can now write a test for this by passing in a mock object to the constructor:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过向构造函数传递一个模拟对象来编写这个测试：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can do the same by extracting the `print_action` method into an `Action`
    class and passing it in as a parameter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`print_action`方法提取到`Action`类中并将其作为参数传递来实现同样的操作。
- en: Remember our original goals?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们的原始目标吗？
- en: 'Right at the start of this chapter, we had said that we wanted to implement
    the following two features:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章一开始，我们就说过我们想要实现以下两个功能：
- en: We need to be able to get updates from a network server
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够从网络服务器获取更新
- en: We need to be able to send an e-mail when an alert is matched
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当警报匹配时，我们需要能够发送电子邮件
- en: The original design didn't make it easy to add this functionality, and we would
    have needed to hack around the code—a dangerous and bug prone proposition.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 原始设计没有使添加此功能变得容易，我们可能需要对该代码进行一些修改——这是一个危险且容易出错的方案。
- en: Our newly refactored design now makes adding these features easy. All we need
    to do is to create new classes, say something like `NetworkReader`, which reads
    input from a server. We pass an instance of this object to the initializer via
    the reader parameter. `AlertProcessor` will then get updates from the server.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新重构的设计现在使得添加这些功能变得容易。我们只需要创建新的类，比如创建一个名为`NetworkReader`的类，它从服务器读取输入。我们通过读取器参数将这个对象的实例传递给初始化器。`AlertProcessor`将随后从服务器获取更新。
- en: We can do the same with by implementing an `EmailAction` class and passing that
    object into this class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现一个`EmailAction`类并将该对象传递给这个类来完成同样的操作。
- en: Long-term refactoring
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长期重构
- en: We've managed to safely add the new features to our legacy code. But our work
    doesn't stop here. There are places where we added default parameters to the `__init__`
    method so that we didn't break existing code that used this class. Over time,
    we would want to go to each of these places and change them to use the new interface.
    Once we have changed all the places, we can then remove the default parameters
    from the interface and the whole codebase would have migrated to the new interface.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将新功能安全地添加到我们的遗留代码中。但我们的工作还没有结束。我们在`__init__`方法中添加了一些默认参数，以便不破坏使用此类的现有代码。随着时间的推移，我们希望逐一访问这些地方，并将它们更改为使用新接口。一旦我们更改了所有地方，我们就可以从接口中删除默认参数，整个代码库就会迁移到新接口。
- en: The cool thing about this is that we don't have to do all the changes in one
    go. The codebase never stays broken for any length of time. We can make these
    changes over time, one by one, and the application is always working correctly
    at every point.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点很酷的是，我们不必一次性完成所有更改。代码库永远不会长时间处于破损状态。我们可以逐步进行这些更改，一次一个，应用程序在每一个点上始终是正确运行的。
- en: 'The other thing we need to do is to go back to our characterization tests and
    clean them up. Remember the first characterization test we wrote? It is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做的一件事是回到我们的特征测试，并对它们进行清理。还记得我们写的第一个特征测试吗？它如下所示：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: At the beginning of this chapter, we mentioned that this is not a great unit
    test, but it is good enough as a characterization test. Well, now is the time
    to revisit this test and make it better. Having refactored the design, we can
    now pass in a mock object for the reader. The test will no longer depend on the
    existence of the `updates.csv` file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到这并不是一个很好的单元测试，但作为一个特征测试来说已经足够好了。现在，是时候重新审视这个测试，并使其变得更好。经过重构设计后，我们现在可以向读者传递一个模拟对象。测试将不再依赖于`updates.csv`文件的存在。
- en: There were also a number of tests where we had patched out the print function.
    Once we refactor the design to take an `Action` class as an input, we would no
    longer need to patch this function as we can just pass in a mock action object
    to the initializer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还进行了一些测试，其中我们修补了打印函数。一旦我们将设计重构为接受`Action`类作为输入，我们就不再需要修补这个函数，因为我们可以直接传递一个模拟动作对象到初始化器。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw how to handle the hairy problem of working with the
    legacy code. We defined the legacy code as any code that does not contain tests.
    It is an unfortunate fact of life that we have to deal with such code. Fortunately
    there are a number of techniques available that allow us to safely work with such
    code. The interactive shell as well as the extremely powerful debugger are a huge
    help in understanding typical spaghetti code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了如何处理与遗留代码一起工作的棘手问题。我们将遗留代码定义为任何不包含测试的代码。我们必须处理这种代码是不幸的事实。幸运的是，有一些技术可以让我们安全地处理这种代码。交互式外壳以及极其强大的调试器在理解典型的乱麻代码方面提供了巨大的帮助。
- en: The dynamic nature of Python also makes it easy to break dependencies. We can
    use default value parameters to maintain compatibility with existing code while
    refactoring to a better design. Powerful patching features as well as the ability
    to dynamically alter existing instance variables and local methods allow us to
    write characterization tests that would normally have been much more difficult.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Python的动态特性也使得打破依赖变得容易。我们可以在重构到更好的设计的同时，使用默认值参数来保持与现有代码的兼容性。强大的修补功能和动态更改现有实例变量和局部方法的能力，使我们能够编写出通常会更困难的特征测试。
- en: Now that you have seen many ways to write tests, let's look at ways to keep
    everything maintainable. We will do this in the next chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了许多编写测试的方法，让我们来看看如何保持一切可维护。我们将在下一章中这样做。
