- en: Distributed Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce some important Python modules for distributed computing.
    In particular, we will describe the `socket` module, which allows you to implement
    simple applications distributed through the client-server model.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will introduce the Celery module, which is a powerful Python framework
    that is used to manage distributed tasks. Finally, we will describe the `Pyro4`
    module, which allows you to call methods that are used in different processes,
    potentially on a different machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing distributed computing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Python socket module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed task management with Celery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote Method Invocation (RMI) with `Pyro4`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing distributed computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Parallel* and *distributed computing* are similar technologies designed to
    increase the amount of processing power available for a specific task. Generally,
    these methods are used to solve problems that require large computational capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: When the problem is divided into many small pieces, individual sections of the
    problem can be calculated by many processors simultaneously. This allows more
    processing power to be exercised on the problem than can be provided by a single
    processor.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between parallel and distributed processing is that parallel
    configurations include many processors within a single system, while distributed
    configurations exploit the processing power of many computers simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the other differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parallel processing** | **Distributed processing** |'
  prefs: []
  type: TYPE_TB
- en: '| Parallel processing has the advantage of providing reliable processing power
    with a very low degree of latency. | Distributed processing is not extremely efficient
    on a processor-by-processor basis, as the data must travel over the network rather
    than through the internal connections of a single system. |'
  prefs: []
  type: TYPE_TB
- en: '| By concentrating all the processing power in one system, speed loss due to
    data transfer is minimized. | Each processor will contribute much less processing
    power than any processor in a parallel system since data transfer creates a bottleneck
    that limits processing power. |'
  prefs: []
  type: TYPE_TB
- en: '| The only real limit is the number of processors incorporated in the system.
    | The system is almost infinitely scalable since there is no actual upper limit
    to the number of processors in a distributed system. |'
  prefs: []
  type: TYPE_TB
- en: 'However, in the context of computer applications, it is customary to distinguish
    between local and distributed architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Local architectures** | **Distributed architectures** |'
  prefs: []
  type: TYPE_TB
- en: '| All the components are on the same machine. | Applications and components
    can reside on different nodes that are connected by a network. |'
  prefs: []
  type: TYPE_TB
- en: The advantages of using distributed computing consist mainly of the possibility
    of concurrent use of the programs, the centralization of the data, and the distribution
    of the processing load, which all come at the price of greater complexity, especially
    with communication between the various components.
  prefs: []
  type: TYPE_NORMAL
- en: Types of distributed applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Distributed applications can be classified according to the degree of distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server applications**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-level applications**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-server applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are only two levels and the operations are carried out entirely on the
    server. As an example, we can mention the classic static or dynamic websites.
    The tools for the realization of these types of applications are the network sockets,
    whose programming is possible in various languages, including C, C ++, Java, and,
    of course, Python.
  prefs: []
  type: TYPE_NORMAL
- en: The term *client-server system* refe*rs* to a network architecture in which
    a client computer or client terminal is generally connected to a server for the
    use of a certain service; for example, the sharing of a certain hardware/software
    resource with other clients, or relying on the underlying protocol architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client-server architecture is a system that realizes a distribution of both
    processing and data. The central element of the architecture is the server. The
    server can be considered both from a logical point of view and from a physical
    point of view. From the physical point of view—hardware—a server is a machine
    dedicated to running a software server.
  prefs: []
  type: TYPE_NORMAL
- en: From a logical point of view, a server is software. The server, as a logical
    process, provides services to other processes that take on the role of requester
    or client. Generally, the server does not send the results to the requester until
    the results are requested by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'A feature that distinguishes the client from its server is that the client
    can initiate a transaction with the server, while the server can never initiate
    a transaction with the client on its own initiative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9df2fb0-1a78-4826-b494-5e3b43effbf0.png)'
  prefs: []
  type: TYPE_IMG
- en: Client-server architecture
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the specific tasks of the client are to start transactions, request
    specific services, notify the completion of the service, and receive results from
    the server, as shown in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication between clients and servers can take place using a variety of
    mechanisms—from geographic to local networks, up to communication services—between
    applications at the OS level. Furthermore, a client-server architecture must be
    independent of the physical connection method that exists between the client and
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that it is not necessary for a client-server process
    to reside on physically separate systems. In fact, the server process and the
    client process can reside on the same computing platform.
  prefs: []
  type: TYPE_NORMAL
- en: The main objective of the client-server architecture, in the context of data
    management, is to allow client applications to access data managed by the servers.
    The server (understood in a logical sense as software) is often running on a remote
    system (for example, in another city or on a local network).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, client-server applications are often associated with distributed
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP client-server architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TCP/IP connection establishes a point-to-point connection between two applications.
    The extremes of this connection are marked by an IP address, which identifies
    the workstation by a port number, which makes it possible to have several connections
    that are connected to independent applications on the same workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Once the connection is established and the protocol can exchange data over it,
    the underlying TCP/IP protocol takes care of sending this data, divided into packets,
    from one end of the connection to the other. In particular, the TCP protocol deals
    with assembling and disassembling the packets, as well as managing the handshaking
    that guarantees the reliability of the connection, while the IP protocol takes
    care of transporting the individual packets and the choice of the best routing
    of the packets along with the network.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism underlies the robustness of the TCP/IP protocol, which, in turn,
    represents one of the reasons for the development of the protocol itself in the
    military sphere (ARPANET).
  prefs: []
  type: TYPE_NORMAL
- en: The various existing standard applications (such as web browsing, file transfer,
    and email) use standardized application protocols, such as HTTP, FTP, POP3, IMAP,
    and SMTP.
  prefs: []
  type: TYPE_NORMAL
- en: Each specific client-server application must instead define and apply its own
    proprietary application protocol. This can involve the exchange of data in blocks
    of a fixed size (which is the simplest solution).
  prefs: []
  type: TYPE_NORMAL
- en: Multi-level applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a greater number of levels that enable the processing load of the
    servers to be alleviated. Those that are, in fact, subdivided are the functionalities
    of the server-side, leaving the characteristics of the client part that has the
    task of hosting the application interface largely unchanged. An example of this
    type of architecture is that of the three-tier model, having a structure divided
    into three layers or levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Frontend or presentation tier or interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middle tier or application logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend or data tier or persistent data management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This nomenclature is typical of web applications. More generally, it is possible
    to refer to a subdivision in three levels that are applicable to any software
    application, which is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation Layer** (**PL**): This is the visualization part of the data
    (such as modules and controls of input) necessary for the user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business Logic Layer** (**BLL**): This is the main part of the application,
    which defines the various entities and their relationships independently of the
    methods of presentation available to the user and saved in the archives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Access Layer** (**DAL**): This contains everything necessary for the
    management of persistent data (essentially, database management systems).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will present some of the solutions proposed by Python for the implementation
    of distributed architectures. We will begin by describing the `socket` module
    with which we will implement some examples of the fundamental client-server model.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Python socket module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A socket is a software object that allows data to be sent and received between
    remote hosts (via a network) or between local processes, such as **Inter-Process
    Communication** (**IPC**).
  prefs: []
  type: TYPE_NORMAL
- en: Sockets were invented at Berkeley as part of the **BSD Unix** project. They
    are based precisely on the management model of input and output of Unix files.
    In fact, the operations of opening, reading, writing, and closing a socket occur
    in the same way as the management of Unix files, but with the difference that
    should be considered are the useful parameters for communication, such as addresses,
    port numbers, and protocols.
  prefs: []
  type: TYPE_NORMAL
- en: The success and spread of socket technology have gone hand in hand with the
    development of the internet. In fact, the combination of sockets with the internet
    has made communication between machines that are of any type, and/or are scattered
    throughout the world, incredibly easy (at least when compared with other systems).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The socket Python module exposes low-level C APIs for communication over a network
    using the **BSD** *(*short for **Berkeley Software Distribution**) socket interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module includes the `Socket` class, which includes the main methods for
    managing the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket ([family [, type [, protocol]]])`: Builds a socket using the following
    as arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `family` address, which can be `AF_INET (default)`, `AF_INET6`, or `AF_UNIX`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `type` socket, which can be `SOCK_STREAM (default)`, `SOCK_DGRAM`, or perhaps
    one of the other `"SOCK_"` constants
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `protocol` number (that is usually zero)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gethostname()`: Returns the current IP address of the machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accept ()`: Returns the following pair of values (`conn` and `address`), where
    `conn` is a socket type object (to send/receive data on the connection), while
    `address` is the address connected to the socket on the other end of the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bind (address)`: Associates the socket with the `address` server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method historically accepted a couple of parameters for the `AF_INET` addresses
    instead of a single tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '`close ()`: Provides the option to clean up the connection once communication
    with the client is finished. The sockets are closed and collected by the garbage
    collector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connect(address)`: Connects a remote socket to an address. The `address` format
    depends on the family address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, the server is listening on a default port, and by
    following a TCP/IP connection, the client sends to the server the date and time that
    the connection was established.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the server implementation for `server.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the relevant Python modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new socket using the given address, socket type, and protocol number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the local machine name (`host`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `port` number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect (bind) the socket to `host` and to `port`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listen for connections made to the socket. The argument of `5` specifies the
    maximum number of connections in the queue. The maximum value depends on the system
    (usually, it is `5`) and the minimum value is always `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Establish a connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the connection is accepted. The return value is a pair (`conn`, `address`),
    where `conn` is a new `socket` object that is used to send and receive data, and
    `address` is the address linked to the socket. Once accepted, a new socket is
    created and it will have its own identifier. This new socket is only used with
    this particular client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The address and the port that is connected are printed out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`currentTime` is evaluated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following statement sends data to the socket, returning the number of bytes
    sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following statement indicates the socket closure (that is, the communication
    channel); all subsequent operations on the socket will fail. The sockets are automatically
    closed when they are rejected, but it is always recommended to close them with
    the `close()` operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the client (`client.py`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `socket` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `socket` object is then created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the local machine name (`host`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `port` number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the connection to `host` and `port`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The maximum number of bytes that can be received is no more than 1,024 bytes:
    (`tm=s.recv(1024)`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, close the connection and finally print out the connection time to the
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clients and servers create their respective sockets, and the server listens
    to them on a port. The client makes a connection request to the server. It should
    be noted that we can have two different port numbers because one could only be
    dedicated to outgoing traffic, and the other could only be dedicated to entry.
    This depends on the host configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the client's local port does not necessarily coincide with the
    server's remote port. The server receives the request and, if accepted, a new
    connection is created. Now, the client and server communicate through a virtual
    channel, between the socket and the server, which is created specifically for
    the data flow of the data socket connection.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent with what was mentioned in the first phase, the server creates the
    data socket because the first one is used exclusively for managing requests. Therefore, it
    is possible that there are many clients communicating with the server using the
    data socket created by the server for them. The TCP protocol is connection-oriented,
    which means that when there is no longer a need to communicate, the client communicates
    this to the server and the connection is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the example, execute the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, execute the client (in a different Windows terminal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result on the client side should report the address (`addr`) and report
    `port` as connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, on the server side, the result should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a small change to the previous code, we can create a simple client-server
    application for file transfer. The server instantiates the socket and waits for
    the connection instance from the client. Once connected to the server, the client
    starts the data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: The data to be transferred, which is in the `mytext.txt` file, is copied byte
    by byte and sent to the server through the call to the `conn.send` function. The
    server then receives the data and writes it to a second file, `received.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for `client2.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the source code for `client.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Types of sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can distinguish between the following three types of sockets, which are
    characterized by connection modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stream sockets**: These are connection-oriented sockets, and they are based
    on reliable protocols such as TCP or SCTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Datagram** **sockets**: These are not connection-oriented (connectionless)
    sockets, and are based on the fast but unreliable UDP protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raw socket** (raw IP): The transport level is bypassed, and the header is
    accessible at the application level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will see more in particular of this type of socket only. Being based on transport
    layer protocols such as TCP, they guarantee a reliable, full-duplex, and connection-oriented
    communication, with a variable-length byte stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Communication through this socket consists of these phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creation of sockets**: Clients and servers create their respective sockets,
    and the server listens to them on a port. Since the server can create multiple
    connections with different clients (but also with the same one), it needs a queue
    to handle the various requests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Connection request**: The client requests a connection to the server. Note
    that we can have different port numbers because one could only be assigned to
    the outgoing traffic, and the other only to entry. This depends on the host configuration.
    Essentially, the client''s local port does not necessarily coincide with the server''s
    remote port. The server receives the request and, if accepted, a new connection
    is created. In the diagram, the port of the client socket is `8080`, while for
    the socket server, the port is `80`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Communication**: Now, the client and server communicate through a virtual
    channel, between the client''s socket, and a new socket (server side)*,* created
    specifically for the data flow of this connection: a data socket. As it was mentioned
    in the first phase, the server creates the data socket because the first data
    socket is used exclusively for managing requests. Therefore, it is possible that
    there are many clients communicating with the server, each with the data socket
    specifically created by the server for them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Closure of the connection**: Since the TCP is a connection-oriented protocol
    when there is no longer a need to communicate, the client communicates it to the
    server, which deallocates the data socket.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The phases of communication through stream sockets are shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a04807a-ed49-44eb-9f21-2346ea59f835.png)'
  prefs: []
  type: TYPE_IMG
- en: Stream socket phases
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information on Python sockets can be found at [https://docs.python.org/3/howto/sockets.html](https://docs.python.org/3/howto/sockets.html).
  prefs: []
  type: TYPE_NORMAL
- en: Distributed task management with Celery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Celery* is a Python framework that manages distributed tasks by following
    theobject-oriented middleware approach. Its main feature is handling many small
    tasks and distributing them on many computational nodes. Finally, the result of
    each task will then be reworked in order to compose the overall solution.'
  prefs: []
  type: TYPE_NORMAL
- en: To use Celery, a message broker is required. This is an independent (from Celery)
    software component that has the function of middleware, which is used to send
    and receive messages to distributed task workers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, a message broker—also known as message middleware—deals with the exchange
    of messages in a communication network.: the addressing scheme of this type of
    middleware is no longer of the point-to-point type, but is message-oriented addressing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reference architecture, with which the message broker manages the exchange
    of messages, is based on the so-called publish/subscribe paradigm, which is depicted
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/081ba83c-57b4-44c6-aaa5-89f6d9e0989c.png)'
  prefs: []
  type: TYPE_IMG
- en: Message broker architecture
  prefs: []
  type: TYPE_NORMAL
- en: Celery supports many types of brokers. However, the more complete ones are RabbitMQ
    and Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install Celery, use the `pip` installer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a message broker must be installed. There are several choices available,
    but for our example, it is recommended to install RabbitMQ from the following
    link: [http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html).'
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ is a message-oriented middleware that implements the **Advanced Message
    Queuing Protocol** (**AMQP**). The RabbitMQ server is written in the Erlang programming
    language, so in order to install it, you need to install Erlang after downloading
    it from [http://www.erlang.org/download.html](http://www.erlang.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps involved are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the `celery` installation, first start the message broker (for example, RabbitMQ).
    Then, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output, which indicates the `celery` version, is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's learn about how to create and call a task using the `celery` module.
  prefs: []
  type: TYPE_NORMAL
- en: '`celery` provides the following two methods to perform a call to a task:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply_async(args[, kwargs[, ...]])`: This sends a task message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay(*args, **kwargs)`: This is a shortcut to send a task message, but it
    does not support execution options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `delay` method is easier to use because it is called as a** regular function**: `task.delay(arg1,
    arg2, kwarg1=''x'', kwarg2=''y'')`. However, for `apply_async`, the syntax is `task.apply_async
    (args=[arg1,arg2] kwargs={''kwarg1'':''x'',''kwarg2'': ''y''})`.'
  prefs: []
  type: TYPE_NORMAL
- en: Windows setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use Celery in a Windows environment, you must perform the following
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to System Properties | Environment Variables | User or System variables |
    New.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Variable name: `FORKED_BY_MULTIPROCESSING`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variable value: `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason for this setup is because of Celery's dependence on the `billiard`
    package ([https://github.com/celery/billiard](https://github.com/celery/billiard)),
    which uses the `FORKED_BY_MULTIPROCESSING` variable.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Celery's Windows setup, read [https://www.distributedpython.com/2018/08/21/celery-4-windows/](https://www.distributedpython.com/2018/08/21/celery-4-windows/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The task here is a sum of two numbers. To perform this easy task, we have to
    compose the `addTask.py` and `addTask_main.py` script files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `addTask.py`, start to import the Celery framework as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the task. In our example, the task is a sum of two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, import the `addTask.py` file that was defined previously into `addtask_main.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, call `addTask.py` to execute the sum of two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use Celery, the first thing to do is to run the RabbitMQ service,
    and then execute the Celery worker server (that is, the `addTask.py` file script)
    by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the second script is launched using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the result should be as follows in the first Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the result is `10`. Let''s focus on the first script, `addTask.py`:
    in the first two lines of code, we create a `Celery` application instance that
    uses the RabbitMQ service broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first argument in the `Celery` function is the name of the current module
    (`addTask.py`), and the second is the broker keyboard argument; this indicates
    the URL that is used to connect the broker (RabbitMQ).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's introduce the task to be accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: Each task must be added with the `@app.task` annotation (namely, decorator); the
    decorator helps `Celery` to identify which functions can be scheduled in the task
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the decorator, we create the task that the workers can execute: this
    will be a simple function that performs the sum of two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second script, `addTask_main.py`, we call our task by using the `delay()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Let's remember that this method is a shortcut to the `apply_async()` method,
    which gives us greater control over the task execution.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Celery usage is very simple. It can be executed by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The main commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Celery protocol can be implemented in any language by using Webhooks ([https://developer.github.com/webhooks/](https://developer.github.com/webhooks/)).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information on Celery can be found at [http://www.celeryproject.org/](http://www.celeryproject.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended message brokers ([https://en.wikipedia.org/wiki/Message_broker](https://en.wikipedia.org/wiki/Message_broker)) are RabbitMQ
    ([https://en.wikipedia.org/wiki/RabbitMQ](https://en.wikipedia.org/wiki/RabbitMQ)) or Redis
    ([https://en.wikipedia.org/wiki/Redis](https://en.wikipedia.org/wiki/Redis)).
    Additionally, there is MongoDB ([https://en.wikipedia.org/wiki/MongoDB](https://en.wikipedia.org/wiki/MongoDB)),
    Beanstalk, Amazon SQS ([https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service](https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service)), CouchDB
    ([https://en.wikipedia.org/wiki/Apache_CouchDB](https://en.wikipedia.org/wiki/Apache_CouchDB)),
    and IronMQ ([https://www.iron.io/mq](https://www.iron.io/mq)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RMI with Pyro4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pyro **is short for **Python Remote Objects**. It works exactly like the
    Java **RMI **(short for **Remote Method Invocation**) allowing to invoke a method
    of a remote object (belonging to a different process) exactly as if the object
    were local (belonging to the same process in which the invocation runs).'
  prefs: []
  type: TYPE_NORMAL
- en: The use of an RMI mechanism, in an object-oriented system, involves significant
    advantages of uniformity and symmetry in the project, as this mechanism enables
    the modelling of interactions between distributed processes using the same conceptual
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following diagram, `Pyro4` enables objects to be distributed in
    a client/server style; this means that the main parts of a `Pyro4` system may
    switch from a client caller to a remote object, which is called to serve a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1782750b-b3f5-4ac1-8274-f01d46cff0ec.png)'
  prefs: []
  type: TYPE_IMG
- en: RMI
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that during the remote calling, there are always two
    distinct parts: a client and a server that accept and execute the client call.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The entire method of managing this mechanism in a distributed way is provided
    by `Pyro4`. To install the latest release of `Pyro4`, use the `pip` installer
    (Windows installation is used here) and add the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `pyro_server.py` and `pyro_client.py` codes for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we''ll see how to build and use a simple client-server communication using
    the `Pyro4` middleware. The code for the client is `pyro_server.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Pyro4` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `Server` class that contains the `welcomeMessage()` method that
    will be exposed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that the decorator, `@Pyro4.expose`, means that the preceding method will
    be remotely accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `startServer` function contains all the instructions that are used to start
    the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, build the `server` instance of the `Server` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the `Pyro4` daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this script, we must run a `Pyro4` statement to locate a nameserver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the object server as *Pyro object*; it will only be known inside the
    Pyro daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can register the object server with a name in the nameserver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The function ends with a call to the daemon''s `requestLoop` method. This starts
    the event loop of the server and waits for calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call `startServer` via the `main` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for the client (`pyro_client.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Pyro4` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Pyro4` API enables the developer to distribute objects in a transparent
    way. In this example, the client script sends requests to the server program in
    order to execute the `welcomeMessage()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the remote call is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the client calls the server, printing a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example is composed of two main functions: `pyro_server.py` and
    `pyro_client.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `pyro_server.py`, the `Server` class object provides the `welcomeMessage()` method,
    returning a string equal to the name inserted in the client session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`Pyro4` uses daemon objects to dispatch incoming calls to appropriate objects.
    A server must create just one daemon that manages everything from its instance.
    Each server has a daemon that knows about all the Pyro objects that the server
    provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the `pyro_client.py` function, the remote call is first performed and
    creates a `Proxy` object. In particular, the `Pyro4` client uses proxy objects
    to forward method calls to the remote objects, and then passes the results back
    to the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to execute a client-server connection, we need to have a `Pyro4` nameserver
    running. In Command Prompt, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you''ll see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding message means that the nameserver is running in your network.
    Finally, we can start the server and the client scripts in two separate Windows
    consoles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run `pyro_server.py`, just type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Following that, you''ll see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the client by typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following message will be printed out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a name (for example, `Ruvika`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following welcome message will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Among the features of `Pyro4`, there is the creation of object topologies.
    For example, let''s suppose we want to build a distributed architecture that follows
    a chain topology, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f93a4ab-70f7-4ecb-8a0b-f5633c11bad1.png)'
  prefs: []
  type: TYPE_IMG
- en: Chaining objects with Pyro4
  prefs: []
  type: TYPE_NORMAL
- en: The Client makes a request to **Server 1**, and then the request is forwarded to
    **Server *2***, which then calls **Server** **3**. The chain call ends when **Server
    3 **calls **Server 1**.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing chain topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement a chain topology using `Pyro4`**,** we need to implement a `chain`
    object and the `client` and `server` objects. The `Chain` class allows the call
    to be redirected to the next server by processing the input message and reconstructing
    the server address to which the request should be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note, in this case, the `@Pyro4.expose` decorator, which allows all the
    methods of the class (`chainTopology.py`) to be exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If the chain is closed (the last call is done from `server_chain_3.py` to `server_chain_1.py`),
    then a closing message is printed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A forwarding message is printed out if there is a next element in the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the source code for the client (`client_chain.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this is the source code for the first server (namely, `server_1`)
    in the chain that is called from the client (`server_chain_1.py`). Here, the relevant
    libraries are imported. Note, the import to the `chainTopology.py` file that was described
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Note also that the source code for the servers only differs as regards the
    definitions of the current and the next servers of the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining lines of code define the communication with the next element
    in the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this example, first run the `Pyro4` nameserver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the three servers in three different terminals, typing each of them respectively 
    (Windows terminals are used here):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first server (`server_chain_1.py`) in the first terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Followed by the second server (`server_chain_2.py`) in the second terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the third server  (`server_chain_3.py`) in the third terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the `client_chain.py` script from another terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output, as shown in the Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The preceding message is displayed as a result of the forwarding request passed
    across the three servers after it returned the fact that the task is completed
    to `server_chain_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can focus on the behavior of the object servers while the request
    is forwarded to the next object in the chain (refer to the message underneath
    the start message):'
  prefs: []
  type: TYPE_NORMAL
- en: '**`server_ 1`** is started and the following message is forwarded to `server_ 2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '`server_2` forwards the following message to `server_3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '`server_ 3` forwards the following message to `server_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the message returns to the starting point (in other words, `server_1`),
    closing the chain :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Pyro4` documentation is available at [https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf](https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: This contains a description and some application examples of the 4.75 release.
  prefs: []
  type: TYPE_NORMAL
