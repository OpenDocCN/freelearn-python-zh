- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Common Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见设计模式
- en: 'Design patterns have been a widespread topic in software engineering since
    their original inception in the famous **Gang of Four** (**GoF**) book, *Design
    Patterns: Elements of Reusable Object-Oriented Software*. Design patterns help
    to solve common problems with abstractions that work for certain scenarios. When
    they are implemented properly, the general design of the solution can benefit
    from them.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式自从在著名的**四人帮**（**GoF**）书籍《设计模式：可复用面向对象软件元素》中首次提出以来，一直是软件工程中的一个广泛讨论的话题。设计模式通过为特定场景提供抽象来帮助解决常见问题。当它们被正确实现时，解决方案的一般设计可以从它们中受益。
- en: In this chapter, we take a look at some of the most common design patterns,
    but not from the perspective of tools to apply under certain conditions (once
    the patterns have been devised), but rather we analyze how design patterns contribute
    to clean code. After presenting a solution that implements a design pattern, we
    will analyze how the final implementation is comparatively better than if we had
    chosen a different path.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们查看了一些最常见的设计模式，但不是从在特定条件下应用工具的视角（一旦模式被设计出来），而是分析设计模式如何有助于编写干净的代码。在展示实现设计模式的解决方案之后，我们将分析最终实现相对于选择不同路径的比较优势。
- en: As part of this analysis, we will see how to concretely implement design patterns
    in Python. As a result of that, we will see that the dynamic nature of Python
    implies some differences of implementation, with respect to other static typed
    languages, for which many of the design patterns were originally thought of. This
    means that there are some particularities about design patterns that you should
    bear in mind when it comes to Python, and, in some cases, trying to apply a design
    pattern where it doesn't really fit is non-Pythonic.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这次分析的一部分，我们将看到如何在Python中具体实现设计模式。结果，我们将看到Python的动态特性意味着与其他静态类型语言相比，在实现上存在一些差异，而这些设计模式最初是为它们而设计的。这意味着在设计模式方面，有一些特定的特性，当涉及到Python时你应该牢记在心，在某些情况下，试图在不适合的地方应用设计模式是不符合Python风格的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Common design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的设计模式
- en: Design patterns that don't apply in Python, and the idiomatic alternative that should
    be followed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中不适用且应遵循的惯用替代设计模式
- en: The Pythonic way of implementing the most common design patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现最常见设计模式的Python风格
- en: Understanding how good abstractions evolve naturally into patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解良好的抽象如何自然地演变成模式
- en: With the knowledge from previous chapters, we're now in a position to analyze
    code at a higher level of design and at the same time think in terms of its detailed
    implementation (how would we write it in a way that uses the features of Python
    most efficiently?).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 借助前几章的知识，我们现在可以分析更高层次的设计代码，同时考虑其详细的实现（我们如何以最有效地使用Python特性的方式来编写它？）。
- en: In this chapter, we'll analyze how we can use design patterns to achieve cleaner
    code, starting with analyzing some initial considerations in the following section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析如何使用设计模式来实现更干净的代码，从以下部分的分析初始考虑开始。
- en: Design pattern considerations in Python
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的设计模式考虑因素
- en: Object-oriented design patterns are ideas of software construction that appear
    in different scenarios when we deal with models of the problem we're solving.
    Because they're high-level ideas, it's hard to think of them as being tied to
    particular programming languages. They are instead more general concepts about
    how objects will interact in the application. Of course, they will have their
    implementation details, varying from language to language, but that doesn't form
    the essence of a design pattern.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的设计模式是软件构建的思路，当我们在处理我们正在解决的问题的模型时，它们会在不同的场景中出现。因为它们是高级思想，所以很难将它们视为与特定编程语言相关联。它们是关于对象如何在应用程序中交互的更一般的概念。当然，它们将有自己的实现细节，这些细节会因语言而异，但这并不构成设计模式的核心。
- en: That's the theoretical aspect of a design pattern, the fact that it is an abstract
    idea that expresses concepts about the layout of the objects in the solution.
    There are plenty of other books and several other resources about object-oriented
    design, and design patterns in particular, so in this book, we are going to focus
    on those implementation details for Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是设计模式的理论方面，即它是一个抽象的概念，表达了关于解决方案中对象布局的概念。关于面向对象设计和特别是设计模式，有大量的其他书籍和资源，所以在这本书中，我们将专注于Python的实现细节。
- en: Given the nature of Python, some of the classical design patterns aren't actually
    needed. That means that Python already supports features that render those patterns
    invisible. Some argue that they don't exist in Python, but keep in mind that invisible
    doesn't mean non-existing. They are there, just embedded in Python itself, so
    it's likely that we won't even notice them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Python的特性，一些经典的设计模式实际上并不需要。这意味着Python已经支持了那些使这些模式变得不可见的功能。有些人认为它们在Python中不存在，但请记住，不可见并不意味着不存在。它们确实存在，只是嵌入在Python本身中，所以我们可能甚至都不会注意到它们。
- en: Others have a much simpler implementation, again thanks to the dynamic nature
    of the language, and the rest of them are practically the same as they are in
    other platforms, with small differences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模式有更简单的实现，这同样要归功于语言的动态特性，而其余的模式在其他平台上实际上与它们相同，只有一些小的差异。
- en: In any case, the important goal for achieving clean code in Python is knowing
    what patterns to implement and how. That means recognizing some of the patterns
    that Python already abstracts and how we can leverage them. For instance, it would
    be completely non-Pythonic to try to implement the standard definition of the
    iterator pattern (as we would do in different languages), because (as we have
    already covered) iteration is deeply embedded in Python, and the fact that we
    can create objects that will directly work in a `for` loop makes this the right
    way to proceed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，实现Python中干净代码的重要目标就是知道要实现哪些模式以及如何实现。这意味着要识别Python已经抽象的一些模式以及我们如何利用它们。例如，尝试实现迭代器模式的常规定义（就像我们在其他语言中做的那样）是完全不符合Python风格的，因为（正如我们已经讨论过的）迭代在Python中已经深深嵌入，而且我们可以创建将在`for`循环中直接工作的对象，这使得这是正确的处理方式。
- en: Something similar happens with some of the creational patterns. Classes are
    regular objects in Python, and so are functions. As we have seen in several examples
    so far, they can be passed around, decorated, reassigned, and so on. That means
    that whatever kind of customization we would like to make to our objects, we can
    most likely do it without needing any particular setup of factory classes. Also,
    there is no special syntax for creating objects in Python (no `new` keyword, for
    example). This is another reason why, most of the time, a simple function call
    will work just like a factory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况也发生在一些创建型模式上。在Python中，类是常规对象，函数也是如此。正如我们在之前的几个例子中看到的，它们可以被传递、装饰、重新分配等等。这意味着无论我们想要对我们的对象进行何种定制，我们很可能不需要任何特定的工厂类设置就能做到。此外，Python中没有创建对象的特殊语法（例如没有`new`关键字）。这也是为什么在大多数情况下，简单的函数调用就能像工厂一样工作的另一个原因。
- en: Other patterns are still needed, and we will see how, with some small adaptations,
    we can make them more Pythonic, taking full advantage of the features that the
    language provides (magic methods or the standard library).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模式仍然是必需的，我们将看到如何通过一些小的调整，使它们更加符合Python风格，充分利用语言提供的特性（魔法方法或标准库）。
- en: Out of all the patterns available, not all of them are equally frequent, nor
    useful, so we will focus on the main ones, those that we would expect to see the
    most in our applications, and we will do so by following a pragmatic approach.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可用的模式中，并不是所有模式都同样频繁或有用，所以我们将关注主要的模式，那些我们预计会在我们的应用程序中最常看到的模式，我们将通过一种实用主义的方法来实现这一点。
- en: Design patterns in action
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式在实际应用中
- en: The canonical reference in this subject, as written by the GoF, introduces 23
    design patterns, each falling under one of the creational, structural, and behavioral
    categories. There are even more patterns or variations of existing ones, but rather
    than learning all of these patterns off by heart, we should focus on keeping two
    things in mind. Some of the patterns are invisible in Python, and we use them
    *probably* without even noticing. Secondly, not all patterns are equally common;
    some of them are tremendously useful, and so they are found very frequently, while others
    are for more specific cases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，由GoF（四人帮）撰写的规范参考书介绍了23种设计模式，每种模式都属于创建型、结构型和行为型类别之一。甚至还有更多模式或现有模式的变体，但与其死记硬背所有这些模式，我们更应该关注两点。一些模式在Python中是看不见的，我们可能在使用它们时甚至没有意识到。其次，并非所有模式都同样常见；其中一些非常有用，因此它们非常频繁地被找到，而另一些则适用于更具体的案例。
- en: In this section, we will revisit the most common patterns, those that are most
    likely to emerge from our design. Note the use of the word **emerge** here. We
    should not force the application of a design pattern to the solution we are building,
    but rather evolve, refactor, and improve our solution until a pattern emerges.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾最常见的模式，那些最有可能从我们的设计中出现的模式。注意这里使用“出现”这个词。我们不应该强迫将设计模式应用到我们正在构建的解决方案中，而应该通过进化、重构和改进我们的解决方案，直到出现一个模式。
- en: Design patterns are therefore not invented but discovered. When a situation
    that occurs repeatedly in our code reveals itself, the general and more abstract
    layout of classes, objects, and related components appears under a name by which
    we identify a pattern.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式并非是发明出来的，而是被发现出来的。当我们在代码中反复遇到某种情况时，类、对象和相关组件的通用和更抽象的布局就会以一个我们用来识别模式的名称出现。
- en: The name of a design pattern wraps up a lot of concepts. This is probably the
    best thing about design patterns; they provide a language. Through design patterns,
    it's easier to communicate design ideas effectively. When two or more software
    engineers share the same vocabulary, and one of them mentions strategy, the rest
    of the software engineers in the room can immediately think about all the classes,
    and how they would be related, what their mechanics would be, and so on, without
    having to repeat this explanation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的名称概括了众多概念。这可能是设计模式最好的地方；它们提供了一种语言。通过设计模式，更有效地传达设计思想变得容易。当两个或更多的软件工程师共享相同的词汇，并且其中一人提到策略时，房间里其余的软件工程师可以立即想到所有相关的类，以及它们如何相互关联，它们的机制是什么，等等，而不必重复这个解释。
- en: The reader will notice that the code shown in this chapter is different from
    the canonical or original envisioning of the design pattern in question. There
    is more than one reason for this. The first reason is that the examples take a
    more pragmatic approach, aimed at solutions for particular scenarios, rather than
    exploring general design theory. The second reason is that the patterns are implemented
    with the particularities of Python, which in some cases are very subtle, but in
    other cases, the differences are noticeable, generally simplifying the code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 读者会注意到，本章中展示的代码与所讨论的设计模式的规范或原始设想不同。这有多个原因。第一个原因是示例采取了一种更务实的方法，旨在解决特定场景的解决方案，而不是探索一般的设计理论。第二个原因是模式是用Python的特定性实现的，在某些情况下非常微妙，但在其他情况下，差异是明显的，通常简化了代码。
- en: Creational patterns
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建型模式
- en: In software engineering, creational patterns are those that deal with object
    instantiation, trying to abstract away much of the complexity (like determining
    the parameters to initialize an object, all the related objects that might be
    needed, and so on), in order to leave the user with a simpler interface that should
    be safer to use. The basic form of object creation could result in design problems
    or added complexity to the design. Creational design patterns solve this problem
    by somehow controlling this object creation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，创建型模式是那些处理对象实例化的模式，试图抽象掉很多复杂性（比如确定初始化对象所需的参数，所有可能需要的相关对象，等等），以便为用户提供一个更简单、更安全的接口。基本的对象创建形式可能会导致设计问题或增加设计的复杂性。创建型设计模式通过某种方式控制对象创建来解决这个问题。
- en: Out of the five patterns for creating objects, we will discuss mainly the variants
    that are used to avoid the singleton pattern and replace it with the Borg pattern
    (most commonly used in Python applications), discussing their differences and
    advantages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建对象的五种模式中，我们将主要讨论用于避免单例模式并替换为博格模式（在Python应用中最常用）的变体，讨论它们之间的差异和优势。
- en: Factories
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂
- en: As was mentioned in the introduction, one of the core features of Python is
    that everything is an object, and as such, they can all be treated equally. This
    means that there are no special distinctions of things that we can or cannot do
    with classes, functions, or custom objects. They can all be passed by a parameter,
    assigned, and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，Python的一个核心特性是万物皆对象，因此它们都可以被同等对待。这意味着我们没有特殊区分的事物，无论是使用类、函数还是自定义对象，我们都可以对它们进行操作。它们都可以通过参数传递、赋值等操作。
- en: It is for this reason that many of the factory patterns are not usually needed.
    We could just simply define a function that will construct a set of objects, and
    we can even pass the class that we want to create with a parameter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，许多工厂模式通常并不需要。我们只需简单地定义一个函数来构建一组对象，我们甚至可以用参数传递我们想要创建的类。
- en: We saw an example of a sort of factory in action when we used `pyinject` as
    a library to help us with dependency injection, and the initialization of complex
    objects. In cases where we need to deal with a complex setup, and we want to make
    sure we are using dependency injection to initialize our objects without repeating
    ourselves, we can use libraries such as `pyinject` or come up with an analogous
    structure in our code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`pyinject`作为库来帮助我们进行依赖注入和复杂对象的初始化时，我们看到了工厂模式的一个例子。在需要处理复杂设置，并确保我们使用依赖注入初始化对象而不重复代码的情况下，我们可以使用`pyinject`这样的库，或者在我们的代码中创建类似的结构。
- en: Singleton and shared state (monostate)
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单例和共享状态（单态）
- en: The singleton pattern, on the other hand, is something not entirely abstracted
    away by Python. The truth is that most of the time, this pattern is either not
    really needed or is a bad choice. There are a lot of problems with singletons
    (after all, they are, in fact, a form of global variables for object-oriented
    software, and as such are a bad practice). They are hard to unit test, the fact
    that they might be modified at any time by any object makes them hard to predict,
    and their side effects can be really problematic.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，单例模式并不是Python完全抽象化的。事实是，大多数情况下，这个模式要么根本不是必需的，要么是一个糟糕的选择。单例有很多问题（毕竟，它们实际上是面向对象软件的全局变量的形式，因此是不良实践）。它们难以进行单元测试，它们可能随时被任何对象修改，这使得它们难以预测，并且它们的副作用可能非常成问题。
- en: As a general principle, we should avoid using singletons as much as possible.
    If in some extreme case they are required, the easiest way of achieving this in
    Python is by using a module. We can create an object in a module, and once it's
    there, it will be available from every part of the module that is imported. Python
    itself makes sure that modules are already singletons, in the sense that no matter
    how many times they're imported, and from how many places, the same module is
    *always* the one that is going to be loaded into `sys.modules`. Therefore, an
    object initialized inside this Python module will be unique.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般原则，我们应该尽可能避免使用单例。如果在某些极端情况下需要使用单例，那么在Python中实现这一点的最简单方法就是使用模块。我们可以在模块中创建一个对象，一旦创建，它将可以从导入模块的任何部分访问。Python本身确保模块已经是单例的，也就是说，无论导入多少次，以及从多少个地方导入，总是同一个模块将被加载到`sys.modules`中。因此，在这个Python模块内部初始化的对象将是唯一的。
- en: Note how this is not quite the same as a singleton. The idea of a singleton
    is to create a class that no matter how many times you invoke it, will always
    give you the same object. The idea presented in the previous paragraph is about
    having a unique object. Regardless of how its class is defined, we create an object
    only once and then use the same object multiple times. These are sometimes called
    well-known objects; objects that don't need more than one of their kind.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不完全等同于单例。单例的想法是创建一个类，无论你调用多少次，它都会给你相同的对象。前一段中提出的思想是关于拥有一个唯一对象。无论其类如何定义，我们只创建一个对象，然后多次使用同一个对象。这些有时被称为知名对象；不需要超过一个的对象。
- en: 'We are familiar with these objects already. Consider `None`. We don''t need
    more than one for the whole Python interpreter. Some developers claim that "`None`
    is a singleton in Python." I slightly disagree with that. It''s a well-known object:
    something we all know, and we don''t need another one. The same goes for `True`
    and `False`. It wouldn''t make sense to try to create a different kind of boolean.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉这些对象了。考虑`None`。对于整个Python解释器，我们不需要多个。一些开发者声称“`None`在Python中是一个单例”。我对此略有不同意见。它是一个众所周知的对象：我们所有人都知道的东西，我们不需要另一个。对于`True`和`False`也是如此。尝试创建不同类型的布尔值是没有意义的。
- en: Shared state
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享状态
- en: Rather than forcing our design to have a singleton in which only one instance
    is created, no matter how the object is invoked, constructed, or initialized,
    it is better to replicate the data across multiple instances.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是强迫我们的设计有一个单例，无论对象是如何被调用、构造或初始化的，都只创建一个实例，更好的做法是在多个实例之间复制数据。
- en: The idea of the monostate pattern (SNGMONO) is that we can have many instances
    that are just regular objects, without having to care whether they're singletons
    or not (seeing as they're just objects). The good thing about this pattern is
    that these objects will have their information synchronized, in a completely transparent
    way, without us having to worry about how this works internally.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式（SNGMONO）的想法是，我们可以有许多只是普通对象而没有必要关心它们是否是单例（因为它们只是对象）。这个模式的好处是，这些对象将同步它们的信息，以一种完全透明的方式，我们不必担心它是如何内部工作的。
- en: This makes this pattern a much better choice, not only for its convenience,
    but also because it is less error-prone, and suffers from fewer of the disadvantages
    of singletons (regarding their testability, creating derived classes, and so on).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得这种模式成为一个更好的选择，不仅因为它方便，而且因为它更不容易出错，并且受单例模式（关于它们的可测试性、创建派生类等）的缺点更少。
- en: We can use this pattern on many levels, depending on how much information we
    need to synchronize.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要同步多少信息来在多个层面上使用这个模式。
- en: In its simplest form, we can assume that we only need to have one attribute
    to be reflected across all instances. If that is the case, the implementation
    is as trivial as using a class variable, and we just need to take care of providing
    a correct interface to update and retrieve the value of the attribute.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，我们可以假设我们只需要一个属性被反射到所有实例上。如果是这样，实现就像使用类变量一样简单，我们只需要确保提供一个正确的接口来更新和检索属性的值。
- en: 'Let''s say we have an object that has to `pull` a version of some code in a
    `Git` repository by the latest `tag`. There might be multiple instances of this
    object, and when every client calls the method for fetching the code, this object
    will use the `tag` version from its attribute. At any point, this `tag` can be
    updated for a newer version, and we want any other instance (new or already created)
    to use this new branch when the `fetch` operation is being called, as shown in
    the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个对象，它必须通过最新的`tag`从`Git`仓库中`pull`某个代码版本。可能会有多个此类对象实例，并且当每个客户端调用获取代码的方法时，此对象将使用其属性中的`tag`版本。在任何时候，这个`tag`都可以更新为更新版本，我们希望其他任何实例（无论是新创建的还是已经创建的）在调用`fetch`操作时使用这个新分支，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The reader can simply verify that creating multiple objects of the `GitFetcher`
    type with different versions will result in all objects being set with the latest
    version at any time, as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以简单地验证创建多个不同版本的`GitFetcher`类型的对象会导致所有对象在任何时候都设置为最新版本，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the case that we need more attributes, or that we wish to encapsulate the
    shared attribute a bit more, to make the design cleaner, we can use a descriptor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更多的属性，或者我们希望更紧密地封装共享属性，以使设计更简洁，我们可以使用描述符。
- en: 'A descriptor, like the one shown in the following code, solves the problem,
    and while it''s true that it requires more code, it also encapsulates a more concrete
    responsibility, and part of the code is actually moved away from our original
    class, making it more cohesive and compliant with the single responsibility principle:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，描述符解决了这个问题，虽然它确实需要更多的代码，但它封装了更具体的责任，并且部分代码实际上被移出了我们的原始类，这使得它更具有凝聚力和符合单一责任原则：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from these considerations, it's also true that the pattern is now more
    reusable. If we want to repeat this logic, we just have to create a new descriptor
    object that would work (complying with the DRY principle).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些考虑因素之外，现在这个模式也更加可重用。如果我们想要重复这个逻辑，我们只需要创建一个新的描述符对象，它将能够工作（符合DRY原则）。
- en: 'If we *now* want to do the same but for the current branch, we create this
    new class attribute, and the rest of the class is kept intact, while still having
    the desired logic in place, as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在想要对当前分支做同样的操作，我们创建这个新的类属性，而类的其余部分保持不变，同时仍然保留所需的逻辑，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The balance and trade-off of this new approach should be clear by now. This
    new implementation uses a bit more code, but it's reusable, so it saves lines
    of code (and duplicated logic) in the long run. Once again, refer to the three
    or more instances rule to decide if you should create such an abstraction.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新方法的平衡和权衡现在应该已经很清晰了。这种新的实现方式使用了更多的代码，但它可以重用，因此从长远来看可以节省代码行数（以及重复的逻辑）。再次提醒，参考三个或更多实例规则来决定你是否应该创建这样的抽象。
- en: Another important benefit of this solution is that it also reduces the repetition
    of unit tests (because we only need to test the `SharedAttribute` class, and not
    all uses of it).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的另一个重要好处是，它还减少了单元测试的重复（因为我们只需要测试`SharedAttribute`类，而不是它的所有使用）。
- en: Reusing code here will give us more confidence in the overall quality of the
    solution, because now we just have to write unit tests for the descriptor object,
    not for all the classes that use it (we can safely assume that they're correct
    as long as the unit tests prove the descriptor to be correct).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里重用代码将使我们更有信心于解决方案的整体质量，因为现在我们只需要为描述符对象编写单元测试，而不是为所有使用它的类编写单元测试（我们可以安全地假设它们是正确的，只要单元测试证明了描述符是正确的）。
- en: The Borg pattern
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 博尔模式
- en: The previous solutions should work for most cases, but if we really have to
    go for a singleton (and this has to be a really good exception), then there is
    one last better alternative to it, only this is a riskier one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的方法应该适用于大多数情况，但如果我们真的需要使用单例（这必须是一个非常好的例外），那么还有最后一个更好的替代方案，但这是一个风险更高的方案。
- en: This is the actual mono-state pattern, referred to as the Borg pattern in Python.
    The idea is to create an object that is capable of replicating all of its attributes
    among all instances of the same class. The fact that absolutely every attribute
    is being replicated has to be a warning to keep in mind undesired side effects.
    Still, this pattern has many advantages over the singleton.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是单态模式，在Python中被称为博尔模式。想法是创建一个对象，能够在其相同类的所有实例之间复制其所有属性。绝对每个属性都在被复制的事实必须是一个警告，要记住可能的不希望出现的副作用。尽管如此，这个模式与单例相比有很多优点。
- en: 'In this case, we are going to split the previous object into two—one that works
    over `Git` tags, and the other over branches. And we are using the code that will
    make the Borg pattern work:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将把之前的对象分成两个——一个用于处理`Git`标签，另一个用于处理分支。我们使用使博尔模式工作的代码：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both objects have a base class, sharing their initialization method. But then
    they have to implement it again in order to make the *Borg logic* work. The idea
    is that we use a class attribute that is a dictionary to store the attributes,
    and then we make the dictionary of each object (at the time it's being initialized)
    use this very same dictionary. This means that any update on the dictionary of
    an object will be reflected in the class, which will be the same for the rest
    of the objects because their class is the same, and dictionaries are mutable objects
    that are passed as a reference. In other words, when we create new objects of
    this type, they will all use the same dictionary, and this dictionary is constantly
    being updated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象都有一个基类，它们共享初始化方法。但随后它们必须再次实现它，以便使*博尔逻辑*工作。想法是使用一个字典作为类属性来存储属性，然后我们让每个对象的字典（在初始化时）使用这个相同的字典。这意味着任何对对象字典的更新都会反映在类上，对于其他对象来说也将是相同的，因为它们的类是相同的，而字典是可变的对象，作为引用传递。换句话说，当我们创建这种类型的新对象时，它们都将使用同一个字典，而这个字典会不断更新。
- en: Note that we cannot put the logic of the dictionary on the base class, because
    this will mix the values among the objects of different classes, which is not
    what we want. This boilerplate solution is what would make many think it's actually
    an idiom rather than a pattern.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不能将字典的逻辑放在基类上，因为这会将不同类对象之间的值混合在一起，这不是我们想要的。这个样板解决方案会让很多人认为它实际上是一个惯用语，而不是一个模式。
- en: 'A possible way of abstracting this in a way that achieves the DRY principle
    would be to create a `mixin` class, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一种以实现DRY原则的方式抽象化这一过程的方法是创建一个`mixin`类，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This time, we are using the `mixin` class to create the dictionary with the
    attributes in each class in case it doesn't already exist, and then continuing
    with the same logic.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用`mixin`类来创建具有每个类中属性的字典，以防它已经存在，然后继续使用相同的逻辑。
- en: This implementation should not have any major problems with inheritance, so
    it's a more viable alternative.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现应该不会与继承有任何重大问题，因此它是一个更可行的替代方案。
- en: Builder
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建者
- en: The builder pattern is an interesting pattern that abstracts away all the complex
    initialization of an object. This pattern does not rely on any particularity of
    the language, so it's as equally applicable in Python as it would be in any other
    language.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者模式是一种有趣的模式，它抽象化了对象的复杂初始化。这个模式不依赖于任何特定的语言特性，因此在Python中的应用与任何其他语言一样广泛。
- en: While it solves a valid case, it's usually also a complicated case that is more
    likely to appear in the design of a framework, library, or API. Similar to the
    recommendations given for descriptors, we should reserve this implementation for
    cases where we expect to expose an API that is going to be consumed by multiple
    users.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它解决了有效的情况，但它通常也是一个复杂的情况，更可能出现在框架、库或API的设计中。类似于对描述符给出的建议，我们应该将这种实现保留在预期将暴露给多个用户使用的API的情况下。
- en: The high-level idea of this pattern is that we need to create a complex object,
    that is, an object that also requires many others to work with. Rather than letting
    the user create all those auxiliary objects, and then assign them to the main
    one, we would like to create an abstraction that allows all of that to be done
    in a single step. In order to achieve this, we will have a `builder` object that
    knows how to create all the parts and link them together, giving the user an interface
    (which could be a class method) to parametrize all the information about what
    the resulting object should look like.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的高级思想是我们需要创建一个复杂对象，即一个还需要许多其他对象来协同工作的对象。我们不想让用户创建所有这些辅助对象，然后将它们分配给主要对象，我们希望创建一个抽象，允许所有这些操作在一步内完成。为了实现这一点，我们将有一个`builder`对象，它知道如何创建所有部分并将它们连接起来，为用户提供一个接口（可能是类方法），以参数化关于结果对象应如何看起来的一切信息。
- en: Structural patterns
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构型模式
- en: Structural patterns are useful for situations where we need to create simpler
    interfaces or objects that are more powerful by extending their functionality
    without adding complexity to their interfaces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型模式适用于需要创建更简单接口或通过扩展其功能而不增加接口复杂性的更强大对象的情况。
- en: The best thing about these patterns is that we can create more interesting objects,
    with enhanced functionality, and we can achieve this in a clean way; that is,
    by composing multiple single objects (the clearest example of this being the composite
    pattern), or by gathering many simple and cohesive interfaces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式最好的地方在于，我们可以创建更多有趣的对象，具有增强的功能，并且我们可以以干净的方式实现这一点；也就是说，通过组合多个单一对象（最明显的例子是组合模式），或者通过收集许多简单且一致的接口。
- en: Adapter
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器
- en: The adapter pattern is probably one of the simplest design patterns there are,
    and one of the most useful ones at the same time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式可能是最简单的设计模式之一，同时也是最有用的一种。
- en: Also known as a *wrapper*, this pattern solves the problem of adapting interfaces
    of two or more objects that are not compatible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为*包装器*，这个模式解决了两个或多个不兼容对象接口适配的问题。
- en: We typically encounter a situation where part of our code works with a model
    or set of classes that were polymorphic with respect to a method. For example,
    if there were multiple objects for retrieving data with a `fetch()` method, then
    we want to maintain this interface so we don't have to make major changes to our
    code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常遇到的情况是，我们的一部分代码与一个或一组类一起工作，这些类在某个方法上是多态的。例如，如果有多个对象使用`fetch()`方法检索数据，那么我们希望保持这个接口，这样我们就不必对我们的代码进行重大更改。
- en: But then we come to a point where we need to add a new data source, and alas,
    this one won't have a `fetch()` method. To make things worse, not only is this
    type of object not compatible, but it is also not something we control (perhaps
    a different team decided on the API, and we cannot modify the code, or it is an
    object coming from an external library).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们来到了一个需要添加新的数据源的地方，不幸的是，这个数据源没有`fetch()`方法。更糟糕的是，这种类型的对象不仅不兼容，而且我们也不控制它（可能是一个不同的团队决定了API，我们无法修改代码，或者它是一个来自外部库的对象）。
- en: Instead of using this object directly, we adapt its interface to the one we
    need. There are two ways of doing this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接使用这个对象，我们调整其接口以适应我们需要的接口。有两种方法可以做到这一点。
- en: The first way would be to create a class that inherits from the one we need
    and create an alias for the method (if required, it will also have to adapt the
    parameters and the signature), which internally will adapt the call to make it
    compatible with the method we need.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法可能是创建一个从我们需要继承的类，并为方法创建一个别名（如果需要，它还必须调整参数和签名），这样内部将调整调用以使其与所需的方法兼容。
- en: 'By means of inheritance, we import the external class and create a new one
    that will define the new method, calling the one that has a different name. In
    this example, let''s say the external dependency has a method named `search()`,
    which takes only one parameter for the search because it queries in a different
    fashion, so our `adapter` method not only calls the external one, but it also
    translates the parameters accordingly, as shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承，我们导入外部类并创建一个新的类，该类将定义新的方法，调用具有不同名称的方法。在这个例子中，假设外部依赖有一个名为`search()`的方法，它只接受一个参数进行搜索，因为它以不同的方式查询，所以我们的`adapter`方法不仅调用外部方法，而且还相应地转换参数，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Taking advantage of the fact that Python supports multiple inheritance, we can
    use it to create our adapters (and even create a `mixin` class that's an adapter,
    as we have seen in previous chapters).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Python支持多重继承的事实，我们可以用它来创建我们的适配器（甚至可以创建一个作为适配器的`mixin`类，就像我们在前面的章节中看到的那样）。
- en: However, as we have seen many times before, inheritance comes with more coupling
    (who knows how many other methods are being carried from the external library?),
    and it's inflexible. Conceptually, it also wouldn't be the right choice because
    we reserve inheritance for situations of specification (an inheritance IS-A kind
    of relationship), and in this case, it's not clear at all that our object has
    to be one of the kinds that are provided by a third-party library (especially
    since we don't fully comprehend that object).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们之前多次看到的，继承伴随着更多的耦合（谁知道有多少其他方法是从外部库中携带过来的？），并且它不够灵活。从概念上讲，这也不是正确的选择，因为我们保留继承用于规范的情况（继承是一种IS-A类型的关系），在这种情况下，我们的对象是否必须是第三方库提供的类型之一并不清楚（尤其是我们并不完全理解那个对象）。
- en: 'Therefore, a better approach would be to use composition instead. Assuming
    that we can provide our object with an instance of `UsernameLookup`, the code
    would be as simple as just redirecting the petition prior to adopting the parameters,
    as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更好的方法可能是使用组合。假设我们可以为我们提供的对象提供一个`UsernameLookup`的实例，代码将像以下代码所示，只需在采用参数之前重定向请求那么简单：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we need to adapt multiple methods, and we can devise a generic way of adapting
    their signature as well, it might be worth using the `__getattr__()` magic method
    to redirect requests toward the wrapped object, but as always with generic implementations,
    we should be careful of not adding more complexity to the solution.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要调整多个方法，并且我们可以设计一种通用的方法来调整它们的签名，那么使用`__getattr__()`魔法方法将请求重定向到包装对象可能是有价值的，但就像所有通用实现一样，我们应该小心不要给解决方案增加更多的复杂性。
- en: The use of `__getattr__()` might enable us to have a sort of "generic adapter";
    something that can wrap another object and adapt all its methods by redirecting
    calls in a generic way. But we should really be careful with this because this
    method will create something so generic that it might be even riskier and have
    unanticipated side effects. If we want to perform transformations or extra functionality
    over an object, while keeping its original interface, the decorator pattern is
    a much better option, as we'll see later in this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__getattr__()`可能使我们能够拥有一种“通用适配器”；一种可以包装另一个对象并通用地适配其所有方法的东西。但我们确实应该非常小心，因为这个方法将创建一个非常通用的东西，这可能甚至更危险，并产生不可预见的副作用。如果我们想在保持原始接口的同时对对象执行转换或额外功能，那么装饰器模式是一个更好的选择，正如我们将在本章后面看到的。
- en: Composite
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合
- en: There will be parts of our programs that require us to work with objects that
    are made out of other objects. We have base objects that have a well-defined logic,
    and then we will have other container objects that will group a bunch of base
    objects, and the challenge is that we want to treat both of them (the base and
    container objects) without noticing any differences.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的部分部分需要我们与由其他对象组成的对象一起工作。我们有具有良好定义逻辑的基本对象，然后我们将有其他容器对象，它们将分组一些基本对象，挑战在于我们希望在不察觉任何差异的情况下同时处理这两种对象（基本和容器对象）。
- en: The objects are structured in a tree hierarchy, where the basic objects would
    be the leaves of the tree, and the composed objects intermediate nodes. A client
    might want to call any of them to get the result of a method that is called. The
    composite object, however, will act as a client; this will also pass this request
    along with all the objects it contains, whether they are leaves or other intermediate
    notes, until they are all processed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象以树形层次结构组织，其中基本对象将是树的叶子，而组合对象将是中间节点。客户可能想要调用任何一个来获取被调用的方法的返回结果。然而，组合对象将充当客户端；它将把这个请求以及它包含的所有对象（无论是叶子还是其他中间节点）传递下去，直到所有对象都被处理。
- en: Imagine a simplified version of an online store in which we have products. Say
    that we offer the possibility of grouping those products, and we give customers
    a discount per group of products. A product has a price, and this value will be
    asked for when the customers come to pay. But a set of grouped products also has
    a price that has to be computed. We will have an object that represents this group
    that contains the products, and that delegates the responsibility of asking the
    price to each particular product (which might be another group of products as
    well), and so on, until there is nothing else to compute.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个简化版的在线商店，其中包含产品。比如说，我们提供将产品分组的功能，并为每组产品提供折扣。产品有一个价格，当顾客付款时，这个值会被询问。但是，一组分组产品的价格也需要计算。我们将有一个代表这个包含产品的组的对象，并将询问每个特定产品的价格的责任委托给每个产品（这可能是另一个产品组），依此类推，直到没有其他需要计算的内容。
- en: 'The implementation of this is shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了这种实现的示例：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We expose the `public` interface through a property and leave `price` as a `private`
    attribute. The `ProductBundle` class uses this property to compute the value with
    the discount applied by first adding all the prices of all the products it contains.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个属性公开接口，并将`price`保留为私有属性。`ProductBundle`类使用这个属性来计算折扣后的值，首先添加它包含的所有产品的价格。
- en: The only discrepancy between these objects is that they are created with different
    parameters. To be fully compatible, we should have tried to mimic the same interface
    and then added extra methods for adding products to the bundle but using an interface
    that allows the creation of complete objects. Not needing these extra steps is an
    advantage that justifies this small difference.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象之间唯一的差异是它们使用不同的参数创建。为了完全兼容，我们应该尝试模仿相同的接口，然后添加额外的添加产品到捆绑的方法，但使用允许创建完整对象的接口。不需要这些额外步骤是一个优势，这也证明了这种小差异的合理性。
- en: Decorator
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器
- en: Don't confuse the decorator pattern with the concept of a Python decorator,
    which we have gone through in *Chapter 5*, *Using Decorators to Improve Our Code*.
    There is some resemblance, but the idea of the design pattern is quite different.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将装饰器模式与Python装饰器的概念混淆，我们在*第5章*中已经讨论过，即*使用装饰器改进我们的代码*。它们有一些相似之处，但设计模式的思想相当不同。
- en: This pattern allows us to dynamically extend the functionality of some objects,
    without needing inheritance. It's a good alternative to multiple inheritance in
    creating more flexible objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式允许我们动态扩展某些对象的功能，而无需使用继承。它是创建更灵活对象时多重继承的良好替代方案。
- en: We are going to create a structure that lets a user define a set of operations
    (decorations) to be applied over an object, and we'll see how each step takes
    place in the specified order.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个结构，允许用户定义要应用到对象上的一系列操作（装饰），我们将看到每个步骤是如何按指定顺序进行的。
- en: The following code example is a simplified version of an object that constructs
    a query in the form of a dictionary from parameters that are passed to it (it
    might be an object that we would use for running queries to `Elasticsearch`, for
    instance, but the code leaves out distracting implementation details to focus
    on the concepts of the pattern).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例是一个简化版本的对象，它从传递给它的参数（例如，我们可能会使用它来运行对 `Elasticsearch` 的查询，但代码省略了分散注意力的实现细节，以专注于模式的理念）构建一个查询字典。
- en: 'In its most basic form, the query just returns the dictionary with the data
    it was provided when it was created. Clients expect to use the `render()` method
    of this object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，查询只是返回在创建时提供的数据的字典。客户端期望使用此对象的 `render()` 方法：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we want to render the query in different ways by applying transformations
    to the data (filtering values, normalizing them, and so on). We could create decorators
    and apply them to the `render` method, but that wouldn't be flexible enough—what
    if we want to change them at runtime? Or if we want to select some of them, but
    not others?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望通过应用转换到数据（过滤值、归一化等）来以不同的方式呈现查询。我们可以创建装饰器并将它们应用到 `render` 方法上，但这不会足够灵活——如果我们想在运行时更改它们怎么办？或者如果我们只想选择其中的一些，而不是全部呢？
- en: The design is to create another object, with the same interface and the capability
    of enhancing (decorating) the original result through many steps, but that can
    be combined. These objects are chained, and each one of them does what it was
    originally supposed to do, plus something else. This something else is the particular
    decoration step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 设计是创建另一个具有相同接口和通过多个步骤增强（装饰）原始结果的能力，但可以组合的对象。这些对象是链式的，每个对象都执行它原本应该执行的操作，以及一些其他操作。这个其他操作就是特定的装饰步骤。
- en: 'Since Python has duck typing, we don''t need to create a new base class and
    make these new objects part of that hierarchy, along with `DictQuery`. Simply
    creating a new class that has a `render()` method will be enough (again, polymorphism
    should not require inheritance). This process is shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 有鸭子类型，我们不需要创建一个新的基类并将这些新对象作为该层次结构的一部分，包括 `DictQuery`。只需创建一个新的具有 `render()`
    方法的类就足够了（再次强调，多态不应需要继承）。这个过程在下面的代码中显示：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `QueryEnhancer` phrase has an interface that is compatible with what the
    clients of `DictQuery` are expecting, so they are interchangeable. This object
    is designed to receive a decorated one. It's going to take the values from this
    and convert them, returning the modified version of the code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryEnhancer` 语句有一个与 `DictQuery` 客户端期望的接口兼容的接口，因此它们可以互换。此对象旨在接收一个装饰过的对象。它将从这些值中获取值并转换它们，返回修改后的代码版本。'
- en: 'If we want to remove all values that evaluate to `False` and normalize them
    to form our original query, we have to use the following schema:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想删除所有评估为 `False` 的值并将它们归一化以形成我们的原始查询，我们必须使用以下模式：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a pattern that we can also implement in different ways, taking advantage
    of the dynamic nature of Python, and the fact that functions are objects. We could
    implement this pattern with functions that are provided to the base decorator
    object (`QueryEnhancer`), and define each decoration step as a function, as shown
    in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们可以以不同方式实现的模式，利用 Python 的动态特性和函数是对象的事实。我们可以通过将函数提供给基装饰器对象（`QueryEnhancer`），并将每个装饰步骤定义为函数来实现此模式，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With respect to the client, nothing has changed because this class maintains
    the compatibility through its `render()` method. Internally, however, this object
    is used in a slightly different fashion, as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端来说，没有任何变化，因为这个类通过其 `render()` 方法保持了兼容性。然而，在内部，这个对象的使用方式略有不同，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `remove_empty` and `case_insensitive` are just regular
    functions that transform a dictionary.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`remove_empty` 和 `case_insensitive` 只是转换字典的常规函数。
- en: In this example, the function-based approach seems easier to understand. There
    might be cases with more complex rules that rely on data from the object being
    decorated (not only its result), and in those cases, it might be worth going for
    the object-oriented approach, especially if we really want to create a hierarchy
    of objects where each class actually represents some knowledge we want to make
    explicit in our design.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，基于函数的方法似乎更容易理解。可能会有一些更复杂的规则，这些规则依赖于被装饰对象的数据（不仅仅是它的结果），在这些情况下，采用面向对象的方法可能更有价值，尤其是如果我们真的想在设计中创建一个对象层次结构，其中每个类实际上代表了一些我们想要在设计中明确表达的知识。
- en: Facade
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外观
- en: Facade is an excellent pattern. It's useful in many situations where we want
    to simplify the interaction between objects. The pattern is applied where there
    is a relation of many-to-many among several objects, and we want them to interact.
    Instead of creating all of these connections, we place an intermediate object
    in front of many of them that act as a facade.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式是一个优秀的模式。它在许多情况下都很有用，当我们想要简化对象之间的交互时。模式应用于存在多个对象之间多对多关系的场景，我们希望它们进行交互。而不是创建所有这些连接，我们在许多对象前面放置一个中间对象，充当外观。
- en: The facade works as a hub or a single point of reference in this layout. Every
    time a new object wants to connect to another one, instead of having to have **N**
    interfaces for all **N** possible objects it needs to connect to (requiring **O(N**²**)**
    total connections), it will instead just talk to the facade, and this will redirect
    the request accordingly. Everything that's behind the facade is completely opaque
    to the rest of the external objects.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个布局中，外观充当中心或单一参考点。每次新对象想要连接到另一个对象时，它不需要为所有可能的 **N** 个对象创建 **N** 个接口（需要 **O(N²**)
    的总连接），它只需与外观进行通信，然后外观会相应地重定向请求。外观后面的所有内容对外部对象来说都是完全透明的。
- en: Apart from the main and obvious benefit (the decoupling of objects), this pattern
    also encourages a simpler design with fewer interfaces and better encapsulation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主要和明显的益处（对象的解耦）之外，这种模式还鼓励设计更简单，接口更少，封装性更好的设计。
- en: This is a pattern that we can use not only for improving the code of our domain
    problem but also to create better APIs. If we use this pattern and provide a single
    interface, acting as a single point of truth or entry point for our code, it will
    be much easier for our users to interact with the functionality exposed. Not only
    that, but by exposing a functionality and hiding everything behind an interface,
    we are free to change or refactor that underlying code as much as we want, because
    as long as it is behind the facade, it will not break backward compatibility,
    and our users will not be affected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们可以用来改进领域问题的代码，也可以用来创建更好的 API 的模式。如果我们使用这个模式并提供一个单一接口，作为我们代码的单一点真实或入口点，那么用户与暴露的功能交互将会容易得多。不仅如此，通过暴露功能并隐藏在接口背后的所有内容，我们可以自由地更改或重构底层代码，因为我们可以在外观后面进行更改，而不会破坏向后兼容性，用户也不会受到影响。
- en: Note how this idea of using facades is not even limited to objects and classes,
    but also applies to packages (technically, packages are objects in Python, but
    still). We can use this idea of the facade to decide the layout of a package;
    that is, what is visible to the user and importable, and what is internal and
    should not be imported directly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用外观模式的想法不仅限于对象和类，也适用于包（技术上，包在 Python 中是对象，但仍然如此）。我们可以使用外观模式来决定包的布局；也就是说，用户可以看到什么，可以导入什么，以及内部的内容不应该直接导入。
- en: When we create a directory to build a package, we place the `__init__.py` file
    along with the rest of the files. This is the root of the module, a sort of facade.
    The rest of the files define the objects to export, but they shouldn't be directly
    imported by clients. The `__init__.py` file should import them and then clients
    should get them from there. This creates a better interface because users only
    need to know a single entry point from which to get the objects, and more importantly,
    the package (the rest of the files) can be refactored or rearranged as many times
    as needed, and this will not affect clients as long as the main API on the `init`
    file is maintained. It is of utmost importance to keep principles like this one
    in mind in order to build maintainable software.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个目录来构建一个包时，我们将`__init__.py`文件与其他文件一起放置。这是模块的根，一种门面。其余的文件定义了要导出的对象，但它们不应该被客户端直接导入。`__init__.py`文件应该导入它们，然后客户端应该从那里获取它们。这创建了一个更好的接口，因为用户只需要知道一个单一的入口点来获取对象，更重要的是，包（其余的文件）可以根据需要多次重构或重新排列，只要`init`文件上的主要API保持不变。牢记这样的原则对于构建可维护的软件至关重要。
- en: There is an example of this in Python itself, with the `os` module. This module
    groups an operating system's functionality, but underneath it, uses the `posix`
    module for **Portable Operating System Interface** (**POSIX**) operating systems
    (this is called **nt** on Windows platforms). The idea is that, for portability
    reasons, we shouldn't ever really import the `posix` module directly, but always
    the `os` module. It is up to this module to determine from which platform it is
    being called and expose the corresponding functionality.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python本身中就有这样一个例子，即`os`模块。该模块将操作系统的功能分组，但在其下面，它使用`posix`模块为**可移植操作系统接口**（**POSIX**）操作系统（在Windows平台上称为**nt**）。想法是，出于可移植性的原因，我们永远不应该直接导入`posix`模块，而应该总是导入`os`模块。这个模块负责确定它被哪个平台调用，并公开相应的功能。
- en: Behavioral patterns
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为模式
- en: Behavioral patterns aim to solve the problem of how objects should cooperate,
    how they should communicate, and what their interfaces should be at runtime.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式旨在解决对象应该如何协作、如何通信以及它们在运行时应该有什么接口的问题。
- en: 'We mainly discuss the following behavioral patterns:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要讨论以下行为模式：
- en: Chain of responsibility
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链模式
- en: Template method
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Command
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: State
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: This can be accomplished statically by means of inheritance or dynamically by
    using composition. Regardless of what the pattern uses, what we will see throughout
    the following examples is that what these patterns have in common is the fact
    that the resulting code is better in some significant way, whether this is because
    it avoids duplication or creates good abstractions that encapsulate behavior accordingly
    and decouple our models.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过继承或使用组合动态地完成。无论该模式使用什么，在接下来的示例中，我们将看到这些模式共有的特点是，结果代码在某些重要方面有所改进，无论是避免重复还是创建良好的抽象来相应地封装行为并解耦我们的模型。
- en: Chain of responsibility
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 责任链模式
- en: Now we are going to take another look at our event systems. We want to parse
    information about the events that happened on the system from the log lines (text
    files, dumped from our HTTP application server, for example), and we want to extract
    this information in a convenient way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次审视我们的事件系统。我们希望从日志行（例如，从我们的HTTP应用程序服务器导出的文本文件）中解析系统上发生的事件的信息，并且我们希望以方便的方式提取这些信息。
- en: In our previous implementation, we achieved an interesting solution that was
    compliant with the open/closed principle and relied on the use of the `__subclasses__()`
    magic method to discover all possible event types and process the data with the
    right event, resolving the responsibility through a method encapsulated on each
    class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的实现中，我们实现了一个符合开闭原则的有趣解决方案，它依赖于使用`__subclasses__()`魔法方法来发现所有可能的事件类型，并使用正确的事件处理数据，通过每个类封装的方法来解决问题。
- en: This solution worked for our purposes, and it was quite extensible, but as we'll
    see, this design pattern will bring additional benefits.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案符合我们的需求，并且相当灵活，但正如我们将看到的，这种设计模式将带来额外的优势。
- en: 'The idea here is that we are going to create the events in a slightly different
    way. Each event still has the logic to determine whether or not it can process
    a particular log line, but it will also have a `successor`. This `successor` is
    a new event, the next one in the line, that will continue processing the text
    line in case the first one was not able to do so. The logic is simple—we chain
    the events, and each one of them tries to process the data. If it can, then it
    just returns the result. If it can''t, it will pass it to its `successor` and
    repeat, as shown in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是我们将以稍微不同的方式创建事件。每个事件仍然具有确定是否可以处理特定日志行的逻辑，但它还将有一个`successor`。这个`successor`是一个新的事件，是队列中的下一个事件，如果第一个事件无法处理文本行，它将继续处理文本行。逻辑很简单——我们链式地连接事件，每个事件都尝试处理数据。如果它可以，它就返回结果。如果它不能，它将传递给它的`successor`并重复，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this implementation, we create the `event` objects, and arrange them in
    the particular order in which they are going to be processed. Since they all have
    a `process()` method, they are polymorphic for this message, so the order in which
    they are aligned is completely transparent to the client, and either one of them
    would be transparent too. Not only that, but the `process()` method has the same
    logic; it tries to extract the information if the data provided is correct for
    the type of object handling it, and if not, it moves on to the next one in the
    line.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们创建`event`对象，并按照它们将要被处理的特定顺序排列。由于它们都具有`process()`方法，它们对于这个消息是多态的，因此它们对齐的顺序对客户端来说是完全透明的，任何一个都是透明的。不仅如此，`process()`方法具有相同的逻辑；它试图提取提供的数据是否适合处理该对象类型的正确信息，如果不是，它将移动到队列中的下一个。
- en: 'This way, we could process a login event in the following way:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以按照以下方式处理登录事件：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note how `LogoutEvent` received `LoginEvent` as its successor, and when it was
    asked to process something that it couldn't handle, it redirected to the correct
    object. As we can see from the `type` key on the dictionary, `LoginEvent` was
    the one that actually created that dictionary.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`LogoutEvent`如何接收`LoginEvent`作为其后续事件，当它被要求处理它无法处理的事情时，它将重定向到正确的事件。正如我们从字典上的`type`键中可以看到的，`LoginEvent`实际上是创建那个字典的事件。
- en: This solution is flexible enough and shares an interesting trait with our previous
    one—all conditions are mutually exclusive. As long as there are no collisions,
    and no piece of data has more than one handler, processing the events in any order
    will not be an issue.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案足够灵活，并且与我们的上一个解决方案有一个有趣的共同点——所有条件都是互斥的。只要没有冲突，并且没有数据块有多个处理程序，以任何顺序处理事件将不会成问题。
- en: But what if we cannot make such an assumption? With the previous implementation,
    we could still change the `__subclasses__()` call for a list that we made according
    to our criteria, and that would have worked just fine. And what if we wanted that
    order of precedence to be determined at runtime (by the user or client, for example)?
    That would be a shortcoming.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们不能做出这样的假设怎么办？在之前的实现中，我们仍然可以改变根据我们的标准制作的列表中的`__subclasses__()`调用，而且效果会很好。如果我们想运行时（例如，由用户或客户端）确定这种优先级顺序，这将是一个缺点。
- en: With the new solution, it's possible to accomplish such requirements because
    we assemble the chain at runtime so we can manipulate it dynamically as we need
    to.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 新的解决方案允许我们实现这样的要求，因为我们可以在运行时组装这个链，这样我们就可以根据需要动态地操作它。
- en: 'For example, now we add a generic type that groups both the login and logout
    session events, as shown in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在我们添加一个通用类型，将登录和登出会话事件分组，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If for some reason, and in some part of the application, we want to capture
    this before the login event, this can be done by the following chain:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，在应用程序的某个部分，我们想在登录事件之前捕获它，可以通过以下链来完成：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By changing the order, we can, for instance, say that a generic session event
    has a higher priority than the login, but not the logout, and so on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变顺序，例如，我们可以指定通用会话事件比登录有更高的优先级，但不是登出，等等。
- en: The fact that this pattern works with objects makes it more flexible with respect
    to our previous implementation, which relied on classes (and while they are still
    objects in Python, they aren't excluded from some degree of rigidity).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个模式与对象一起工作使其比我们之前的实现更加灵活，我们之前的实现依赖于类（虽然在Python中它们仍然是对象，但它们并没有完全排除一定程度上的刚性）。
- en: The template method
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板方法
- en: The template method is a pattern that yields important benefits when implemented
    properly. Mainly, it allows us to reuse code, and it also makes our objects more
    flexible and easier to change while preserving polymorphism.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式是一种在正确实现时能带来重要益处的模式。主要的好处是它允许我们重用代码，并且它还使我们的对象更加灵活，更容易更改，同时保持多态性。
- en: The idea is that there is a class hierarchy that defines some behavior, let's
    say an important method of its public interface. All of the classes of the hierarchy
    share a common template and might need to change only certain elements of it.
    The idea, then, is to place this generic logic in the public method of the parent
    class that will internally call all other (private) methods, and these methods
    are the ones that the derived classes are going to modify; therefore, all the
    logic in the template is reused.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是存在一个定义某些行为的类层次结构，比如说其公共接口中的一个重要方法。层次结构中的所有类共享一个公共模板，可能只需要更改其某些元素。因此，理念是将这种通用逻辑放在父类的公共方法中，该方法将内部调用所有其他（私有）方法，而这些方法正是派生类将要修改的；因此，模板中的所有逻辑都得到了重用。
- en: 'Astute readers might have noticed that we already implemented this pattern
    in the previous section (as part of the chain of responsibility example). Note
    that the classes derived from `Event` implement only one thing in their particular
    pattern. For the rest of the logic, the template is in the `Event` class. The
    `process` event is generic, and relies on two auxiliary methods: `can_process()`
    and `process()` (which in turn calls `_parse_data()`).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能已经注意到，我们在前面的章节中已经实现了这个模式（作为责任链模式示例的一部分）。请注意，从`Event`派生出的类在其特定模式中只实现了一件事。对于其余的逻辑，模板位于`Event`类中。`process`事件是通用的，依赖于两个辅助方法：`can_process()`和`process()`（它反过来调用`_parse_data()`）。
- en: These extra methods rely on a class attribute pattern. Therefore, in order to
    extend this with a new type of object, we just have to create a new derived class
    and place the regular expression. After that, the rest of the logic will be inherited
    with this new attribute changed. This reuses a lot of code because the logic for
    processing the log lines is defined once and only once in the parent class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的方法依赖于类属性模式。因此，为了扩展这个模式以支持新的对象类型，我们只需创建一个新的派生类并将正则表达式放置其中。之后，其余的逻辑将通过这个新的属性继承过来。这重用了大量的代码，因为处理日志行的逻辑在父类中只定义了一次。
- en: This makes the design flexible because preserving the polymorphism is also easily
    achievable. If we need a new event type that for some reason needs a different
    way of parsing data, we only override this private method in that subclass, and
    the compatibility will be kept, as long as it returns something of the same type
    as the original one (complying with the Liskov's substitution and open/closed
    principles). This is because it is the parent class that is calling the method
    from the derived classes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得设计更加灵活，因为保持多态性也容易实现。如果我们需要一种新的事件类型，由于某种原因需要以不同的方式解析数据，我们只需在那个子类中重写这个私有方法，并且兼容性将得到保持，只要它返回与原始类型相同的东西（符合Liskov替换原则和开闭原则）。这是因为父类正在调用派生类的方法。
- en: This pattern is also useful if we are designing our own library or framework.
    By arranging the logic this way, we give users the ability to change the behavior
    of one of the classes quite easily. They would have to create a subclass and override
    the particular private method, and the result will be a new object with the new
    behavior that is guaranteed to be compatible with previous callers of the original
    object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在设计自己的库或框架，这种模式同样很有用。通过这种方式安排逻辑，我们使用户能够非常容易地改变其中一个类的行为。他们需要创建一个子类并重写特定的私有方法，结果将是一个具有新行为的新对象，这个新行为将保证与原始对象的先前调用者兼容。
- en: Command
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令
- en: 'The command pattern provides us with the ability to separate an action that
    needs to be done from the moment that it is requested to its actual execution.
    More than that, it can also separate the original request issued by a client from
    its recipient, which might be a different object. In this section, we are going
    to focus mainly on the first aspect of the patterns: the fact that we can separate
    how an order has to be run from when it actually executes.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式为我们提供了将需要执行的操作与其请求时刻的实际执行时刻分离的能力。不仅如此，它还可以将客户端发出的原始请求与其接收者分离，接收者可能是一个不同的对象。在本节中，我们将主要关注模式的第一个方面：我们可以将命令的执行方式与其实际执行时刻分离的事实。
- en: We know we can create callable objects by implementing the `__call__()` magic
    method, so we could just initialize the object and then call it later on. In fact,
    if this is the only requirement, we might even achieve this through a nested function
    that, by means of a closure, creates another function to achieve the effect of
    delayed execution. But this pattern can be extended to ends that aren't so easily
    achievable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道可以通过实现`__call__()`魔法方法来创建可调用的对象，所以我们只需初始化对象，然后稍后调用它。实际上，如果这是唯一的要求，我们甚至可以通过一个嵌套函数来实现这一点，该函数通过闭包创建另一个函数，以达到延迟执行的效果。但这个模式可以被扩展到更难以实现的目的。
- en: The idea is that the command might also be modified after its definition. This
    means that the client specifies a command to run, and then some of its parameters
    might be changed, more options added, and so on, until someone finally decides
    to perform the action.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是命令也可能在其定义之后被修改。这意味着客户端指定要运行的命令，然后其中的一些参数可能会被更改，添加更多选项，等等，直到有人最终决定执行动作。
- en: Examples of this can be found in libraries that interact with databases. For
    instance, in `psycopg2` (a `PostgreSQL` client library), we establish a connection.
    From this, we get a cursor, and to that cursor, we can pass a `SQL` statement
    to run. When we call the `execute` method, the internal representation of the
    object changes, but nothing is actually run in the database. It is when we call
    `fetchall()` (or a similar method) that the data is actually queried and is available
    in the cursor.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种例子可以在与数据库交互的库中找到。例如，在`psycopg2`（一个`PostgreSQL`客户端库）中，我们建立了一个连接。从这一点，我们得到一个游标，并且可以向这个游标传递一个`SQL`语句来执行。当我们调用`execute`方法时，对象的内部表示会发生变化，但实际上在数据库中并没有执行任何操作。只有在调用`fetchall()`（或类似的方法）时，数据才会被查询并可在游标中获取。
- en: The same happens in the popular **Object Relational Mapper SQLAlchemy** (**ORM
    SQLAlchemy**). A query is defined through several steps, and once we have the
    `query` object, we can still interact with it (add or remove filters, change the
    conditions, apply for an order, and so on), until we decide we want the results
    of the query. After calling each method, the `query` object changes its internal
    properties and returns `self` (itself).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在流行的**对象关系映射器 SQLAlchemy**（**ORM SQLAlchemy**）中，同样会发生这种情况。查询是通过几个步骤定义的，一旦我们有了`query`对象，我们仍然可以与之交互（添加或删除过滤器、更改条件、申请排序等），直到我们决定需要查询的结果。在调用每个方法后，`query`对象会改变其内部属性并返回`self`（自身）。
- en: These are examples that resemble the behavior that we would like to achieve.
    A very simple way of creating this structure would be to have an object that stores
    the parameters of the commands that are to be run. After that, it has to also
    provide methods for interacting with those parameters (adding or removing filters,
    and so on). Optionally, we can add tracing or logging capabilities to that object
    to audit the operations that have been taking place. Finally, we need to provide
    a method that will actually perform the action. This one can be just `__call__()`
    or a custom one. Let's call it `do()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们想要实现的行为的类似例子。创建这种结构的一个非常简单的方法是拥有一个对象，该对象存储要运行的命令的参数。之后，它还必须提供与这些参数交互的方法（添加或删除过滤器等）。可选地，我们可以向该对象添加跟踪或日志功能以审计正在进行的操作。最后，我们需要提供一个实际执行动作的方法。这个方法可以是`__call__()`或自定义的。让我们称它为`do()`。
- en: This pattern can be useful when we're dealing with asynchronous programming.
    As we have seen, asynchronous programming has syntax nuances. By separating the
    preparation of a command from its execution, we can make the former still have
    the synchronous form, and the latter the asynchronous syntax (assuming this is
    the part that needs to run asynchronously, if, for example, we're using a library
    to connect to a database).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理异步编程时，这个模式可能很有用。正如我们所看到的，异步编程有语法上的细微差别。通过将命令的准备与执行分离，我们可以使前者仍然具有同步形式，而后者具有异步语法（假设这部分需要异步运行，例如，如果我们正在使用库连接到数据库）。
- en: State
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态
- en: The state pattern is a clear example of reification in software design, making
    the concept of our domain problem an explicit object rather than just a side value
    (for example, using strings or integer flags to represent values or managing state).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式是软件设计中具体化的一个明显例子，它将我们的领域问题的概念明确化为一个对象，而不是仅仅是一个辅助值（例如，使用字符串或整数标志来表示值或管理状态）。
- en: In *Chapter 8*, *Unit Testing and Refactoring*, we had an object that represented
    a `merge` request, and it had a state associated with it (`open`, `closed`, and
    so on). We used an enumeration to represent those states because, at that point,
    they were just data holding a value (the string representation of that particular
    state). If they had to have some behavior, or the entire `merge` request had to
    perform some actions depending on its state and transitions, this would not have
    been enough.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章*，*单元测试和重构*中，我们有一个表示`merge`请求的对象，并且它有一个与之关联的状态（例如`open`、`closed`等）。我们使用枚举来表示这些状态，因为那时它们只是持有值的（特定状态的字符串表示）数据。如果它们需要具有某些行为，或者整个`merge`请求必须根据其状态和转换执行某些操作，这就不够了。
- en: The fact that we are adding behavior, a runtime structure, to a part of the
    code has to make us think in terms of objects, because that's what objects are
    supposed to do, after all. And here comes the reification—now the state cannot
    just simply be an enumeration with a string; it needs to be an object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向代码的一部分添加行为、运行时结构的事实，迫使我们从对象的角度思考，因为毕竟这就是对象应该做的事情。现在，状态不能仅仅是一个带有字符串的枚举；它需要是一个对象。
- en: Imagine that we have to add some rules to the `merge` request, say that when
    it moves from `open` to `closed`, all approvals are removed (they will have to
    review the code again)—and that when a `merge` request is just opened, the number
    of approvals is set to zero (regardless of whether it's a reopened or brand-new
    `merge` request). Another rule could be that when a `merge` request is merged,
    we want to delete the source branch, and of course, we want to forbid users from
    performing invalid transitions (for example, a closed merge request cannot be
    merged, and so on).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须向`merge`请求添加一些规则，比如当它从`open`转换为`closed`时，所有批准都会被移除（他们将不得不再次审查代码）——并且当`merge`请求刚刚打开时，批准的数量设置为零（无论它是重新打开的还是全新的`merge`请求）。另一个规则可能是，当`merge`请求合并时，我们希望删除源分支，当然，我们希望禁止用户执行无效的转换（例如，已关闭的`merge`请求不能合并，等等）。
- en: If we put all that logic into a single place, namely in the `MergeRequest` class,
    we will end up with a class that has lots of responsibilities (a sign of a poor
    design), probably many methods, and a very large number of `if` statements. It
    would be hard to follow the code and to understand which part is supposed to represent
    which business rule.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有这些逻辑放入一个地方，即在`MergeRequest`类中，我们最终会得到一个具有许多职责（这是设计不良的迹象）的类，可能有很多方法，以及大量的`if`语句。这将很难跟踪代码并理解哪一部分应该代表哪个业务规则。
- en: It's better to distribute this into smaller objects, each one with fewer responsibilities,
    and the state objects are a good place for this. We create an object for each
    kind of state we want to represent, and, in their methods, we place the logic
    for the transitions with the aforementioned rules. The `MergeRequest` object will
    then have a state collaborator, and this, in turn, will also know about `MergeRequest`
    (the double-dispatching mechanism is needed to run the appropriate actions on
    `MergeRequest` and handle the transitions).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将其分布到更小的对象中会更好，每个对象都有更少的职责，状态对象是这种分布的好地方。我们为每种我们想要表示的状态创建一个对象，并在它们的方法中放置上述规则的转换逻辑。然后`MergeRequest`对象将有一个状态协作者，这反过来也将了解`MergeRequest`（需要双重分发机制来在`MergeRequest`上运行适当的操作并处理转换）。
- en: 'We define a base abstract class with the set of methods to be implemented,
    and then a subclass for each particular `state` we want to represent. Then the
    `MergeRequest` object delegates all the actions to `state`, as shown in the following
    code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个包含要实现的方法的基抽象类，然后为每个我们想要表示的特定`state`创建一个子类。然后`MergeRequest`对象将所有操作委托给`state`，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following list outlines some clarifications about implementation details
    and the design decisions that should be made:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表概述了一些关于实现细节和应做出的设计决策的澄清：
- en: The `state` is a property, so not only is it `public`, but there is also a single
    place with the definitions of how states are created for a merge request, passing
    `self` as a parameter.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`是一个属性，因此它不仅是`public`的，而且还有一个单独的地方定义了如何为`merge`请求创建状态，传递`self`作为参数。'
- en: 'The abstract base class is not strictly needed, but there are benefits to having
    it. First, it makes the kind of object we are dealing with more explicit. Second,
    it forces every substate to implement all the methods of the interface. There
    are two alternatives to this:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类不是必需的，但拥有它有一些好处。首先，它使我们所处理的对象类型更加明确。其次，它强制每个子状态实现接口的所有方法。有另外两种选择：
- en: We could have not written the methods and let `AttributeError` raise when trying
    to perform an invalid action, but this is not correct, and it doesn't express
    what happened.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以不编写这些方法，当尝试执行无效操作时让`AttributeError`抛出，但这并不正确，并且它没有表达出实际发生的情况。
- en: Related to this point is the fact that we could have just used a simple base
    class and left those methods empty, but then the default behavior of not doing
    anything doesn't make it any clearer what should happen. If one of the methods
    in the subclass should do nothing (as in the case of merge), then it's better
    to let the empty method just sit there and make it explicit that for that particular
    case, nothing should be done, as opposed to forcing that logic to all objects.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与这一点相关的是，我们本可以使用一个简单的基类并留那些方法为空，但这样默认的不执行任何操作的行为并没有使它更清楚应该发生什么。如果子类中的某个方法应该不执行任何操作（例如合并的情况），那么最好让空方法就那样放着，并明确指出对于那个特定的情况，不应该执行任何操作，而不是强迫所有对象执行那个逻辑。
- en: '`MergeRequest` and `MergeRequestState` have links to each other. The moment
    a transition is made, the former object will not have extra references and should
    be garbage-collected, so this relationship should be always 1:1\. With some small
    and more detailed considerations, a weak reference might be used.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MergeRequest`和`MergeRequestState`之间存在关联。一旦发生转换，前一个对象将不会有额外的引用并且应该被垃圾回收，因此这种关系应该是始终为1:1。经过一些小的和更详细的考虑，可以使用弱引用。'
- en: 'The following code shows some examples of how the object is used:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用对象的示例：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The actions for transitioning states are delegated to the `state` object, which
    `MergeRequest` holds at all times (this can be any of the subclasses of `ABC`).
    They all know how to respond to the same messages (in different ways), so these
    objects will take the appropriate actions corresponding to each transition (deleting
    branches, raising exceptions, and so on), and will then move `MergeRequest` to
    the next state.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 转换状态的操作委托给`state`对象，这是`MergeRequest`始终持有的（这可以是`ABC`的任何子类）。它们都知道如何以不同的方式响应相同的消息，因此这些对象将采取与每个转换相对应的适当行动（删除分支、引发异常等），然后移动`MergeRequest`到下一个状态。
- en: Since `MergeRequest` delegates all actions to its `state` object, we will find
    that this typically happens every time the actions that it needs to do are in
    the form `self.state.open()`, and so on. Can we remove some of that boilerplate?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`MergeRequest`将所有操作委托给其`state`对象，我们会发现这通常发生在它需要执行的操作形式为`self.state.open()`等情况下。我们能移除一些那些样板代码吗？
- en: 'We could, by means of `__getattr__()`, as it is portrayed in the following
    code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`__getattr__()`来实现，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Be careful with implementing these types of generic redirections in the code,
    because it might harm readability. Sometimes, it's better to have some small boilerplate,
    but be explicit about what our code does.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中实现这些类型的通用重定向时要小心，因为这可能会损害可读性。有时，有一些小的样板代码，但明确说明我们的代码做什么会更好。
- en: On the one hand, it is good that we reuse some code and remove repetitive lines.
    This gives the abstract base class even more sense. Somewhere, we want to have
    all possible actions documented, listed in a single place. That place used to
    be the `MergeRequest` class, but now those methods are gone, so the only remaining
    source of that truth is in `MergeRequestState`. Luckily, the type annotation on
    the `state` attribute is really helpful for users to know where to look for the
    interface definition.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们重用了一些代码并去除了重复的行，这是好事。这使抽象基类更有意义。在某个地方，我们希望记录所有可能的行为，并列在单一位置。那个地方曾经是`MergeRequest`类，但现在那些方法已经消失了，所以唯一剩下的真理来源是`MergeRequestState`。幸运的是，`state`属性的类型注解对用户来说非常有帮助，知道在哪里查找接口定义。
- en: A user can simply take a look and see that everything that `MergeRequest` doesn't
    have will be asked of its `state` attribute. From the `init` definition, the annotation
    will tell us that this is an object of the `MergeRequestState` type, and by looking
    at this interface, we will see that we can safely ask for the `open()`, `close()`,
    and `merge()` methods on it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以简单地看一下，就会看到`MergeRequest`没有的任何东西都会询问其`state`属性。从`init`定义中，注解会告诉我们这是一个`MergeRequestState`类型的对象，通过查看这个接口，我们会看到我们可以安全地调用其上的`open()`、`close()`和`merge()`方法。
- en: The null object pattern
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空对象模式
- en: The null object pattern is an idea that relates to the good practices that were
    mentioned in previous chapters of this book. Here, we are formalizing them, and
    giving more context and analysis to this idea.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 空对象模式是一个与本书前几章提到的良好实践相关联的想法。在这里，我们对其进行了正式化，并为此想法提供了更多的背景分析和解释。
- en: The principle is rather simple—functions or methods must return objects of a
    consistent type. If this is guaranteed, then clients of our code can use the objects
    that are returned with polymorphism, without having to run extra checks on them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 原则相当简单——函数或方法必须返回一致类型的对象。如果这一点得到保证，那么我们代码的客户就可以使用返回的对象，并以多态的方式使用它们，而无需对它们进行额外的检查。
- en: In the previous examples, we explored how the dynamic nature of Python made
    things easier for most design patterns. In some cases, they disappear entirely,
    and in others, they are much easier to implement. The main goal of design patterns
    as they were originally thought of is that methods or functions should not explicitly
    name the class of the object that they need in order to work. For this reason,
    they propose the creation of interfaces and a way of rearranging the objects to
    make them fit these interfaces in order to modify the design. But most of the
    time, this is not needed in Python, and we can just pass different objects, and
    as long as they respect the methods they must have, then the solution will work.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们探讨了Python的动态特性如何使大多数设计模式变得更加容易。在某些情况下，它们完全消失，在其他情况下，它们更容易实现。设计模式的主要目标，正如最初所设想的那样，是方法或函数不应明确命名它们需要以工作的对象类。因此，它们提出了创建接口和重新排列对象的方法，以便使它们符合这些接口，从而修改设计。但在Python中，大多数时候这并不是必需的，我们只需传递不同的对象，只要它们尊重必须有的方法，解决方案就会有效。
- en: On the other hand, the fact that objects don't necessarily have to comply with
    an interface requires us to be more careful as to the things that are returning
    from such methods and functions. In the same way that our functions didn't make
    any assumptions about what they were receiving, it's fair to assume that clients
    of our code will not make any assumptions either (it is our responsibility to
    provide objects that are compatible). This can be enforced or validated with design
    by contract. Here, we will explore a simple pattern that will help us avoid these
    kinds of problems.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对象不一定必须遵守接口的事实要求我们更加小心地对待从这些方法和函数返回的事物。就像我们的函数没有对其接收的内容做出任何假设一样，我们有理由假设我们的代码的客户也不会做出任何假设（这是我们的责任，提供兼容的对象）。这可以通过契约设计来强制或验证。在这里，我们将探讨一个简单的模式，这将帮助我们避免这类问题。
- en: Consider the chain of responsibility design pattern explored in the previous
    section. We saw how flexible it is and its many advantages, such as decoupling
    responsibilities into smaller objects. One of the problems it has is that we never
    actually know what object will end up processing the message, if any. In particular,
    in our example, if there was no suitable object to process the log line, then
    the method would simply return `None`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在前一节中探讨的责任链设计模式。我们看到了它的灵活性及其许多优点，例如将责任分解为更小的对象。它存在的问题之一是我们实际上永远不知道哪个对象最终会处理消息，如果有的话。特别是，在我们的例子中，如果没有合适的对象来处理日志行，那么该方法将简单地返回`None`。
- en: 'We don''t know how users will use the data we passed, but we do know that they
    are expecting a dictionary. Therefore, the following error might occur:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道用户会如何使用我们传递的数据，但我们确实知道他们期望的是一个字典。因此，可能会发生以下错误：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, the fix is rather simple—the default value of the `process()`
    method should be an empty dictionary rather than `None`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，修复方法相当简单——`process()`方法的默认值应该是一个空字典而不是`None`。
- en: Ensure that you return objects of a consistent type.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你返回的是一致类型的对象。
- en: But what if the method didn't return a dictionary, but a custom object of our
    domain?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果该方法没有返回字典，而是返回了我们领域中的自定义对象呢？
- en: 'To solve this problem, we should have a class that represents the empty state
    for that object and return it. If we have a class that represents users in our
    system, and a function that queries users by their `ID`, then in the case that
    a user is not found, it should do one of the following two things:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们应该有一个表示该对象空状态的类，并返回它。如果我们有一个表示系统中用户的类，以及一个通过`ID`查询用户的函数，那么在找不到用户的情况下，它应该做以下两件事之一：
- en: Raise an exception
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Return an object of the `UserUnknown` type
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`UserUnknown`类型的对象
- en: But in no case should it return `None`. The phrase `None` doesn't represent
    what just happened, and the caller might legitimately try to ask methods to it,
    and it will fail with `AttributeError`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但在任何情况下都不应该返回`None`。`None`这个短语并不代表刚刚发生的事情，调用者可能会合法地尝试调用它的方法，这将导致`AttributeError`。
- en: We have discussed exceptions and their pros and cons earlier on, so we should
    mention that this `null` object should just have the same methods as the original
    user and do nothing for each one of them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过异常及其优缺点，因此我们应该提到，这个`null`对象应该只拥有与原始用户相同的方法，并且对每一个方法都不做任何事情。
- en: The advantage of using this structure is that not only are *we* avoiding an
    error at runtime but also that this object might be useful. It could make the
    code easier to test, and it can even, for instance, help in debugging (maybe we
    could put logging into the methods to understand why that state was reached, what
    data was provided to it, and so on).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构的优点是，我们不仅避免了运行时错误，而且这个对象可能是有用的。它可以使代码更容易测试，甚至可以，例如，帮助调试（我们可能需要在方法中添加日志记录，以了解为什么达到那种状态，提供了哪些数据，等等）。
- en: 'By exploiting almost all of the magic methods of Python, it would be possible
    to create a generic `null` object that does absolutely nothing, no matter how
    it is called, but that can be called from almost any client. Such an object would
    slightly resemble a `Mock` object. It is not advisable to go down that path because
    of the following reasons:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用Python几乎所有的魔法方法，我们可以创建一个通用的`null`对象，它绝对什么也不做，无论怎样调用它，但可以从几乎任何客户端调用。这样的对象会稍微类似于一个`Mock`对象。由于以下原因，不建议走这条路：
- en: It loses meaning with the domain problem. Back in our example, having an object
    of the `UnknownUser` type makes sense, and gives the caller a clear idea that
    something went wrong with the query.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与领域问题失去了意义。回到我们的例子中，有一个`UnknownUser`类型的对象是有意义的，并且给调用者一个清晰的印象，即查询出了问题。
- en: It doesn't respect the original interface. This is problematic. Remember that
    the point is that an `UnknownUser` is a user, and therefore it must have the same
    methods. If the caller accidentally asks for a method that is not there, then,
    in that case, it should raise an `AttributeError` exception, and that would be
    good. With the generic `null` object that can do anything and respond to anything,
    we would be losing this information, and bugs might creep in. If we opt for creating
    a `Mock` object with `spec=User`, then this anomaly would be caught, but again,
    using a `Mock` object to represent what is actually an empty state doesn't match
    our intention of providing clear, understandable code.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不尊重原始接口。这是问题所在。记住，目标是`UnknownUser`是一个用户，因此它必须具有相同的方法。如果调用者意外地请求一个不存在的方法，那么在这种情况下，它应该抛出一个`AttributeError`异常，这将很好。如果我们选择创建一个具有`spec=User`的`Mock`对象，那么这种异常就会被捕获，但再次强调，使用`Mock`对象来表示实际上是一个空状态，这与我们提供清晰、易懂代码的意图不符。
- en: This pattern is a good practice that allows us to maintain polymorphism in our
    objects.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是一种良好的实践，它允许我们在对象中保持多态性。
- en: Final thoughts about design patterns
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于设计模式的最后思考
- en: We have seen the world of design patterns in Python, and in doing so, we have
    found solutions to common problems, as well as more techniques that will help
    us achieve a clean design.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Python中的设计模式世界，在这个过程中，我们找到了解决常见问题的方法，以及更多有助于我们实现清晰设计的技巧。
- en: 'All of this sounds good, but it begs the question: how good are design patterns?
    Some people argue that they do more harm than good, that they were created for
    languages whose limited type system (and lack of first-class functions) makes
    it impossible to accomplish things we would normally do in Python. Others claim
    that design patterns force a design solution, creating some bias that limits a
    design that would have otherwise emerged, and that would have been better. Let''s
    look at each of these points in turn.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都听起来很好，但它提出了一个问题：设计模式有多好？有些人认为它们弊大于利，认为它们是为那些有限类型系统（以及缺乏一等函数）的语言而创建的，这使得我们无法完成在Python中通常能做的事情。另一些人声称，设计模式强迫采用一种设计方案，从而产生一些偏见，限制了本应出现的、更好的设计方案。让我们逐一审视这些观点。
- en: The influence of patterns over the design
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式对设计的影响
- en: A design pattern cannot be good or bad by itself, but rather by how it's implemented,
    or used. In some cases, there is no need for a design pattern when a simpler solution
    would do. Trying to force a pattern where it doesn't fit is a case of over-engineering,
    and that's clearly bad, but it doesn't mean that there is a problem with the design
    pattern, and most likely in these scenarios, the problem is not even related to
    patterns at all. Some people try to over-engineer everything because they don't
    understand what flexible and adaptable software really means.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计模式本身不能说是好是坏，而是取决于它的实现方式或使用方式。在某些情况下，当有更简单的解决方案时，并不需要设计模式。试图将模式强加在不适合的地方，就是过度设计，这显然是错误的，但这并不意味着设计模式本身有问题，而且在这些场景中，问题甚至可能根本与模式无关。有些人试图过度设计一切，因为他们不理解灵活和适应性软件的真正含义。
- en: As we mentioned before in this book, making good software is not about anticipating
    future requirements (there is no point in doing futurology), but just solving
    the problem that we have at hand right now, in a way that doesn't prevent us from
    making changes to it in the future. It doesn't have to handle those changes now;
    it just needs to be flexible enough so that it can be modified in the future.
    And when that future comes, we will still have to remember the rule of three or
    more instances of the same problem before coming up with a generic solution or
    a proper abstraction.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书前面提到的，编写好软件不是关于预测未来需求（进行未来学是没有意义的），而是仅仅解决我们现在手头的问题，以一种不会阻止我们在未来对其进行更改的方式。它现在不需要处理这些变化；它只需要足够灵活，以便将来可以进行修改。当未来来临时，我们仍然需要记住在提出通用解决方案或适当的抽象之前，必须记住三个或更多相同问题的规则。
- en: This is typically the point where the design patterns should emerge, once we
    have identified the problem correctly and can recognize the pattern and abstract
    accordingly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是设计模式应该出现的地方，一旦我们正确地识别了问题，能够识别模式并相应地进行抽象。
- en: Let's come back to the topic of the suitability of the patterns to the language.
    As we said in the introduction of the chapter, design patterns are high-level
    ideas. They typically refer to the relation of objects and their interactions.
    It's hard to think that such things might disappear from one language to another.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到模式对语言的适用性这个话题。正如我们在本章引言中所说，设计模式是高级思想。它们通常指的是对象及其交互的关系。很难想象这些事情可能会从一个语言消失到另一个语言。
- en: It's true that some patterns would require less work in Python, as is the case
    of the iterator pattern (which, as it was heavily discussed earlier in the book,
    is built in Python), or a strategy (because, instead, we would just pass functions
    like any other regular object; we don't need to encapsulate the strategy method
    into an object, as the function itself would be that object).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，有些模式在Python中可能需要更少的工作，比如迭代器模式（正如在本书前面详细讨论的那样，它是Python内置的），或者策略模式（因为，相反，我们只需像传递任何其他常规对象一样传递函数；我们不需要将策略方法封装到对象中，因为函数本身就是这个对象）。
- en: But other patterns are actually needed, and they indeed solve problems, as in
    the case of the decorator and composite patterns. In other cases, there are design
    patterns that Python itself implements, and we just don't always see them, as
    in the case of the facade pattern that we discussed earlier in the chapter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但其他模式实际上是需要的，并且它们确实解决了问题，就像装饰器和组合模式的情况一样。在其他情况下，Python本身实现了某些设计模式，我们只是没有总是看到它们，就像我们在本章前面讨论的外观模式一样。
- en: As to our design patterns leading our solution in the wrong direction, we have
    to be careful here. Once again, it's better if we start designing our solution
    by thinking in terms of the domain problem and creating the right abstractions,
    and then later see whether there is a design pattern that emerges from that design.
    Let's say that it does. Is that a bad thing? The fact that there is already a
    solution to the problem we're trying to solve cannot be a bad thing. It would
    be bad to reinvent the wheel, as happens many times in our field. Moreover, the
    fact that we are applying a pattern, something already proven and validated, should
    give us greater confidence in the quality of what we are building.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们的设计模式可能将我们的解决方案引向错误的方向，我们必须在这里小心。再一次，如果我们从考虑领域问题并创建正确的抽象开始设计我们的解决方案，然后看看是否有一个设计模式从那个设计中浮现出来，那就更好了。假设它确实如此。这是坏事吗？我们试图解决的问题已经有了现成的解决方案，这并不是坏事。在我们这个领域，重新发明轮子的情况很多，这是坏事。此外，我们正在应用一个模式，一个已经被证明和验证过的模式，这应该让我们对我们所构建的质量更有信心。
- en: Design patterns as theory
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计模式作为理论
- en: One interesting way I see design patterns is as software engineering theory.
    While I agree with the idea that the more naturally the code evolves, the better,
    that doesn't mean we should ignore design patterns completely.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为设计模式是一种软件工程理论。虽然我同意代码越自然地演变越好这个观点，但这并不意味着我们应该完全忽视设计模式。
- en: 'Design patterns exist because there''s no point in reinventing the wheel. If
    there''s a solution that has already been devised for a particular kind of problem,
    it will save us some time to ponder that idea as we plan our design. In this sense
    (and to re-invoke an analogy from the first chapter), I like to think about design
    patterns as analogous to chess openings: professional chess players don''t think
    about every combination in the early stages of a game. That''s the theory. It''s
    already been studied. It''s the same as with a math or physics formula. You should
    understand it deeply the first time, know how to infer it, and incorporate its
    meaning, but after that, there''s no need to develop that theory over and over
    again.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式之所以存在，是因为没有必要重新发明轮子。如果已经有一个针对特定类型问题的解决方案，那么在我们规划设计时思考这个想法可以节省我们一些时间。从这个意义上讲（以及为了重新引用第一章中的类比），我喜欢将设计模式类比为棋局的开局：职业棋手在游戏的早期阶段不会考虑每一个组合。这是理论。它已经被研究了。这与数学或物理公式是一样的。你应该第一次就深入理解它，知道如何推断它，并吸收其含义，但之后就没有必要反复发展这个理论了。
- en: As practitioners of software engineering, we should use the theory of design
    patterns to save mental energy and come up with solutions faster. More than that,
    design patterns should become not only language but building blocks as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件工程的从业者，我们应该利用设计模式的理论来节省脑力并更快地提出解决方案。不仅如此，设计模式应该成为不仅是语言，也是构建模块。
- en: Names in our models
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型中的名称
- en: Should we mention that we are using a design pattern in our code?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该在代码中提及我们正在使用设计模式？
- en: 'If the design is good and the code is clean, it should speak for itself. It
    is not recommended that you name things after the design patterns you are using
    for a couple of reasons:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设计良好且代码整洁，它应该能够自我表达。出于以下几个原因，不建议你根据你正在使用的设计模式来命名：
- en: Users of our code and other developers don't need to know the design pattern
    behind the code, as long as it works as intended.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们代码的使用者和其他开发者不需要了解代码背后的设计模式，只要它能按预期工作即可。
- en: Stating the design pattern ruins the intention revealing principle. Adding the
    name of the design pattern to a class makes it lose part of its original meaning.
    If a class represents a query, it should be named `Query` or `EnhancedQuery`,
    something that reveals the intention of what that object is supposed to do. `EnhancedQueryDecorator`
    doesn't mean anything meaningful, and the `Decorator` suffix creates more confusion
    than clarity.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈述设计模式破坏了意图揭示原则。将设计模式的名称添加到类中会使它失去部分原始含义。如果一个类代表一个查询，它应该被命名为`Query`或`EnhancedQuery`，这应该揭示该对象预期要做什么。`EnhancedQueryDecorator`没有任何意义，而`Decorator`后缀比清晰度更造成混淆。
- en: Mentioning the design patterns in docstrings might be acceptable because they
    work as documentation, and expressing the design ideas (again, communicating)
    in our design is a good thing. However, this should not be needed. Most of the
    time, though, we do not need to know that a design pattern is there.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串中提及设计模式可能是可以接受的，因为它们充当文档，在我们的设计中表达设计思想（再次，沟通）是好事。然而，这并不是必需的。尽管如此，大多数时候，我们并不需要知道设计模式的存在。
- en: The best designs are those in which design patterns are completely transparent
    to the users. An example of this is how the facade pattern appears in the standard
    library, making it completely transparent to users as to how to access the `os`
    module. An even more elegant example is how the iterator design pattern is so
    completely abstracted by the language that we don't even have to think about it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的设计是那些设计模式对用户完全透明的。一个例子是外观模式在标准库中的出现，它使得用户对如何访问`os`模块的方式完全透明。一个更加优雅的例子是迭代器设计模式被语言完全抽象化，以至于我们甚至不需要考虑它。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Design patterns have always been seen as proven solutions to common problems.
    This is a correct assessment, but in this chapter, we explored them from the point
    of view of good design techniques, patterns that leverage clean code. In most
    of the cases, we looked at how they provide a good solution to preserve polymorphism,
    reduce coupling, and create the right abstractions that encapsulate details as
    needed—all traits that relate to the concepts explored in *Chapter 8*, *Unit Testing
    and Refactoring*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式一直被视为解决常见问题的有效方案。这是一个正确的评估，但在这章中，我们从良好的设计技术角度探讨了它们，这些模式利用了整洁的代码。在大多数情况下，我们研究了它们如何提供良好的解决方案来保持多态性、减少耦合，并创建所需的正确抽象来封装细节——所有这些都与第8章中探讨的概念相关，即单元测试和重构。
- en: Still, the best thing about design patterns is not the clean design we can obtain
    from applying them, but the extended vocabulary. Used as a communication tool,
    we can use their names to express the intention of our design. And sometimes,
    it's not the entire pattern that we need to apply, but we might need to take a
    particular idea (a substructure, for example) of a pattern from our solution,
    and here, too, they prove to be a way of communicating more effectively.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，设计模式最吸引人的地方并不是应用它们所能获得的整洁设计，而是扩展的词汇量。作为沟通工具，我们可以用它们的名称来表达我们设计的意图。有时，我们并不需要应用整个模式，而可能只需要从我们的解决方案中提取模式的一个特定想法（例如，一个子结构），在这里，它们也证明是更有效地沟通的一种方式。
- en: When we create solutions by thinking in terms of patterns, we are solving problems
    at a more general level. Thinking in terms of design patterns brings us closer
    to higher-level design. We can slowly "zoom-out" and think more in terms of architecture.
    And now that we are solving more general problems, it's time to start thinking
    about how the system is going to evolve and be maintained in the long run (how
    it's going to scale, change, adapt, and so on).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以模式为思考方式来创建解决方案时，我们是在更高层次上解决问题。以设计模式为思考方式使我们更接近高级设计。我们可以逐渐“缩小”视野，更多地从架构的角度思考。既然我们现在正在解决更普遍的问题，那么是时候开始思考系统将如何长期演变和维护了（如何扩展、变化、适应等等）。
- en: For a software project to be successful in these goals, it requires clean code
    at its core, but the architecture also has to be clean as well, which is what
    we are going to look at in the next chapter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，一个软件项目需要在核心上拥有整洁的代码，同时架构也必须是整洁的，这就是我们将在下一章中探讨的内容。
- en: References
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Here is a list of information you can refer to:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份您可以参考的信息列表：
- en: '*GoF*: The book written by *Erich Gamma*, *Richard Helm*, *Ralph Johnson*,
    and *John Vlissides* named *Design Patterns: Elements of Reusable Object-Oriented
    Software*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GoF*：由*艾里希·伽玛*、*理查德·赫尔姆*、*拉尔夫·约翰逊*和*约翰·弗利西斯*合著的《设计模式：可复用面向对象软件元素》一书'
- en: '*SNGMONO*: An article written by *Robert C. Martin*, 2002, named *SINGLETON
    and MONOSTATE*: [http://staff.cs.utu.fi/~jounsmed/doos_06/material/SingletonAndMonostate.pdf](http://staff.cs.utu.fi/~jounsmed/doos_06/material/SingletonAndMonostate.pdf)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SNGMONO*：由*罗伯特·C·马丁*于2002年撰写的一篇文章，名为*单例和单态*：[http://staff.cs.utu.fi/~jounsmed/doos_06/material/SingletonAndMonostate.pdf](http://staff.cs.utu.fi/~jounsmed/doos_06/material/SingletonAndMonostate.pdf)'
- en: '*The Null Object Pattern*, written by *Bobby Woolf*'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*空对象模式*，由*博比·伍尔夫*撰写'
