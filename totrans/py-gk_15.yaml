- en: '*Chapter 11*: Using Python for Microservices Development'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monolithic applications that are built as a single-tiered software have been
    a popular option for developing applications for many years. However, it is not
    efficient to deploy monolithic applications in cloud platforms in terms of reserving
    and utilizing resources. This is even true for the deployment of large-scale monolithic
    applications on physical machines. The maintenance and development costs of such
    applications are always high. Multi-tier applications have solved this problem
    to some extent for web applications by breaking the applications down into several
    tiers.
  prefs: []
  type: TYPE_NORMAL
- en: To meet dynamic resource demands and to reduce development/maintenance costs,
    the real savior is a **microservices architecture**. This new architecture encourages
    applications to be built on loosely coupled services and deployed on dynamically
    scalable platforms such as containers. Organizations such as Amazon, Netflix,
    and Facebook have already moved from a monolithic model to microservices-based
    architecture. Without this change, these organizations couldn't have served a
    large number of clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning best practices for microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building microservices-based applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you will learn about microservices and will be
    able to build applications based on microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to have Python 3.7 or later installed on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Flask library with RESTful extensions installed on top of a Python 3.7
    or later release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Django with Django Rest Framework library on top of a Python 3.7 or later
    release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to have a Docker registry account and installed Docker Engine and Docker
    Compose on your machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To deploy a microservice in GCP Cloud Run, you will need a GCP account (a free
    trial will work fine).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter11](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: We will start our discussion with the introduction of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A microservice is an independent software entity that must have the following
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loosely coupled** with other services and without any dependency on other
    software components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to develop** and **maintain** by a small team without depending on other
    teams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independently installable** as a separate entity, preferably in a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offers **easy-to-consume** interfaces using synchronous protocols such as REST
    APIs, or asynchronous protocols such as **Kafka** or **RabbitMQ**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keywords in terms of software being called a microservice are independently
    deployable, loosely coupled, and easily maintainable. Each microservice can have
    its own database servers to avoid sharing resources with other microservices.
    This will ensure the elimination of dependencies between the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The microservices architecture style is a software development paradigm for
    developing applications using purely microservices. This architecture even includes
    the main interface entity of the application, such as a web application. An example
    of a microservices-based application is illustrated next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – A sample microservices architecture style application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – A sample microservices architecture style application
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example application, we have individual microservices such as **Authorization
    Service**, **Product Catalog Service**, and **Product Inventory Service**. We
    built a web application, also as a microservice, that uses the three individual
    microservices through the REST API. For mobile clients, a mobile app can be built
    using the same individual microservices through an API gateway. We can see an
    immediate advantage of microservices architecture, which is reusability. A few
    other advantages of using microservices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We are flexible when it comes to selecting any technology and any programming
    language that suits any individual microservice requirements. We can even reuse
    legacy code written in any language if we can expose it using an API interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can develop, test, and maintain individual microservices by small independent
    teams. It is crucial to have independent and autonomous small teams for the development
    of large-scale applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the challenges with monolithic applications is the managing of conflicting
    library versions, which we are forced to include because of different features
    bundled in a single application. With microservices, the chances of conflict as
    regards the versions of these libraries are minimized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can deploy and patch the individual microservices independently. This enables
    us to use **Continuous Integration/Continuous Delivery** (**CI/CD**) for complex
    applications. This is also important when we need to apply a patch or upgrade
    one feature of an application. For monolithic applications, we will redeploy the
    entire application, which means there are chances to break other parts of the
    application. With microservices, only one or two services will be redeployed without
    risks of breaking anything else in other microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can isolate faults and failures on a microservice level instead of the application
    level. If there is a fault or failure with one service, we can debug it, fix it,
    and patch it or stop it for maintenance without impacting the rest of the application's
    functionality. In the case of monolithic applications, a problem in one component
    can bring down the entire application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Despite several advantages, there are some disadvantages associated with using
    the microservices architecture style:'
  prefs: []
  type: TYPE_NORMAL
- en: First is the increased complexity of creating microservices-based applications.
    The complexity mainly arises from the fact that each microservice has to expose
    an API and the consumer service or program has to interact with microservices
    using an API. Security on a per microservice basis is another contributor to the
    complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second disadvantage is the increased resource requirements as compared to
    monolithic applications. Every microservice requires additional memory to be hosted
    independently in a container or a virtual machine, even if it is a **Java Virtual
    Machine** (**JVM**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third disadvantage is that additional efforts are required to debug and
    troubleshoot a problem across different microservices that may be deployed in
    separate containers or systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will study the best practice of building microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Learning best practices for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When starting a new application, the first and foremost question we should be
    asking ourselves is whether the microservices architecture is a good fit. This
    starts with an analysis of the application requirements and the ability to divide
    the requirements into separate and individual components. If you see that your
    components frequently depend on one another, this is an indicator that the segregation
    of components may require reworking, or that this application may not be a fit
    for the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to make this decision of whether to use microservices right
    in the early phase of an application. There is a school of thought that says that
    it is better to start building an application using monolithic architecture to
    avoid the additional costs of microservices in the beginning. However, this is
    not an advisable approach. Once we have built a monolithic application, it is
    difficult to transform it into microservices architecture, especially if the application
    is already in production. Companies such as Amazon and Netflix have done it, but
    they did it as part of their evolution of technology and certainly, they have
    the human and technology resources available to undertake this transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have made our decision to build our next application using microservices,
    the following best practices will guide you in making design and deployment decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Independent and loosely coupled**: These requirements are part of the microservices
    definition. Each microservice should be built independently from the other microservices
    and is built as loosely coupled as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain-Driven Design** (**DDD**): The purpose of microservices architecture
    is not to have as many small microservices as possible. We need to always remember
    that each microservice has its overhead costs. We should build as many microservices
    as the business or domain requires. We recommend considering DDD, which was introduced
    by *Eric Evans* in 2004\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we try to apply DDD to microservices, it suggests having a strategic design
    first to define different contexts by combining related business domains and their
    subdomains. The strategic design can be followed by a tactical design that focuses
    on breaking down the core domains into fine-grained building blocks and entities.
    This breakdown will provide clear guidelines to map the requirements to possible
    microservices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Communication interfaces**: We should use well-defined microservice interfaces,
    preferably a REST API or an event-driven API, for communication. Microservices
    should avoid calling each other directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use an API gateway**: Microservices and their consumer applications should
    interact with individual microservices using an API gateway. The API gateway can
    take care of security aspects, such as authentication and load balancing, out
    of the box. Moreover, with a new version of a microservice, we can use the API
    gateway to redirect the client requests to the newer version without impacting
    the client-side software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limit technology stack**: Although microservice architecture allows the use
    of any programming language and framework on a per-service basis, it is not advisable
    to develop microservices using different technologies in the absence of any business
    or reusability reasons. A diverse technology stack may be appealing for academic
    reasons, but it will bring operational complexity in maintaining and troubleshooting
    the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment model**: It is not mandatory to deploy a microservice in a container,
    but it is recommended. Containers bring a lot of built-in features, such as automated
    deployment, cross-platform support, and interoperability. Additionally, by using
    containers, we can assign the resources to the service as per its requirements
    and ensure a fair distribution of resources across different microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control**: We should be using a separate versioning control system
    for each microservice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team organization**: Microservices architecture provides an opportunity to
    have dedicated teams on a per-microservice basis. We should be keeping this principle
    in mind when organizing teams for a large-scale project. The size of a team should
    be based on the *two-pizza philosophy*, which states that we should set up a team
    with as many engineers who can be fed by two large pizzas. A team can own one
    or more microservices based on their complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralized logging/monitoring**: As discussed previously, troubleshooting
    problems in a microservice architecture-style application can be time-consuming,
    especially if the microservices are running in containers. We should be using
    open source or professional tools to monitor and troubleshoot the microservices
    to reduce such operational costs. A few examples of such tools are **Splunk**,
    **Grafana**, **Elk**, and **App Dynamics**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have covered the introduction as well as best practices of microservices,
    next, we will deep dive into learning to build an application using microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Building microservices-based applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going into the implementation details of microservices, it is important
    to analyze several microservice frameworks and deployment options. We will start
    with a microservices framework available in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Learning microservice development options in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, we have a plethora of frameworks and libraries available for microservice
    development. We cannot enumerate all the available options, but it is worth highlighting
    the most popular and those that have some different feature sets. These options
    are described next:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flask**: This is a lightweight framework that can be used to build **Web
    Service Gateway Interface** (**WSGI**)-based microservices. Note that WSGI is
    based on a request-response synchronous design pattern. We already used Flask
    and its RESTful extension to build a REST API application in [*Chapter 10*](B17189_10_Final_PG_ePub.xhtml#_idTextAnchor264),
    *Using Python for Web Development and REST API*. Since Flask is a popular web
    and API development framework, it is an easy adoption choice for many developers
    who are already using Flask.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Django**: Django is another popular web framework with a large community
    of developers. With its **Django Rest Framework** (**DRF**), we can build microservices
    with REST API interfaces. Django offers both WSGI and **Asynchronous Service Gateway
    Interface** (**ASGI**)-based microservices. ASGI is considered a successor to
    the WSGI interface. ASGI is an excellent option if you are interested in developing
    your application based on **Asyncio**, a topic we discussed in detail in [*Chapter
    7*](B17189_07_Final_PG_ePub.xhtml#_idTextAnchor207), *Multiprocessing, Multithreading,
    and Asynchronous Programming*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Falcon**: This is also a popular web framework after Flask and Django. It
    does not come with a built-in web server, but it is well optimized for microservices.
    Like Django, it supports both ASGI and WSGI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nameko**: This framework is specifically designed for microservice development
    in Python, and is not a web application framework. Nameko comes with built-in
    support for **Remote Procedure Call** (**RPC**), asynchronous events, and WebSocket-based
    RPCs. If your application requires any of these communication interfaces, you
    should consider Nameko.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bottle**: This is a super lightweight WSGI-based microservices framework.
    The whole framework is based on a single file and leverages only a Python standard
    library for its operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tornado**: It is based on non-blocking network I/O. Tornado can handle high
    traffic with extremely low overheads. This is also a suitable choice for long-polling
    and WebSocket-based connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the development of our sample microservices, we can use any of the frameworks
    mentioned earlier. But we will use Flask and Django for two reasons. First, these
    two are the most popular for developing web applications and microservices. Second,
    we will reuse an example API application that we developed in the previous chapter.
    A new microservice will be developed using Django and it will illustrate how to
    use Django for web and API development.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss microservice deployment options.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing deployment options for microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we write microservices, the next question is how to deploy them as an
    isolated and independent entity. For the sake of discussion, we will assume that
    microservices are built with HTTP/REST interfaces. We can deploy all microservices
    on the same web server as different web apps or host one web server for one microservice.
    One microservice in a separate web server can be deployed on a single machine
    (physical or virtual) or on separate machines or even on separate containers.
    We have summarized all these different deployment models in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Microservices deployment models'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Microservices deployment models
  prefs: []
  type: TYPE_NORMAL
- en: 'The four deployments models shown in *Figure 11.2* are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model A**: In this model, we are deploying four different microservices on
    the same web server. There is a good chance that the microservices in this case
    are sharing libraries, being on a single web server. This may result in library
    conflicts and is not a recommended model for deploying microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model B**: For this model, we deployed four microservices on a single machine,
    but using one microservice per web server to make them independent. This model
    is fine for development environments, but may not be suitable on a production
    scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model C**: This model is using four virtual machines to host four different
    microservices. Each machine host only one microservice with a web server. This
    model is suitable for production if it is not possible to use containers. The
    main caveat of this model is the additional costs because of resource overheads
    that each virtual machine will bring with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model D**: In this model, we deploy each microservice as a container on a
    single machine or across multiple machines. This is not only cost-effective but
    also provides an easy way to be compliant with microservice specifications. This
    is the recommended model whenever it is feasible to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We analyzed different deployment models to understand which option is more appropriate
    than others. For the development of our sample microservices-based application,
    we will use a mix of both a container-based microservice and a microservice hosted
    only on a web server. This mixed model illustrates that we can use any option
    technically, although the container-based deployment is a recommended one. Later,
    we will take one of our microservices to the cloud to demonstrate the portability
    of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing the development and deployment options for microservices, it
    is time to start building an application using two microservices in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a sample microservices-based application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the sample application, we will develop two microservices and a web application
    using Flask and Django frameworks. Our sample application will be an extension
    of the **Student** web application that was developed as a case study in the previous
    chapter. The application architecture will appear as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – C microservices-based architecture of a sample application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – C microservices-based architecture of a sample application
  prefs: []
  type: TYPE_NORMAL
- en: 'To develop this sample application, we will develop the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a new `Student` model under the Students microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse the `apiapp` application from the previous chapter. It is named as a `Students`
    microservice for this sample application. There will be no change in the code
    of this application/module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will update the `webapp` application from the previous chapter's case study
    to consume the `Grades` microservice and add additional `Grade` attributes with
    each `Student` object. This will require minor updates to the Jinja templates
    as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by building the `Grades` microservice with Django.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Grades microservice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To develop a microservice using Django, we will use **Django Rest Framework**
    (**DRF**). Django uses various components from its web framework to build a REST
    API and microservices. Hence, this development exercise will also give you a high-level
    idea about developing web applications using Django.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we started with Flask and are already familiar with the core web concepts
    of web development, it will be a convenient transition for us to start using Django.
    Let''s now understand the steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we will create a project directory or create a new project
    in our favorite IDE with a virtual environment. If you are not using an IDE, you
    can create and activate a virtual environment under your project directory using
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For any web application, it is vital to create a virtual environment for each
    application. Using a global environment for library dependencies can result in
    such errors that are hard to troubleshoot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To build a Django application, we will require at least two libraries that
    can be installed using the following `pip` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have installed Django, we can use the `django-admin` command-line utility
    to create a Django project. The command shown next will create a Django `grades`
    project for our microservice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create a new Django application (our `Grades` microservice)
    by using the following command under the main `grades` project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition to the files created automatically in the `grades_svc` directory,
    we will add two more files – `urls.py` and `serializers.py`. A complete project
    directory structure with two additional files is shown in *Figure 11.5*. The roles
    of different files relevant to our project are also elaborated in this diagram:![Figure
    11.5 – Full directory structure with the grades_svc app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17189_11_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.5 – Full directory structure with the grades_svc app
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will add the necessary code for our microservice in these files one
    by one. We will start by defining our `Grade` model class by extending the `Model`
    class from the Django database `models` package. The complete code of the `models.py`
    file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make our model visible in the `admin` app dashboard, we need to register
    our model `Grade` class in the `admin.py` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will implement a method to retrieve a list of `Grade` objects from
    the database. We will add a `GradeViewSet` class by extending `ViewSet` in the
    `views.py` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we implement our core methods under the `grades_svc` application, we will
    add our application to the Django project for deployment and add routes at the
    application as well as at the API level:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add our `grades_svc` app and also `rest-framework` to the list
    of `INSTALLED_APPS` in the `settings.py` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A common mistake made by developers is to keep adding new components to a single
    settings file, which is hard to maintain for a large project. The best practice
    is to split the file into multiple files and load them in the main settings file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will also ensure that our application is visible in the `admin` app. The
    next step is to add URL configuration at the `admin` app level and then at the
    application level. First, we will add the URL for our application in the `urls.py`
    file under the `admin` app as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to set routes in our application based on different HTTP methods.
    This requires us to add the `urls.py` file to our `grades_svc` directory with
    the following route definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This concludes our implementation of our `Grades` microservice. The next step
    is to run this service under the Django web server for validation. But before
    running the service, we will make sure that the model objects are transferred
    to the database. This is equivalent to initializing the database in the case of
    Flask. In the case of Django, we run the following two commands to prepare the
    changes and then execute them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, developers miss this important step and get errors when trying to start
    the application. So, ensure that all the changes are executed before we start
    the web server by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start a web server on a default port, `8000`, on our local host machine.
    Note that the default settings, including the database and web server with host
    and port attributes, can be changed in the `settings.py` file. Additionally, we
    will recommend setting up a user account for the `admin` app by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This command will prompt you to select a username, email address, and password
    for the admin account. Once our microservice is performing the functions as expected,
    it is time to bundle it in a container and run it as a container application.
    This is explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing a microservice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Containerization is a type of operating system virtualization in which applications
    are run in their separate user space, but sharing the same operating system. This
    separate user space is called a **container**. Docker is the most popular platform
    for creating, managing, and running applications as containers. Docker still holds
    more than an 80% market share, but there are other container runtimes such as
    **CoreOS rkt**, **Mesos**, **lxc**, and **containerd**. Before using Docker to
    containerize our microservice, we will quickly review the main components of the
    Docker platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Engine**: This is the core Docker application for building, packaging,
    and running container-based applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker image**: A Docker image is a file that is used to run the application
    in a container environment. The applications developed using Docker Engine are
    stored as Docker images, which are a collection of application code, libraries,
    resource files, and any other dependencies that are required for application execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Hub**: This is an online repository of Docker images for sharing within
    your team and with the community as well. **Docker Registry** is another term
    used in the same context. Docker Hub is an official name of the Docker registry
    that manages Docker image repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Compose**: This is a tool for building and running container applications
    using a YAML-based file instead of using the CLI commands of Docker Engine. Docker
    Compose provides an easy way to deploy and run multiple containers with configuration
    attributes and dependencies. Therefore, we will recommend using Docker Compose
    or similar technology to build and run your containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use Docker Engine and Docker Compose, you need to have an account with the
    Docker registry. Also, you must download and install Docker Engine and Docker
    Compose on your machine before starting the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, we will create a list of our project dependencies by using
    the `pip freeze` command file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: asgiref==3.4.1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Django==3.2.5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: django-rest-framework==0.1.0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: djangorestframework==3.12.4
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pytz==2021.1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlparse==0.4.1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, we will build `Dockerfile`. This file will also be used by
    Docker Engine to create a new image of a container. In our case, we will add the
    following lines to this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line in this file is setting the base image for this container, and
    we set it to `Python:3.8-slim`, which is already available in the Docker repository.
    The second line in the file is setting an environment variable for better logging.
    The rest of the lines are self-explanatory as they are mostly Unix commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a next step, we will create a Docker Compose file (`docker-compose.yml`)
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the last step, we mount the current directory (`.`) to the `/app` directory
    inside the container. This will allow the changes made on our system to be reflected
    in the container and vice versa. This step is important if you are creating containers
    during the development cycle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can start our container by using the following Docker Compose command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the first time, it will build a new container image and will require internet
    access to download the base container image from the Docker registry. After creating
    a container image, it will automatically start the container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Details of how Docker Engine and Docker Compose work are beyond the scope of
    this book, but we recommend that you become familiar with container technology
    such as Docker through their online documentation ([https://docs.docker.com/](https://docs.docker.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Reusing our Students API app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be reusing our `Students` API app, which we developed in the previous
    chapter. This app will be started with its built-in server and we will name it
    the `Students` microservice for our sample application. There will be no change
    in this application.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our Students web application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `webapp` application, which we developed for the case study in the previous
    chapter, is only using `apiapp` via a REST API. In a revised version of this web
    application, we will use the `Grades` microservice and the `Students` microservice
    to fetch the list of `Grade` objects and the list of `Student` objects. The `list`
    function in our web application will combine the two object lists to provide additional
    info to web clients. The updated `list` function in the `webapp.py` file will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this revised code, we created a `grades` dictionary using a dictionary comprehension
    from the list of `Grades` objects. This dictionary will be used to insert the
    grade attributes inside the `Student` objects before sending them to the Jinja
    template for rendering. In our main Jinja template (`main.html`), we added two
    additional columns, **Building** and **Teacher**, to the **Students** table, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Updated main page with Building and Teacher data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17189_11_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – Updated main page with Building and Teacher data
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered creating a microservice, deploying it as a Docker
    container as well as a web app on a web server, and combining the results of the
    two microservices for a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the Students microservice to GCP Cloud Run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have used the `Students` microservice as a web application with
    a REST API hosted in a flask development server. It is now the time to containerize
    it and deploy it to the **Google Cloud Platform** (**GCP**). GCP has a runtime
    engine (**Cloud Run**) for deploying containers and running them as a service
    (microservice). Here are the steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To package the application code of our `Students` microservice in a container,
    we will first identify a list of dependencies and export them to a `requirements.txt`
    file. We will run the following command from the virtual environment of the `Students`
    microservice project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to build a Dockerfile in the root directory of the project,
    like the one we prepared for our `Grades` microservice. The contents of the Dockerfile
    are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To deploy our application on GCP Cloud Run, Dockerfile will suffice. But first,
    we need to build the container image using the GCP Cloud SDK. This will require
    us to create a GCP project using either the Cloud SDK or GCP Console. We explained
    the steps of creating a GCP project and associating a billing account with it
    in the previous chapters. We assume you have created a project with the name `students-run`
    on GCP.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the project is ready, we can use the following command to build a container
    image of our `Students` API application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create an image, we have to provide the tag attribute in the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our case, the hostname is `gcr.io`, which is based in the United States.
    We can use a locally created image as well, but we must first set the `tag` attribute
    as per the aforementioned format and then push it to the Google registry. This
    can be achieved with the following Docker commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to run the uploaded image. We can run our container image
    by using the following Cloud SDK command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The execution of our image can be triggered from the GCP console as well. Once
    the container is successfully deployed and running, the output of this command
    (or on a GCP console) will include the URL of our microservice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To consume this new version of the `Students` microservice from GCP Cloud Run,
    we will update our web application to switch to use the URL of this newly deployed
    service in GCP Cloud Run. If we test our web application with a locally deployed
    `Grades` microservice and the remotely deployed `Students` microservice, we will
    get the same results as shown earlier in *Figure 11.6* and can perform all operations
    as we did when the `Students` microservice was deployed locally.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion on building microservices using different Python
    frameworks, deploying them locally as well as in the cloud, and consuming them
    from a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced microservices architecture and discussed its
    merits and demerits. We covered several best practices for building, deploying,
    and operationalizing microservices. We also analyzed the development options available
    in Python for building microservices that include Flask, Django, Falcon, Nameko,
    Bottle, and Tornado. We selected Flask and Django to build sample microservices.
    To implement a new microservice, we used Django with its REST framework (DRF).
    This microservice implementation also introduces you to how the Django framework
    works in general. Later, we provided details of how to containerize a newly created
    microservice using Docker Engine and Docker Compose. Finally, we converted our
    `Students` API application to a Docker image and deployed it on GCP Cloud Run.
    We updated the `Students` web application to consume two microservices deployed
    in different parts of the world.
  prefs: []
  type: TYPE_NORMAL
- en: The code examples included in this chapter will provide you with hands-on experience
    in building and deploying microservices for different environments. This knowledge
    is beneficial for anyone who is looking to build microservices in their next projects.
    In the next chapter, we will explore how to use Python to develop serverless functions,
    another new paradigm of software development for the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can we deploy a microservice without a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it appropriate for two microservices to share a single database but with
    a different schema?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Docker Compose and how does it help to deploy microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is REST the only format for data exchange for microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Hands-On Docker for Microservices with Python*, by Jaime Buelta'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python Microservices Development*, by Tarek Ziade'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software*, by Eric
    Evans'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Google Cloud Run quick-start tutorials* for building and deploying microservices,
    available at [https://cloud.google.com/run/docs/quickstarts/](https://cloud.google.com/run/docs/quickstarts/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, but it is recommended to deploy it in a container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Technically, it is feasible, but it is not a best practice. Database failure
    will bring both microservices down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Compose is a tool for deploying and running container applications using
    a YAML file. It provides an easy format to define different services (containers)
    with deployment and runtime attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A REST API is the most popular interface for data exchange for microservices,
    but not the only one. Microservices can also use RPC and events-based protocols
    for data exchange.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
