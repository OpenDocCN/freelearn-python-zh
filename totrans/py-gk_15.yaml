- en: '*Chapter 11*: Using Python for Microservices Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用Python进行微服务开发'
- en: Monolithic applications that are built as a single-tiered software have been
    a popular option for developing applications for many years. However, it is not
    efficient to deploy monolithic applications in cloud platforms in terms of reserving
    and utilizing resources. This is even true for the deployment of large-scale monolithic
    applications on physical machines. The maintenance and development costs of such
    applications are always high. Multi-tier applications have solved this problem
    to some extent for web applications by breaking the applications down into several
    tiers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，单体应用程序作为单层软件构建，一直是开发应用程序的流行选择。然而，在云平台上部署单体应用程序在资源预留和利用方面并不高效。这在物理机上部署大规模单体应用程序的情况下也是如此。这类应用程序的维护和开发成本始终很高。多级应用程序通过将应用程序分解为几个层级，在一定程度上解决了Web应用程序的这个问题。
- en: To meet dynamic resource demands and to reduce development/maintenance costs,
    the real savior is a **microservices architecture**. This new architecture encourages
    applications to be built on loosely coupled services and deployed on dynamically
    scalable platforms such as containers. Organizations such as Amazon, Netflix,
    and Facebook have already moved from a monolithic model to microservices-based
    architecture. Without this change, these organizations couldn't have served a
    large number of clients.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足动态资源需求并降低开发/维护成本，真正的救星是**微服务架构**。这种新架构鼓励在松散耦合的服务上构建应用程序，并部署在如容器等动态可扩展平台上。像亚马逊、Netflix和Facebook这样的组织已经从单体模型迁移到了基于微服务的架构。没有这种改变，这些组织无法服务大量客户。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: Introducing microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍微服务
- en: Learning best practices for microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习微服务的最佳实践
- en: Building microservices-based applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基于微服务的应用程序
- en: After completing this chapter, you will learn about microservices and will be
    able to build applications based on microservices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章学习后，您将了解微服务，并能够基于微服务构建应用程序。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章的技术要求：
- en: You need to have Python 3.7 or later installed on your computer.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在您的计算机上安装Python 3.7或更高版本。
- en: Python Flask library with RESTful extensions installed on top of a Python 3.7
    or later release.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python 3.7或更高版本上安装了RESTful扩展的Python Flask库。
- en: Python Django with Django Rest Framework library on top of a Python 3.7 or later
    release.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python 3.7或更高版本上，使用Django Rest Framework库构建的Python Django。
- en: You need to have a Docker registry account and installed Docker Engine and Docker
    Compose on your machine.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在您的机器上拥有Docker注册表账户，并安装Docker Engine和Docker Compose。
- en: To deploy a microservice in GCP Cloud Run, you will need a GCP account (a free
    trial will work fine).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在GCP Cloud Run中部署微服务，您需要一个GCP账户（免费试用版即可）。
- en: Sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter11](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter11).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在[https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter11](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter11)找到。
- en: We will start our discussion with the introduction of microservices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从微服务的介绍开始讨论。
- en: Introducing microservices
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微服务
- en: 'A microservice is an independent software entity that must have the following
    characteristics:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个独立的软件实体，必须具备以下特征：
- en: '**Loosely coupled** with other services and without any dependency on other
    software components'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松散耦合**与其他服务，且不依赖于其他软件组件'
- en: '**Easy to develop** and **maintain** by a small team without depending on other
    teams'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于开发**和**维护**，小型团队无需依赖其他团队'
- en: '**Independently installable** as a separate entity, preferably in a container'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立安装**作为一个单独的实体，最好在容器中'
- en: Offers **easy-to-consume** interfaces using synchronous protocols such as REST
    APIs, or asynchronous protocols such as **Kafka** or **RabbitMQ**
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供使用同步协议（如REST API）或异步协议（如**Kafka**或**RabbitMQ**）的**易于消费**的接口
- en: The keywords in terms of software being called a microservice are independently
    deployable, loosely coupled, and easily maintainable. Each microservice can have
    its own database servers to avoid sharing resources with other microservices.
    This will ensure the elimination of dependencies between the microservices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 软件被称为微服务的关键字是独立部署、松散耦合和易于维护。每个微服务都可以有自己的数据库服务器，以避免与其他微服务共享资源。这将确保消除微服务之间的依赖性。
- en: 'The microservices architecture style is a software development paradigm for
    developing applications using purely microservices. This architecture even includes
    the main interface entity of the application, such as a web application. An example
    of a microservices-based application is illustrated next:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构风格是一种软件开发范式，用于使用纯微服务开发应用程序。这种架构甚至包括应用程序的主要接口实体，例如网络应用程序。以下是一个基于微服务的应用程序的示例：
- en: '![Figure 11.1 – A sample microservices architecture style application'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 一个示例的微服务架构风格应用程序'
- en: '](img/B17189_11_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_11_01.jpg)'
- en: Figure 11.1 – A sample microservices architecture style application
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 一个示例的微服务架构风格应用程序
- en: 'In this example application, we have individual microservices such as **Authorization
    Service**, **Product Catalog Service**, and **Product Inventory Service**. We
    built a web application, also as a microservice, that uses the three individual
    microservices through the REST API. For mobile clients, a mobile app can be built
    using the same individual microservices through an API gateway. We can see an
    immediate advantage of microservices architecture, which is reusability. A few
    other advantages of using microservices are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例应用程序中，我们有如**授权服务**、**产品目录服务**和**产品库存服务**等单个微服务。我们构建了一个网络应用程序，也是一个微服务，它通过
    REST API 使用这三个单个微服务。对于移动客户端，可以通过 API 网关使用相同的单个微服务构建一个移动应用程序。我们可以看到微服务架构的一个直接优势，那就是可重用性。使用微服务的其他一些优势如下：
- en: We are flexible when it comes to selecting any technology and any programming
    language that suits any individual microservice requirements. We can even reuse
    legacy code written in any language if we can expose it using an API interface.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择任何适合任何单个微服务需求的技术和编程语言时，我们非常灵活。如果我们能够通过 API 接口暴露它，我们甚至可以重用任何语言编写的遗留代码。
- en: We can develop, test, and maintain individual microservices by small independent
    teams. It is crucial to have independent and autonomous small teams for the development
    of large-scale applications.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过小型独立团队开发、测试和维护单个微服务。对于大规模应用程序的开发，拥有独立和自主的小型团队至关重要。
- en: One of the challenges with monolithic applications is the managing of conflicting
    library versions, which we are forced to include because of different features
    bundled in a single application. With microservices, the chances of conflict as
    regards the versions of these libraries are minimized.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体应用程序的一个挑战是管理冲突的库版本，我们被迫包含这些版本，因为它们包含在单个应用程序的不同功能中。使用微服务，这些库版本冲突的可能性最小化。
- en: We can deploy and patch the individual microservices independently. This enables
    us to use **Continuous Integration/Continuous Delivery** (**CI/CD**) for complex
    applications. This is also important when we need to apply a patch or upgrade
    one feature of an application. For monolithic applications, we will redeploy the
    entire application, which means there are chances to break other parts of the
    application. With microservices, only one or two services will be redeployed without
    risks of breaking anything else in other microservices.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以独立部署和修补单个微服务。这使得我们能够为复杂的应用程序使用**持续集成/持续交付**（**CI/CD**）。当我们需要应用补丁或升级应用程序的一个功能时，这也非常重要。对于单体应用程序，我们将重新部署整个应用程序，这意味着有可能破坏应用程序的其他部分。使用微服务，只有一两个服务会被重新部署，而不会在其他微服务中造成破坏的风险。
- en: We can isolate faults and failures on a microservice level instead of the application
    level. If there is a fault or failure with one service, we can debug it, fix it,
    and patch it or stop it for maintenance without impacting the rest of the application's
    functionality. In the case of monolithic applications, a problem in one component
    can bring down the entire application.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在微服务级别而不是应用程序级别隔离故障和失败。如果一个服务出现故障或失败，我们可以调试它、修复它、打补丁或停止它进行维护，而不会影响应用程序的其他功能。在单体应用程序的情况下，一个组件的问题可能会使整个应用程序崩溃。
- en: 'Despite several advantages, there are some disadvantages associated with using
    the microservices architecture style:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有多个优点，但使用微服务架构风格也有一些缺点：
- en: First is the increased complexity of creating microservices-based applications.
    The complexity mainly arises from the fact that each microservice has to expose
    an API and the consumer service or program has to interact with microservices
    using an API. Security on a per microservice basis is another contributor to the
    complexity.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是创建基于微服务的应用程序的复杂性增加。这种复杂性主要源于每个微服务都必须暴露一个API，并且消费者服务或程序必须使用API与微服务进行交互。基于每个微服务的安全性也是复杂性的另一个贡献者。
- en: The second disadvantage is the increased resource requirements as compared to
    monolithic applications. Every microservice requires additional memory to be hosted
    independently in a container or a virtual machine, even if it is a **Java Virtual
    Machine** (**JVM**).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个缺点是与单体应用程序相比，资源需求增加。每个微服务都需要额外的内存来独立托管在容器或虚拟机中，即使它是一个**Java虚拟机**（**JVM**）。
- en: The third disadvantage is that additional efforts are required to debug and
    troubleshoot a problem across different microservices that may be deployed in
    separate containers or systems.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个缺点是，在可能部署在不同容器或系统中的不同微服务之间调试和解决问题需要额外的努力。
- en: Next, we will study the best practice of building microservices.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究构建微服务的最佳实践。
- en: Learning best practices for microservices
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习微服务的最佳实践
- en: When starting a new application, the first and foremost question we should be
    asking ourselves is whether the microservices architecture is a good fit. This
    starts with an analysis of the application requirements and the ability to divide
    the requirements into separate and individual components. If you see that your
    components frequently depend on one another, this is an indicator that the segregation
    of components may require reworking, or that this application may not be a fit
    for the microservices architecture.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个新的应用程序时，我们首先应该问自己的问题是微服务架构是否合适。这始于对应用程序需求的分析以及将需求划分为单独和独立组件的能力。如果你看到你的组件经常相互依赖，这是一个指标，表明组件的隔离可能需要重新设计，或者这个应用程序可能不适合微服务架构。
- en: It is important to make this decision of whether to use microservices right
    in the early phase of an application. There is a school of thought that says that
    it is better to start building an application using monolithic architecture to
    avoid the additional costs of microservices in the beginning. However, this is
    not an advisable approach. Once we have built a monolithic application, it is
    difficult to transform it into microservices architecture, especially if the application
    is already in production. Companies such as Amazon and Netflix have done it, but
    they did it as part of their evolution of technology and certainly, they have
    the human and technology resources available to undertake this transformation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的早期阶段就决定是否使用微服务非常重要。有一种观点认为，最好一开始就使用单体架构来避免微服务的额外成本。然而，这不是一个可取的方法。一旦我们构建了一个单体应用程序，就很难将其转换为微服务架构，尤其是如果应用程序已经在生产中。像亚马逊和Netflix这样的公司已经做到了，但他们是在其技术演化的过程中做的，而且他们当然有可供利用的人力和技术资源来完成这种转型。
- en: 'Once we have made our decision to build our next application using microservices,
    the following best practices will guide you in making design and deployment decisions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定使用微服务来构建我们的下一个应用程序，以下最佳实践将指导你在设计和部署决策中：
- en: '**Independent and loosely coupled**: These requirements are part of the microservices
    definition. Each microservice should be built independently from the other microservices
    and is built as loosely coupled as possible.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立且松散耦合**：这些要求是微服务定义的一部分。每个微服务都应该独立于其他微服务构建，并且尽可能地以松散耦合的方式构建。'
- en: '**Domain-Driven Design** (**DDD**): The purpose of microservices architecture
    is not to have as many small microservices as possible. We need to always remember
    that each microservice has its overhead costs. We should build as many microservices
    as the business or domain requires. We recommend considering DDD, which was introduced
    by *Eric Evans* in 2004\.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）：微服务架构的目的不是尽可能多地拥有小型微服务。我们需要始终记住，每个微服务都有其开销成本。我们应该构建业务或领域所需的微服务数量。我们建议考虑领域驱动设计（DDD），这是由*埃里克·埃文斯*在2004年提出的。'
- en: If we try to apply DDD to microservices, it suggests having a strategic design
    first to define different contexts by combining related business domains and their
    subdomains. The strategic design can be followed by a tactical design that focuses
    on breaking down the core domains into fine-grained building blocks and entities.
    This breakdown will provide clear guidelines to map the requirements to possible
    microservices.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们尝试将领域驱动设计（DDD）应用于微服务，它建议首先进行战略设计，通过结合相关的业务领域及其子领域来定义不同的上下文。战略设计可以由战术设计跟随，战术设计专注于将核心领域分解成细粒度的构建块和实体。这种分解将为将需求映射到可能的微服务提供明确的指导。
- en: '**Communication interfaces**: We should use well-defined microservice interfaces,
    preferably a REST API or an event-driven API, for communication. Microservices
    should avoid calling each other directly.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信接口**：我们应该使用定义良好的微服务接口，最好是REST API或事件驱动API，用于通信。微服务应避免直接相互调用。'
- en: '**Use an API gateway**: Microservices and their consumer applications should
    interact with individual microservices using an API gateway. The API gateway can
    take care of security aspects, such as authentication and load balancing, out
    of the box. Moreover, with a new version of a microservice, we can use the API
    gateway to redirect the client requests to the newer version without impacting
    the client-side software.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用API网关**：微服务和它们的消费者应用应该通过API网关与单个微服务进行交互。API网关可以开箱即用地处理安全方面的问题，例如身份验证和负载均衡。此外，当我们有一个微服务的新版本时，我们可以使用API网关将客户端请求重定向到新版本，而不会影响客户端软件。'
- en: '**Limit technology stack**: Although microservice architecture allows the use
    of any programming language and framework on a per-service basis, it is not advisable
    to develop microservices using different technologies in the absence of any business
    or reusability reasons. A diverse technology stack may be appealing for academic
    reasons, but it will bring operational complexity in maintaining and troubleshooting
    the application.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制技术栈**：尽管微服务架构允许在服务级别使用任何编程语言和框架，但在没有业务或重用性原因的情况下，不建议使用不同的技术来开发微服务。多样化的技术栈可能从学术角度来看很有吸引力，但它将在维护和解决问题时带来运营复杂性。'
- en: '**Deployment model**: It is not mandatory to deploy a microservice in a container,
    but it is recommended. Containers bring a lot of built-in features, such as automated
    deployment, cross-platform support, and interoperability. Additionally, by using
    containers, we can assign the resources to the service as per its requirements
    and ensure a fair distribution of resources across different microservices.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署模型**：在容器中部署微服务不是强制性的，但这是推荐的。容器带来了许多内置功能，例如自动化部署、跨平台支持和互操作性。此外，通过使用容器，我们可以根据服务的要求分配资源，并确保不同微服务之间资源的公平分配。'
- en: '**Version control**: We should be using a separate versioning control system
    for each microservice.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：我们应该为每个微服务使用独立的版本控制系统。'
- en: '**Team organization**: Microservices architecture provides an opportunity to
    have dedicated teams on a per-microservice basis. We should be keeping this principle
    in mind when organizing teams for a large-scale project. The size of a team should
    be based on the *two-pizza philosophy*, which states that we should set up a team
    with as many engineers who can be fed by two large pizzas. A team can own one
    or more microservices based on their complexity.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队组织**：微服务架构提供了一个按每个微服务分配专用团队的机会。在组织大规模项目团队时，我们应该牢记这一原则。团队的大小应根据*两个披萨原则*来确定，即我们应该组建一个可以由两个大披萨喂养的工程师团队。一个团队可以拥有一个或多个微服务，这取决于它们的复杂性。'
- en: '**Centralized logging/monitoring**: As discussed previously, troubleshooting
    problems in a microservice architecture-style application can be time-consuming,
    especially if the microservices are running in containers. We should be using
    open source or professional tools to monitor and troubleshoot the microservices
    to reduce such operational costs. A few examples of such tools are **Splunk**,
    **Grafana**, **Elk**, and **App Dynamics**.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式日志/监控**：如前所述，在微服务架构风格的应用程序中解决问题可能很耗时，尤其是如果微服务在容器中运行。我们应该使用开源或专业工具来监控和解决问题，以减少此类运营成本。此类工具的几个例子包括**Splunk**、**Grafana**、**Elk**和**App
    Dynamics**。'
- en: Now that we have covered the introduction as well as best practices of microservices,
    next, we will deep dive into learning to build an application using microservices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了微服务的概念以及最佳实践，接下来，我们将深入学习如何使用微服务构建应用程序。
- en: Building microservices-based applications
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于微服务的应用程序
- en: Before going into the implementation details of microservices, it is important
    to analyze several microservice frameworks and deployment options. We will start
    with a microservices framework available in Python.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解微服务的实现细节之前，分析几个微服务框架和部署选项是非常重要的。我们将从Python中可用的一个微服务框架开始。
- en: Learning microservice development options in Python
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习Python中的微服务开发选项
- en: 'In Python, we have a plethora of frameworks and libraries available for microservice
    development. We cannot enumerate all the available options, but it is worth highlighting
    the most popular and those that have some different feature sets. These options
    are described next:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们有大量的框架和库可用于微服务开发。我们无法列举所有可用的选项，但值得突出显示最受欢迎的以及那些具有一些不同功能集的选项。以下是对这些选项的描述：
- en: '**Flask**: This is a lightweight framework that can be used to build **Web
    Service Gateway Interface** (**WSGI**)-based microservices. Note that WSGI is
    based on a request-response synchronous design pattern. We already used Flask
    and its RESTful extension to build a REST API application in [*Chapter 10*](B17189_10_Final_PG_ePub.xhtml#_idTextAnchor264),
    *Using Python for Web Development and REST API*. Since Flask is a popular web
    and API development framework, it is an easy adoption choice for many developers
    who are already using Flask.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flask**：这是一个轻量级的框架，可以用来构建基于**Web服务网关接口**（**WSGI**）的微服务。请注意，WSGI基于请求-响应的同步设计模式。我们已经在[*第10章*](B17189_10_Final_PG_ePub.xhtml#_idTextAnchor264)，“使用Python进行Web开发和REST
    API”中使用了Flask及其RESTful扩展来构建REST API应用程序。由于Flask是一个流行的Web和API开发框架，因此对于已经使用Flask的开发者来说，它是一个易于采纳的选择。'
- en: '**Django**: Django is another popular web framework with a large community
    of developers. With its **Django Rest Framework** (**DRF**), we can build microservices
    with REST API interfaces. Django offers both WSGI and **Asynchronous Service Gateway
    Interface** (**ASGI**)-based microservices. ASGI is considered a successor to
    the WSGI interface. ASGI is an excellent option if you are interested in developing
    your application based on **Asyncio**, a topic we discussed in detail in [*Chapter
    7*](B17189_07_Final_PG_ePub.xhtml#_idTextAnchor207), *Multiprocessing, Multithreading,
    and Asynchronous Programming*.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Django**：Django是另一个拥有庞大开发者社区的流行Web框架。通过其**Django Rest Framework**（**DRF**），我们可以使用REST
    API接口构建微服务。Django提供基于WSGI和**异步服务网关接口**（**ASGI**）的微服务。ASGI被认为是WSGI接口的继任者。如果你对基于**Asyncio**（我们在[*第7章*](B17189_07_Final_PG_ePub.xhtml#_idTextAnchor207)，“多进程、多线程和异步编程”中详细讨论的主题）开发应用程序感兴趣，ASGI是一个很好的选择。'
- en: '**Falcon**: This is also a popular web framework after Flask and Django. It
    does not come with a built-in web server, but it is well optimized for microservices.
    Like Django, it supports both ASGI and WSGI.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Falcon**：这也是在Flask和Django之后的一个流行的Web框架。它没有内置Web服务器，但针对微服务进行了很好的优化。像Django一样，它支持ASGI和WSGI。'
- en: '**Nameko**: This framework is specifically designed for microservice development
    in Python, and is not a web application framework. Nameko comes with built-in
    support for **Remote Procedure Call** (**RPC**), asynchronous events, and WebSocket-based
    RPCs. If your application requires any of these communication interfaces, you
    should consider Nameko.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nameko**：这个框架专门为Python中的微服务开发设计，并且不是一个Web应用程序框架。Nameko内置了对**远程过程调用**（**RPC**）、异步事件和基于WebSocket的RPC的支持。如果你的应用程序需要这些通信接口中的任何一个，你应该考虑使用Nameko。'
- en: '**Bottle**: This is a super lightweight WSGI-based microservices framework.
    The whole framework is based on a single file and leverages only a Python standard
    library for its operations.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bottle**：这是一个基于WSGI的超级轻量级微服务框架。整个框架基于一个文件，并且仅使用Python标准库进行操作。'
- en: '**Tornado**: It is based on non-blocking network I/O. Tornado can handle high
    traffic with extremely low overheads. This is also a suitable choice for long-polling
    and WebSocket-based connections.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tornado**：它基于非阻塞网络I/O。Tornado可以以极低的开销处理高流量。这也适用于长轮询和基于WebSocket的连接。'
- en: For the development of our sample microservices, we can use any of the frameworks
    mentioned earlier. But we will use Flask and Django for two reasons. First, these
    two are the most popular for developing web applications and microservices. Second,
    we will reuse an example API application that we developed in the previous chapter.
    A new microservice will be developed using Django and it will illustrate how to
    use Django for web and API development.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们样本微服务的开发，我们可以使用前面提到的任何框架。但我们将使用Flask和Django，原因有两个。首先，这两个框架在开发Web应用和微服务方面是最受欢迎的。其次，我们将重用我们在上一章中开发的示例API应用。一个新的微服务将使用Django开发，它将展示如何使用Django进行Web和API开发。
- en: Next, we will discuss microservice deployment options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论微服务的部署选项。
- en: Introducing deployment options for microservices
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍微服务的部署选项
- en: 'Once we write microservices, the next question is how to deploy them as an
    isolated and independent entity. For the sake of discussion, we will assume that
    microservices are built with HTTP/REST interfaces. We can deploy all microservices
    on the same web server as different web apps or host one web server for one microservice.
    One microservice in a separate web server can be deployed on a single machine
    (physical or virtual) or on separate machines or even on separate containers.
    We have summarized all these different deployment models in the following diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了微服务，下一个问题就是如何将它们作为独立和独立的实体进行部署。为了讨论方便，我们假设微服务是用HTTP/REST接口构建的。我们可以将所有微服务部署在同一台Web服务器上作为不同的Web应用，或者为每个微服务托管一台Web服务器。一个单独的Web服务器上的微服务可以部署在单台机器（物理或虚拟）上，或者在不同的机器上，甚至在不同的容器中。我们已经在以下图表中总结了所有这些不同的部署模型：
- en: '![Figure 11.2 – Microservices deployment models'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.2 – 微服务部署模型](Figure 11.2 – 微服务部署模型)'
- en: '](img/B17189_11_02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_11_02.jpg](img/B17189_11_02.jpg)'
- en: Figure 11.2 – Microservices deployment models
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 微服务部署模型
- en: 'The four deployments models shown in *Figure 11.2* are described as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.2* 中显示的四种部署模型描述如下：'
- en: '**Model A**: In this model, we are deploying four different microservices on
    the same web server. There is a good chance that the microservices in this case
    are sharing libraries, being on a single web server. This may result in library
    conflicts and is not a recommended model for deploying microservices.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型A**：在这个模型中，我们在同一台Web服务器上部署了四个不同的微服务。在这种情况下，微服务很可能共享库，位于单个Web服务器上。这可能会导致库冲突，因此不推荐使用这种模型来部署微服务。'
- en: '**Model B**: For this model, we deployed four microservices on a single machine,
    but using one microservice per web server to make them independent. This model
    is fine for development environments, but may not be suitable on a production
    scale.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型B**：对于这个模型，我们在一台机器上部署了四个微服务，但每个微服务使用一个Web服务器来使它们独立。这种模型在开发环境中是可行的，但在生产规模上可能不太合适。'
- en: '**Model C**: This model is using four virtual machines to host four different
    microservices. Each machine host only one microservice with a web server. This
    model is suitable for production if it is not possible to use containers. The
    main caveat of this model is the additional costs because of resource overheads
    that each virtual machine will bring with it.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型C**：这个模型使用四台虚拟机来托管四个不同的微服务。每台机器只托管一个微服务和一个Web服务器。如果无法使用容器，这种模型适合生产环境。这个模型的主要缺点是由于每个虚拟机都会带来额外的资源开销，从而增加了成本。'
- en: '**Model D**: In this model, we deploy each microservice as a container on a
    single machine or across multiple machines. This is not only cost-effective but
    also provides an easy way to be compliant with microservice specifications. This
    is the recommended model whenever it is feasible to use.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型D**：在这个模型中，我们将每个微服务作为容器部署在单台机器上或跨多台机器。这不仅成本低，而且提供了一个简单的方法来符合微服务规范。只要可行，这是推荐使用的模型。'
- en: We analyzed different deployment models to understand which option is more appropriate
    than others. For the development of our sample microservices-based application,
    we will use a mix of both a container-based microservice and a microservice hosted
    only on a web server. This mixed model illustrates that we can use any option
    technically, although the container-based deployment is a recommended one. Later,
    we will take one of our microservices to the cloud to demonstrate the portability
    of microservices.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了不同的部署模型，以了解哪个选项比其他选项更合适。对于我们的示例基于微服务的应用程序开发，我们将使用基于容器和仅托管在Web服务器上的微服务的混合模式。这种混合模式说明我们可以从技术上使用任何选项，尽管基于容器的部署是一个推荐的选择。稍后，我们将把我们的一个微服务带到云端，以展示微服务的可移植性。
- en: After discussing the development and deployment options for microservices, it
    is time to start building an application using two microservices in the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了微服务的开发和部署选项之后，现在是时候在下一节开始使用两个微服务构建应用程序了。
- en: Developing a sample microservices-based application
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发一个基于微服务的示例应用程序
- en: 'For the sample application, we will develop two microservices and a web application
    using Flask and Django frameworks. Our sample application will be an extension
    of the **Student** web application that was developed as a case study in the previous
    chapter. The application architecture will appear as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例应用程序，我们将使用Flask和Django框架开发两个微服务和一个Web应用程序。我们的示例应用程序将是上一章作为案例研究开发的**学生**Web应用程序的扩展。应用程序架构将如图所示：
- en: '![Figure 11.3 – C microservices-based architecture of a sample application'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 – C示例应用程序的基于微服务的架构]'
- en: '](img/B17189_11_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B17189_11_03.jpg]'
- en: Figure 11.3 – C microservices-based architecture of a sample application
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – C示例应用程序的基于微服务的架构
- en: 'To develop this sample application, we will develop the following components:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发这个示例应用程序，我们将开发以下组件：
- en: Build a new `Student` model under the Students microservice.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Students微服务下构建一个新的`Student`模型。
- en: Reuse the `apiapp` application from the previous chapter. It is named as a `Students`
    microservice for this sample application. There will be no change in the code
    of this application/module.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新使用上一章中的`apiapp`应用程序。在这个示例应用程序中，它被命名为`Students`微服务。这个应用程序/模块的代码将不会发生变化。
- en: We will update the `webapp` application from the previous chapter's case study
    to consume the `Grades` microservice and add additional `Grade` attributes with
    each `Student` object. This will require minor updates to the Jinja templates
    as well.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将更新上一章案例研究中的`webapp`应用程序，以使用`Grades`微服务，并为每个`Student`对象添加额外的`Grade`属性。这还需要对Jinja模板进行一些小的更新。
- en: We will start by building the `Grades` microservice with Django.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用Django构建`Grades`微服务。
- en: Creating a Grades microservice
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建成绩微服务
- en: To develop a microservice using Django, we will use **Django Rest Framework**
    (**DRF**). Django uses various components from its web framework to build a REST
    API and microservices. Hence, this development exercise will also give you a high-level
    idea about developing web applications using Django.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Django开发微服务，我们将使用**Django Rest Framework**（**DRF**）。Django使用其Web框架的多个组件来构建REST
    API和微服务。因此，这个开发练习也将给您一个关于使用Django开发Web应用程序的高级概念。
- en: 'Since we started with Flask and are already familiar with the core web concepts
    of web development, it will be a convenient transition for us to start using Django.
    Let''s now understand the steps involved:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从Flask开始的，并且已经熟悉了Web开发的核心概念，因此对我们来说，开始使用Django将是一个方便的过渡。现在让我们了解涉及的步骤：
- en: 'First things first, we will create a project directory or create a new project
    in our favorite IDE with a virtual environment. If you are not using an IDE, you
    can create and activate a virtual environment under your project directory using
    the following commands:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个项目目录，或者在最喜欢的IDE中创建一个新的项目并使用虚拟环境。如果您没有使用IDE，您可以在项目目录下使用以下命令创建和激活一个虚拟环境：
- en: '[PRE0]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For any web application, it is vital to create a virtual environment for each
    application. Using a global environment for library dependencies can result in
    such errors that are hard to troubleshoot.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于任何Web应用程序，为每个应用程序创建一个虚拟环境是至关重要的。使用全局环境来管理库依赖可能会导致难以调试的错误。
- en: 'To build a Django application, we will require at least two libraries that
    can be installed using the following `pip` commands:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建一个Django应用程序，我们需要至少两个可以使用以下`pip`命令安装的库：
- en: '[PRE1]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we have installed Django, we can use the `django-admin` command-line utility
    to create a Django project. The command shown next will create a Django `grades`
    project for our microservice:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们安装了 Django，我们就可以使用 `django-admin` 命令行工具来创建一个 Django 项目。下面的命令将创建一个用于我们的微服务的
    Django `grades` 项目：
- en: '[PRE2]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is to create a new Django application (our `Grades` microservice)
    by using the following command under the main `grades` project directory:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个新的 Django 应用（我们的 `Grades` 微服务），在主 `grades` 项目目录下使用以下命令：
- en: '[PRE3]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition to the files created automatically in the `grades_svc` directory,
    we will add two more files – `urls.py` and `serializers.py`. A complete project
    directory structure with two additional files is shown in *Figure 11.5*. The roles
    of different files relevant to our project are also elaborated in this diagram:![Figure
    11.5 – Full directory structure with the grades_svc app
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了在 `grades_svc` 目录中自动创建的文件外，我们还将添加两个额外的文件 – `urls.py` 和 `serializers.py`。带有两个额外文件的完整项目目录结构在
    *图 11.5* 中显示。与我们的项目相关的不同文件的作用也在这个图中进行了详细说明：![Figure 11.5 – Full directory structure
    with the grades_svc app
- en: '](img/B17189_11_05.jpg)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B17189_11_05.jpg](img/B17189_11_05.jpg)'
- en: Figure 11.5 – Full directory structure with the grades_svc app
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.5 – 包含 grades_svc 应用的完整目录结构
- en: 'Next, we will add the necessary code for our microservice in these files one
    by one. We will start by defining our `Grade` model class by extending the `Model`
    class from the Django database `models` package. The complete code of the `models.py`
    file is as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将逐个添加这些文件中我们微服务所需的必要代码。我们将首先通过扩展 Django 数据库 `models` 包中的 `Model` 类来定义我们的
    `Grade` 模型类。`models.py` 文件的完整代码如下：
- en: '[PRE4]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To make our model visible in the `admin` app dashboard, we need to register
    our model `Grade` class in the `admin.py` file as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的模型在 `admin` 应用仪表板中可见，我们需要在 `admin.py` 文件中注册我们的 `Grade` 类模型，如下所示：
- en: '[PRE5]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we will implement a method to retrieve a list of `Grade` objects from
    the database. We will add a `GradeViewSet` class by extending `ViewSet` in the
    `views.py` file as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个从数据库中检索 `Grade` 对象列表的方法。我们将在 `views.py` 文件中通过扩展 `ViewSet` 来添加一个 `GradeViewSet`
    类，如下所示：
- en: '[PRE6]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we implement our core methods under the `grades_svc` application, we will
    add our application to the Django project for deployment and add routes at the
    application as well as at the API level:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 `grades_svc` 应用程序下实现了核心方法，我们将添加我们的应用程序到 Django 项目中进行部署，并在应用以及 API 级别添加路由：
- en: 'First, we will add our `grades_svc` app and also `rest-framework` to the list
    of `INSTALLED_APPS` in the `settings.py` file as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在 `settings.py` 文件中将我们的 `grades_svc` 应用和 `rest-framework` 添加到 `INSTALLED_APPS`
    列表中，如下所示：
- en: '[PRE7]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A common mistake made by developers is to keep adding new components to a single
    settings file, which is hard to maintain for a large project. The best practice
    is to split the file into multiple files and load them in the main settings file.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开发者常犯的一个错误是将新组件不断添加到单个设置文件中，这对于大型项目来说很难维护。最佳实践是将文件拆分为多个文件，并在主设置文件中加载它们。
- en: 'This will also ensure that our application is visible in the `admin` app. The
    next step is to add URL configuration at the `admin` app level and then at the
    application level. First, we will add the URL for our application in the `urls.py`
    file under the `admin` app as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也将确保我们的应用程序在 `admin` 应用中可见。下一步是在 `admin` 应用级别以及应用级别添加 URL 配置。首先，我们将在 `admin`
    应用的 `urls.py` 文件中添加我们应用程序的 URL，如下所示：
- en: '[PRE8]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next step is to set routes in our application based on different HTTP methods.
    This requires us to add the `urls.py` file to our `grades_svc` directory with
    the following route definitions:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在我们的应用程序中根据不同的 HTTP 方法设置路由。这需要我们在 `grades_svc` 目录中添加 `urls.py` 文件，并包含以下路由定义：
- en: '[PRE9]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This concludes our implementation of our `Grades` microservice. The next step
    is to run this service under the Django web server for validation. But before
    running the service, we will make sure that the model objects are transferred
    to the database. This is equivalent to initializing the database in the case of
    Flask. In the case of Django, we run the following two commands to prepare the
    changes and then execute them:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的 `Grades` 微服务的实现。下一步是在 Django 网络服务器上运行此服务以进行验证。但在运行服务之前，我们将确保模型对象已转移到数据库中。这在
    Flask 的情况下相当于初始化数据库。在 Django 的情况下，我们运行以下两个命令来准备更改，然后执行它们：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Often, developers miss this important step and get errors when trying to start
    the application. So, ensure that all the changes are executed before we start
    the web server by using the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发者会错过这个重要的步骤，在尝试启动应用程序时遇到错误。因此，在通过以下命令启动Web服务器之前，请确保所有更改都已执行：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will start a web server on a default port, `8000`, on our local host machine.
    Note that the default settings, including the database and web server with host
    and port attributes, can be changed in the `settings.py` file. Additionally, we
    will recommend setting up a user account for the `admin` app by using the following
    command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的本地主机机器上的默认端口`8000`启动一个Web服务器。请注意，包括数据库和具有主机和端口属性的Web服务器在内的默认设置可以在`settings.py`文件中更改。此外，我们建议使用以下命令设置`admin`应用程序的用户账户：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command will prompt you to select a username, email address, and password
    for the admin account. Once our microservice is performing the functions as expected,
    it is time to bundle it in a container and run it as a container application.
    This is explained in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将提示您选择管理员账户的用户名、电子邮件地址和密码。一旦我们的微服务按预期执行功能，就是时候将其打包到容器中，并以容器应用程序的形式运行它。这将在下一节中解释。
- en: Containerizing a microservice
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务容器化
- en: 'Containerization is a type of operating system virtualization in which applications
    are run in their separate user space, but sharing the same operating system. This
    separate user space is called a **container**. Docker is the most popular platform
    for creating, managing, and running applications as containers. Docker still holds
    more than an 80% market share, but there are other container runtimes such as
    **CoreOS rkt**, **Mesos**, **lxc**, and **containerd**. Before using Docker to
    containerize our microservice, we will quickly review the main components of the
    Docker platform:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化是一种操作系统虚拟化类型，其中应用程序在其单独的用户空间中运行，但共享相同的操作系统。这个单独的用户空间被称为**容器**。Docker是创建、管理和运行容器应用程序最流行的平台。Docker仍然占据超过80%的市场份额，但还有其他容器运行时，如**CoreOS
    rkt**、**Mesos**、**lxc**和**containerd**。在用Docker对我们的微服务进行容器化之前，我们将快速回顾Docker平台的主要组件：
- en: '**Docker Engine**: This is the core Docker application for building, packaging,
    and running container-based applications.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Engine**：这是Docker的核心应用程序，用于构建、打包和运行基于容器的应用程序。'
- en: '**Docker image**: A Docker image is a file that is used to run the application
    in a container environment. The applications developed using Docker Engine are
    stored as Docker images, which are a collection of application code, libraries,
    resource files, and any other dependencies that are required for application execution.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：Docker镜像是一个文件，用于在容器环境中运行应用程序。使用Docker Engine开发的程序存储为Docker镜像，这些镜像是一组应用程序代码、库、资源文件以及应用程序执行所需的任何其他依赖项。'
- en: '**Docker Hub**: This is an online repository of Docker images for sharing within
    your team and with the community as well. **Docker Registry** is another term
    used in the same context. Docker Hub is an official name of the Docker registry
    that manages Docker image repositories.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**：这是一个在线仓库，用于在您的团队和社区内共享Docker镜像。**Docker Registry**是在同一上下文中使用的另一个术语。Docker
    Hub是管理Docker镜像仓库的Docker注册表的官方名称。'
- en: '**Docker Compose**: This is a tool for building and running container applications
    using a YAML-based file instead of using the CLI commands of Docker Engine. Docker
    Compose provides an easy way to deploy and run multiple containers with configuration
    attributes and dependencies. Therefore, we will recommend using Docker Compose
    or similar technology to build and run your containers.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Compose**：这是一个使用基于YAML的文件构建和运行容器应用程序的工具，而不是使用Docker Engine的CLI命令。Docker
    Compose提供了一种简单的方式来部署和运行多个容器，包括配置属性和依赖项。因此，我们建议使用Docker Compose或类似技术来构建和运行您的容器。'
- en: 'To use Docker Engine and Docker Compose, you need to have an account with the
    Docker registry. Also, you must download and install Docker Engine and Docker
    Compose on your machine before starting the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Docker Engine和Docker Compose，您需要在Docker注册表中有一个账户。此外，在开始以下步骤之前，您必须在您的机器上下载并安装Docker
    Engine和Docker Compose。
- en: 'As a first step, we will create a list of our project dependencies by using
    the `pip freeze` command file as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们将使用`pip freeze`命令文件创建我们项目的依赖列表，如下所示：
- en: '[PRE13]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: asgiref==3.4.1
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: asgiref==3.4.1
- en: Django==3.2.5
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Django==3.2.5
- en: django-rest-framework==0.1.0
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: django-rest-framework==0.1.0
- en: djangorestframework==3.12.4
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: djangorestframework==3.12.4
- en: pytz==2021.1
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pytz==2021.1
- en: sqlparse==0.4.1
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sqlparse==0.4.1
- en: '[PRE14]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the next step, we will build `Dockerfile`. This file will also be used by
    Docker Engine to create a new image of a container. In our case, we will add the
    following lines to this file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将构建 `Dockerfile`。此文件也将被 Docker Engine 用于创建容器的新镜像。在我们的情况下，我们将向此文件添加以下行：
- en: '[PRE15]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first line in this file is setting the base image for this container, and
    we set it to `Python:3.8-slim`, which is already available in the Docker repository.
    The second line in the file is setting an environment variable for better logging.
    The rest of the lines are self-explanatory as they are mostly Unix commands.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件的第一行设置了此容器的基镜像，我们将其设置为 `Python:3.8-slim`，这个镜像已经在 Docker 仓库中可用。文件的第二行设置了环境变量以实现更好的日志记录。其余的行都是自解释的，因为它们大多是
    Unix 命令。
- en: 'As a next step, we will create a Docker Compose file (`docker-compose.yml`)
    as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为下一步，我们将创建一个 Docker Compose 文件（`docker-compose.yml`），如下所示：
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As the last step, we mount the current directory (`.`) to the `/app` directory
    inside the container. This will allow the changes made on our system to be reflected
    in the container and vice versa. This step is important if you are creating containers
    during the development cycle.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将当前目录（`.`）挂载到容器内的 `/app` 目录。这将允许系统上的更改反映在容器中，反之亦然。如果您在开发周期中创建容器，这一步非常重要。
- en: 'We can start our container by using the following Docker Compose command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下 Docker Compose 命令来启动我们的容器：
- en: '[PRE17]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For the first time, it will build a new container image and will require internet
    access to download the base container image from the Docker registry. After creating
    a container image, it will automatically start the container.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一次，它将构建一个新的容器镜像，并且需要互联网访问来从 Docker 仓库下载基础容器镜像。在创建容器镜像后，它将自动启动容器。
- en: Details of how Docker Engine and Docker Compose work are beyond the scope of
    this book, but we recommend that you become familiar with container technology
    such as Docker through their online documentation ([https://docs.docker.com/](https://docs.docker.com/)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine 和 Docker Compose 的工作细节超出了本书的范围，但我们建议您通过他们的在线文档（[https://docs.docker.com/](https://docs.docker.com/)）熟悉容器技术，如
    Docker。
- en: Reusing our Students API app
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复使用我们的 Students API 应用
- en: We will be reusing our `Students` API app, which we developed in the previous
    chapter. This app will be started with its built-in server and we will name it
    the `Students` microservice for our sample application. There will be no change
    in this application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复使用我们在上一章中开发的 `Students` API 应用。此应用将使用其内置服务器启动，我们将它命名为我们的示例应用的 `Students`
    微服务。此应用将不会有任何变化。
- en: Updating our Students web application
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新我们的 Students Web 应用程序
- en: 'The `webapp` application, which we developed for the case study in the previous
    chapter, is only using `apiapp` via a REST API. In a revised version of this web
    application, we will use the `Grades` microservice and the `Students` microservice
    to fetch the list of `Grade` objects and the list of `Student` objects. The `list`
    function in our web application will combine the two object lists to provide additional
    info to web clients. The updated `list` function in the `webapp.py` file will
    be as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章案例研究中开发的 `webapp` 应用程序仅通过 REST API 使用 `apiapp`。在修订版的这个 Web 应用程序中，我们将使用
    `Grades` 微服务和 `Students` 微服务来获取 `Grade` 对象列表和 `Student` 对象列表。我们 Web 应用程序中的 `list`
    函数将结合这两个对象列表，为 Web 客户端提供更多信息。`webapp.py` 文件中更新的 `list` 函数如下：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this revised code, we created a `grades` dictionary using a dictionary comprehension
    from the list of `Grades` objects. This dictionary will be used to insert the
    grade attributes inside the `Student` objects before sending them to the Jinja
    template for rendering. In our main Jinja template (`main.html`), we added two
    additional columns, **Building** and **Teacher**, to the **Students** table, as
    shown here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修订的代码中，我们使用字典推导从 `Grades` 对象列表中创建了一个 `grades` 字典。这个字典将被用来在将它们发送到 Jinja 模板进行渲染之前，将成绩属性插入到
    `Student` 对象中。在我们的主 Jinja 模板（`main.html`）中，我们向 **Students** 表格中添加了两个额外的列，**Building**
    和 **Teacher**，如下所示：
- en: '![Figure 11.6 – Updated main page with Building and Teacher data'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.6 – 更新后的主页面，包含建筑和教师数据'
- en: '](img/B17189_11_06.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_11_06.jpg]'
- en: Figure 11.6 – Updated main page with Building and Teacher data
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 更新后的主页面，包含建筑和教师数据
- en: In this section, we covered creating a microservice, deploying it as a Docker
    container as well as a web app on a web server, and combining the results of the
    two microservices for a web application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了创建微服务、将其作为 Docker 容器以及 Web 服务器上的 Web 应用程序部署，并将两个微服务的结果结合到一个 Web 应用程序中。
- en: Deploying the Students microservice to GCP Cloud Run
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Students 微服务部署到 GCP Cloud Run
- en: 'So far, we have used the `Students` microservice as a web application with
    a REST API hosted in a flask development server. It is now the time to containerize
    it and deploy it to the **Google Cloud Platform** (**GCP**). GCP has a runtime
    engine (**Cloud Run**) for deploying containers and running them as a service
    (microservice). Here are the steps involved:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已使用 `Students` 微服务作为具有 REST API 的 Web 应用程序，该 API 在 Flask 开发服务器上托管。现在是时候将其容器化并部署到
    **Google Cloud Platform**（**GCP**）了。GCP 有一个运行时引擎（**Cloud Run**），用于部署容器并将它们作为服务（微服务）运行。以下是涉及的步骤：
- en: 'To package the application code of our `Students` microservice in a container,
    we will first identify a list of dependencies and export them to a `requirements.txt`
    file. We will run the following command from the virtual environment of the `Students`
    microservice project:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将我们的 `Students` 微服务的应用程序代码打包到容器中，我们首先确定一个依赖项列表并将它们导出到 `requirements.txt` 文件中。我们将从
    `Students` 微服务项目的虚拟环境中运行以下命令：
- en: '[PRE19]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next step is to build a Dockerfile in the root directory of the project,
    like the one we prepared for our `Grades` microservice. The contents of the Dockerfile
    are as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在项目的根目录中构建 Dockerfile，就像我们为我们的 `Grades` 微服务准备的那样。Dockerfile 的内容如下：
- en: '[PRE20]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To deploy our application on GCP Cloud Run, Dockerfile will suffice. But first,
    we need to build the container image using the GCP Cloud SDK. This will require
    us to create a GCP project using either the Cloud SDK or GCP Console. We explained
    the steps of creating a GCP project and associating a billing account with it
    in the previous chapters. We assume you have created a project with the name `students-run`
    on GCP.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在 GCP Cloud Run 上部署我们的应用程序，Dockerfile 就足够了。但首先，我们需要使用 GCP Cloud SDK 构建容器镜像。这需要我们使用
    Cloud SDK 或 GCP 控制台创建一个 GCP 项目。我们在前面的章节中解释了创建 GCP 项目并将其与计费账户关联的步骤。我们假设您已经在 GCP
    上创建了一个名为 `students-run` 的项目。
- en: 'Once the project is ready, we can use the following command to build a container
    image of our `Students` API application:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目准备就绪，我们可以使用以下命令构建 `Students` API 应用程序的容器镜像：
- en: '[PRE21]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To create an image, we have to provide the tag attribute in the following format:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个镜像，我们必须在以下格式中提供 tag 属性：
- en: '[PRE22]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In our case, the hostname is `gcr.io`, which is based in the United States.
    We can use a locally created image as well, but we must first set the `tag` attribute
    as per the aforementioned format and then push it to the Google registry. This
    can be achieved with the following Docker commands:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的案例中，主机名是 `gcr.io`，它位于美国。我们也可以使用本地创建的镜像，但我们必须首先按照上述格式设置 `tag` 属性，然后将它推送到
    Google 仓库。这可以通过以下 Docker 命令实现：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next step is to run the uploaded image. We can run our container image
    by using the following Cloud SDK command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是运行上传的镜像。我们可以通过以下 Cloud SDK 命令来运行我们的容器镜像：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The execution of our image can be triggered from the GCP console as well. Once
    the container is successfully deployed and running, the output of this command
    (or on a GCP console) will include the URL of our microservice.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们镜像的执行也可以从 GCP 控制台触发。一旦容器成功部署并运行，此命令的输出（或 GCP 控制台）将包括我们的微服务的 URL。
- en: To consume this new version of the `Students` microservice from GCP Cloud Run,
    we will update our web application to switch to use the URL of this newly deployed
    service in GCP Cloud Run. If we test our web application with a locally deployed
    `Grades` microservice and the remotely deployed `Students` microservice, we will
    get the same results as shown earlier in *Figure 11.6* and can perform all operations
    as we did when the `Students` microservice was deployed locally.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 GCP Cloud Run 消费这个新的 `Students` 微服务版本，我们需要更新我们的 Web 应用程序以切换到使用 GCP Cloud
    Run 中新部署服务的 URL。如果我们使用本地部署的 `Grades` 微服务和远程部署的 `Students` 微服务测试我们的 Web 应用程序，我们将得到与前面
    *图 11.6* 中所示相同的成果，并且可以执行所有操作，就像 `Students` 微服务本地部署时一样。
- en: This concludes our discussion on building microservices using different Python
    frameworks, deploying them locally as well as in the cloud, and consuming them
    from a web application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们关于使用不同的 Python 框架构建微服务、在本地以及云中部署它们，并从 Web 应用程序中消费它们的讨论。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced microservices architecture and discussed its
    merits and demerits. We covered several best practices for building, deploying,
    and operationalizing microservices. We also analyzed the development options available
    in Python for building microservices that include Flask, Django, Falcon, Nameko,
    Bottle, and Tornado. We selected Flask and Django to build sample microservices.
    To implement a new microservice, we used Django with its REST framework (DRF).
    This microservice implementation also introduces you to how the Django framework
    works in general. Later, we provided details of how to containerize a newly created
    microservice using Docker Engine and Docker Compose. Finally, we converted our
    `Students` API application to a Docker image and deployed it on GCP Cloud Run.
    We updated the `Students` web application to consume two microservices deployed
    in different parts of the world.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了微服务架构，并讨论了其优点和缺点。我们涵盖了构建、部署和运营微服务的几个最佳实践。我们还分析了在 Python 中构建微服务的开发选项，包括
    Flask、Django、Falcon、Nameko、Bottle 和 Tornado。我们选择了 Flask 和 Django 来构建示例微服务。为了实现一个新的微服务，我们使用了
    Django 及其 REST 框架（DRF）。这个微服务实现还向您介绍了 Django 框架的一般工作方式。稍后，我们提供了如何使用 Docker Engine
    和 Docker Compose 容器化新创建的微服务的详细说明。最后，我们将我们的 `Students` API 应用程序转换为 Docker 镜像，并在
    GCP Cloud Run 上部署。我们还更新了 `Students` 网络应用程序，使其能够消费部署在世界不同地区的两个微服务。
- en: The code examples included in this chapter will provide you with hands-on experience
    in building and deploying microservices for different environments. This knowledge
    is beneficial for anyone who is looking to build microservices in their next projects.
    In the next chapter, we will explore how to use Python to develop serverless functions,
    another new paradigm of software development for the cloud.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的代码示例将为您提供在构建和部署不同环境中的微服务时的实践经验。这些知识对任何希望在下一个项目中构建微服务的人来说都是有益的。在下一章中，我们将探讨如何使用
    Python 开发无服务器函数，这是云软件开发的新范式。
- en: Questions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can we deploy a microservice without a container?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在不使用容器的情况下部署微服务？
- en: Is it appropriate for two microservices to share a single database but with
    a different schema?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个微服务是否应该共享一个数据库，但使用不同的模式？
- en: What is Docker Compose and how does it help to deploy microservices?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose 是什么，它是如何帮助部署微服务的？
- en: Is REST the only format for data exchange for microservices?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST 是否是微服务数据交换的唯一格式？
- en: Further reading
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Hands-On Docker for Microservices with Python*, by Jaime Buelta'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《动手实践：使用 Python 的 Docker 微服务》，作者：Jaime Buelta
- en: '*Python Microservices Development*, by Tarek Ziade'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Python 微服务开发》，作者：Tarek Ziade
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software*, by Eric
    Evans'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《领域驱动设计：软件核心的复杂性处理》，作者：Eric Evans
- en: '*Google Cloud Run quick-start tutorials* for building and deploying microservices,
    available at [https://cloud.google.com/run/docs/quickstarts/](https://cloud.google.com/run/docs/quickstarts/)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Google Cloud Run 快速入门教程》用于构建和部署微服务，可在 [https://cloud.google.com/run/docs/quickstarts/](https://cloud.google.com/run/docs/quickstarts/)
    找到
- en: Answers
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Yes, but it is recommended to deploy it in a container.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，但建议将其部署在容器中。
- en: Technically, it is feasible, but it is not a best practice. Database failure
    will bring both microservices down.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从技术上讲，这是可行的，但并不是最佳实践。数据库故障将导致所有微服务都崩溃。
- en: Docker Compose is a tool for deploying and running container applications using
    a YAML file. It provides an easy format to define different services (containers)
    with deployment and runtime attributes.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose 是一个使用 YAML 文件部署和运行容器应用的工具。它提供了一个简单的格式来定义不同的服务（容器）及其部署和运行时属性。
- en: A REST API is the most popular interface for data exchange for microservices,
    but not the only one. Microservices can also use RPC and events-based protocols
    for data exchange.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST API 是微服务之间数据交换最流行的接口，但并非唯一。微服务还可以使用 RPC 和基于事件的协议进行数据交换。
