- en: Chapter 11. Class Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Python object is an instance of a class. A **class** defines the behavior
    of an object via the method functions. In this chapter, we'll look at creating
    our own classes and our own objects. We'll start by looking at the basics of creating
    classes and objects. Once we've seen the essential tools, we can summarize some
    of the ways that we can class definitions to create objects, and how objects should
    interact to create the behavior we intend.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at some elements of more sophisticated class definition. Advanced
    topics will include the concepts of class methods and static methods. An entire
    book can be written on advanced object-oriented programming in Python, so we'll
    take a broad, but shallow, approach to looking at class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at the built-in abstract base classes. We can use these to simplify
    our own class definitions. In many cases, we have container-like classes that
    can leverage a base class, saving us some programming and assuring a seamless
    fit with other Python features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of the object-oriented program is the class definition. The class statement
    creates an object that is used to create instances of the class. When we create
    a new class, `SomeClass`, we can then use that `SomeClass()` function to create
    objects that share the common definitions of the class. This is the way the built-in
    classes all work; for example, the `int()` function creates an instance of the
    `int` class.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, a `class` statement includes the method functions that describe the
    behavior of each instance. In addition to ordinary methods, there are several
    varieties of "special" methods which are intimately bound to the way Python operates.
  prefs: []
  type: TYPE_NORMAL
- en: We aren't obligated—in any formal way—to provide specific attributes (also called
    instance variables) for a class. The instance variables of an object are flexible,
    and are not defined in advance.
  prefs: []
  type: TYPE_NORMAL
- en: The initial clause of a `class` statement provides the class name. It can also
    name any superclasses, from which features are inherited. The bulk of the class
    body contains method definitions, created with the indented `def` statements.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we don't need to provide a suite of statements. We often create
    customized exception classes like this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've provided a new class name, `MyAppError`, and specified
    that it inherits the features of the `Exception` class. We don't need to make
    any changes to that base definition; since we must provide an indented suite of
    statements, we use the pass statement to complete the syntax of the `class` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Since this class works like any other exception, we can use statements like
    `raise MyAppError("Some Message")` to raise an instance of this new class of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the suite of statements in a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The suite of statements inside a `class` statement is generally a collection
    of method definitions. Each method is a function that's bound to the class. The
    suite of statements can also include assignment statements; these will create
    variables that are part of the class definition as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple class for an (*x*, *y*) coordinate pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've provided a class name, `Point`. We haven't explicitly provided a superclass;
    by default our new class will be a subclass of `object`. By convention, the names
    of most built-in classes, like `object`, begin with lowercase letters. All of
    the other classes that we will define should begin with uppercase letters; hence,
    our name of `Point`. We've also provided a minimal docstring for this class. In
    [Chapter 14](ch14.html "Chapter 14. Fit and Finish – Unit Testing, Packaging,
    and Documentation"), *Fit and Finish – Unit Testing, Packaging, and Documentation*,
    we'll look at expanding this docstring.
  prefs: []
  type: TYPE_NORMAL
- en: We've defined two methods in the class. The first has a special name of `__init__()`.
    The first parameter to any method defined within a class must include the instance
    variable. This variable, usually `self`, will be the reference to the relevant
    object. When we assign a value to the variable `self.x`, this will set the `x`
    attribute of a specific instance of the `Point` class. The instance variable is
    provided implicitly when the method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of any formal definition of the allowed instance variables, Python relies
    on the `__init__()` special method to initialize appropriate instance variables.
    By default, an object can have additional attributes added at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method has a special name of `__repr__()`. To be a proper method,
    the first parameter must be the instance variable, `self`. This method must return
    a string that represents our coordinate pair. If we don''t override this special
    method, we''ll get a default string representation that looks like this: `<__main__.Point
    object at 0x100623e10>`. Our implementation uses `self.__class__.__name__` to
    leverage the class of an object so that any subclass will have the proper class
    name inserted into the resulting output.'
  prefs: []
  type: TYPE_NORMAL
- en: Special method names are ubiquitous in Python. Using them allows a seamless
    integration between our classes and built-in Python features. There are a large
    number of special method names—too many to review in this book. All such names
    begin and end with `__` (two underscores). It's easy to avoid conflicts with this
    naming convention. There is no good reason to use `__` names that are part of
    our application programming; any name in this form that we choose may turn out
    to be a hidden feature of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we did not include placeholder docstrings on the two method functions.
    We've omitted them to keep the example short, and focused on class definitions.
    In general, every method of a class will have a docstring to provide a pithy,
    helpful summary of that method.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Variables, Assignment and Scoping Rules"),
    *Variables, Assignment and Scoping Rules*, we introduced the concept of a namespace
    as a container for variables. The `self` variable is the object, which is a namespace
    into which we can insert attribute variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an instance of a class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've used the class name, `Point`, like a function. An empty object is created
    first. Then the argument values are provided to the `__init__()` special method
    to initialize that empty object. Note that we did not explicitly provide a value
    for the instance variable, `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the `__repr__()` special method, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When an object is printed, the built-in `repr()` function is applied to get
    a string representation of the object. This built-in function relies on the `__repr__()`
    special method of an object to provide a string representation for the object.
    The object, `p_1`, was implicitly assigned to the instance variable, `self`, when
    evaluating the `__repr__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Our implementation of the `__repr__()` special method produced a string with
    the *x* and *y* coordinate values. We used `.0f` as the format specification,
    providing zero places to the right of the decimal point for the `x` and `y` attributes
    of the self instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using instance variables and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Point` class definition in the previous section included only two special
    methods. We''ll now add a third method that''s not special. Here''s the third
    method for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This method function accepts a single parameter, named `point`. The body of
    this method function uses `math.hypot()` to compute the direct distance between
    two points on the same plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We've created two `Point` objects. When the `p_1.dist(p_2)` expression is evaluated,
    the object that was assigned to the `p_1` variable will be assigned to the `self`
    variable. This is the instance of `Point` that's doing the relevant processing.
    The argument to the `dist()` method, assigned to the `p_2` variable, will be assigned
    to the `point` parameter variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we evaluate `obj.method()`, the `obj` object will be the `self` instance
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the objects we create are mutable. Here''s another method of the
    `Point` object—this changes the internal state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method requires two values which are used to offset the coordinates of
    the `Point` object. The method assigns new values to the `x` and `y` attributes
    of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what happens when we use this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've evaluated the offset method associated with object `p_1`. As noted earlier,
    the `self` instance variable will be the same object referred to by `p_1`. When
    we assign a value to `self.x`, that will mutate the object referred to by `p_1`,
    setting `p_1.x`.
  prefs: []
  type: TYPE_NORMAL
- en: Pythonic object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen a few important features of Python's approach to object-orientation.
    Perhaps the most important is that Python lacks a static binding between variable
    name and type; any type of object can be assigned to any variable. Names are not
    resolved statically by a compiler. Python's dynamic name resolution means that
    we can think of our programs as being entirely generic with respect to class.
  prefs: []
  type: TYPE_NORMAL
- en: When we evaluate `obj.attribute` or `obj.method()`, there are two steps. First
    the name, `attribute` or `method`, must be resolved. Second the referenced attribute
    or method is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: For the name resolution step, there are several namespaces that are searched
    to determine what the name means.
  prefs: []
  type: TYPE_NORMAL
- en: The local namespace of the `obj` instance is searched to resolve the name. The
    object's namespace is available as `obj.__dict__`. Attribute names (and values)
    are generally found in the object's own namespace. Methods, on the other hand,
    are not generally part of an object instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the name isn't local to the object, the local namespace of the object's class
    is searched. The class namespace is available as `obj.__class__.__dict__`. Method
    names are generally found in the class's namespace. An attribute of the class
    may also be found here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the name isn't in the class, the superclasses are searched for the name.
    The entire lattice of superclasses is assembled into the `obj.__class__.__mro__`
    value. This defines the **Method Resolution Order** (**MRO**); each of the classes
    in this sequence is searched for the name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the name has been found, Python must determine the value. For names that
    do not refer to callable methods, that is, attributes—the object referred to by
    the name is the value of the attribute. A name that refers to a callable method
    will have argument values bound and it will be evaluated as a function. The result
    of that function is the value.
  prefs: []
  type: TYPE_NORMAL
- en: The "search" described previously relies on the built-in `dict` class. This
    uses hashing to make an extremely fast determination of the presence or absence
    of a name. There's remarkably little performance cost from the sophisticated and
    flexible class behavior available in Python.
  prefs: []
  type: TYPE_NORMAL
- en: If an object of an inappropriate type is provided at run-time, a method name
    or attribute name won't be found in the object, and an `AttributeError` exception
    is raised. In our preceding example, we can try to evaluate `p_1.copy()`. The
    `copy` name is not defined in our class nor any of the superclasses, so an `AttributeError`
    exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to do type casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Python variables are merely names attached to objects, the underlying
    objects are very strongly typed. There's no way to assign a new value to the `__class__`
    name that defines the class of an object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type casts** are required by some statically-compiled languages to make it
    possible to create generic data structures. In those languages, we can cast a
    reference from one type to another type. Because of the dynamic nature of method
    resolution, there''s no need for this kind of type casting in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All Python collections can contain objects of mixed types. We can easily evaluate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The lambda expression, `x+1`, can be applied to an `int`, a `float`, or a `complex`
    type without resorting to any kind of type cast operation. This works because
    each class provides appropriate special method functions to implement the addition
    of an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for encapsulation and privacy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common question about Python class definitions is how we can achieve **encapsulation**
    if all attribute and member names are public. Some programmers worry about this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created an object, `p_2`. Then we modified an attribute value of the
    object without using any of the object''s method functions. This is not a failure
    to use the encapsulation design principle: the class has a properly encapsulated
    design. The class doesn''t have an implementation that can be checked statically
    by a compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pythonic principle is summarized with the following observation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*We''re all adults here.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There's no compelling reason to create the complexity of private, public, and
    protected methods and attributes of an object, because Python code is distributed
    as source and anyone can inspect the source to see what the consequences of bending
    or breaking encapsulation might be. The preferred approach is to write clear docstrings
    for classes and methods, and to provide unit tests to demonstrate that attributes
    and methods are being used properly.
  prefs: []
  type: TYPE_NORMAL
- en: We can prefix a name with a single `_` to indicate that the method or attribute
    is not part of the public interface to a class. Python documentation tools will
    politely ignore these names so that these implementation details can be changed
    freely. Names that begin with `_` are considered to be subject to change without
    notice; depending on these names may lead to a program breaking in unexpected
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some languages, "getter and setter" methods are required to expose the attributes
    of a class. In Python, we can use the object''s `__dict__` directly, simplifying
    introspection. We can also use the built-in functions `getattr()`, `setattr()`,
    and `delattr()`to work with attribute names as strings. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This shows how we can get an attribute's names and values dynamically. In the
    first example, we looked at the object's internal namespace, `__dict__`, to get
    the attributes. In the second example, we used the built-in `getattr()` function
    to get the value of an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Using properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python allows us to create methods that can be used as if they were attributes.
    This gives us very pleasant syntax for getting a derived value from an object.
    A method that appears to be an attribute is called a **property**. We''ll extend
    our `Point` class with two more methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've defined two functions using the `@property` decorator. This decorator
    can be used with a function that has only the instance variable, `self`, as a
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can use these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We've accessed these methods as if they were simple attributes of the object,
    `p`. Using `p.r` and `p.`θ can be more pleasant than having to write `p.r()` and
    `p.`θ`()` in a complex formula. The preceding properties are explicitly *read-only*.
    We get an exception if we try to assign a value to `p.r` or `p.`θ.
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to the topic of the `@property` decorator in [Chapter 13](ch13.html
    "Chapter 13. Metaprogramming and Decorators"), *Metaprogramming and Decorators*.
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance to simplify class definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use **inheritance**—reuse of code from a superclass in subclasses—which
    can simplify a subclass definition. In an earlier example, we created the `MyAppError`
    class as a subclass of `Exception`. This means that all of the features of `Exception`
    will be available to `MyAppError`. This works because of the three-step search
    for a name: if a method name is not found in an object''s class, then the superclasses
    are all searched for the name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a subclass which overrides just one method of the parent
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a subclass of `Point` named `Manhattan_Point`. This class has
    all of the features of a `Point`. It makes a single change to the parent class.
    It provides a definition for the `dist()` method that will override the definition
    in the `Point` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that shows how method resolution works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created two objects: `p_1` is an instance of `Point`, and `p_2` is an
    instance of `Manhattan_Point`. We didn''t write the `__init__()` method of `Manhattan_Point`;
    it was inherited from `Point`. When we evaluate `p_1.dist()`, we''re using the
    `dist()` method that''s part of `p_1`''s class, `Point`. When we evaluate `p_2.dist()`,
    on the other hand, we''re using the `dist()` method that''s part of `p_2`, which
    is the method of `Manhattan_Point`.'
  prefs: []
  type: TYPE_NORMAL
- en: Reuse through inheritance is a way to guarantee that several classes have identical
    behavior. This is an import object-oriented design principle, sometimes called
    the **Liskov Substitution Principle** (**LSP**). An instance of `Manhattan_Point`
    can be used anywhere an instance of `Point` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple inheritance and the mixin design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance is sometimes visualized as a simple hierarchy of related classes.
    If each subclass has at most one parent class, there's a chain of relationships
    between any given subclass and the `object` superclass. This single inheritance
    model isn't always appropriate. In some cases, a class will include a number of
    disparate features that don't fit the linear ancestry idea.
  prefs: []
  type: TYPE_NORMAL
- en: The `collections` abstract base class module, `collections.abc`, contains a
    number of examples of multiple inheritance. The overall design pattern here is
    to have a central class hierarchy that defines the essential features of the `List`,
    `Set`, or `Mapping` collections. Other features are included via reusable **mixin**
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `Set` class is a subclass of `Container`. Mixed into this definition
    are features from the `Sized` and `Iterable` class definitions. The `Sized` mixin
    incorporates the `__len__()` special method. The `Iterable` mixin incorporates
    the `__iter__()` special method.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to the final class being an assembly of reusable superclasses. We
    can leverage this to create our own classes which contain different mixtures of
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python manages multiple inheritance by relying on the order in which classes
    are named in the `class` statement. This builds the `__mro__` value used to search
    for names in the inheritance lattice. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've imported one of the abstract base classes. When we look at the MRO, we
    see that Python will search for a name in `Mapping`, `Sized`, `Iterable`, `Container`,
    and `object`, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: When designing with mixin classes like this, we generally divide responsibility
    among the various classes so that we avoid any name collisions between the various
    superclasses that are used to assemble the final class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Using class methods and attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, we expect objects to be stateful and classes to be stateless. While
    typical, a stateless class is not a requirement. We can create class objects which
    have attributes as well as methods. A class can also have mutable attributes,
    in the rare cases that this is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'One use for class variables is to create parameters that apply to all instances
    of the class. When a name is not resolved by the object instance, the class is
    searched next. Here is a small hierarchy of classes that rely on a class-level
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Units` class definition extends the `float` class. It introduces a class-level
    attribute named `units`. It overrides the `__repr__()` special method of `float`.
    This method uses the superclass `__repr__()` method to get the essential text
    representation of a value. It then includes the value of the `units` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: When we evaluate `self.units`, there will be a three-step search for this name.
    An instance of `Height` will not provide the `units` attribute. The `Height` class,
    however, will provide the `units` attribute; the value will be `inches`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create an instance of a `Height` object, we''ll see the units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When we print an instance of `Height`, the `print()` function will use the built-in
    `repr()` function to get a string representation. The `repr()` function uses the
    `__repr__()` special method of an object. We've overridden the `__repr__()` special
    method to include the text from the `units` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Since all attributes are publicly available, we can write something like `Height.units=
    "furlongs"`, which will cause all further uses of objects of the `Height` class
    to display different units. Changing the class level attributes is generally a
    bad idea, but it is not prohibited in any formal way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the policy: *We''re all adults here.*'
  prefs: []
  type: TYPE_NORMAL
- en: Using mutable class variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some applications may call for a properly mutable variable that''s part of
    an overall class. A class-level attribute name is found during the three-step
    search for a name: first the object, then the class, then the superclasses. This
    means that we can successfully evaluate `self.class_level_name`, even if the name
    is not in the object instance, but is defined in the class or one of the parent
    superclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: If we try to assign a class-level variable, however, using a name like `self.class_level_name`,
    we'll be creating a new attribute in the instance. The class-level name will no
    longer be visible because the instance name will now be found first.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to update a class-level variable, we must explicitly use the class
    name, avoiding the self instance variable. Here''s a class which assigns a sequence
    number to each instance that is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a class-level variable, `counter`, which is initialized to
    zero when the class is created. The `__init__()` method will increment the class-level
    `counter` attribute. In order to avoid creating a variable in the instance, the
    class name, `Sample`, is used instead of `self`. In addition to updating `Sample.counter`,
    this method also sets two attributes of the instance: the current value of `Sample.counter`
    is assigned to the sequence attribute, and the given value for the measure is
    also saved.'
  prefs: []
  type: TYPE_NORMAL
- en: It's essential to note that, inside a method function, we can use `self.counter`
    and `Sample.counter` to access the same object. This will be true when there's
    no instance variable named `counter`. In order to assign a variable in the class,
    however, we can only use `Sample.counter`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing static methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, we'll include a method in a class that does not actually depend
    on any instance variables. In many languages, this kind of method is called **static**.
    Using the word *static* to refer to class-level features comes from C++ and Java;
    it has also been adopted for Python.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have any syntax complications for class-level attributes. As we've
    seen in previous examples, any attribute that's not part of the instance will
    be searched for in the class; the distinction between instance variables and class
    variables doesn't require any additional syntax.
  prefs: []
  type: TYPE_NORMAL
- en: A class-level method, however, cannot have an instance variable as the first
    defined parameter. This is an important syntactic change. We use the `@staticmethod`
    decorator to annotate methods that do not have an instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll expand the `Sample` class shown earlier to include a validity check.
    Checking for validity isn''t a proper instance method: we should not create an
    instance with invalid values. We''ll add this method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We've marked this method with the `@staticmethod` decorator. The method does
    not have a `self` variable, since it doesn't apply to an instance of the class.
    This method can only be invoked via `Sample.validate(some_value)`. The method
    will confirm that the value of the `measure` parameter is valid, or it will raise
    an exception which details the reason why the value is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might use this method to create and use an instance of the `Sample` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll start the `try` statement by simply evaluating the `Sample.validate()`
    method. If this method does not raise an exception, the given value is valid.
    If this method does raise an exception, we''ll write an error message and continue
    processing. Often, we''ll have this kind of processing in a file input loop: we''ll
    process good data and write messages about bad data to the log.'
  prefs: []
  type: TYPE_NORMAL
- en: Python also offers a `@classmethod` decorator. This is a more specialized tool.
    It provides the class as an argument instead of the instance. It allows us to
    write a method that can work with a variety of classes. This might be used in
    a metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to the topic of decorators in [Chapter 13](ch13.html "Chapter 13. Metaprogramming
    and Decorators"), *Metaprogramming and Decorators*.
  prefs: []
  type: TYPE_NORMAL
- en: Using __slots__ to save storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default behavior of the `object` superclass is to create a `dict` for an
    object's attributes. This provides fast resolution of names. It means that an
    object can have attributes added and changed very freely. Because a hash is used
    to locate the attribute by name, the internal `dict` object can consume quite
    a bit of memory.
  prefs: []
  type: TYPE_NORMAL
- en: We can modify the behavior of the `object` superclass by providing a list of
    specific attribute names when we create a class. When we assign these names to
    the specially named `__slots__` variable, these will be the only available attributes.
    A `dict` is not created, and memory use is reduced considerably.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re working with very large datasets, we might need to use a class that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This class uses the `__slots__` attribute to define the only two attributes
    that can be used for an instance. This avoids using a `dict` to represent the
    attributes of instances of this class.
  prefs: []
  type: TYPE_NORMAL
- en: The ABCs of abstract base classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex
    Data Types*, we looked at the `collections` module, which offers a number of variations
    on the mapping theme. These different kinds of collections are built on a foundation
    of abstract base classes, defined in the `collections.abc` module. Looking at
    this module exposes the common features, and the differences, among the collections.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how `Sequence` is the basis for the built-in tuple `class`, and `MutableSequence`
    is the basis for the built-in `list`. The `Set` abstract base class is the basis
    for the `frozenset` built-in class, and `MutableSet` is the basis for the `set`
    class. There's no concrete implementation of the `Mapping` class, but the `dict`
    class is the built-in implementation of the `MutableMapping` class.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to implement a unique kind of collection, one not already provided
    by the `collection` module, we're encouraged to use the `collections.abc` module
    as a starting point. If we leverage these common base classes, we're assured that
    our new collection will fit seamlessly with other Python features.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a callable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract base class `Callable` is defined in the `collections.abc` module.
    This class doesn't seem to have much to do with collections. It's a useful abstraction,
    nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: A class that derives from `Callable` must define the `__call__()` special method.
    The objects created from this class are callable, and can be used as if they were
    functions. This allows us to create fairly complex functions based on a class
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a function to compute the *n*th Fibonacci number. There are three relevant
    rules for computing this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a callable class](img/B03671_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first two Fibonacci numbers are defined as zero and one. Other Fibonacci
    numbers are the sum of the two preceding numbers. If we use a naïve algorithm,
    it's quite expensive to compute a large Fibonacci number. We can, however, define
    a `Callable` that uses an internal cache to reduce the workload to a manageable
    level. This technique is called **memoization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class definition for a `Callable` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a class, `Fibonacci`, which extends the `Callable` abstract base
    class. The `__init__()` method initializes a cache with two defined values for
    Fibonacci numbers. The `__call__()` method only computes a Fibonacci number, `n`,
    if the number is not already in the cache. It does this by recursive calls to
    compute Fibonacci numbers `n-1` and `n-2`. Once the result is in the cache, it
    can be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create an instance of this class, we have created a callable function.
    Given that function, we can compute Fibonacci numbers. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We've created an instance of the `Fibonacci` class, and assigned this to the
    variable `fib`. The `fib` object is callable; when we evaluate it with an argument
    value of six, we get the seventh Fibonacci number.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve seen the basics of defining a class and using objects
    of that class. We''ve looked at how we create the methods that define the behavior
    of a class. The internal state of the class is the result of the various methods:
    in Python we don''t formally declare instance variables. We generally rely in
    the `__init__()` method to provide the initial or default values for the object''s
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at the way Python resolves attribute and method names by searching
    the object, the class, and then the superclasses. The method resolution order
    is based on the order the classes are presented in the initial `class` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The `@properties` decorator can be used to create methods that have the same
    syntax as an attribute. This can help clarify otherwise complex algorithms. We've
    also looked at the `@staticmethod` decorator, which is used to create methods
    that belong to the class as a whole and are independent of any specific instance
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: In order to save some memory, we can use the `__slots__` variable. This will
    construct an object that isn't based on a `dict` for storing attributes. The object
    is quite a bit smaller, but also suffers from some limitations.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how we can create a callable object. This is an object that
    can be used like a function, but has all of the powerful features of an object.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](ch12.html "Chapter 12. Scripts, Modules, Packages, Libraries,
    and Applications"), *Scripts, Modules, Packages, Libraries, and Applications*,
    we'll look at how we can package our functions and classes into modules. We'll
    see how modules are grouped into packages. The *Python Standard Library* is a
    collection of packages that we install with Python. We'll look at the tiny distinctions
    between modules and script files, and how we can create more complete Python applications.
  prefs: []
  type: TYPE_NORMAL
