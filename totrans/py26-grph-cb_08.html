<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 8. Data In and Data Out"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Data In and Data Out</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a new file on the hard drive</li><li class="listitem" style="list-style-type: disc">Writing data to a newly created file</li><li class="listitem" style="list-style-type: disc">Writing data to multiple files</li><li class="listitem" style="list-style-type: disc">Adding data to existing files</li><li class="listitem" style="list-style-type: disc">Saving a Tkinter drawing shape to disk</li><li class="listitem" style="list-style-type: disc">Retrieving Python data from disk</li><li class="listitem" style="list-style-type: disc">Simple mouse input</li><li class="listitem" style="list-style-type: disc">Storing and retrieving a mouse-drawn shape</li><li class="listitem" style="list-style-type: disc">A mouse-line editor</li><li class="listitem" style="list-style-type: disc">All possible mouse actions</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec01"/>Introduction</h1></div></div></div><p>Now we address the technicalities of storing and retrieving graphic data on storage media like hard disks. Besides raster images, we need to be able to create, store, and retrieve vector graphics of ever increasing complexity. We also want techniques for transforming portions of raster images into vector images.</p><p>Till now, all our programs have carried their data inside the source code. This limits the complexity of the data lists and arrays that we can conveniently type in a few minutes. We do not want this limitation. We want to be able to handle and manipulate blocks of raw data that may be hundreds of megabytes in size if necessary. Typing in such files by hand is unthinkably inefficient. There are better ways of doing things. This is what named-files, data streams, and hard drives are for.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creation of a new file on a hard drive"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec02"/>Creation of a new file on a hard drive</h1></div></div></div><p>We write and execute the simplest program that will create a data file on disk.<a id="id220" class="indexterm"/>
</p><p>Till now, it was not required to store any data on our hard drive or a USB memory stick. Now we work through a series of simple exercises in storing and retrieving data in files on storage media. Then we use these methods to save and edit Tkinter lines in a practical way. Tkinter lines can be a large collection of separate line segments and shapes. If we are developing a drawing of complexity and richness, it is vital that we be able to store and retrieve work in progress.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec01"/>How to do it...</h2></div></div></div><p>Write, save, and execute the program shown in the usual way. When you run the program, all you will observe from a successful execution is a short pause after you have clicked<span class="emphasis"><em> Enter</em></span>. The execution will terminate without any messages. However, a new file called<code class="literal"> brand_new_file.dat</code> now exists on the destination directory<code class="literal"> constr</code>. We should open<code class="literal"> constr</code> and verify that this is indeed the case.</p><div class="informalexample"><pre class="programlisting"># file_make_1 .py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
filename = "constr/brand_new_file.dat"
FILE = open(filename,"w")
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec02"/>How it works...</h2></div></div></div><p>This minimalist-looking program achieves the following objectives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It verifies that Python's file IO functions are present and working. No modules need to be imported</li><li class="listitem" style="list-style-type: disc">It demonstrates that there is nothing unusual about the way Python accesses data files on storage devices</li><li class="listitem" style="list-style-type: disc">It proves that the operating system obeys file creation directives from Python</li></ul></div></div><div class="section" title="How to read the newly created file"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec02a"/>
How to read the newly created file
</h2></div></div></div><p>Once a file has been created, it can then be read. So a program to read an existing file on disk would be:<a id="id221" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># file_read_1 .py
# &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
filename = "constr/brand_new_file.dat"
FILE = open(filename,"r")
</pre></div><p>As you can see, the only difference is the<code class="literal"> r</code> instead of the<code class="literal"> w</code>.</p><p>Note that Python reads and writes files in more than one format. A<code class="literal"> b</code> as in<code class="literal"> rb</code> and<code class="literal"> wb</code> reads and writes as byte or binary format. These are the<code class="literal"> 1s</code> and<code class="literal"> 0s</code> in each byte.<code class="literal"> r</code> and<code class="literal"> w</code> without the<code class="literal"> b</code> as in our examples tells the Python interpreter that it must interpret the bytes as ASCII characters. The only point we need to remember is to keep the formats separate.<a id="id222" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Writing data to a newly-created file"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec03"/>Writing data to a newly-created file</h1></div></div></div><p>We now create a file and then write a small amount of data to it. The value of these very, very simple recipes is that when we are trying some task that is complex and things do not work as expected, the simple one-action-only test programs allow us to break our problem down into simple tasks that we can gradually add complexity to, verifying the validity of each new change. This is a tried and trusted philosophy used by many of the best programmers.<a id="id223" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># file_write_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
# Let's create a file and write it to disk.
filename = "/constr/test_write_1.dat"
filly = open(filename,"w") # Create a file object, in write # mode
for i in range(0,2):
filly.write("everything inside quotes is a string, even 3.1457")
filly.writelines("\n")
filly.write("How will stored data be delimited so we can read \ chunks of it into elements of list, tuple or dictionart?")
filly.writelines("\n")
#filly.close()
</pre></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec03"/>How it works...</h2></div></div></div><p>The important thing to note at this point is that the newline character<code class="literal"> \n</code> is the natural way by which Python separates variables. Space characters will also be used as number or character value separators or delimiters.<a id="id224" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Writing data to multiple files"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec04"/>Writing data to multiple files</h1></div></div></div><p>We see here that opening and writing data to a series of separate files is, as we have come to expect from Python, very simple and straightforward. Once we have seen an example of the correct syntax, it just works.<a id="id225" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># file_write_2.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
# Let's create a file and write it to disk.
filename_1 = "/constr/test_write_1.dat"
filly = open(filename_1,"w") # Create a file object, in # write mode
filly.write("This is number one and the fun has just begun")
filename_2 = "/constr/test_write_2.dat"
filly = open(filename_2,"w") # Create a file object, in # write mode
filly.write("This is number two and he has lost his shoe")
filename_3 = "/constr/test_write_3.dat"
filly = open(filename_3,"w") # Create a file object, in # write mode
filly.write("This is number three and a bump is on his knee")
#filly.close()
</pre></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec04"/>How it works...</h2></div></div></div><p>The value of this example is that it provides examples of correct debugged syntax. So it is available for reuse and modification with the minimum of bother.<a id="id226" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Adding data to existing files"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec05"/>Adding data to existing files</h1></div></div></div><p>We test three ways of writing data to existing files in order to discover some basic rules of data storage.<a id="id227a" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># file_append_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
# Open an existing file and add (append) data to it.
filename_1 = "/constr/test_write_1.dat"
filly = open(filename_1,"a") # Open a file in append mode
filly.write("\n")
filly.write("This is number four and he has reached the door")
for i in range(0,5):
filename_2 = "/constr/test_write_2.dat"
filly = open(filename_2,"a") # Create a file in append mode
filly.write("This is number five and the cat is still alive")
filename_3 = "/constr/test_write_2.dat"
filly = open(filename_3,"w") # Open an existing file in # write mode
# The command below WILL fail "w" is really "overwrite"
filly.write("This is number six and they cannot find the fix")
</pre></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec05"/>How it works...</h2></div></div></div><p>What make up the first method are two things: firstly, we open the file for appending ("a") which means we will add data to what is already in the file. Nothing will be destroyed or overwritten. Secondly, we separate the new data from the old with the line<a id="id228" class="indexterm"/>
</p><p>
<code class="literal">filly.write("\n")</code>
</p><p>The second method works, but is a very bad practice because there is no way of separating different entries.</p><p>The third method wipes out whatever was previously stored in the file.</p></div><div class="section" title="So remember the difference between write and append"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec06a"/>So remember the difference between write and append</h2></div></div></div><p>If we keep the above three methods clear in our heads, we will be able to successfully store and retrieve our data without mishap and frustration.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Saving a Tkinter-drawing shape to disk"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec06"/>Saving a Tkinter-drawing shape to disk</h1></div></div></div><p>When we create an elaborate shape using Tkinter, we often want to preserve that shape for later use. In fact, we would like to build up a whole library of shapes. If other people do similar work, we may want to share and exchange shapes. Such community efforts are the key to the success of the most powerful and successful open-source programs.<a id="id229" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec06"/>Getting ready</h2></div></div></div><p>If we go back to the example titled "Drawing Intricate Shapes the Curly Vine", in<span class="emphasis"><em> Chapter 2, Drawing Fundamental Shapes</em></span>, we see that the shapes are defined by the two coordinate lists<code class="literal"> vine_x</code> and<code class="literal"> vine_y</code>. We are going to first save these shapes in a disk file and then see what is needed to successfully retrieve and draw them.</p><p>Create a folder<code class="literal"> /constr/vector_shapes</code> on your hard drive ready to receive your stored data.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec07"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.</p><div class="informalexample"><pre class="programlisting"># save_curly_vine_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
vine_x = [23, 20, 11, 9, 29, 52, 56, 39, 24, 32, 53, 69, 63, \ 47, 35, 35, 51,\
82, 116, 130, 95, 67, 95, 114, 95, 78, 95, 103, 95, 85, 95, 94.5]
vine_y = [36, 44, 39, 22, 16, 32, 56, 72, 91, 117,125, 138, 150, \ 151, 140, 123, 107,\
92, 70, 41, 5, 41, 66, 41, 24, 41, 53, 41, 33, 41, 41, 39]
vine_1 = open('/constr/vector_shapes/curley_vine_1.txt', 'w')
vine_1.write(str(vine_x ))
vine_1.write("\n")
vine_1.write(str(vine_y ))
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec08"/>How it works...</h2></div></div></div><p>The first thing to note is that stored data does not have a 'type' it is just text characters. So any data being appended to an open file must be converted into string format using the string conversion function<code class="literal"> str(some_integer_or_float_object)</code>.<a id="id230" class="indexterm"/>
</p><p>The second thing to note is that storing the whole list as a list object, like<code class="literal"> str(vine_x)</code>, is the best way to do things because when stored this way it can be read back directly as a whole line read into a similar list object see the next recipe to how to do this. In typical Python fashion, the simple and obvious method always seems to be the best.</p></div><div class="section" title="Storing commands"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec09a"/>Storing commands</h2></div></div></div><p>The problem we face when retrieving lists of mixed integer and floating point data is that it is stored as a long string of characters. So how do we get Python to convert the long lists of characters that include square brackets, commas, spaces and new-line characters, into a normal Python numerical list? We want our drawing back undamaged. There is a lovely function<code class="literal"> eval()</code> that does this effortlessly.<a id="id231" class="indexterm"/>
</p><p>There is another method called pickle that does the same thing.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Retrieving Python data from disk storage"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec07"/>Retrieving Python data from disk storage</h1></div></div></div><p>We retrieve two lists<code class="literal"> vine_x</code> and<code class="literal"> vine_y</code> from the stored file<code class="literal"> curley_vine_1.txt</code>. We want them to be in exactly the same form they were in before they were sent for storage.<a id="id232" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec09"/>Getting ready</h2></div></div></div><p>The preparation for this recipe was done by running the previous program<code class="literal"> save_curly_vine_1.py</code>. If this ran successfully, there will be a file<code class="literal"> curly_vine_1.txt</code> inside<code class="literal"> /constr/vector_shapes</code>. If you open the text file you will see two lines, the first line being the string representation of our original<code class="literal"> vine_x</code> and similarly the second line of this file will represent<code class="literal"> vine_y</code>.</p><div class="informalexample"><pre class="programlisting"># retrieve_curly_vine_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
#vine_x = []
vine_1 = open('/constr/vector_shapes/curley_vine_1.txt', 'r')
vine_x = eval(vine_1.readline())
vine_y = eval(vine_1.readline())
# Tests to confirm that everything worked.
print "vine_x = ",vine_x
print vine_x[31]
print "vine_y = ",vine_y
print vine_y[6]
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec10"/>How it works...</h2></div></div></div><p>This works so simply and elegantly because of the<code class="literal"> eval()</code> function. The documentation says: "The<span class="emphasis"><em> expression</em></span> argument is parsed and evaluated as a Python expression" and "The return value is the result of the evaluated expression". This is a way of saying that the text inside the brackets is treated as if it were plain Python expressions and executed as such. In our particular example, the string inside the curly brackets is interpreted as a list of numbers, not characters which is what we desire.<a id="id233" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Simple mouse input"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec08"/>Simple mouse input</h1></div></div></div><p>We now develop code that helps to draw complicated shapes by capturing mouse clicks on electronic graph paper rather than with a pencil, eraser, and sheets of paper made from dead trees. We break this complex task into simple steps covered by the next three recipes.<a id="id234" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># mouseclick_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
frame = Frame(root, width=100, height=100)
def callback(event):
print "clicked at", event.x, event.y
frame.bind("&lt;Button-1&gt;", callback)
frame.grid()
root.mainloop()
root.destroy()
</pre></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec11"/>How it works...</h2></div></div></div><p>Clicking a mouse button is referred to as an event. If we want our program to perform some actions within our program, then we need to write a<code class="literal"> callback</code> function that is called whenever the event occurs. Older terminology for<code class="literal"> callback</code> was "interrupt service routine".<a id="id235" class="indexterm"/>
</p><p>The line<code class="literal"> frame.bind("&lt;Button-1&gt;", callback)</code> says in effect:</p><p>"Make a connection (bind()) between the event, which is the click of the left button on the mouse<code class="literal"> (&lt;Button-1&gt;)</code>, and the function called<code class="literal"> callback"</code>. You could name this function anything you like, but the word callback makes the code easier to understand.</p><p>The final point to note is that the variables<code class="literal"> event.x</code> and<code class="literal"> event.y</code> are reserved for recording the x-y coordinates of the mouse. In this specific<code class="literal"> callback</code> function we print out the position, in a frame called "frame", of the mouse when clicked.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec12"/>There's more...</h2></div></div></div><p>We build on the use of mouse-triggered<code class="literal"> callback</code> functions in the next two recipes with the objective of producing a shape-tracing tool.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Storing and retrieving a mouse-drawn shape"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec09"/>Storing and retrieving a mouse-drawn shape</h1></div></div></div><p>We make a program that lets you create a shape through the use of the mouse and by means of three buttons we can store the shape on disk, clear the canvas and then recall and display the shape on the screen.<a id="id236" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec13"/>Getting ready</h2></div></div></div><p>Ensure you have created a folder call<code class="literal"> constr</code> because this is where the code in our program expects to be able to save the shape drawn. It is also where it will retrieve it from when commanded to retrieve and display it.</p><div class="informalexample"><pre class="programlisting"># mouse_shape_recorder_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Mouse Drawn Shape Saver")
cw = 600 # canvas width
ch = 400 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="#ffffff")
chart_1.grid(row=1, column=1)
pt = [0]
x0 = [0]
y0 = [0]
count_point = 0
x_end = 10
y_end = 10
#============================================
# Create a new circle where the click happens and draw a new line
# segment to the last point (where the mouse was left clicked).
def callback_1(event): # Left button pressed.
global count_point, x_end, y_end
global x0, y0
global x0_n, y0_n, pt
x_start = x_end
y_start = y_end
x_end = event.x
y_end = event.y
chart_1.create_line(x_start, y_start , x_end,y_end , fill = \ "#0088ff")
chart_1.create_oval(x_end-5,y_end-5, x_end+5, y_end+5, outline = \ "#0088ff")
count_point += 1
pt = pt + [count_point]
x0 = x0 + [x_end] # extend list of all points
y0 = y0 + [y_end]
chart_1.bind("&lt;Button-1&gt;", callback_1) # &lt;button-1&gt; left mouse button
#==============================================
# 1. Button control to store segmented line
def callback_6():
global x0, y0
xy_points = open('/constr/shape_xy_1.txt', 'w')
xy_points.write(str(x0))
xy_points.write('\n')
xy_points.write(str(y0))
xy_points.close()
Button(root, text="Store", command=callback_6).grid(row=0, column=2)
#=============================================
# 2. Button control to retrieve line from file.
def callback_7():
global x0, y0 # Stored list of mouse-click positions.
xy_points = open('/constr/shape_xy_1.txt', 'r')
x0 = eval(xy_points.readline())
y0 = eval(xy_points.readline())
xy_points.close()
print "x0 = ",x0
print "y0 = ",y0
for i in range(1, count_point): # Re-plot the stored and # retreived line
chart_1.create_line(x0[i], y0[i] , x0[i+1], y0[i+1] , \ fill = "#0088ff")
chart_1.create_oval(x_end - 5,y_end - 5, x_end + 5, \ y_end + 5 , outline = "#0088ff")
Button(root, text="retrieve", command=callback_7).grid(row=1, \ column=2)
#=============================================
# 3. Button control to clear canvas
def callback_8():
chart_1.delete(ALL)
Button(root, text="CLEAR", command=callback_8).grid(row=2, column=2)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec14"/>How it works...</h2></div></div></div><p>In addition to a<code class="literal"> callback</code> function for adding the positions of left mouse clicks to lists<code class="literal"> x0</code> and<code class="literal"> y0</code>, of x and y-coordinates, we have another three<code class="literal"> callback</code> functions. The three additional<code class="literal"> callback</code> functions are to trigger the execution of functions that:<a id="id237" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Save the lists<code class="literal"> x0</code> and<code class="literal"> y0</code> to a disk in a file called<code class="literal"> shape_xy_1.txt</code>.</li><li class="listitem" style="list-style-type: disc">Clear the canvas of all drawn lines and circles</li><li class="listitem" style="list-style-type: disc">Retrieve the contents of<code class="literal"> shape_xy_1.txt</code> and re-draw it onto the canvas</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec15"/>There's more...</h2></div></div></div><p>Drawing is an imperfect process and artists and draughtsman use an eraser as well as a pencil. When we make drawings with a mouse connected to a computer we also need to make adjustments and corrections to any lines we draw. We need editing ability.</p><p>Drawing is an imperfect process. We would like to be able to adjust the position of some of the points in order to improve the drawing. We do this in the next recipe.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A mouse-line editor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec10"/>A mouse-line editor</h1></div></div></div><p>We edit (change) a shape drawn using the mouse after the drawing is finished.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec16"/>Getting ready</h2></div></div></div><p>To limit the complexity and length of the code, we have excluded the facilities provided in the previous recipe for storing and recalling the drawn shape. So for this recipe no storage folders will be used.<a id="id238" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># mouse_shape_editor_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
root = Tk()
root.title("Left drag to draw, right to re-position.")
cw = 600 # canvas width
ch = 650 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="#ffffff")
chart_1.grid(row=1, column=1)
linedrag = {'x_start':0, 'y_start':0, 'x_end':0, 'y_end':0}
map_distance = 0
dist_meter = 0
x_initial = 0
y_initial = 0
#==============================================
# Adjust the distance between points if desired
way_points = 50 # Distance between editable way-points
#==============================================
magic_circle_flag = 0 # 0-&gt; normal dragging, 1 -&gt; double-click: # Pull point.
point_num = 0
x0 = []
y0 = []
#================================================
def separation(x_now, y_now, x_dot, y_dot): # DISTANCE MEASUREMENT
# Distance to points - used to find out if the mouse # clicked inside a circle
sum_squares = (x_now - x_dot)**2 + (y_now -y_dot)**2
distance= int(math.sqrt(sum_squares)) # Get Pythagorean # distance
return( distance)
#================================================
# CALLBACK EVENT PROCESSING FUNCTIONS
def callback_1(event): # LEFT DOWN
global x_initial, y_initial
x_initial = event.x
y_initial = event.y
def callback_2(event): # LEFT DRAG
global x_initial, y_initial
global map_distance, dist_meter
global x0, y0
linedrag['x_start'] = linedrag['x_end'] # update positions
linedrag['y_start'] = linedrag['y_end']
linedrag['x_end'] = event.x
linedrag['y_end'] = event.y
increment = separation(linedrag['x_start'],linedrag['y_start'], \ linedrag['x_end'], linedrag['y_end'] )
map_distance += increment # Total distance - # potentiasl use as a map odometer.
dist_meter += increment # Distance from last circle
if dist_meter&gt;way_points: # Action at way-points
x0.append(linedrag['x_end']) # append to line
y0.append(linedrag['y_end'])
xb = linedrag['x_end'] - 5 ; yb = linedrag['y_end'] - 5 # Centre circle on line
x1 = linedrag['x_end'] + 5 ; y1 = linedrag['y_end'] + 5
chart_1.create_oval(xb,yb, x1,y1, outline = "green")
dist_meter = 0 # re-zero the odometer.
linexy = [ x_initial, y_initial, linedrag['x_end'] , \ linedrag['y_end'] ]
chart_1.create_line(linexy, fill='green')
x_initial = linedrag['x_end'] # start of next segment
y_initial = linedrag['y_end']
def callback_5(event): # RIGHT CLICK
global point_num, magic_circle_flag, x0, y0
# Measure distances to each point in turn, determine if any are # inside magic circle.
# That is, identify which point has been clicked on.
for i in range(0, len(x0)):
d = separation(event.x, event.y, x0[i], y0[i])
if d &lt;= 5:
point_num = i # this is the index that controls editing
magic_circle_flag = 1
chart_1.create_oval(x0[i] - 10,y0[i] - 10, x0[i] + 10, \ y0[i] + 10 , width = 4, outline = "#ff8800")
x0[i] = event.x
y0[i] = event.y
def callback_6(event): # RIGHT RELEASE
global point_num, magic_circle_flag, x0, y0
if magic_circle_flag == 1: # The point is going to be # repositioned.
x0[point_num] =event.x
y0[point_num] =event.y
chart_1.delete(ALL)
chart_1.update() # Refreshes the drawing on the # canvas.
q=[]
for i in range(0,len(x0)):
q.append(x0[i])
q.append(y0[i])
chart_1.create_oval(x0[i] - 5,y0[i] - 5, x0[i] + 5, \ y0[i] + 5 , outline = "#00ff00")
chart_1.create_line(q , fill = "#ff00ff") # Now show the # new positions
magic_circle_flag = 0
#==============================
chart_1.bind("&lt;Button-1&gt;", callback_1) # &lt;Button-1&gt; -&gt;LEFT mouse # button
chart_1.bind("&lt;B1-Motion&gt;", callback_2)
chart_1.bind("&lt;Button-3&gt;", callback_5) # &lt;Button-3&gt; -&gt;RIGHT mouse # button
chart_1.bind("&lt;ButtonRelease-3&gt;", callback_6)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec17"/>How it works...</h2></div></div></div><p>The preceding program now includes:<a id="id239" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">callback</code> functions to deal with left and right mouse clicks and drags.</li></ul></div><p>A distance-measuring function<code class="literal"> separation(x_now, y_now, x_dot, y_dot)</code>. When the right mouse button is clicked, the distance to every line joint is measured. If one of these distances is inside an existing joint then an orange circle is drawn and control is passed to<code class="literal"> callback_6</code> which updates the coordinates of the new point and refreshes the revised drawing. The decision on whether to move a point or not is decided by the value of the<code class="literal"> magic_circle_flag</code>. The state of this flag is determined by the distance computed by<code class="literal"> separation()</code>. It is set to<code class="literal"> 1</code> if the distance measurement finds it inside a joint when the right mouse is pressed and set to<code class="literal"> 0</code> after a point has been moved.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec18"/>There's more...</h2></div></div></div><p>Now that we have a means to control and adjust the drawing of lines and curves using mouse manipulation, other possibilities are opened up.</p><div class="section" title="Why don't we add more features?"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec01"/>Why don't we add more features?</h3></div></div></div><p>It would be good to extend the features of this program to include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The ability to erase points</li><li class="listitem" style="list-style-type: disc">The ability to work with unjoined segments</li><li class="listitem" style="list-style-type: disc">The ability to select or click to create points</li><li class="listitem" style="list-style-type: disc">Drag fairy lights (equal length segments)</li></ul></div><p>The list will grow longer as we work on the extensions. In the end, we will have created a useful vector graphics editor and the pressure would be on to match features of existing proprietary and open-source editors. Why re-invent the wheel? What may bear more fruit would be an effort to work with vector images produced by an existing mature vector editor, if this is a practical option.</p></div><div class="section" title="Using other tools to acquire and re-work images"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec02"/>Using other tools to acquire and re-work images</h3></div></div></div><p>In the next chapter, we explore ways and means of using vector images from the open-source vector graphics editor Inkscape. Inkscape is able to export images in a wide choice of formats including a standardized web format called<span class="strong"><strong> Scaled Vector Graphics</strong></span> or<span class="strong"><strong> SVG</strong></span> for short.<a id="id240" class="indexterm"/>
</p></div><div class="section" title="How to exploit that mouse"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec03"/>How to exploit that mouse</h3></div></div></div><p>This chapter has made much use of the mouse as a user-interaction tool for drawing shapes on Tkinter canvasses. To complete the job of acquiring the know-how of using the mouse to its fullest the next recipe will be an examination of the full toolkit of mouse interactions.</p></div><div class="section" title="We can measure the distance along a meandering line"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec04"/>We can measure the distance along a meandering line</h3></div></div></div><p>In the code, there is a variable called<code class="literal"> map_distance</code> that has not been used. It can be used to trace the distance travelled on meandering paths on maps. The idea is that if we wanted to measure distances on unmarked paths and roads on something like a Google map, we would be able to adapt this recipe to the task.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="All possible mouse actions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec11"/>All possible mouse actions</h1></div></div></div><p>Now we make a program that tests each possible mouse event that Python is capable of responding to.<a id="id241" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec19"/>How to do it...</h2></div></div></div><p>Execute the program shown in the normal way.</p><div class="informalexample"><pre class="programlisting"># all_mouse_actions_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Mouse follower")
# The Canvas here is bound to the mouse events
cw = 200 # canvas width
ch = 100 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="#ffffff")
chart_1.grid(row=1, column=1)
#========= Left Mouse Button Events ===============
# callback events
def callback_1(event):
print "left mouse clicked"
def callback_2(event):
print "left dragged"
def callback_3(event):
print "left doubleclick"
def callback_4(event):
print "left released"
#======== Center Mouse Button Events ======================
def callback_5(event):
print "center mouse clicked"
def callback_6(event):
print "center dragged"
def callback_7(event):
print "center doubleclick"
def callback_8(event):
print "center released"
#======== Right Mouse Button Events ======================
def callback_9(event):
print "right mouse clicked"
def callback_10(event):
print "right dragged"
def callback_11(event):
print "right doubleclick"
def callback_12(event):
print "right released"
# &lt;button-1&gt; is the left mouse button
chart_1.bind("&lt;Button-1&gt;", callback_1)
chart_1.bind("&lt;B1-Motion&gt;", callback_2)
chart_1.bind("&lt;Double-1&gt;", callback_3)
chart_1.bind("&lt;ButtonRelease-1&gt;", callback_4)
# &lt;button-2&gt; is the center mouse button
chart_1.bind("&lt;Button-2&gt;", callback_5)
chart_1.bind("&lt;B2-Motion&gt;", callback_6)
chart_1.bind("&lt;Double-2&gt;", callback_7)
chart_1.bind("&lt;ButtonRelease-2&gt;", callback_8)
# &lt;button-3&gt; is the right mouse button
chart_1.bind("&lt;Button-3&gt;", callback_9)
chart_1.bind("&lt;B3-Motion&gt;", callback_10)
chart_1.bind("&lt;Double-3&gt;", callback_11)
chart_1.bind("&lt;ButtonRelease-3&gt;", callback_12)
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec20"/>How it works...</h2></div></div></div><p>The preceding code is reasonably self-explanatory. A small canvas is created that is responsive to all the mouse actions. Proof that the responses are working correctly are by means of confirmation messages typed on the system console. We can adapt the<code class="literal"> callback</code> functions to do any kind of task we choose simply by inserting appropriate Python commands into the<code class="literal"> callback</code> functions.<a id="id242" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec21"/>There's more...</h2></div></div></div><p>Mouse events and Tkinter widgets often work together. Most Tkinter GUI widgets are designed to be controlled by mouse events such as left or right-clicks or dragging with a button held down. Tkinter provides a versatile selection of widgets and these will be explored in<span class="emphasis"><em> Chapter 10, GUI Construction Part 1</em></span> and<span class="emphasis"><em> Chapter 11, GUI Construction</em></span>
</p></div></div></div>
</body></html>