<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Integration Testing and System Testing</h1></div></div></div><p>
<em>With all of the tools, techniques, and practices that we've discussed so far, we've still only been been thinking about testing units: the smallest meaningfully testable pieces of code. It's time to expand the focus and start testing code that incorporates multiple units.</em>
</p><p>In this chapter, we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Describe integration testing and system testing</li><li class="listitem" style="list-style-type: disc">Learn how to break up a program into testable multi-unit sections</li><li class="listitem" style="list-style-type: disc">Use doctest, unittest, and Nose to automate multi-unit tests</li></ul></div><p>So let's get on with it!</p><div><div><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Integration tests and system tests</h1></div></div></div><a class="indexterm" id="id566"/><p>Integration testing is the process of checking that the units making up your program work correctly in concert with each other, rather than in isolation. It's not practical to start the process with integration testing, because if the units don't work, the integration won't work either, and it will be harder to track down the cause of your problems. Once your units are solid though, it's necessary to test that the things you build out of them also work. The interactions between units can be surprising.</p><p>While you perform integration testing, you'll be putting the units together into bigger and bigger collections and testing those collections. When your integration tests expand to cover the entirety of your program, they have become system tests.</p><p>The trickiest part of integration testing is choosing which units to integrate into each test, so that you always have a solid base of code that you can believe in; a place to stand, while you pull in more code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Time for action – figuring out the order of integration</h1></div></div></div><a class="indexterm" id="id567"/><p>We'll walk through an exercise that can help with the process of deciding where to put the boundaries of integration tests.</p><div><ol class="orderedlist arabic"><li class="listitem">Using a piece of paper or a graphics program, write out names or representations for each of the units in the time planner project from Chapter 7. Group the methods of each class together. Being part of the same class is an obvious relationship between units, and we'll take advantage of that. (The <code class="literal">==</code> symbol here represents the Python <code class="literal">==</code> operator, which invokes the <code class="literal">__eq__</code> method on an object).<div><img alt="Time for action – figuring out the order of integration" src="img/8846_09_01.jpg"/></div></li><li class="listitem">Now, draw arrows between units that are supposed to directly interact with each other, from the caller to the callee. Laying everything out in an orderly fashion (like in step 1) can actually make this harder, so feel free to move the classes around to help the lines make sense.<div><img alt="Time for action – figuring out the order of integration" src="img/8846_09_02.jpg"/></div></li><li class="listitem">Draw circles around each class and each pair of classes that is connected by at least one line.<div><img alt="Time for action – figuring out the order of integration" src="img/8846_09_03.jpg"/></div></li><li class="listitem"><a class="indexterm" id="id568"/>Continue the process by drawing circles around overlapping pairs of circles, until there are only three circles left. Circle a pair of them and then put one more big circle around the whole mess.<div><img alt="Time for action – figuring out the order of integration" src="img/8846_09_04.jpg"/></div></li><li class="listitem">These circles tell us which order to write our integration tests in. The smaller the <a class="indexterm" id="id569"/>circle, the sooner the test should be written.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec97"/>
<em>What just happened?</em>
</h2></div></div></div><p>What we just did is a way to visualize and concretize the process of building up integration tests. While it's not critical to actually draw the lines and circles, it's useful to follow the process in your head. For larger projects, a lot can be gained from actually drawing the diagrams. When you can see the diagram, the correct next step tends to jump right out at you—especially if you use multiple colors to render the diagram—where it might otherwise be hidden behind the complexity of the program.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec98"/>Pop quiz – diagramming integration</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem"><a class="indexterm" id="id570"/>What's the point of grouping units together into classes during the early part of this process?</li><li class="listitem">When we move classes around to help the arrows make sense, what effect does that have on the later process?</li><li class="listitem"><a class="indexterm" id="id571"/>Why do we always focus on grouping together pairs when we do this?</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec99"/>Have a go hero – diagram your own program</h2></div></div></div><p>Take one of your own programs and build an integration diagram for it. If your program is large enough that the diagram begins to get clumsy, try putting different 'levels' of the diagram on separate pages.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Automation with doctest, unittest, and Nose</h1></div></div></div><p>The <a class="indexterm" id="id572"/>
<a class="indexterm" id="id573"/>only real difference between an integration test and a unit test, is that you could break the code being tested into smaller meaningful chunks, in an integration test. In a unit test, if you divided the code up any more it wouldn't be meaningful. For this reason, the same tools that help automate unit testing can be applied to integration testing. Since system testing is really the highest level of integration testing, the tools can be used for that as well.</p><p><a class="indexterm" id="id574"/> <a class="indexterm" id="id575"/>
<a class="indexterm" id="id576"/>The role of doctest in integration testing tends to be fairly limited. The real strengths of doctest are in the early part of the development process. It's easy for a testable specification to stray into integration testing—as mentioned before, that's fine as long as there are unit tests as well—but after that it's likely that you'll prefer unittest and Nose for writing your integration tests.</p><p>Integration tests need to be isolated from each other. Even though they contain multiple interacting units within themselves, you still benefit from knowing that nothing outside the test is affecting it. For this reason, unittest is a good choice for writing automated integration tests. Working together with unittest, Nose and Mocker complete the picture nicely.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Time for action – writing integration tests for the time planner</h1></div></div></div><p>Now <a class="indexterm" id="id577"/>that we've got an integration diagram for the time planner code, we can move ahead with actually writing automated integration tests.</p><div><ol class="orderedlist arabic"><li class="listitem">The integration diagram provides only a partial ordering of the integration tests, and there are several tests that could be the first one we write. Looking at the diagram, we see that the <code class="literal">statuses</code> and <code class="literal">activities</code> classes are at the ends of a lot of arrows, but not at the beginnings of any. This makes them particularly good places to start, because it means that they don't call on anything outside of themselves to operate. Since there's nothing to distinguish one of them as a better place to start than the other, we can choose between them arbitrarily. Let's start with <code class="literal">statuses</code>, and then do <code class="literal">activities</code>. We're going to write tests that exercise the whole class. At this low level, the integration tests will look a lot like the unit tests for the same class, but we're not going to use mock objects to represent other instances of the same class: we'll use real instances. We're testing whether the class correctly interacts with itself.</li><li class="listitem">Here<a class="indexterm" id="id578"/> is the test code for <code class="literal">statuses</code>:<div><pre class="programlisting">from unittest import TestCase
from planner.data import statuses, task_error
from datetime import datetime

class statuses_integration_tests(TestCase):
    def setUp(self):
        self.A = statuses('A',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2009, month=5, day=2))

    def test_repr(self):
        self.assertEqual(repr(self.A), '&lt;A 2008-07-15T00:00:00 2009-05-02T00:00:00&gt;')

    def test_equality(self):
        self.assertEqual(self.A, self.A)
        self.assertNotEqual(self.A, statuses('B',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2009, month=5, day=2)))
        self.assertNotEqual(self.A, statuses('A',
                          datetime(year=2007, month=7, day=15),
                          datetime(year=2009, month=5, day=2)))
        self.assertNotEqual(self.A, statuses('A',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2010, month=5, day=2)))

    def test_overlap_begin(self):
        status = statuses('status name',
                          datetime(year=2007, month=8, day=11),
                          datetime(year=2008, month=11, day=27))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_end(self):
        status = statuses('status name',
                          datetime(year=2008, month=1, day=11),
                          datetime(year=2010, month=4, day=16))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_inner(self):
        status = statuses('status name',
                          datetime(year=2007, month=10, day=11),
                          datetime(year=2010, month=1, day=27))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_outer(self):
        status = statuses('status name',
                          datetime(year=2008, month=8, day=12),
                          datetime(year=2008, month=9, day=15))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_after(self):
        status = statuses('status name',
                          datetime(year=2011, month=2, day=6),
                          datetime(year=2015, month=4, day=27))

        self.assertFalse(status.overlaps(self.A))</pre></div></li><li class="listitem">Here<a class="indexterm" id="id579"/> is the test code for <code class="literal">activities</code>:<div><pre class="programlisting">from unittest import TestCase
from planner.data import activities, task_error
from datetime import datetime

class activities_integration_tests(TestCase):
    def setUp(self):
        self.A = activities('A',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2009, month=5, day=2))
    def test_repr(self):
        self.assertEqual(repr(self.A), '&lt;A 2008-07-15T00:00:00 2009-05-02T00:00:00&gt;')

    def test_equality(self):
        self.assertEqual(self.A, self.A)
        self.assertNotEqual(self.A, activities('B',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2009, month=5, day=2)))
        self.assertNotEqual(self.A, activities('A',
                          datetime(year=2007, month=7, day=15),
                          datetime(year=2009, month=5, day=2)))
        self.assertNotEqual(self.A, activities('A',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2010, month=5, day=2)))

    def test_overlap_begin(self):
        activity = activities('activity name',
                          datetime(year=2007, month=8, day=11),
                          datetime(year=2008, month=11, day=27))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_end(self):
        activity = activities('activity name',
                          datetime(year=2008, month=1, day=11),
                          datetime(year=2010, month=4, day=16))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_inner(self):
        activity = activities('activity name',
                          datetime(year=2007, month=10, day=11),
                          datetime(year=2010, month=1, day=27))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

   <a class="indexterm" id="id580"/> def test_overlap_outer(self):
        activity = activities('activity name',
                          datetime(year=2008, month=8, day=12),
                          datetime(year=2008, month=9, day=15))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_after(self):
        activity = activities('activity name',
                          datetime(year=2011, month=2, day=6),
                          datetime(year=2015, month=4, day=27))

        self.assertFalse(activity.overlaps(self.A))</pre></div></li><li class="listitem">Looking at our diagram, we can see that the next level out from either <code class="literal">statuses</code> or <code class="literal">activities</code> represents the integration of those classes with the <code class="literal">schedules</code> class. Before we write that integration, we ought to write any tests that involve the schedules class interacting with itself, without mocking it.<div><pre class="programlisting">from unittest import TestCase
from mocker import MockerTestCase, MATCH, ANY
from planner.data import schedules, schedule_error
from datetime import datetime

class schedules_tests(MockerTestCase):
    def setUp(self):
        mocker = self.mocker

   <a class="indexterm" id="id581"/>     A = mocker.mock()
        A.__eq__(MATCH(lambda x: x is A))
        mocker.result(True)
        mocker.count(0, None)
        A.__eq__(MATCH(lambda x: x is not A))
        mocker.result(False)
        mocker.count(0, None)
        A.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        A.begins
        mocker.result(5)
        mocker.count(0, None)

        B = mocker.mock()
        A.__eq__(MATCH(lambda x: x is B))
        mocker.result(True)
        mocker.count(0, None)
        B.__eq__(MATCH(lambda x: x is not B))
        mocker.result(False)
        mocker.count(0, None)
        B.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        B.begins
        mocker.result(3)
        mocker.count(0, None)

        C = mocker.mock()
        C.__eq__(MATCH(lambda x: x is C))
        mocker.result(True)
        mocker.count(0, None)
        C.__eq__(MATCH(lambda x: x is not C))
        mocker.result(False)
        mocker.count(0, None)
        C.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        C.begins
        mocker.result(7)
        mocker.count(0, None)

        self.A = A
        self.B = B
        self.C = C

        mocker.replay()

    def test_equality(self):
        sched1 = schedules()
        sched2 = schedules()

        self.assertEqual(sched1, sched2)

        sched1.add(self.A)
        sched1.add(self.B)

        sched2.add(self.A)
        sched2.add(self.B)
        sched2.add(self.C)

        self.assertNotEqual(sched1, sched2)

        sched1.add(self.C)

        self.assertEqual(sched1, sched2)</pre></div></li><li class="listitem">Now <a class="indexterm" id="id582"/>that interactions within the <code class="literal">schedules</code> class have been tested, we can write tests that integrate <code class="literal">schedules</code> and one of <code class="literal">statuses</code> or <code class="literal">activities</code>. Let's start with <code class="literal">statuses</code>, then do <code class="literal">activities</code>. Here are the tests for <code class="literal">schedules</code> and <code class="literal">statuses</code>:<div><pre class="programlisting">from planner.data import schedules, statuses
from unittest import TestCase
from datetime import datetime, timedelta

class test_schedules_and_statuses(TestCase):
    def setUp(self):
        self.A = statuses('A',
                         datetime.now(),
                         datetime.now() + timedelta(minutes = 7))
        self.B = statuses('B',
                         datetime.now() - timedelta(hours = 1),
                         datetime.now() + timedelta(hours = 1))
        self.C = statuses('C',
                         datetime.now() + timedelta(minutes = 10),
                         datetime.now() + timedelta(hours = 1))

    def test_usage_pattern(self):
        sched = schedules()

        sched.add(self.A)
        sched.add(self.C)

   <a class="indexterm" id="id583"/>     self.assertTrue(self.A in sched)
        self.assertTrue(self.C in sched)
        self.assertFalse(self.B in sched)

        sched.add(self.B)

        self.assertTrue(self.B in sched)

        self.assertEqual(sched, sched)

        sched.remove(self.A)

        self.assertFalse(self.A in sched)
        self.assertTrue(self.B in sched)
        self.assertTrue(self.C in sched)

        sched.remove(self.B)
        sched.remove(self.C)

        self.assertFalse(self.B in sched)
        self.assertFalse(self.C in sched)</pre></div></li><li class="listitem">Here are the tests for <code class="literal">schedules</code> and <code class="literal">activities</code>:<div><pre class="programlisting">from planner.data import schedules, activities, schedule_error
from unittest import TestCase
from datetime import datetime, timedelta

class test_schedules_and_activities(TestCase):
    def setUp(self):
        self.A = activities('A',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))
        self.B = activities('B',
                          datetime.now() - timedelta(hours = 1),
                          datetime.now() + timedelta(hours = 1))
        self.C = activities('C',
                          datetime.now() + timedelta(minutes = 10),
                          datetime.now() + timedelta(hours = 1))

   <a class="indexterm" id="id584"/> def test_usage_pattern(self):
        sched = schedules()

        sched.add(self.A)
        sched.add(self.C)

        self.assertTrue(self.A in sched)
        self.assertTrue(self.C in sched)
        self.assertFalse(self.B in sched)

        self.assertRaises(schedule_error, sched.add, self.B)

        self.assertFalse(self.B in sched)
        self.assertEqual(sched, sched)

        sched.remove(self.A)

        self.assertFalse(self.A in sched)
        self.assertFalse(self.B in sched)
        self.assertTrue(self.C in sched)

        sched.remove(self.C)

        self.assertFalse(self.B in sched)
        self.assertFalse(self.C in sched)</pre></div></li><li class="listitem">It's time to pull <code class="literal">schedules</code>, <code class="literal">statuses</code>, and <code class="literal">activities</code> all together into the same tests.<div><pre class="programlisting">from planner.data import schedules, statuses, activities, schedule_error
from unittest import TestCase
from datetime import datetime, timedelta

class test_schedules_activities_and_statuses(TestCase):
    def setUp(self):
        self.A = statuses('A',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))
        self.B = statuses('B',
                          datetime.now() - timedelta(hours = 1),
                          datetime.now() + timedelta(hours = 1))
        self.C = statuses('C',
                         datetime.now() + timedelta(minutes = 10),
                         datetime.now() + timedelta(hours = 1))

        self.D = activities('D',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))

   <a class="indexterm" id="id585"/>     self.E = activities('E',
                          datetime.now() + timedelta(minutes=30),
                          datetime.now() + timedelta(hours=1))

        self.F = activities('F',
                          datetime.now() - timedelta(minutes=20),
                          datetime.now() + timedelta(minutes=40))

    def test_usage_pattern(self):
        sched = schedules()

        sched.add(self.A)
        sched.add(self.B)
        sched.add(self.C)

        sched.add(self.D)

        self.assertTrue(self.A in sched)
        self.assertTrue(self.B in sched)
        self.assertTrue(self.C in sched)
        self.assertTrue(self.D in sched)

        self.assertRaises(schedule_error, sched.add, self.F)
        self.assertFalse(self.F in sched)

        sched.add(self.E)
        sched.remove(self.D)

        self.assertTrue(self.E in sched)
        self.assertFalse(self.D in sched)

        self.assertRaises(schedule_error, sched.add, self.F)

        self.assertFalse(self.F in sched)

        sched.remove(self.E)

        self.assertFalse(self.E in sched)

        sched.add(self.F)

        self.assertTrue(self.F in sched)</pre></div></li><li class="listitem">The <a class="indexterm" id="id586"/>next thing that we need to pull in is the <code class="literal">file</code> class, but before we integrate it with the rest of the system, we need to integrate it with itself; checking its internal interactions without using mock objects.<div><pre class="programlisting">from unittest import TestCase
from planner.persistence import file
from os import unlink

class test_file(TestCase):
    def setUp(self):
        storage = file('file_test.sqlite')

        storage.store_object('tag1', 'A')
        storage.store_object('tag2', 'B')
        storage.store_object('tag1', 'C')
        storage.store_object('tag1', 'D')
        storage.store_object('tag3', 'E')
        storage.store_object('tag3', 'F')

    def tearDown(self):
        unlink('file_test.sqlite')

    def test_other_instance(self):
        storage = file('file_test.sqlite')

        self.assertEqual(set(storage.load_objects('tag1')),
                         set(['A', 'C', 'D']))

        self.assertEqual(set(storage.load_objects('tag2')),
                         set(['B']))

        self.assertEqual(set(storage.load_objects('tag3')),
                         set(['E', 'F']))</pre></div></li><li class="listitem">Now we can write tests that integrate <code class="literal">schedules</code> and <code class="literal">file</code>. Notice that for this step, we still aren't involving <code class="literal">statuses</code> or <code class="literal">activities</code>, because they're outside the oval.<div><pre class="programlisting">from mocker import Mocker, MockerTestCase, ANY
from planner.data import schedules
from planner.persistence import file
from os import unlink
<a class="indexterm" id="id587"/>
def unpickle_mocked_task(begins):
    mocker = Mocker()
    ret = mocker.mock()
    ret.overlaps(ANY)
    mocker.result(False)
    mocker.count(0, None)
    ret.begins
    mocker.result(begins)
    mocker.count(0, None)
    mocker.replay()
    return ret
unpickle_mocked_task.__safe_for_unpickling__ = True

class test_schedules_and_file(MockerTestCase):
    def setUp(self):
        mocker = self.mocker

        A = mocker.mock()
        A.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        A.begins
        mocker.result(5)
        mocker.count(0, None)
        A.__reduce_ex__(ANY)
        mocker.result((unpickle_mocked_task, (5,)))
        mocker.count(0, None)

        B = mocker.mock()
        B.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        B.begins
        mocker.result(3)
        mocker.count(0, None)
        B.__reduce_ex__(ANY)
        mocker.result((unpickle_mocked_task, (3,)))
        mocker.count(0, None)

        C = mocker.mock()
        C.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        C.begins
        mocker.result(7)
        mocker.count(0, None)
        C.__reduce_ex__(ANY)
        mocker.result((unpickle_mocked_task, (7,)))
        mocker.count(0, None)
<a class="indexterm" id="id588"/>
        self.A = A
        self.B = B
        self.C = C

        mocker.replay()

    def tearDown(self):
        try:
            unlink('test_schedules_and_file.sqlite')
        except OSError:
            pass

    def test_save_and_restore(self):
        sched1 = schedules()

        sched1.add(self.A)
        sched1.add(self.B)
        sched1.add(self.C)

        store1 = file('test_schedules_and_file.sqlite')
        sched1.store(store1)

        del sched1
        del store1

        store2 = file('test_schedules_and_file.sqlite')
        sched2 = schedules.load(store2)

        self.assertEqual(set([x.begins for x in sched2.tasks]),
                         set([3, 5, 7]))</pre></div></li><li class="listitem">We've built our way up to the outermost circle now, which means that it's time to write tests that involve the whole system, with no mock objects anywhere.<div><pre class="programlisting">from planner.data import schedules, statuses, activities, schedule_error
from planner.persistence import file
from unittest import TestCase
from datetime import datetime, timedelta
from os import unlink
<a class="indexterm" id="id589"/>
class test_system(TestCase):
    def setUp(self):
        self.A = statuses('A',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))
        self.B = statuses('B',
                         datetime.now() - timedelta(hours = 1),
                         datetime.now() + timedelta(hours = 1))
        self.C = statuses('C',
                         datetime.now() + timedelta(minutes = 10),
                         datetime.now() + timedelta(hours = 1))

        self.D = activities('D',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))

        self.E = activities('E',
                          datetime.now() + timedelta(minutes=30),
                          datetime.now() + timedelta(hours = 1))

        self.F = activities('F',
                          datetime.now() - timedelta(minutes=20),
                          datetime.now() + timedelta(minutes=40))

    def tearDown(self):
        try:
            unlink('test_system.sqlite')
        except OSError:
            pass

    def test_usage_pattern(self):
        sched1 = schedules()

        sched1.add(self.A)
        sched1.add(self.B)
        sched1.add(self.C)
        sched1.add(self.D)
        sched1.add(self.E)

        store1 = file('test_system.sqlite')
        sched1.store(store1)

        del store1

        store2 = file('test_system.sqlite')
        sched2 = schedules.load(store2)

        self.assertEqual(sched1, sched2)

        sched2.remove(self.D)
        sched2.remove(self.E)
<a class="indexterm" id="id590"/>
        self.assertNotEqual(sched1, sched2)

        sched2.add(self.F)

        self.assertTrue(self.F in sched2)
        self.assertFalse(self.F in sched1)

        self.assertRaises(schedule_error, sched2.add, self.D)
        self.assertRaises(schedule_error, sched2.add, self.E)

        self.assertTrue(self.A in sched1)
        self.assertTrue(self.B in sched1)
        self.assertTrue(self.C in sched1)
        self.assertTrue(self.D in sched1)
        self.assertTrue(self.E in sched1)
        self.assertFalse(self.F in sched1)

        self.assertTrue(self.A in sched2)
        self.assertTrue(self.B in sched2)
        self.assertTrue(self.C in sched2)
        self.assertFalse(self.D in sched2)
        self.assertFalse(self.E in sched2)
        self.assertTrue(self.F in sched2)<a class="indexterm" id="id591"/>
</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec100"/>
<em>What just happened?</em>
</h2></div></div></div><p>We've just tested our whole code base, always being careful to test one thing at a time. Because we took care to go step-by-step, we always knew where newly discovered bugs originated, and we were able to fix them easily.</p><p>Let's take a moment to examine each section of the code.</p><div><pre class="programlisting">class statuses_integration_tests(TestCase):
    def setUp(self):
        self.A = statuses('A',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2009, month=5, day=2))</pre></div><p>We're creating a status object here in our <code class="literal">setUp</code> method. Because it's a <code class="literal">setUp</code> method—part of the test fixture—each test will have its own unique version of <code class="literal">self.A</code>, and changes made in one test won't be visible to any other test.</p><div><pre class="programlisting">    def test_equality(self):
        self.assertEqual(self.A, self.A)
        self.assertNotEqual(self.A, statuses('B',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2009, month=5, day=2)))
        self.assertNotEqual(self.A, statuses('A',
                          datetime(year=2007, month=7, day=15),
                          datetime(year=2009, month=5, day=2)))
        self.assertNotEqual(self.A, statuses('A',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2010, month=5, day=2)))</pre></div><p>The <code class="literal">test_equality</code> test checks that a status compares equal to itself, and that differences in name, start time or end time cause statuses to compare as unequal.</p><div><pre class="programlisting">def test_overlap_begin(self):
        status = statuses('status name',
                          datetime(year=2007, month=8, day=11),
                          datetime(year=2008, month=11, day=27))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_end(self):
        status = statuses('status name',
                          datetime(year=2008, month=1, day=11),
                          datetime(year=2010, month=4, day=16))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_inner(self):
        status = statuses('status name',
                          datetime(year=2007, month=10, day=11),
                          datetime(year=2010, month=1, day=27))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_outer(self):
        status = statuses('status name',
                          datetime(year=2008, month=8, day=12),
                          datetime(year=2008, month=9, day=15))

        self.assertTrue(status.overlaps(self.A))

    def test_overlap_after(self):
        status = statuses('status name',
                          datetime(year=2011, month=2, day=6),
                          datetime(year=2015, month=4, day=27))

        self.assertFalse(status.overlaps(self.A))</pre></div><p>This series of tests checks that statuses correctly recognize when they overlap, whether that overlap happens at the beginning, at the end, or because one status is within the other.</p><div><pre class="programlisting">class activities_integration_tests(TestCase):
    def setUp(self):
        self.A = activities('A',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2009, month=5, day=2))

    def test_repr(self):
        self.assertEqual(repr(self.A), '&lt;A 2008-07-15T00:00:00 2009-05-02T00:00:00&gt;')

    def test_equality(self):
        self.assertEqual(self.A, self.A)
        self.assertNotEqual(self.A, activities('B',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2009, month=5, day=2)))
        self.assertNotEqual(self.A, activities('A',
                          datetime(year=2007, month=7, day=15),
                          datetime(year=2009, month=5, day=2)))
        self.assertNotEqual(self.A, activities('A',
                          datetime(year=2008, month=7, day=15),
                          datetime(year=2010, month=5, day=2)))</pre></div><p>As with statuses, activities are tested by creating a sample object in the <code class="literal">setUp</code> method, and performing operations on it in the tests. Equality checking is the same as in statuses; we want to make sure that a different name, begin time, or end time means that the two activities are not equal.</p><div><pre class="programlisting">def test_overlap_begin(self):
        activity = activities('activity name',
                          datetime(year=2007, month=8, day=11),
                          datetime(year=2008, month=11, day=27))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_end(self):
        activity = activities('activity name',
                          datetime(year=2008, month=1, day=11),
                          datetime(year=2010, month=4, day=16))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_inner(self):
        activity = activities('activity name',
                          datetime(year=2007, month=10, day=11),
                          datetime(year=2010, month=1, day=27))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_outer(self):
        activity = activities('activity name',
                          datetime(year=2008, month=8, day=12),
                          datetime(year=2008, month=9, day=15))

        self.assertTrue(activity.overlaps(self.A))
        self.assertTrue(activity.excludes(self.A))

    def test_overlap_after(self):
        activity = activities('activity name',
                          datetime(year=2011, month=2, day=6),
                          datetime(year=2015, month=4, day=27))

        self.assertFalse(activity.overlaps(self.A))</pre></div><p>This series of tests makes sure that activities correctly recognize when they overlap with each other, whether that overlapping happens at the beginning, the end, or in the middle.</p><div><pre class="programlisting">class schedules_tests(MockerTestCase):
    def setUp(self):
        mocker = self.mocker

        A = mocker.mock()
        A.__eq__(MATCH(lambda x: x is A))
        mocker.result(True)
        mocker.count(0, None)
        A.__eq__(MATCH(lambda x: x is not A))
        mocker.result(False)
        mocker.count(0, None)
        A.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        A.begins
        mocker.result(5)
        mocker.count(0, None)

        B = mocker.mock()
        A.__eq__(MATCH(lambda x: x is B))
        mocker.result(True)
        mocker.count(0, None)
        B.__eq__(MATCH(lambda x: x is not B))
        mocker.result(False)
        mocker.count(0, None)
        B.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        B.begins
        mocker.result(3)
        mocker.count(0, None)

        C = mocker.mock()
        C.__eq__(MATCH(lambda x: x is C))
        mocker.result(True)
        mocker.count(0, None)
        C.__eq__(MATCH(lambda x: x is not C))
        mocker.result(False)
        mocker.count(0, None)
        C.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        C.begins
        mocker.result(7)
        mocker.count(0, None)

        self.A = A
        self.B = B
        self.C = C

        mocker.replay()</pre></div><p>We'll test how <code class="literal">schedules</code> interacts with itself, but not yet how it interacts with <code class="literal">activities</code> and <code class="literal">statuses</code>. As such, we need some mock objects to represent those things. Here in the test fixture, we create three mock objects for just that purpose.</p><div><pre class="programlisting">    def test_equality(self):
        sched1 = schedules()
        sched2 = schedules()

        self.assertEqual(sched1, sched2)

        sched1.add(self.A)
        sched1.add(self.B)

        sched2.add(self.A)
        sched2.add(self.B)
        sched2.add(self.C)

        self.assertNotEqual(sched1, sched2)

        sched1.add(self.C)

        self.assertEqual(sched1, sched2)</pre></div><p>The only interaction that <code class="literal">schedules</code> has with itself is equality comparison, so here we've tested that the comparison between two real schedules works the way it's supposed to.</p><div><pre class="programlisting">class test_schedules_and_statuses(TestCase):
    def setUp(self):
        self.A = statuses('A',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))
        self.B = statuses('B',
                          datetime.now() - timedelta(hours = 1),
                          datetime.now() + timedelta(hours = 1))
        self.C = statuses('C',
                          datetime.now() + timedelta(minutes = 10),
                          datetime.now() + timedelta(hours = 1))</pre></div><p>Where before we used mock objects to represent the statuses, now we can use the real thing. Since we're testing the interaction between <code class="literal">schedules</code> and <code class="literal">statuses</code>, we need to use the real thing.</p><div><pre class="programlisting">    def test_usage_pattern(self):
        sched = schedules()

        sched.add(self.A)
        sched.add(self.C)

        self.assertTrue(self.A in sched)
        self.assertTrue(self.C in sched)
        self.assertFalse(self.B in sched)

        sched.add(self.B)

        self.assertTrue(self.B in sched)
        self.assertEqual(sched, sched)
        sched.remove(self.A)

        self.assertFalse(self.A in sched)
        self.assertTrue(self.B in sched)
        self.assertTrue(self.C in sched)

        sched.remove(self.B)
        sched.remove(self.C)

        self.assertFalse(self.B in sched)
        self.assertFalse(self.C in sched)</pre></div><p>This test runs through the whole expected usage pattern between <code class="literal">schedules</code> and <code class="literal">statuses</code>, all in one test. This sort of thing isn't a good idea when we perform unit testing, because it naturally involves more than one unit. We're doing integration testing now, though, and all of the involved units have already been tested in isolation. We actually want to have them interact with each other to make sure it works, and this is a good way to achieve that.</p><div><pre class="programlisting">class test_schedules_and_activities(TestCase):
    def setUp(self):
        self.A = activities('A',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))
        self.B = activities('B',
                          datetime.now() - timedelta(hours = 1),
                          datetime.now() + timedelta(hours = 1))
        self.C = activities('C',
                          datetime.now() + timedelta(minutes = 10),
                          datetime.now() + timedelta(hours = 1))

    def test_usage_pattern(self):
        sched = schedules()

        sched.add(self.A)
        sched.add(self.C)

        self.assertTrue(self.A in sched)
        self.assertTrue(self.C in sched)
        self.assertFalse(self.B in sched)

        self.assertRaises(schedule_error, sched.add, self.B)

        self.assertFalse(self.B in sched)

        self.assertEqual(sched, sched)

        sched.remove(self.A)

        self.assertFalse(self.A in sched)
        self.assertFalse(self.B in sched)
        self.assertTrue(self.C in sched)

        sched.remove(self.C)

        self.assertFalse(self.B in sched)
        self.assertFalse(self.C in sched)</pre></div><p>These tests are a lot like the tests for <code class="literal">schedules</code> and <code class="literal">statuses</code> together. The differences are due to the fact that activities can exclude each other from participating in a schedule, so when we try to add an overlapping activity to the schedule, it should raise an exception, and then should not be added to the schedule.</p><div><pre class="programlisting">class test_schedules_activities_and_statuses(TestCase):
    def setUp(self):
        self.A = statuses('A',
                          datetime.now(),
                          datetime.now() + timedelta(minutes = 7))
        self.B = statuses('B',
                          datetime.now() - timedelta(hours = 1),
                          datetime.now() + timedelta(hours = 1))
        self.C = statuses('C',
                          datetime.now() + timedelta(minutes = 10),
                          datetime.now() + timedelta(hours = 1))

        self.D = activities('D',
                            datetime.now(),
                            datetime.now() + timedelta(minutes = 7))

        self.E = activities('E',
                            datetime.now() + timedelta(minutes=30),
                            datetime.now() + timedelta(hours=1))

        self.F = activities('F',
                            datetime.now() - timedelta(minutes=20),
                            datetime.now() + timedelta(minutes=40))</pre></div><p>We're not using any mocks at all here. These tests use <code class="literal">schedules</code>, <code class="literal">activities</code>, and <code class="literal">statuses</code> without any limits on their interactions. Our test fixture just creates a bunch of them, so we don't have to duplicate that code in each of the tests.</p><div><pre class="programlisting">    def test_usage_pattern(self):
        sched = schedules()

        sched.add(self.A)
        sched.add(self.B)
        sched.add(self.C)

        sched.add(self.D)

        self.assertTrue(self.A in sched)
        self.assertTrue(self.B in sched)
        self.assertTrue(self.C in sched)
        self.assertTrue(self.D in sched)

        self.assertRaises(schedule_error, sched.add, self.F)
        self.assertFalse(self.F in sched)

        sched.add(self.E)
        sched.remove(self.D)

        self.assertTrue(self.E in sched)
        self.assertFalse(self.D in sched)

        self.assertRaises(schedule_error, sched.add, self.F)
        self.assertFalse(self.F in sched)

        sched.remove(self.E)

        self.assertFalse(self.E in sched)

        sched.add(self.F)

        self.assertTrue(self.F in sched)</pre></div><p>Here again, we have a single test for a complete usage pattern. We're intentionally not limiting the interactions between the tested components; instead we're putting them together and making sure that they work.</p><div><pre class="programlisting">class test_file(TestCase):
    def setUp(self):
        storage = file('file_test.sqlite')

        storage.store_object('tag1', 'A')
        storage.store_object('tag2', 'B')
        storage.store_object('tag1', 'C')
        storage.store_object('tag1', 'D')
        storage.store_object('tag3', 'E')
        storage.store_object('tag3', 'F')

    def tearDown(self):
        unlink('file_test.sqlite')</pre></div><p>Our test fixture creates a persistence database, containing several objects before each test runs, and deletes that database after each test. As usual, that means we know what the environment looks like for each test, and they don't interact with each other.</p><div><pre class="programlisting">    def test_other_instance(self):
        storage = file('file_test.sqlite')

        self.assertEqual(set(storage.load_objects('tag1')),
                         set(['A', 'C', 'D']))

        self.assertEqual(set(storage.load_objects('tag2')),
                         set(['B']))

        self.assertEqual(set(storage.load_objects('tag3')),
                         set(['E', 'F']))</pre></div><p>In this test, we create a new persistence file object, and tell it to load data from the database created in the <code class="literal">setUp</code> method. Then we make sure that the loaded data match our expectations.</p><p>When we run this test, it turns up an error which was not previously visible. The changes to the database aren't being committed to the file, and so they aren't visible outside of the transaction where they were stored. Not testing the persistence code in separate transactions was an oversight, but that's exactly the sort of mistake that we perform integration testing to catch.</p><p>We can fix the problem by altering the <code class="literal">store_object</code> method of the <code class="literal">file</code> class in <code class="literal">persistence.py</code> as follows:</p><div><pre class="programlisting">    def store_object(self, tag, object):
        self.connection.execute('insert into objects values (?, ?)',
                               (tag, sqlite3.Binary(dumps(object))))
<strong>        self.connection.commit()</strong>
def unpickle_mocked_task(begins):
    mocker = Mocker()
    ret = mocker.mock()
    ret.overlaps(ANY)
    mocker.result(False)
    mocker.count(0, None)
    ret.begins
    mocker.result(begins)
    mocker.count(0, None)
    mocker.replay()
    return ret
unpickle_mocked_task.__safe_for_unpickling__ = True</pre></div><p>The <code class="literal">unpickle_mocked_task</code> function is necessary because one thing that mocks doesn't handle very well is being 'pickled' and 'unpickled'. We used tuples in the tests for <code class="literal">file</code> because of that, but we need mocks for this test, so we have to go to the extra trouble of telling Pickle how to handle them.</p><div><pre class="programlisting">class test_schedules_and_file(MockerTestCase):
    def setUp(self):
        mocker = self.mocker

        A = mocker.mock()
        A.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        A.begins
        mocker.result(5)
        mocker.count(0, None)
        A.__reduce_ex__(ANY)
        mocker.result((unpickle_mocked_task, (5,)))
        mocker.count(0, None)

        B = mocker.mock()
        B.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        B.begins
        mocker.result(3)
        mocker.count(0, None)
        B.__reduce_ex__(ANY)
        mocker.result((unpickle_mocked_task, (3,)))
        mocker.count(0, None)

        C = mocker.mock()
        C.overlaps(ANY)
        mocker.result(False)
        mocker.count(0, None)
        C.begins
        mocker.result(7)
        mocker.count(0, None)
        C.__reduce_ex__(ANY)
        mocker.result((unpickle_mocked_task, (7,)))
        mocker.count(0, None)

        self.A = A
        self.B = B
        self.C = C

        mocker.replay()

    def tearDown(self):
        try:
            unlink('test_schedules_and_file.sqlite')
        except OSError:
            pass</pre></div><p>This should be a fairly familiar sort of test fixture, by now. The new thing is that the <code class="literal">tearDown</code> method will delete a database file, ( if it exists) but won't complain if it doesn't. The database is expected to be created within the test itself, and we don't want to leave it lying around, but if it's not there, it's not a test fixture error.</p><div><pre class="programlisting">    def test_save_and_restore(self):
        sched1 = schedules()

        sched1.add(self.A)
        sched1.add(self.B)
        sched1.add(self.C)

        store1 = file('test_schedules_and_file.sqlite')
        sched1.store(store1)

        del sched1
        del store1

        store2 = file('test_schedules_and_file.sqlite')
        sched2 = schedules.load(store2)

        self.assertEqual(set([x.begins for x in sched2.tasks]),
                         set([3, 5, 7]))</pre></div><p>We're testing the interaction between schedules and persistence files, which means we've created and populated a schedule, created a persistence file, stored the schedule, and then created a new persistence file object using the same database file and loaded a new schedule from it. If the loaded schedule matches our expectations, all's well.</p><p>A lot of the test code in this chapter might seem redundant to you. That's because, in some sense, it is. Some things are repeatedly checked in different tests. Why bother?</p><p>The main reason for the redundancy is that each test is supposed to stand alone. We're not supposed to care what order they run in, or whether any other tests even exist. Each test is self-contained, so if it fails, we know exactly what needs to be fixed. Because each test is self-contained, some foundational things end up getting tested multiple times. In the case of this simple project, that redundancy is even more pronounced than it would normally be.</p><p>Whether it's blatant or subtle, the redundancy isn't a problem. The so-called DRY (Don't Repeat Yourself) principle doesn't particularly apply to tests. There's not much downside to having something tested multiple times. This is not to say that it's a good idea to copy and paste tests, because it's most certainly not. Don't be surprised or alarmed to see similarity between your tests, but don't use that as an excuse.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec101"/>Pop quiz – writing integration tests</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem"><a class="indexterm" id="id592"/>Which integration tests do you write first?</li><li class="listitem">What happens when you have a large chunk of integrated code, but the next section you need to pull in doesn't have any integration tests at all?</li><li class="listitem">What's the point of writing tests that check the integration of a chunk of code with itself?</li><li class="listitem">What is a system test, and how do system tests relate to integration tests?</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec102"/>Have a go hero – integrating your own program</h2></div></div></div><p>Earlier, you wrote an integration diagram for one of your own programs. It's time now to follow up on that and write integration tests for that code, guided by the diagram.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Summary</h1></div></div></div><p>In this chapter, we learned about the process of building up from a foundation of unit tests, into a set of tests that cover the whole system.</p><p>Specifically, we covered:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to draw an integration diagram</li><li class="listitem" style="list-style-type: disc">How to interpret an integration diagram to decide in what order to build the tests</li><li class="listitem" style="list-style-type: disc">How to write integration tests</li></ul></div><p>Now that we've learned about integration testing, we're ready to introduce a number of other useful testing tools and strategies—which is the topic of the next chapter.</p></div></body></html>