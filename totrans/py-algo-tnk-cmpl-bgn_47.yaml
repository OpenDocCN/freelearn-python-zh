- en: Chapter 33
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 33 章
- en: More with Data Structures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于数据结构的内容
- en: 33.1 Simple Exercises with Lists
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.1 列表简单练习
- en: Exercise 33.1-1 Creating a List that Contains the Average Values of its Neighboring
    Elements
  id: totrans-3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 33.1-1 创建包含相邻元素平均值的列表
- en: Write a Python program that lets the user enter 100 positive numerical values
    into a list. Then, the program must create a new list of 98 elements. This new
    list must contain, in each position the average value of the three elements that
    exist in the current and the next two positions of the user-provided list.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，让用户输入 100 个正数值到一个列表中。然后，程序必须创建一个包含 98 个元素的新列表 newArr。这个新列表的每个位置必须包含用户提供的列表中当前和下两个位置的三个元素的平均值。
- en: Solution
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Let's try to understand this exercise through an example using 10 elements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 10 个元素的示例来尝试理解这个练习。
- en: '![Image](img/chapter33-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter33-01.png)'
- en: List newArr is the new list that is created. In list newArr, the element at
    position 0 is the average value of the elements in the current and the next two
    positions of list a; that is, (5 + 10 + 9) / 3 = 8\. The element at position 1
    is the average value of the elements in the current and the next two positions
    of list a; that is, (10 + 9 + 2) / 3 = 7, and so on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: List newArr 是创建的新列表。在列表 newArr 中，位置 0 的元素是列表 a 中当前和下两个位置的元素的平均值；即 (5 + 10 +
    9) / 3 = 8。位置 1 的元素是列表 a 中当前和下两个位置的元素的平均值；即 (10 + 9 + 2) / 3 = 7，以此类推。
- en: The Python program is as follows.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序如下。
- en: '![](img/my_exercise_header.png) file_33.1-1a'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_33.1-1a'
- en: ELEMENTS_OF_A = 100
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS_OF_A = 100
- en: ELEMENTS_OF_NEW = ELEMENTS_OF_A - 2
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS_OF_NEW = ELEMENTS_OF_A - 2
- en: a = [None] * ELEMENTS_OF_A
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: a = [None] * ELEMENTS_OF_A
- en: 'for i in range(ELEMENTS_OF_A):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS_OF_A):'
- en: a[i] = float(input())
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: a[i] = float(input())
- en: newArr = [None] * ELEMENTS_OF_NEW
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: newArr = [None] * ELEMENTS_OF_NEW
- en: 'for i in range(ELEMENTS_OF_NEW):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS_OF_NEW):'
- en: newArr[i] = (a[i] + a[i + 1] + a[i + 2]) / 3
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: newArr[i] = (a[i] + a[i + 1] + a[i + 2]) / 3
- en: 'for i in range(ELEMENTS_OF_NEW):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS_OF_NEW):'
- en: print(newArr[i])
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: print(newArr[i])
- en: If you prefer a more Pythonic way, though, the solution is shown here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢更 Pythonic 的方式，解决方案如下。
- en: '![](img/my_exercise_header.png) file_33.1-1b'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_33.1-1b'
- en: from math import fsum
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: from math import fsum
- en: ELEMENTS_OF_A = 100
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS_OF_A = 100
- en: a = []
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: a = []
- en: 'for i in range(ELEMENTS_OF_A):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS_OF_A):'
- en: a.append(float(input()))
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: a.append(float(input()))
- en: newArr = []
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: newArr = []
- en: 'for i in range(ELEMENTS_OF_A - 2):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS_OF_A - 2):'
- en: newArr.append(fsum(a[i:i + 3]) / 3)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: newArr.append(fsum(a[i:i + 3]) / 3)
- en: 'for element in newArr:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'for element in newArr:'
- en: print(element)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: print(element)
- en: Exercise 33.1-2 Creating a List with the Greatest Values
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 33.1-2 创建包含最大值的列表
- en: Write a Python program that lets the user enter numerical values into lists
    a and b of 20 elements each. Then, the program must create a new list newArr of
    20 elements. The new list must contain in each position the greatest value of
    lists a and b of the corresponding position.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，让用户输入到列表 a 和 b 中各 20 个数值。然后，程序必须创建一个包含 20 个元素的新列表 newArr。新列表的每个位置必须包含列表
    a 和 b 对应位置的较大值。
- en: Solution
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Nothing new here! You need two for-loops to read the values for lists a and
    b, one for creating the list newArr, and one to display the list newArr on the
    screen.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么新的！你需要两个 for 循环来读取列表 a 和 b 的值，一个用于创建列表 newArr，另一个用于在屏幕上显示列表 newArr。
- en: The Python program is shown here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序如下所示。
- en: '![](img/my_exercise_header.png) file_33.1-2'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_33.1-2'
- en: ELEMENTS = 20
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 20
- en: '#Read lists a and b'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '#读取列表 a 和 b'
- en: a = [None] * ELEMENTS
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: a = [None] * ELEMENTS
- en: b = [None] * ELEMENTS
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: b = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: a[i] = float(input())
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: a[i] = float(input())
- en: 'for i in range(ELEMENTS):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: b[i] = float(input())
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: b[i] = float(input())
- en: '#Create list newArr'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建列表 newArr'
- en: newArr = [None] * ELEMENTS
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: newArr = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: 'if a[i] > b[i]:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'if a[i] > b[i]:'
- en: newArr[i] = a[i]
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: newArr[i] = a[i]
- en: 'else:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: newArr[i] = b[i]
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: newArr[i] = b[i]
- en: '#Display list newArr'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#显示列表 newArr'
- en: 'for i in range(ELEMENTS):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: print(newArr[i])
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: print(newArr[i])
- en: Exercise 33.1-3 Merging One-Dimensional Lists
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 33.1-3 合并一维列表
- en: Write a Python program that, for two given lists a and b of 10 and 15 elements,
    respectively, creates a new list newArr of 25 elements. This new list must contain
    in the first 10 positions the elements of list a, and in the next 15 positions
    the elements of list b.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，对于两个分别包含 10 和 15 个元素的列表 a 和 b，创建一个包含 25 个元素的新列表 newArr。这个新列表的前
    10 个位置必须包含列表 a 的元素，接下来的 15 个位置包含列表 b 的元素。
- en: Solution
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Since not all computer languages are so powerful in the field of data structures
    as Python, let's study three approaches here. The first one can be applied to
    most computer languages, whereas the second and the third ones are more Pythonic!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有计算机语言在数据结构领域都像Python那样强大，所以我们在这里研究三种方法。第一种方法可以应用于大多数计算机语言，而第二种和第三种方法则更具有Python风格！
- en: First approach
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法
- en: As you can see in the example presented next, there is a direct one-to-one correspondence
    between the index positions of the elements of list a and those of list newArr.
    Specifically, the element from position 0 of list a is stored in position 0 of
    list newArr, the element from position 1 of list a is stored in position 1 of
    list newArr, and so forth. However, this correspondence doesn't hold for list
    b; its elements need to be shifted by 10 positions in newArr.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的示例中可以看到的，列表a和列表newArr的元素索引位置之间存在直接的对应关系。具体来说，列表a的位置0的元素存储在列表newArr的位置0，列表a的位置1的元素存储在列表newArr的位置1，依此类推。然而，这种对应关系对于列表b不成立；它的元素需要在newArr中偏移10个位置。
- en: '![Image](img/chapter33-02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/chapter33-02.png)'
- en: In order to assign the values of list a to list newArr you can use the following
    code fragment.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将列表a的值赋给列表newArr，你可以使用以下代码片段。
- en: 'for i in range(len(a)):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(a)):'
- en: newArr[i] = a[i]
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: newArr[i] = a[i]
- en: However, to assign the values of list b to list newArr your code fragment should
    be slightly different as shown here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了将列表b的值赋给列表newArr，你的代码片段应该略有不同，如下所示。
- en: 'for i in range(len(b)):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(b)):'
- en: newArr[len(a) + i] = b[i]
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: newArr[len(a) + i] = b[i]
- en: The final Python program is as follows.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的Python程序如下。
- en: '![](img/my_exercise_header.png) file_33.1-3a'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_33.1-3a'
- en: '#Create lists a and b'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建列表a和b'
- en: a = [5, 10, 9, 6, 7, -6, 13, 12, 11, 2]
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: a = [5, 10, 9, 6, 7, -6, 13, 12, 11, 2]
- en: b = [-11, 25, 4, 45, 67, 87, 34, 23, 33, 55, 13, 15, -4, -2, -22]
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: b = [-11, 25, 4, 45, 67, 87, 34, 23, 33, 55, 13, 15, -4, -2, -22]
- en: '#Create list newArr'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建列表newArr'
- en: newArr = [None] * (len(a) + len(b))
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: newArr = [None] * (len(a) + len(b))
- en: 'for i in range(len(a)):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(a)):'
- en: newArr[i] = a[i]
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: newArr[i] = a[i]
- en: 'for i in range(len(b)):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(b)):'
- en: newArr[len(a) + i] = b[i]
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: newArr[len(a) + i] = b[i]
- en: '#Display list newArr'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '#显示列表newArr'
- en: 'for i in range(len(newArr)):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(newArr)):'
- en: print(newArr[i], end = "\t")
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: print(newArr[i], end = "\t")
- en: Second approach
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法
- en: This approach uses the append() method of Python.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用了Python的append()方法。
- en: '![](img/my_exercise_header.png) file_33.1-3b'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_33.1-3b'
- en: '#Create lists a and b'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建列表a和b'
- en: a = [5, 10, 9, 6, 7, -6, 13, 12, 11, 2]
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: a = [5, 10, 9, 6, 7, -6, 13, 12, 11, 2]
- en: b = [-11, 25, 4, 45, 67, 87, 34, 23, 33, 55, 13, 15, -4, -2, -22]
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: b = [-11, 25, 4, 45, 67, 87, 34, 23, 33, 55, 13, 15, -4, -2, -22]
- en: '#Create list newArr'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建列表newArr'
- en: newArr = []
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: newArr = []
- en: 'for element in a:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'for element in a:'
- en: newArr.append(element)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: newArr.append(element)
- en: 'for element in b:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'for element in b:'
- en: newArr.append(element)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: newArr.append(element)
- en: '#Display list newArr'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#显示列表newArr'
- en: 'for i in range(len(newArr)):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(newArr)):'
- en: print(newArr[i], end = "\t")
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: print(newArr[i], end = "\t")
- en: Third approach
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法
- en: This approach uses the magic forces of Python. In order to merge two lists in
    Python, you can simply use the concatenation operator ( + ). Python will do the
    rest for you!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法利用了Python的魔法力量。在Python中，为了合并两个列表，你可以简单地使用连接运算符（+）。Python会为你完成剩下的工作！
- en: '![](img/my_exercise_header.png) file_33.1-3c'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_33.1-3c'
- en: '#Create lists a and b'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建列表a和b'
- en: a = [5, 10, 9, 6, 7, -6, 13, 12, 11, 2]
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: a = [5, 10, 9, 6, 7, -6, 13, 12, 11, 2]
- en: b = [-11, 25, 4, 45, 67, 87, 34, 23, 33, 55, 13, 15, -4, -2, -22]
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: b = [-11, 25, 4, 45, 67, 87, 34, 23, 33, 55, 13, 15, -4, -2, -22]
- en: '#Create list newArr'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建列表newArr'
- en: newArr = a + b
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: newArr = a + b
- en: '#Display list newArr'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#显示列表newArr'
- en: 'for i in range(len(newArr)):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(newArr)):'
- en: print(newArr[i], end = "\t")
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: print(newArr[i], end = "\t")
- en: Exercise 33.1-4 Creating Two Lists – Separating Positive from Negative Values
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习33.1-4 创建两个列表 - 分离正负值
- en: Write a Python program that lets the user enter 100 numerical values into a
    list and then creates two new lists, pos and neg. List pos must contain positive
    values, whereas list neg must contain the negative ones. The value 0 (if any)
    must not be added to either of the final lists, pos or neg.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，让用户输入100个数值到列表中，然后创建两个新的列表，pos和neg。列表pos必须包含正数，而列表neg必须包含负数。值0（如果有）不得添加到最终的列表pos或neg中。
- en: Solution
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are two approaches! The first one can be applied to most computer languages,
    whereas the second one is more Pythonic!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法！第一种可以应用于大多数计算机语言，而第二种则更具有Python风格！
- en: First approach
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法
- en: Let's analyze this approach using the following example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来分析这种方法。
- en: '![Image](img/chapter33-03.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: In this exercise, there is no one-to-one correspondence between the index positions
    of the elements of list ar and the lists pos and neg. For example, the element
    from position 1 of list ar is not stored in position 1 of list neg, or the element
    from position 2 of list ar is not stored in position 2 of list pos. Thus, you
    cannot do the following,
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'if ar[i] > 0:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: pos[i] = ar[i]
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif ar[i] < 0:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: neg[i] = ar[i]
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: because it will result in the following two lists.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-04.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'What you need here are two independent index variables: posIndex for the list
    pos, and negIndex for the list neg. These index variables must be incremented
    independently, and only when an element is added to the corresponding list. The
    index variable posIndex must be incremented only when an element is added to the
    list pos, and the index variable negIndex must be incremented only when an element
    is added to the list neg, as shown in the code fragment that follows.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: posIndex = 0
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: negIndex = 0
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'if ar[i] > 0:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: pos[posIndex] = ar[i]
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: posIndex += 1
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif ar[i] < 0:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: neg[negIndex] = ar[i]
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: negIndex += 1
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that variables posIndex and negIndex have dual roles.
    When the loop iterates, each points to the next position in which a new element
    must be placed. But when the loop finishes iterating, variables posIndex and negIndex
    also contain the total number of elements in each corresponding list!'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The complete solution is presented next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-4a'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 100
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: ar = [None] * ELEMENTS
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: ar[i] = float(input())
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '#Create lists pos and neg'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: posIndex = 0
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: negIndex = 0
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: pos = [None] * ELEMENTS
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: neg = [None] * ELEMENTS
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'if ar[i] > 0:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: pos[posIndex] = ar[i]
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: posIndex += 1
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif ar[i] < 0:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: neg[negIndex] = ar[i]
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: negIndex += 1
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(posIndex):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: print(pos[i], end = "\t")
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(negIndex):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: print(neg[i], end = "\t")
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that the lists pos and neg contain a total number of
    posIndex and negIndex elements respectively. This is why the two last loop control
    structures iterate until variable i reaches values posIndex − 1 and negIndex −
    1, respectively, and not until ELEMENTS − 1, as you may mistakenly expect.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The first approach has a main disadvantage! The lists pos and neg must be initialized
    to a size of 100 because there is always a possibility that list ar contains only
    positive numbers, or probably only negative ones. Using the append() method, the
    next approach is more efficient than the previous one since it uses the least
    possible amount of main memory (RAM).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-4b'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 100
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: ar = []
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: ar.append(float(input()))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '#Create lists pos and neg'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: pos = []
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: neg = []
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in ar:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'if element > 0:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: pos.append(element)
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif element < 0:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: neg.append(element)
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for element in pos:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: print(element, end = "\t")
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: 'for element in neg:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'for element in neg:'
- en: print(element, end = "\t")
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: print(element, end = "\t")
- en: '![](img/notice.jpg)It is obvious that one problem can have many solutions.
    It is up to you to find the optimal one!'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)显然，一个问题可以有多个解决方案。取决于你找到最优解！'
- en: '![](img/notice.jpg)Be careful! In Python, even though you can do something
    like x = y = 0, this is not true when it comes to lists. It is absolutely incorrect
    to write pos = neg = [] because both pos and neg would refer to the same list.
    You must use two individual statements, as shown in this approach.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)小心！在Python中，尽管你可以做类似x = y = 0的事情，但这在列表中并不成立。写下pos = neg
    = []是完全错误的，因为pos和neg都会指向同一个列表。你必须使用两个单独的语句，就像这个方法中展示的那样。'
- en: Exercise 33.1-5 Creating a List with Those who Contain Digit 5
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习33.1-5 创建包含数字5的列表
- en: Write a Python program that lets the user enter 100 two-digit integers into
    a list and then creates a new list of only the integers that contain at least
    one of the digit 5.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，让用户输入100个两位整数到列表中，然后创建一个新列表，其中只包含包含至少一个数字5的整数。
- en: Solution
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: This exercise requires some knowledge from the past. In [Exercise 13.1-2](chapter13.html#toc_3)
    you learned how to use the quotient and the remainder to split an integer into
    its individual digits. Here, the user-provided integers have two digits; therefore,
    you can use the following code fragment to split any two-digit integer contained
    in variable x.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习需要一些过去的知识。在[练习13.1-2](chapter13.html#toc_3)中，你学习了如何使用商和余数将整数分解为其各个位数。在这里，用户提供的整数有两位数；因此，你可以使用以下代码片段来分解变量x中包含的任何两位数整数。
- en: lastDigit = x % 10
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: lastDigit = x % 10
- en: firstDigit = x // 10
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: firstDigit = x // 10
- en: or a more Pythonic way is to use the divmod() function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更符合Python风格的方式是使用divmod()函数。
- en: firstDigit, lastDigit = divmod(x, 10)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: firstDigit, lastDigit = divmod(x, 10)
- en: There are two approaches that you can use to solve this exercise! The first
    one can be applied to most computer languages, whereas the second one is more
    Pythonic!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法你可以用来解决这个练习！第一种方法可以应用于大多数计算机语言，而第二种方法则更符合Python风格！
- en: First approach
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法
- en: This approach uses an extra variable as an index for the new list. This is necessary
    when you want to create a new list using values from an old list and there is
    no one-to-one correspondence between their index positions. Of course, this variable
    must increase by 1 only when a new element is added into the new list. Moreover,
    when the loop that creates the new list finishes iterating, the value of this
    variable also matches the total number of elements in the new list! The final
    Python program is as follows.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用一个额外的变量作为新列表的索引。当你想要使用旧列表的值创建一个新列表，并且它们的索引位置没有一一对应关系时，这是必要的。当然，这个变量只有在向新列表添加新元素时才增加1。此外，当创建新列表的循环完成迭代后，这个变量的值也匹配新列表中的元素总数！最终的Python程序如下。
- en: '![](img/my_exercise_header.png) file_33.1-5a'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_33.1-5a'
- en: ELEMENTS = 100
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 100
- en: a = [None] * ELEMENTS
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: a = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: a[i] = int(input())
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: a[i] = int(input())
- en: k = 0
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: k = 0
- en: b = [None] * ELEMENTS
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: b = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: lastDigit = a[i] % 10
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: lastDigit = a[i] % 10
- en: firstDigit = a[i] // 10
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: firstDigit = a[i] // 10
- en: 'if firstDigit == 5 or lastDigit == 5:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'if firstDigit == 5 or lastDigit == 5:'
- en: b[k] = a[i]
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b[k] = a[i]
- en: k += 1
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: k += 1
- en: 'for i in range(k):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(k):'
- en: print(b[i], end = "\t")
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: print(b[i], end = "\t")
- en: Second approach
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法
- en: As in the previous exercise, the main disadvantage of the first approach is
    that it initializes list b to a size of 100, regardless of the fact that the user
    may or may not enter integers that contain at least one instance of the digit
    5! Using the append() method, the next approach is more efficient and more Pythonic!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个练习所示，第一种方法的主要缺点是它将列表b初始化为100的大小，而不管用户是否输入包含至少一个5的数字！使用append()方法，第二种方法更高效，也更符合Python风格！
- en: '![](img/my_exercise_header.png) file_33.1-5b'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_33.1-5b'
- en: ELEMENTS = 100
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 100
- en: a = []
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: a = []
- en: 'for i in range(ELEMENTS):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: a.append(int(input()))
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: a.append(int(input()))
- en: b = []
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: b = []
- en: 'for element in a:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'for element in a:'
- en: firstDigit, lastDigit = divmod(element, 10)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: firstDigit, lastDigit = divmod(element, 10)
- en: 'if 5 in [firstDigit, lastDigit]:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'if 5 in [firstDigit, lastDigit]:'
- en: b.append(element)
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b.append(element)
- en: 'for element in b:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'for element in b:'
- en: print(element, end = "\t")
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: print(element, end = "\t")
- en: 33.2 Data Validation with Lists
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.2 使用列表进行数据验证
- en: As you have already been taught in [Section 29.3](chapter29.html#toc_11), there
    are three approaches that you can use to validate data input. Your approach will
    depend on whether or not you wish to display an error message, and whether you
    wish to display a different error message for each type of input error or just
    a generic error message for any kind of error.  Let's see how those three approaches
    can be adapted and used with lists.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如你已在 [第 29.3 节](chapter29.html#toc_11) 中所学，你可以使用三种方法来验证数据输入。你的方法将取决于你是否希望显示错误信息，以及你是否希望为每种输入错误显示不同的错误信息，或者只是显示通用的错误信息。
- en: First approach – Validating data input without error messages
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法 – 无错误信息验证数据输入
- en: In [Section 29.3](chapter29.html#toc_11), you learned how to validate one single
    value entered by the user without displaying any error messages. For your convenience,
    the code fragment given in general form is presented once again.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 29.3 节](chapter29.html#toc_11) 中，你学习了如何不显示任何错误信息来验证用户输入的单个值。为了方便起见，以下再次给出一般形式的代码片段。
- en: 'while True:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: input_data = input("Prompt message")
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据 = input("提示信息")
- en: if input_data test 1 succeeds and
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: if 输入数据测试 1 成功并
- en: input_data test 2 succeeds and
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据测试 2 成功并
- en: …
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: 'input_data test N succeeds: break'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据测试 N 成功：break
- en: Do you remember how this operates? If the user enters a valid value, the flow
    of execution simply proceeds to the next section of the program. However, if they
    enter an invalid value, the primary objective is to repeatedly prompt them until
    they eventually provide a valid one.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得它是如何工作的吗？如果用户输入一个有效的值，执行流程将简单地继续到程序的下一部分。然而，如果他们输入一个无效的值，主要目标是反复提示他们，直到他们最终提供一个有效的值。
- en: You can use the same principle when entering data into lists. If you use a for-loop
    to iterate for all elements of the list, the code fragment becomes as follows.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当将数据输入列表时，你可以使用相同的原则。如果你使用 for 循环迭代列表的所有元素，代码片段将如下所示。
- en: input_list = [None] * ELEMENTS
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: input_list = [None] * ELEMENTS
- en: for i in range(ELEMENTS)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: for i in range(ELEMENTS)
- en: 'while True:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: input_data = input("Prompt message")
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入数据 = input("提示信息")
- en: if input_data test 1 succeeds and
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if 输入数据测试 1 成功并
- en: input_data test 2 succeeds and
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入数据测试 2 成功并
- en: …
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …
- en: 'input_data test N succeeds: break'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入数据测试 N 成功：break
- en: input_list[i] = input_data
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: input_list[i] = 输入数据
- en: As you can see, when the flow of execution exits the nested post-test loop structure,
    the variable input_data definitely contains a valid value which in turn is assigned
    to an element of the list input_list. However, the same process can be implemented
    more simply, without using the extra variable input_data, as follows.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当执行流程退出嵌套的测试后循环结构时，变量 input_data 一定包含一个有效的值，该值随后被分配到列表 input_list 的一个元素中。然而，同样的过程可以更简单地实现，而不需要使用额外的变量
    input_data，如下所示。
- en: input_list = [None] * ELEMENTS
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: input_list = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: 'while True:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: input_list[i] = input("Prompt message")
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: input_list[i] = input("提示信息")
- en: if input_list[i] test 1 succeeds and
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if input_list[i] 测试 1 成功并
- en: input_list[i] test 2 succeeds and
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: input_list[i] 测试 2 成功并
- en: …
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …
- en: 'input_list[i] test N succeeds: break'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: input_list[i] 测试 N 成功：break
- en: Second approach – Validating data input with a generic error message
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法 – 使用通用错误信息验证数据输入
- en: As before, the next code fragment is taken from [Section 29.3](chapter29.html#toc_11)
    and adapted to operate with a list. It validates data input and displays a generic
    error message (that is, the same error message for any type of input error).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，下一个代码片段取自 [第 29.3 节](chapter29.html#toc_11) 并调整为与列表一起工作。它验证数据输入并为任何类型的输入错误显示通用的错误信息（即，任何类型输入错误的相同错误信息）。
- en: input_list = [None] * ELEMENTS
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: input_list = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: input_list[i] = input("Prompt message")
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: input_list[i] = input("提示信息")
- en: while input_list[i] test 1 fails or
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当 input_list[i] 测试 1 失败或
- en: input_list[i] test 2 fails or
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: input_list[i] 测试 2 失败或
- en: …
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …
- en: 'input_list[i] test N fails:'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: input_list[i] 测试 N 失败：
- en: print("Error message")
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("错误信息")
- en: input_list[i] = input("Prompt message")
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: input_list[i] = input("提示信息")
- en: Third approach – Validating data input with different error messages
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法 – 使用不同错误信息验证数据输入
- en: Once again, the next code fragment is taken from [Section 29.3](chapter29.html#toc_11)
    and adapted to operate with a list. It validates data input and displays a different
    error message for each type of input error.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，下一个代码片段取自 [第 29.3 节](chapter29.html#toc_11) 并调整为与列表一起工作。它验证数据输入并为每种输入错误显示不同的错误信息。
- en: input_list = [None] * ELEMENTS
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: input_list = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: 'while True:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: input_list[i] = input("Prompt message")
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: input_list[i] = input("提示消息")
- en: failure = False
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = False
- en: 'if input_list[i] test 1 fails:'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if input_list[i] test 1 fails:'
- en: print("Error message 1")
  id: totrans-271
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("错误消息1")
- en: failure = True
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: 'elif input_list[i] test 2 fails:'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'elif input_list[i] test 2 fails:'
- en: print("Error message 2")
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("错误消息2")
- en: failure = True
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: elif …
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: elif …
- en: …
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …
- en: 'elif input_list[i] test N fails:'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'elif input_list[i] test N fails:'
- en: print("Error message N")
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("错误消息N")
- en: failure = True
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: 'if not failure: break'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if not failure: break'
- en: Exercise 33.2-1 Displaying Odds in Reverse Order
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习33.2-1 以相反顺序显示奇数
- en: 'Write a Python program that prompts the user to enter 20 odd positive integers
    into a list and then displays them in the exact reverse of the order in which
    they were provided. The program must validate data input, preventing the user
    from entering a non-positive value, a float, or an even integer. Solve this exercise
    in three versions:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，提示用户输入20个奇数正整数到一个列表中，然后以它们提供的顺序的相反顺序显示它们。程序必须验证数据输入，防止用户输入非正值、浮点数或偶数整数。以三种版本解决这个练习：
- en: a)Validate data input without displaying any error messages.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: a)在没有显示任何错误消息的情况下验证数据输入。
- en: b)Validate data input and display a generic error message.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: b)验证数据输入并显示一个通用的错误消息。
- en: c)Validate data input and display a different error message for each type of
    input error.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: c)验证数据输入并显示不同类型的输入错误的不同错误消息。
- en: Solution
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: All three approaches for validating data input that you learned in [Section
    33.2](#toc_7) will be presented here. Let's first solve this exercise without
    data validation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第33.2节](#toc_7)中学习到的所有三种验证数据输入的方法都将在此处展示。让我们首先在不进行数据验证的情况下解决这个练习。
- en: ELEMENTS = 20
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 20
- en: odds = [None] * ELEMENTS
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: odds = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: 'x = int(input("Enter an odd positive integer: "))   [[More…]](more.html#more_33_2_1_1)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = int(input("输入一个奇数正整数: "))   [[更多…]](more.html#more_33_2_1_1)'
- en: odds[i] = x
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: odds[i] = x
- en: '#Display elements backwards             # Or you can do the following'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#以相反的顺序显示元素             # 或者你可以这样做'
- en: 'for i in range(ELEMENTS - 1, -1, -1):   # for element in odds[::-1]:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS - 1, -1, -1):   # for element in odds[::-1]:'
- en: print(odds[i], end = "\t")          #     print(element, end = "\t")
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: print(odds[i], end = "\t")          #     print(element, end = "\t")
- en: Validation without error messages
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 无错误消息的验证
- en: To validate data input without displaying any error messages, use the first
    approach from [Section 33.2](#toc_7). Simply replace the statements marked with
    a dashed rectangle with the following code fragment.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要在没有显示任何错误消息的情况下验证数据输入，请使用[第33.2节](#toc_7)中的第一种方法。只需将带有虚线矩形的语句替换为以下代码片段。
- en: 'while True:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'x = float(input("Enter an odd positive integer: "))'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("输入一个奇数正整数: "))'
- en: 'if x > 0 and x == int(x) and x % 2 != 0: break'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 0 and x == int(x) and x % 2 != 0: break'
- en: odds[i] = int(x)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: odds[i] = int(x)
- en: The final program becomes
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最终程序如下
- en: '![](img/my_exercise_header.png) file_33.2-1a'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_33.2-1a'
- en: ELEMENTS = 20
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 20
- en: odds = [None] * ELEMENTS
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: odds = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: while True:                                    [[More…]](more.html#more_33_2_1_2)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: while True:                                    [[更多…]](more.html#more_33_2_1_2)
- en: 'x = float(input("Enter an odd positive integer: "))'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'x = float(input("输入一个奇数正整数: "))'
- en: 'if x > 0 and x == int(x) and x % 2 != 0: break'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if x > 0 and x == int(x) and x % 2 != 0: break'
- en: odds[i] = int(x)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: odds[i] = int(x)
- en: '#Display elements backwards             # Or you can do the following'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '#以相反的顺序显示元素             # 或者你可以这样做'
- en: 'for i in range(ELEMENTS - 1, -1, -1):   # for element in odds[::-1]:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS - 1, -1, -1):   # for element in odds[::-1]:'
- en: print(odds[i], end = "\t")          #     print(element, end = "\t")
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: print(odds[i], end = "\t")          #     print(element, end = "\t")
- en: '![](img/notice.jpg)Variable x must be of type float. This is necessary in order
    to allow the user to enter either an integer or a float (real).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)变量x必须是浮点型。这是为了允许用户输入整数或浮点数（实数）。'
- en: Validation with a generic error message
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 带有通用错误消息的验证
- en: To validate data input and display a generic error message, replace the statements
    marked with the dashed rectangle with a code fragment based on the second approach
    from [Section 33.2](#toc_7). The Python program is as follows.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证数据输入并显示一个通用的错误消息，请将带有虚线矩形的语句替换为[第33.2节](#toc_7)中第二种方法的基础代码片段。Python程序如下。
- en: '![](img/my_exercise_header.png) file_33.2-1b'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_33.2-1b'
- en: ELEMENTS = 20
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 20
- en: odds = [None] * ELEMENTS
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: odds = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: 'x = float(input("Enter an odd positive integer: "))   [[More…]](more.html#more_33_2_1_3)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 'x = float(input("请输入一个奇数正整数: "))   [[更多…]](more.html#more_33_2_1_3)'
- en: 'while x <= 0 or x != int(x) or x % 2 == 0:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'while x <= 0 or x != int(x) or x % 2 == 0:'
- en: print("Invalid value!")
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("无效值！")
- en: 'x = float(input("Enter an odd positive integer: "))'
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'x = float(input("请输入一个奇数正整数: "))'
- en: odds[i] = int(x)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: odds[i] = int(x)
- en: '#Display elements backwards'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '#反向显示元素'
- en: 'for element in odds[::-1]:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'for element in odds[::-1]:'
- en: print(element, end = "\t")
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: print(element, end = "\t")
- en: Validation with different error messages
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的错误信息进行验证
- en: Here, the replacing code fragment is based on the third approach from [Section
    33.2](#toc_7). To validate data input and display a different error message for
    each type of input error, the Python program is as follows.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，替换的代码片段基于[第33.2节](#toc_7)的第三种方法。为了验证数据输入并显示针对每种输入错误的错误信息，Python程序如下。
- en: '![](img/my_exercise_header.png) file_33.2-1c'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_33.2-1c'
- en: ELEMENTS = 20
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ELEMENTS = 20
- en: odds = [None] * ELEMENTS
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: odds = [None] * ELEMENTS
- en: 'for i in range(ELEMENTS):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ELEMENTS):'
- en: while True:                                      [[More…]](more.html#more_33_2_1_4)
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: while True:                                      [[更多…]](more.html#more_33_2_1_4)
- en: 'x = float(input("Enter an odd positive integer: "))'
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'x = float(input("请输入一个奇数正整数: "))'
- en: failure = False
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = False
- en: 'if x <= 0 :'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if x <= 0 :'
- en: 'print("Invalid value: Non-positive entered!")'
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("无效值：输入了非正数！")
- en: failure = True
  id: totrans-341
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: 'elif x != int(x):'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'elif x != int(x):'
- en: 'print("Invalid value: Float entered!")'
  id: totrans-343
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("无效值：输入了浮点数！")
- en: failure = True
  id: totrans-344
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: 'elif x % 2 == 0:'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'elif x % 2 == 0:'
- en: 'print("Invalid value: Even entered!")'
  id: totrans-346
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: print("无效值：输入了偶数！")
- en: failure = True
  id: totrans-347
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: failure = True
- en: 'if not failure: break'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'if not failure: break'
- en: odds[i] = int(x)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: odds[i] = int(x)
- en: '#Display elements backwards'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '#反向显示元素'
- en: 'for element in odds[::-1]:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'for element in odds[::-1]:'
- en: print(element, end = "\t")
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: print(element, end = "\t")
- en: 33.3 Finding Minimum and Maximum Values in Lists
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 33.3 在列表中查找最小和最大值
- en: This is the third and last time that this subject is brought up in this book.
    The first time was in [Section 22.2](chapter22.html#toc_8) using decision control
    structures and the second time was in [Section 29.4](chapter29.html#toc_14) using
    loop control structures. So, there is not much left to discuss except the fact
    that when you want to find the minimum or maximum value of a data structure that
    already contains some values, you needn't worry about the initial values of variables
    minimum or maximum because you can just assign to them the value of the first
    element of the data structure!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中第三次也是最后一次讨论这个主题。第一次是在[第22.2节](chapter22.html#toc_8)中使用决策控制结构，第二次是在[第29.4节](chapter29.html#toc_14)中使用循环控制结构。所以，除了当你想要找到已包含一些值的数据结构的最小或最大值时，不需要担心变量最小或最大值的初始值，因为你可以直接将数据结构的第一个元素的值赋给它们之外，没有太多可讨论的。
- en: Exercise 33.3-1 Which Depth is the Greatest?
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习33.3-1 哪个深度最大？
- en: Write a Python program that lets the user enter the depths of 20 lakes and then
    displays the depth of the deepest one.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，允许用户输入20个湖泊的深度，然后显示最深的一个。
- en: Solution
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: After the user enters the depths of the 20 lakes in the list depths, the initial
    value of variable maximum can be set to the value of depths[0], that is, the first
    element of list depths. The program can then search any subsequent value greater
    than this, starting from index 1\. The final solution is quite straightforward
    and is presented next without further explanation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户输入列表depths中20个湖泊的深度后，变量maximum的初始值可以设置为depths[0]的值，即列表depths的第一个元素。然后程序可以搜索从索引1开始的任何后续值，只要这个值大于这个值。最终的解决方案非常直接，下面将不进行进一步解释。
- en: '![](img/my_exercise_header.png) file_33.3-1a'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/my_exercise_header.png) file_33.3-1a'
- en: LAKES = 20
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: LAKES = 20
- en: depths = [None] * LAKES
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: depths = [None] * LAKES
- en: 'for i in range(LAKES):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(LAKES):'
- en: depths[i] = float(input())
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: depths[i] = float(input())
- en: maximum = depths[0]  #Initial value
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = depths[0]  #初始值
- en: '#Search thereafter, starting from index 1'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '#从索引1开始搜索'
- en: 'for i in range(1, LAKES):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, LAKES):'
- en: 'if depths[i] > maximum:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'if depths[i] > maximum:'
- en: maximum = depths[i]
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: maximum = depths[i]
- en: print(maximum)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: print(maximum)
- en: '![](img/notice.jpg)It wouldn''t be wrong to start iterating from position 0
    instead of 1, though the program would perform one useless iteration.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)虽然从位置0开始迭代而不是1可能不会出错，但程序将执行一次无用的迭代。'
- en: '![](img/notice.jpg)It wouldn''t be wrong to assign an “almost arbitrary” initial
    value to variable maximum but there is no reason to do so. The value of the first
    element is just fine! If you insist though, you can assign an initial value of
    0, since there is no lake on planet Earth with a negative depth.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)将变量 maximum 分配一个“几乎任意”的初始值并没有错，但这样做没有理由。第一个元素的值就很好！如果你坚持的话，你可以分配一个初始值为
    0，因为地球上没有湖泊的深度是负数。'
- en: Keep in mind though, that a more Pythonic way to find the greatest value of
    a list is to use the max() function, as shown here.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，找到列表中最大值的更 Pythonic 方法是使用 max() 函数，如下所示。
- en: '![](img/my_exercise_header.png) file_33.3-1b'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_33.3-1b'
- en: LAKES = 20
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: LAKES = 20
- en: depths = []
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: depths = []
- en: 'for i in range(LAKES):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(LAKES):'
- en: depths.append(float(input()))
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: depths.append(float(input()))
- en: maximum = max(depths)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = max(depths)
- en: print(maximum)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: print(maximum)
- en: '![](img/notice.jpg)Correspondingly, if you want to find the smallest value
    of a list you can use the min() function.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)相应地，如果你想找到列表中最小值，你可以使用 min() 函数。'
- en: Exercise 33.3-2 Which Lake is the Deepest?
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 33.3-2 哪个湖泊最深？
- en: Write a Python program that lets the user enter the names and the depths of
    20 lakes and then displays the name of the deepest one.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，让用户输入 20 个湖泊的名称和深度，然后显示最深湖泊的名称。
- en: Solution
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: If you don't know how to find the name of the deepest lake, you may need to
    refresh your memory by re-reading [Exercise 29.4-2](chapter29.html#toc_16).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道如何找到最深湖泊的名称，你可能需要通过重新阅读 [练习 29.4-2](chapter29.html#toc_16) 来刷新你的记忆。
- en: 'In this exercise, you need two one-dimensional lists: one to hold the names,
    and one to hold the depths of the lakes. The solution is presented next.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你需要两个一维列表：一个用于存储湖泊的名称，另一个用于存储湖泊的深度。解决方案如下。
- en: '![](img/my_exercise_header.png) file_33.3-2'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_33.3-2'
- en: LAKES = 20
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: LAKES = 20
- en: names = [None] * LAKES
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: names = [None] * LAKES
- en: depths = [None] * LAKES
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: depths = [None] * LAKES
- en: 'for i in range(LAKES):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(LAKES):'
- en: names[i] = input()
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: names[i] = input()
- en: depths[i] = float(input())
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: depths[i] = float(input())
- en: maximum = depths[0]
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: maximum = depths[0]
- en: mName = names[0]
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: mName = names[0]
- en: 'for i in range(1, LAKES):'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, LAKES):'
- en: 'if depths[i] > maximum:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 'if depths[i] > maximum:'
- en: maximum = depths[i]
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: maximum = depths[i]
- en: mName = names[i]
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: mName = names[i]
- en: print(mName)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: print(mName)
- en: '![](img/notice.jpg)You cannot use the function max() in this exercise! It would
    return the greatest depth, not the name of the lake with that greatest depth!'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)在这个练习中，你不能使用 max() 函数！它会返回最大的深度，而不是那个最深湖泊的名称！'
- en: Exercise 33.3-3 Which Lake, in Which Country, Having Which Average Area, is
    the Deepest?
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 33.3-3 哪个湖泊，在哪个国家，拥有哪个平均面积，是最深的？
- en: Write a Python program that lets the user enter the names and the depths of
    20 lakes as well as the country in which they belong, and their average area.
    The program must then display all available information about the deepest lake.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，让用户输入 20 个湖泊的名称、深度以及它们所属的国家和平均面积。程序必须然后显示关于最深湖泊的所有可用信息。
- en: Solution
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: Let's look at the next example of six lakes. The depths are expressed in feet
    and the average areas in square miles.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个例子，六个湖泊的深度以英尺表示，平均面积以平方英里表示。
- en: '![Image](img/chapter33-05.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![图像](img/chapter33-05.png)'
- en: It's evident that Lake Baikal holds the record as the deepest lake, positioned
    at index 2\. If you were to approach this exercise in a manner similar to the
    previous exercise ([Exercise 33.3-2](#toc_11)), you would need three more variables
    to keep the name, country, and area each time a depth greater than the previously
    stored one is found. However, the solution presented below employs a more efficient
    approach, using only one variable (indexOfMax) to track the index where these
    values are located.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，贝加尔湖保持着最深湖泊的记录，位于索引 2。如果你要以类似于上一个练习（[练习 33.3-2](#toc_11)）的方式来做这个练习，你需要三个额外的变量来保存每次找到比之前存储的深度更大的深度时的名称、国家和面积。然而，下面提供的解决方案采用了一种更有效的方法，只使用一个变量（indexOfMax）来跟踪这些值所在的索引。
- en: '![](img/my_exercise_header.png) file_33.3-3'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '![我的练习标题](img/my_exercise_header.png) file_33.3-3'
- en: LAKES = 20
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: LAKES = 20
- en: names = [None] * LAKES
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: names = [None] * LAKES
- en: depths = [None] * LAKES
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: depths = [None] * LAKES
- en: countries = [None] * LAKES
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: countries = [None] * LAKES
- en: areas = [None] * LAKES
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: areas = [None] * LAKES
- en: 'for i in range(LAKES):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(LAKES):'
- en: names[i] = input()
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: names[i] = input()
- en: depths[i] = float(input())
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: depths[i] = float(input())
- en: countries[i] = input()
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: countries[i] = input()
- en: areas[i] = float(input())
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: areas[i] = float(input())
- en: '#Find the maximum depth and the index in which this maximum depth exists'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '#找到最大深度及其索引'
- en: maximum = depths[0]
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: indexOfMax = 0
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, LAKES):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'if depths[i] > maximum:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: maximum = depths[i]
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexOfMax = i
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display information using indexOfMax as index'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: print(depths[indexOfMax], names[indexOfMax], end = " ")
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: print(countries[indexOfMax], areas[indexOfMax])
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Assigning an initial value of 0 to variable indexOfMax is
    necessary since there is always a possibility that the maximum value does exist
    in position 0.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-4 Which Students Have got the Greatest Grade?
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names and the grades
    of 200 students and then displays the names of all those who share the one greatest
    grade. Using a loop control structure, the program must also validate data input
    and display an error message when the user enters an empty name or any negative
    values or values greater than 100 for grades.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need to validate both the names and the grades. A code
    fragment, given in general form, shows the data input stage.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: STUDENTS = 200
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * STUDENTS
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: grades = [None] * STUDENTS
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Prompt the user to enter a name and validate it. It cannot be empty!
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Prompt the user to enter a grade and validate it. It cannot be negative or greater
    than 100.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: After data input stage, a loop control structure must search for the greatest
    value, and then, another loop control structure must search the list grades for
    all values that are equal to that greatest value.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The solution in presented next.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-4'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: STUDENTS = 200
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * STUDENTS
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: grades = [None] * STUDENTS
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '#Prompt the user to enter a name and validate it.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for student No " + str(i + 1) + ": ")'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'while names[i] == "":'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: print("Error! Name cannot be empty!")
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for student No " + str(i + 1) + ": ")'
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Prompt the user to enter a grade and validate it.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'grades[i] = int(input("Enter their grade: "))'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'while grades[i] < 0 or grades[i] > 100:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: print("Invalid value!")
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'grades[i] = int(input("Enter their grade: "))'
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Find the greatest grade'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'maximum = grades[0]                 # Or you can do the following:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, STUDENTS):        # maximum = max(grades)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'if grades[i] > maximum:         #'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'maximum = grades[i]         #'
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Displays the names of all those who share the one greatest grade'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: print("The following students have got the greatest grade:")
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'if grades[i] == maximum:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that this exercise could not have been solved without
    the use of a list.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Keep in mind that the following code fragment is also correct
    but very inefficient.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: print("The following students have got the greatest grade:")
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'if grades[i] == max(grades):'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The reason is that in this example, function max() is called each time the loop
    iterates—that is, 200 times!
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-5 Finding the Minimum Value of a Two-Dimensional List
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the temperatures (in degrees
    Fahrenheit) recorded at the same hour each day in January in 10 different cities.
    The Python program must display the lowest temperature.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following list.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-06.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)The list t has 31 columns (0 to 30), as many as there are
    days in January.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing new here. The initial value of variable minimum can be the
    value of the element t[0][0]. Then, the program can iterate through rows, or even
    through columns, to search for the minimum value. The solution is presented next.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-5a'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '#Read list t'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: t = [[None] * DAYS for i in range(CITIES)]
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: t[i][j] = int(input())
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Find minimum'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: minimum = t[0][0]
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < minimum:'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = t[i][j]
  id: totrans-493
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(minimum)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In this exercise you cannot do the following because if
    you do, and variable j starts from 1, the whole column with index 0 won''t be
    checked!'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '#Find minimum'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: minimum = t[0][0]
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, DAYS):  #This is wrong! Variable j must start from 0'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < minimum:'
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = t[i][j]
  id: totrans-501
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: A more Pythonic way, though, is to find the lowest value of list t using the
    min() function, as shown here.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-5b'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '#Read list t'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: t = []
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: t.append([])
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: t[i].append(int(input()))
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(min(t))
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-6 Finding the City with the Coldest Day
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the names of 10 cities as well
    as the temperatures (in degrees Fahrenheit) recorded at the same hour each day
    in January in those cities. The Python program must display the name of the city
    that had the lowest temperature and on which day it was recorded.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, the following two lists are needed.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-07.png)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
- en: The solution is simple. Every time variable minimum updates its value, two variables,
    m_i and m_j, can hold the current values of variables i and j respectively. In
    the end, these two variables will contain the row index and the column index of
    the position in which the minimum value exists. The solution is as follows.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-6'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * CITIES
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: t = [[None] * DAYS for i in range(CITIES)]
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: names[i] = input()
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: t[i][j] = int(input())
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = t[0][0]
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: m_i = 0
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: m_j = 0
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < minimum:'
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = t[i][j]
  id: totrans-534
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: m_i = i
  id: totrans-535
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: m_j = j
  id: totrans-536
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("Minimum temperature: ", minimum)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'print("City: ", names[m_i])'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Day: ", m_j + 1)'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Assigning an initial value of 0 to variables m_i and m_j
    is necessary since there is always a possibility that the minimum value is the
    value of the element t[0][0].'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-7 Finding the Minimum and the Maximum Value of Each Row
  id: totrans-541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter values into list b of 20 × 30
    elements and then finds and displays the minimum and the maximum values of each
    row.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: There are three approaches, actually. The first approach creates two auxiliary
    one-dimensional lists, minimum and maximum, and then displays them. Lists minimum
    and maximum will contain, in each position, the minimum and the maximum values
    of each row respectively. On the other hand, the second and third approaches find
    and directly display the minimum and maximum values of each row. Let's study them
    all.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Creating auxiliary lists
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this approach, let's use the “from inner to outer” method.
    When the following code fragment completes its iterations, the auxiliary one-dimensional
    lists minimum and maximum will contain at position 0 the minimum and the maximum
    values of the first row (row index 0) of list b respectively. Assume variable
    i contains value 0.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: minimum[i] = b[i][0]
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: maximum[i] = b[i][0]
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum[i]:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: minimum[i] = b[i][j]
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum[i]:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: maximum[i] = b[i][j]
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that variable j starts from 1\. It wouldn''t be wrong
    to start iterating from column index 0 instead of 1, though the program would
    perform one useless iteration.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything has been clarified, in order to process the whole list b,
    you can just nest the previous code fragment into a for-loop that iterates for
    all rows as shown next.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: minimum[i] = b[i][0]
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: maximum[i] = b[i][0]
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum[i]:'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum[i] = b[i][j]
  id: totrans-561
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum[i]:'
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum[i] = b[i][j]
  id: totrans-563
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-7a'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: ROWS = 30
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: COLUMNS = 20
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: b = [[None] * COLUMNS for i in range(ROWS)]
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: b[i][j] = float(input())
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = [None] * ROWS
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: maximum = [None] * ROWS
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: minimum[i] = b[i][0]
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: maximum[i] = b[i][0]
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum[i]:'
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum[i] = b[i][j]
  id: totrans-579
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum[i]:'
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum[i] = b[i][j]
  id: totrans-581
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: print(minimum[i], maximum[i])
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: Second approach – Finding and directly displaying minimum and maximum values
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the “from inner to outer” method once again. The next code fragment
    finds and directly displays the minimum and the maximum values of the first row
    (row index 0) of list b. Assume variable i contains the value 0.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: minimum = b[i][0]
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: maximum = b[i][0]
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: minimum = b[i][j]
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: maximum = b[i][j]
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(minimum, maximum)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: In order to process the whole list b, you can just nest this code fragment into
    a for-loop that iterates for all rows, as follows.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: minimum = b[i][0]
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: maximum = b[i][0]
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum:'
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = b[i][j]
  id: totrans-600
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum:'
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum = b[i][j]
  id: totrans-602
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(minimum, maximum)
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-7b'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: ROWS = 30
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: COLUMNS = 20
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: b = [[None] * COLUMNS for i in range(ROWS)]
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: b[i][j] = float(input())
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: minimum = b[i][0]
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: maximum = b[i][0]
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum:'
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = b[i][j]
  id: totrans-617
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum:'
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum = b[i][j]
  id: totrans-619
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(minimum, maximum)
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Third approach – The Pythonic way
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: This approach uses the min() and max() functions of Python. It finds and directly
    displays the lowest and the highest values of each row.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-7c'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: ROWS = 30
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: COLUMNS = 20
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: b = []
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: b.append([])
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: b[i].append(float(input()))
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for row in b:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: print(min(row), max(row))
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 33.4 Sorting Lists
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sorting algorithms are an important topic in computer science. A sorting algorithm
    is an algorithm that puts elements of a list in a certain order. There are many
    sorting algorithms and each one of them has particular strengths and weaknesses.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Most sorting algorithms work by comparing the elements of the list. They are
    usually evaluated by their efficiency and their memory requirements.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many sorting algorithms. Some of them are:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: ►the bubble sort algorithm
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: ►the modified bubble sort algorithm
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: ►the selection sort algorithm
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: ►the insertion sort algorithm
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: ►the heap sort algorithm
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: ►the merge sort algorithm
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: ►the quicksort algorithm
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: As regards their efficiency, the bubble sort algorithm is considered the least
    efficient, while each succeeding algorithm in the list performs better than the
    preceding one. The quicksort algorithm is considered one of the best and fastest
    sorting algorithms, especially for large scale data operations.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms can be used for more than just displaying data in ascending
    or descending order; they can also assist in finding the minimum and the maximum
    values from a set of given values. For instance, in a list sorted in ascending
    order, the minimum value exists at the first index position and the maximum value
    exists at the last index position. While sorting a list solely for the purpose
    of finding the minimum and maximum values is very inefficient, if a program sorts
    a list for other reasons, and you subsequently need the minimum or maximum value,
    you know where you can find them!
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: Another scenario where you might need sorting algorithms is when you want to
    find and display, for example, the three largest (or smallest) numbers in a list.
    In this case, you can sort the list in descending order and then display only
    the first three elements, located at index positions 0, 1, and 2.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, Python incorporates the method sort() and the function
    sorted() for list sorting. However, there are situations where it's necessary
    to implement a custom sorting algorithm, especially when you need to sort a list
    while preserving the one-to-one correspondence with the elements of a second list.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-1 The Bubble Sort Algorithm – Sorting One-Dimensional Lists with
    Numeric Values
  id: totrans-648
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter 20 numerical values into a list
    and then sorts them in ascending order using the bubble sort algorithm.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: 'The bubble sort algorithm is probably one of the most inefficient sorting algorithms
    but it is widely used for teaching purposes. The main idea (when asked to sort
    a list in ascending order) is to repeatedly move the smallest elements of the
    list to the positions of lowest index. This works as follows: the algorithm iterates
    through the elements of the list, compares each pair of adjacent elements, and
    then swaps their contents (if they are in the wrong order). This process is repeated
    many times until the list is sorted.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's try to sort the following list in ascending order.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter33-08.png)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: The lowest value is the value 5\. According to the bubble sort algorithm, this
    value must gradually “bubble” or “rise” to position 0, like bubbles rising in
    a glass of cola. When the value 5 has been moved into position 0, the next smallest
    value is the value 8\. Now, the value 8 must “bubble” to position 1\. Next is
    the value 12, which must “bubble” to position 2, and so on. This process repeats
    until all elements are placed in proper position.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: But how can this “bubbling” be done using an algorithm? Let's see the whole
    process in more detail. For the previous list A of six elements, five passes must
    be performed.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: First Pass
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 1st Compare
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: Initially, elements at index positions 4 and 5 are compared. Since the value
    12 is less than the value 49, these two elements swap their content.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 2nd Compare
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 3 and 4 are compared. Since the value 12 is not
    less than the value 5, no swapping is done.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: 3rd Compare
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 2 and 3 are compared. Since the value 5 is less
    than the value 8, these two elements swap their content.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 4th Compare
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 1 and 2 are compared. Since the value 5 is less
    than the value 25, these two elements swap their content.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: 5th Compare
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 0 and 1 are compared. Since the value 5 is less
    than the value 17, these two elements swap their content.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-09.png)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
- en: The first pass has been completed but, as you can see, the list has not been
    sorted yet. The only value that is guaranteed to be placed in proper position
    is the value 5\. However, since more passes will follow, there is no need for
    the value 5 to take part in the subsequent compares. In the pass that follows,
    one less compare will be performed—that is, four compares.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: Second Pass
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 1st Compare
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 4 and 5 are compared. Since the value 49 is not
    less than the value 12, no swapping is done.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 2nd Compare
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 3 and 4 are compared. Since the value 12 is not
    less than the value 8, no swapping is done.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 3rd Compare
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 2 and 3 are compared. Since the value 8 is less
    than the value 25, these two elements swap their content.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: 4th Compare
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 1 and 2 are compared. Since the value 8 is less
    than the value 17, these two elements swap their content.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-10.png)'
  id: totrans-678
  prefs: []
  type: TYPE_IMG
- en: The second pass has been completed and the value of 8 is guaranteed to be placed
    in proper position. However, since more passes will follow, there is no need for
    the value 8 (nor 5, of course) to take part in the subsequent compares. In the
    pass that follows, one less compare will be performed—that is, three compares.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: Third Pass
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: In this pass, three compares (but only two swaps) are performed, as shown below.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-11.png)'
  id: totrans-682
  prefs: []
  type: TYPE_IMG
- en: The third pass has been completed and the value of 12 is guaranteed to be placed
    in proper position. As previously, since more passes will follow there is no need
    for the value 12 (nor the values 5 and 8, of course) to take part in the subsequent
    compares. In the pass that follows, one compare less will be performed—that is,
    two compares.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: Fourth Pass
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: In this pass, two compares (and no swaps) are performed, as shown below.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-12.png)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
- en: The fourth pass has been completed and the value 17 is guaranteed to be placed
    in proper position. As previously, since one last pass will follow, there is no
    need for the value 17 (nor the values 5, 8, and 12, of course) to take part in
    the subsequent compares. In the last pass that follows, one compare less will
    be performed—that is one compare.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: Fifth pass
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: In this last pass, only one compare is performed. Since the value 49 is not
    less than the value 25, no swapping is done.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter33-13.png)
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: The fifth pass has been completed and the final two values (25 and 49) are now
    guaranteed to be in proper positions. The bubble sort algorithm has finished and
    the list is sorted in ascending order!
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: Now you need a Python program that can do the whole previous process. Let's
    use the “from inner to outer” method. The code fragment that performs only the
    first pass is shown below. Please note that this is the inner (nested) loop control
    structure. Assume variable m contains the value 0.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < a[n - 1]:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: temp = a[n]
  id: totrans-695
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n] = a[n - 1]
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n - 1] = temp
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In the first pass, variable m must contain the value 0\.
    This assures that at the last iteration, the elements that are compared are those
    at index positions 1 and 0.'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Swapping the contents of two elements uses a method you
    have already learned! Please recall the two glasses of orange juice and lemon
    juice. If this doesn''t ring a bell, you need to refresh your memory and re-read
    [Exercise 8.1-3](chapter08.html#toc_4).'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you can swap the contents of a[n] and a[n − 1] in a more Pythonic
    way, as shown here.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < a[n - 1]:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: a[n], a[n - 1] = a[n - 1], a[n]
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second pass can be performed if you just re-execute the previous code fragment.
    Variable m, however, needs to contain the value 1\. This will ensure that the
    element at index position 0 won't be compared again. Similarly, for the third
    pass, the previous code fragment can be re-executed but variable m needs to contain
    the value 2 for the same reason.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, the previous code fragment needs to be executed five times (one
    for each pass), and each time variable m must be incremented by 1\. The final
    code fragment that sorts list a using the bubble sort algorithm is as follows.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS - 1):'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < a[n - 1]:'
  id: totrans-708
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n], a[n - 1] = a[n - 1], a[n]
  id: totrans-709
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)For N elements, the algorithm needs to perform N − 1 passes.
    For example, if list a contains 20 elements, the statement for m in range(ELEMENTS
    - 1) performs 19 passes.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: The complete Python program is as follows.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-1'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * ELEMENTS
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: a[i] = float(input())
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS - 1):'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < a[n - 1]:'
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n], a[n - 1] = a[n - 1], a[n]
  id: totrans-720
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: print(a[i], end = "\t")
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The bubble sort algorithm is very inefficient. The total
    number of compares that it performs is ![Image](img/chapter33-14.png), where N
    is the total number of list elements.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The total number of swaps depends on the given list. The
    worst case is when you want to sort in ascending order a list that is already
    sorted in descending order, or vice versa.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-2 Sorting One-Dimensional Lists with Alphanumeric Values
  id: totrans-725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that sorts the alphanumeric values of a list in descending
    order using the bubble sort algorithm.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the wording of this exercise to the previous one, two things are different.
    First, the bubble sort algorithm needs to sort alphanumeric values, such as names
    of people or names of cities; and second, it has to sort them in descending order.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: In order to sort alphanumeric data, you don't have to change anything in the
    algorithm! Python handles letters the same way it handles numbers. The letter
    “A” is considered “less than” the letter “B”, “B” is considered “less than” the
    letter “C”, and so on. Of course, if the list contains words in which the first
    letter is identical, Python moves on to compare their second letter and perhaps
    their third letter (if necessary). For example, the name “Johathan” is considered
    “less than” the name “Jone” as the fourth letter “a” is “less than” the fourth
    letter “e”.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Consider the alphanumeric sorting in the context of how
    words are organized in an English dictionary.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see what you need to change so that the algorithm can sort in descending
    order instead of ascending. Do you remember how the bubble sort algorithm actually
    works? Elements gradually “bubble” to positions of lowest index, like bubbles
    rise in a glass of cola. What you want in this exercise is to make the bigger
    (instead of the smaller) elements “bubble” to lower index positions. Therefore,
    all you need to do is simply reverse the comparison operator of the decision control
    structure!
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: The code fragment that sorts alphanumeric, and of course numeric, values in
    descending order is as follows.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: for m in range(ELEMENTS − 1)
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] > a[n - 1]:'
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n], a[n - 1] = a[n - 1], a[n]
  id: totrans-736
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.4-3 Sorting One-Dimensional Lists While Preserving the Relationship
    with a Second List
  id: totrans-737
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the names of 20 lakes and their
    corresponding average area. The program must then sort them by average area in
    ascending order using the bubble sort algorithm.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise you need the following two lists.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-15.png)'
  id: totrans-741
  prefs: []
  type: TYPE_IMG
- en: If you want to sort list areas while preserving the one-to-one correspondence
    between the elements of the two lists, you must rearrange the elements of the
    list names as well. This means that every time two elements of the list areas
    swap contents, the corresponding elements of the list names must swap contents
    as well. The Python program is as follows.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-3'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: LAKES = 20
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * LAKES
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: areas = [None] * LAKES
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(LAKES):'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: names[i] = input()
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: areas[i] = float(input())
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(LAKES - 1):'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(LAKES - 1, m, -1):'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'if areas[n] < areas[n - 1]:'
  id: totrans-752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: areas[n], areas[n - 1] = areas[n - 1], areas[n]
  id: totrans-753
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  id: totrans-754
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(LAKES):'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i], "\t", areas[i])
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-4 Sorting Last and First Names
  id: totrans-757
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the last and first names
    of 100 people. The program must then display the names with the last names sorted
    in alphabetical order. In cases where two or more people share the same last name,
    their first names should be displayed in alphabetical order.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to sort a list while preserving the one-to-one correspondence
    with the elements of a second list. Now, you have to handle the case when two
    last names in the first list are equal. According to the wording of the exercise,
    the corresponding first names in the second list must also be sorted alphabetically.
    For example, the following list lastNm contains the last names of 100 people.
    It is sorted in alphabetical order and it contains the last name “Parker” three
    times. The corresponding first names “Andrew”, “Anna”, and “Chloe”, in list firstNm
    also have to be sorted alphabetically, as shown here.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-16.png)'
  id: totrans-761
  prefs: []
  type: TYPE_IMG
- en: For your convenience, the basic version of the bubble sort algorithm is presented
    once again here. Please note that this algorithm preserves the one-to-one correspondence
    between the elements of lists lastNm and firstNm.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(PEOPLE - 1):'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PEOPLE - 1, m, -1):'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: 'if lastNm[n] < lastNm[n - 1]:'
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lastNm[n], lastNm[n - 1] = lastNm[n - 1], lastNm[n]
  id: totrans-766
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  id: totrans-767
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: To solve this exercise, however, this bubble sort algorithm must be adapted
    correspondingly. According to this basic version of the bubble sort algorithm,
    when the last name at position n is “less” than the last name at position n −
    1, the algorithm swaps the corresponding contents. However, if the last names
    at these positions are equal, the algorithm must then verify whether the corresponding
    first names are in the correct order. If not, a swap is required in the list firstNm.
    The adapted bubble sort algorithm is depicted in the following code fragment.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(PEOPLE - 1):'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PEOPLE - 1, m, -1):'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: 'if lastNm[n] < lastNm[n - 1]:'
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lastNm[n], lastNm[n - 1] = lastNm[n - 1], lastNm[n]
  id: totrans-772
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  id: totrans-773
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif lastNm[n] == lastNm[n - 1]:      #If the last names are equal'
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if firstNm[n] < firstNm[n - 1]:   #check the corresponding first names'
  id: totrans-775
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Swap first names if not in correct order'
  id: totrans-776
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  id: totrans-777
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is presented next.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-4'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: PEOPLE = 100
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '#Read lists firstNm and lastNm'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: firstNm = [None] * PEOPLE
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: lastNm = [None] * PEOPLE
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: 'firstNm[i] = input("First name for person No" + str(i + 1) + ": ")'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: 'lastNm[i] = input("Last name for person No" + str(i + 1) + ": ")'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '#Sort lists lastNm and firstNm'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(PEOPLE - 1):'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PEOPLE - 1, m, -1):'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: 'if lastNm[n] < lastNm[n - 1]:'
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lastNm[n], lastNm[n - 1] = lastNm[n - 1], lastNm[n]
  id: totrans-791
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  id: totrans-792
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif lastNm[n] == lastNm[n - 1]:'
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if firstNm[n] < firstNm[n - 1]:'
  id: totrans-794
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  id: totrans-795
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display lists lastNm and firstNm'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: print(lastNm[i], "\t", firstNm[i])
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-5 Sorting a Two-Dimensional List
  id: totrans-799
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that sorts each column of a two-dimensional list in ascending
    order.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: An example of a two-dimension list is as follows.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-17.png)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
- en: Since this list has seven columns, the bubble sort algorithm needs to be executed
    seven times, one for each column. Therefore, the whole bubble sort algorithm should
    be nested within a for-loop that iterates seven times.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: But let's get things in the right order. Using the “from inner to outer” method,
    the next code fragment sorts only the first column (column index 0) of the two-dimensional
    list a. Assume variable j contains the value 0.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ROWS - 1):'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ROWS - 1, m, -1):'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n][j] < a[n - 1][j]:'
  id: totrans-808
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n][j], a[n - 1][j] = a[n - 1][j], a[n][j]
  id: totrans-809
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, in order to sort all columns, you can nest this code fragment in a for-loop
    that iterates for all of them, as follows.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ROWS - 1):'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ROWS - 1, m, -1):'
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if a[n][j] < a[n - 1][j]:'
  id: totrans-814
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n][j], a[n - 1][j] = a[n - 1][j], a[n][j]
  id: totrans-815
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: That wasn't so difficult, was it?
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-6 The Modified Bubble Sort Algorithm – Sorting One-Dimensional
    Lists
  id: totrans-817
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the weights of 20 people and
    then displays the three heaviest weights and the three lightest weights. Use the
    modified bubble sort algorithm.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: To solve this exercise, the Python program can sort the user-provided data in
    ascending order and then display the elements at index positions 17, 18, and 19
    (for the three heaviest weights) and the elements at index positions 0, 1 and
    2 (for the three lightest weights). But what is that modified version of the bubble
    sort algorithm, and how does it actually work? Suppose you have the following
    list containing the weights of six people.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-18.png)'
  id: totrans-821
  prefs: []
  type: TYPE_IMG
- en: If you look closer, you can confirm for yourself that the only elements not
    in the proper position are those at index positions 3 and 4\. If you swap their
    values, the list w immediately becomes sorted! Unfortunately, the bubble sort
    algorithm doesn't operate this way. For this given list of six elements, it will
    perform five passes either way, with a total of ![Image](img/chapter33-19.png)
    compares, where N is the total number of list elements. For larger lists, the
    total number of compares that the bubble sort algorithm performs increases exponentially!
    For example, for a given list of 1000 elements, the bubble sort algorithm performs
    499,500 compares!
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course the modified bubble sort algorithm can overcome this situation as
    follows: if a complete pass is performed and no swaps have been made, then this
    indicates that the list is now sorted and there is no need for further passes.
    To accomplish this, the Python program can use a flag variable that indicates
    if any swaps were made. At the beginning of a pass, a value of False can be assigned
    to the flag variable; when a swap is made, a value of True is assigned. If, at
    the end of the pass, the flag is still False, this indicates that no swaps have
    been made, thus iterations must stop. The modified bubble sort is shown next.
    It uses the break statement and the flag variable swaps.'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS - 1):'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '#Assign False to variable swaps'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: swaps = False
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '#Perform a new pass'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: 'if w[n] < w[n - 1]:'
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: w[n], w[n - 1] = w[n - 1], w[n]
  id: totrans-830
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: swaps = True
  id: totrans-831
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#If variable swaps is still False, no swaps have been made in this pass. Stop
    iterations!'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 'if not swaps: break'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The value False must be assigned to variable swaps each
    time a new pass starts. This is why the statement swaps = False must be placed
    between the two for statements.'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The statement if not swaps is equivalent to the statement
    if swaps == False'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: The final Python program is shown next.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-6'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: w = [None] * ELEMENTS
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: w[i] = float(input())
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS - 1):'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: swaps = False
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: 'if w[n] < w[n - 1]:'
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: w[n], w[n - 1] = w[n - 1], w[n]
  id: totrans-846
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: swaps = True
  id: totrans-847
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not swaps: break'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: print("The three heaviest weights are:")
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: print(w[-3], w[-2], w[-1])
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: print("The three lightest weights are:")
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: print(w[0], w[1], w[2])
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-7 The Selection Sort Algorithm – Sorting One-Dimensional Lists
  id: totrans-853
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that sorts the elements of a list in ascending order using
    the selection sort algorithm.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: The selection sort algorithm is inefficient for large scale data, as is the
    bubble sort algorithm, but it generally performs better than the latter. It is
    the simplest of all the sorting algorithms and performs well on computer systems
    in which limited main memory (RAM) comes into play.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm finds the smallest (or largest, depending on sorting order) element
    of the list and swaps its content with that at position 0\. Then the process is
    repeated for the remainder of the list; the next smallest (or largest) element
    is found and put into the next position, until all elements are examined.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's try to sort the following list in ascending order.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-20.png)'
  id: totrans-859
  prefs: []
  type: TYPE_IMG
- en: The lowest value is the value 4, found at position 4\. According to the selection
    sort algorithm, this element swaps its content with the element at position 0\.
    The list A becomes
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-21.png)'
  id: totrans-861
  prefs: []
  type: TYPE_IMG
- en: The lowest value in the remainder of the list (index positions 1 to 5) is the
    value 9, found at position 5\. This element swaps its content with the element
    at position 1\. The list A becomes
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-22.png)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
- en: The lowest value in the remainder of the list (index positions 2 to 5) is the
    value 18, found at position 4\. This element swaps its content with the element
    at position 2\. The list A becomes
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-23.png)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
- en: Proceeding the same way, the next lowest value is the value 19, found at position
    5\. The list A becomes
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-24.png)'
  id: totrans-867
  prefs: []
  type: TYPE_IMG
- en: The next lowest value is the value 36, found at position 5\. This element swaps
    its content with the element at position 4 and the list A is finally sorted in
    ascending order!
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-25.png)'
  id: totrans-869
  prefs: []
  type: TYPE_IMG
- en: Now, let's write the corresponding Python program. The “from inner to outer”
    method is used in order to help you better understand the whole process. The next
    code fragment finds the smallest element and then swaps its content with that
    at position 0\. Please note that this is the inner (nested) loop control structure.
    Assume variable m contains the value 0.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: minimum = a[m]
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: indexOfMin = m
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(m, ELEMENTS):'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < minimum:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: minimum = a[n]
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexOfMin = n
  id: totrans-876
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Minimum found! Now, swap values.'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: a[m], a[indexOfMin] = a[indexOfMin], a[m]
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to repeat the process for all elements of the list, you can nest
    this code fragment within a for-loop that iterates for all elements. The final
    selection sort algorithm that sorts a list in ascending order is as follows.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS):'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: minimum = a[m]
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: indexOfMin = m
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(m, ELEMENTS):'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < minimum:'
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = a[n]
  id: totrans-885
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexOfMin = n
  id: totrans-886
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[m], a[indexOfMin] = a[indexOfMin], a[m]
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you wish to sort a list in descending order, all you
    need to do is search for maximum instead of minimum values.'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)As in the bubble sort algorithm, in order to sort alphanumeric
    data with the selection sort algorithm, you can do one simple thing: leave the
    algorithm as is!'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-8 Sorting One-Dimensional Lists While Preserving the Relationship
    with a Second List
  id: totrans-890
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the total number of kWh
    consumed each month for a period of one year. It then displays the three months
    with the highest consumption of kWh, along with the corresponding number of KWh
    (in descending order). Use the selection sort algorithm.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise you need the following two one-dimensional lists.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-26.png)'
  id: totrans-894
  prefs: []
  type: TYPE_IMG
- en: While the selection sort algorithm sorts the elements of list kwh, the one-to-one
    correspondence with the elements of list months must be preserved. This means
    that every time two elements of list kwh swap contents, the corresponding elements
    of list months must swap their contents as well.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: However, given that you solely require the three months with the highest consumption
    of KWh, the selection sort algorithm should sort only the first three elements.
    The Python program is as follows.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-8'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: months = ["January", "February", "March", "April", "May", "June",
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '"July", "August", "September", "October", "November", "December"]'
  id: totrans-899
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kwh = [None] * len(months)
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(months)):'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: 'kwh[i] = float(input("Enter kWh for " + months[i] + ": "))'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(3):     #Sort only the first three elements'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: maximum = kwh[m]
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: indexOfMax = m
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(m, len(months)):'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: 'if kwh[n] > maximum:'
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum = kwh[n]
  id: totrans-908
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexOfMax = n
  id: totrans-909
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Swap values of kwh'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: kwh[m], kwh[indexOfMax] = kwh[indexOfMax], kwh[m]
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '#Swap values of months'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: months[m], months[indexOfMax] = months[indexOfMax], months[m]
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: print(months[i], ":", kwh[i])
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If this exercise required the use of the bubble sort instead
    of the selection sort algorithm, you could employ the same “trick”. The algorithm
    could perform 3 passes instead of ELEMENTS – 1 passes.'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-9 The Insertion Sort Algorithm – Sorting One-Dimensional Lists
  id: totrans-917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that sorts the elements of a list in ascending order using
    the insertion sort algorithm.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: The insertion sort algorithm is inefficient for large scale data, as are the
    selection and the bubble sort algorithms, but it generally performs better than
    either of them. Moreover, the insertion sort algorithm can prove very fast when
    sorting very small lists— sometimes even faster than the quicksort algorithm.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: 'The insertion sort algorithm resembles the way you might sort playing cards.
    You start with all the cards face down on the table. The cards on the table represent
    the unsorted “list”. In the beginning your left hand is empty, but in the end
    this hand will hold the sorted cards. The process goes as follows: you remove
    from the table one card at a time and insert it into the correct position in your
    left hand. To find the correct position for a card, you compare it with each of
    the cards already in your hand, from right to left. At the end, there must be
    no cards on the table and your left hand will hold all the cards, sorted.'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's try to sort the following list in ascending order. To better
    understand this example, assume that the sorting process has already begun and
    the first three elements of the list have been sorted.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-27.png)'
  id: totrans-923
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)The elements at index positions 0, 1, and 2 represent the
    cards in your left hand, while the remaining elements of the list represent the
    unsorted cards on the table.'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: The element at position 3 (which is 8) is removed from the list and all elements
    on its left with a value greater than 8 are shifted to the right. The list A becomes
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-28.png)'
  id: totrans-926
  prefs: []
  type: TYPE_IMG
- en: Now that a position has been released, the value 8 is inserted in there. The
    list becomes
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-29.png)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
- en: The element at position 4 (which is 10) is removed from the list and all elements
    on its left with a value greater than 10 are shifted to the right. The list A
    becomes
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-30.png)'
  id: totrans-930
  prefs: []
  type: TYPE_IMG
- en: Now that a position has been released, the value of 10 is inserted in there.
    The list becomes
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-31.png)'
  id: totrans-932
  prefs: []
  type: TYPE_IMG
- en: The element at position 5 (which is 18) is removed from the list and all elements
    on its left with a value greater than 18 are shifted to the right. The list A
    becomes
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-32.png)'
  id: totrans-934
  prefs: []
  type: TYPE_IMG
- en: The value of 18 is inserted in the released position. The list becomes
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-33.png)'
  id: totrans-936
  prefs: []
  type: TYPE_IMG
- en: The element at position 6 (which is 9) is removed from the list and all elements
    on its left with a value greater than 9 are shifted to the right. The list A becomes
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-34.png)'
  id: totrans-938
  prefs: []
  type: TYPE_IMG
- en: Finally, the value of 9 is inserted in the released position, the algorithm
    finishes and the list is now sorted.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-35.png)'
  id: totrans-940
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)What the algorithm actually does is to check the unsorted
    elements one by one and insert each one in the appropriate position among those
    considered already sorted.'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: The code fragment that sorts a list in ascending order using the insertion sort
    algorithm is as follows.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, ELEMENTS):'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: '#"Remove" the element at index position m from the list and keep it in variable
    element'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: element = a[m]
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '#Shift appropriate elements to the right'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: n = m
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: 'while n > 0 and a[n - 1] > element:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: a[n] = a[n - 1]
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Insert the previously "removed" element at index position n'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: a[n] = element
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Please note that the element at index position m is not
    actually removed from the list but is in fact overwritten when shifting to the
    right is performed. This is why its value is kept in variable element before shifting
    the elements.'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you wish to sort a list in descending order, all you
    need to do is alter the Boolean expression of the while statement to n > 0 and
    a[n − 1] < element.'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)As in the previous two sorting algorithms, in order to
    sort alphanumeric data, you don''t have to change anything in this algorithm!'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-10 The Three Worst Elapsed Times
  id: totrans-956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ten race car drivers run their cars as fast as possible on a racing track. Each
    car runs 20 laps and for each lap the corresponding elapsed time (in seconds)
    is recorded. Write a Python program that prompts the user to enter the name of
    each driver and their elapsed time for each lap. The program must then display
    the name of each driver along with their three worst elapsed times. Use the insertion
    sort algorithm.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following two lists.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-36.png)'
  id: totrans-960
  prefs: []
  type: TYPE_IMG
- en: After the user enters all data, the Python program must sort each row of the
    list in descending order but, in the end, must display only the first three columns.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: Using the “from inner to outer” method, the next code fragment sorts only the
    first row (row index 0) of the two-dimensional list elapsedTimes in descending
    order using the insertion sort algorithm. Assume variable i contains the value
    0.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, LAPS):'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: element = elapsedTimes[i][m]
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: n = m
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: 'while n > 0 and elapsedTimes[i][n - 1] < element:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = elapsedTimes[i][n - 1]
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = element
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to sort all rows, you need to nest this code fragment in a for-loop
    that iterates for all of them, as follows.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CARS):'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, LAPS):'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: element = elapsedTimes[i][m]
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n = m
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while n > 0 and elapsedTimes[i][n - 1] < element:'
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = elapsedTimes[i][n - 1]
  id: totrans-976
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  id: totrans-977
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = element
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And now, let's focus on the given exercise. The final Python program is as follows.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-10'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: CARS = 10
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: LAPS = 20
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '#Read names and elapsed times all together'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * CARS
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: elapsedTimes = [[None] * LAPS for i in range(CARS)]
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CARS):'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for driver No." + str(i + 1) + ": ")'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(LAPS):'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: 'elapsedTimes[i][j] = float(input("Enter elapsed time for lap No" + str(j +
    1) + ": "))'
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Sort list elapsedTimes'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CARS):'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, LAPS):'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: element = elapsedTimes[i][m]
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n = m
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while n > 0 and elapsedTimes[i][n - 1] < element:'
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = elapsedTimes[i][n - 1]
  id: totrans-996
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  id: totrans-997
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = element
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display 3 worst elapsed times'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CARS):'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: print("Worst elapsed times of", names[i])
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: print("-------------------------------------")
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(3):'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: print(elapsedTimes[i][j])
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 33.5 Searching Elements in Data Structures
  id: totrans-1005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In computer science, a search algorithm is an algorithm that searches for an
    item with specific features within a set of data. In the case of a data structure,
    a search algorithm searches the data structure to find the element, or elements,
    that equal a given value.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: When searching in a data structure, there can be two situations.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: ►You want to search for a given value in a data structure that may contain the
    same value multiple times. Therefore, you need to find all the elements (or their
    corresponding indexes) that are equal to that given value.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: ►You want to search for a given value in a data structure where each value is
    unique. Therefore, you need to find just one element (or its corresponding index),
    the one that is equal to that given value, and then stop searching any further!
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used search algorithms are:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: ►the linear (or sequential) search algorithm
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: ►the binary search algorithm
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: Both linear and binary search algorithms have advantages and disadvantages.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-1 The Linear Search Algorithm – Searching in a One-Dimensional
    List that may Contain the Same Value Multiple Times
  id: totrans-1014
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that performs a search on a one-dimensional list to find
    a user-provided value. Assume that the list contains numerical values and may
    contain the same value multiple times. Use the linear search algorithm.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: The linear (or sequential) search algorithm checks if the first element of the
    list is equal to a given value, then checks the second element, then the third,
    and so on until the end of the list. Since this process of checking elements one
    by one is quite slow, the linear search algorithm is suitable for lists with few
    elements.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: The code fragment is shown next. It looks for the user-provided value needle
    in the list haystack!
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] == needle:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", i)
  id: totrans-1023
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1024
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-2 Display the Last Names of All Those People Who Have the Same
    First Name
  id: totrans-1027
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write a Python program that prompts the user to enter the names of 20 people:
    their first names into the list firstNames, and their last names into the list
    lastNames. The program must then ask the user for a first name, upon which it
    will search and display the last names of all those whose first name equals the
    provided one.'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: Even though it is not clear in the wording of the exercise, it is true that
    the list firstNames may contain a value multiple times. How rare is it to meet
    two people named “John”, for example?
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: The program must search for the user-provided first name in list firstNames
    and every time it finds it, it must display the corresponding last name from the
    other list.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: The solution is as follows.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-2'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: PEOPLE = 20
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: firstNames = [None] * PEOPLE
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: lastNames = [None] * PEOPLE
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: 'firstNames[i] = input("Enter first name: ")'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: 'lastNames[i] = input("Enter last name: ")'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '#Get name to search and convert it to uppercase'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = input("Enter a first name to search: ").upper()'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '#Search for user-provided value in list firstNames'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: 'if firstNames[i].upper() == needle:   #Convert to uppercase and compare'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: print(lastNames[i])
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: print("No one found!")
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Since the program deals with alphanumeric data, the upper()
    method is required so that the program can operate correctly for any user-provided
    value. For example, if the value “John” exists in the list firstNames and the
    user wants to search for the value “JOHN”, the upper() method ensures that the
    program finds all Johns.'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-3 The Linear Search Algorithm – Searching in a Two-Dimensional
    List that May Contain the Same Value Multiple Times
  id: totrans-1051
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that performs a search on each row of a two-dimensional
    list to find a user-provided value. Assume that the list contains numerical values
    and may contain the same value multiple times. Use the linear search algorithm.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: This code fragment must search for the user-provided number in each row of a
    two-dimensional list that may contain the same value multiple times. This means
    that the code fragment must search in the first row and display all the columns
    where the user-provided number is found; otherwise, it must display a message
    that the user-provided number was not found in the first row. Then, it must search
    in the second row, and this process must continue until all rows have been examined.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this exercise, the “inner to outer” method is used. The
    following code fragment searches for a given value (variable needle) only in the
    first row of the two-dimensional list named haystack. Assume variable i contains
    the value 0.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: print("Found at column", j)
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found in row", i)
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to search in all rows, you need to nest this code fragment in
    a for-loop that iterates for all of them, as follows.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  id: totrans-1068
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Found at column", j)
  id: totrans-1069
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1070
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found in row", i)
  id: totrans-1072
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.5-4 The Linear Search Algorithm – Searching in a One-Dimensional
    List that Contains Unique Values
  id: totrans-1073
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that performs a search on a one-dimensional list to find
    a user-provided value. Assume that the list contains numerical values and each
    value in the list is unique. Use the linear search algorithm.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: This case is quite different from the previous ones. Since each value in the
    list is unique, when the user-provided value is found, there is no need to iterate
    without reason until the end of the list, thus wasting CPU time. There are three
    approaches, actually! Let's analyze them all!
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Using the break statement
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, when the user-provided value is found, a break statement is
    used to break out of the for-loop. The solution is as follows.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] == needle:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", i)
  id: totrans-1083
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1085
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Or you can do the same, in a little bit different way.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: indexPosition = -1
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] == needle:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: indexPosition = i
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if indexPosition == -1:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", indexPosition)
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: Second approach – Using a flag
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: The break statement doesn't actually exist in all computer languages; and since
    this book's intent is to teach you “Algorithmic Thinking” (and not just special
    statements that only Python supports), let's look at an alternate approach.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: In the next code fragment, when the user-provided value is found within list
    haystack, the variable found forces the flow of execution to immediately exit
    the loop.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < ELEMENTS and not found:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] == needle:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexPosition = i
  id: totrans-1108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: i += 1
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", indexPosition)
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: Third approach – Using only a pre-test loop structure
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is likely the most efficient among the three. The while-loop
    iterates through the list, comparing each element with the needle. The loop continues
    as long as two conditions are met: variable i (representing the index) is within
    the valid range for the list haystack, and the value at the current index in the
    list is not equal to the needle. If both conditions are True, variable i is incremented
    to move to the next element. This process continues until a match is found or
    until the end of the list is reached.'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < ELEMENTS - 1 and haystack[i] != needle:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] != needle:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", i)
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-5 Searching for a Social Security Number
  id: totrans-1124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the United States, the Social Security Number (SSN) is a nine-digit identity
    number applied to all U.S. citizens in order to identify them for the purposes
    of Social Security. Write a Python program that prompts the user to enter the
    SSN and the first and last names of 100 people. The program must then ask the
    user for an SSN, upon which it will search and display the first and last name
    of the person who holds that SSN.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: In the United States, there is no possibility that two or more people will have
    the same SSN. Thus, even though it is not clear in the wording of the exercise,
    each value in the list that holds the SSNs is unique!
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: According to everything you have learned so far, the solution to this exercise
    is as follows.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-5'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: PEOPLE = 100
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: SSNs = [None] * PEOPLE
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: firstNames = [None] * PEOPLE
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: lastNames = [None] * PEOPLE
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: 'SSNs[i] = input("Enter SSN: ")'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: 'firstNames[i] = input("Enter first name: ")'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: 'lastNames[i] = input("Enter last name: ")'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = input("Enter an SSN to search: ")'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '#Search for user-provided value in list SSNs'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < PEOPLE - 1 and SSNs[i] != needle:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: 'if SSNs[i] != needle:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: print(firstNames[i], lastNames[i])
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-6 The Linear Search Algorithm – Searching in a Two-Dimensional
    List that Contains Unique Values
  id: totrans-1147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A public opinion polling company makes phone calls in 10 cities and asks 30
    citizens in each city whether or not they exercise. Write a Python program that
    prompts the user to enter each citizen's phone number and their answer (Y for
    Yes, N for No, S for Sometimes). The program must then prompt the user to enter
    a phone number, and it will search and display the answer that was provided at
    this phone number. The program must also validate data input and accept only the
    values Y, N, or S as an answer.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following two lists.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-37.png)'
  id: totrans-1151
  prefs: []
  type: TYPE_IMG
- en: Even though it is not clear in the wording of the exercise, each value in the
    list phoneNum is unique! The program must search for the user-provided number
    and if it finds it, it must stop searching thereafter. The solution is as follows.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-6'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: CITIZENS = 30
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: phoneNum = [[None] * CITIZENS for i in range(CITIES)]
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: ans = [[None] * CITIZENS for i in range(CITIES)]
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: print("City No.", i + 1)
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(CITIZENS):'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: 'phoneNum[i][j] = input("Enter phone number of citizen No." + str(j + 1) + ":
    ")'
  id: totrans-1161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'ans[i][j] = input("Enter the answer of citizen No." + str(j + 1) + ": ").upper()'
  id: totrans-1162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while ans[i][j] not in ["Y", "N", "S"]:'
  id: totrans-1163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'ans[i][j] = input("Wrong answer. Enter a valid one: ").upper()'
  id: totrans-1164
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'needle = input("Enter a phone number to search: ")'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(CITIZENS):'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: 'if phoneNum[i][j] == needle: #If it is found'
  id: totrans-1169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1170
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: positionI = i  #Keep row index where needle was found
  id: totrans-1171
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: positionJ = j  #Keep column index where needle was found
  id: totrans-1172
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break  #Exit the inner loop
  id: totrans-1173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: 'break   #If it is found, exit the outer loop as well'
  id: totrans-1175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: print("Phone number not found!")
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: print("Phone number", phoneNum[positionI][positionJ], "gave '", end = "")
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: 'if ans[positionI][positionJ] == "Y":'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: print("Yes", end = "")
  id: totrans-1181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif ans[positionI][positionJ] == "N":'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: print("No", end = "")
  id: totrans-1183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: print("Sometimes", end = "")
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("' as an answer")
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-7 Checking if a Value Exists in all Columns
  id: totrans-1187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter numeric values into a 20 × 30
    list. After all of the values have been entered, the program then lets the user
    enter a value. In the end, a message must be displayed if the user-provided value
    exists, at least once, in each column of the list.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: This exercise can be solved using the linear search algorithm and a counter
    variable count. The Python program will iterate through the first column; if the
    user-provided value is found, the Python program must stop searching in the first
    column thereafter, and the variable count must increment by one. Then, the program
    will iterate through the second column; if the user-provided value is found again,
    the Python program must stop searching in the second column thereafter, and the
    variable count must once more increment by one. This process must repeat until
    all columns have been examined. At the end of the process, if the value of count
    is equal to the total number of columns, this means that the user-provided value
    exists, at least once, in each column of the list.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the “from inner to outer” method. The following code fragment searches
    in first column (column index 0) of the list and if the user-provided value is
    found, the flow of execution exits the for-loop and variable count increments
    by one. Assume variable j contains the value 0.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: Now you can nest this code fragment in a for-loop that iterates for all columns.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  id: totrans-1203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1204
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1205
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-1207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You are almost ready—but consider a small detail! If the inner for-loop doesn't
    find the user-provided value in a column, the outer for-loop must stop iterating.
    It is pointless to continue because the user-provided value does not exist in
    at least one column. Thus, a better approach would be to use a break statement
    for the outer loop as shown in the code fragment that follows.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  id: totrans-1212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1213
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-1216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: break
  id: totrans-1218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-7'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: ROWS = 20
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: COLUMNS = 30
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: haystack = [[None] * COLUMNS for i in range(ROWS)]
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: haystack[i][j] = float(input())
  id: totrans-1226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  id: totrans-1232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1233
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1234
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-1236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: break
  id: totrans-1238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if count == COLUMNS:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found in every column!")
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you need a message to be displayed when a user-provided
    value exists at least once in each row (rather than in each column), the Python
    program can follow a procedure like the one previously shown but in this case,
    it must iterate through the rows instead of the columns.'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-8 The Binary Search Algorithm – Searching in a Sorted One-Dimensional
    List
  id: totrans-1242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that performs a search on a sorted one-dimensional list
    to find a given value. Use the binary search algorithm.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: The binary search algorithm is considered very fast and can be used with large
    scale data. Its main disadvantage, though, is that the data need to be sorted.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: The main idea of the binary search algorithm is to first examine the element
    in the middle of the list. If it does not match the “needle in the haystack” that
    you are looking for, the algorithm determines whether the target is smaller or
    larger than the middle element. This guides the search to the corresponding half
    of the list. In other words, if the “needle” you are looking for is smaller than
    the value of the middle element, it means that the “needle” might be in the first
    half of the list; otherwise it might be in the last half of the list. The process
    continues, narrowing down the search by checking the middle element in the remaining
    half of the list until the "needle" is found or the portion of the list being
    examined is reduced to a single element. If the latter occurs without finding
    the "needle," it means the “needle” is not present in the list.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: Confused? Let's try to analyze the binary search algorithm through an example.
    The following list contains numeric values in ascending order. Assume that the
    “needle” that you are looking for is the value 44.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-38.png)'
  id: totrans-1248
  prefs: []
  type: TYPE_IMG
- en: Three variables are used. Initially, variable left contains the value 0 (this
    is the index of the first element), variable right contains the value 13 (this
    is the index of the last element) and variable middle contains the value 6 (this
    is approximately the index of the middle element).
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-39.png)'
  id: totrans-1250
  prefs: []
  type: TYPE_IMG
- en: The “needle” (value 44) that you are looking for is larger than the value of
    39 in the middle, thus the element that you are looking for might be in the last
    half of the list. Therefore, variable left is updated to point to index position
    7 and variable middle is updated to a point in the middle between left (the new
    one) and right, as shown below.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-40.png)'
  id: totrans-1252
  prefs: []
  type: TYPE_IMG
- en: Now, the “needle” (value 44) that you are looking for is smaller than the value
    of 57 in the middle, thus the element that you are looking for might be in the
    first half of the portion of the list being examined. Therefore, it is the variable
    right that is now updated to point to index position 9, and variable middle is
    updated to point to the middle between left and right (the new one), as shown
    below002E
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-41.png)'
  id: totrans-1254
  prefs: []
  type: TYPE_IMG
- en: You are done! The “needle” has been found at index position 8 and the whole
    process can stop!
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Each unsuccessful comparison reduces the number of elements
    left to check by half!'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The index variables left and right each time point to the
    beginning and end, respectively, of the portion of the list being examined.'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see the corresponding code fragment.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: left = 0
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: right = ELEMENTS - 1
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: 'while left <= right and not found:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: 'middle = (left + right) // 2   #This is a DIV 2 operation'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: 'if needle < haystack[middle]:  #If the needle is in the first half of the portion'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: 'right = middle – 1         #of the list being examined, update the right index'
  id: totrans-1265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > haystack[middle]:  #If it is in the second half,'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: left = middle + 1            #update the left index
  id: totrans-1267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", middle)
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The binary search algorithm is very efficient because it
    drastically reduces the search space with each iteration, making it highly effective
    for sorted lists. Using this algorithm on the example list, the value of 44 can
    be found within just three iterations. In contrast, the linear search algorithm
    would require nine iterations for the same data!'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If the list contains a value multiple times, the binary
    search algorithm can find only one occurrence.'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-9 Display all the Historical Events for a Country
  id: totrans-1276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names of 10 countries
    in alphabetical order and 20 important historical events for each country (a brief
    description of each event). The Python program must then prompt the user to enter
    a country, and it will search and display all events for that country. Use the
    binary search algorithm.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, the following two lists are required.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-42.png)'
  id: totrans-1280
  prefs: []
  type: TYPE_IMG
- en: Assume that the user enters a country to search for, and the binary search algorithm
    finds that country, for example, at index position 2 of list countryNames. The
    program can then use this value of 2 as a column index for the list eventDescriptions,
    and display all the event descriptions of column 2.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: The Python program is as follows.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-9'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: EVENTS = 20
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: COUNTRIES = 10
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: countryNames = [None] * COUNTRIES
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: eventDescriptions = [[None] * COUNTRIES for i in range(EVENTS)]
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COUNTRIES):'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: 'countryNames[j] = input("Enter Country No" + str(j + 1) + ": ")'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(EVENTS):'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: 'eventDescriptions[i][j] = input("Enter description for event No" + str(i +
    1) + ": ")'
  id: totrans-1291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'needle = input("Enter a country to search: ").upper()'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: '#Country names are entered in alphabetical order.'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: '#Use the binary search algorithm to search for needle.'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: left = 0
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: right = EVENTS - 1
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: 'while left <= right and not found:'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: middle = (left + right) // 2
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: 'if needle < countryNames[middle].upper():'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: right = middle - 1
  id: totrans-1301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > countryNames[middle].upper():'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: left = middle + 1
  id: totrans-1303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: print("No country found!")
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(EVENTS):'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: print(eventDescriptions[i][middle])
  id: totrans-1310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.5-10 Searching in Each Column of a Two-Dimensional List
  id: totrans-1311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names of 10 countries
    and 20 important historical events for each country (a brief description of each
    event), and the corresponding year of each event. The Python program must then
    prompt the user to enter a year, and it will search and display all events that
    happened that year for each country. Use the binary search algorithm. Assume that
    for each country there is only one event in each year and that the user enters
    the events ordered by year in ascending order.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, the following three lists are required.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-43.png)'
  id: totrans-1315
  prefs: []
  type: TYPE_IMG
- en: In order to write the code fragment that performs a search on each column of
    the list eventYears, let's use the “from inner to outer” method. The next binary
    search algorithm searches in the first column (column index 0) for a user-provided
    year. Assume variable j contains the value 0\. Since the search is performed vertically,
    and in order to increase program's readability, the variables left and right of
    the binary search algorithm have been renamed to top and bottom respectively.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: top = 0
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: bottom = EVENTS - 1
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: 'while top <= bottom and not found:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: middle = (top + bottom) // 2
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: 'if needle < eventYears[middle][j]:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: bottom = middle - 1
  id: totrans-1323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > eventYears[middle][j]:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: top = middle + 1
  id: totrans-1325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: print("No event found for country", countryNames[j])
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: print("Country:", countryNames[j])
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: print("Year:", eventYears[middle][j])
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: print("Event:", eventDescriptions[middle][j])
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: Now, nesting this code fragment in a for-loop that iterates for all columns
    results in the following.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COUNTRIES):'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: top = 0
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: bottom = EVENTS - 1
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: 'while top <= bottom and not found:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: middle = (top + bottom) // 2
  id: totrans-1340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if needle < eventYears[middle][j]:'
  id: totrans-1341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bottom = middle - 1
  id: totrans-1342
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > eventYears[middle][j]:'
  id: totrans-1343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: top = middle + 1
  id: totrans-1344
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1346
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: print("No event found for country", countryNames[j])
  id: totrans-1348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: print("Country:", countryNames[j])
  id: totrans-1350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Year:", eventYears[middle][j])
  id: totrans-1351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Event:", eventDescriptions[middle][j])
  id: totrans-1352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-10'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: EVENTS = 20
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: COUNTRIES = 10
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: countryNames = [None] * COUNTRIES
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: eventDescriptions = [[None] * COUNTRIES for i in range(EVENTS)]
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: eventYears = [[None] * COUNTRIES for i in range(EVENTS)]
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COUNTRIES):'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: 'countryNames[j] = input("Enter Country No." + str(j + 1) + ": ")'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(EVENTS):'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: 'eventDescriptions[i][j] = input("Enter description for event No" + str(i +
    1) + ": ")'
  id: totrans-1363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'eventYears[i][j] = int(input("Enter year for event No" + str(i + 1) + ": "))'
  id: totrans-1364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'needle = int(input("Enter a year to search: "))'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COUNTRIES):'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: top = 0
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: bottom = EVENTS - 1
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: 'while top <= bottom and not found:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: middle = (top + bottom) // 2
  id: totrans-1371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if needle < eventYears[middle][j]:'
  id: totrans-1372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bottom = middle - 1
  id: totrans-1373
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > eventYears[middle][j]:'
  id: totrans-1374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: top = middle + 1
  id: totrans-1375
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1377
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: print("No event found for country", countryNames[j])
  id: totrans-1379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: print("Country:", countryNames[j])
  id: totrans-1381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Year:", eventYears[middle][j])
  id: totrans-1382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Event:", eventDescriptions[middle][j])
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 33.6 Exercises of a General Nature with Data Structures
  id: totrans-1384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exercise 33.6-1 On Which Days was There a Possibility of Snow?
  id: totrans-1385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the temperatures (in degrees
    Fahrenheit) recorded at the same hour each day for the 31 days of January. The
    Python program must then display the numbers of those days (1, 2, ..., 31) on
    which there was a possibility of snow, that is, those on which temperatures were
    below 36 degrees Fahrenheit (about 2 degrees Celsius).
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: The one-dimensional list for this exercise is shown next.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-44.png)'
  id: totrans-1389
  prefs: []
  type: TYPE_IMG
- en: and the Python program is as follows.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-1'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: t = [None] * DAYS
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: t[i] = int(input())
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i] < 36:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: print(i + 1, end = "\t")
  id: totrans-1398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.6-2 Was There Any Possibility of Snow?
  id: totrans-1399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the temperatures (in degrees
    Fahrenheit) recorded at the same hour each day for the 31 days of January. The
    Python program must then display a message indicating if there was a possibility
    of snow, that is, if there were any temperatures below 36 degrees Fahrenheit (about
    2 degrees Celsius).
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you cannot replicate the approach used in the previous exercise.
    The code fragment that follows would be incorrect.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i] < 36:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: print("There was a possibility of snow in January!")
  id: totrans-1405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If January had more than one day with a temperature below 36 degrees Fahrenheit,
    the same message would be displayed multiple times—and obviously you do not want
    this! You actually want to display a message once, regardless of whether January
    had one, two, or even more days below 36 degrees Fahrenheit.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: There are two approaches, actually. Let's study them both.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Counting all temperatures below 36 degrees Fahrenheit
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, you can use a variable in the program to count all the days
    on which the temperature was below 36 degrees Fahrenheit. After all of the days
    have been examined, the program can check the value of this variable. If the value
    is not zero, it means that there was at least one day where there was a possibility
    of snow.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-2a'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: t = [None] * DAYS
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: t[i] = int(input())
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i] < 36:'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-1418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if count != 0:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: print("There was a possibility of snow in January!")
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: Second approach – Using a flag
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, instead of counting all those days that had a temperature
    below 36 degrees Fahrenheit, you can use a Boolean variable (a flag). The solution
    is presented next.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-2b'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: t = [None] * DAYS
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: t[i] = int(input())
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i] < 36:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: print("There was a possibility of snow in January!")
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Imagine the variable found as if it''s a real flag. Initially,
    the flag is not hoisted (found = False). Within the for-loop, however, when a
    temperature below 36 degrees Fahrenheit is found, the flag is hoisted (the value
    True is assigned to the variable found) and it is never lowered again.'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note the break statement! Once a temperature below 36 degrees
    Fahrenheit is found, it is meaningless to continue checking thereafter.'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If the loop performs all of its iterations and no temperature
    below 36 degrees Fahrenheit is found, the variable found will still contain its
    initial value (False) since the flow of execution never entered the decision control
    structure.'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.6-3 In Which Cities was There a Possibility of Snow?
  id: totrans-1438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names of ten cities
    and their temperatures (in degrees Fahrenheit) recorded at the same hour each
    day for the 31 days of January. The Python program must display the names of the
    cities in which there was a possibility of snow, that is, those in which temperatures
    were below 36 degrees Fahrenheit (about 2 degrees Celsius).
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous exercise, you need to display each city name once, regardless
    of whether it had one, two, or even more days below 36 degrees Fahrenheit. There
    are two approaches. In the first approach, the auxiliary list count, as presented
    below, is created by the program to count the total number of days on which each
    city had temperatures lower than 36 degrees Fahrenheit. The second approach, however,
    doesn't create the auxiliary list count. It uses just one extra Boolean variable
    (a flag). Obviously the second one is more efficient. But let's study both approaches.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-45.png)'
  id: totrans-1442
  prefs: []
  type: TYPE_IMG
- en: First approach – Using an auxiliary list
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: You were taught in [Section 32.2](chapter32.html#toc_2) how to process each
    row individually. The nested loop control structure that can create the auxiliary
    list count is as follows.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: count = [None] * CITIES
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: count[i] = 0
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  id: totrans-1449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: count[i] += 1
  id: totrans-1450
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: After list count is created you can iterate through it, and when an element
    contains a value other than zero, it means that the corresponding city had at
    least one day below 36 degrees Fahrenheit; thus the program must display the name
    of that city. The final Python program is presented next
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-3a'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * CITIES
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: t = [[None] * DAYS for i in range(CITIES)]
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter a name for city No:" + str(i + 1) + ": ")'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: 't[i][j] = int(input("Enter a temperature for day No: " + str(j + 1) + ": "))'
  id: totrans-1460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Create auxiliary list count'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: count = [None] * CITIES
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: count[i] = 0
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  id: totrans-1466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: count[i] += 1
  id: totrans-1467
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("Cities in which there was a possibility of snow in January: ")'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: 'if count[i] != 0:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  id: totrans-1471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Second approach – Using a flag
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: This approach does not use an auxiliary list. It processes list t and directly
    displays any city name that had a temperature below 36 degrees Fahrenheit. But
    how can this be done without displaying a city name twice, or even more than twice?
    This is where you need a flag, that is, an extra Boolean variable.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this approach, let's use the “from inner to outer” method.
    The following code fragment checks if the first row of list t (row index 0) contains
    at least one temperature below 36 degrees Fahrenheit; if so, it displays the corresponding
    city name that exists at position 0 of the list names. Assume variable i contains
    the value 0.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything has been clarified, in order to process the whole list t,
    you can just nest this code fragment in a for-loop that iterates for all cities,
    as follows.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  id: totrans-1486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1487
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1488
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  id: totrans-1490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-3b'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * CITIES
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: t = [[None] * DAYS for i in range(CITIES)]
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter a name for city No:" + str(i + 1) + ": ")'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: 't[i][j] = int(input("Enter a temperature for day No:" + str(j + 1) + ": "))'
  id: totrans-1500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("Cities in which there was a possibility of snow in January: ")'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  id: totrans-1505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  id: totrans-1506
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  id: totrans-1507
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  id: totrans-1509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.6-4 Display from Highest to Lowest Grades by Student, and in Alphabetical
    Order
  id: totrans-1510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are 10 students and each one of them has received their grades for five
    lessons. Write a Python program that prompts a teacher to enter the name of each
    student and their grades for all lessons. The program must then calculate each
    student's average grade, and display the names and the average grades of the students
    sorted by their average grade in descending order. Moreover, if two or more students
    have the same average grade, their names must be displayed in alphabetical order.
    Use the bubble sort algorithm, adapted accordingly.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following three lists. The values for the lists
    names and grades will be entered by the user, whereas the auxiliary list average
    will be created by the Python program.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-46.png)'
  id: totrans-1514
  prefs: []
  type: TYPE_IMG
- en: You're already familiar with all the steps in this exercise. You can create
    the auxiliary list average (see [Section 32.2](chapter32.html#toc_2)), sort it
    while maintaining the one-to-one correspondence with the elements in the list
    names (as shown in [Exercise 33.4-3](#toc_20)), and handle the scenario where,
    if two average grades are equal, the corresponding student names should be sorted
    alphabetically (as demonstrated in [Exercise 33.4-4](#toc_21)). Here's the final
    Python program.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-4'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: STUDENTS = 10
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: LESSONS = 5
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: '#Read list names and grades'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * STUDENTS
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: grades = [[None] * LESSONS for i in range(STUDENTS)]
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for student No." + str(i + 1) + ": ")'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(LESSONS):'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: 'grades[i][j] = int(input("Enter grade for lesson No." + str(j + 1) + ": "))'
  id: totrans-1525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Create list average'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: average = [None] * STUDENTS
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: average[i] = 0
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(LESSONS):'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: average[i] += grades[i][j]
  id: totrans-1531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: average[i] /= LESSONS
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: '#Sort lists average and names'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(STUDENTS - 1):'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(STUDENTS - 1, m, -1):'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: 'if average[n] > average[n - 1]:'
  id: totrans-1536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: average[n], average[n - 1] = average[n - 1], average[n]
  id: totrans-1537
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  id: totrans-1538
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif average[n] == average[n - 1]:'
  id: totrans-1539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if names[n] < names[n - 1]:'
  id: totrans-1540
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  id: totrans-1541
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display lists names and average'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i], "\t", average[i])
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.6-5 Archery at the Summer Olympics
  id: totrans-1545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In archery at the Summer Olympics, 20 athletes each shoot six arrows. Write
    a Python program that prompts the user to enter the name of each athlete, and
    the points awarded for each shot. The program must then display the names of the
    three athletes that won the gold, silver, and bronze medals depending on which
    athlete obtained the highest sum of points. Assume that no two athletes have an
    equal sum of points.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following three lists. The values for the lists
    names and points will be entered by the user, whereas the auxiliary list total
    will be created by the Python program.
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-47.png)'
  id: totrans-1549
  prefs: []
  type: TYPE_IMG
- en: After the auxiliary list total is created, a sorting algorithm can sort the
    list total in descending order (while preserving the one-to-one correspondence
    with the elements of the list names). The Python program can then display the
    names of the three athletes at index positions 0, 1, and 2 (since these are the
    athletes that should win the gold, the silver, and the bronze medals, respectively).
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: The following program uses the bubble sort algorithm to sort the list total.
    Since the algorithm must sort in descending order, bigger elements must gradually
    “bubble” to positions of lowest index, like bubbles rise in a glass of cola. However,
    instead of performing 19 passes (there are 20 athletes), given that only the three
    best athletes must be found, the algorithm can perform just 3 passes. Doing this,
    only the first three bigger elements will gradually “bubble” to the first three
    positions in the list.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: The solution is presented next.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-5'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: from math import fsum
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: ATHLETES = 20
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: SHOTS = 6
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '#Read list names and points'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * ATHLETES
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: points = [[None] * SHOTS for i in range(ATHLETES)]
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ATHLETES):'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for athlete No." + str(i + 1) + ": ")'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(SHOTS):'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: 'points[i][j] = int(input("Enter points for shot No." + str(j + 1) + ": "))'
  id: totrans-1563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Create list total'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: total = []
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in points:'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: total.append(fsum(row))
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: '#Sort lists names and total. Perform only 3 passes'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(3):'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ATHLETES - 1, m, -1):'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: 'if total[n] > total[n - 1]:'
  id: totrans-1571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: total[n], total[n - 1] = total[n - 1], total[n]
  id: totrans-1572
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  id: totrans-1573
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display gold, silver and bronze metal'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i], "\t", total[i])
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.6-6 The Five Best Scorers
  id: totrans-1577
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names of the 32 national
    teams of the FIFA World Cup, the names of the 24 players for each team, and the
    total number of goals each player scored. The program must then display the name
    of each team along with its five best scorers. Use the bubble sort algorithm.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise you need the following three lists.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-48.png)'
  id: totrans-1581
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)To save paper short list names are used, but it is more
    or less obvious that list t holds the names of the 32 national teams, list p holds
    the names of the 24 players of each team, and list g holds the total number of
    goals each player scored.'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: The Python program must sort each row of list g in descending order but it must
    also take care to preserve the one-to-one correspondence with the elements of
    list p. This means that, every time the bubble sort algorithm swaps the contents
    of two elements of list g, the corresponding elements of list p must be swapped
    as well. However, instead of performing 23 passes (there are 24 players), given
    that only the five best scorers must be found, the algorithm can perform just
    5 passes. When sorting is completed, the five best scorers should appear in the
    first five columns.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: The “from inner to outer” method is used again. The following code fragment
    sorts the first row (row index 0) of list g in descending order and, at the same
    time, takes care to preserve the one-to-one correspondence with the elements of
    list p. Assume variable i contains the value 0.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(5):  #Perform 5 passes'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PLAYERS - 1, m, -1):'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: 'if g[i][n] > g[i][n - 1]:'
  id: totrans-1587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: g[i][n], g[i][n - 1] = g[i][n - 1], g[i][n]
  id: totrans-1588
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: p[i][n], p[i][n - 1] = p[i][n - 1], p[i][n]
  id: totrans-1589
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, in order to sort all rows, you need to nest this code fragment in a for-loop
    that iterates for all of them, as shown next.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(TEAMS):'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(5):  #Perform 5 passes'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PLAYERS - 1, m, -1):'
  id: totrans-1593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if g[i][n] > g[i][n - 1]:'
  id: totrans-1594
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: g[i][n], g[i][n - 1] = g[i][n - 1], g[i][n]
  id: totrans-1595
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: p[i][n], p[i][n - 1] = p[i][n - 1], p[i][n]
  id: totrans-1596
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-6'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: TEAMS = 32
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: PLAYERS = 24
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: '#Read team names, player names and goals all together'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: t = [None] * TEAMS
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: p = [[None] * PLAYERS for i in range(TEAMS)]
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: g = [[None] * PLAYERS for i in range(TEAMS)]
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(TEAMS):'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: 't[i] = input("Enter name for team No." + str(i + 1) + ": ")'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(PLAYERS):'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: 'p[i][j] = input("Enter name of player No." + str(j + 1) + ": ")'
  id: totrans-1608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'g[i][j] = int(input("Enter goals of player No." + str(j + 1) + ": "))'
  id: totrans-1609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Sort list g'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(TEAMS):'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(5):  #Perform 5 passes'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PLAYERS - 1, m, -1):'
  id: totrans-1613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if g[i][n] > g[i][n - 1]:'
  id: totrans-1614
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: g[i][n], g[i][n - 1] = g[i][n - 1], g[i][n]
  id: totrans-1615
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: p[i][n], p[i][n - 1] = p[i][n - 1], p[i][n]
  id: totrans-1616
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display 5 best scorers of each team'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(TEAMS):'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: print("Best scorers of", t[i])
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: print("----------------------------------")
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(5):'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: print(p[i][j], "scored", g[i][j], "goals")
  id: totrans-1622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.6-7 Counting the Frequency of Vowels
  id: totrans-1623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter an English sentence and
    counts the frequency of each vowel in the sentence. Use a dictionary to store
    the vowels as keys and their frequencies as values.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of programming, the manipulation and analysis of textual data play
    a crucial role. One common task involves counting the frequency of specific elements
    within a given text, providing insights into its linguistic characteristics. Vowels
    are fundamental components of the English language, and analyzing their frequency
    can reveal patterns, aid in language processing, and even assist in certain cryptographic
    algorithms.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: In the solution that follows, the program starts by creating a dictionary named
    vowelsFrequency to store and manage the frequency of each vowel (A, E, I, O, U),
    with initial frequencies all set to zero. For each character in the user-provided
    sentence, the program checks if it is a vowel and, if it is, the corresponding
    frequency count in the dictionary is updated.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png)  file_33.6-7'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a dictionary to store the frequencies of each vowel with initial'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: '#frequencies all set to zero.'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: 'vowelsFrequency  = {"A": 0, "E": 0, "I": 0, "O": 0, "U": 0}'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: 'sentence = input("Enter an English sentence: ")'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: '#Iterate through the characters of the user-provided sentence and if it is
    a vowel,'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: '#update (increase) the corresponding frequency count in the vowelsFrequency
    dictionary.'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: 'for character in sentence.upper():'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: 'if character in vowelsFrequency:'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: vowelsFrequency[character] += 1
  id: totrans-1637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display the frequencies of each vowel'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: 'for vowel in vowelsFrequency:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: print(vowel + ":", vowelsFrequency[vowel])
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: '33.7 Review Questions: True/False'
  id: totrans-1641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: 1)The main idea of the bubble sort algorithm (when sorting a list in ascending
    order) is to repeatedly move the smallest elements of the list to the lowest index
    positions.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: 2)In a list sorted in ascending order, the first element is the greatest of
    all.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: 3)When using the bubble sort algorithm, the total number of swaps depends on
    the given list.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: 4)The case in which the bubble sort algorithm performs the greatest number of
    swaps is when you want to sort in descending order a list that is already sorted
    in ascending order.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: 5)In the bubble sort algorithm, when the decision control structure tests the
    Boolean expression A[n] > A[n − 1], it means that the elements of list A are being
    sorted in descending order.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: 6)In Python, sorting algorithms compare letters in the same way that they compare
    numbers.
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: 7)If you want to sort a list A but preserve the one-to-one correspondence with
    the elements of a list B, you must rearrange the elements of list B as well.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: 8)The bubble sort algorithm sometimes performs better than the modified bubble
    sort algorithm.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: 9)According to the bubble sort algorithm, in each pass (except the last one)
    only one element is guaranteed to be placed in proper position.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: 10)The bubble sort algorithm can be implemented only by using for-loops.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: 11)The quick sort algorithm cannot be used to sort each column of a two-dimensional
    list.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: 12)The insertion sort algorithm can sort in either descending or ascending order.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: 13)One of the fastest sorting algorithms is the modified bubble sort algorithm.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: 14)The bubble sort algorithm, for a one-dimensional list of N elements, performs
    ![Image](img/chapter33-49.png) compares.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: 15)The bubble sort algorithm, for a one-dimensional list of N elements, performs
    ![Image](img/chapter33-50.png) passes.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: 16)When using the modified bubble sort algorithm, if a complete pass is performed
    and no swaps have been done, then the algorithm knows the list is sorted and there
    is no need for further passes.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: 17)When using the selection sort algorithm, if you wish to sort a list in descending
    order, you need to search for maximum values.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: 18)The selection sort algorithm performs well on computer systems with limited
    main memory.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: 19)The selection sort algorithm is suitable for large scale data operations.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: 20)The selection sort algorithm is a very complex algorithm.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: 21)The insertion sort algorithm generally performs better than the selection
    and the bubble sort algorithm.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: 22)The insertion sort algorithm can sometimes prove even faster than the quicksort
    algorithm.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: 23)The quicksort algorithm is considered one of the best and fastest sorting
    algorithms.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: 24)A sorted list contains only elements that are different from each other.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: 25)A search algorithm is an algorithm that searches for an item with specific
    features within a set of data.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: 26)The sequential search algorithm can be used only on lists that contain arithmetic
    values.
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: 27)One of the most commonly used search algorithms is the quick search algorithm.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: 28)One search algorithm is called the heap algorithm.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: '29)A linear (or sequential) search algorithm can work as follows: it can check
    if the last element of the list is equal to a given value, then it can check the
    last but one element, and so on, until the beginning of the list or until the
    given value is found.'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: 30)The linear search algorithm can, in certain situations, find an element faster
    than the binary search algorithm.
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: 31)The linear search algorithm can be used in large scale data operations.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: 32)The linear search algorithm cannot be used in sorted lists.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: 33)The binary search algorithm can be used in large scale data operations.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: 34)If a list contains a value multiple times, the binary search algorithm can
    find only the first in order occurrence of a given value.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: 35)When using search algorithms, if a list contains unique values and the element
    that you are looking for is found, there is no need to check any further.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: 36)The main disadvantage of the binary search algorithm is that data needs to
    be sorted.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: 37)The binary search algorithm can be used only in lists that contain arithmetic
    values.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: 38)If the element you are looking for is in the last position of a list, a linear
    search algorithm that starts searching from the beginning of the list will examine
    all the elements in the list .
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: 39)The linear search algorithm can be used on two-dimensional lists.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: 40)If the element that you are looking for using the binary search algorithm
    is at the first position of a list with at least three elements, it will be found
    in just one iteration.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: 33.8 Review Exercises
  id: totrans-1683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: 1)Write the Python program that corresponds to the following flowchart fragment.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-51.png)'
  id: totrans-1686
  prefs: []
  type: TYPE_IMG
- en: '2)Design a flowchart and write the corresponding Python program that lets the
    user enter 50 positive numerical values into a list. The algorithm, and consequently
    the Python program, must then create a new list of 47 elements. In this new list,
    each position must contain the average value of four elements: the values that
    exist in the current and the next three positions of the user-provided list.'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: 3)Write a Python program that lets the user enter numerical values into lists
    a, b, and c, of 15 elements each. The program must then create a new list newArr
    of 15 elements. In this new list, each position must contain the lowest value
    of lists a, b, and c, for the corresponding position.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: Next, design the corresponding flowchart fragment for only that part of your
    program that creates the list newArr.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: 4)Write a Python program that lets the user enter numerical values into lists
    a, b, and c, of 10, 5, and 15 elements respectively. The program must then create
    a new list newArr of 30 elements. In this new list, the first 15 positions must
    contain the elements of list c, the next five positions must contain the elements
    of list b, and the last 10 positions must contains the elements of list a.
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: Next, design the corresponding flowchart fragment for only that part of your
    program that creates the list newArr.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: 5)Write a Python program that for two given lists a and b of 3 × 4 and 5 × 4
    elements respectively it creates a new list newArr of 8 × 4 elements. In this
    new list, the first 3 rows must contain the elements of list a and the next 5
    rows must contain the elements of list b.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: 6)Write a Python program that lets the user enter numerical values into lists
    a, b, and c, of 5 × 10, 5 × 15, and 5 × 20 elements, respectively. The program
    must then create a new list newArr of 5 × 45 elements. In this new list, the first
    10 columns must contain the elements of list a, the next 15 columns must contain
    the elements of list b, and the last 20 rows must contain the elements of list
    c.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: 7)Write a Python program that lets the user enter 50 numerical values into a
    list and then creates two new lists, reals and integers. The list reals must contain
    the real values, whereas the list integers must contain the integer values. The
    value 0 (if any) must not be added to any of the final lists, either reals or
    integers.
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: Next, design the corresponding flowchart fragment for only that part of your
    program that creates the lists reals and integers.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: 8)Write a Python program that lets the user enter 50 three-digit integers into
    a list and then creates a new list containing only the integers in which the first
    digit is less than the second digit and the second digit is less than the third
    digit. For example, the values 357, 456, and 159 are such integers.
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: '9)A public opinion polling company asks 200 citizens to each score 10 consumer
    products. Write a Python program that prompts the user to enter the name of each
    product and the score each citizen gave (A, B, C, or D). The program must then
    calculate and display the following:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: a)for each product, the name of the product and the number of citizens that
    gave it an “A”
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: b)for each citizen, the number of “B” responses they gave
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: c)which product or products are considered the best
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any score with a value other
    than A, B, C, or D.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: 10)Write a Python program that prompts the user to enter the names of 20 U.S.
    cities and the names of 20 Canadian cities and then, for each U.S. city, the distance
    (in miles) from each Canadian city. Finally, the program must display, for each
    U.S. city, its closest Canadian city.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: 11)Design a flowchart and write the corresponding Python program that lets the
    user enter the names and the heights of 30 mountains, as well as the country in
    which each one belongs. The algorithm, and consequently the Python program, must
    then display all available information about the highest and the lowest mountain.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: 12)Design the flowchart fragment of an algorithm that, for a given list A of
    N × M elements, finds and displays the maximum value as well as the row and the
    column in which this value was found.
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: 13)Twenty-six teams participate in a football tournament. Each team plays 15
    games, one game each week. Write a Python program that lets the user enter the
    name of each team and the letter “W” for win, “L” for loss, and “T” for tie (draw)
    for each game. If a win receives 3 points and a tie 1 point, the Python program
    must find and display the name of the team that wins the championship based on
    which team obtained the greatest sum of points. Assume that no two teams have
    an equal sum of points.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: 14)On Earth, a free-falling object has an acceleration of 9.81 m/s² downward.
    This value is denoted by g. A student wants to calculate that value using an experiment.
    She allows 10 different objects to fall downward from a known height, and measures
    the time they need to reach the floor. However, since her chronometer is not so
    accurate, she does this 20 times for each object. She needs a Python program that
    allows her to enter the heights (from which objects are left to fall), as well
    as the measured times that they take to reach the floor. The program must then
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: ►calculate g and store all calculated values in a 10 × 20 list.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: ►find and display the minimum and the maximum calculated values of g for each
    object.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: ►find and display the overall minimum and maximum calculated values of g of
    all objects.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: The required formula is
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter10-01.png)
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: where
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: ►S is the distance that the free-falling objects traveled, in meters (m)
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: ►u[o] is the initial velocity (speed) of the free-falling objects in meters
    per second (m/sec). However, since the free-falling objects start from rest, the
    value of u[0] must be zero.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: ►t is the time that it took the free-falling object to reach the floor, in seconds
    (sec)
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: ►g is the acceleration, in meters per second² (m/sec²)
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: 15)Ten measuring stations, one in each city, record the daily CO[2] levels for
    a period of a year. Write a Python program that lets the user enter the name of
    each city and the CO[2] levels recorded at the same hour each day. The Python
    program then displays the name of the city that has the clearest atmosphere (on
    average).
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: 16)Design the flowchart fragment of an algorithm that, for a given list A of
    N × M elements, finds and displays the minimum and the maximum values of each
    row.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: 17)Write a Python program that lets the user enter values into a 20 × 30 list
    and then finds and displays the minimum and the maximum values of each column.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: 18)Twenty teams participate in a football tournament, and each team plays 10
    games, one game each week. Write a Python program that prompts the user to enter
    the name of each team and the letter “W” for win, “L” for loss, and “T” for tie
    (draw) for each game. If a win receives 3 points and a tie 1 point, the Python
    program must find and display the names of the teams that win the gold, the silver,
    and the bronze medals based on which team obtained the greatest sum of points.
    Use the modified bubble sort algorithm. Assume that no two teams have an equal
    sum of points.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any letter other than W, L,
    or T.
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Instead of performing 19 passes (there are 20 teams), given that only
    the three best teams must be found, the modified bubble sort algorithm can perform
    just 3 passes.'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: 19)Write a Python program that prompts the user to enter the names and the heights
    of 50 people. The program must then display this information, sorted by height,
    in descending order. In cases where two or more people share the same height,
    their names must be displayed in alphabetical order. To achieve this, use the
    bubble sort algorithm, adapted accordingly.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: 20)Write a Python program that prompts the user to enter the first names, last
    names and father's names of 50 people. The program must then display this information,
    sorted by last name. In cases where two or more people share the same last name,
    their first names must be displayed in alphabetical order. Additionally, if two
    or more people share the same first name, their father's names must be displayed
    in alphabetical order. To achieve this, use the bubble sort algorithm, adapted
    accordingly.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: 21)In a song contest there are 10 judges, each of whom scores 12 artists for
    their performance. However, according to the rules of this contest, the total
    score is calculated after excluding the highest and lowest scores. Write a Python
    program that prompts the user to enter the names of the artists and the score
    they get from each judge. The program must then display
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: a)for each artist, their name and total score, after excluding the maximum and
    the minimum scores. Assume that each artist's highest and lowest scores are unique,
    meaning they won't have multiple scores with the same value.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: b)the final classification, starting with the artist that has the greatest score.
    However, if two or more artists have the same score, their names must be displayed
    in alphabetical order. Use the bubble sort algorithm, adapted accordingly.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: 22)Design the flowchart fragment of an algorithm that, for a given list A of
     20 × 8 elements, sorts each row in descending order using the bubble sort algorithm.
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: 23)Design the flowchart fragment of an algorithm that, for a given list A of
    5 × 10 elements, sorts each column in ascending order using the bubble sort algorithm.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: 24)Design the flowchart fragment of an algorithm that, for a given list A of
     20 × 8 elements, sorts each row in descending order using the insertion sort
    algorithm.
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: 25)Design the flowchart fragment of an algorithm that, for a given list A of
    5 × 10 elements, sorts each column in ascending order using the selection sort
    algorithm.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: 26)In a Sudoku contest, 10 participants compete to solve eight different Sudoku
    puzzles as quickly as possible. Write a Python program that lets the user enter
    the name of each contestant and their time (in hours, minutes and seconds) to
    complete each puzzle. The program must then display
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: a)for each contestant, their name along with their three best times. Assume
    that the times of each contestant are different.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: b)the names of the three contestants who receive the gold, the silver, and the
    bronze medals based on the contestant with the lowest average time. Assume that
    no two contestants have the same average time.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: Use the selection sort algorithm when necessary.
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Given that only the three best contestants must be found, the selection
    sort algorithm could sort only the first three elements.'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: 27)Five measuring stations, one in each area of a large city, record the daily
    carbon dioxide (CO[2]) levels on an hourly basis. Write a Python program that
    lets the user enter the name of each area and the CO[2] levels recorded every
    hour (00:00 to 23:00) for a period of two days. The Python program then must calculate
    and display
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: a)for each area, its name and its average CO[2] level
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: b)for each hour, the average CO[2] level of the city
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: c)the hour in which the city atmosphere was most polluted (on average)
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: d)the hour and the area in which the highest level of CO[2] was recorded
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: e)the three areas with the dirtiest atmosphere (on average), using the insertion
    sort algorithm
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: 28)Design the flowchart fragment of the linear search algorithm that performs
    a search on list a of N elements to find the value needle and displays the position
    index(es) at which needle is found. If needle is not found, the message “Not found”
    must be displayed.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: 29)Design the flowchart fragment of the binary search algorithm that performs
    a search on list a of N elements to find the value needle and displays the position
    at which needle is found. If needle is not found, the message “Not found” must
    be displayed.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: 30)Twelve teams participate in a football tournament, and each team plays 20
    games, one game each week. Write a Python program that prompts the user to enter
    the name of each team and the letter “W” for win, “L” for loss, or “T” for tie
    (draw) for each game. Then the program must prompt the user for a letter (W, L,
    or T) and display, for each team, the week number(s) in which the team won, lost,
    or tied respectively. For example, if the user enters “L”, the Python program
    must search and display, for each team, the week numbers (e.g., Week 3, Week 14,
    and so on) in which the team lost the game.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: 31)Ten teams participate in a football tournament, and each team plays 16 games,
    one game each week. Write a Python program that prompts the user to enter the
    name of each team, the number of goals the team scored, and the number of goals
    the team let in for each match. A win receives 3 points and a tie receives 1 point.
    The Python program must then prompt the user for a team name and finally calculate
    and display the total number of points for this team. If the user-provided team
    name is not found, the message “This team does not exist” must be displayed.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any negative number of goals.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: Assume that no two teams share the same name.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: 32)In a high school, there are two classes, with 20 and 25 students respectively.
    Write a Python program that prompts the user to enter the names of the students
    in two separate lists. The program then displays the names of each class independently
    in ascending order. Afterwards, the program prompts the user to enter a name and
    it searches for that user-provided name in both lists. If the student's name is
    found, the program must display the message “Student found in Class No N”, where
    N can be either 1 or 2; otherwise the message “Student not found in either class”
    must be displayed. Assume that both lists contain unique names.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Since the lists are sorted and the names are unique, use the binary search
    algorithm.'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: 33)Suppose there are two lists, usernames and passwords, that contain the login
    information of 100 employees of a company. Write a code fragment that prompts
    the user to enter a username and a password and then displays the message “Login
    OK!” when the combination of username and password is valid; the message “Login
    Failed!” must be displayed otherwise. Both usernames and passwords are case-insensitive.
    Assume that usernames are unique but passwords are not.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: 34)Suppose there are two lists, names and SSNs, that contain the names and the
    SSNs (Social Security Numbers) of 1,000 U.S. citizens. Write a code fragment that
    prompts the user to enter a value (it can be either a name or an SSN) and then
    searches for and displays the names of all the people that have this name or this
    SSN. If the user-provided value is not found, the message “This value does not
    exist” must be displayed.
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: 35)There are 12 students and each one of them has received their grades for
    six lessons. Write a Python program that lets the user enter the grades for all
    lessons and then displays a message indicating whether or not there is at least
    one student that has an average value below 70\. Moreover, using a loop control
    structure, the program must validate data input and display a different error
    message for each type of input error when the user enters any negative value,
    or a value greater than 100.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: 36)Write a Python program that prompts the user to enter an English message,
    and then, using the table that follows, displays the corresponding Morse code
    using dots and dashes. Please note that space characters must be displayed as
    slash characters ( / ) in the translated message.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: '| Morse Code |'
  id: totrans-1755
  prefs: []
  type: TYPE_TB
- en: '| A | .‑ | N | ‑. |'
  id: totrans-1756
  prefs: []
  type: TYPE_TB
- en: '| B | ‑... | O | ‑‑‑ |'
  id: totrans-1757
  prefs: []
  type: TYPE_TB
- en: '| C | ‑.‑. | P | .‑‑. |'
  id: totrans-1758
  prefs: []
  type: TYPE_TB
- en: '| D | ‑.. | Q | ‑‑.‑ |'
  id: totrans-1759
  prefs: []
  type: TYPE_TB
- en: '| E | . | R | .‑. |'
  id: totrans-1760
  prefs: []
  type: TYPE_TB
- en: '| F | ..‑. | S | ... |'
  id: totrans-1761
  prefs: []
  type: TYPE_TB
- en: '| G | ‑‑. | T | ‑ |'
  id: totrans-1762
  prefs: []
  type: TYPE_TB
- en: '| H | .... | U | ..‑ |'
  id: totrans-1763
  prefs: []
  type: TYPE_TB
- en: '| I | .. | V | ...‑ |'
  id: totrans-1764
  prefs: []
  type: TYPE_TB
- en: '| J | .‑‑‑ | W | .‑‑ |'
  id: totrans-1765
  prefs: []
  type: TYPE_TB
- en: '| K | ‑.‑ | X | ‑..‑ |'
  id: totrans-1766
  prefs: []
  type: TYPE_TB
- en: '| L | .‑.. | Y | ‑.‑‑ |'
  id: totrans-1767
  prefs: []
  type: TYPE_TB
- en: '| M | ‑‑ | Z | ‑‑.. |'
  id: totrans-1768
  prefs: []
  type: TYPE_TB
- en: 'Hint: Use a dictionary to hold the Morse code.'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: '37)Write a Python program that prompts the user to enter an English sentence.
    The program must then display:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: a)all letters that exist in the user-provided sentence along with their frequency
    count
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: b)all letters that do not exist in the user-provided sentence
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: c)the percentage of letters that do not exist in relation to the letters of
    the English alphabet
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: d)the percentage of non-alphabetic characters in relation to the characters
    of the user-provided sentence (excluding space characters)
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Use a dictionary to store all 26 English letters as keys and their frequencies
    as values, but find a clever way to create it.'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
