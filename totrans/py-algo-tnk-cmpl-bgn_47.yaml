- en: Chapter 33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More with Data Structures
  prefs: []
  type: TYPE_NORMAL
- en: 33.1 Simple Exercises with Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exercise 33.1-1 Creating a List that Contains the Average Values of its Neighboring
    Elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter 100 positive numerical values
    into a list. Then, the program must create a new list of 98 elements. This new
    list must contain, in each position the average value of the three elements that
    exist in the current and the next two positions of the user-provided list.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand this exercise through an example using 10 elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-01.png)'
  prefs: []
  type: TYPE_IMG
- en: List newArr is the new list that is created. In list newArr, the element at
    position 0 is the average value of the elements in the current and the next two
    positions of list a; that is, (5 + 10 + 9) / 3 = 8\. The element at position 1
    is the average value of the elements in the current and the next two positions
    of list a; that is, (10 + 9 + 2) / 3 = 7, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-1a'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS_OF_A = 100
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS_OF_NEW = ELEMENTS_OF_A - 2
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * ELEMENTS_OF_A
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS_OF_A):'
  prefs: []
  type: TYPE_NORMAL
- en: a[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: newArr = [None] * ELEMENTS_OF_NEW
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS_OF_NEW):'
  prefs: []
  type: TYPE_NORMAL
- en: newArr[i] = (a[i] + a[i + 1] + a[i + 2]) / 3
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS_OF_NEW):'
  prefs: []
  type: TYPE_NORMAL
- en: print(newArr[i])
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer a more Pythonic way, though, the solution is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-1b'
  prefs: []
  type: TYPE_NORMAL
- en: from math import fsum
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS_OF_A = 100
  prefs: []
  type: TYPE_NORMAL
- en: a = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS_OF_A):'
  prefs: []
  type: TYPE_NORMAL
- en: a.append(float(input()))
  prefs: []
  type: TYPE_NORMAL
- en: newArr = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS_OF_A - 2):'
  prefs: []
  type: TYPE_NORMAL
- en: newArr.append(fsum(a[i:i + 3]) / 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in newArr:'
  prefs: []
  type: TYPE_NORMAL
- en: print(element)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.1-2 Creating a List with the Greatest Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter numerical values into lists
    a and b of 20 elements each. Then, the program must create a new list newArr of
    20 elements. The new list must contain in each position the greatest value of
    lists a and b of the corresponding position.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Nothing new here! You need two for-loops to read the values for lists a and
    b, one for creating the list newArr, and one to display the list newArr on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: The Python program is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-2'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: '#Read lists a and b'
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: b = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: a[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: b[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: '#Create list newArr'
  prefs: []
  type: TYPE_NORMAL
- en: newArr = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[i] > b[i]:'
  prefs: []
  type: TYPE_NORMAL
- en: newArr[i] = a[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: newArr[i] = b[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display list newArr'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(newArr[i])
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.1-3 Merging One-Dimensional Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that, for two given lists a and b of 10 and 15 elements,
    respectively, creates a new list newArr of 25 elements. This new list must contain
    in the first 10 positions the elements of list a, and in the next 15 positions
    the elements of list b.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Since not all computer languages are so powerful in the field of data structures
    as Python, let's study three approaches here. The first one can be applied to
    most computer languages, whereas the second and the third ones are more Pythonic!
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the example presented next, there is a direct one-to-one correspondence
    between the index positions of the elements of list a and those of list newArr.
    Specifically, the element from position 0 of list a is stored in position 0 of
    list newArr, the element from position 1 of list a is stored in position 1 of
    list newArr, and so forth. However, this correspondence doesn't hold for list
    b; its elements need to be shifted by 10 positions in newArr.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-02.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to assign the values of list a to list newArr you can use the following
    code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(a)):'
  prefs: []
  type: TYPE_NORMAL
- en: newArr[i] = a[i]
  prefs: []
  type: TYPE_NORMAL
- en: However, to assign the values of list b to list newArr your code fragment should
    be slightly different as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(b)):'
  prefs: []
  type: TYPE_NORMAL
- en: newArr[len(a) + i] = b[i]
  prefs: []
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-3a'
  prefs: []
  type: TYPE_NORMAL
- en: '#Create lists a and b'
  prefs: []
  type: TYPE_NORMAL
- en: a = [5, 10, 9, 6, 7, -6, 13, 12, 11, 2]
  prefs: []
  type: TYPE_NORMAL
- en: b = [-11, 25, 4, 45, 67, 87, 34, 23, 33, 55, 13, 15, -4, -2, -22]
  prefs: []
  type: TYPE_NORMAL
- en: '#Create list newArr'
  prefs: []
  type: TYPE_NORMAL
- en: newArr = [None] * (len(a) + len(b))
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(a)):'
  prefs: []
  type: TYPE_NORMAL
- en: newArr[i] = a[i]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(b)):'
  prefs: []
  type: TYPE_NORMAL
- en: newArr[len(a) + i] = b[i]
  prefs: []
  type: TYPE_NORMAL
- en: '#Display list newArr'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(newArr)):'
  prefs: []
  type: TYPE_NORMAL
- en: print(newArr[i], end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: This approach uses the append() method of Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-3b'
  prefs: []
  type: TYPE_NORMAL
- en: '#Create lists a and b'
  prefs: []
  type: TYPE_NORMAL
- en: a = [5, 10, 9, 6, 7, -6, 13, 12, 11, 2]
  prefs: []
  type: TYPE_NORMAL
- en: b = [-11, 25, 4, 45, 67, 87, 34, 23, 33, 55, 13, 15, -4, -2, -22]
  prefs: []
  type: TYPE_NORMAL
- en: '#Create list newArr'
  prefs: []
  type: TYPE_NORMAL
- en: newArr = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in a:'
  prefs: []
  type: TYPE_NORMAL
- en: newArr.append(element)
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in b:'
  prefs: []
  type: TYPE_NORMAL
- en: newArr.append(element)
  prefs: []
  type: TYPE_NORMAL
- en: '#Display list newArr'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(newArr)):'
  prefs: []
  type: TYPE_NORMAL
- en: print(newArr[i], end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: Third approach
  prefs: []
  type: TYPE_NORMAL
- en: This approach uses the magic forces of Python. In order to merge two lists in
    Python, you can simply use the concatenation operator ( + ). Python will do the
    rest for you!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-3c'
  prefs: []
  type: TYPE_NORMAL
- en: '#Create lists a and b'
  prefs: []
  type: TYPE_NORMAL
- en: a = [5, 10, 9, 6, 7, -6, 13, 12, 11, 2]
  prefs: []
  type: TYPE_NORMAL
- en: b = [-11, 25, 4, 45, 67, 87, 34, 23, 33, 55, 13, 15, -4, -2, -22]
  prefs: []
  type: TYPE_NORMAL
- en: '#Create list newArr'
  prefs: []
  type: TYPE_NORMAL
- en: newArr = a + b
  prefs: []
  type: TYPE_NORMAL
- en: '#Display list newArr'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(newArr)):'
  prefs: []
  type: TYPE_NORMAL
- en: print(newArr[i], end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.1-4 Creating Two Lists – Separating Positive from Negative Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter 100 numerical values into a
    list and then creates two new lists, pos and neg. List pos must contain positive
    values, whereas list neg must contain the negative ones. The value 0 (if any)
    must not be added to either of the final lists, pos or neg.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: There are two approaches! The first one can be applied to most computer languages,
    whereas the second one is more Pythonic!
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze this approach using the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-03.png)'
  prefs: []
  type: TYPE_IMG
- en: In this exercise, there is no one-to-one correspondence between the index positions
    of the elements of list ar and the lists pos and neg. For example, the element
    from position 1 of list ar is not stored in position 1 of list neg, or the element
    from position 2 of list ar is not stored in position 2 of list pos. Thus, you
    cannot do the following,
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if ar[i] > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: pos[i] = ar[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif ar[i] < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: neg[i] = ar[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: because it will result in the following two lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What you need here are two independent index variables: posIndex for the list
    pos, and negIndex for the list neg. These index variables must be incremented
    independently, and only when an element is added to the corresponding list. The
    index variable posIndex must be incremented only when an element is added to the
    list pos, and the index variable negIndex must be incremented only when an element
    is added to the list neg, as shown in the code fragment that follows.'
  prefs: []
  type: TYPE_NORMAL
- en: posIndex = 0
  prefs: []
  type: TYPE_NORMAL
- en: negIndex = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if ar[i] > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: pos[posIndex] = ar[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: posIndex += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif ar[i] < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: neg[negIndex] = ar[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: negIndex += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that variables posIndex and negIndex have dual roles.
    When the loop iterates, each points to the next position in which a new element
    must be placed. But when the loop finishes iterating, variables posIndex and negIndex
    also contain the total number of elements in each corresponding list!'
  prefs: []
  type: TYPE_NORMAL
- en: The complete solution is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-4a'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 100
  prefs: []
  type: TYPE_NORMAL
- en: ar = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: ar[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: '#Create lists pos and neg'
  prefs: []
  type: TYPE_NORMAL
- en: posIndex = 0
  prefs: []
  type: TYPE_NORMAL
- en: negIndex = 0
  prefs: []
  type: TYPE_NORMAL
- en: pos = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: neg = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if ar[i] > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: pos[posIndex] = ar[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: posIndex += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif ar[i] < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: neg[negIndex] = ar[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: negIndex += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(posIndex):'
  prefs: []
  type: TYPE_NORMAL
- en: print(pos[i], end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(negIndex):'
  prefs: []
  type: TYPE_NORMAL
- en: print(neg[i], end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that the lists pos and neg contain a total number of
    posIndex and negIndex elements respectively. This is why the two last loop control
    structures iterate until variable i reaches values posIndex − 1 and negIndex −
    1, respectively, and not until ELEMENTS − 1, as you may mistakenly expect.'
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: The first approach has a main disadvantage! The lists pos and neg must be initialized
    to a size of 100 because there is always a possibility that list ar contains only
    positive numbers, or probably only negative ones. Using the append() method, the
    next approach is more efficient than the previous one since it uses the least
    possible amount of main memory (RAM).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-4b'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 100
  prefs: []
  type: TYPE_NORMAL
- en: ar = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: ar.append(float(input()))
  prefs: []
  type: TYPE_NORMAL
- en: '#Create lists pos and neg'
  prefs: []
  type: TYPE_NORMAL
- en: pos = []
  prefs: []
  type: TYPE_NORMAL
- en: neg = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in ar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if element > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: pos.append(element)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif element < 0:'
  prefs: []
  type: TYPE_NORMAL
- en: neg.append(element)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for element in pos:'
  prefs: []
  type: TYPE_NORMAL
- en: print(element, end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in neg:'
  prefs: []
  type: TYPE_NORMAL
- en: print(element, end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)It is obvious that one problem can have many solutions.
    It is up to you to find the optimal one!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Be careful! In Python, even though you can do something
    like x = y = 0, this is not true when it comes to lists. It is absolutely incorrect
    to write pos = neg = [] because both pos and neg would refer to the same list.
    You must use two individual statements, as shown in this approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.1-5 Creating a List with Those who Contain Digit 5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter 100 two-digit integers into
    a list and then creates a new list of only the integers that contain at least
    one of the digit 5.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: This exercise requires some knowledge from the past. In [Exercise 13.1-2](chapter13.html#toc_3)
    you learned how to use the quotient and the remainder to split an integer into
    its individual digits. Here, the user-provided integers have two digits; therefore,
    you can use the following code fragment to split any two-digit integer contained
    in variable x.
  prefs: []
  type: TYPE_NORMAL
- en: lastDigit = x % 10
  prefs: []
  type: TYPE_NORMAL
- en: firstDigit = x // 10
  prefs: []
  type: TYPE_NORMAL
- en: or a more Pythonic way is to use the divmod() function.
  prefs: []
  type: TYPE_NORMAL
- en: firstDigit, lastDigit = divmod(x, 10)
  prefs: []
  type: TYPE_NORMAL
- en: There are two approaches that you can use to solve this exercise! The first
    one can be applied to most computer languages, whereas the second one is more
    Pythonic!
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: This approach uses an extra variable as an index for the new list. This is necessary
    when you want to create a new list using values from an old list and there is
    no one-to-one correspondence between their index positions. Of course, this variable
    must increase by 1 only when a new element is added into the new list. Moreover,
    when the loop that creates the new list finishes iterating, the value of this
    variable also matches the total number of elements in the new list! The final
    Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-5a'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 100
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: a[i] = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: k = 0
  prefs: []
  type: TYPE_NORMAL
- en: b = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: lastDigit = a[i] % 10
  prefs: []
  type: TYPE_NORMAL
- en: firstDigit = a[i] // 10
  prefs: []
  type: TYPE_NORMAL
- en: 'if firstDigit == 5 or lastDigit == 5:'
  prefs: []
  type: TYPE_NORMAL
- en: b[k] = a[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: k += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(k):'
  prefs: []
  type: TYPE_NORMAL
- en: print(b[i], end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous exercise, the main disadvantage of the first approach is
    that it initializes list b to a size of 100, regardless of the fact that the user
    may or may not enter integers that contain at least one instance of the digit
    5! Using the append() method, the next approach is more efficient and more Pythonic!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.1-5b'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 100
  prefs: []
  type: TYPE_NORMAL
- en: a = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: a.append(int(input()))
  prefs: []
  type: TYPE_NORMAL
- en: b = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in a:'
  prefs: []
  type: TYPE_NORMAL
- en: firstDigit, lastDigit = divmod(element, 10)
  prefs: []
  type: TYPE_NORMAL
- en: 'if 5 in [firstDigit, lastDigit]:'
  prefs: []
  type: TYPE_NORMAL
- en: b.append(element)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for element in b:'
  prefs: []
  type: TYPE_NORMAL
- en: print(element, end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: 33.2 Data Validation with Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you have already been taught in [Section 29.3](chapter29.html#toc_11), there
    are three approaches that you can use to validate data input. Your approach will
    depend on whether or not you wish to display an error message, and whether you
    wish to display a different error message for each type of input error or just
    a generic error message for any kind of error.  Let's see how those three approaches
    can be adapted and used with lists.
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Validating data input without error messages
  prefs: []
  type: TYPE_NORMAL
- en: In [Section 29.3](chapter29.html#toc_11), you learned how to validate one single
    value entered by the user without displaying any error messages. For your convenience,
    the code fragment given in general form is presented once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: input_data = input("Prompt message")
  prefs: []
  type: TYPE_NORMAL
- en: if input_data test 1 succeeds and
  prefs: []
  type: TYPE_NORMAL
- en: input_data test 2 succeeds and
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: 'input_data test N succeeds: break'
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember how this operates? If the user enters a valid value, the flow
    of execution simply proceeds to the next section of the program. However, if they
    enter an invalid value, the primary objective is to repeatedly prompt them until
    they eventually provide a valid one.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same principle when entering data into lists. If you use a for-loop
    to iterate for all elements of the list, the code fragment becomes as follows.
  prefs: []
  type: TYPE_NORMAL
- en: input_list = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: for i in range(ELEMENTS)
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: input_data = input("Prompt message")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if input_data test 1 succeeds and
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: input_data test 2 succeeds and
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'input_data test N succeeds: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: input_list[i] = input_data
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when the flow of execution exits the nested post-test loop structure,
    the variable input_data definitely contains a valid value which in turn is assigned
    to an element of the list input_list. However, the same process can be implemented
    more simply, without using the extra variable input_data, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: input_list = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: input_list[i] = input("Prompt message")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if input_list[i] test 1 succeeds and
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: input_list[i] test 2 succeeds and
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'input_list[i] test N succeeds: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Second approach – Validating data input with a generic error message
  prefs: []
  type: TYPE_NORMAL
- en: As before, the next code fragment is taken from [Section 29.3](chapter29.html#toc_11)
    and adapted to operate with a list. It validates data input and displays a generic
    error message (that is, the same error message for any type of input error).
  prefs: []
  type: TYPE_NORMAL
- en: input_list = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: input_list[i] = input("Prompt message")
  prefs: []
  type: TYPE_NORMAL
- en: while input_list[i] test 1 fails or
  prefs: []
  type: TYPE_NORMAL
- en: input_list[i] test 2 fails or
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'input_list[i] test N fails:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Error message")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: input_list[i] = input("Prompt message")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Third approach – Validating data input with different error messages
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the next code fragment is taken from [Section 29.3](chapter29.html#toc_11)
    and adapted to operate with a list. It validates data input and displays a different
    error message for each type of input error.
  prefs: []
  type: TYPE_NORMAL
- en: input_list = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: input_list[i] = input("Prompt message")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = False
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if input_list[i] test 1 fails:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Error message 1")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif input_list[i] test 2 fails:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Error message 2")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: elif …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif input_list[i] test N fails:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Error message N")
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not failure: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.2-1 Displaying Odds in Reverse Order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write a Python program that prompts the user to enter 20 odd positive integers
    into a list and then displays them in the exact reverse of the order in which
    they were provided. The program must validate data input, preventing the user
    from entering a non-positive value, a float, or an even integer. Solve this exercise
    in three versions:'
  prefs: []
  type: TYPE_NORMAL
- en: a)Validate data input without displaying any error messages.
  prefs: []
  type: TYPE_NORMAL
- en: b)Validate data input and display a generic error message.
  prefs: []
  type: TYPE_NORMAL
- en: c)Validate data input and display a different error message for each type of
    input error.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: All three approaches for validating data input that you learned in [Section
    33.2](#toc_7) will be presented here. Let's first solve this exercise without
    data validation.
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: odds = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = int(input("Enter an odd positive integer: "))   [[More…]](more.html#more_33_2_1_1)'
  prefs: []
  type: TYPE_NORMAL
- en: odds[i] = x
  prefs: []
  type: TYPE_NORMAL
- en: '#Display elements backwards             # Or you can do the following'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS - 1, -1, -1):   # for element in odds[::-1]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(odds[i], end = "\t")          #     print(element, end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: Validation without error messages
  prefs: []
  type: TYPE_NORMAL
- en: To validate data input without displaying any error messages, use the first
    approach from [Section 33.2](#toc_7). Simply replace the statements marked with
    a dashed rectangle with the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter an odd positive integer: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x > 0 and x == int(x) and x % 2 != 0: break'
  prefs: []
  type: TYPE_NORMAL
- en: odds[i] = int(x)
  prefs: []
  type: TYPE_NORMAL
- en: The final program becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.2-1a'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: odds = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: while True:                                    [[More…]](more.html#more_33_2_1_2)
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter an odd positive integer: "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if x > 0 and x == int(x) and x % 2 != 0: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: odds[i] = int(x)
  prefs: []
  type: TYPE_NORMAL
- en: '#Display elements backwards             # Or you can do the following'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS - 1, -1, -1):   # for element in odds[::-1]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(odds[i], end = "\t")          #     print(element, end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Variable x must be of type float. This is necessary in order
    to allow the user to enter either an integer or a float (real).'
  prefs: []
  type: TYPE_NORMAL
- en: Validation with a generic error message
  prefs: []
  type: TYPE_NORMAL
- en: To validate data input and display a generic error message, replace the statements
    marked with the dashed rectangle with a code fragment based on the second approach
    from [Section 33.2](#toc_7). The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.2-1b'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: odds = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter an odd positive integer: "))   [[More…]](more.html#more_33_2_1_3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'while x <= 0 or x != int(x) or x % 2 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Invalid value!")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'x = float(input("Enter an odd positive integer: "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: odds[i] = int(x)
  prefs: []
  type: TYPE_NORMAL
- en: '#Display elements backwards'
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in odds[::-1]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(element, end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: Validation with different error messages
  prefs: []
  type: TYPE_NORMAL
- en: Here, the replacing code fragment is based on the third approach from [Section
    33.2](#toc_7). To validate data input and display a different error message for
    each type of input error, the Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.2-1c'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: odds = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: while True:                                      [[More…]](more.html#more_33_2_1_4)
  prefs: []
  type: TYPE_NORMAL
- en: 'x = float(input("Enter an odd positive integer: "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = False
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if x <= 0 :'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("Invalid value: Non-positive entered!")'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif x != int(x):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("Invalid value: Float entered!")'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif x % 2 == 0:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("Invalid value: Even entered!")'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: failure = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not failure: break'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: odds[i] = int(x)
  prefs: []
  type: TYPE_NORMAL
- en: '#Display elements backwards'
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in odds[::-1]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(element, end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: 33.3 Finding Minimum and Maximum Values in Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the third and last time that this subject is brought up in this book.
    The first time was in [Section 22.2](chapter22.html#toc_8) using decision control
    structures and the second time was in [Section 29.4](chapter29.html#toc_14) using
    loop control structures. So, there is not much left to discuss except the fact
    that when you want to find the minimum or maximum value of a data structure that
    already contains some values, you needn't worry about the initial values of variables
    minimum or maximum because you can just assign to them the value of the first
    element of the data structure!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-1 Which Depth is the Greatest?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the depths of 20 lakes and then
    displays the depth of the deepest one.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: After the user enters the depths of the 20 lakes in the list depths, the initial
    value of variable maximum can be set to the value of depths[0], that is, the first
    element of list depths. The program can then search any subsequent value greater
    than this, starting from index 1\. The final solution is quite straightforward
    and is presented next without further explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-1a'
  prefs: []
  type: TYPE_NORMAL
- en: LAKES = 20
  prefs: []
  type: TYPE_NORMAL
- en: depths = [None] * LAKES
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(LAKES):'
  prefs: []
  type: TYPE_NORMAL
- en: depths[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: maximum = depths[0]  #Initial value
  prefs: []
  type: TYPE_NORMAL
- en: '#Search thereafter, starting from index 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, LAKES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if depths[i] > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = depths[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(maximum)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)It wouldn''t be wrong to start iterating from position 0
    instead of 1, though the program would perform one useless iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)It wouldn''t be wrong to assign an “almost arbitrary” initial
    value to variable maximum but there is no reason to do so. The value of the first
    element is just fine! If you insist though, you can assign an initial value of
    0, since there is no lake on planet Earth with a negative depth.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind though, that a more Pythonic way to find the greatest value of
    a list is to use the max() function, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-1b'
  prefs: []
  type: TYPE_NORMAL
- en: LAKES = 20
  prefs: []
  type: TYPE_NORMAL
- en: depths = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(LAKES):'
  prefs: []
  type: TYPE_NORMAL
- en: depths.append(float(input()))
  prefs: []
  type: TYPE_NORMAL
- en: maximum = max(depths)
  prefs: []
  type: TYPE_NORMAL
- en: print(maximum)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Correspondingly, if you want to find the smallest value
    of a list you can use the min() function.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-2 Which Lake is the Deepest?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the names and the depths of
    20 lakes and then displays the name of the deepest one.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know how to find the name of the deepest lake, you may need to
    refresh your memory by re-reading [Exercise 29.4-2](chapter29.html#toc_16).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you need two one-dimensional lists: one to hold the names,
    and one to hold the depths of the lakes. The solution is presented next.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-2'
  prefs: []
  type: TYPE_NORMAL
- en: LAKES = 20
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * LAKES
  prefs: []
  type: TYPE_NORMAL
- en: depths = [None] * LAKES
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(LAKES):'
  prefs: []
  type: TYPE_NORMAL
- en: names[i] = input()
  prefs: []
  type: TYPE_NORMAL
- en: depths[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: maximum = depths[0]
  prefs: []
  type: TYPE_NORMAL
- en: mName = names[0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, LAKES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if depths[i] > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = depths[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: mName = names[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(mName)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)You cannot use the function max() in this exercise! It would
    return the greatest depth, not the name of the lake with that greatest depth!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-3 Which Lake, in Which Country, Having Which Average Area, is
    the Deepest?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the names and the depths of
    20 lakes as well as the country in which they belong, and their average area.
    The program must then display all available information about the deepest lake.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the next example of six lakes. The depths are expressed in feet
    and the average areas in square miles.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-05.png)'
  prefs: []
  type: TYPE_IMG
- en: It's evident that Lake Baikal holds the record as the deepest lake, positioned
    at index 2\. If you were to approach this exercise in a manner similar to the
    previous exercise ([Exercise 33.3-2](#toc_11)), you would need three more variables
    to keep the name, country, and area each time a depth greater than the previously
    stored one is found. However, the solution presented below employs a more efficient
    approach, using only one variable (indexOfMax) to track the index where these
    values are located.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-3'
  prefs: []
  type: TYPE_NORMAL
- en: LAKES = 20
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * LAKES
  prefs: []
  type: TYPE_NORMAL
- en: depths = [None] * LAKES
  prefs: []
  type: TYPE_NORMAL
- en: countries = [None] * LAKES
  prefs: []
  type: TYPE_NORMAL
- en: areas = [None] * LAKES
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(LAKES):'
  prefs: []
  type: TYPE_NORMAL
- en: names[i] = input()
  prefs: []
  type: TYPE_NORMAL
- en: depths[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: countries[i] = input()
  prefs: []
  type: TYPE_NORMAL
- en: areas[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: '#Find the maximum depth and the index in which this maximum depth exists'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = depths[0]
  prefs: []
  type: TYPE_NORMAL
- en: indexOfMax = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, LAKES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if depths[i] > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = depths[i]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexOfMax = i
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display information using indexOfMax as index'
  prefs: []
  type: TYPE_NORMAL
- en: print(depths[indexOfMax], names[indexOfMax], end = " ")
  prefs: []
  type: TYPE_NORMAL
- en: print(countries[indexOfMax], areas[indexOfMax])
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Assigning an initial value of 0 to variable indexOfMax is
    necessary since there is always a possibility that the maximum value does exist
    in position 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-4 Which Students Have got the Greatest Grade?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names and the grades
    of 200 students and then displays the names of all those who share the one greatest
    grade. Using a loop control structure, the program must also validate data input
    and display an error message when the user enters an empty name or any negative
    values or values greater than 100 for grades.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need to validate both the names and the grades. A code
    fragment, given in general form, shows the data input stage.
  prefs: []
  type: TYPE_NORMAL
- en: STUDENTS = 200
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * STUDENTS
  prefs: []
  type: TYPE_NORMAL
- en: grades = [None] * STUDENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: Prompt the user to enter a name and validate it. It cannot be empty!
  prefs: []
  type: TYPE_NORMAL
- en: Prompt the user to enter a grade and validate it. It cannot be negative or greater
    than 100.
  prefs: []
  type: TYPE_NORMAL
- en: After data input stage, a loop control structure must search for the greatest
    value, and then, another loop control structure must search the list grades for
    all values that are equal to that greatest value.
  prefs: []
  type: TYPE_NORMAL
- en: The solution in presented next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-4'
  prefs: []
  type: TYPE_NORMAL
- en: STUDENTS = 200
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * STUDENTS
  prefs: []
  type: TYPE_NORMAL
- en: grades = [None] * STUDENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Prompt the user to enter a name and validate it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for student No " + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'while names[i] == "":'
  prefs: []
  type: TYPE_NORMAL
- en: print("Error! Name cannot be empty!")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for student No " + str(i + 1) + ": ")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Prompt the user to enter a grade and validate it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'grades[i] = int(input("Enter their grade: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'while grades[i] < 0 or grades[i] > 100:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Invalid value!")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'grades[i] = int(input("Enter their grade: "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Find the greatest grade'
  prefs: []
  type: TYPE_NORMAL
- en: 'maximum = grades[0]                 # Or you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, STUDENTS):        # maximum = max(grades)'
  prefs: []
  type: TYPE_NORMAL
- en: 'if grades[i] > maximum:         #'
  prefs: []
  type: TYPE_NORMAL
- en: 'maximum = grades[i]         #'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Displays the names of all those who share the one greatest grade'
  prefs: []
  type: TYPE_NORMAL
- en: print("The following students have got the greatest grade:")
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if grades[i] == maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that this exercise could not have been solved without
    the use of a list.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Keep in mind that the following code fragment is also correct
    but very inefficient.'
  prefs: []
  type: TYPE_NORMAL
- en: print("The following students have got the greatest grade:")
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if grades[i] == max(grades):'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The reason is that in this example, function max() is called each time the loop
    iterates—that is, 200 times!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-5 Finding the Minimum Value of a Two-Dimensional List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the temperatures (in degrees
    Fahrenheit) recorded at the same hour each day in January in 10 different cities.
    The Python program must display the lowest temperature.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-06.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)The list t has 31 columns (0 to 30), as many as there are
    days in January.'
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing new here. The initial value of variable minimum can be the
    value of the element t[0][0]. Then, the program can iterate through rows, or even
    through columns, to search for the minimum value. The solution is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-5a'
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  prefs: []
  type: TYPE_NORMAL
- en: '#Read list t'
  prefs: []
  type: TYPE_NORMAL
- en: t = [[None] * DAYS for i in range(CITIES)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: t[i][j] = int(input())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Find minimum'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = t[0][0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < minimum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = t[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(minimum)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In this exercise you cannot do the following because if
    you do, and variable j starts from 1, the whole column with index 0 won''t be
    checked!'
  prefs: []
  type: TYPE_NORMAL
- en: '#Find minimum'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = t[0][0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, DAYS):  #This is wrong! Variable j must start from 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < minimum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = t[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: A more Pythonic way, though, is to find the lowest value of list t using the
    min() function, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-5b'
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  prefs: []
  type: TYPE_NORMAL
- en: '#Read list t'
  prefs: []
  type: TYPE_NORMAL
- en: t = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: t.append([])
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: t[i].append(int(input()))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(min(t))
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-6 Finding the City with the Coldest Day
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the names of 10 cities as well
    as the temperatures (in degrees Fahrenheit) recorded at the same hour each day
    in January in those cities. The Python program must display the name of the city
    that had the lowest temperature and on which day it was recorded.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, the following two lists are needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-07.png)'
  prefs: []
  type: TYPE_IMG
- en: The solution is simple. Every time variable minimum updates its value, two variables,
    m_i and m_j, can hold the current values of variables i and j respectively. In
    the end, these two variables will contain the row index and the column index of
    the position in which the minimum value exists. The solution is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-6'
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * CITIES
  prefs: []
  type: TYPE_NORMAL
- en: t = [[None] * DAYS for i in range(CITIES)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: names[i] = input()
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: t[i][j] = int(input())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = t[0][0]
  prefs: []
  type: TYPE_NORMAL
- en: m_i = 0
  prefs: []
  type: TYPE_NORMAL
- en: m_j = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < minimum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = t[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: m_i = i
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: m_j = j
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("Minimum temperature: ", minimum)'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("City: ", names[m_i])'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Day: ", m_j + 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Assigning an initial value of 0 to variables m_i and m_j
    is necessary since there is always a possibility that the minimum value is the
    value of the element t[0][0].'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.3-7 Finding the Minimum and the Maximum Value of Each Row
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter values into list b of 20 × 30
    elements and then finds and displays the minimum and the maximum values of each
    row.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: There are three approaches, actually. The first approach creates two auxiliary
    one-dimensional lists, minimum and maximum, and then displays them. Lists minimum
    and maximum will contain, in each position, the minimum and the maximum values
    of each row respectively. On the other hand, the second and third approaches find
    and directly display the minimum and maximum values of each row. Let's study them
    all.
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Creating auxiliary lists
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this approach, let's use the “from inner to outer” method.
    When the following code fragment completes its iterations, the auxiliary one-dimensional
    lists minimum and maximum will contain at position 0 the minimum and the maximum
    values of the first row (row index 0) of list b respectively. Assume variable
    i contains value 0.
  prefs: []
  type: TYPE_NORMAL
- en: minimum[i] = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: maximum[i] = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum[i]:'
  prefs: []
  type: TYPE_NORMAL
- en: minimum[i] = b[i][j]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum[i]:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum[i] = b[i][j]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that variable j starts from 1\. It wouldn''t be wrong
    to start iterating from column index 0 instead of 1, though the program would
    perform one useless iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything has been clarified, in order to process the whole list b,
    you can just nest the previous code fragment into a for-loop that iterates for
    all rows as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: minimum[i] = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: maximum[i] = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum[i]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum[i] = b[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum[i]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum[i] = b[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-7a'
  prefs: []
  type: TYPE_NORMAL
- en: ROWS = 30
  prefs: []
  type: TYPE_NORMAL
- en: COLUMNS = 20
  prefs: []
  type: TYPE_NORMAL
- en: b = [[None] * COLUMNS for i in range(ROWS)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: b[i][j] = float(input())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = [None] * ROWS
  prefs: []
  type: TYPE_NORMAL
- en: maximum = [None] * ROWS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: minimum[i] = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: maximum[i] = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum[i]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum[i] = b[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum[i]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum[i] = b[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(minimum[i], maximum[i])
  prefs: []
  type: TYPE_NORMAL
- en: Second approach – Finding and directly displaying minimum and maximum values
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the “from inner to outer” method once again. The next code fragment
    finds and directly displays the minimum and the maximum values of the first row
    (row index 0) of list b. Assume variable i contains the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: minimum = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: maximum = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = b[i][j]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = b[i][j]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(minimum, maximum)
  prefs: []
  type: TYPE_NORMAL
- en: In order to process the whole list b, you can just nest this code fragment into
    a for-loop that iterates for all rows, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: maximum = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = b[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum = b[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(minimum, maximum)
  prefs: []
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-7b'
  prefs: []
  type: TYPE_NORMAL
- en: ROWS = 30
  prefs: []
  type: TYPE_NORMAL
- en: COLUMNS = 20
  prefs: []
  type: TYPE_NORMAL
- en: b = [[None] * COLUMNS for i in range(ROWS)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: b[i][j] = float(input())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: maximum = b[i][0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(1, COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i][j] < minimum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = b[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if b[i][j] > maximum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum = b[i][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: print(minimum, maximum)
  prefs: []
  type: TYPE_NORMAL
- en: Third approach – The Pythonic way
  prefs: []
  type: TYPE_NORMAL
- en: This approach uses the min() and max() functions of Python. It finds and directly
    displays the lowest and the highest values of each row.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.3-7c'
  prefs: []
  type: TYPE_NORMAL
- en: ROWS = 30
  prefs: []
  type: TYPE_NORMAL
- en: COLUMNS = 20
  prefs: []
  type: TYPE_NORMAL
- en: b = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: b.append([])
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: b[i].append(float(input()))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for row in b:'
  prefs: []
  type: TYPE_NORMAL
- en: print(min(row), max(row))
  prefs: []
  type: TYPE_NORMAL
- en: 33.4 Sorting Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sorting algorithms are an important topic in computer science. A sorting algorithm
    is an algorithm that puts elements of a list in a certain order. There are many
    sorting algorithms and each one of them has particular strengths and weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: Most sorting algorithms work by comparing the elements of the list. They are
    usually evaluated by their efficiency and their memory requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many sorting algorithms. Some of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: ►the bubble sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: ►the modified bubble sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: ►the selection sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: ►the insertion sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: ►the heap sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: ►the merge sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: ►the quicksort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: As regards their efficiency, the bubble sort algorithm is considered the least
    efficient, while each succeeding algorithm in the list performs better than the
    preceding one. The quicksort algorithm is considered one of the best and fastest
    sorting algorithms, especially for large scale data operations.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms can be used for more than just displaying data in ascending
    or descending order; they can also assist in finding the minimum and the maximum
    values from a set of given values. For instance, in a list sorted in ascending
    order, the minimum value exists at the first index position and the maximum value
    exists at the last index position. While sorting a list solely for the purpose
    of finding the minimum and maximum values is very inefficient, if a program sorts
    a list for other reasons, and you subsequently need the minimum or maximum value,
    you know where you can find them!
  prefs: []
  type: TYPE_NORMAL
- en: Another scenario where you might need sorting algorithms is when you want to
    find and display, for example, the three largest (or smallest) numbers in a list.
    In this case, you can sort the list in descending order and then display only
    the first three elements, located at index positions 0, 1, and 2.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, Python incorporates the method sort() and the function
    sorted() for list sorting. However, there are situations where it's necessary
    to implement a custom sorting algorithm, especially when you need to sort a list
    while preserving the one-to-one correspondence with the elements of a second list.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-1 The Bubble Sort Algorithm – Sorting One-Dimensional Lists with
    Numeric Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter 20 numerical values into a list
    and then sorts them in ascending order using the bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: 'The bubble sort algorithm is probably one of the most inefficient sorting algorithms
    but it is widely used for teaching purposes. The main idea (when asked to sort
    a list in ascending order) is to repeatedly move the smallest elements of the
    list to the positions of lowest index. This works as follows: the algorithm iterates
    through the elements of the list, compares each pair of adjacent elements, and
    then swaps their contents (if they are in the wrong order). This process is repeated
    many times until the list is sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's try to sort the following list in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter33-08.png)
  prefs: []
  type: TYPE_NORMAL
- en: The lowest value is the value 5\. According to the bubble sort algorithm, this
    value must gradually “bubble” or “rise” to position 0, like bubbles rising in
    a glass of cola. When the value 5 has been moved into position 0, the next smallest
    value is the value 8\. Now, the value 8 must “bubble” to position 1\. Next is
    the value 12, which must “bubble” to position 2, and so on. This process repeats
    until all elements are placed in proper position.
  prefs: []
  type: TYPE_NORMAL
- en: But how can this “bubbling” be done using an algorithm? Let's see the whole
    process in more detail. For the previous list A of six elements, five passes must
    be performed.
  prefs: []
  type: TYPE_NORMAL
- en: First Pass
  prefs: []
  type: TYPE_NORMAL
- en: 1st Compare
  prefs: []
  type: TYPE_NORMAL
- en: Initially, elements at index positions 4 and 5 are compared. Since the value
    12 is less than the value 49, these two elements swap their content.
  prefs: []
  type: TYPE_NORMAL
- en: 2nd Compare
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 3 and 4 are compared. Since the value 12 is not
    less than the value 5, no swapping is done.
  prefs: []
  type: TYPE_NORMAL
- en: 3rd Compare
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 2 and 3 are compared. Since the value 5 is less
    than the value 8, these two elements swap their content.
  prefs: []
  type: TYPE_NORMAL
- en: 4th Compare
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 1 and 2 are compared. Since the value 5 is less
    than the value 25, these two elements swap their content.
  prefs: []
  type: TYPE_NORMAL
- en: 5th Compare
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 0 and 1 are compared. Since the value 5 is less
    than the value 17, these two elements swap their content.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-09.png)'
  prefs: []
  type: TYPE_IMG
- en: The first pass has been completed but, as you can see, the list has not been
    sorted yet. The only value that is guaranteed to be placed in proper position
    is the value 5\. However, since more passes will follow, there is no need for
    the value 5 to take part in the subsequent compares. In the pass that follows,
    one less compare will be performed—that is, four compares.
  prefs: []
  type: TYPE_NORMAL
- en: Second Pass
  prefs: []
  type: TYPE_NORMAL
- en: 1st Compare
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 4 and 5 are compared. Since the value 49 is not
    less than the value 12, no swapping is done.
  prefs: []
  type: TYPE_NORMAL
- en: 2nd Compare
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 3 and 4 are compared. Since the value 12 is not
    less than the value 8, no swapping is done.
  prefs: []
  type: TYPE_NORMAL
- en: 3rd Compare
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 2 and 3 are compared. Since the value 8 is less
    than the value 25, these two elements swap their content.
  prefs: []
  type: TYPE_NORMAL
- en: 4th Compare
  prefs: []
  type: TYPE_NORMAL
- en: Elements at index positions 1 and 2 are compared. Since the value 8 is less
    than the value 17, these two elements swap their content.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-10.png)'
  prefs: []
  type: TYPE_IMG
- en: The second pass has been completed and the value of 8 is guaranteed to be placed
    in proper position. However, since more passes will follow, there is no need for
    the value 8 (nor 5, of course) to take part in the subsequent compares. In the
    pass that follows, one less compare will be performed—that is, three compares.
  prefs: []
  type: TYPE_NORMAL
- en: Third Pass
  prefs: []
  type: TYPE_NORMAL
- en: In this pass, three compares (but only two swaps) are performed, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-11.png)'
  prefs: []
  type: TYPE_IMG
- en: The third pass has been completed and the value of 12 is guaranteed to be placed
    in proper position. As previously, since more passes will follow there is no need
    for the value 12 (nor the values 5 and 8, of course) to take part in the subsequent
    compares. In the pass that follows, one compare less will be performed—that is,
    two compares.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth Pass
  prefs: []
  type: TYPE_NORMAL
- en: In this pass, two compares (and no swaps) are performed, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-12.png)'
  prefs: []
  type: TYPE_IMG
- en: The fourth pass has been completed and the value 17 is guaranteed to be placed
    in proper position. As previously, since one last pass will follow, there is no
    need for the value 17 (nor the values 5, 8, and 12, of course) to take part in
    the subsequent compares. In the last pass that follows, one compare less will
    be performed—that is one compare.
  prefs: []
  type: TYPE_NORMAL
- en: Fifth pass
  prefs: []
  type: TYPE_NORMAL
- en: In this last pass, only one compare is performed. Since the value 49 is not
    less than the value 25, no swapping is done.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter33-13.png)
  prefs: []
  type: TYPE_NORMAL
- en: The fifth pass has been completed and the final two values (25 and 49) are now
    guaranteed to be in proper positions. The bubble sort algorithm has finished and
    the list is sorted in ascending order!
  prefs: []
  type: TYPE_NORMAL
- en: Now you need a Python program that can do the whole previous process. Let's
    use the “from inner to outer” method. The code fragment that performs only the
    first pass is shown below. Please note that this is the inner (nested) loop control
    structure. Assume variable m contains the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < a[n - 1]:'
  prefs: []
  type: TYPE_NORMAL
- en: temp = a[n]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n] = a[n - 1]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n - 1] = temp
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In the first pass, variable m must contain the value 0\.
    This assures that at the last iteration, the elements that are compared are those
    at index positions 1 and 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Swapping the contents of two elements uses a method you
    have already learned! Please recall the two glasses of orange juice and lemon
    juice. If this doesn''t ring a bell, you need to refresh your memory and re-read
    [Exercise 8.1-3](chapter08.html#toc_4).'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you can swap the contents of a[n] and a[n − 1] in a more Pythonic
    way, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < a[n - 1]:'
  prefs: []
  type: TYPE_NORMAL
- en: a[n], a[n - 1] = a[n - 1], a[n]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second pass can be performed if you just re-execute the previous code fragment.
    Variable m, however, needs to contain the value 1\. This will ensure that the
    element at index position 0 won't be compared again. Similarly, for the third
    pass, the previous code fragment can be re-executed but variable m needs to contain
    the value 2 for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, the previous code fragment needs to be executed five times (one
    for each pass), and each time variable m must be incremented by 1\. The final
    code fragment that sorts list a using the bubble sort algorithm is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < a[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n], a[n - 1] = a[n - 1], a[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)For N elements, the algorithm needs to perform N − 1 passes.
    For example, if list a contains 20 elements, the statement for m in range(ELEMENTS
    - 1) performs 19 passes.'
  prefs: []
  type: TYPE_NORMAL
- en: The complete Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-1'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: a[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < a[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n], a[n - 1] = a[n - 1], a[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(a[i], end = "\t")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The bubble sort algorithm is very inefficient. The total
    number of compares that it performs is ![Image](img/chapter33-14.png), where N
    is the total number of list elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The total number of swaps depends on the given list. The
    worst case is when you want to sort in ascending order a list that is already
    sorted in descending order, or vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-2 Sorting One-Dimensional Lists with Alphanumeric Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that sorts the alphanumeric values of a list in descending
    order using the bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the wording of this exercise to the previous one, two things are different.
    First, the bubble sort algorithm needs to sort alphanumeric values, such as names
    of people or names of cities; and second, it has to sort them in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: In order to sort alphanumeric data, you don't have to change anything in the
    algorithm! Python handles letters the same way it handles numbers. The letter
    “A” is considered “less than” the letter “B”, “B” is considered “less than” the
    letter “C”, and so on. Of course, if the list contains words in which the first
    letter is identical, Python moves on to compare their second letter and perhaps
    their third letter (if necessary). For example, the name “Johathan” is considered
    “less than” the name “Jone” as the fourth letter “a” is “less than” the fourth
    letter “e”.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Consider the alphanumeric sorting in the context of how
    words are organized in an English dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see what you need to change so that the algorithm can sort in descending
    order instead of ascending. Do you remember how the bubble sort algorithm actually
    works? Elements gradually “bubble” to positions of lowest index, like bubbles
    rise in a glass of cola. What you want in this exercise is to make the bigger
    (instead of the smaller) elements “bubble” to lower index positions. Therefore,
    all you need to do is simply reverse the comparison operator of the decision control
    structure!
  prefs: []
  type: TYPE_NORMAL
- en: The code fragment that sorts alphanumeric, and of course numeric, values in
    descending order is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: for m in range(ELEMENTS − 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] > a[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n], a[n - 1] = a[n - 1], a[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.4-3 Sorting One-Dimensional Lists While Preserving the Relationship
    with a Second List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the names of 20 lakes and their
    corresponding average area. The program must then sort them by average area in
    ascending order using the bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise you need the following two lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-15.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to sort list areas while preserving the one-to-one correspondence
    between the elements of the two lists, you must rearrange the elements of the
    list names as well. This means that every time two elements of the list areas
    swap contents, the corresponding elements of the list names must swap contents
    as well. The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-3'
  prefs: []
  type: TYPE_NORMAL
- en: LAKES = 20
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * LAKES
  prefs: []
  type: TYPE_NORMAL
- en: areas = [None] * LAKES
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(LAKES):'
  prefs: []
  type: TYPE_NORMAL
- en: names[i] = input()
  prefs: []
  type: TYPE_NORMAL
- en: areas[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(LAKES - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(LAKES - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if areas[n] < areas[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: areas[n], areas[n - 1] = areas[n - 1], areas[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for i in range(LAKES):'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i], "\t", areas[i])
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-4 Sorting Last and First Names
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the last and first names
    of 100 people. The program must then display the names with the last names sorted
    in alphabetical order. In cases where two or more people share the same last name,
    their first names should be displayed in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to sort a list while preserving the one-to-one correspondence
    with the elements of a second list. Now, you have to handle the case when two
    last names in the first list are equal. According to the wording of the exercise,
    the corresponding first names in the second list must also be sorted alphabetically.
    For example, the following list lastNm contains the last names of 100 people.
    It is sorted in alphabetical order and it contains the last name “Parker” three
    times. The corresponding first names “Andrew”, “Anna”, and “Chloe”, in list firstNm
    also have to be sorted alphabetically, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-16.png)'
  prefs: []
  type: TYPE_IMG
- en: For your convenience, the basic version of the bubble sort algorithm is presented
    once again here. Please note that this algorithm preserves the one-to-one correspondence
    between the elements of lists lastNm and firstNm.
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(PEOPLE - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PEOPLE - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if lastNm[n] < lastNm[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lastNm[n], lastNm[n - 1] = lastNm[n - 1], lastNm[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: To solve this exercise, however, this bubble sort algorithm must be adapted
    correspondingly. According to this basic version of the bubble sort algorithm,
    when the last name at position n is “less” than the last name at position n −
    1, the algorithm swaps the corresponding contents. However, if the last names
    at these positions are equal, the algorithm must then verify whether the corresponding
    first names are in the correct order. If not, a swap is required in the list firstNm.
    The adapted bubble sort algorithm is depicted in the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(PEOPLE - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PEOPLE - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if lastNm[n] < lastNm[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lastNm[n], lastNm[n - 1] = lastNm[n - 1], lastNm[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif lastNm[n] == lastNm[n - 1]:      #If the last names are equal'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if firstNm[n] < firstNm[n - 1]:   #check the corresponding first names'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Swap first names if not in correct order'
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-4'
  prefs: []
  type: TYPE_NORMAL
- en: PEOPLE = 100
  prefs: []
  type: TYPE_NORMAL
- en: '#Read lists firstNm and lastNm'
  prefs: []
  type: TYPE_NORMAL
- en: firstNm = [None] * PEOPLE
  prefs: []
  type: TYPE_NORMAL
- en: lastNm = [None] * PEOPLE
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  prefs: []
  type: TYPE_NORMAL
- en: 'firstNm[i] = input("First name for person No" + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'lastNm[i] = input("Last name for person No" + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: '#Sort lists lastNm and firstNm'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(PEOPLE - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PEOPLE - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if lastNm[n] < lastNm[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: lastNm[n], lastNm[n - 1] = lastNm[n - 1], lastNm[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif lastNm[n] == lastNm[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if firstNm[n] < firstNm[n - 1]:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: firstNm[n], firstNm[n - 1] = firstNm[n - 1], firstNm[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display lists lastNm and firstNm'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  prefs: []
  type: TYPE_NORMAL
- en: print(lastNm[i], "\t", firstNm[i])
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-5 Sorting a Two-Dimensional List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that sorts each column of a two-dimensional list in ascending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: An example of a two-dimension list is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-17.png)'
  prefs: []
  type: TYPE_IMG
- en: Since this list has seven columns, the bubble sort algorithm needs to be executed
    seven times, one for each column. Therefore, the whole bubble sort algorithm should
    be nested within a for-loop that iterates seven times.
  prefs: []
  type: TYPE_NORMAL
- en: But let's get things in the right order. Using the “from inner to outer” method,
    the next code fragment sorts only the first column (column index 0) of the two-dimensional
    list a. Assume variable j contains the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ROWS - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ROWS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n][j] < a[n - 1][j]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n][j], a[n - 1][j] = a[n - 1][j], a[n][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, in order to sort all columns, you can nest this code fragment in a for-loop
    that iterates for all of them, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ROWS - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ROWS - 1, m, -1):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if a[n][j] < a[n - 1][j]:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[n][j], a[n - 1][j] = a[n - 1][j], a[n][j]
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: That wasn't so difficult, was it?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-6 The Modified Bubble Sort Algorithm – Sorting One-Dimensional
    Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the weights of 20 people and
    then displays the three heaviest weights and the three lightest weights. Use the
    modified bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: To solve this exercise, the Python program can sort the user-provided data in
    ascending order and then display the elements at index positions 17, 18, and 19
    (for the three heaviest weights) and the elements at index positions 0, 1 and
    2 (for the three lightest weights). But what is that modified version of the bubble
    sort algorithm, and how does it actually work? Suppose you have the following
    list containing the weights of six people.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-18.png)'
  prefs: []
  type: TYPE_IMG
- en: If you look closer, you can confirm for yourself that the only elements not
    in the proper position are those at index positions 3 and 4\. If you swap their
    values, the list w immediately becomes sorted! Unfortunately, the bubble sort
    algorithm doesn't operate this way. For this given list of six elements, it will
    perform five passes either way, with a total of ![Image](img/chapter33-19.png)
    compares, where N is the total number of list elements. For larger lists, the
    total number of compares that the bubble sort algorithm performs increases exponentially!
    For example, for a given list of 1000 elements, the bubble sort algorithm performs
    499,500 compares!
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course the modified bubble sort algorithm can overcome this situation as
    follows: if a complete pass is performed and no swaps have been made, then this
    indicates that the list is now sorted and there is no need for further passes.
    To accomplish this, the Python program can use a flag variable that indicates
    if any swaps were made. At the beginning of a pass, a value of False can be assigned
    to the flag variable; when a swap is made, a value of True is assigned. If, at
    the end of the pass, the flag is still False, this indicates that no swaps have
    been made, thus iterations must stop. The modified bubble sort is shown next.
    It uses the break statement and the flag variable swaps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '#Assign False to variable swaps'
  prefs: []
  type: TYPE_NORMAL
- en: swaps = False
  prefs: []
  type: TYPE_NORMAL
- en: '#Perform a new pass'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if w[n] < w[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: w[n], w[n - 1] = w[n - 1], w[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: swaps = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#If variable swaps is still False, no swaps have been made in this pass. Stop
    iterations!'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not swaps: break'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The value False must be assigned to variable swaps each
    time a new pass starts. This is why the statement swaps = False must be placed
    between the two for statements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The statement if not swaps is equivalent to the statement
    if swaps == False'
  prefs: []
  type: TYPE_NORMAL
- en: The final Python program is shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-6'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: w = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: w[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: swaps = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ELEMENTS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if w[n] < w[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: w[n], w[n - 1] = w[n - 1], w[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: swaps = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not swaps: break'
  prefs: []
  type: TYPE_NORMAL
- en: print("The three heaviest weights are:")
  prefs: []
  type: TYPE_NORMAL
- en: print(w[-3], w[-2], w[-1])
  prefs: []
  type: TYPE_NORMAL
- en: print("The three lightest weights are:")
  prefs: []
  type: TYPE_NORMAL
- en: print(w[0], w[1], w[2])
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-7 The Selection Sort Algorithm – Sorting One-Dimensional Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that sorts the elements of a list in ascending order using
    the selection sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The selection sort algorithm is inefficient for large scale data, as is the
    bubble sort algorithm, but it generally performs better than the latter. It is
    the simplest of all the sorting algorithms and performs well on computer systems
    in which limited main memory (RAM) comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm finds the smallest (or largest, depending on sorting order) element
    of the list and swaps its content with that at position 0\. Then the process is
    repeated for the remainder of the list; the next smallest (or largest) element
    is found and put into the next position, until all elements are examined.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's try to sort the following list in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-20.png)'
  prefs: []
  type: TYPE_IMG
- en: The lowest value is the value 4, found at position 4\. According to the selection
    sort algorithm, this element swaps its content with the element at position 0\.
    The list A becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-21.png)'
  prefs: []
  type: TYPE_IMG
- en: The lowest value in the remainder of the list (index positions 1 to 5) is the
    value 9, found at position 5\. This element swaps its content with the element
    at position 1\. The list A becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-22.png)'
  prefs: []
  type: TYPE_IMG
- en: The lowest value in the remainder of the list (index positions 2 to 5) is the
    value 18, found at position 4\. This element swaps its content with the element
    at position 2\. The list A becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-23.png)'
  prefs: []
  type: TYPE_IMG
- en: Proceeding the same way, the next lowest value is the value 19, found at position
    5\. The list A becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-24.png)'
  prefs: []
  type: TYPE_IMG
- en: The next lowest value is the value 36, found at position 5\. This element swaps
    its content with the element at position 4 and the list A is finally sorted in
    ascending order!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-25.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's write the corresponding Python program. The “from inner to outer”
    method is used in order to help you better understand the whole process. The next
    code fragment finds the smallest element and then swaps its content with that
    at position 0\. Please note that this is the inner (nested) loop control structure.
    Assume variable m contains the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: minimum = a[m]
  prefs: []
  type: TYPE_NORMAL
- en: indexOfMin = m
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(m, ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = a[n]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexOfMin = n
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Minimum found! Now, swap values.'
  prefs: []
  type: TYPE_NORMAL
- en: a[m], a[indexOfMin] = a[indexOfMin], a[m]
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to repeat the process for all elements of the list, you can nest
    this code fragment within a for-loop that iterates for all elements. The final
    selection sort algorithm that sorts a list in ascending order is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: minimum = a[m]
  prefs: []
  type: TYPE_NORMAL
- en: indexOfMin = m
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(m, ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[n] < minimum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimum = a[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexOfMin = n
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[m], a[indexOfMin] = a[indexOfMin], a[m]
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you wish to sort a list in descending order, all you
    need to do is search for maximum instead of minimum values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)As in the bubble sort algorithm, in order to sort alphanumeric
    data with the selection sort algorithm, you can do one simple thing: leave the
    algorithm as is!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-8 Sorting One-Dimensional Lists While Preserving the Relationship
    with a Second List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the total number of kWh
    consumed each month for a period of one year. It then displays the three months
    with the highest consumption of kWh, along with the corresponding number of KWh
    (in descending order). Use the selection sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise you need the following two one-dimensional lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-26.png)'
  prefs: []
  type: TYPE_IMG
- en: While the selection sort algorithm sorts the elements of list kwh, the one-to-one
    correspondence with the elements of list months must be preserved. This means
    that every time two elements of list kwh swap contents, the corresponding elements
    of list months must swap their contents as well.
  prefs: []
  type: TYPE_NORMAL
- en: However, given that you solely require the three months with the highest consumption
    of KWh, the selection sort algorithm should sort only the first three elements.
    The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-8'
  prefs: []
  type: TYPE_NORMAL
- en: months = ["January", "February", "March", "April", "May", "June",
  prefs: []
  type: TYPE_NORMAL
- en: '"July", "August", "September", "October", "November", "December"]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: kwh = [None] * len(months)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(months)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'kwh[i] = float(input("Enter kWh for " + months[i] + ": "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(3):     #Sort only the first three elements'
  prefs: []
  type: TYPE_NORMAL
- en: maximum = kwh[m]
  prefs: []
  type: TYPE_NORMAL
- en: indexOfMax = m
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(m, len(months)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if kwh[n] > maximum:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: maximum = kwh[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexOfMax = n
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Swap values of kwh'
  prefs: []
  type: TYPE_NORMAL
- en: kwh[m], kwh[indexOfMax] = kwh[indexOfMax], kwh[m]
  prefs: []
  type: TYPE_NORMAL
- en: '#Swap values of months'
  prefs: []
  type: TYPE_NORMAL
- en: months[m], months[indexOfMax] = months[indexOfMax], months[m]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: print(months[i], ":", kwh[i])
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If this exercise required the use of the bubble sort instead
    of the selection sort algorithm, you could employ the same “trick”. The algorithm
    could perform 3 passes instead of ELEMENTS – 1 passes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-9 The Insertion Sort Algorithm – Sorting One-Dimensional Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that sorts the elements of a list in ascending order using
    the insertion sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The insertion sort algorithm is inefficient for large scale data, as are the
    selection and the bubble sort algorithms, but it generally performs better than
    either of them. Moreover, the insertion sort algorithm can prove very fast when
    sorting very small lists— sometimes even faster than the quicksort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The insertion sort algorithm resembles the way you might sort playing cards.
    You start with all the cards face down on the table. The cards on the table represent
    the unsorted “list”. In the beginning your left hand is empty, but in the end
    this hand will hold the sorted cards. The process goes as follows: you remove
    from the table one card at a time and insert it into the correct position in your
    left hand. To find the correct position for a card, you compare it with each of
    the cards already in your hand, from right to left. At the end, there must be
    no cards on the table and your left hand will hold all the cards, sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's try to sort the following list in ascending order. To better
    understand this example, assume that the sorting process has already begun and
    the first three elements of the list have been sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-27.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)The elements at index positions 0, 1, and 2 represent the
    cards in your left hand, while the remaining elements of the list represent the
    unsorted cards on the table.'
  prefs: []
  type: TYPE_NORMAL
- en: The element at position 3 (which is 8) is removed from the list and all elements
    on its left with a value greater than 8 are shifted to the right. The list A becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-28.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that a position has been released, the value 8 is inserted in there. The
    list becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-29.png)'
  prefs: []
  type: TYPE_IMG
- en: The element at position 4 (which is 10) is removed from the list and all elements
    on its left with a value greater than 10 are shifted to the right. The list A
    becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-30.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that a position has been released, the value of 10 is inserted in there.
    The list becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-31.png)'
  prefs: []
  type: TYPE_IMG
- en: The element at position 5 (which is 18) is removed from the list and all elements
    on its left with a value greater than 18 are shifted to the right. The list A
    becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-32.png)'
  prefs: []
  type: TYPE_IMG
- en: The value of 18 is inserted in the released position. The list becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-33.png)'
  prefs: []
  type: TYPE_IMG
- en: The element at position 6 (which is 9) is removed from the list and all elements
    on its left with a value greater than 9 are shifted to the right. The list A becomes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-34.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the value of 9 is inserted in the released position, the algorithm
    finishes and the list is now sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-35.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)What the algorithm actually does is to check the unsorted
    elements one by one and insert each one in the appropriate position among those
    considered already sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: The code fragment that sorts a list in ascending order using the insertion sort
    algorithm is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: '#"Remove" the element at index position m from the list and keep it in variable
    element'
  prefs: []
  type: TYPE_NORMAL
- en: element = a[m]
  prefs: []
  type: TYPE_NORMAL
- en: '#Shift appropriate elements to the right'
  prefs: []
  type: TYPE_NORMAL
- en: n = m
  prefs: []
  type: TYPE_NORMAL
- en: 'while n > 0 and a[n - 1] > element:'
  prefs: []
  type: TYPE_NORMAL
- en: a[n] = a[n - 1]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Insert the previously "removed" element at index position n'
  prefs: []
  type: TYPE_NORMAL
- en: a[n] = element
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Please note that the element at index position m is not
    actually removed from the list but is in fact overwritten when shifting to the
    right is performed. This is why its value is kept in variable element before shifting
    the elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you wish to sort a list in descending order, all you
    need to do is alter the Boolean expression of the while statement to n > 0 and
    a[n − 1] < element.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)As in the previous two sorting algorithms, in order to
    sort alphanumeric data, you don''t have to change anything in this algorithm!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.4-10 The Three Worst Elapsed Times
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ten race car drivers run their cars as fast as possible on a racing track. Each
    car runs 20 laps and for each lap the corresponding elapsed time (in seconds)
    is recorded. Write a Python program that prompts the user to enter the name of
    each driver and their elapsed time for each lap. The program must then display
    the name of each driver along with their three worst elapsed times. Use the insertion
    sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following two lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-36.png)'
  prefs: []
  type: TYPE_IMG
- en: After the user enters all data, the Python program must sort each row of the
    list in descending order but, in the end, must display only the first three columns.
  prefs: []
  type: TYPE_NORMAL
- en: Using the “from inner to outer” method, the next code fragment sorts only the
    first row (row index 0) of the two-dimensional list elapsedTimes in descending
    order using the insertion sort algorithm. Assume variable i contains the value
    0.
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, LAPS):'
  prefs: []
  type: TYPE_NORMAL
- en: element = elapsedTimes[i][m]
  prefs: []
  type: TYPE_NORMAL
- en: n = m
  prefs: []
  type: TYPE_NORMAL
- en: 'while n > 0 and elapsedTimes[i][n - 1] < element:'
  prefs: []
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = elapsedTimes[i][n - 1]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = element
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to sort all rows, you need to nest this code fragment in a for-loop
    that iterates for all of them, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CARS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, LAPS):'
  prefs: []
  type: TYPE_NORMAL
- en: element = elapsedTimes[i][m]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n = m
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while n > 0 and elapsedTimes[i][n - 1] < element:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = elapsedTimes[i][n - 1]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = element
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And now, let's focus on the given exercise. The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.4-10'
  prefs: []
  type: TYPE_NORMAL
- en: CARS = 10
  prefs: []
  type: TYPE_NORMAL
- en: LAPS = 20
  prefs: []
  type: TYPE_NORMAL
- en: '#Read names and elapsed times all together'
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * CARS
  prefs: []
  type: TYPE_NORMAL
- en: elapsedTimes = [[None] * LAPS for i in range(CARS)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CARS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for driver No." + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(LAPS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'elapsedTimes[i][j] = float(input("Enter elapsed time for lap No" + str(j +
    1) + ": "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Sort list elapsedTimes'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CARS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(1, LAPS):'
  prefs: []
  type: TYPE_NORMAL
- en: element = elapsedTimes[i][m]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n = m
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while n > 0 and elapsedTimes[i][n - 1] < element:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = elapsedTimes[i][n - 1]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: n -= 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: elapsedTimes[i][n] = element
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display 3 worst elapsed times'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CARS):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Worst elapsed times of", names[i])
  prefs: []
  type: TYPE_NORMAL
- en: print("-------------------------------------")
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: print(elapsedTimes[i][j])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 33.5 Searching Elements in Data Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In computer science, a search algorithm is an algorithm that searches for an
    item with specific features within a set of data. In the case of a data structure,
    a search algorithm searches the data structure to find the element, or elements,
    that equal a given value.
  prefs: []
  type: TYPE_NORMAL
- en: When searching in a data structure, there can be two situations.
  prefs: []
  type: TYPE_NORMAL
- en: ►You want to search for a given value in a data structure that may contain the
    same value multiple times. Therefore, you need to find all the elements (or their
    corresponding indexes) that are equal to that given value.
  prefs: []
  type: TYPE_NORMAL
- en: ►You want to search for a given value in a data structure where each value is
    unique. Therefore, you need to find just one element (or its corresponding index),
    the one that is equal to that given value, and then stop searching any further!
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used search algorithms are:'
  prefs: []
  type: TYPE_NORMAL
- en: ►the linear (or sequential) search algorithm
  prefs: []
  type: TYPE_NORMAL
- en: ►the binary search algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Both linear and binary search algorithms have advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-1 The Linear Search Algorithm – Searching in a One-Dimensional
    List that may Contain the Same Value Multiple Times
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that performs a search on a one-dimensional list to find
    a user-provided value. Assume that the list contains numerical values and may
    contain the same value multiple times. Use the linear search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The linear (or sequential) search algorithm checks if the first element of the
    list is equal to a given value, then checks the second element, then the third,
    and so on until the end of the list. Since this process of checking elements one
    by one is quite slow, the linear search algorithm is suitable for lists with few
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: The code fragment is shown next. It looks for the user-provided value needle
    in the list haystack!
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] == needle:'
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-2 Display the Last Names of All Those People Who Have the Same
    First Name
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write a Python program that prompts the user to enter the names of 20 people:
    their first names into the list firstNames, and their last names into the list
    lastNames. The program must then ask the user for a first name, upon which it
    will search and display the last names of all those whose first name equals the
    provided one.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Even though it is not clear in the wording of the exercise, it is true that
    the list firstNames may contain a value multiple times. How rare is it to meet
    two people named “John”, for example?
  prefs: []
  type: TYPE_NORMAL
- en: The program must search for the user-provided first name in list firstNames
    and every time it finds it, it must display the corresponding last name from the
    other list.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-2'
  prefs: []
  type: TYPE_NORMAL
- en: PEOPLE = 20
  prefs: []
  type: TYPE_NORMAL
- en: firstNames = [None] * PEOPLE
  prefs: []
  type: TYPE_NORMAL
- en: lastNames = [None] * PEOPLE
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  prefs: []
  type: TYPE_NORMAL
- en: 'firstNames[i] = input("Enter first name: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'lastNames[i] = input("Enter last name: ")'
  prefs: []
  type: TYPE_NORMAL
- en: '#Get name to search and convert it to uppercase'
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = input("Enter a first name to search: ").upper()'
  prefs: []
  type: TYPE_NORMAL
- en: '#Search for user-provided value in list firstNames'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if firstNames[i].upper() == needle:   #Convert to uppercase and compare'
  prefs: []
  type: TYPE_NORMAL
- en: print(lastNames[i])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No one found!")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Since the program deals with alphanumeric data, the upper()
    method is required so that the program can operate correctly for any user-provided
    value. For example, if the value “John” exists in the list firstNames and the
    user wants to search for the value “JOHN”, the upper() method ensures that the
    program finds all Johns.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-3 The Linear Search Algorithm – Searching in a Two-Dimensional
    List that May Contain the Same Value Multiple Times
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that performs a search on each row of a two-dimensional
    list to find a user-provided value. Assume that the list contains numerical values
    and may contain the same value multiple times. Use the linear search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: This code fragment must search for the user-provided number in each row of a
    two-dimensional list that may contain the same value multiple times. This means
    that the code fragment must search in the first row and display all the columns
    where the user-provided number is found; otherwise, it must display a message
    that the user-provided number was not found in the first row. Then, it must search
    in the second row, and this process must continue until all rows have been examined.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this exercise, the “inner to outer” method is used. The
    following code fragment searches for a given value (variable needle) only in the
    first row of the two-dimensional list named haystack. Assume variable i contains
    the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Found at column", j)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found in row", i)
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to search in all rows, you need to nest this code fragment in
    a for-loop that iterates for all of them, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Found at column", j)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found in row", i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.5-4 The Linear Search Algorithm – Searching in a One-Dimensional
    List that Contains Unique Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that performs a search on a one-dimensional list to find
    a user-provided value. Assume that the list contains numerical values and each
    value in the list is unique. Use the linear search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: This case is quite different from the previous ones. Since each value in the
    list is unique, when the user-provided value is found, there is no need to iterate
    without reason until the end of the list, thus wasting CPU time. There are three
    approaches, actually! Let's analyze them all!
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Using the break statement
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, when the user-provided value is found, a break statement is
    used to break out of the for-loop. The solution is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] == needle:'
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  prefs: []
  type: TYPE_NORMAL
- en: Or you can do the same, in a little bit different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  prefs: []
  type: TYPE_NORMAL
- en: indexPosition = -1
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] == needle:'
  prefs: []
  type: TYPE_NORMAL
- en: indexPosition = i
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if indexPosition == -1:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", indexPosition)
  prefs: []
  type: TYPE_NORMAL
- en: Second approach – Using a flag
  prefs: []
  type: TYPE_NORMAL
- en: The break statement doesn't actually exist in all computer languages; and since
    this book's intent is to teach you “Algorithmic Thinking” (and not just special
    statements that only Python supports), let's look at an alternate approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the next code fragment, when the user-provided value is found within list
    haystack, the variable found forces the flow of execution to immediately exit
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < ELEMENTS and not found:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] == needle:'
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: indexPosition = i
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", indexPosition)
  prefs: []
  type: TYPE_NORMAL
- en: Third approach – Using only a pre-test loop structure
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is likely the most efficient among the three. The while-loop
    iterates through the list, comparing each element with the needle. The loop continues
    as long as two conditions are met: variable i (representing the index) is within
    the valid range for the list haystack, and the value at the current index in the
    list is not equal to the needle. If both conditions are True, variable i is incremented
    to move to the next element. This process continues until a match is found or
    until the end of the list is reached.'
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < ELEMENTS - 1 and haystack[i] != needle:'
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i] != needle:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", i)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-5 Searching for a Social Security Number
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the United States, the Social Security Number (SSN) is a nine-digit identity
    number applied to all U.S. citizens in order to identify them for the purposes
    of Social Security. Write a Python program that prompts the user to enter the
    SSN and the first and last names of 100 people. The program must then ask the
    user for an SSN, upon which it will search and display the first and last name
    of the person who holds that SSN.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In the United States, there is no possibility that two or more people will have
    the same SSN. Thus, even though it is not clear in the wording of the exercise,
    each value in the list that holds the SSNs is unique!
  prefs: []
  type: TYPE_NORMAL
- en: According to everything you have learned so far, the solution to this exercise
    is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-5'
  prefs: []
  type: TYPE_NORMAL
- en: PEOPLE = 100
  prefs: []
  type: TYPE_NORMAL
- en: SSNs = [None] * PEOPLE
  prefs: []
  type: TYPE_NORMAL
- en: firstNames = [None] * PEOPLE
  prefs: []
  type: TYPE_NORMAL
- en: lastNames = [None] * PEOPLE
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(PEOPLE):'
  prefs: []
  type: TYPE_NORMAL
- en: 'SSNs[i] = input("Enter SSN: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'firstNames[i] = input("Enter first name: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'lastNames[i] = input("Enter last name: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'needle = input("Enter an SSN to search: ")'
  prefs: []
  type: TYPE_NORMAL
- en: '#Search for user-provided value in list SSNs'
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < PEOPLE - 1 and SSNs[i] != needle:'
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if SSNs[i] != needle:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(firstNames[i], lastNames[i])
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-6 The Linear Search Algorithm – Searching in a Two-Dimensional
    List that Contains Unique Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A public opinion polling company makes phone calls in 10 cities and asks 30
    citizens in each city whether or not they exercise. Write a Python program that
    prompts the user to enter each citizen's phone number and their answer (Y for
    Yes, N for No, S for Sometimes). The program must then prompt the user to enter
    a phone number, and it will search and display the answer that was provided at
    this phone number. The program must also validate data input and accept only the
    values Y, N, or S as an answer.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following two lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-37.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though it is not clear in the wording of the exercise, each value in the
    list phoneNum is unique! The program must search for the user-provided number
    and if it finds it, it must stop searching thereafter. The solution is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-6'
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  prefs: []
  type: TYPE_NORMAL
- en: CITIZENS = 30
  prefs: []
  type: TYPE_NORMAL
- en: phoneNum = [[None] * CITIZENS for i in range(CITIES)]
  prefs: []
  type: TYPE_NORMAL
- en: ans = [[None] * CITIZENS for i in range(CITIES)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: print("City No.", i + 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(CITIZENS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'phoneNum[i][j] = input("Enter phone number of citizen No." + str(j + 1) + ":
    ")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'ans[i][j] = input("Enter the answer of citizen No." + str(j + 1) + ": ").upper()'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'while ans[i][j] not in ["Y", "N", "S"]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'ans[i][j] = input("Wrong answer. Enter a valid one: ").upper()'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'needle = input("Enter a phone number to search: ")'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(CITIZENS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if phoneNum[i][j] == needle: #If it is found'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: positionI = i  #Keep row index where needle was found
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: positionJ = j  #Keep column index where needle was found
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break  #Exit the inner loop
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: 'break   #If it is found, exit the outer loop as well'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Phone number not found!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Phone number", phoneNum[positionI][positionJ], "gave '", end = "")
  prefs: []
  type: TYPE_NORMAL
- en: 'if ans[positionI][positionJ] == "Y":'
  prefs: []
  type: TYPE_NORMAL
- en: print("Yes", end = "")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif ans[positionI][positionJ] == "N":'
  prefs: []
  type: TYPE_NORMAL
- en: print("No", end = "")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Sometimes", end = "")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("' as an answer")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-7 Checking if a Value Exists in all Columns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter numeric values into a 20 × 30
    list. After all of the values have been entered, the program then lets the user
    enter a value. In the end, a message must be displayed if the user-provided value
    exists, at least once, in each column of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: This exercise can be solved using the linear search algorithm and a counter
    variable count. The Python program will iterate through the first column; if the
    user-provided value is found, the Python program must stop searching in the first
    column thereafter, and the variable count must increment by one. Then, the program
    will iterate through the second column; if the user-provided value is found again,
    the Python program must stop searching in the second column thereafter, and the
    variable count must once more increment by one. This process must repeat until
    all columns have been examined. At the end of the process, if the value of count
    is equal to the total number of columns, this means that the user-provided value
    exists, at least once, in each column of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the “from inner to outer” method. The following code fragment searches
    in first column (column index 0) of the list and if the user-provided value is
    found, the flow of execution exits the for-loop and variable count increments
    by one. Assume variable j contains the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: Now you can nest this code fragment in a for-loop that iterates for all columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You are almost ready—but consider a small detail! If the inner for-loop doesn't
    find the user-provided value in a column, the outer for-loop must stop iterating.
    It is pointless to continue because the user-provided value does not exist in
    at least one column. Thus, a better approach would be to use a break statement
    for the outer loop as shown in the code fragment that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-7'
  prefs: []
  type: TYPE_NORMAL
- en: ROWS = 20
  prefs: []
  type: TYPE_NORMAL
- en: COLUMNS = 30
  prefs: []
  type: TYPE_NORMAL
- en: haystack = [[None] * COLUMNS for i in range(ROWS)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: haystack[i][j] = float(input())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'needle = float(input("Enter a value to search: "))'
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COLUMNS):'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if haystack[i][j] == needle:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if count == COLUMNS:'
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found in every column!")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you need a message to be displayed when a user-provided
    value exists at least once in each row (rather than in each column), the Python
    program can follow a procedure like the one previously shown but in this case,
    it must iterate through the rows instead of the columns.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-8 The Binary Search Algorithm – Searching in a Sorted One-Dimensional
    List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a code fragment that performs a search on a sorted one-dimensional list
    to find a given value. Use the binary search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The binary search algorithm is considered very fast and can be used with large
    scale data. Its main disadvantage, though, is that the data need to be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea of the binary search algorithm is to first examine the element
    in the middle of the list. If it does not match the “needle in the haystack” that
    you are looking for, the algorithm determines whether the target is smaller or
    larger than the middle element. This guides the search to the corresponding half
    of the list. In other words, if the “needle” you are looking for is smaller than
    the value of the middle element, it means that the “needle” might be in the first
    half of the list; otherwise it might be in the last half of the list. The process
    continues, narrowing down the search by checking the middle element in the remaining
    half of the list until the "needle" is found or the portion of the list being
    examined is reduced to a single element. If the latter occurs without finding
    the "needle," it means the “needle” is not present in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Confused? Let's try to analyze the binary search algorithm through an example.
    The following list contains numeric values in ascending order. Assume that the
    “needle” that you are looking for is the value 44.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-38.png)'
  prefs: []
  type: TYPE_IMG
- en: Three variables are used. Initially, variable left contains the value 0 (this
    is the index of the first element), variable right contains the value 13 (this
    is the index of the last element) and variable middle contains the value 6 (this
    is approximately the index of the middle element).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-39.png)'
  prefs: []
  type: TYPE_IMG
- en: The “needle” (value 44) that you are looking for is larger than the value of
    39 in the middle, thus the element that you are looking for might be in the last
    half of the list. Therefore, variable left is updated to point to index position
    7 and variable middle is updated to a point in the middle between left (the new
    one) and right, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-40.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the “needle” (value 44) that you are looking for is smaller than the value
    of 57 in the middle, thus the element that you are looking for might be in the
    first half of the portion of the list being examined. Therefore, it is the variable
    right that is now updated to point to index position 9, and variable middle is
    updated to point to the middle between left and right (the new one), as shown
    below002E
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-41.png)'
  prefs: []
  type: TYPE_IMG
- en: You are done! The “needle” has been found at index position 8 and the whole
    process can stop!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Each unsuccessful comparison reduces the number of elements
    left to check by half!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The index variables left and right each time point to the
    beginning and end, respectively, of the portion of the list being examined.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see the corresponding code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: left = 0
  prefs: []
  type: TYPE_NORMAL
- en: right = ELEMENTS - 1
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'while left <= right and not found:'
  prefs: []
  type: TYPE_NORMAL
- en: 'middle = (left + right) // 2   #This is a DIV 2 operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'if needle < haystack[middle]:  #If the needle is in the first half of the portion'
  prefs: []
  type: TYPE_NORMAL
- en: 'right = middle – 1         #of the list being examined, update the right index'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > haystack[middle]:  #If it is in the second half,'
  prefs: []
  type: TYPE_NORMAL
- en: left = middle + 1            #update the left index
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Nothing found!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(needle, "found at position:", middle)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The binary search algorithm is very efficient because it
    drastically reduces the search space with each iteration, making it highly effective
    for sorted lists. Using this algorithm on the example list, the value of 44 can
    be found within just three iterations. In contrast, the linear search algorithm
    would require nine iterations for the same data!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If the list contains a value multiple times, the binary
    search algorithm can find only one occurrence.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.5-9 Display all the Historical Events for a Country
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names of 10 countries
    in alphabetical order and 20 important historical events for each country (a brief
    description of each event). The Python program must then prompt the user to enter
    a country, and it will search and display all events for that country. Use the
    binary search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, the following two lists are required.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-42.png)'
  prefs: []
  type: TYPE_IMG
- en: Assume that the user enters a country to search for, and the binary search algorithm
    finds that country, for example, at index position 2 of list countryNames. The
    program can then use this value of 2 as a column index for the list eventDescriptions,
    and display all the event descriptions of column 2.
  prefs: []
  type: TYPE_NORMAL
- en: The Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-9'
  prefs: []
  type: TYPE_NORMAL
- en: EVENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: COUNTRIES = 10
  prefs: []
  type: TYPE_NORMAL
- en: countryNames = [None] * COUNTRIES
  prefs: []
  type: TYPE_NORMAL
- en: eventDescriptions = [[None] * COUNTRIES for i in range(EVENTS)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COUNTRIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'countryNames[j] = input("Enter Country No" + str(j + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(EVENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'eventDescriptions[i][j] = input("Enter description for event No" + str(i +
    1) + ": ")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'needle = input("Enter a country to search: ").upper()'
  prefs: []
  type: TYPE_NORMAL
- en: '#Country names are entered in alphabetical order.'
  prefs: []
  type: TYPE_NORMAL
- en: '#Use the binary search algorithm to search for needle.'
  prefs: []
  type: TYPE_NORMAL
- en: left = 0
  prefs: []
  type: TYPE_NORMAL
- en: right = EVENTS - 1
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'while left <= right and not found:'
  prefs: []
  type: TYPE_NORMAL
- en: middle = (left + right) // 2
  prefs: []
  type: TYPE_NORMAL
- en: 'if needle < countryNames[middle].upper():'
  prefs: []
  type: TYPE_NORMAL
- en: right = middle - 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > countryNames[middle].upper():'
  prefs: []
  type: TYPE_NORMAL
- en: left = middle + 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No country found!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(EVENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(eventDescriptions[i][middle])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.5-10 Searching in Each Column of a Two-Dimensional List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names of 10 countries
    and 20 important historical events for each country (a brief description of each
    event), and the corresponding year of each event. The Python program must then
    prompt the user to enter a year, and it will search and display all events that
    happened that year for each country. Use the binary search algorithm. Assume that
    for each country there is only one event in each year and that the user enters
    the events ordered by year in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, the following three lists are required.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-43.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to write the code fragment that performs a search on each column of
    the list eventYears, let's use the “from inner to outer” method. The next binary
    search algorithm searches in the first column (column index 0) for a user-provided
    year. Assume variable j contains the value 0\. Since the search is performed vertically,
    and in order to increase program's readability, the variables left and right of
    the binary search algorithm have been renamed to top and bottom respectively.
  prefs: []
  type: TYPE_NORMAL
- en: top = 0
  prefs: []
  type: TYPE_NORMAL
- en: bottom = EVENTS - 1
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'while top <= bottom and not found:'
  prefs: []
  type: TYPE_NORMAL
- en: middle = (top + bottom) // 2
  prefs: []
  type: TYPE_NORMAL
- en: 'if needle < eventYears[middle][j]:'
  prefs: []
  type: TYPE_NORMAL
- en: bottom = middle - 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > eventYears[middle][j]:'
  prefs: []
  type: TYPE_NORMAL
- en: top = middle + 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No event found for country", countryNames[j])
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Country:", countryNames[j])
  prefs: []
  type: TYPE_NORMAL
- en: print("Year:", eventYears[middle][j])
  prefs: []
  type: TYPE_NORMAL
- en: print("Event:", eventDescriptions[middle][j])
  prefs: []
  type: TYPE_NORMAL
- en: Now, nesting this code fragment in a for-loop that iterates for all columns
    results in the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COUNTRIES):'
  prefs: []
  type: TYPE_NORMAL
- en: top = 0
  prefs: []
  type: TYPE_NORMAL
- en: bottom = EVENTS - 1
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'while top <= bottom and not found:'
  prefs: []
  type: TYPE_NORMAL
- en: middle = (top + bottom) // 2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if needle < eventYears[middle][j]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bottom = middle - 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > eventYears[middle][j]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: top = middle + 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No event found for country", countryNames[j])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Country:", countryNames[j])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Year:", eventYears[middle][j])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Event:", eventDescriptions[middle][j])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.5-10'
  prefs: []
  type: TYPE_NORMAL
- en: EVENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: COUNTRIES = 10
  prefs: []
  type: TYPE_NORMAL
- en: countryNames = [None] * COUNTRIES
  prefs: []
  type: TYPE_NORMAL
- en: eventDescriptions = [[None] * COUNTRIES for i in range(EVENTS)]
  prefs: []
  type: TYPE_NORMAL
- en: eventYears = [[None] * COUNTRIES for i in range(EVENTS)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COUNTRIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'countryNames[j] = input("Enter Country No." + str(j + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(EVENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'eventDescriptions[i][j] = input("Enter description for event No" + str(i +
    1) + ": ")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'eventYears[i][j] = int(input("Enter year for event No" + str(i + 1) + ": "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'needle = int(input("Enter a year to search: "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(COUNTRIES):'
  prefs: []
  type: TYPE_NORMAL
- en: top = 0
  prefs: []
  type: TYPE_NORMAL
- en: bottom = EVENTS - 1
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'while top <= bottom and not found:'
  prefs: []
  type: TYPE_NORMAL
- en: middle = (top + bottom) // 2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if needle < eventYears[middle][j]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bottom = middle - 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif needle > eventYears[middle][j]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: top = middle + 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if not found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("No event found for country", countryNames[j])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Country:", countryNames[j])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Year:", eventYears[middle][j])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: print("Event:", eventDescriptions[middle][j])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 33.6 Exercises of a General Nature with Data Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exercise 33.6-1 On Which Days was There a Possibility of Snow?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the temperatures (in degrees
    Fahrenheit) recorded at the same hour each day for the 31 days of January. The
    Python program must then display the numbers of those days (1, 2, ..., 31) on
    which there was a possibility of snow, that is, those on which temperatures were
    below 36 degrees Fahrenheit (about 2 degrees Celsius).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The one-dimensional list for this exercise is shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-44.png)'
  prefs: []
  type: TYPE_IMG
- en: and the Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-1'
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  prefs: []
  type: TYPE_NORMAL
- en: t = [None] * DAYS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: t[i] = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i] < 36:'
  prefs: []
  type: TYPE_NORMAL
- en: print(i + 1, end = "\t")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.6-2 Was There Any Possibility of Snow?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter the temperatures (in degrees
    Fahrenheit) recorded at the same hour each day for the 31 days of January. The
    Python program must then display a message indicating if there was a possibility
    of snow, that is, if there were any temperatures below 36 degrees Fahrenheit (about
    2 degrees Celsius).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you cannot replicate the approach used in the previous exercise.
    The code fragment that follows would be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i] < 36:'
  prefs: []
  type: TYPE_NORMAL
- en: print("There was a possibility of snow in January!")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If January had more than one day with a temperature below 36 degrees Fahrenheit,
    the same message would be displayed multiple times—and obviously you do not want
    this! You actually want to display a message once, regardless of whether January
    had one, two, or even more days below 36 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: There are two approaches, actually. Let's study them both.
  prefs: []
  type: TYPE_NORMAL
- en: First approach – Counting all temperatures below 36 degrees Fahrenheit
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, you can use a variable in the program to count all the days
    on which the temperature was below 36 degrees Fahrenheit. After all of the days
    have been examined, the program can check the value of this variable. If the value
    is not zero, it means that there was at least one day where there was a possibility
    of snow.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-2a'
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  prefs: []
  type: TYPE_NORMAL
- en: t = [None] * DAYS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: t[i] = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i] < 36:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if count != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("There was a possibility of snow in January!")
  prefs: []
  type: TYPE_NORMAL
- en: Second approach – Using a flag
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, instead of counting all those days that had a temperature
    below 36 degrees Fahrenheit, you can use a Boolean variable (a flag). The solution
    is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-2b'
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  prefs: []
  type: TYPE_NORMAL
- en: t = [None] * DAYS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: t[i] = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i] < 36:'
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: print("There was a possibility of snow in January!")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Imagine the variable found as if it''s a real flag. Initially,
    the flag is not hoisted (found = False). Within the for-loop, however, when a
    temperature below 36 degrees Fahrenheit is found, the flag is hoisted (the value
    True is assigned to the variable found) and it is never lowered again.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note the break statement! Once a temperature below 36 degrees
    Fahrenheit is found, it is meaningless to continue checking thereafter.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If the loop performs all of its iterations and no temperature
    below 36 degrees Fahrenheit is found, the variable found will still contain its
    initial value (False) since the flow of execution never entered the decision control
    structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.6-3 In Which Cities was There a Possibility of Snow?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names of ten cities
    and their temperatures (in degrees Fahrenheit) recorded at the same hour each
    day for the 31 days of January. The Python program must display the names of the
    cities in which there was a possibility of snow, that is, those in which temperatures
    were below 36 degrees Fahrenheit (about 2 degrees Celsius).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous exercise, you need to display each city name once, regardless
    of whether it had one, two, or even more days below 36 degrees Fahrenheit. There
    are two approaches. In the first approach, the auxiliary list count, as presented
    below, is created by the program to count the total number of days on which each
    city had temperatures lower than 36 degrees Fahrenheit. The second approach, however,
    doesn't create the auxiliary list count. It uses just one extra Boolean variable
    (a flag). Obviously the second one is more efficient. But let's study both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-45.png)'
  prefs: []
  type: TYPE_IMG
- en: First approach – Using an auxiliary list
  prefs: []
  type: TYPE_NORMAL
- en: You were taught in [Section 32.2](chapter32.html#toc_2) how to process each
    row individually. The nested loop control structure that can create the auxiliary
    list count is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: count = [None] * CITIES
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: count[i] = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: count[i] += 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: After list count is created you can iterate through it, and when an element
    contains a value other than zero, it means that the corresponding city had at
    least one day below 36 degrees Fahrenheit; thus the program must display the name
    of that city. The final Python program is presented next
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-3a'
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * CITIES
  prefs: []
  type: TYPE_NORMAL
- en: t = [[None] * DAYS for i in range(CITIES)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter a name for city No:" + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 't[i][j] = int(input("Enter a temperature for day No: " + str(j + 1) + ": "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Create auxiliary list count'
  prefs: []
  type: TYPE_NORMAL
- en: count = [None] * CITIES
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: count[i] = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: count[i] += 1
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("Cities in which there was a possibility of snow in January: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if count[i] != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Second approach – Using a flag
  prefs: []
  type: TYPE_NORMAL
- en: This approach does not use an auxiliary list. It processes list t and directly
    displays any city name that had a temperature below 36 degrees Fahrenheit. But
    how can this be done without displaying a city name twice, or even more than twice?
    This is where you need a flag, that is, an extra Boolean variable.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this approach, let's use the “from inner to outer” method.
    The following code fragment checks if the first row of list t (row index 0) contains
    at least one temperature below 36 degrees Fahrenheit; if so, it displays the corresponding
    city name that exists at position 0 of the list names. Assume variable i contains
    the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  prefs: []
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything has been clarified, in order to process the whole list t,
    you can just nest this code fragment in a for-loop that iterates for all cities,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-3b'
  prefs: []
  type: TYPE_NORMAL
- en: CITIES = 10
  prefs: []
  type: TYPE_NORMAL
- en: DAYS = 31
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * CITIES
  prefs: []
  type: TYPE_NORMAL
- en: t = [[None] * DAYS for i in range(CITIES)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter a name for city No:" + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 't[i][j] = int(input("Enter a temperature for day No:" + str(j + 1) + ": "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'print("Cities in which there was a possibility of snow in January: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(CITIES):'
  prefs: []
  type: TYPE_NORMAL
- en: found = False
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(DAYS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if t[i][j] < 36:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: found = True
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if found:'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.6-4 Display from Highest to Lowest Grades by Student, and in Alphabetical
    Order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are 10 students and each one of them has received their grades for five
    lessons. Write a Python program that prompts a teacher to enter the name of each
    student and their grades for all lessons. The program must then calculate each
    student's average grade, and display the names and the average grades of the students
    sorted by their average grade in descending order. Moreover, if two or more students
    have the same average grade, their names must be displayed in alphabetical order.
    Use the bubble sort algorithm, adapted accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following three lists. The values for the lists
    names and grades will be entered by the user, whereas the auxiliary list average
    will be created by the Python program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-46.png)'
  prefs: []
  type: TYPE_IMG
- en: You're already familiar with all the steps in this exercise. You can create
    the auxiliary list average (see [Section 32.2](chapter32.html#toc_2)), sort it
    while maintaining the one-to-one correspondence with the elements in the list
    names (as shown in [Exercise 33.4-3](#toc_20)), and handle the scenario where,
    if two average grades are equal, the corresponding student names should be sorted
    alphabetically (as demonstrated in [Exercise 33.4-4](#toc_21)). Here's the final
    Python program.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-4'
  prefs: []
  type: TYPE_NORMAL
- en: STUDENTS = 10
  prefs: []
  type: TYPE_NORMAL
- en: LESSONS = 5
  prefs: []
  type: TYPE_NORMAL
- en: '#Read list names and grades'
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * STUDENTS
  prefs: []
  type: TYPE_NORMAL
- en: grades = [[None] * LESSONS for i in range(STUDENTS)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for student No." + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(LESSONS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'grades[i][j] = int(input("Enter grade for lesson No." + str(j + 1) + ": "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Create list average'
  prefs: []
  type: TYPE_NORMAL
- en: average = [None] * STUDENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: average[i] = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(LESSONS):'
  prefs: []
  type: TYPE_NORMAL
- en: average[i] += grades[i][j]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: average[i] /= LESSONS
  prefs: []
  type: TYPE_NORMAL
- en: '#Sort lists average and names'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(STUDENTS - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(STUDENTS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if average[n] > average[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: average[n], average[n - 1] = average[n - 1], average[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'elif average[n] == average[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if names[n] < names[n - 1]:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display lists names and average'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(STUDENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i], "\t", average[i])
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.6-5 Archery at the Summer Olympics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In archery at the Summer Olympics, 20 athletes each shoot six arrows. Write
    a Python program that prompts the user to enter the name of each athlete, and
    the points awarded for each shot. The program must then display the names of the
    three athletes that won the gold, silver, and bronze medals depending on which
    athlete obtained the highest sum of points. Assume that no two athletes have an
    equal sum of points.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need the following three lists. The values for the lists
    names and points will be entered by the user, whereas the auxiliary list total
    will be created by the Python program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-47.png)'
  prefs: []
  type: TYPE_IMG
- en: After the auxiliary list total is created, a sorting algorithm can sort the
    list total in descending order (while preserving the one-to-one correspondence
    with the elements of the list names). The Python program can then display the
    names of the three athletes at index positions 0, 1, and 2 (since these are the
    athletes that should win the gold, the silver, and the bronze medals, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: The following program uses the bubble sort algorithm to sort the list total.
    Since the algorithm must sort in descending order, bigger elements must gradually
    “bubble” to positions of lowest index, like bubbles rise in a glass of cola. However,
    instead of performing 19 passes (there are 20 athletes), given that only the three
    best athletes must be found, the algorithm can perform just 3 passes. Doing this,
    only the first three bigger elements will gradually “bubble” to the first three
    positions in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-5'
  prefs: []
  type: TYPE_NORMAL
- en: from math import fsum
  prefs: []
  type: TYPE_NORMAL
- en: ATHLETES = 20
  prefs: []
  type: TYPE_NORMAL
- en: SHOTS = 6
  prefs: []
  type: TYPE_NORMAL
- en: '#Read list names and points'
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * ATHLETES
  prefs: []
  type: TYPE_NORMAL
- en: points = [[None] * SHOTS for i in range(ATHLETES)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ATHLETES):'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name for athlete No." + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(SHOTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'points[i][j] = int(input("Enter points for shot No." + str(j + 1) + ": "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Create list total'
  prefs: []
  type: TYPE_NORMAL
- en: total = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for row in points:'
  prefs: []
  type: TYPE_NORMAL
- en: total.append(fsum(row))
  prefs: []
  type: TYPE_NORMAL
- en: '#Sort lists names and total. Perform only 3 passes'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(ATHLETES - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if total[n] > total[n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: total[n], total[n - 1] = total[n - 1], total[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: names[n], names[n - 1] = names[n - 1], names[n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display gold, silver and bronze metal'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i], "\t", total[i])
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 33.6-6 The Five Best Scorers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter the names of the 32 national
    teams of the FIFA World Cup, the names of the 24 players for each team, and the
    total number of goals each player scored. The program must then display the name
    of each team along with its five best scorers. Use the bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise you need the following three lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-48.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)To save paper short list names are used, but it is more
    or less obvious that list t holds the names of the 32 national teams, list p holds
    the names of the 24 players of each team, and list g holds the total number of
    goals each player scored.'
  prefs: []
  type: TYPE_NORMAL
- en: The Python program must sort each row of list g in descending order but it must
    also take care to preserve the one-to-one correspondence with the elements of
    list p. This means that, every time the bubble sort algorithm swaps the contents
    of two elements of list g, the corresponding elements of list p must be swapped
    as well. However, instead of performing 23 passes (there are 24 players), given
    that only the five best scorers must be found, the algorithm can perform just
    5 passes. When sorting is completed, the five best scorers should appear in the
    first five columns.
  prefs: []
  type: TYPE_NORMAL
- en: The “from inner to outer” method is used again. The following code fragment
    sorts the first row (row index 0) of list g in descending order and, at the same
    time, takes care to preserve the one-to-one correspondence with the elements of
    list p. Assume variable i contains the value 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(5):  #Perform 5 passes'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PLAYERS - 1, m, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if g[i][n] > g[i][n - 1]:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: g[i][n], g[i][n - 1] = g[i][n - 1], g[i][n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: p[i][n], p[i][n - 1] = p[i][n - 1], p[i][n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, in order to sort all rows, you need to nest this code fragment in a for-loop
    that iterates for all of them, as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(TEAMS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(5):  #Perform 5 passes'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PLAYERS - 1, m, -1):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if g[i][n] > g[i][n - 1]:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: g[i][n], g[i][n - 1] = g[i][n - 1], g[i][n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: p[i][n], p[i][n - 1] = p[i][n - 1], p[i][n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The final Python program is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_33.6-6'
  prefs: []
  type: TYPE_NORMAL
- en: TEAMS = 32
  prefs: []
  type: TYPE_NORMAL
- en: PLAYERS = 24
  prefs: []
  type: TYPE_NORMAL
- en: '#Read team names, player names and goals all together'
  prefs: []
  type: TYPE_NORMAL
- en: t = [None] * TEAMS
  prefs: []
  type: TYPE_NORMAL
- en: p = [[None] * PLAYERS for i in range(TEAMS)]
  prefs: []
  type: TYPE_NORMAL
- en: g = [[None] * PLAYERS for i in range(TEAMS)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(TEAMS):'
  prefs: []
  type: TYPE_NORMAL
- en: 't[i] = input("Enter name for team No." + str(i + 1) + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(PLAYERS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'p[i][j] = input("Enter name of player No." + str(j + 1) + ": ")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'g[i][j] = int(input("Enter goals of player No." + str(j + 1) + ": "))'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Sort list g'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(TEAMS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in range(5):  #Perform 5 passes'
  prefs: []
  type: TYPE_NORMAL
- en: 'for n in range(PLAYERS - 1, m, -1):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if g[i][n] > g[i][n - 1]:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: g[i][n], g[i][n - 1] = g[i][n - 1], g[i][n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: p[i][n], p[i][n - 1] = p[i][n - 1], p[i][n]
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display 5 best scorers of each team'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(TEAMS):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Best scorers of", t[i])
  prefs: []
  type: TYPE_NORMAL
- en: print("----------------------------------")
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(5):'
  prefs: []
  type: TYPE_NORMAL
- en: print(p[i][j], "scored", g[i][j], "goals")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 33.6-7 Counting the Frequency of Vowels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter an English sentence and
    counts the frequency of each vowel in the sentence. Use a dictionary to store
    the vowels as keys and their frequencies as values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of programming, the manipulation and analysis of textual data play
    a crucial role. One common task involves counting the frequency of specific elements
    within a given text, providing insights into its linguistic characteristics. Vowels
    are fundamental components of the English language, and analyzing their frequency
    can reveal patterns, aid in language processing, and even assist in certain cryptographic
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the solution that follows, the program starts by creating a dictionary named
    vowelsFrequency to store and manage the frequency of each vowel (A, E, I, O, U),
    with initial frequencies all set to zero. For each character in the user-provided
    sentence, the program checks if it is a vowel and, if it is, the corresponding
    frequency count in the dictionary is updated.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png)  file_33.6-7'
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a dictionary to store the frequencies of each vowel with initial'
  prefs: []
  type: TYPE_NORMAL
- en: '#frequencies all set to zero.'
  prefs: []
  type: TYPE_NORMAL
- en: 'vowelsFrequency  = {"A": 0, "E": 0, "I": 0, "O": 0, "U": 0}'
  prefs: []
  type: TYPE_NORMAL
- en: 'sentence = input("Enter an English sentence: ")'
  prefs: []
  type: TYPE_NORMAL
- en: '#Iterate through the characters of the user-provided sentence and if it is
    a vowel,'
  prefs: []
  type: TYPE_NORMAL
- en: '#update (increase) the corresponding frequency count in the vowelsFrequency
    dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'for character in sentence.upper():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if character in vowelsFrequency:'
  prefs: []
  type: TYPE_NORMAL
- en: vowelsFrequency[character] += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '#Display the frequencies of each vowel'
  prefs: []
  type: TYPE_NORMAL
- en: 'for vowel in vowelsFrequency:'
  prefs: []
  type: TYPE_NORMAL
- en: print(vowel + ":", vowelsFrequency[vowel])
  prefs: []
  type: TYPE_NORMAL
- en: '33.7 Review Questions: True/False'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)The main idea of the bubble sort algorithm (when sorting a list in ascending
    order) is to repeatedly move the smallest elements of the list to the lowest index
    positions.
  prefs: []
  type: TYPE_NORMAL
- en: 2)In a list sorted in ascending order, the first element is the greatest of
    all.
  prefs: []
  type: TYPE_NORMAL
- en: 3)When using the bubble sort algorithm, the total number of swaps depends on
    the given list.
  prefs: []
  type: TYPE_NORMAL
- en: 4)The case in which the bubble sort algorithm performs the greatest number of
    swaps is when you want to sort in descending order a list that is already sorted
    in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 5)In the bubble sort algorithm, when the decision control structure tests the
    Boolean expression A[n] > A[n − 1], it means that the elements of list A are being
    sorted in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: 6)In Python, sorting algorithms compare letters in the same way that they compare
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 7)If you want to sort a list A but preserve the one-to-one correspondence with
    the elements of a list B, you must rearrange the elements of list B as well.
  prefs: []
  type: TYPE_NORMAL
- en: 8)The bubble sort algorithm sometimes performs better than the modified bubble
    sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 9)According to the bubble sort algorithm, in each pass (except the last one)
    only one element is guaranteed to be placed in proper position.
  prefs: []
  type: TYPE_NORMAL
- en: 10)The bubble sort algorithm can be implemented only by using for-loops.
  prefs: []
  type: TYPE_NORMAL
- en: 11)The quick sort algorithm cannot be used to sort each column of a two-dimensional
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 12)The insertion sort algorithm can sort in either descending or ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 13)One of the fastest sorting algorithms is the modified bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 14)The bubble sort algorithm, for a one-dimensional list of N elements, performs
    ![Image](img/chapter33-49.png) compares.
  prefs: []
  type: TYPE_NORMAL
- en: 15)The bubble sort algorithm, for a one-dimensional list of N elements, performs
    ![Image](img/chapter33-50.png) passes.
  prefs: []
  type: TYPE_NORMAL
- en: 16)When using the modified bubble sort algorithm, if a complete pass is performed
    and no swaps have been done, then the algorithm knows the list is sorted and there
    is no need for further passes.
  prefs: []
  type: TYPE_NORMAL
- en: 17)When using the selection sort algorithm, if you wish to sort a list in descending
    order, you need to search for maximum values.
  prefs: []
  type: TYPE_NORMAL
- en: 18)The selection sort algorithm performs well on computer systems with limited
    main memory.
  prefs: []
  type: TYPE_NORMAL
- en: 19)The selection sort algorithm is suitable for large scale data operations.
  prefs: []
  type: TYPE_NORMAL
- en: 20)The selection sort algorithm is a very complex algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 21)The insertion sort algorithm generally performs better than the selection
    and the bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 22)The insertion sort algorithm can sometimes prove even faster than the quicksort
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 23)The quicksort algorithm is considered one of the best and fastest sorting
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 24)A sorted list contains only elements that are different from each other.
  prefs: []
  type: TYPE_NORMAL
- en: 25)A search algorithm is an algorithm that searches for an item with specific
    features within a set of data.
  prefs: []
  type: TYPE_NORMAL
- en: 26)The sequential search algorithm can be used only on lists that contain arithmetic
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 27)One of the most commonly used search algorithms is the quick search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 28)One search algorithm is called the heap algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '29)A linear (or sequential) search algorithm can work as follows: it can check
    if the last element of the list is equal to a given value, then it can check the
    last but one element, and so on, until the beginning of the list or until the
    given value is found.'
  prefs: []
  type: TYPE_NORMAL
- en: 30)The linear search algorithm can, in certain situations, find an element faster
    than the binary search algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 31)The linear search algorithm can be used in large scale data operations.
  prefs: []
  type: TYPE_NORMAL
- en: 32)The linear search algorithm cannot be used in sorted lists.
  prefs: []
  type: TYPE_NORMAL
- en: 33)The binary search algorithm can be used in large scale data operations.
  prefs: []
  type: TYPE_NORMAL
- en: 34)If a list contains a value multiple times, the binary search algorithm can
    find only the first in order occurrence of a given value.
  prefs: []
  type: TYPE_NORMAL
- en: 35)When using search algorithms, if a list contains unique values and the element
    that you are looking for is found, there is no need to check any further.
  prefs: []
  type: TYPE_NORMAL
- en: 36)The main disadvantage of the binary search algorithm is that data needs to
    be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 37)The binary search algorithm can be used only in lists that contain arithmetic
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 38)If the element you are looking for is in the last position of a list, a linear
    search algorithm that starts searching from the beginning of the list will examine
    all the elements in the list .
  prefs: []
  type: TYPE_NORMAL
- en: 39)The linear search algorithm can be used on two-dimensional lists.
  prefs: []
  type: TYPE_NORMAL
- en: 40)If the element that you are looking for using the binary search algorithm
    is at the first position of a list with at least three elements, it will be found
    in just one iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 33.8 Review Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Write the Python program that corresponds to the following flowchart fragment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter33-51.png)'
  prefs: []
  type: TYPE_IMG
- en: '2)Design a flowchart and write the corresponding Python program that lets the
    user enter 50 positive numerical values into a list. The algorithm, and consequently
    the Python program, must then create a new list of 47 elements. In this new list,
    each position must contain the average value of four elements: the values that
    exist in the current and the next three positions of the user-provided list.'
  prefs: []
  type: TYPE_NORMAL
- en: 3)Write a Python program that lets the user enter numerical values into lists
    a, b, and c, of 15 elements each. The program must then create a new list newArr
    of 15 elements. In this new list, each position must contain the lowest value
    of lists a, b, and c, for the corresponding position.
  prefs: []
  type: TYPE_NORMAL
- en: Next, design the corresponding flowchart fragment for only that part of your
    program that creates the list newArr.
  prefs: []
  type: TYPE_NORMAL
- en: 4)Write a Python program that lets the user enter numerical values into lists
    a, b, and c, of 10, 5, and 15 elements respectively. The program must then create
    a new list newArr of 30 elements. In this new list, the first 15 positions must
    contain the elements of list c, the next five positions must contain the elements
    of list b, and the last 10 positions must contains the elements of list a.
  prefs: []
  type: TYPE_NORMAL
- en: Next, design the corresponding flowchart fragment for only that part of your
    program that creates the list newArr.
  prefs: []
  type: TYPE_NORMAL
- en: 5)Write a Python program that for two given lists a and b of 3 × 4 and 5 × 4
    elements respectively it creates a new list newArr of 8 × 4 elements. In this
    new list, the first 3 rows must contain the elements of list a and the next 5
    rows must contain the elements of list b.
  prefs: []
  type: TYPE_NORMAL
- en: 6)Write a Python program that lets the user enter numerical values into lists
    a, b, and c, of 5 × 10, 5 × 15, and 5 × 20 elements, respectively. The program
    must then create a new list newArr of 5 × 45 elements. In this new list, the first
    10 columns must contain the elements of list a, the next 15 columns must contain
    the elements of list b, and the last 20 rows must contain the elements of list
    c.
  prefs: []
  type: TYPE_NORMAL
- en: 7)Write a Python program that lets the user enter 50 numerical values into a
    list and then creates two new lists, reals and integers. The list reals must contain
    the real values, whereas the list integers must contain the integer values. The
    value 0 (if any) must not be added to any of the final lists, either reals or
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, design the corresponding flowchart fragment for only that part of your
    program that creates the lists reals and integers.
  prefs: []
  type: TYPE_NORMAL
- en: 8)Write a Python program that lets the user enter 50 three-digit integers into
    a list and then creates a new list containing only the integers in which the first
    digit is less than the second digit and the second digit is less than the third
    digit. For example, the values 357, 456, and 159 are such integers.
  prefs: []
  type: TYPE_NORMAL
- en: '9)A public opinion polling company asks 200 citizens to each score 10 consumer
    products. Write a Python program that prompts the user to enter the name of each
    product and the score each citizen gave (A, B, C, or D). The program must then
    calculate and display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a)for each product, the name of the product and the number of citizens that
    gave it an “A”
  prefs: []
  type: TYPE_NORMAL
- en: b)for each citizen, the number of “B” responses they gave
  prefs: []
  type: TYPE_NORMAL
- en: c)which product or products are considered the best
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any score with a value other
    than A, B, C, or D.
  prefs: []
  type: TYPE_NORMAL
- en: 10)Write a Python program that prompts the user to enter the names of 20 U.S.
    cities and the names of 20 Canadian cities and then, for each U.S. city, the distance
    (in miles) from each Canadian city. Finally, the program must display, for each
    U.S. city, its closest Canadian city.
  prefs: []
  type: TYPE_NORMAL
- en: 11)Design a flowchart and write the corresponding Python program that lets the
    user enter the names and the heights of 30 mountains, as well as the country in
    which each one belongs. The algorithm, and consequently the Python program, must
    then display all available information about the highest and the lowest mountain.
  prefs: []
  type: TYPE_NORMAL
- en: 12)Design the flowchart fragment of an algorithm that, for a given list A of
    N × M elements, finds and displays the maximum value as well as the row and the
    column in which this value was found.
  prefs: []
  type: TYPE_NORMAL
- en: 13)Twenty-six teams participate in a football tournament. Each team plays 15
    games, one game each week. Write a Python program that lets the user enter the
    name of each team and the letter “W” for win, “L” for loss, and “T” for tie (draw)
    for each game. If a win receives 3 points and a tie 1 point, the Python program
    must find and display the name of the team that wins the championship based on
    which team obtained the greatest sum of points. Assume that no two teams have
    an equal sum of points.
  prefs: []
  type: TYPE_NORMAL
- en: 14)On Earth, a free-falling object has an acceleration of 9.81 m/s² downward.
    This value is denoted by g. A student wants to calculate that value using an experiment.
    She allows 10 different objects to fall downward from a known height, and measures
    the time they need to reach the floor. However, since her chronometer is not so
    accurate, she does this 20 times for each object. She needs a Python program that
    allows her to enter the heights (from which objects are left to fall), as well
    as the measured times that they take to reach the floor. The program must then
  prefs: []
  type: TYPE_NORMAL
- en: ►calculate g and store all calculated values in a 10 × 20 list.
  prefs: []
  type: TYPE_NORMAL
- en: ►find and display the minimum and the maximum calculated values of g for each
    object.
  prefs: []
  type: TYPE_NORMAL
- en: ►find and display the overall minimum and maximum calculated values of g of
    all objects.
  prefs: []
  type: TYPE_NORMAL
- en: The required formula is
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter10-01.png)
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: ►S is the distance that the free-falling objects traveled, in meters (m)
  prefs: []
  type: TYPE_NORMAL
- en: ►u[o] is the initial velocity (speed) of the free-falling objects in meters
    per second (m/sec). However, since the free-falling objects start from rest, the
    value of u[0] must be zero.
  prefs: []
  type: TYPE_NORMAL
- en: ►t is the time that it took the free-falling object to reach the floor, in seconds
    (sec)
  prefs: []
  type: TYPE_NORMAL
- en: ►g is the acceleration, in meters per second² (m/sec²)
  prefs: []
  type: TYPE_NORMAL
- en: 15)Ten measuring stations, one in each city, record the daily CO[2] levels for
    a period of a year. Write a Python program that lets the user enter the name of
    each city and the CO[2] levels recorded at the same hour each day. The Python
    program then displays the name of the city that has the clearest atmosphere (on
    average).
  prefs: []
  type: TYPE_NORMAL
- en: 16)Design the flowchart fragment of an algorithm that, for a given list A of
    N × M elements, finds and displays the minimum and the maximum values of each
    row.
  prefs: []
  type: TYPE_NORMAL
- en: 17)Write a Python program that lets the user enter values into a 20 × 30 list
    and then finds and displays the minimum and the maximum values of each column.
  prefs: []
  type: TYPE_NORMAL
- en: 18)Twenty teams participate in a football tournament, and each team plays 10
    games, one game each week. Write a Python program that prompts the user to enter
    the name of each team and the letter “W” for win, “L” for loss, and “T” for tie
    (draw) for each game. If a win receives 3 points and a tie 1 point, the Python
    program must find and display the names of the teams that win the gold, the silver,
    and the bronze medals based on which team obtained the greatest sum of points.
    Use the modified bubble sort algorithm. Assume that no two teams have an equal
    sum of points.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any letter other than W, L,
    or T.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Instead of performing 19 passes (there are 20 teams), given that only
    the three best teams must be found, the modified bubble sort algorithm can perform
    just 3 passes.'
  prefs: []
  type: TYPE_NORMAL
- en: 19)Write a Python program that prompts the user to enter the names and the heights
    of 50 people. The program must then display this information, sorted by height,
    in descending order. In cases where two or more people share the same height,
    their names must be displayed in alphabetical order. To achieve this, use the
    bubble sort algorithm, adapted accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 20)Write a Python program that prompts the user to enter the first names, last
    names and father's names of 50 people. The program must then display this information,
    sorted by last name. In cases where two or more people share the same last name,
    their first names must be displayed in alphabetical order. Additionally, if two
    or more people share the same first name, their father's names must be displayed
    in alphabetical order. To achieve this, use the bubble sort algorithm, adapted
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 21)In a song contest there are 10 judges, each of whom scores 12 artists for
    their performance. However, according to the rules of this contest, the total
    score is calculated after excluding the highest and lowest scores. Write a Python
    program that prompts the user to enter the names of the artists and the score
    they get from each judge. The program must then display
  prefs: []
  type: TYPE_NORMAL
- en: a)for each artist, their name and total score, after excluding the maximum and
    the minimum scores. Assume that each artist's highest and lowest scores are unique,
    meaning they won't have multiple scores with the same value.
  prefs: []
  type: TYPE_NORMAL
- en: b)the final classification, starting with the artist that has the greatest score.
    However, if two or more artists have the same score, their names must be displayed
    in alphabetical order. Use the bubble sort algorithm, adapted accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 22)Design the flowchart fragment of an algorithm that, for a given list A of
     20 × 8 elements, sorts each row in descending order using the bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 23)Design the flowchart fragment of an algorithm that, for a given list A of
    5 × 10 elements, sorts each column in ascending order using the bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 24)Design the flowchart fragment of an algorithm that, for a given list A of
     20 × 8 elements, sorts each row in descending order using the insertion sort
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 25)Design the flowchart fragment of an algorithm that, for a given list A of
    5 × 10 elements, sorts each column in ascending order using the selection sort
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 26)In a Sudoku contest, 10 participants compete to solve eight different Sudoku
    puzzles as quickly as possible. Write a Python program that lets the user enter
    the name of each contestant and their time (in hours, minutes and seconds) to
    complete each puzzle. The program must then display
  prefs: []
  type: TYPE_NORMAL
- en: a)for each contestant, their name along with their three best times. Assume
    that the times of each contestant are different.
  prefs: []
  type: TYPE_NORMAL
- en: b)the names of the three contestants who receive the gold, the silver, and the
    bronze medals based on the contestant with the lowest average time. Assume that
    no two contestants have the same average time.
  prefs: []
  type: TYPE_NORMAL
- en: Use the selection sort algorithm when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Given that only the three best contestants must be found, the selection
    sort algorithm could sort only the first three elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 27)Five measuring stations, one in each area of a large city, record the daily
    carbon dioxide (CO[2]) levels on an hourly basis. Write a Python program that
    lets the user enter the name of each area and the CO[2] levels recorded every
    hour (00:00 to 23:00) for a period of two days. The Python program then must calculate
    and display
  prefs: []
  type: TYPE_NORMAL
- en: a)for each area, its name and its average CO[2] level
  prefs: []
  type: TYPE_NORMAL
- en: b)for each hour, the average CO[2] level of the city
  prefs: []
  type: TYPE_NORMAL
- en: c)the hour in which the city atmosphere was most polluted (on average)
  prefs: []
  type: TYPE_NORMAL
- en: d)the hour and the area in which the highest level of CO[2] was recorded
  prefs: []
  type: TYPE_NORMAL
- en: e)the three areas with the dirtiest atmosphere (on average), using the insertion
    sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 28)Design the flowchart fragment of the linear search algorithm that performs
    a search on list a of N elements to find the value needle and displays the position
    index(es) at which needle is found. If needle is not found, the message “Not found”
    must be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 29)Design the flowchart fragment of the binary search algorithm that performs
    a search on list a of N elements to find the value needle and displays the position
    at which needle is found. If needle is not found, the message “Not found” must
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 30)Twelve teams participate in a football tournament, and each team plays 20
    games, one game each week. Write a Python program that prompts the user to enter
    the name of each team and the letter “W” for win, “L” for loss, or “T” for tie
    (draw) for each game. Then the program must prompt the user for a letter (W, L,
    or T) and display, for each team, the week number(s) in which the team won, lost,
    or tied respectively. For example, if the user enters “L”, the Python program
    must search and display, for each team, the week numbers (e.g., Week 3, Week 14,
    and so on) in which the team lost the game.
  prefs: []
  type: TYPE_NORMAL
- en: 31)Ten teams participate in a football tournament, and each team plays 16 games,
    one game each week. Write a Python program that prompts the user to enter the
    name of each team, the number of goals the team scored, and the number of goals
    the team let in for each match. A win receives 3 points and a tie receives 1 point.
    The Python program must then prompt the user for a team name and finally calculate
    and display the total number of points for this team. If the user-provided team
    name is not found, the message “This team does not exist” must be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a loop control structure, the program must validate data input
    and display an error message when the user enters any negative number of goals.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that no two teams share the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 32)In a high school, there are two classes, with 20 and 25 students respectively.
    Write a Python program that prompts the user to enter the names of the students
    in two separate lists. The program then displays the names of each class independently
    in ascending order. Afterwards, the program prompts the user to enter a name and
    it searches for that user-provided name in both lists. If the student's name is
    found, the program must display the message “Student found in Class No N”, where
    N can be either 1 or 2; otherwise the message “Student not found in either class”
    must be displayed. Assume that both lists contain unique names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Since the lists are sorted and the names are unique, use the binary search
    algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 33)Suppose there are two lists, usernames and passwords, that contain the login
    information of 100 employees of a company. Write a code fragment that prompts
    the user to enter a username and a password and then displays the message “Login
    OK!” when the combination of username and password is valid; the message “Login
    Failed!” must be displayed otherwise. Both usernames and passwords are case-insensitive.
    Assume that usernames are unique but passwords are not.
  prefs: []
  type: TYPE_NORMAL
- en: 34)Suppose there are two lists, names and SSNs, that contain the names and the
    SSNs (Social Security Numbers) of 1,000 U.S. citizens. Write a code fragment that
    prompts the user to enter a value (it can be either a name or an SSN) and then
    searches for and displays the names of all the people that have this name or this
    SSN. If the user-provided value is not found, the message “This value does not
    exist” must be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 35)There are 12 students and each one of them has received their grades for
    six lessons. Write a Python program that lets the user enter the grades for all
    lessons and then displays a message indicating whether or not there is at least
    one student that has an average value below 70\. Moreover, using a loop control
    structure, the program must validate data input and display a different error
    message for each type of input error when the user enters any negative value,
    or a value greater than 100.
  prefs: []
  type: TYPE_NORMAL
- en: 36)Write a Python program that prompts the user to enter an English message,
    and then, using the table that follows, displays the corresponding Morse code
    using dots and dashes. Please note that space characters must be displayed as
    slash characters ( / ) in the translated message.
  prefs: []
  type: TYPE_NORMAL
- en: '| Morse Code |'
  prefs: []
  type: TYPE_TB
- en: '| A | .‑ | N | ‑. |'
  prefs: []
  type: TYPE_TB
- en: '| B | ‑... | O | ‑‑‑ |'
  prefs: []
  type: TYPE_TB
- en: '| C | ‑.‑. | P | .‑‑. |'
  prefs: []
  type: TYPE_TB
- en: '| D | ‑.. | Q | ‑‑.‑ |'
  prefs: []
  type: TYPE_TB
- en: '| E | . | R | .‑. |'
  prefs: []
  type: TYPE_TB
- en: '| F | ..‑. | S | ... |'
  prefs: []
  type: TYPE_TB
- en: '| G | ‑‑. | T | ‑ |'
  prefs: []
  type: TYPE_TB
- en: '| H | .... | U | ..‑ |'
  prefs: []
  type: TYPE_TB
- en: '| I | .. | V | ...‑ |'
  prefs: []
  type: TYPE_TB
- en: '| J | .‑‑‑ | W | .‑‑ |'
  prefs: []
  type: TYPE_TB
- en: '| K | ‑.‑ | X | ‑..‑ |'
  prefs: []
  type: TYPE_TB
- en: '| L | .‑.. | Y | ‑.‑‑ |'
  prefs: []
  type: TYPE_TB
- en: '| M | ‑‑ | Z | ‑‑.. |'
  prefs: []
  type: TYPE_TB
- en: 'Hint: Use a dictionary to hold the Morse code.'
  prefs: []
  type: TYPE_NORMAL
- en: '37)Write a Python program that prompts the user to enter an English sentence.
    The program must then display:'
  prefs: []
  type: TYPE_NORMAL
- en: a)all letters that exist in the user-provided sentence along with their frequency
    count
  prefs: []
  type: TYPE_NORMAL
- en: b)all letters that do not exist in the user-provided sentence
  prefs: []
  type: TYPE_NORMAL
- en: c)the percentage of letters that do not exist in relation to the letters of
    the English alphabet
  prefs: []
  type: TYPE_NORMAL
- en: d)the percentage of non-alphabetic characters in relation to the characters
    of the user-provided sentence (excluding space characters)
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Use a dictionary to store all 26 English letters as keys and their frequencies
    as values, but find a clever way to create it.'
  prefs: []
  type: TYPE_NORMAL
