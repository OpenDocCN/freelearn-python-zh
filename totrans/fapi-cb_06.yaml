- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating FastAPI with SQL Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll now embark on a journey to harness the full potential of SQL databases
    within your FastAPI applications. This chapter is meticulously designed to guide
    you through the nuances of leveraging **SQLAlchemy**, a powerful SQL toolkit and
    **object-relational** **mapping** (**ORM**) for Python. From setting up your database
    environment to implementing sophisticated **create, read, update and delete**
    (**CRUD**) operations and managing complex relationships, this chapter provides
    a comprehensive blueprint for integrating SQL databases seamlessly with FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: By creating a basic ticketing platform, you’ll practically engage in configuring
    SQLAlchemy with FastAPI, creating data models that reflect your application’s
    data structures, and crafting efficient, secure CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you’ll explore the management of database migrations with **Alembic**,
    ensuring your database schema evolves alongside your application without hassle.
    This chapter doesn’t stop at just handling data; it delves into optimizing SQL
    queries for performance, securing sensitive information within your database,
    and managing transactions and concurrency to ensure data integrity and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be adept at integrating and managing SQL
    databases in your FastAPI applications, equipped with the skills to ensure your
    applications are not only efficient and scalable but also secure. Whether you’re
    building a new application from scratch or integrating a database into an existing
    project, the insights and techniques covered here will empower you to leverage
    the full power of SQL databases in your FastAPI projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling relationships in SQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing SQL queries for performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing sensitive data in SQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling transactions and concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with all the recipes of the chapter, make sure you have these
    essentials in your setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: Your environment should have a Python version above 3.9 installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FastAPI**: It should be installed in your virtual environment with all the
    dependencies it needs. If you didn’t do it in the previous chapters, you can easily
    do it from your terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code that accompanies the chapter is available on GitHub at the following
    link: [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also advisable to create a virtual environment for the project inside
    the project root folder, to handle dependencies well and keep the project separate.
    In your virtual environment, you can install all the dependencies at once by using
    the `requirements.txt` file from the GitHub repo in the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the code of the chapter will make use of the `async`/`await` syntax from
    the `asyncio` Python library, you should be already familiar with it. Feel free
    to read more about `asyncio` and `async`/`await` syntax at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/asyncio.xhtml](https://docs.python.org/3/library/asyncio.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://fastapi.tiangolo.com/async/](https://fastapi.tiangolo.com/async/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have this ready Once we have everything ready, we can begin preparing
    our recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin any data application, you need to establish a database connection.
    This recipe will help you set up and configure `sqlalchemy` package with an **SQLite**
    database so that you can use the advantages of SQL databases in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project is going to be fairly large, so we will put the working modules
    for the application in a folder named `app`, which will be under the root project
    folder that we will call `ticketing_system`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need `fastapi`, `sqlalchemy`, and `aiosqlite` installed in your environment
    to use the recipe. The recipe is meant to work with `sqlalchemy` with versions
    above 2.0.0\. You can still use version 1; however, some adaptions are required.
    You can find a migration guide at the following link: [https://docs.sqlalchemy.org/en/20/changelog/migration_20.xhtml](https://docs.sqlalchemy.org/en/20/changelog/migration_20.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t installed the packages with the `requirements.txt` file in the
    repo, you can do it by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the packages are correctly installed, you can follow the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The setup of a generic SQL database connection with `sqlalchemy` will go through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating mapping object classes, that will match the database tables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating abstraction layers, an engine, and a session to communicate with the
    database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing a database connection, at the server startup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating mapping object classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `app` folder, let’s create a module called `database.py` and then create
    a class object to track tickets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We just created a `Ticket` class that will be used to match the `tickets` table
    into our SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating abstraction layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In SQLAlchemy, the *engine* manages database connections and executes SQL statements,
    while a *session* allows querying, inserting, updating, and deleting data within
    a transactional context, ensuring consistency and atomicity. Sessions are bound
    to an engine for communication with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a function that returns the engine. In a new module
    called `db_connection.py`, under the `app` folder, let’s write the function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You may have observed that the `SQLALCHEMY_DATABASE_URL` database URL uses the
    `sqlite` and `aiosqlite` modules.
  prefs: []
  type: TYPE_NORMAL
- en: This implies that we will use an SQLite database where the operations will happen
    via the `aiosqlite` asynchronous library that supports the `asyncio` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will use a session maker to specify that the session will be asynchronous,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `get_db_session` function will be used as a dependency for each endpoint
    interacting with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a database connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have the abstraction layers, we need to create our FastAPI server object
    and start the database classes when the server runs. We can do it in the `main.py`
    module under the `app` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To specify server actions at the startup event, we have used the `lifespan`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We have everything in place to connect our application with the database.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creation of the `Ticket` database mapping class tells our application how
    the database is structured, and the session will manage the transactions. Then,
    the engine will not only execute the operations but compare the mapping classes
    with the database, and it will create tables if any are missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check that our app communicates with our database, let’s spin up the server
    from the command line at the project root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should see message logs on the command output that says table tickets have
    been created. Furthermore, open the `.database.db` file with the database reader
    you prefer, and the table should be there with the schema that is defined in the
    `database.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can see more about how to set up a database with SQLAlchemy and how to
    make it compatible with the `asyncio` module on the official documentation pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*How to set up an SQLAlchemy* *database*: [https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml](https://docs.sqlalchemy.org/en/20/orm/quickstart.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SQLAlchemy* `asyncio` *extension* *reference*: [https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we have used an SQLite database by specifying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, you can use SQLAlchemy to interact with multiple SQL databases such
    as `asyncio`-supported driver, and the database address.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for MySQL, the connection string would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you need the `aiomysql` package installed in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check more on the official documentation pages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy MySQL dialect: [https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml](https://docs.sqlalchemy.org/en/20/dialects/mysql.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLAlchemy PostgreSQL dialect: [https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml](https://docs.sqlalchemy.org/en/20/dialects/postgresql.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CRUD operations with a RESTful API can be implemented using HTTP methods (`POST`,
    `GET`, `PUT`, and `DELETE`) for web services. This recipe demonstrates how to
    use SQLAlchemy and `asyncio` to build CRUD operations asynchronously on an SQL
    database with the corresponding endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you start with the recipe, you need to have a database connection and
    a table in the dataset, as well as a matching class in the code base. If you completed
    the previous recipe, you should have them ready.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll begin by making an `operations.py` module under the `app` folder to contain
    our database operations by following these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can set up the operation to add a new ticket to the database as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function will give back the ID attached to the ticket when saved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, let’s create a function to get a ticket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the ticket is not found, the function will return a `None` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we build an operation to update only the price of the ticket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function gives back `False` if the operation couldn’t delete any ticket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To conclude the CRUD operations, we define a `delete_ticket` operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly to the update operation, the function returns `False` if it does not
    find any ticket to delete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After defining the operations, we can expose them by creating the corresponding
    endpoints in the `main.py` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s do it for the create operation right after defining the app server:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The remaining operations can be exposed in the same way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to what we did for the `create_ticket` operation, expose the other
    operations (get, update, and delete) with the respective endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functions created to interact with the database are exposed through the
    endpoints. This means that an external user will execute the operations by calling
    the respective endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s verify that the endpoint works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the server from the command line as usual by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then, go to the interactive documentation link at `http://localhost:8000/docs`,
    and you will see the endpoints you just created. Experiment with them in different
    combinations and see the results in the `.database.db` database file.
  prefs: []
  type: TYPE_NORMAL
- en: You have just created CRUD operations to interact with an SQL database by using
    `sqlalchemy` with the `asyncio` library.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: Make a `tests` folder in the root project folder and write all the unit tests
    for the operation functions and the endpoints. You can refer to [*Chapter 5*](B21025_05.xhtml#_idTextAnchor157),
    *Testing and Debugging FastAPI Applications*, to learn how to unit test FastAPI
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Working with migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database migrations let you version control your database schema and keep it
    consistent across environments. They also help you automate the deployment of
    your database changes and track the history of your schema evolution.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe shows you how to use **Alembic**, a popular tool for managing database
    migrations in Python. You will learn how to create, run, and roll back migrations
    and how to integrate them with your ticketing system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the recipe, you need to have `alembic` in your environment. You can
    install it with `pip,` if you didn’t do it with the `requirements.txt` file from
    the GitHub repository, by typing this on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You also need to make sure you have at least one class that corresponds to the
    table in the database you want to create. If you don’t have one, go back to the
    *Setting up SQLAlchemy* recipe and make one. If you’re already running the application,
    delete the `.database.db` file that the application has created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To configure Alembic and manage database migrations, go through the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to set up `alembic`. In the project root folder, run the
    following command in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the `sqlalchemy.url` variable and set the database URL to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This specifies that we are using an SQLite database If you use a different database,
    adjust it accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `alembic` directory contains a folder version and an `env.py` file that
    has the variable for creating our database migrations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `env.py` file and find the `target_metadata` variable. Set its value
    to the metadata of our application as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now create our first database migration script and apply the migration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following command from the command line to create an initial migration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you removed the existing `.database.db` file, and let’s execute our
    first migration with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have the first version of our database, let’s see the migration in action.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we want to change the table in the `database.py` module while the application
    is already deployed in a production environment so that we can’t delete any records
    when updating it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some tickets to the database, then in the code, let’s add a new field called
    `sold` that will indicate if the ticket has been sold or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a new migration, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You will find a new script in the `alembic/versions` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the migration command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Open the database, and you will see that the `tickets` table schema has the
    `sold` field added to it, and no record has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: You just created a migration strategy that will seamlessly change our database
    while running without any data loss. From now on, remember to use migrations to
    track changes on database schemas.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can see more on how to manage database migrations with Alembic at the official
    documentation links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Setting up* *Alembic*: [https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml](https://alembic.sqlalchemy.org/en/latest/tutorial.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Autogenerating* *migrations*: [https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml](https://alembic.sqlalchemy.org/en/latest/autogenerate.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling relationships in SQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database relationships are associations between two or more tables that allow
    you to model complex data structures and perform queries across multiple tables.
    In this recipe, you will learn how to implement one-to-one, many-to-one, and many-to-many
    relationships for the existing ticketing system application. You will also see
    how to use SQLAlchemy to define your database schema relationships and query the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow the recipe, you need to have the core of the application already implemented
    with at least one table in it. If you have already done that, you will also have
    the necessary packages ready. We will keep on working on our ticketing system
    platform application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now proceed to set up relationships. We will show an example for each
    type of SQL table relationship.
  prefs: []
  type: TYPE_NORMAL
- en: One to one
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will demonstrate the one-to-one relationship by making a new table that holds
    details about the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one relationships are used to group specific information about a record
    in a separate logic.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, let’s make the table in the `database.py` module. The records
    will have information such as the seat associated with the ticket, with a ticket
    type that we will use as a label for possible information. Let's create the table
    in two steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add the ticket details reference to the existing `Ticket` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create the table to map the ticket’s details as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the database classes are set up to accommodate the new table, we can proceed
    to update the CRUD operations with the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update ticket details, let’s create a dedicated function in the `operations.py`
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function will return `False` if no records have been updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, modify the `create_ticket` function to consider the details of the ticket
    and create an endpoint to expose the updating operation we just created, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, each time a ticket is created, an empty record of ticket details
    is created as well to keep the database consistent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This was the minimum setup to handle one-to-one relationships. We will continue
    by setting up many-to-one relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Many to one
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A ticket can be associated with an event, and an event can have multiple tickets.
    To showcase a many-to-one relationship, we will create an `events` table that
    will have a relationship with the `tickets` table. Let’s go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create a column in the `tickets` table that will accommodate the
    reference to the `events` table in the `database.py` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'class Event(Base):'
  prefs: []
  type: TYPE_NORMAL
- en: __tablename__ = "events"
  prefs: []
  type: TYPE_NORMAL
- en: 'id: Mapped[int] = mapped_column(primary_key=True)'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: Mapped[str]'
  prefs: []
  type: TYPE_NORMAL
- en: 'tickets: Mapped[list["Ticket"]] = relationship('
  prefs: []
  type: TYPE_NORMAL
- en: back_populates="event"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'class Event(Base):'
  prefs: []
  type: TYPE_NORMAL
- en: __tablename__ = "events"
  prefs: []
  type: TYPE_NORMAL
- en: '# existing columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'sponsors: Mapped[list["Sponsor"]] = relationship('
  prefs: []
  type: TYPE_NORMAL
- en: secondary="sponsorships",
  prefs: []
  type: TYPE_NORMAL
- en: back_populates="events",
  prefs: []
  type: TYPE_NORMAL
- en: 'sponsors table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you might have noticed, the class contains columns to accommodate the `events`
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can define an association table that will be the `sponsorships`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The association table can contain information on the relationship itself. For
    example, in our case, a piece of useful information is the amount provided by
    the sponsor for the event.
  prefs: []
  type: TYPE_NORMAL
- en: This is all you need to create many-to-many relationships for your ticketing
    system platform.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete your application, create an operations function with the relative
    endpoints to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Add a sponsor to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: '- Add a sponsorship with the amount. If the sponsorship already exists, replace
    the sponsorship with the new amount.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'You can dive deeper into handling relationships with SQLAlchemy at the following
    official documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SQLAlchemy basic* *relationships*: [https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml](https://docs.sqlalchemy.org/en/20/orm/basic_relationships.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing SQL queries for performance
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing SQL queries is key in database management, as it enhances efficiency,
    scalability, cost-effectiveness, user satisfaction, data integrity, compliance,
    and security.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how to make applications run faster by improving SQL queries.
    Queries that use fewer resources and less time can enhance user satisfaction and
    application capacity. Improving SQL queries is a repeated process, but you could
    use some tips that could assist you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have an existing application running using SQLAlchemy for database
    interaction or to keep working on the ticketing system application all along the
    chapter. Also, basic knowledge of SQL and database schema design can be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: 'Improving SQL queries is a process that involves several steps. As with most
    optimization processes, many steps are specific to the use case, but there are
    general rules that can help optimize SQL queries overall, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid *N*+1 queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `JOIN` statement sparingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize data to fetch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will apply each with a significant example.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding N+1 queries
  prefs: []
  type: TYPE_NORMAL
- en: The N+1 query issue happens when your application does one query to get a list
    of items and then loops over those items to get related data, making N more queries.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want an endpoint to show all events with the associated sponsors.
    A first try might be to fetch the `events` table and loop over the events to fetch
    the `sponsors` table. This solution means a first query to get the events and
    N more queries to get the sponsors for each event, which is exactly what we want
    to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to load all related records in the query to retrieve the related
    sponsors. This is technically called *eager loading*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQLAlchemy, this is done by using a `joinedload` option so that the function
    operation will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `joinedload` method will include a `JOIN` operation on the query, so it
    is no longer necessary to make N queries to get the sponsors.
  prefs: []
  type: TYPE_NORMAL
- en: Using the join statement sparingly
  prefs: []
  type: TYPE_NORMAL
- en: Joined tables can make the query easier to read. But be careful and only join
    tables that you need for your query.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to get a list of sponsors names with the amount given for a
    certain event in order from the highest to the lowest.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use multiple joins since we need to fetch three tables. The function
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The double join implies to call the `events` table that we won’t use, so it
    would be much more efficient to organize the query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will return what we need without selecting the `events` table at all.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing data to fetch
  prefs: []
  type: TYPE_NORMAL
- en: Fetching more data than needed can slow down your queries and the application.
  prefs: []
  type: TYPE_NORMAL
- en: Use SQLAlchemy’s `load_only` function to load only specific columns from the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that for a marketing analysis, we are asked to make a function that
    gets a list of tickets with only the ticket ID, the user, and the price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We now try to retrieve the tickets from this function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that each element only has the `id`, `user`, and `price` fields
    and it will give an error if you attempt to access the `show` field, for example.
    In larger applications, this can reduce memory usage and make responses much faster.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs: []
  type: TYPE_NORMAL
- en: SQL query optimization involves more than what the recipe showed. Often, choosing
    a certain SQL database depends on specific optimization needs.
  prefs: []
  type: TYPE_NORMAL
- en: Different SQL databases may have different strengths and weaknesses in handling
    these factors, depending on their architecture and features. For example, some
    SQL databases may support partitioning, sharding, replication, or distributed
    processing, which can improve the scalability and availability of data. Some SQL
    databases may offer more advanced query optimization techniques, such as cost-based
    optimization, query rewriting, or query caching, which can reduce the execution
    time and resource consumption of queries. Some SQL databases may implement different
    storage engines, transaction models, or index types, which can affect the performance
    and consistency of data operations.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when choosing an SQL database for a specific application, it is important
    to consider the characteristics and requirements of the data and queries, and
    compare the capabilities and limitations of the available SQL databases. A good
    way to do this is to benchmark the performance of SQL databases using realistic
    datasets and queries and measure the relevant metrics, such as throughput, latency,
    accuracy, and reliability. By doing so, one can find the optimal SQL database
    for the given scenario and also identify potential areas for improvement in the
    database design and query formulation.
  prefs: []
  type: TYPE_NORMAL
- en: Securing sensitive data in SQL databases
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data, such as personal information, financial records, or confidential
    documents, is often stored in SQL databases for various applications and purposes.
    However, this also exposes the data to potential risks of unauthorized access,
    theft, leakage, or corruption. Therefore, it is essential to secure sensitive
    data in SQL databases and protect it from malicious attacks or accidental errors.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to store sensitive data, such as credit card information,
    in SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: To follow the recipe, you need to have an application with a database connection
    already in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we will use the `cryptography` package. If you haven’t installed
    it with the `requirements.txt` file, you can do it by running this command in
    your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: A sound knowledge of cryptography can be beneficial but is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: We will make a new table from the ground up to store credit card information.
    Some of the information, such as credit card numbers and **Card Verification Values**
    (**CVV**), will not be saved in clear text in our database but rather encrypted.
    Since we need to get it back, we will use a symmetric encryption that needs a
    key. Let's make the process through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a class in the `database.py` module that corresponds
    to the `credit_card` table in our database, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Next, in the `app` folder, we create a module named `security.py` where
    we will write our code for encrypting and decrypting data using **Fernet symmetric
    encryption**, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `cypher_suite` object will be used to define the encryption and decryption
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is worth mentioning that in a production environment, the `cypher_key` object
    can be either kept in an external service that offers rotation or created at startup,
    based on the security needs of the business.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.  In the same module, we can create a function to encrypt credit card info
    and one to decrypt it as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Those functions will be used when writing and reading from the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '4.  Then, we can write a storing operation in the same `security.py` module
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each time the function is awaited, the credit card information will be stored
    with the confidential data encrypted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.  Similarly, we can define a function to retrieve the encrypted credit card
    information from the database as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have just developed code to save confidential information in our database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: 'We just saw the backbone of how to store sensitive data securely. You can complete
    the feature by yourself by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Writing unit tests for our encryption operations. In the `tests` folder,
    let’s create a new test module called `test_security.py`. Verify that the credit
    card is securely saved in our database, but the fields for credit card numbers
    and CVV are encrypted.'
  prefs: []
  type: TYPE_NORMAL
- en: '- Creating endpoints to store, retrieve, and delete credit card information
    in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: '- Associating a credit card with a sponsor and managing the relative CRUD operations.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used Fernet symmetric encryption to encrypt credit card information.
    You can have a deeper insight about it at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fernet symmetric* *encryption*: [https://cryptography.io/en/latest/fernet/](https://cryptography.io/en/latest/fernet/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling transactions and concurrency
  prefs: []
  type: TYPE_NORMAL
- en: 'In the realm of database management, two critical aspects govern the reliability
    and performance of applications: handling transactions and managing concurrency.'
  prefs: []
  type: TYPE_NORMAL
- en: Transactions, encapsulating a series of database operations, are fundamental
    for maintaining data consistency by ensuring that changes occur as a single unit
    of work. Concurrency, on the other hand, addresses the challenge of managing simultaneous
    access to shared resources by multiple users or processes.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between transactions and concurrency becomes apparent when
    considering scenarios where multiple transactions may attempt to access or modify
    the same data concurrently. Without proper concurrency control mechanisms such
    as locking, transactions could interfere with each other, potentially leading
    to data corruption or inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe will show how to manage transactions and concurrency with FastAPI
    and SQLAlchemy by emulating the process of selling tickets from the ticketing
    platform we created.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: You need a CRUD application as the basis for the recipe, or you can continue
    to use the ticketing system application that we have been using throughout the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: The most significant situation where transaction and concurrency become important
    is in managing updating operations, such as with the sales ticket for our application.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by creating a function operation that will label our ticket as
    sold and give the name of the customer. Then, we will simulate two sales occurring
    at the same time and observe the outcome. To do so, follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `operations.py` module, create the function to sell a ticket as follows::'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The query will only sell the ticket if the ticket has not been sold yet; otherwise,
    the function will return `False`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2.  Let’s try to add a ticket to our database and try to simulate two users
    buying the same ticket at the same time. Let’s write all in the form of unit tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We start by defining a fixture to write our ticket into the database in the
    `tests/conftest.py` file as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  We can create a test by performing two concurrent sales with two separate
    database sessions (define another one as a different fixture) to do them at the
    same time in the `tests/test_operations.py` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the test function, we run two coroutines at the same time by using the `asyncio.gather`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We just assume that only one user can purchase the ticket and they will match
    the successful transaction. Once we have created the test, we can execute with
    `pytest` as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The test will succeed, which means that the asynchronous session handles transaction
    conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: 'You have just created a draft of the selling ticket operation. As an exercise,
    you can improve the draft by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Adding a table for users to the database'
  prefs: []
  type: TYPE_NORMAL
- en: '- Adding the foreign key reference of the user on the ticket to make it sold'
  prefs: []
  type: TYPE_NORMAL
- en: '- Creating an `alembic` migration for the database modification'
  prefs: []
  type: TYPE_NORMAL
- en: '- Creating an API endpoint that exposes the `sell_ticket_to_user` function'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs: []
  type: TYPE_NORMAL
- en: One of the fundamental challenges of database systems is to handle concurrent
    transactions from multiple users while preserving data consistency and integrity.
    Different types of transactions may have different requirements for how they access
    and modify data and how they deal with other transactions that may conflict with
    them. For example, a common way to manage concurrency is to use *locks*, which
    are mechanisms that prevent unauthorized or incompatible operations on data. However,
    locks can also introduce trade-offs between performance, availability, and correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the business needs, some transactions may need to acquire locks
    for longer periods or at different levels of granularity, such as table-level
    or row-level. For example, SQLite only allows locks on a database level, while
    PostgreSQL allows locks till the row table level.
  prefs: []
  type: TYPE_NORMAL
- en: Another key aspect of managing concurrent transactions is the concept of *isolation
    levels*, which define the degree to which one transaction must be isolated from
    the effects of other concurrent transactions. Isolation levels ensure that transactions
    maintain data consistency despite simultaneous access and modification by multiple
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL standard defines four isolation levels, each offering different trade-offs
    between concurrency and data consistency:'
  prefs: []
  type: TYPE_NORMAL
- en: '**READ UNCOMMITTED**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transactions at this level allow dirty reads, meaning a transaction can see
    uncommitted changes made by other concurrent transactions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-repeatable reads and phantom reads are possible.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This isolation level provides the highest concurrency but the lowest level of
    data consistency.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**READ COMMITTED**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transactions at this level only see changes committed by other transactions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They do not allow dirty reads.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-repeatable reads are possible, but phantom reads can still occur.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This level strikes a balance between concurrency and consistency.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REPEATABLE READ**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transactions at this level see a consistent snapshot of the data throughout
    the transaction.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes committed by other transactions after the transaction began are not
    visible.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-repeatable reads are prevented, but phantom reads can occur.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This level provides stronger consistency at the cost of some concurrency.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SERIALIZABLE**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transactions at this level behave as if they are executed serially – that is,
    one after another.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide the highest level of data consistency.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-repeatable reads and phantom reads are prevented.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This level offers strong consistency but may result in reduced concurrency due
    to increased locking.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite, for example, allows isolation, while MySQL and PostgreSQL offer all
    four transaction levels.
  prefs: []
  type: TYPE_NORMAL
- en: When the database supports it, in SQLAlchemy, you can set up the isolation level
    per engine or connection by specifying it as an argument when initializing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to specify the isolation level at the engine level
    for PostgreSQL, the engine will be initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: All these choices in terms of locks and isolation level affect the architecture
    and design of the database system since not all SQL databases support it. Therefore,
    it is important to understand the principles and best practices of locking strategies
    and how they relate to the transaction behavior and the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: You have just completed a comprehensive overview of integrating SQL databases
    with FastAPI. In the next chapter, we will explore integrating FastAPI applications
    with NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about locking strategies for SQLite and PostgreSQL
    at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SQLite* *locking*: [https://www.sqlite.org/lockingv3.xhtml](https://www.sqlite.org/lockingv3.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PostgreSQL* *locking*: [https://www.postgresql.org/docs/current/explicit-locking.xhtml](https://www.postgresql.org/docs/current/explicit-locking.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Information on the isolation level for singular databases can be found on the
    respective documentation pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SQLite* *isolation*: [https://www.sqlite.org/isolation.xhtml](https://www.sqlite.org/isolation.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MySQL isolation* *levels*: [https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PostgreSQL isolation* *levels*: [https://www.postgresql.org/docs/current/transaction-iso.xhtml](https://www.postgresql.org/docs/current/transaction-iso.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, a comprehensive guide on how to manage isolation levels with SQLAlchemy
    is available at the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SQLAlchemy session* *transaction*: [https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml](https://docs.sqlalchemy.org/en/20/orm/session_transaction.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
