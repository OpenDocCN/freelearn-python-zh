- en: Chapter 8. Integration and System Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the tools, techniques, and practices we''ve discussed so far, we''ve
    still only been been thinking about testing units: the smallest, meaningfully
    testable pieces of code. It''s time to expand the focus, and start testing code
    that incorporates multiple units.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That means we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Think about what integration testing and system testing actually are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to identify testable multi-unit segments of a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the tools we've learned in order to create tests for these segments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to integration testing and system testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing is the process of checking whether the units of our program
    work together properly. At this stage, thanks to our unit tests, we can assume
    that each unit works as expected in isolation, and we're kicking the tests up
    to a new level of complexity. It's not practical to start the process with integration
    testing because, if the units don't work, the integration won't work either, and
    it will be harder to track down the problems. Once the units are solid, though,
    it's necessary to test that the things we build out of them also work. The interactions
    can be surprising.
  prefs: []
  type: TYPE_NORMAL
- en: While you're doing integration testing, you'll be putting the units together
    into bigger and bigger collections, and testing these collections. When your integration
    tests expand to cover the entirety of your program, they become system tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trickiest part of integration testing is choosing which units to integrate
    into each test, so that you always have a solid base of code that you can believe
    in: a place to stand, while you pull in more code.'
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on an integration order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to work through an exercise that will help you with the process
    of deciding where to put the boundaries of integration tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a piece of paper or a graphics program, write down names or representations
    for each of the units in the time planner project from [Chapter 7](ch07.html "Chapter 7. Test-driven
    Development Walk-through"), *Test-driven Development Walk-through*. Group the
    methods of each class together. Being part of the same class is an obvious relationship
    between units, and we'll take advantage of this. The `==` symbol here represents
    the Python `==` operator, which invokes the `__eq__` method on an object:![Deciding
    on an integration order](img/3211OS_08_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now draw arrows between units that are supposed to directly interact with each
    other, from the caller to the callee. Laying everything out in an orderly fashion,
    as in step 1, can actually make this harder, so feel free to move the classes
    around to help the lines make sense:![Deciding on an integration order](img/3211OS_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw circles around each class and each pair of classes connected by at least
    one line:![Deciding on an integration order](img/3211OS_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue the process by drawing circles around overlapping pairs of circles,
    until there are only three circles left. Circle a pair of them, and then put one
    more big circle around the whole mess:![Deciding on an integration order](img/3211OS_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, to decide which integration tests to write first, we just have to look
    at the number of circles surrounding all parts of it. The more deeply nested the
    circle that contains every unit involved in an integration test is, the sooner
    we write that test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we just did is a way to visualize and solidify the process of building
    integration tests. While it's not critical to actually draw the lines and circles,
    it's useful to follow the process in your head. For larger projects, a lot can
    be gained from actually drawing the diagrams. When you see the diagram, the next
    correct step tends to jump right out at you—especially if you use multiple colors
    to render the diagram—where it might otherwise be hidden behind the complexity
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Automating integration tests and system tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only real difference between an integration test and a unit test is that,
    in an integration test, you can break the code being tested into smaller meaningful
    chunks; in a unit test, however, if you divided the code any more, it wouldn't
    be meaningful. For this reason, the same tools that help you automate unit testing
    can be applied to integration testing. Since system testing is really the highest
    level of integration testing, the tools can be used for that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The role of `doctest` in integration testing tends to be fairly limited: doctest''s
    real strengths are in the early part of the development process. It''s easy for
    a testable specification to stray into integration testing—as said before, that''s
    fine as long as there are unit tests as well, but after that it''s likely that
    you''ll prefer `unittest` and Nose for writing your integration tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests need to be isolated from each other. Even though they contain
    multiple interacting units within themselves, you still benefit from knowing that
    nothing outside the test is affecting it. For this reason, `unittest` is a good
    choice for writing automated integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests for the time planner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The integration diagram only provides a partial ordering of the integration
    tests, and there are several tests that could be the first one we write. Looking
    at the diagram, we can see that the `Status` and `Activity` classes are at the
    end of a lot of arrows, but not at the beginning of any. This makes them particularly
    good places to start writing integration tests, because it means that they don't
    call on anything outside themselves to operate. Since there's nothing to distinguish
    one of them as a better place to start than the other, we can choose between them
    arbitrarily. Let's start with `Status`, and then do `Activity`. We're going to
    write tests that exercise the whole class. At this low level, the integration
    tests will look a lot like the unit tests for the same class, but we're not going
    to use mock objects to represent other instances of the same class. We will use
    real instances. We're testing whether the class correctly interacts with itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test code for `Status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the test code for `Activity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at our diagram, we can see that the next level out from either `Status`
    or `Activity` represents the integration of these classes with the `Schedule`
    class. Before we write this integration, we ought to write any tests that involve
    the `Schedule` class interacting with itself, without using mock objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that the interactions within the `Schedule` class have been tested, we can
    write tests that integrate `Schedule` with either `Status` or `Activity`. Let's
    start with `Status`, then do `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the tests for `Schedule` and `Status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the tests for the interactions between real `Schedule` and `Activity`
    instances. Due to the similarity between `Activity` and `Status`, the tests are,
    not surprisingly, structured similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All right, it''s finally time to put `Schedule`, `Status`, and `Activity` together
    in the same test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to pull in is the `File` class but, before we integrate
    it with the rest of the system, we need to integrate it with itself and check
    its internal interactions without using mock objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write tests that integrate `Schedules` and `File`. Notice that,
    for this step, we still aren''t involving `Status` or `Activity`, because they''re
    outside the oval. We''ll use mock objects in place of them, for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve built our way up to the outermost circle now, which means it''s time
    to write tests that involve the whole system with no mock objects anywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've just integrated our whole code base, progressively constructing larger
    tests until we had tests encompassing the whole system. The whole time, we were
    careful to test one thing at a time. Because we took care to go step-by-step,
    we always knew where the newly discovered bugs originated, and we were able to
    fix them easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of which, if you were to run the tests for yourself while building
    this code structure, you would notice that some of them fail. All three of the
    failures point to the same problem: there''s something wrong with the persistence
    database. This error doesn''t show up in the unit tests for the `File` class,
    because it''s only visible on a larger scale, when the database is used to communicate
    information between units.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the error reported by the `test_file.py` tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The changes to the database aren't being committed to the file, and so they
    aren't visible outside the transaction where they were stored. Not testing the
    persistence code in separate transactions was not an oversight, but that's exactly
    the sort of mistake that we expect integration testing to catch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix the problem by altering the `store_object` method of the `File`
    class in `persistence.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another point of interest is the interaction between `pickle` and mock objects.
    There are a lot of things that mock objects do well, but accepting pickling is
    not one of them. Fortunately, that''s relatively easy to work around is demonstrated
    in test integrating `Schedule` and `File`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The trick here is not really very tricky. We've just told the mock objects what
    return value to use for calls to the `__reduce__` method. It so happens that the
    pickle dumping functions call `__reduce__` to find out whether an object needs
    special handling when being pickled and unpickled. We told it that it did, and
    that it should call the `unpickle_mocked_task` function to reconstitute the mock
    object during unpickling. Now, our mock objects can be pickled and unpickled as
    well as the real objects can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another point of interest in the tests for `Schedule` and `File` is the `tearDown`
    test fixture method. The `tearDown` method will delete a database file, if it
    exists, but won''t complain if it doesn''t. The database is expected to be created
    within the test itself, and we don''t want to leave it lying around; however,
    if it''s not there, it''s not a test fixture error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A lot of the test code in this chapter might seem redundant to you. That's because,
    in some sense, it is. Some things are repeatedly checked in different tests. Why
    bother?
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for the redundancy is that each test is supposed to stand alone.
    We're not supposed to care what order they run in, or whether any other tests
    even exist. Each test is self-contained; thus, if it fails, we know exactly what
    needs to be fixed. Because each test is self-contained, some foundational things
    end up getting tested multiple times. In the case of this simple project, redundancy
    is even more pronounced than it would normally be.
  prefs: []
  type: TYPE_NORMAL
- en: Whether it's blatant or subtle, though, the redundancy isn't a problem. The
    so-called **Don't Repeat Yourself** (**DRY**) principle doesn't particularly apply
    to tests. There's not much downside to having something tested multiple times.
    This is not to say that it's a good idea to copy and paste tests, because it's
    very much not. Don't be surprised or alarmed to see similarities between your
    tests, but don't use that as an excuse. Every test that checks a particular thing
    is a test that needs to be changed if you change that thing, so it's still best
    to minimize redundancy where you can.
  prefs: []
  type: TYPE_NORMAL
- en: Check yourself – writing integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try answering the following questions to check about integration tests yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Which integration tests do you write first?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: The ones in the smallest circles, especially if they don''t have any
    lines pointing from themselves to other circles. Put another way, write the most
    independent tests first.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What happens when you have a large chunk of integrated code, but the next section
    you need to pull in doesn't have any integration tests at all?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: Start from the smallest circles involving that code, and build up step-by-step
    until you''re ready to integrate it with your earlier code.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What's the point of writing tests that check the integration of a chunk of code
    with itself?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: When we were doing unit testing, even other instances of the same class
    were mocked, as were other methods of the same instance when it was reasonable
    to do so; we were concerned that this code did what it was supposed to, without
    involving anything else. Now that we''re doing integration testing, we need to
    test the instances of the same class that interact correctly with each other,
    or with themselves when they''re allowed to retain a state from one operation
    to the next. The two kinds of tests cover different things, so it makes sense
    that we would need both.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is a system test and how do system tests relate to integration tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Answer: A system test is the final stage of integration testing. It''s a test
    that involves the whole code base.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the process of building from a foundation
    of unit tests into a set of tests that cover the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered how to draw an integration diagram. We learned how
    to interpret an integration diagram to decide in what order to build the tests
    and also learned which tools to use and how to use them to write the integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about integration testing, we're ready to introduce a
    number of other useful testing tools and strategies, which is the topic of the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
