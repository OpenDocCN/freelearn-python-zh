- en: Chapter 4. Kivy Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：Kivy网络
- en: Previously, we talked about trade-offs such as narrowing the application compatibility
    while aiming to broaden its feature set, for example, an Android-only application
    using the native API to do the heavy lifting. Now, let's explore the opposite
    extreme and build an app based on uncompromising, universally available functionality—networking.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了在扩展功能集的同时缩小应用兼容性的权衡，例如，仅使用原生API进行重负载处理的Android应用。现在，让我们探索相反的极端，并基于不妥协、普遍可用的功能——网络——来构建一个应用。
- en: In this chapter, we are going to build a Chat app, which is similar in concept
    to an **Internet Relay Chat** (**IRC**), but much simpler.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个聊天应用，其概念与**互联网中继聊天**（**IRC**）类似，但更加简单。
- en: While certainly not a replacement for enterprise-scale behemoths like Skype,
    by the end of this chapter, our little app will support multi-user messaging over
    the Internet. This is sufficient for small and friendly groups of people.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的小应用当然不能取代像Skype这样的企业级巨无霸，但到本章结束时，我们的应用将支持互联网上的多用户消息传递。这对于小型友好群体来说已经足够了。
- en: Being friendly is actually a requirement, as we're intentionally simplifying
    things by not implementing authentication. This means that users are able to easily
    impersonate each other. Tweaking the application to sustain hostile environments
    and catastrophic events (such as a political debate) is left for you to do, if
    you feel particularly adventurous.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 友好实际上是一个要求，因为我们有意简化事情，没有实现身份验证。这意味着用户可以轻易地模仿彼此。调整应用程序以适应敌对环境和灾难性事件（如政治辩论）的任务留给你去完成，如果你特别有冒险精神的话。
- en: We're also aiming at the widest possible compatibility, at least on the server
    side; you will be able to use even **Telnet** to send and receive messages. While
    not as pretty as graphical Kivy apps, Telnet runs perfectly fine in Windows 95
    and even MS-DOS. Chat with dinosaurs!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还旨在实现尽可能广泛的兼容性，至少在服务器端；你甚至可以使用**Telnet**发送和接收消息。虽然不如图形Kivy应用那么美观，但Telnet在Windows
    95甚至MS-DOS上运行得很好。与恐龙聊天吧！
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To be more historically accurate, the Telnet protocol was standardized in 1973,
    so it even predates the 8086 CPU and the x86 architecture. MS-DOS is much more
    modern in comparison, and Windows 95 is practically the future of computing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更准确地反映历史，Telnet协议是在1973年标准化的，因此它甚至早于8086 CPU和x86架构。相比之下，MS-DOS要现代得多，而Windows
    95几乎可以说是计算的未来。
- en: 'The following important topics will be covered in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下重要主题：
- en: Writing and testing a custom server in Python, using the **Twisted** framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python编写和测试自定义服务器，采用**Twisted**框架
- en: Developing a couple of client apps on different levels of abstraction, from
    simple terminal program using raw sockets to an event-driven Twisted client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同抽象级别上开发几个客户端应用，从使用原始套接字的简单终端程序到事件驱动的Twisted客户端
- en: Using Kivy `ScreenManager` to better organize the application UI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kivy `ScreenManager`更好地组织应用UI
- en: Employing a `ScrollView` container to efficiently present lengthy widgets on
    the screen
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ScrollView`容器有效地在屏幕上展示长文本小部件
- en: Our application will feature the centralized, client-server architecture; such
    topology is very common on the Internet, and many websites and applications work
    this way. As you will see shortly, it's also rather easy to implement as opposed
    to a decentralized, peer-to-peer network.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将采用集中式、客户端-服务器架构；这种拓扑在互联网上非常常见，许多网站和应用都是这样工作的。您很快就会看到，与去中心化、点对点网络相比，实现起来也相当简单。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the purposes of this chapter we don't differentiate a **local area network**
    (**LAN**) from the Internet, as it's largely irrelevant at this level of abstraction.
    However, note that deploying your application for large-scale consumption on the
    Internet, if done properly, requires knowledge in many additional areas, from
    setting up a secure web server and configuring the firewall to making the code
    scale across many processor cores and even several physical machines. In practice
    this may be less scary than it sounds, but still constitutes a nontrivial endeavor
    per se.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们不区分**局域网**（**LAN**）和互联网，因为在抽象的这一层，这基本上是不相关的。然而，请注意，如果正确部署您的应用程序以供互联网大规模消费，这需要许多额外的知识，从设置安全的Web服务器和配置防火墙到使代码跨多个处理器核心甚至多台物理机器扩展。在实践中，这可能没有听起来那么可怕，但本身仍然是一项非同小可的任务。
- en: Writing the chat server
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写聊天服务器
- en: Let's start the development with the server-side code so that we have an endpoint
    to connect to before we begin writing the client. For this, we'll use an excellent
    **Twisted** framework that reduces many common, low-level networking tasks to
    a small number of lines of clean, relatively high-level Python code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从服务器端代码开始开发，这样在我们开始编写客户端之前就有了一个连接的端点。为此，我们将使用一个优秀的**Twisted**框架，该框架将许多常见的低级别网络任务简化为少量干净、相对高级的Python代码。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Compatibility notice**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**兼容性通知**'
- en: Twisted doesn't support Python 3 at the time of writing, so we'll assume that
    all the following Python code is intended to run on Python 2.7\. It should be
    easy to port it to Python 3 eventually, as no deliberately incompatible design
    decisions are made. (On a related note, we'll also completely ignore Unicode-related
    issues, because resolving them properly depends on Python version.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Twisted在撰写本文时不支持Python 3，因此我们假设以下所有Python代码都是针对Python 2.7编写的。最终应该很容易将其移植到Python
    3，因为没有任何故意的不兼容设计决策。（相关地，我们还将完全忽略与Unicode相关的问题，因为正确解决这些问题取决于Python版本。）
- en: Twisted is an event-driven, low-level server framework, not unlike **Node.js**
    (in fact, Node.js design was influenced by Twisted). Quite similar to Kivy, the
    event-driven architecture means that we don't structure the code as a loop; instead,
    we bind a number of event listeners to the events that we deem useful for our
    app. Hardcore, low-level networking, such as handling incoming connections and
    working with raw data packets, is performed by Twisted automatically as soon as
    we start the server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Twisted是一个事件驱动的、低级别的服务器框架，与**Node.js**（实际上，Node.js的设计受到了Twisted的影响）非常相似。与Kivy类似，事件驱动的架构意味着我们不会将代码结构化为循环；相反，我们将多个事件监听器绑定到我们认为对我们应用有用的那些事件上。硬核、低级别的网络操作，如处理传入连接和与原始数据包一起工作，由Twisted在启动服务器时自动执行。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to install Twisted on your machine, run the usual command in the terminal:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在你的机器上安装Twisted，请在终端中运行常规命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are a few caveats:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意：
- en: Chances are, you'll need to become root (administrator or "super user") to perform
    a system-wide installation. If you're on Mac OS or Linux, try prefixing the command
    with `sudo` if you receive an **Access Denied** error message.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很可能，你需要成为root（管理员或“超级用户”）才能执行系统范围内的安装。如果你使用Mac OS或Linux，当收到**访问被拒绝**的错误消息时，尝试在命令前加上`sudo`。
- en: In the event you don't have pip installed, try the **easy_install twisted**
    command (or **easy_install pip**, for that matter).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有安装pip，请尝试使用**easy_install twisted**命令（或者**easy_install pip**）。
- en: Alternatively, please follow the official pip installation guide at [https://pip.pypa.io/en/latest/installing.html](https://pip.pypa.io/en/latest/installing.html).
    This covers Windows too.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，请遵循官方pip安装指南[https://pip.pypa.io/en/latest/installing.html](https://pip.pypa.io/en/latest/installing.html)。这也涵盖了Windows。
- en: The protocol definition
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议定义
- en: Let's talk about the protocol that we are going to use to communicate with the
    chat server. Since the application is going to be very unsophisticated, instead
    of using a full-fledged extensive protocol such as XMPP, we're going to create
    our own barebones protocol containing only the bits we need.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论我们将要使用的与聊天服务器通信的协议。由于应用程序将非常简单，我们不会使用像XMPP这样的完整协议，而是将创建一个仅包含我们需要的位的裸骨协议。
- en: In the context of this tutorial, there are just two messages passed from client
    to server that we want to implement on the protocol level—connecting to server
    (entering the chatroom), and actually talking to other users. Everything that
    the server sends back to the client is rendered; no service events originate on
    the server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程的上下文中，我们只想在协议级别实现从客户端到服务器的两条消息——连接到服务器（进入聊天室）以及实际上与其他用户交谈。服务器发送回客户端的所有内容都会被渲染；没有服务事件在服务器上发起。
- en: Our protocol will be textual, like many other application-level protocols, including
    the universally used HTTP. This is a very practical property because it makes
    debugging and related activities easier. Text protocols are also generally considered
    more extensible and future-proof, as opposed to binary ones. The downside of plain
    text is mainly its size; binary enumeration tends to be more compact. This is
    largely irrelevant in this case and can be easily mitigated anyway using compression
    (this is exactly what many servers do in case of HTTP).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的协议将是文本格式，类似于许多其他应用层协议，包括广泛使用的HTTP。这是一个非常实用的特性，因为它使得调试和相关活动更加容易。与二进制协议相比，文本协议通常被认为更具可扩展性和未来适应性。纯文本的缺点主要是其大小；二进制枚举通常更紧凑。在这种情况下，这基本上是不相关的，而且可以通过压缩轻松缓解（这正是许多服务器在HTTP情况下所做的事情）。
- en: 'Now let''s review the individual messages that comprise our application''s
    protocol:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾构成我们应用程序协议的各个消息：
- en: Connecting to the server communicates no other information except the fact that
    the user is now in the chat room, so we'll send just the word `CONNECT` every
    time. This message is not parameterized.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到服务器不会传达除用户现在在聊天室的事实之外的其他信息，因此我们将每次只发送单词`CONNECT`。这条消息没有参数化。
- en: 'Talking in the chat room is more interesting. There are two parameters: the
    nickname and the text message itself. Let''s define the format of such message
    as `A:B`, where `A` is the nickname (as a direct consequence, the nickname can''t
    contain the colon `:` character).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在聊天室里说话更有趣。有两个参数：昵称和文本消息本身。让我们定义这种消息的格式为`A:B`，其中`A`是昵称（作为直接后果，昵称不能包含冒号`:`字符）。
- en: 'From this specification, we can derive an effective algorithm (pseudo code):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个规范中，我们可以推导出一个有效的算法（伪代码）：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Testing for the same user is meant to cut the unnecessary transmission of users'
    own messages back to them (echo).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试相同用户是为了减少用户自己的消息回传给他们的不必要的传输（回声）。
- en: The server source code
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器源代码
- en: 'With the help of the Twisted framework, our pseudocode can be translated into
    Python pretty much literally. The following listing contains the full source code
    of our `server.py` application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twisted框架的帮助下，我们的伪代码可以几乎直接地翻译成Python。以下列表包含我们`server.py`应用程序的完整源代码：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The principle of operation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作原理
- en: 'This is the control flow outline that will help you understand exactly how
    our server works:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是帮助你理解我们的服务器是如何工作的控制流程概述：
- en: The last line, `reactor.run()`, starts the `ChatFactory` server that listens
    on port 9096
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一行，`reactor.run()`，启动监听端口9096的`ChatFactory`服务器
- en: When the server receives input, it invokes the `dataReceived()` callback
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器接收到输入时，它调用`dataReceived()`回调
- en: The `dataReceived()` method implements the pseudocode from the protocol section,
    sending messages to other connected clients as required
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataReceived()`方法实现了协议部分的伪代码，根据需要向其他已连接客户端发送消息'
- en: The set of connections to clients is called `transports`. We're adding the current
    transport, `self.transport`, to the set unconditionally, because in the case of
    existing element that's a no-op, so why bother.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端连接的集合被称为`transports`。我们无条件地将当前传输`self.transport`添加到集合中，因为在现有元素的情况下，这是一个无操作，为什么要费那个劲。
- en: 'The rest of the listing follows the algorithm exactly. As a result, every connected
    user except for the one who sent the original message will receive a notification,
    `<` **username** `> says: <` **message text** `>`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '列表中的其余部分严格遵循算法。因此，除了发送原始消息的用户之外，每个已连接的用户都将收到通知，`<` **用户名** `> says: <` **消息文本**
    `>`.'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Notice how we didn''t actually check that the connect message says `CONNECT`.
    That''s an example of closely following the *network robustness* principle, coined
    by Jon Postel in the TCP specification in 1980: *be conservative in what you send,
    and liberal in what you accept*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们实际上并没有检查连接消息是否说`CONNECT`。这是紧密遵循乔恩·波斯尔在1980年TCP规范中提出的*网络鲁棒性*原则的例子：*发送时要保守，接受时要宽容*。
- en: In addition to simplifying the code in this case, we're also gaining an option
    for a forward compatibility. Let's say that in the future release of the client,
    we've added a new message to the protocol, namely the imaginary `WHARRGARBL` message
    that does, according to its name, something truly amazing. Instead of crashing
    due to receiving a malformed message (in this case, because of version mismatch),
    an old revision of the server will just ignore such messages and continue functioning.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简化本例中的代码外，我们还获得了一个向前兼容性的选项。假设在未来客户端的版本中，我们向协议中添加了一条新消息，即名为`WHARRGARBL`的虚构消息，根据其名称，它确实做了一些真正令人惊叹的事情。而不是因为收到格式不正确的消息（在这种情况下，因为版本不匹配）而崩溃，旧版本的服务器将简单地忽略这些消息并继续运行。
- en: Specifically this aspect—compatibility between versions—can be easily handled
    using a number of strategies. However, there are also more difficult problems
    when it comes to networking and especially public networks, including malicious
    users trying to defeat your system and bring it down on purpose. So, practically,
    there is no such thing as exaggerated server stability.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这个方面——版本之间的兼容性——可以通过多种策略轻松处理。然而，在涉及网络，尤其是公共网络时，也存在一些更困难的问题，包括恶意用户试图破坏你的系统并故意使其崩溃。因此，实际上并不存在过度夸大的服务器稳定性。
- en: Testing the server
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试服务器
- en: 'Run the server as you usually run any Python program:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常运行任何Python程序的方式运行服务器：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command shouldn't produce any visible output. The server just sits there,
    waiting quietly for clients to connect. However, there are no client programs
    in the known universe that can speak this protocol, since we've made it all up
    about page and a half ago. How can we make sure that the server works?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令不应产生任何可见的输出。服务器只是静静地坐着，等待客户端连接。然而，在已知的宇宙中没有任何客户端程序能够使用这个协议，因为我们大约在一页半之前就编造了它。我们如何确保服务器能正常工作？
- en: Thankfully, this chicken and egg problem is so common in this field that there
    are many useful tools to do just that—send arbitrary bytes to any server, and
    receive and display arbitrary bytes that server sends back.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种“鸡生蛋，蛋生鸡”的问题在这个领域非常普遍，因此有许多有用的工具可以做到这一点——向任何服务器发送任意字节，并接收和显示服务器发送回的任意字节。
- en: One of the standard programs suitable for fiddling with servers that use text
    protocols is Telnet. Like many "old school" Unix-style utilities, Telnet is a
    command-line program that can be used both interactively and as part of larger
    batch (shell) script.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于篡改使用文本协议的服务器的标准程序之一是Telnet。像许多“老式”Unix风格的实用程序一样，Telnet是一个既可以用作交互式程序，也可以作为更大批处理（shell）脚本一部分的命令行程序。
- en: 'Most operating systems come with the `telnet` command preinstalled. If it isn''t,
    chances are that you''re on MS Windows version 7 or greater. In this case, you
    can go to **Control Panel** | **Programs and Features** | **Turn Windows features
    on or off**,as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都预装了`telnet`命令。如果没有，那么你可能正在使用Windows 7或更高版本。在这种情况下，你可以按照以下截图所示，转到**控制面板**
    | **程序和功能** | **启用或关闭Windows功能**：
- en: '![Testing the server](img/B01620_04_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![测试服务器](img/B01620_04_02.jpg)'
- en: 'Then, make sure that the **Telnet Client** checkbox is on, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，确保**Telnet客户端**复选框已勾选，如下所示：
- en: '![Testing the server](img/B01620_04_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![测试服务器](img/B01620_04_03.jpg)'
- en: 'Telnet accepts two arguments: host name and port number of the server to connect
    to. In order to connect to the chat server with telnet, you''ll need to start
    `server.py` first, and then in another terminal run:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet接受两个参数：要连接的服务器的名称和端口号。为了使用telnet连接到聊天服务器，你首先需要启动`server.py`，然后在另一个终端中运行：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Alternatively, you can use `localhost` for host name on most systems, as this
    is synonymous with `127.0.0.1`; both denote the current machine.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在大多数系统中使用`localhost`作为主机名，因为这等同于`127.0.0.1`；两者都表示当前机器。
- en: 'If all went well, you will have an interactive session open where every line
    you type is sent to the server. Now, using the chat protocol that we discussed
    earlier, you can communicate with the server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将打开一个交互式会话，你输入的每一行都会发送到服务器。现在，使用我们之前讨论的聊天协议，你可以与服务器进行通信：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There will be no output, because we programmed the server in such a way that
    it doesn't echo messages back to their original author—that will be wasteful.
    So, let's open yet another terminal (and a Telnet session) so that we have two
    simultaneously connected users.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将不会有输出，因为我们以这种方式编程服务器，使其不会将消息回显给原始作者——这将是一种浪费。所以，让我们再打开另一个终端（以及一个Telnet会话），这样我们就有两个同时连接的用户。
- en: 'This is what the chat session looks like when everything is functioning properly:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切正常时，聊天会话看起来是这样的：
- en: '![Testing the server](img/B01620_04_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![测试服务器](img/B01620_04_04.jpg)'
- en: An interactive chat over the network at its finest
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的交互式聊天达到最佳状态
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If for some reason, technical or otherwise, you cannot use Telnet on your system,
    please don't feel particularly bad about this, as this test is not required to
    successfully complete the tutorial.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，无论是技术原因还是其他原因，您无法在您的系统上使用Telnet，请不要对此感到特别难过，因为这项测试不是成功完成教程所必需的。
- en: 'However, here''s some (very personal, intimate even) advice that is more related
    to your career than to the topic of this book: do yourself a favor and get a Mac
    OS or Linux box, or maybe use dual-boot on the same machine. These Unix-like operating
    systems are much better suited for software development than Windows, and the
    productivity boost is totally worth the inconvenience of getting used to a new
    environment.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一些（非常个人化，甚至可以说是亲密的）建议，这些建议与您的职业比与本书的主题更相关：为自己做点好事，获取一个Mac OS或Linux系统，或者也许在同一台机器上使用双启动。这些类Unix操作系统比Windows更适合软件开发，而且生产力的提升完全值得适应新环境的不便。
- en: 'With this we can conclude that our server works: two Telnet windows are talking
    just fine. Now that we''re done with the backend, let''s build a cross-platform
    GUI chat client.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们可以得出结论：我们的服务器正在正常工作：两个Telnet窗口正在良好地通信。现在后端工作已经完成，让我们构建一个跨平台的GUI聊天客户端。
- en: Screen manager
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕管理器
- en: 'Let''s begin the UI development with a new concept, namely screen management.
    Our application at hand, the chat client, is a fitting example. There will be
    two application states with different UI that are completely separate from one
    another:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个新概念开始UI开发，即屏幕管理。我们手头的应用程序，即聊天客户端，是一个合适的例子。将会有两个应用程序状态，具有不同的UI，彼此完全独立：
- en: The login screen where the user enters the hostname to connect to and the desired
    nickname:![Screen manager](img/B01620_04_05.jpg)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录屏幕，用户在此输入要连接的主机名和所需的昵称：![屏幕管理器](img/B01620_04_05.jpg)
- en: The chatroom screen, where the actual conversation takes place:![Screen manager](img/B01620_04_06.jpg)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天室屏幕，实际对话发生的地方：![屏幕管理器](img/B01620_04_06.jpg)
- en: Conceptually, these are the application states of the Chat app's frontend.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这些都是聊天应用程序前端的应用程序状态。
- en: A straightforward approach to such UI separation will amount to managing the
    visible and hidden controls depending on some variable that holds the current
    desired UI state. This gets cumbersome very quickly as the number of widgets grow,
    and the boilerplate code isn't exactly fun to write anyway.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的UI分离方法将涉及根据某个变量管理可见和隐藏的控件，该变量持有当前所需的UI状态。当小部件数量增加时，这会变得非常繁琐，而且样板代码本身就不太有趣。
- en: That's why the Kivy framework provides us with a container widget specifically
    tailored for the task, `ScreenManager`. Additionally, `ScreenManager` supports
    short animations to visualize the screen change, with a number of prebuilt transitions
    to choose from. It can be used from a Kivy language file in a completely declarative
    manner without touching the Python code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，Kivy框架为我们提供了一个专门针对此任务定制的容器小部件，即`ScreenManager`。此外，`ScreenManager`支持短动画来可视化屏幕切换，并提供多种预构建的过渡效果可供选择。它可以完全声明性地从Kivy语言文件中使用，而不需要接触Python代码。
- en: 'Let''s do just that. Add the following code in the `chat.kv` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做。在`chat.kv`文件中添加以下代码：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the basic structure of the program: we have a `ScreenManager` at the
    root and a `Screen` container for every UI state we want to have (the first one
    will be displayed by default). Inside the `Screen` is the usual UI: layouts, buttons,
    and everything we''ve seen so far. We''ll get to it in a bit.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的基本结构：我们在根目录有一个`ScreenManager`，为每个我们想要的UI状态（第一个将默认显示）有一个`Screen`容器。在`Screen`内部是通常的UI：布局、按钮以及我们迄今为止看到的一切。我们很快就会接触到它。
- en: The code we just saw also includes screen-changing buttons, one per `Screen`
    instance. In order to switch the application state, we need to assign the desired
    screen's name to the `current` property of `ScreenManager`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的代码还包括屏幕切换按钮，每个`Screen`实例一个。为了切换应用程序状态，我们需要将所需屏幕的名称分配给`ScreenManager`的`current`属性。
- en: Customizing the animation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义动画
- en: 'As stated previously, the brief animation that happens when changing screens
    can be customized. Kivy provides a number of such animations out of the box, found
    inside the `kivy.uix.screenmanager` package:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当切换屏幕时发生的简短动画可以自定义。Kivy提供了多种此类动画，位于`kivy.uix.screenmanager`包中：
- en: '| Transition class name | Visual effect |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 过渡类名称 | 视觉效果 |'
- en: '| --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `NoTransition` | No animation, just displays the new screen immediately.
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `NoTransition` | 没有动画，立即显示新屏幕。|'
- en: '| `SlideTransition` | Slides the new screen. Pass `''left''` (the default),
    `''right''`, `''up''`, or `''down''` to select the direction of the effect. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `SlideTransition` | 滑动新屏幕。传递`''left''`（默认）、`''right''`、`''up''`或`''down''`以选择效果的方向。|'
- en: '| `SwapTransition` | In theory, this class simulates the iOS screen-swapping
    animation. The actual effect looks nothing like that though. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `SwapTransition` | 理论上，这个类模拟了iOS屏幕切换动画。但实际效果与理论相差甚远。|'
- en: '| `FadeTransition` | Fades the screen out, then fades it back in. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `FadeTransition` | 淡出屏幕，然后淡入。|'
- en: '| `WipeTransition` | A smooth directional transition using a pixel shader.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `WipeTransition` | 使用像素着色器实现的平滑方向过渡。|'
- en: '| `FallOutTransition` | Shrinks an old screen towards center of the window
    and makes it transparent, revealing the new screen. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `FallOutTransition` | 将旧屏幕缩小到窗口中心并使其透明，从而显示新屏幕。|'
- en: '| `RiseInTransition` | The exact opposite of `FallOutTransition`: grows the
    new screen from the center, overlapping and concealing an old one. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `RiseInTransition` | `FallOutTransition`的完全相反：从中心生长新屏幕，重叠并隐藏旧的一个。|'
- en: 'There''s a small caveat in relation to setting these inside a `.kv` file: the
    transitions aren''t imported by default, so you''ll need to import the ones you
    want to use, using the following syntax (at the top of `chat.kv`):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.kv`文件中设置这些内容有一个小问题：默认情况下不会导入过渡动画，因此您需要使用以下语法（在`chat.kv`的顶部）导入您想要使用的动画：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you can assign it to `ScreenManager`. Note that it''s a Python class instantiation,
    so the parentheses at the end are required:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将其分配给`ScreenManager`。请注意，这是一个Python类实例化，因此结尾的括号是必需的：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Login screen layout
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录屏幕布局
- en: 'What happens inside the login screen, layout-wise, is very similar to the previous
    chapter''s Sound recorder app: a `GridLayout` solves the task of aligning components
    on a grid.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录屏幕内部，布局方面与上一章的录音应用非常相似：一个`GridLayout`解决了在网格上对齐组件的任务。
- en: The only thing that hasn't been used in this book yet is the `TextInput` widget.
    Kivy's text input behaves almost exactly like a button, with the obvious exception
    that you can type text into it. By default, `TextInput` is multiline, so we set
    the `multiline` property to `False` because multiline text inputs don't make much
    sense in the context of this app.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本书尚未使用的是`TextInput`小部件。Kivy的文本输入几乎与按钮的行为完全相同，唯一的区别是您可以在其中输入文本。默认情况下，`TextInput`是多行的，因此我们将`multiline`属性设置为`False`，因为在应用程序的上下文中，多行文本输入没有太多意义。
- en: When running on a device with no physical keyboard attached, Kivy will fall
    back to a virtual onscreen keyboard, just as native apps do.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当在未连接物理键盘的设备上运行时，Kivy将回退到虚拟屏幕键盘，就像原生应用一样。
- en: 'This is the code that implements the login screen layout (in the same Kivy
    language file, `chat.kv`, under `ScreenManager`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现登录屏幕布局的代码（在同一个Kivy语言文件`chat.kv`中的`ScreenManager`下）：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we add two text fields, `Server` and `Nickname`, with corresponding labels,
    and a **Connect** button. The event handler for the button has nothing to do with
    actual networking just yet and merely switches the screen to the chatroom, but
    this will change in the near future.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了两个文本字段，`Server`和`Nickname`，以及相应的标签，还有一个**连接**按钮。按钮的事件处理程序目前与实际的网络无关，只是切换到聊天室，但这种情况将在不久的将来改变。
- en: 'There is one interesting bit of styling needed to make a single-line `TextInput`.
    In addition to setting its `multiline` property to `False`, we want to align the
    text inside vertically in the middle (otherwise, it will stick to the top of the
    control, leaving a large gap at the bottom). We can achieve the proper alignment
    using the padding property like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作单行的`TextInput`，需要一些有趣的样式。除了将其`multiline`属性设置为`False`外，我们还想将文本垂直居中（否则，它将粘在控制的顶部，底部留下很大的间隙）。我们可以使用如下方式使用填充属性来实现正确的对齐：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `padding` line sets both left and right padding to 10, with top and bottom
    computed as *0.5 × (height of the widget − height of one line of text)*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这条`padding`行将左右填充设置为10，上下填充计算为*（小部件高度 - 一行文本高度）× 0.5*。
- en: This is what the resulting screen looks like; it is pretty similar to other
    applications that we've produced during the course of this book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终屏幕的显示效果；它与我们在本书的编写过程中制作的其他应用程序非常相似。
- en: '![Login screen layout](img/B01620_04_07.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![登录屏幕布局](img/B01620_04_07.jpg)'
- en: Chat application's login screen
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天应用登录屏幕
- en: We could start writing code that connects to the server right now, but first
    let's get the primary screen, the chatroom, working. This will allow us to conduct
    meaningful tests right away afterwards.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写连接服务器的代码，但首先让我们让主屏幕，即聊天室，工作起来。这将使我们能够立即进行有意义的测试。
- en: Chatroom screen layout
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聊天室屏幕布局
- en: Next on our list is the chatroom screen. It features a `ScrollView` widget for
    lengthy conversations, and since that's the first time a scrolling widget appears
    in this book, let's take a closer look at how it works.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在我们的列表中是聊天室屏幕。它包含一个用于长篇对话的`ScrollView`小部件，由于这是第一次在这本书中出现滚动小部件，让我们仔细看看它是如何工作的。
- en: 'The simplest `.kv` snippet to produce a scrolling widget is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 生成滚动小部件最简单的`.kv`片段如下：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you add enough text to it so that it overflows the screen, it starts to scroll,
    similar to what you'd expect from a long list of items in iOS or Android.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您添加足够的文本使其溢出屏幕，它就会开始滚动，类似于您在iOS或Android中期望的长列表项。
- en: 'This is how this layout works:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这种布局的工作原理：
- en: We constrain the `text_size` width (first value) of our custom `Label` subclass
    to the widget's available width, and let it choose the height depending on its
    contents by setting the second value to `None`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将自定义`Label`子类的`text_size`宽度（第一个值）限制为小部件的可用宽度，并通过将第二个值设置为`None`让它根据其内容选择高度。
- en: Then, we set the vertical `size_hint` (second value) to `None` to force height
    of the widget to be computed independently of its container. Otherwise, it will
    be limited by the parent element, and thus there will be nothing to scroll.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将垂直`size_hint`（第二个值）设置为`None`，以强制小部件的高度独立于其容器计算。否则，它将被父元素限制，因此将没有可滚动的内容。
- en: Now, we can set the widget's height to be equal to the `texture_size` height
    (note that indexing is zero-based as usual, so the second value is indeed `texture_size[1]`).
    This will force the `ChatLabel` to become larger than the containing widget, `ScrollView`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将小部件的高度设置为等于`texture_size`的高度（请注意，索引通常是零基的，所以第二个值确实是`texture_size[1]`）。这将迫使`ChatLabel`比包含它的`ScrollView`小部件更大。
- en: When the `ScrollView` detects that its child widget is larger than the available
    screen space, scrolling is enabled. It works as usual on mobile, and adds mouse
    wheel support on desktop.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`ScrollView`检测到其子小部件大于可用屏幕空间时，启用滚动。在移动设备上它按常规工作，并在桌面上添加鼠标滚轮支持。
- en: Overscroll modes
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动模式
- en: 'You can also customize the overscroll effect of a `ScrollView` to mimic a behavior
    native to the corresponding platform (which still looks noticeably different from
    native components anyway, despite being similar in concept). At the time of writing,
    the Android-style edge glow isn''t supported out of the box; the available options
    are listed as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以自定义`ScrollView`的滚动回弹效果，以模仿对应平台的原生行为（尽管在概念上相似，但与原生组件相比，仍然看起来明显不同）。截至写作时，Android风格的边缘发光效果不是默认支持的；可用的选项如下：
- en: '`ScrollEffect`: This effect allows you to stop scrolling abruptly when you
    reach the end. This is similar to how desktop programs usually work, so this behavior
    might be desirable if the app in question is intended mostly for desktop.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollEffect`：此效果允许您在到达末尾时突然停止滚动。这与桌面程序通常的工作方式相似，因此如果所讨论的应用程序主要针对桌面，则此行为可能是有吸引力的。'
- en: '`DampedScrollEffect`: This is the default effect. It is similar to the bounce
    back effect found in iOS. This is arguably the best mode for mobile devices.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DampedScrollEffect`：这是默认效果。它与iOS中找到的回弹效果相似。这可能是移动设备上最好的模式。'
- en: '`OpacityScrollEffect`: This effect is similar to `DampedScrollEffect` with
    added transparency when scrolling past the edge of the content.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpacityScrollEffect`：此效果类似于`DampedScrollEffect`，在滚动过内容边缘时增加了透明度。'
- en: To use one of these settings, import it from the `kivy.effects` module and assign
    to the `ScrollView.effect_cls` property, similar to the `ScreenManager` transitions
    just discussed. We aren't going to use this, as `DampedScrollEffect` suits our
    application just fine.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些设置之一，从 `kivy.effects` 模块导入它，并将其分配给 `ScrollView.effect_cls` 属性，类似于刚刚讨论的
    `ScreenManager` 过渡。我们不会使用这个，因为 `DampedScrollEffect` 已经非常适合我们的应用程序。
- en: 'With all of these points in mind, this is what the chatroom screen layout looks
    like (in `chat.kv`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些点，这是聊天室屏幕布局的样子（在 `chat.kv` 中）：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last line, `size_hint`, sets the horizontal proportion of the `Button` widget
    to `0.3`, down from the default of `1`. This makes the **Send** button smaller
    than the message input field.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行，`size_hint`，将 `Button` 小部件的横向比例设置为 `0.3`，低于默认的 `1`。这使得 **发送** 按钮比消息输入字段更小。
- en: 'In order to set the background of the messages area to white, we can use the
    following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将消息区域的背景设置为白色，我们可以使用以下代码：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This draws a white rectangle behind the `ScrollView` unconditionally before
    every other drawing operation takes place. Don''t forget to tweak the `<ChatLabel>`
    class, setting text color to something readable on a light background:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每次其他绘图操作之前无条件地绘制一个白色矩形在 `ScrollView` 后面。别忘了调整 `<ChatLabel>` 类，将文本颜色设置为在浅色背景上可读：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is what we have so far:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了这些：
- en: '![Overscroll modes](img/B01620_04_08.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![滚动模式](img/B01620_04_08.jpg)'
- en: Chatroom screen, devoid of meaningful conversations
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 没有有意义对话的聊天室屏幕
- en: Again, the **Disconnect** button just switches screens without any networking
    going on behind the scenes. This is the next topic actually; as you will see shortly,
    implementing simple network programs in Python is not very different in terms
    of complexity from building a simple user interface with Kivy.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，**断开连接** 按钮只是切换屏幕，而不会在幕后进行任何网络操作。这实际上是下一个主题；正如你很快就会看到的，用 Python 实现简单的网络程序在复杂性方面与用
    Kivy 构建简单的用户界面并没有太大区别。
- en: Bringing the app online
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用上线
- en: This is the interesting part! We are going to establish the connection with
    the server, send and receive messages, and display meaningful output to users.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最有趣的部分！我们将与服务器建立连接，发送和接收消息，并向用户显示有意义的输出。
- en: But first, let's take a look at the minimal, pure-Python implementation of the
    chat client, to see what's going on. This is low-level code using a socket to
    communicate. In practice, using a higher-level abstraction, like Twisted, is almost
    always advised; but if you're not familiar with the underlying concepts, it may
    be hard to grasp what happens in your code behind the scenes, which turns debugging
    into guesswork.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看聊天客户端的最小、纯 Python 实现，看看发生了什么。这是使用套接字进行通信的低级代码。在实际应用中，使用更高层次的抽象，如 Twisted，几乎总是建议的；但如果你不熟悉底层概念，可能很难理解代码背后的实际发生情况，这使得调试变成了猜测。
- en: Building a simple Python client
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建简单的 Python 客户端
- en: In the following listing, we're reading user input from the console using the
    built-in `readline()` function and displaying the output with `print()`. This
    means that using this simple client is not vastly different from using Telnet—the
    UI consists of the exact same plain text in a terminal window—but this time we
    implement it ourselves from scratch using sockets.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们使用内置的 `readline()` 函数从控制台读取用户输入，并使用 `print()` 函数显示输出。这意味着使用这个简单的客户端与使用
    Telnet 并无太大区别——UI 由终端窗口中的相同纯文本组成——但这次我们是自己从头开始使用套接字实现的。
- en: 'We are going to need a number of Python modules, all from the standard library:
    `socket`, `sys` (for `sys.stdin`, standard input file descriptor), and the `select`
    module to implement efficient waiting until the data is available. Assuming a
    new file, let''s call it `client.py`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一些 Python 模块，所有这些模块都来自标准库：`socket`、`sys`（用于 `sys.stdin`，标准输入文件描述符）和 `select`
    模块，以实现高效等待数据可用。假设一个新的文件，让我们称它为 `client.py`：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This program doesn't need external dependencies at all; this is as pure-Python
    as it gets.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序根本不需要外部依赖；这是最纯粹的 Python。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note than on Windows, `select` cannot poll file descriptors the same as sockets
    because of implementation details, so our code will not function correctly. Since
    this is only a demonstration of the low-level networking and not the final product,
    we aren't going to port it to marginal systems.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Windows 上，由于实现细节，`select` 无法像套接字那样轮询文件描述符，因此我们的代码将无法正确运行。由于这只是一个低级网络演示，而不是最终产品，我们不会将其移植到边缘系统。
- en: 'Now, we open the connection to server and do the usual `CONNECT` handshake:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们打开到服务器的连接并执行通常的`CONNECT`握手：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next part in interesting: we wait for data to become available on either
    standard input (meaning that the user entered something), or the `s` socket (meaning
    that the server sent something our way). The waiting is achieved using the `select.select()`
    call:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个有趣的部分：我们等待标准输入（意味着用户输入了某些内容）或`s`套接字（意味着服务器发送了某些内容给我们）上的数据变得可用。等待是通过使用`select.select()`调用来实现的：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, depending on the source of newly available data, we either print it on
    the screen in case of a message received from the server, or send it to the server
    if it's a message from the local user. Again, this is more or less what Telnet
    does, sans error checking.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据新可用数据源的不同，我们要么在收到来自服务器的消息时将其打印到屏幕上，要么将其发送到服务器，如果它是来自本地用户的消息。再次强调，这基本上就是Telnet所做的工作，但没有错误检查。
- en: As you can see, there is nothing inherently impossible or insanely complex in
    low-level networking. But for what it's worth, raw sockets are still quite cumbersome
    to handle and we will illustrate the high-level approach to the same code soon.
    However, this is what happens under the hood of any framework; ultimately, it's
    always sockets doing the heavy lifting, presented under a different sauce of abstractions
    (APIs).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在低级网络中，并没有什么本质上不可能或疯狂复杂的事情。但是，就其价值而言，原始套接字仍然相当难以处理，我们很快将展示相同代码的高级方法。然而，这正是任何框架底层的运作方式；最终，总是套接字在承担重活，只是被不同的抽象（API）所呈现。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that in this tutorial we are not doing extensive error checking on purpose,
    because it will increase the amount of code by the factor of 2-3 and make it unwieldy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个教程中，我们故意没有进行广泛错误检查，因为这会使代码量增加2-3倍，并使其难以控制。
- en: 'There are lots of things that can go wrong over the network; it''s more fragile
    than it''s commonly perceived to be. So if you''re planning to compete with Skype
    *et al.*, be ready to do incredible amounts of error checking and testing: network
    problems such as packet loss and nationwide firewalls, to name a few, will surely
    bite at some point. No matter how well-planned your architecture is, making network
    services highly available is hard.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上可能会出现很多问题；它比人们通常认为的要脆弱得多。所以如果你计划与Skype等软件竞争，准备好进行大量的错误检查和测试：例如，网络问题如数据包丢失和全国范围内的防火墙，肯定会在某个时刻出现。无论你的架构计划多么周密，使网络服务高度可用都是一项艰巨的任务。
- en: Kivy integration with Twisted
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kivy与Twisted的集成
- en: Another reason why our low-level client code is not a good fit for a Kivy application
    is that it relies on its own main loop (the `while 1:` part). It will take some
    work to make this code play well with the event loop that powers Kivy.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的低级客户端代码不适合Kivy应用程序的另一个原因是它依赖于自己的主循环（即`while 1:`部分）。要使这段代码与驱动Kivy的事件循环良好地协同工作，需要做一些工作。
- en: Instead, let's take advantage of the Twisted integration that's distributed
    as a part of Kivy. This also means that the same network library will be used
    on both the client and the server, making the code more uniform across the board.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们利用作为Kivy的一部分分发的Twisted集成。这也意味着相同的网络库将在客户端和服务器上使用，使代码在整个系统中更加统一。
- en: 'The necessary step to make Kivy''s main loop play well with Twisted is to run
    the following code before the Twisted framework is even imported:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Kivy的主循环与Twisted良好地协同工作，需要在导入Twisted框架之前运行以下代码：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code should be at the very beginning of the `main.py` file. This is crucial
    to get right, otherwise everything will cease to function in obscure ways.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该在`main.py`文件的非常开头部分。这是至关重要的，否则一切都将以一种神秘的方式停止工作。
- en: Now, let's implement the chat client using Twisted.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Twisted来实现聊天客户端。
- en: ChatClient and ChatClientFactory
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ChatClient和ChatClientFactory
- en: On the Twisted part, there is surprisingly little to do, since the framework
    takes care of everything that's related to actual networking. These classes are
    used mostly to wire the "moving parts" of the program together.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twisted方面，实际上要做的事情很少，因为框架负责处理与实际网络相关的一切。这些类主要用于将程序的“移动部件”连接起来。
- en: 'The `ClientFactory` subclass, `ChatClientFactory`, will just store the Kivy
    app instance when initialized so that we can pass events to it later. Take a look
    at the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientFactory`子类`ChatClientFactory`在初始化时仅存储Kivy应用程序实例，以便我们可以在以后传递事件给它。请看以下代码：'
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The complementary `ChatClient` class listens to `connectionMade` and `dataReceived`
    events from Twisted and passes them to the Kivy app:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 相对应的`ChatClient`类监听Twisted的`connectionMade`和`dataReceived`事件，并将它们传递给Kivy应用程序：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the ubiquitous `CONNECT` handshake.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意无处不在的`CONNECT`握手。
- en: This is very different from the code utilizing raw sockets, right? At the same
    time, this is very similar to what happens on the server side in `server.py`.
    But, instead of actually handling events, we're just passing them to the `app`
    object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用原始套接字的代码非常不同，对吧？同时，这非常类似于在`server.py`服务器端发生的事情。但是，我们不是真正处理事件，而是将它们传递给`app`对象。
- en: UI integration
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI集成
- en: 'In order to finally see the whole picture, let''s hook the networking code
    up to the UI and write the missing Kivy application class. The following are the
    cumulative updates that need to be applied to the `chat.kv` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最终看到整个画面，让我们将网络代码连接到UI，并编写缺失的Kivy应用程序类。以下是对`chat.kv`文件需要应用的累积更新：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how buttons don't switch screens anymore, instead they call methods on
    `app`, similar to `ChatClient` event handling.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意按钮不再切换屏幕，而是调用`app`上的方法，类似于`ChatClient`事件处理。
- en: 'Having done that, we now need to implement a grand total of five methods that
    are missing from the Kivy application class: two for server-originated events
    that come from Twisted code (`on_connect` and `on_message`), and three more for
    the user interface events (`connect`, `disconnect`, and `send_msg`). This will
    make our Chat app actually usable.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，我们现在需要实现Kivy应用程序类中缺失的五个方法：两个用于来自Twisted代码的服务器端事件（`on_connect`和`on_message`），以及另外三个用于用户界面事件（`connect`、`disconnect`和`send_msg`）。这将使我们的聊天应用程序真正可用。
- en: Application logic of the client
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端应用程序逻辑
- en: 'Let''s begin writing the program logic in roughly the lifecycle order: from
    `connect()` to `disconnect()`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从大致的生命周期顺序开始编写程序逻辑：从`connect()`到`disconnect()`。
- en: 'In the `connect()` method, we pick up the values of **Server** and **Nickname**
    fields, as provided by the user. The nickname is then stored in `self.nick`, and
    the Twisted client connects to the specified host, as shown in the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`connect()`方法中，我们获取用户提供的**服务器**和**昵称**字段的值。然后，昵称被存储在`self.nick`中，Twisted客户端连接到指定的主机，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, the `ChatClient.connectionMade()` function is called, passing control
    to the `on_connect()` method. We will use this event to store the connection in
    `self.conn` and switch screens. As discussed previously, buttons no longer switch
    screens directly; instead, we rely on more specific event handlers like this one:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用`ChatClient.connectionMade()`函数，将控制权传递给`on_connect()`方法。我们将使用这个事件将连接存储在`self.conn`中并切换屏幕。正如之前讨论的，按钮不再直接切换屏幕；相反，我们依赖于更具体的事件处理器，如这个：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now the main part: sending and receiving messages. This is very straightforward
    actually: to send a message we get the message text from the `TextInput`, get
    our nickname from `self.nick`, concatenate them together, and send the resulting
    line to the server. We also echo the same message onscreen and clear the message
    input box. The code is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是主要部分：发送和接收消息。实际上，这非常直接：要发送消息，我们从`TextInput`获取消息文本，从`self.nick`获取我们的昵称，将它们连接起来，然后将生成的行发送到服务器。我们还在屏幕上回显相同的消息并清除消息输入框。代码如下：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Receiving messages is completely trivial; since we don''t proactively keep
    track of them, just put the newly arrived message onscreen followed by a newline,
    and that''s all:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接收消息是完全微不足道的；因为我们没有主动跟踪它们，只需将新到达的消息显示在屏幕上，然后换行，就完成了：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last remaining method is `disconnect()`. It does exactly what it says on
    the tin: closes the connection and performs a general cleanup to return things
    back as they were when the program first started (notably, empties the `chat_logs`
    widget). Finally, it sends the user back to the login screen, so they can jump
    to another server or change nickname. The code is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后剩下的方法是`disconnect()`。它确实做了它所说的：关闭连接并执行一般清理，以便将事物恢复到程序首次启动时的状态（特别是清空`chat_logs`小部件）。最后，它将用户送回登录屏幕，以便他们可以跳转到另一个服务器或更改昵称。代码如下：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With this, our app finally has the ability to send and receive chat messages.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的应用程序终于有了发送和接收聊天消息的能力。
- en: '![Application logic of the client](img/B01620_04_09.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![客户端应用程序逻辑](img/B01620_04_09.jpg)'
- en: Chat app in action
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天应用程序运行中
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Caveats**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意事项**'
- en: During testing, the `server.py` script should obviously be running at all times;
    otherwise, our app won't have an endpoint to connect to. Presently, this will
    result in the app staying on the login screen; in the absence of an `on_connect()`
    call, the user won't get to the chatroom screen.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试期间，`server.py`脚本显然应该始终运行；否则，我们的应用程序将没有连接的端点。目前，这将导致应用程序停留在登录屏幕；如果没有`on_connect()`调用，用户将无法进入聊天室屏幕。
- en: Also, when testing on Android, make sure you enter the correct IP address of
    the server, as it will *not* be `127.0.0.1` anymore—that's always the local machine,
    so on an Android device this will mean that very device and not the computer you're
    working on. Use the `ifconfig` utility (called `ipconfig` on Windows for additional
    confusion) to determine the correct network address of your machine.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当在Android上进行测试时，请确保输入服务器的正确IP地址，因为它将不再是`127.0.0.1`——那总是本地机器，所以在Android设备上这意味着是设备本身而不是你正在工作的电脑。使用`ifconfig`实用程序（在Windows上称为`ipconfig`以增加混淆）来确定你机器的正确网络地址。
- en: Cross-application interoperability
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨应用互操作性
- en: One interesting property of the resulting application (besides the fact that
    it works at all) is that it's compatible with every client mentioned in this chapter.
    Users can connect to the server using Telnet, the pure-Python client, or the Kivy
    UI program—the core functionality is equally available to all of them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应用程序的一个有趣特性（除了它实际上能工作之外）是它与本章中提到的所有客户端都兼容。用户可以使用Telnet、纯Python客户端或Kivy UI程序连接到服务器——核心功能对所有用户都是同样可用的。
- en: 'This is very similar to how the Internet operates: once you have a well-defined
    protocol (such as HTTP), many unrelated parties can develop servers and clients
    that will be ultimately interoperable: web servers, web browsers, search engine
    crawlers, and so on.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这与互联网的运作方式非常相似：一旦你有一个定义良好的协议（如HTTP），许多无关的各方可以开发服务器和客户端，它们最终将是互操作的：Web服务器、Web浏览器、搜索引擎爬虫等等。
- en: A protocol is a higher form of an API, language- and system-independent, like
    a good foundation should be. While not many web developers are familiar with the
    API of, for example, Microsoft Silverlight released in 2007, anyone working in
    the field knows at least the basics of HTTP, documented in 1991\. Such a level
    of ubiquity is nearly impossible to achieve with a library or framework.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 协议是API的一种高级形式，它是语言和系统无关的，就像一个好的基础应该那样。虽然不是很多网络开发者熟悉例如2007年发布的微软Silverlight的API，但在这个领域工作的任何人至少都了解HTTP的基础，它是在1991年记录的。这种普及程度几乎不可能通过库或框架来实现。
- en: Enhancements and eye candy
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强和视觉享受
- en: Now that our chat basically works, we can apply some finishing touches to it,
    for example, improve the chat log presentation. Since the client already displays
    anything that the server sends its way, we can easily use Kivy markup (**BBCode**-like
    markup language, discussed in [Chapter 1](ch01.html "Chapter 1. Building a Clock
    App"), *Building a Clock App*) to style the conversation log.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的聊天基本上已经工作，我们可以给它添加一些最后的修饰，例如改进聊天日志的展示。由于客户端已经显示了服务器发送的所有内容，我们可以轻松地使用Kivy标记（类似于**BBCode**的标记语言，在[第1章](ch01.html
    "第1章. 构建时钟应用")中讨论，*构建时钟应用*)来样式化对话日志。
- en: To do this, let's assign a color to each user and then paint the nickname with
    this color and make it bold. This will help readability and generally look nicer
    than a wall of monochrome plain text.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，让我们为每个用户分配一个颜色，然后用这个颜色绘制昵称并使其加粗。这将有助于可读性，并且通常比单色的纯文本墙看起来更美观。
- en: We'll use the **Flat UI** color palette instead of generating purely random
    colors, because generating substantially different colors that look good when
    used together is by itself not an easy task.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Flat UI**调色板而不是生成纯随机颜色，因为生成看起来搭配在一起时看起来好的显著不同的颜色本身就不是一件容易的事情。
- en: Outgoing messages (those sent by the current user) don't come from the server
    and are added to chat log by the client code instead. So, we will paint the current
    user's nickname with a constant color right on the client.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的消息（由当前用户发送的消息）不是来自服务器，而是由客户端代码添加到聊天日志中。因此，我们将使用恒定颜色直接在客户端上绘制当前用户的昵称。
- en: 'After this update, the final code of the chat server, `server.py`, is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次更新之后，聊天服务器的最终代码`server.py`如下所示：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Given a finite list of colors, we pop one from the end of the list, and then
    insert it back to the front, creating a rotating buffer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个有限的颜色列表，我们从列表的末尾弹出一个颜色，然后将其重新插入到列表的前端，创建一个旋转缓冲区。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you''re familiar with the more advanced `itertools` module from the standard
    library, you can rewrite the code we just saw like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉标准库中的更高级的`itertools`模块，你可以像这样重写我们刚才看到的代码：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And now, we will discuss the bit where we pass the message to the client. The
    markup for the desired effect is very straightforward: `[b][color]Nickname[/color][/b]`.
    The code that makes use of it is equally simple:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论将消息传递给客户端的部分。期望效果的标记非常简单：`[b][color]Nickname[/color][/b]`。利用它的代码同样简单：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The client in `main.py` is also updated to match formatting, as discussed earlier.
    Here, we have a constant color, which is different from the ones assigned by the
    server, so that the current user always stands out. The code is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.py`中的客户端也更新以匹配格式，如前所述。这里有一个常量颜色，与服务器分配的不同，这样当前用户总是突出显示。代码如下：'
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we set the `markup` property to `True` on the conversation log widget,
    `ChatLabel`, as shown in the following code snippet, and we''re (almost) done:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将对话日志小部件`ChatLabel`的`markup`属性设置为`True`，如下面的代码片段所示，我们（几乎）完成了：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, before we solve a problem with this approach (and there''s indeed
    at least one serious problem here), here''s the obligatory resulting screenshot.
    This is how the final conversation screen looks like:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们用这种方法解决问题之前（实际上这里确实至少有一个严重的问题），这是必须的最终截图。这就是最终对话屏幕的样子：
- en: '![Enhancements and eye candy](img/B01620_04_10.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![增强和视觉享受](img/B01620_04_10.jpg)'
- en: Colorful chat logs help readability and generally look better and more "polished"
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 彩色的聊天记录有助于可读性，并且通常看起来更好，更“精致”
- en: Escaping the special syntax
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转义特殊语法
- en: One shortcoming in this code, as mentioned earlier, is that now we have special
    syntax in the protocol that's interpreted in a certain way on the client. Users
    can forge (or just inadvertently use, by pure chance) the BBCode-ish markup, creating
    unwanted visual glitches, such as assigning very large font sizes and unreadable
    colors. For example, if one of the users posts an unclosed `[i]` tag, all following
    text in the chatroom will be italicized. That's pretty bad.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个代码的一个缺点是，现在我们在协议中有特殊的语法，在客户端以某种方式解释。用户可以伪造（或者纯粹偶然地使用，纯粹是巧合）BBCode风格的标记，造成不想要的视觉错误，例如分配非常大的字体大小和难以阅读的颜色。例如，如果某个用户发布了一个未关闭的`[i]`标签，聊天室中所有随后的文本都将被设置为斜体。这相当糟糕。
- en: In order to prevent users from highlighting text in random ways, we need to
    escape all markup that may exist in the message. Fortunately, Kivy provides a
    function to do just that, `kivy.utils.escape_markup`. Bad news is that it's been
    bugged since 2012.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止用户以随机的方式突出显示文本，我们需要转义消息中可能存在的所有标记。幸运的是，Kivy提供了一个函数来完成这项工作，即`kivy.utils.escape_markup`。不幸的是，这个函数自2012年以来就存在bug。
- en: 'There''s a high probability that the function will have been fixed by the time
    you''re reading this book, but for the sake of completeness, here''s an implementation
    that works:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有很高的可能性，当你阅读这本书的时候，这个函数已经被修复了，但为了完整性，这里有一个可行的实现：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this, all characters that are special to Kivy markup are replaced with
    HTML-style character entities, so the markup passed through this function will
    be displayed as is and won't affect the rich text attributes in any way.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，所有对Kivy标记特殊字符都被替换为HTML风格的字符实体，因此通过这个函数传递的标记将按原样显示，并且不会以任何方式影响富文本属性。
- en: We need to call this function in two places, on the server when sending messages
    to clients, and on the client when displaying messages from self (the current
    user).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在两个地方调用这个函数，在服务器发送消息给客户端时，以及在客户端显示来自self（当前用户）的消息时。
- en: 'In `server.py`, the relevant portion of the code looks like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server.py`中，相关代码如下：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `main.py`, the implementation is similar:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.py`中，实现方式类似：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the vulnerability is patched; now users can safely send BBCode markup
    to each other if they choose to do so.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，漏洞已被修复；现在，如果用户选择这样做，他们可以安全地向彼此发送BBCode标记。
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interestingly, this type of bug is also very pervasive in Internet apps. When
    applied to websites, it's called **cross-site scripting** (**XSS**) and allows
    much more damage than merely changing fonts and colors.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这种类型的bug在互联网应用中也非常普遍。当应用于网站时，它被称为**跨站脚本**（**XSS**），它允许造成比仅仅更改字体和颜色更多的损害。
- en: Don't forget to sanitize all user input in all scenarios that may involve commands
    (such as markup, inline scripts, even ANSI escape codes) mixed in with the data;
    neglecting to do so is a sure-fire disaster waiting to happen.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在所有可能涉及命令（如标记、内联脚本，甚至是ANSI转义码）与数据混合的场景中对所有用户输入进行清理；忽视这一点将是一场灾难，只是等待发生。
- en: What's next
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: 'Obviously, this is only the beginning. The implementation at hand still has
    a vast number of deficiencies: user names aren''t enforced to be unique, and there
    is no history and no support for fetching messages that have been sent while other
    parties were offline. Hence, bad network with frequent disconnects will render
    this application mostly unusable.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这仅仅是开始。当前的实施方案仍然存在大量的缺陷：用户名没有被强制要求唯一，没有历史记录，也没有支持在其他人离线时获取已发送的消息。因此，网络状况不佳且频繁断开连接将使这个应用程序基本无法使用。
- en: But what matters is that these points can certainly be addressed, and we already
    have a working prototype. In the start-up world, having a prototype is an attractive
    quality, particularly when raising funds; if you're programming for fun mostly,
    it's even more so, as seeing a working product is greatly motivating (as opposed
    to observing a pile of code that doesn't so much as run yet).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但重要的是，这些问题肯定是可以解决的，我们已经有了一个工作原型。在创业界，拥有一个原型是一个吸引人的特质，尤其是在筹集资金时；如果你主要是为了娱乐而编程，那就更是如此，因为看到一款工作产品是非常有动力的（相比之下，观察一堆尚未运行的代码就没有那么有动力了）。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we saw in this chapter, client-server application development (and generally
    speaking, networking on the application level) isn't necessarily inherently complex.
    Even the low-level code utilizing sockets is quite manageable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，客户端-服务器应用程序开发（以及一般而言，应用层面的网络）并不一定本质上复杂。即使是利用套接字的底层代码也是相当容易管理的。
- en: There are, of course, many gray areas and aspects that are hard to get right
    when writing an app that makes heavy use of the network. Examples of these include
    working around high latency, restoring an interrupted connection, and syncing
    across a large number of nodes (especially peer-to-peer or multi-master, when
    none of the machines have the full dataset).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在编写大量使用网络的程序时，有许多灰色区域和难以处理的问题。这些问题的例子包括处理高延迟、恢复中断的连接，以及在大量节点（尤其是点对点或多主节点，当没有任何机器拥有完整数据集时）上进行同步。
- en: Another relatively new class of network problems is the political one. Lately,
    Internet regulations are being implemented by governments of varying oppressiveness,
    ranging from relatively logical (for example, blocking resources promoting terrorism)
    to completely nonsensical (for example, banning educational sites like Wikipedia,
    major news sites, or video games). This type of connectivity problem is also known
    for high collateral damage, for example, if a **content delivery network** (**CDN**)
    goes down, then many sites that link to it will cease to work properly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类相对较新的网络问题是政治问题。最近，不同压迫程度的政府正在实施互联网法规，从相对合理（例如，封锁推广恐怖主义的资源）到完全荒谬（例如，禁止像维基百科、主要新闻网站或视频游戏这样的教育网站）。这种类型的连接问题也以其高附带损害而闻名，例如，如果**内容分发网络**（**CDN**）崩溃，那么许多链接到它的网站将无法正常工作。
- en: 'However, with careful programming and testing, it is certainly possible to
    overcome every obstacle and deliver a product of exceptional quality to your users.
    Rich Python infrastructure shoulders some of this burden for you, as shown in
    our Chat program: many low-level details are abstracted with the help of Kivy
    and Twisted, two excellent Python libraries.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过仔细的编程和测试，确实有可能克服每一个障碍，并向用户交付一个质量卓越的产品。丰富的Python基础设施为你承担了部分负担，正如我们在聊天程序中所展示的那样：许多底层细节都通过Kivy和Twisted这两个优秀的Python库得到了抽象化。
- en: The possibilities in this field, given the universal accessibility, are nothing
    short of endless. We will discuss and implement a way more interesting use case
    for a networked app in the next chapter, so read on.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到普遍的可用性，这个领域的可能性几乎是无尽的。我们将在下一章讨论和实施一个更有趣的网络应用程序用例，所以请继续阅读。
