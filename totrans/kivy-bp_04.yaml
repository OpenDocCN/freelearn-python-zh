- en: Chapter 4. Kivy Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we talked about trade-offs such as narrowing the application compatibility
    while aiming to broaden its feature set, for example, an Android-only application
    using the native API to do the heavy lifting. Now, let's explore the opposite
    extreme and build an app based on uncompromising, universally available functionality—networking.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to build a Chat app, which is similar in concept
    to an **Internet Relay Chat** (**IRC**), but much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: While certainly not a replacement for enterprise-scale behemoths like Skype,
    by the end of this chapter, our little app will support multi-user messaging over
    the Internet. This is sufficient for small and friendly groups of people.
  prefs: []
  type: TYPE_NORMAL
- en: Being friendly is actually a requirement, as we're intentionally simplifying
    things by not implementing authentication. This means that users are able to easily
    impersonate each other. Tweaking the application to sustain hostile environments
    and catastrophic events (such as a political debate) is left for you to do, if
    you feel particularly adventurous.
  prefs: []
  type: TYPE_NORMAL
- en: We're also aiming at the widest possible compatibility, at least on the server
    side; you will be able to use even **Telnet** to send and receive messages. While
    not as pretty as graphical Kivy apps, Telnet runs perfectly fine in Windows 95
    and even MS-DOS. Chat with dinosaurs!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be more historically accurate, the Telnet protocol was standardized in 1973,
    so it even predates the 8086 CPU and the x86 architecture. MS-DOS is much more
    modern in comparison, and Windows 95 is practically the future of computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following important topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing and testing a custom server in Python, using the **Twisted** framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a couple of client apps on different levels of abstraction, from
    simple terminal program using raw sockets to an event-driven Twisted client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kivy `ScreenManager` to better organize the application UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employing a `ScrollView` container to efficiently present lengthy widgets on
    the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our application will feature the centralized, client-server architecture; such
    topology is very common on the Internet, and many websites and applications work
    this way. As you will see shortly, it's also rather easy to implement as opposed
    to a decentralized, peer-to-peer network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purposes of this chapter we don't differentiate a **local area network**
    (**LAN**) from the Internet, as it's largely irrelevant at this level of abstraction.
    However, note that deploying your application for large-scale consumption on the
    Internet, if done properly, requires knowledge in many additional areas, from
    setting up a secure web server and configuring the firewall to making the code
    scale across many processor cores and even several physical machines. In practice
    this may be less scary than it sounds, but still constitutes a nontrivial endeavor
    per se.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the chat server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start the development with the server-side code so that we have an endpoint
    to connect to before we begin writing the client. For this, we'll use an excellent
    **Twisted** framework that reduces many common, low-level networking tasks to
    a small number of lines of clean, relatively high-level Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Compatibility notice**'
  prefs: []
  type: TYPE_NORMAL
- en: Twisted doesn't support Python 3 at the time of writing, so we'll assume that
    all the following Python code is intended to run on Python 2.7\. It should be
    easy to port it to Python 3 eventually, as no deliberately incompatible design
    decisions are made. (On a related note, we'll also completely ignore Unicode-related
    issues, because resolving them properly depends on Python version.)
  prefs: []
  type: TYPE_NORMAL
- en: Twisted is an event-driven, low-level server framework, not unlike **Node.js**
    (in fact, Node.js design was influenced by Twisted). Quite similar to Kivy, the
    event-driven architecture means that we don't structure the code as a loop; instead,
    we bind a number of event listeners to the events that we deem useful for our
    app. Hardcore, low-level networking, such as handling incoming connections and
    working with raw data packets, is performed by Twisted automatically as soon as
    we start the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to install Twisted on your machine, run the usual command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: Chances are, you'll need to become root (administrator or "super user") to perform
    a system-wide installation. If you're on Mac OS or Linux, try prefixing the command
    with `sudo` if you receive an **Access Denied** error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the event you don't have pip installed, try the **easy_install twisted**
    command (or **easy_install pip**, for that matter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, please follow the official pip installation guide at [https://pip.pypa.io/en/latest/installing.html](https://pip.pypa.io/en/latest/installing.html).
    This covers Windows too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protocol definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's talk about the protocol that we are going to use to communicate with the
    chat server. Since the application is going to be very unsophisticated, instead
    of using a full-fledged extensive protocol such as XMPP, we're going to create
    our own barebones protocol containing only the bits we need.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of this tutorial, there are just two messages passed from client
    to server that we want to implement on the protocol level—connecting to server
    (entering the chatroom), and actually talking to other users. Everything that
    the server sends back to the client is rendered; no service events originate on
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Our protocol will be textual, like many other application-level protocols, including
    the universally used HTTP. This is a very practical property because it makes
    debugging and related activities easier. Text protocols are also generally considered
    more extensible and future-proof, as opposed to binary ones. The downside of plain
    text is mainly its size; binary enumeration tends to be more compact. This is
    largely irrelevant in this case and can be easily mitigated anyway using compression
    (this is exactly what many servers do in case of HTTP).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s review the individual messages that comprise our application''s
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the server communicates no other information except the fact that
    the user is now in the chat room, so we'll send just the word `CONNECT` every
    time. This message is not parameterized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Talking in the chat room is more interesting. There are two parameters: the
    nickname and the text message itself. Let''s define the format of such message
    as `A:B`, where `A` is the nickname (as a direct consequence, the nickname can''t
    contain the colon `:` character).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From this specification, we can derive an effective algorithm (pseudo code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Testing for the same user is meant to cut the unnecessary transmission of users'
    own messages back to them (echo).
  prefs: []
  type: TYPE_NORMAL
- en: The server source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the help of the Twisted framework, our pseudocode can be translated into
    Python pretty much literally. The following listing contains the full source code
    of our `server.py` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The principle of operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the control flow outline that will help you understand exactly how
    our server works:'
  prefs: []
  type: TYPE_NORMAL
- en: The last line, `reactor.run()`, starts the `ChatFactory` server that listens
    on port 9096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the server receives input, it invokes the `dataReceived()` callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dataReceived()` method implements the pseudocode from the protocol section,
    sending messages to other connected clients as required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of connections to clients is called `transports`. We're adding the current
    transport, `self.transport`, to the set unconditionally, because in the case of
    existing element that's a no-op, so why bother.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the listing follows the algorithm exactly. As a result, every connected
    user except for the one who sent the original message will receive a notification,
    `<` **username** `> says: <` **message text** `>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Notice how we didn''t actually check that the connect message says `CONNECT`.
    That''s an example of closely following the *network robustness* principle, coined
    by Jon Postel in the TCP specification in 1980: *be conservative in what you send,
    and liberal in what you accept*.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to simplifying the code in this case, we're also gaining an option
    for a forward compatibility. Let's say that in the future release of the client,
    we've added a new message to the protocol, namely the imaginary `WHARRGARBL` message
    that does, according to its name, something truly amazing. Instead of crashing
    due to receiving a malformed message (in this case, because of version mismatch),
    an old revision of the server will just ignore such messages and continue functioning.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically this aspect—compatibility between versions—can be easily handled
    using a number of strategies. However, there are also more difficult problems
    when it comes to networking and especially public networks, including malicious
    users trying to defeat your system and bring it down on purpose. So, practically,
    there is no such thing as exaggerated server stability.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the server as you usually run any Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command shouldn't produce any visible output. The server just sits there,
    waiting quietly for clients to connect. However, there are no client programs
    in the known universe that can speak this protocol, since we've made it all up
    about page and a half ago. How can we make sure that the server works?
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, this chicken and egg problem is so common in this field that there
    are many useful tools to do just that—send arbitrary bytes to any server, and
    receive and display arbitrary bytes that server sends back.
  prefs: []
  type: TYPE_NORMAL
- en: One of the standard programs suitable for fiddling with servers that use text
    protocols is Telnet. Like many "old school" Unix-style utilities, Telnet is a
    command-line program that can be used both interactively and as part of larger
    batch (shell) script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most operating systems come with the `telnet` command preinstalled. If it isn''t,
    chances are that you''re on MS Windows version 7 or greater. In this case, you
    can go to **Control Panel** | **Programs and Features** | **Turn Windows features
    on or off**,as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the server](img/B01620_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, make sure that the **Telnet Client** checkbox is on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the server](img/B01620_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Telnet accepts two arguments: host name and port number of the server to connect
    to. In order to connect to the chat server with telnet, you''ll need to start
    `server.py` first, and then in another terminal run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use `localhost` for host name on most systems, as this
    is synonymous with `127.0.0.1`; both denote the current machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all went well, you will have an interactive session open where every line
    you type is sent to the server. Now, using the chat protocol that we discussed
    earlier, you can communicate with the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There will be no output, because we programmed the server in such a way that
    it doesn't echo messages back to their original author—that will be wasteful.
    So, let's open yet another terminal (and a Telnet session) so that we have two
    simultaneously connected users.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the chat session looks like when everything is functioning properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the server](img/B01620_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An interactive chat over the network at its finest
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If for some reason, technical or otherwise, you cannot use Telnet on your system,
    please don't feel particularly bad about this, as this test is not required to
    successfully complete the tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, here''s some (very personal, intimate even) advice that is more related
    to your career than to the topic of this book: do yourself a favor and get a Mac
    OS or Linux box, or maybe use dual-boot on the same machine. These Unix-like operating
    systems are much better suited for software development than Windows, and the
    productivity boost is totally worth the inconvenience of getting used to a new
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this we can conclude that our server works: two Telnet windows are talking
    just fine. Now that we''re done with the backend, let''s build a cross-platform
    GUI chat client.'
  prefs: []
  type: TYPE_NORMAL
- en: Screen manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin the UI development with a new concept, namely screen management.
    Our application at hand, the chat client, is a fitting example. There will be
    two application states with different UI that are completely separate from one
    another:'
  prefs: []
  type: TYPE_NORMAL
- en: The login screen where the user enters the hostname to connect to and the desired
    nickname:![Screen manager](img/B01620_04_05.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chatroom screen, where the actual conversation takes place:![Screen manager](img/B01620_04_06.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conceptually, these are the application states of the Chat app's frontend.
  prefs: []
  type: TYPE_NORMAL
- en: A straightforward approach to such UI separation will amount to managing the
    visible and hidden controls depending on some variable that holds the current
    desired UI state. This gets cumbersome very quickly as the number of widgets grow,
    and the boilerplate code isn't exactly fun to write anyway.
  prefs: []
  type: TYPE_NORMAL
- en: That's why the Kivy framework provides us with a container widget specifically
    tailored for the task, `ScreenManager`. Additionally, `ScreenManager` supports
    short animations to visualize the screen change, with a number of prebuilt transitions
    to choose from. It can be used from a Kivy language file in a completely declarative
    manner without touching the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do just that. Add the following code in the `chat.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the basic structure of the program: we have a `ScreenManager` at the
    root and a `Screen` container for every UI state we want to have (the first one
    will be displayed by default). Inside the `Screen` is the usual UI: layouts, buttons,
    and everything we''ve seen so far. We''ll get to it in a bit.'
  prefs: []
  type: TYPE_NORMAL
- en: The code we just saw also includes screen-changing buttons, one per `Screen`
    instance. In order to switch the application state, we need to assign the desired
    screen's name to the `current` property of `ScreenManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated previously, the brief animation that happens when changing screens
    can be customized. Kivy provides a number of such animations out of the box, found
    inside the `kivy.uix.screenmanager` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Transition class name | Visual effect |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `NoTransition` | No animation, just displays the new screen immediately.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SlideTransition` | Slides the new screen. Pass `''left''` (the default),
    `''right''`, `''up''`, or `''down''` to select the direction of the effect. |'
  prefs: []
  type: TYPE_TB
- en: '| `SwapTransition` | In theory, this class simulates the iOS screen-swapping
    animation. The actual effect looks nothing like that though. |'
  prefs: []
  type: TYPE_TB
- en: '| `FadeTransition` | Fades the screen out, then fades it back in. |'
  prefs: []
  type: TYPE_TB
- en: '| `WipeTransition` | A smooth directional transition using a pixel shader.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FallOutTransition` | Shrinks an old screen towards center of the window
    and makes it transparent, revealing the new screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `RiseInTransition` | The exact opposite of `FallOutTransition`: grows the
    new screen from the center, overlapping and concealing an old one. |'
  prefs: []
  type: TYPE_TB
- en: 'There''s a small caveat in relation to setting these inside a `.kv` file: the
    transitions aren''t imported by default, so you''ll need to import the ones you
    want to use, using the following syntax (at the top of `chat.kv`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can assign it to `ScreenManager`. Note that it''s a Python class instantiation,
    so the parentheses at the end are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Login screen layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What happens inside the login screen, layout-wise, is very similar to the previous
    chapter''s Sound recorder app: a `GridLayout` solves the task of aligning components
    on a grid.'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that hasn't been used in this book yet is the `TextInput` widget.
    Kivy's text input behaves almost exactly like a button, with the obvious exception
    that you can type text into it. By default, `TextInput` is multiline, so we set
    the `multiline` property to `False` because multiline text inputs don't make much
    sense in the context of this app.
  prefs: []
  type: TYPE_NORMAL
- en: When running on a device with no physical keyboard attached, Kivy will fall
    back to a virtual onscreen keyboard, just as native apps do.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code that implements the login screen layout (in the same Kivy
    language file, `chat.kv`, under `ScreenManager`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add two text fields, `Server` and `Nickname`, with corresponding labels,
    and a **Connect** button. The event handler for the button has nothing to do with
    actual networking just yet and merely switches the screen to the chatroom, but
    this will change in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one interesting bit of styling needed to make a single-line `TextInput`.
    In addition to setting its `multiline` property to `False`, we want to align the
    text inside vertically in the middle (otherwise, it will stick to the top of the
    control, leaving a large gap at the bottom). We can achieve the proper alignment
    using the padding property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This `padding` line sets both left and right padding to 10, with top and bottom
    computed as *0.5 × (height of the widget − height of one line of text)*.
  prefs: []
  type: TYPE_NORMAL
- en: This is what the resulting screen looks like; it is pretty similar to other
    applications that we've produced during the course of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Login screen layout](img/B01620_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chat application's login screen
  prefs: []
  type: TYPE_NORMAL
- en: We could start writing code that connects to the server right now, but first
    let's get the primary screen, the chatroom, working. This will allow us to conduct
    meaningful tests right away afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Chatroom screen layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next on our list is the chatroom screen. It features a `ScrollView` widget for
    lengthy conversations, and since that's the first time a scrolling widget appears
    in this book, let's take a closer look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest `.kv` snippet to produce a scrolling widget is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you add enough text to it so that it overflows the screen, it starts to scroll,
    similar to what you'd expect from a long list of items in iOS or Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how this layout works:'
  prefs: []
  type: TYPE_NORMAL
- en: We constrain the `text_size` width (first value) of our custom `Label` subclass
    to the widget's available width, and let it choose the height depending on its
    contents by setting the second value to `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we set the vertical `size_hint` (second value) to `None` to force height
    of the widget to be computed independently of its container. Otherwise, it will
    be limited by the parent element, and thus there will be nothing to scroll.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can set the widget's height to be equal to the `texture_size` height
    (note that indexing is zero-based as usual, so the second value is indeed `texture_size[1]`).
    This will force the `ChatLabel` to become larger than the containing widget, `ScrollView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `ScrollView` detects that its child widget is larger than the available
    screen space, scrolling is enabled. It works as usual on mobile, and adds mouse
    wheel support on desktop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overscroll modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also customize the overscroll effect of a `ScrollView` to mimic a behavior
    native to the corresponding platform (which still looks noticeably different from
    native components anyway, despite being similar in concept). At the time of writing,
    the Android-style edge glow isn''t supported out of the box; the available options
    are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ScrollEffect`: This effect allows you to stop scrolling abruptly when you
    reach the end. This is similar to how desktop programs usually work, so this behavior
    might be desirable if the app in question is intended mostly for desktop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DampedScrollEffect`: This is the default effect. It is similar to the bounce
    back effect found in iOS. This is arguably the best mode for mobile devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OpacityScrollEffect`: This effect is similar to `DampedScrollEffect` with
    added transparency when scrolling past the edge of the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use one of these settings, import it from the `kivy.effects` module and assign
    to the `ScrollView.effect_cls` property, similar to the `ScreenManager` transitions
    just discussed. We aren't going to use this, as `DampedScrollEffect` suits our
    application just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of these points in mind, this is what the chatroom screen layout looks
    like (in `chat.kv`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The last line, `size_hint`, sets the horizontal proportion of the `Button` widget
    to `0.3`, down from the default of `1`. This makes the **Send** button smaller
    than the message input field.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set the background of the messages area to white, we can use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This draws a white rectangle behind the `ScrollView` unconditionally before
    every other drawing operation takes place. Don''t forget to tweak the `<ChatLabel>`
    class, setting text color to something readable on a light background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overscroll modes](img/B01620_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chatroom screen, devoid of meaningful conversations
  prefs: []
  type: TYPE_NORMAL
- en: Again, the **Disconnect** button just switches screens without any networking
    going on behind the scenes. This is the next topic actually; as you will see shortly,
    implementing simple network programs in Python is not very different in terms
    of complexity from building a simple user interface with Kivy.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the app online
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the interesting part! We are going to establish the connection with
    the server, send and receive messages, and display meaningful output to users.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's take a look at the minimal, pure-Python implementation of the
    chat client, to see what's going on. This is low-level code using a socket to
    communicate. In practice, using a higher-level abstraction, like Twisted, is almost
    always advised; but if you're not familiar with the underlying concepts, it may
    be hard to grasp what happens in your code behind the scenes, which turns debugging
    into guesswork.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple Python client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following listing, we're reading user input from the console using the
    built-in `readline()` function and displaying the output with `print()`. This
    means that using this simple client is not vastly different from using Telnet—the
    UI consists of the exact same plain text in a terminal window—but this time we
    implement it ourselves from scratch using sockets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to need a number of Python modules, all from the standard library:
    `socket`, `sys` (for `sys.stdin`, standard input file descriptor), and the `select`
    module to implement efficient waiting until the data is available. Assuming a
    new file, let''s call it `client.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This program doesn't need external dependencies at all; this is as pure-Python
    as it gets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note than on Windows, `select` cannot poll file descriptors the same as sockets
    because of implementation details, so our code will not function correctly. Since
    this is only a demonstration of the low-level networking and not the final product,
    we aren't going to port it to marginal systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we open the connection to server and do the usual `CONNECT` handshake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part in interesting: we wait for data to become available on either
    standard input (meaning that the user entered something), or the `s` socket (meaning
    that the server sent something our way). The waiting is achieved using the `select.select()`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then, depending on the source of newly available data, we either print it on
    the screen in case of a message received from the server, or send it to the server
    if it's a message from the local user. Again, this is more or less what Telnet
    does, sans error checking.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is nothing inherently impossible or insanely complex in
    low-level networking. But for what it's worth, raw sockets are still quite cumbersome
    to handle and we will illustrate the high-level approach to the same code soon.
    However, this is what happens under the hood of any framework; ultimately, it's
    always sockets doing the heavy lifting, presented under a different sauce of abstractions
    (APIs).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in this tutorial we are not doing extensive error checking on purpose,
    because it will increase the amount of code by the factor of 2-3 and make it unwieldy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of things that can go wrong over the network; it''s more fragile
    than it''s commonly perceived to be. So if you''re planning to compete with Skype
    *et al.*, be ready to do incredible amounts of error checking and testing: network
    problems such as packet loss and nationwide firewalls, to name a few, will surely
    bite at some point. No matter how well-planned your architecture is, making network
    services highly available is hard.'
  prefs: []
  type: TYPE_NORMAL
- en: Kivy integration with Twisted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another reason why our low-level client code is not a good fit for a Kivy application
    is that it relies on its own main loop (the `while 1:` part). It will take some
    work to make this code play well with the event loop that powers Kivy.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, let's take advantage of the Twisted integration that's distributed
    as a part of Kivy. This also means that the same network library will be used
    on both the client and the server, making the code more uniform across the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'The necessary step to make Kivy''s main loop play well with Twisted is to run
    the following code before the Twisted framework is even imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code should be at the very beginning of the `main.py` file. This is crucial
    to get right, otherwise everything will cease to function in obscure ways.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's implement the chat client using Twisted.
  prefs: []
  type: TYPE_NORMAL
- en: ChatClient and ChatClientFactory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the Twisted part, there is surprisingly little to do, since the framework
    takes care of everything that's related to actual networking. These classes are
    used mostly to wire the "moving parts" of the program together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ClientFactory` subclass, `ChatClientFactory`, will just store the Kivy
    app instance when initialized so that we can pass events to it later. Take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The complementary `ChatClient` class listens to `connectionMade` and `dataReceived`
    events from Twisted and passes them to the Kivy app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note the ubiquitous `CONNECT` handshake.
  prefs: []
  type: TYPE_NORMAL
- en: This is very different from the code utilizing raw sockets, right? At the same
    time, this is very similar to what happens on the server side in `server.py`.
    But, instead of actually handling events, we're just passing them to the `app`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: UI integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to finally see the whole picture, let''s hook the networking code
    up to the UI and write the missing Kivy application class. The following are the
    cumulative updates that need to be applied to the `chat.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice how buttons don't switch screens anymore, instead they call methods on
    `app`, similar to `ChatClient` event handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having done that, we now need to implement a grand total of five methods that
    are missing from the Kivy application class: two for server-originated events
    that come from Twisted code (`on_connect` and `on_message`), and three more for
    the user interface events (`connect`, `disconnect`, and `send_msg`). This will
    make our Chat app actually usable.'
  prefs: []
  type: TYPE_NORMAL
- en: Application logic of the client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin writing the program logic in roughly the lifecycle order: from
    `connect()` to `disconnect()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `connect()` method, we pick up the values of **Server** and **Nickname**
    fields, as provided by the user. The nickname is then stored in `self.nick`, and
    the Twisted client connects to the specified host, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `ChatClient.connectionMade()` function is called, passing control
    to the `on_connect()` method. We will use this event to store the connection in
    `self.conn` and switch screens. As discussed previously, buttons no longer switch
    screens directly; instead, we rely on more specific event handlers like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the main part: sending and receiving messages. This is very straightforward
    actually: to send a message we get the message text from the `TextInput`, get
    our nickname from `self.nick`, concatenate them together, and send the resulting
    line to the server. We also echo the same message onscreen and clear the message
    input box. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Receiving messages is completely trivial; since we don''t proactively keep
    track of them, just put the newly arrived message onscreen followed by a newline,
    and that''s all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last remaining method is `disconnect()`. It does exactly what it says on
    the tin: closes the connection and performs a general cleanup to return things
    back as they were when the program first started (notably, empties the `chat_logs`
    widget). Finally, it sends the user back to the login screen, so they can jump
    to another server or change nickname. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With this, our app finally has the ability to send and receive chat messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application logic of the client](img/B01620_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chat app in action
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Caveats**'
  prefs: []
  type: TYPE_NORMAL
- en: During testing, the `server.py` script should obviously be running at all times;
    otherwise, our app won't have an endpoint to connect to. Presently, this will
    result in the app staying on the login screen; in the absence of an `on_connect()`
    call, the user won't get to the chatroom screen.
  prefs: []
  type: TYPE_NORMAL
- en: Also, when testing on Android, make sure you enter the correct IP address of
    the server, as it will *not* be `127.0.0.1` anymore—that's always the local machine,
    so on an Android device this will mean that very device and not the computer you're
    working on. Use the `ifconfig` utility (called `ipconfig` on Windows for additional
    confusion) to determine the correct network address of your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-application interoperability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One interesting property of the resulting application (besides the fact that
    it works at all) is that it's compatible with every client mentioned in this chapter.
    Users can connect to the server using Telnet, the pure-Python client, or the Kivy
    UI program—the core functionality is equally available to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very similar to how the Internet operates: once you have a well-defined
    protocol (such as HTTP), many unrelated parties can develop servers and clients
    that will be ultimately interoperable: web servers, web browsers, search engine
    crawlers, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: A protocol is a higher form of an API, language- and system-independent, like
    a good foundation should be. While not many web developers are familiar with the
    API of, for example, Microsoft Silverlight released in 2007, anyone working in
    the field knows at least the basics of HTTP, documented in 1991\. Such a level
    of ubiquity is nearly impossible to achieve with a library or framework.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancements and eye candy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our chat basically works, we can apply some finishing touches to it,
    for example, improve the chat log presentation. Since the client already displays
    anything that the server sends its way, we can easily use Kivy markup (**BBCode**-like
    markup language, discussed in [Chapter 1](ch01.html "Chapter 1. Building a Clock
    App"), *Building a Clock App*) to style the conversation log.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, let's assign a color to each user and then paint the nickname with
    this color and make it bold. This will help readability and generally look nicer
    than a wall of monochrome plain text.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the **Flat UI** color palette instead of generating purely random
    colors, because generating substantially different colors that look good when
    used together is by itself not an easy task.
  prefs: []
  type: TYPE_NORMAL
- en: Outgoing messages (those sent by the current user) don't come from the server
    and are added to chat log by the client code instead. So, we will paint the current
    user's nickname with a constant color right on the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this update, the final code of the chat server, `server.py`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Given a finite list of colors, we pop one from the end of the list, and then
    insert it back to the front, creating a rotating buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''re familiar with the more advanced `itertools` module from the standard
    library, you can rewrite the code we just saw like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we will discuss the bit where we pass the message to the client. The
    markup for the desired effect is very straightforward: `[b][color]Nickname[/color][/b]`.
    The code that makes use of it is equally simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The client in `main.py` is also updated to match formatting, as discussed earlier.
    Here, we have a constant color, which is different from the ones assigned by the
    server, so that the current user always stands out. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set the `markup` property to `True` on the conversation log widget,
    `ChatLabel`, as shown in the following code snippet, and we''re (almost) done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, before we solve a problem with this approach (and there''s indeed
    at least one serious problem here), here''s the obligatory resulting screenshot.
    This is how the final conversation screen looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhancements and eye candy](img/B01620_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Colorful chat logs help readability and generally look better and more "polished"
  prefs: []
  type: TYPE_NORMAL
- en: Escaping the special syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One shortcoming in this code, as mentioned earlier, is that now we have special
    syntax in the protocol that's interpreted in a certain way on the client. Users
    can forge (or just inadvertently use, by pure chance) the BBCode-ish markup, creating
    unwanted visual glitches, such as assigning very large font sizes and unreadable
    colors. For example, if one of the users posts an unclosed `[i]` tag, all following
    text in the chatroom will be italicized. That's pretty bad.
  prefs: []
  type: TYPE_NORMAL
- en: In order to prevent users from highlighting text in random ways, we need to
    escape all markup that may exist in the message. Fortunately, Kivy provides a
    function to do just that, `kivy.utils.escape_markup`. Bad news is that it's been
    bugged since 2012.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a high probability that the function will have been fixed by the time
    you''re reading this book, but for the sake of completeness, here''s an implementation
    that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With this, all characters that are special to Kivy markup are replaced with
    HTML-style character entities, so the markup passed through this function will
    be displayed as is and won't affect the rich text attributes in any way.
  prefs: []
  type: TYPE_NORMAL
- en: We need to call this function in two places, on the server when sending messages
    to clients, and on the client when displaying messages from self (the current
    user).
  prefs: []
  type: TYPE_NORMAL
- en: 'In `server.py`, the relevant portion of the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main.py`, the implementation is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the vulnerability is patched; now users can safely send BBCode markup
    to each other if they choose to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interestingly, this type of bug is also very pervasive in Internet apps. When
    applied to websites, it's called **cross-site scripting** (**XSS**) and allows
    much more damage than merely changing fonts and colors.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to sanitize all user input in all scenarios that may involve commands
    (such as markup, inline scripts, even ANSI escape codes) mixed in with the data;
    neglecting to do so is a sure-fire disaster waiting to happen.
  prefs: []
  type: TYPE_NORMAL
- en: What's next
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Obviously, this is only the beginning. The implementation at hand still has
    a vast number of deficiencies: user names aren''t enforced to be unique, and there
    is no history and no support for fetching messages that have been sent while other
    parties were offline. Hence, bad network with frequent disconnects will render
    this application mostly unusable.'
  prefs: []
  type: TYPE_NORMAL
- en: But what matters is that these points can certainly be addressed, and we already
    have a working prototype. In the start-up world, having a prototype is an attractive
    quality, particularly when raising funds; if you're programming for fun mostly,
    it's even more so, as seeing a working product is greatly motivating (as opposed
    to observing a pile of code that doesn't so much as run yet).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in this chapter, client-server application development (and generally
    speaking, networking on the application level) isn't necessarily inherently complex.
    Even the low-level code utilizing sockets is quite manageable.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, many gray areas and aspects that are hard to get right
    when writing an app that makes heavy use of the network. Examples of these include
    working around high latency, restoring an interrupted connection, and syncing
    across a large number of nodes (especially peer-to-peer or multi-master, when
    none of the machines have the full dataset).
  prefs: []
  type: TYPE_NORMAL
- en: Another relatively new class of network problems is the political one. Lately,
    Internet regulations are being implemented by governments of varying oppressiveness,
    ranging from relatively logical (for example, blocking resources promoting terrorism)
    to completely nonsensical (for example, banning educational sites like Wikipedia,
    major news sites, or video games). This type of connectivity problem is also known
    for high collateral damage, for example, if a **content delivery network** (**CDN**)
    goes down, then many sites that link to it will cease to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with careful programming and testing, it is certainly possible to
    overcome every obstacle and deliver a product of exceptional quality to your users.
    Rich Python infrastructure shoulders some of this burden for you, as shown in
    our Chat program: many low-level details are abstracted with the help of Kivy
    and Twisted, two excellent Python libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: The possibilities in this field, given the universal accessibility, are nothing
    short of endless. We will discuss and implement a way more interesting use case
    for a networked app in the next chapter, so read on.
  prefs: []
  type: TYPE_NORMAL
