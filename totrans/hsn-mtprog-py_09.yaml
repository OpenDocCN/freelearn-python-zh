- en: '*Chapter 7*: Understanding Generics and Typing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at what generics are and how to perform type checking
    in Python 3 and understand how it is useful in metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Python is a programming language where variables are declared as generics and
    they don’t get a data type assigned to them on the declaration. Python resolves
    the data types dynamically during runtime depending on the values assigned to
    variables. In other programming languages such as C++, generics need to be programmatically
    designed to make the variables generic, whereas in Python, generics are how the
    variables are defined. In such cases, how we would declare a variable with typing
    and restrict the behavior of the variables is what we will be focusing on in detail
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will look at understanding how generics work in
    Python and how to define type checks so that we can apply metaprogramming on variables
    to statically type them so that we don’t have to wait for the complete program
    to run to determine that we have unintentionally used incorrect typing in our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are generics?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when data types are specified?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typing with explicit type checks – approach 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typing with explicit type checks – approach 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding data types with constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple custom data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a domain-specific data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to apply generics and type checking
    on Python variables. You should also be able to create your own domain-specific
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: What are generics?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generics** are a programming paradigm where any attribute or variable is
    a function in a language that is not assigned to any specific type. When we speak
    of type, it is either the variable data type or the function return type.'
  prefs: []
  type: TYPE_NORMAL
- en: How are generics connected to metaprogramming?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Metaprogramming** deals with the concepts of Python 3 and above, where we
    can develop scripts or programs that manipulate the objects of Python externally
    without actually impacting the definition of classes, methods, or functions in
    a program. Generics are the way in which Python has built the handling of data
    types for its objects. If we need to change the data type handling in Python from
    generics to specific types, we can perform it through metaprogramming. To understand
    how to make specifics work, we need to understand generics with examples. Let’s
    look at generics in the following section.'
  prefs: []
  type: TYPE_NORMAL
- en: How are generics handled in Python?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we can investigate generics with an example. Throughout this chapter,
    we will look into another interesting section of our core example, *ABC Megamart*.
    In this chapter, we will be covering our examples using the clothing and fashion
    department of *ABC Megamart*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the fashion department of *ABC Megamart* in this example. This
    department covers various clothing products. To examine generics, we will first
    define a class named `Fashion` with attributes such as `clothing_category`, `gender`,
    `model`, `design`, `dress_type`, `size`, and `color`. We will also add a method
    named `get_item` to return the preceding attributes. The code is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code handles generics. Let’s explain this statement by assigning values
    of any data types to the attributes of `Fashion`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added string values to `clothing_category`, `gender`, `model`, `design`,
    `dress_type`, and `color`, while we added an integer value to the `size` attribute.
    Since the language handles generics by default, we did not have to declare the
    data types and the values are accepted without throwing any errors. We can call
    the `get_item` method to display these generic values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the data types of `clothing_category` and `size` results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s double-check our statement on generics now. What happens when we change
    the data types of input variables? Will they be accepted by Python? To test this,
    let’s change the data types of `clothing_category` and `size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The change in data types is accepted and processed by Python and can be viewed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, no matter which data type the input value belongs
    to, they are processed successfully. In the following section, let’s explicitly
    assign data types and check further.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when data types are specified?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations in Python are added to code to provide additional information or
    help to end users with a piece of code while creating libraries. Annotations can
    be used to add data types to a specific code so that the information on data types
    can later be retrieved using the annotations by developers.
  prefs: []
  type: TYPE_NORMAL
- en: Type hints as annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of typing, which is the topic of this chapter, let’s look at
    type hints in this section. Data types of a function or method can be defined
    in Python using a functionality of annotations called `Fashion` class by declaring
    type hints on the methods of the class. To implement this, we can explicitly assign
    a data type and its return type to a variable while declaring a variable and adding
    it to a method in Python. We will also add a type hint for the return type of
    a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s declare the `Fashion` class initialized with its attributes or variables
    along with the data types, which we would expect the variables to be on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have specifically tagged a data type to each variable.
    In this class, we will also add a `get_item` method and add annotation with a
    type hint specifying that this method returns a `list` item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now check what happens when these data types are not followed while creating
    an object and assigning values to these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have declared `clothingCategory_c` as a string and `size` as an integer in
    the preceding class definition but we have assigned an integer to `clothing_category`
    and a string to the `size` variables. The program still ran successfully without
    throwing any type error, while there should, ideally, have been a type error in
    this case. This example again proves that types are handled as generics in Python
    when we assign a data type during variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also look at the annotation for the `get_item` method in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `__annotations__` on the method provides the list data type annotated
    as the return type for the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look further into the concept of typing, in which we can look at how to
    deal with specific types instead of generics.
  prefs: []
  type: TYPE_NORMAL
- en: Typing with explicit type checks – approach 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we looked at Python’s ability to handle data types
    as generics. While building an application, there can be scenarios where a variable
    will need a specific data type, and we might expect metaprogramming to have the
    ability to handle such specific data types. In this section, let’s look at creating
    a class to perform type checking.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class to implement type checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will be creating a class named `typecheck` and adding methods
    to check each data type specifically. If a data type, for instance, an integer
    type, is provided as input to the method, it returns the input and, if the condition
    fails, it returns a message to provide the input value as an integer. Similarly,
    we will add various methods to check string, float, list, tuple, and dictionary
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now define a method named `intcheck`. The purpose of this method is to
    perform an integer type check of any input explicitly. In this method, a value
    will be provided as input and the method will verify whether the input value is
    an integer. If the input value is an integer, we will return the input value.
    If the value is not an integer, we will return a message that says `"value should
    be an integer"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a string
    (for example, `Orangesexample`) and return an error message when the condition
    is `true` and return the input value when the condition is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a floating-point
    value (for example, `example, 2335.2434`) and return an error message when the
    condition is `true` and return the input value when the condition is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a list
    of variables (for example, `[''fruits'',''flowers'',1990]`) and return an error
    message when the condition is `true` and return the input value when the condition
    is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a tuple
    of variables (for example, `example, (''fruits'',''flowers'',1990)`) and return
    an error message when the condition is `true` and return the input value when
    the condition is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a dictionary
    with key/value pairs (for example, `example: {''one'': 1, ''two'': 2}`) and return
    an error message when the condition is `true` and return the input value when
    the condition is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s , we will proceed further to create the `Fashion` class to perform
    type checks using the `typecheck` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class to test type checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now create the `Fashion` class with the same set of variables, that is,
    `clothing_category`, `gender`, `model`, `design`, `dress_type`, `size`, and `color`.
    In this example too, we will assign a specific data type to each variable. In
    the following class definition, let’s create an object for the `typecheck` class
    and call type-specific methods to store the variables of each type. For instance,
    a `price` variable will be declared as `float`, and the `floatcheck` method from
    `typecheck` will be used to store the variable instead of using generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, let’s initialize the variables for the `Fashion` class
    along with their specific data types defined using the type checking methods of
    the `typecheck` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, let’s return all the variables initialized in the
    `Fashion` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the `floatcheck` method on the `price` variable acts as a typing mechanism
    for the variable declaration, and if the input provided is not a float, then an
    error will be displayed in the variable declaration phase itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have declared four variables with incorrect data
    types; `clothing_category` should be a string, `price` should be a float, `size`
    should be an integer, and `color` should be a list. All these incorrect variables
    were not accepted by the code and hence we have received corresponding variable
    type errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'While we get the items from the fashion object, all incorrect type variables
    have no values assigned to them. Let’s now look at the correct values and how
    they are accepted by the `fashion` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have corrected the input values by assigning values
    of specific data types and the error is now resolved. By developing such explicit
    typing libraries, we can convert Python’s generics into specifics.
  prefs: []
  type: TYPE_NORMAL
- en: Typing with explicit type checks – approach 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at another approach for applying specific data
    types to variables. In the first approach, we developed a `typecheck` class and
    used the type checking methods themselves to create new data types. In this example,
    we will be creating the `typecheck` class with each type checking method to check
    that the input value belongs to the expected type and returns a Boolean value
    based on the condition’s result. This method of type checking gives us the flexibility
    of modifying the `Fashion` class to provide variable-specific error messages when
    the condition is not met.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class to implement type checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, let’s begin by creating the `typecheck` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `typecheck` class is created here to make all the methods in this class
    reusable just in case all the methods in the type check code need to be exported
    into a different file for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the methods in this example can be created with or without a class and
    used throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not an integer
    (for example, `23348`) and return `False` when the condition is true and return
    `True` when the condition is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a string
    (for example, `Orangesexample`) and return `False` when the condition is true
    and return `True` when the condition is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a floating
    point value (for example, `2335.2434`) and return `False` when the condition is
    true and return `True` when the condition is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a list
    of variables (for example, `[''fruits'',''flowers'',1990]`) and return `False`
    when the condition is true and return `True` when the condition is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a tuple
    of variables (for example, `(''fruits'',''flowers'',1990)`) and return `False`
    when the condition is true and return `True` when the condition is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a dictionary
    with key/value pairs (for example, `{''one'': 1, ''two'': 2}`) and return `False`
    when the condition is true and return `True` when the condition is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can proceed further to create the `Fashion` class to perform type checks
    using the `typecheck` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class to test type checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, let’s look at creating a `Fashion` class with a different
    variable type definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s initialize the variables along with the specific data types for each:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s check whether the `clothing_category` input is
    a string and return the value if it is true, and return an error specific to `clothing_category`
    if it is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let‘s check whether the `gender` input is a string and
    return the value if it is true and return an error specific to the `gender` variable
    if it is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s check whether the `model` input is a tuple and
    return the value if it is true and return an error specific to the `model` variable
    if it is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s check whether the `design` input is an integer
    and return the value if it is true and return an error specific to the `design`
    variable if it is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s check whether the `price` input is a floating
    point value and return the value if it is true and return an error specific to
    the `price` variable if it is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s check whether the `size` input is a dictionary
    object and return the value if it is true and return an error specific to the
    `size` variable if it is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s check whether the `color` input is a list object
    and return the value if it is true and return an error specific to the `color`
    variable if it is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s create a method to return all the variables listed
    in the preceding code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test this approach of type checking, let’s pass some incorrect values as
    input for some of these variables and check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code results in the following list of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, calling the `get_item` method on the preceding `fashion` object results
    in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The graphical representation of the error message is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Error on calling the get_item method ](img/Figure_7.1_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Error on calling the get_item method
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding error, the first variable, `clothing-category`, was not accepted
    by the method since type expectations were not met by this variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check further by providing the right input types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'There were no errors from the preceding value assignments. Calling the `get_item`
    method on the `fashion` object now results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output meets all the type requirements and the end goal of type
    checking is achieved successfully through this approach. Now that you understand
    this, let’s look further into the concept of data types with constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data types with constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at an example of adding constraints to data types
    and checking constraints along with type checking. There might be scenarios where
    we would like to create an integer variable and restrict its length to two digits
    or to create a string and restrict its length to 10 characters and more. With
    this example, let’s explore how to add such constraints or restricts during the
    static type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let’s create a `typecheck` class with only two methods to
    check an integer and a string. While checking these data types, let’s also add
    a few more constraints within the method definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not an integer
    or its length is greater than two, and return `False` when the condition is true,
    and return `True` when the condition is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following method, let’s check that the input variable is not a string
    or its length is greater than 10, and return `False` when the condition is true,
    and return `True` when the condition is false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With just two methods with type checks and constraints, we can look into creating
    a `Fashion` class with two variables and one method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s initialize the class with `clothing_category` as a string and `size`
    as an integer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s declare `clothing_category` using the `stringcheck`
    method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s declare `size` using the `intcheck` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s add the method to get the items and return them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further create an object for the `fashion` class and assign two variables
    that do not match the type-checking conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding error messages indicate that both the type checks and constraints
    are not met for the string as well as integer data types. Let’s now provide the
    right type of input values and perform static type checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The value assignments are now working as expected in the preceding code. With
    this understanding, let’s proceed further to create simple custom data types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple custom data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until the preceding section, we looked at adding explicit type checks and converting
    generic type variables into specific types to handle specific data needs we might
    get while programming an application, and we also added errors to help debug incorrect
    data types assigned to variables.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, let’s look at creating our own simple data types and what will
    be required to do so. First of all, let’s answer the question of why we need our
    own data types. Any custom data type is a derivation of basic data types in Python
    along with certain variations to fulfill the purpose of our data needs in an application.
    Any data type will have its own set of operations that can be performed on top
    of the data of that specific type. For instance, an integer data type will support
    arithmetic operations such as addition, subtraction, multiplication, and division.
    Similarly, a string supports concatenation in the place of addition, and so on.
    So, when we create our own data type, we can override these basic operations to
    fulfill the need of our custom data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let‘s first create our own data type and override the
    basic operators to perform the operations that we expect. Please note that custom
    data types may be required only in situations where we would like to make it domain-specific
    or application-specific. We can always use default data types and avoid creating
    custom data types where there is no requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a class named `DressSize` and initialize it with the `size`
    variable of the integer type. If the input value for `size` is not an integer
    and the input values do not follow a specific list of dress sizes, type checking
    returns an error message in red (as shown in *Figure 7.2*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s override the default `str` method of a class to return the string
    version of the `size` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s add a new method named `value` to return the value of the `size`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s override the addition (`+`) operator of the integer method to increase
    `size` values from one dress size object created for the `DressSize` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s override the subtraction (`-`) operator of the integer method to
    decrease `size` values from one size object created for the `DressSize` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then create an object for the class, in this case, our new custom data
    type, `DressSize`, and initialize it with a string instead of an integer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Incorrect input type results in an error with a red font similar to how error
    messages are usually displayed while debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Error message for DressSize  ](img/Figure_7.2_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Error message for DressSize
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the `value` method would also result in an error since the type checking
    failed for the `DressSize` data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The value error is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Value error due to incorrect DressSize input type ](img/Figure_7.3_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Value error due to incorrect DressSize input type
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s correct this error by providing the correct input type while creating
    a `DressSize` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, we can look at how the addition operation (`+`) works
    on the objects of `DressSize`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The addition of two objects works like a regular addition since we have overloaded
    the addition operator (`+`) to add the initialized variables of two objects. Similarly,
    we can check the results of subtraction, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The subtraction of two objects works like a regular subtraction since we have
    overloaded the subtraction operator (`-`) to subtract the initialized variables
    of two objects. Similarly, printing the object results in printing the string
    format of the `size` variable since we have overloaded the `str` method to do
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have also added a `value` method to display the value of the `size` variable,
    and it works as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling the `type` method on the variable or the `s` object displays the class
    name, `DressSize`, which is the data type of `s` in this case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can consider creating a more detailed data type of our own in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a domain-specific data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let’s create an even more customized data type to deal with
    the dress size of the fashion department of *ABC Megamart*. The `DressSize` data
    type we defined in the preceding section handles any integer as input and performs
    the operations we overloaded. When we look at the domain of the fashion industry
    and consider the dress size as a domain-specific variable, the `DressSize` data
    type should ideally be considering only specific values for `size` and not accept
    all integers. The dress size will be based on the size of dresses held in the
    inventory of *ABC Megamart*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The accepted input for dress size in this example should be the list of integers,
    `[36,38,40,42,44,46,48]`, or the list of strings that indicates the equivalent
    text values for dress size such as `[XS,S,M,L,XL,XXL,XXXL]`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by creating the `DressSize` class along with its methods to work
    as a domain-specific data type, and initialize `size` as its only input value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further define two domain-specific lists that holds the valid set of
    values for dress size in text and integer formats, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, we will be creating a dictionary object that holds the
    integer and text format of `size` as key/value pairs. The reason behind adding
    this dictionary object is to use it further in the data type-specific methods
    created for this data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now add the condition that accepts the input value as `size` if it meets
    the data type criteria and then rejects the input value with an error if it does
    not meet the criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, the input value will be accepted if it is present in
    the `romanchart` list variable or if it is present in the `sizenum` list variable.
    If both the criteria are not met, the value will be rejected by the `DressSize`
    data type and an error message will be displayed in a red-colored font. Why do
    we need to set these strict constraints in this particular domain-specific data
    type? If we look at the `size` values of a dress, the size usually is an even
    number and there are no odd-numbered dress sizes in a shopping cart or in a clothing
    store. Also, the size of the clothing in most of the generic clothing stores falls
    between 36 and 48 in general. If the store holds clothes of lesser or greater
    sizes, we can adjust the lists accordingly and redefine the data type. In this
    specific scenario, let’s consider the dress sizes between 36 and 48 and their
    corresponding text codes between XS and XXXL as acceptable values. Now, we have
    added the acceptance criteria for the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add specific methods that can be processed on the data type. In the following
    method, let’s override the default `str` method of a class to return the string
    version of the `size` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s add a new method named `value` to return the value
    of the `size` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s add a method to increment the `size` value. The
    `size` value should increment by `2` since dress size is always measured in even
    numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we have added a logic to look up the value of a dress
    size such as `XL` if `DressSize` is a text input to the data type, and then increment
    the value by `2`. We have also added a logic to check the integer value of the
    dress size and increment by `2` if the dress size input is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add one more method to decrement the `DressSize` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we have added a logic to look up the value of a dress
    size such as `XL` if `DressSize` is a text input to the data type, and then decrement
    the value by `2`. We have also added a logic to check the integer value of `DressSize`
    and decrement by `2` if the dress size input is an integer. This defines the overall
    creation of a domain-specific data type named `DressSize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to test this data type by creating an object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we have created an object named `s`, so let’s look at
    how various methods and attributes work on this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Attributes of DressSize ](img/Figure_7.4_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Attributes of DressSize
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, let’s call `chart` from the `s` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Printing the object results in the string format representation of the value
    of the `s` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling the value method results as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling the increment method results as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling the decrement method results as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now create the `Fashion` class and initialize variables out of which
    the `size` variable will be initialized as the `DressSize` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, let’s define the type checking condition for `DressSize`.
    If `size` is an instance of `DressSize`, then it returns the instance, and if
    it is not an instance, an appropriate error message will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s further add the `get_item` method to return the attributes of the `Fashion`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Creating the object further results as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we did not assign the correct data type for the size
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To correct it, let’s create an instance of `DressSize` and provide it as input
    to the `Fashion` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code did not result in any error and is accepted as input by
    the `Fashion` class. Calling the `get_item` method would result in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to look at the specific value of the `M` object, we can call the
    `value` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we looked at how to create a domain-specific custom data type
    and how to use it on another class as a type variable.
  prefs: []
  type: TYPE_NORMAL
- en: These are some of the examples of how generics work in Python and how specifics
    can be applied to Python objects using user-defined functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the concepts of generics and type checking.
    We also looked at creating user-defined data types with specific constraints and
    we’ve also seen how to apply them to our core example. We created our own domain-specific
    data type and overloaded operators and methods to work according to the data type.
    Similar to other chapters covered in this book, this chapter is also used to change
    the behavior of Python objects externally using the concept of metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at the concept of templates with some
    interesting examples.
  prefs: []
  type: TYPE_NORMAL
