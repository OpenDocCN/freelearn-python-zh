- en: Design Techniques and Strategies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计技术和策略
- en: In this chapter, we will take a step back and look into the broader topics in
    computer algorithm design. As your experience with programming grows, certain
    patterns begin to become apparent to you. And just like with any other skilled
    trade, you cannot do without some techniques and principles to achieve the means.
    In the world of algorithms, there are a plethora of these techniques and design
    principles. A working knowledge and mastery of these techniques is required to
    tackle harder problems in the field.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将退后一步，探讨计算机算法设计中的更广泛主题。随着你对编程经验的增长，某些模式开始变得明显。就像任何其他熟练的手艺一样，你不能没有一些技术和原则来实现目标。在算法的世界里，有大量的这些技术和设计原则。要解决该领域的更难问题，需要对这些技术的实际知识和掌握。
- en: We will look at the ways in which algorithms are generally classified. Other
    design techniques will be treated alongside implementation of some of the algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨算法通常是如何分类的。其他设计技术将与一些算法的实现一起处理。
- en: The aim of this chapter is not to make you a pro at algorithm design and strategy
    but to unveil the large expanse of algorithms in a few pages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是让你成为算法设计和策略的专家，而是要在几页纸内揭示算法的广阔天地。
- en: Classification of algorithms
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法分类
- en: There exist a number of classification schemes that are based on the goal that
    an algorithm has to achieve. In the previous chapters, we implemented a number
    of algorithms. One question that may arise is, do these algorithms share the same
    form? If yes, what are the similarities and characteristics being used as the
    basis? If no, can the algorithms be grouped into classes?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着许多基于算法必须达到的目标的分类方案。在前几章中，我们实现了许多算法。可能出现的一个问题是，这些算法是否具有相同的形式？如果是，基于哪些相似性和特征作为基础？如果不是，算法能否被分组到类别中？
- en: These are the questions we will examine as we tackle the major modes of classifying
    algorithms.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在解决算法分类的主要模式时考察的问题。
- en: Classification by implementation
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按实现分类
- en: When translating a series of steps or processes into a working algorithm, there
    are a number of forms that it may take. The heart of the algorithm may employ some
    assets, described further in this section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当将一系列步骤或过程转换为工作算法时，它可能采取多种形式。算法的核心可能使用一些资产，这些资产在本节中将进一步描述。
- en: Recursion
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: Recursive algorithms are the ones that make calls to themselves until a certain
    condition is satisfied. Some problems are more easily expressed by implementing
    their solution through recursion. One classic example is the Towers of Hanoi.
    There are also different types of recursive algorithms, some of which include
    single and multiple recursion, indirect recursion, anonymous recursion, and generative
    recursion. An iterative algorithm, on the other hand, uses a series of steps or
    a repetitive construct to formulate a solution. This repetitive construct could
    be a simple `while` loop or any other kind of loop. Iterative solutions also come
    to mind more easily than their recursive implementations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 递归算法是那些在满足一定条件之前对自己进行调用的算法。一些问题通过递归实现其解决方案更为容易表达。一个经典的例子是汉诺塔。也存在不同类型的递归算法，其中包括单递归和多递归、间接递归、匿名递归和生成递归。另一方面，迭代算法使用一系列步骤或重复结构来制定解决方案。这种重复结构可以是简单的`while`循环或任何其他类型的循环。迭代解决方案比它们的递归实现更容易想到。
- en: Logical
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑
- en: One implementation of an algorithm is expressing it as a controlled logical
    deduction. This logic component is comprised of the axioms that will be used in
    the computation. The control component determines the manner in which deduction
    is applied to the axioms. This is expressed in the form a*lgorithm = logic + control*.
    This forms the basis of the logic programming paradigm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的一种实现是将它表达为受控的逻辑演绎。这个逻辑组件由将在计算中使用的公理组成。控制组件确定演绎应用于公理的方式。这以*a*lgorithm = logic
    + control*的形式表达。这构成了逻辑编程范式的基石。
- en: The logic component determines the meaning of the algorithm. The control component
    only affects its efficiency. Without modifying the logic, the efficiency can be
    improved by improving the control component.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑组件决定了算法的意义。控制组件仅影响其效率。在不修改逻辑的情况下，可以通过改进控制组件来提高效率。
- en: Serial or parallel
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 串行或并行
- en: The RAM model of most computers allows for the assumption that computing is
    done one instruction at a time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机的RAM模型允许假设计算是一次执行一条指令。
- en: Serial algorithms, also known as **sequential algorithms**, are algorithms that
    are executed sequentially. Execution commences from start to finish without any
    other execution procedure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 串行算法，也称为**顺序算法**，是按顺序执行的算法。执行从开始到结束，没有其他执行过程。
- en: To be able to process several instructions at once, a different model or computing
    technique is required. Parallel algorithms perform more than one operation at
    a time. In the PRAM model, there are serial processors that share a global memory.
    The processors can also perform various arithmetic and logical operations in parallel.
    This enables the execution of several instructions at one time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够同时处理多个指令，就需要不同的模型或计算技术。并行算法可以同时执行多个操作。在PRAM模型中，有串行处理器共享全局内存。处理器还可以并行执行各种算术和逻辑操作。这使得可以同时执行多个指令。
- en: The parallel/distributed algorithms divide a problem into subproblems among
    its processors to collect the results. Some sorting algorithms can be efficiently
    parallelized, while iterative algorithms are generally parallelizable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 并行/分布式算法将问题分解为子问题，分配给其处理器以收集结果。一些排序算法可以有效地并行化，而迭代算法通常可以并行化。
- en: Deterministic versus nondeterministic algorithms
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定性算法与非确定性算法
- en: Deterministic algorithms will produce the same output without fail every time
    the algorithm is run with the same input. There are some sets of problems that
    are so complex in the design of their solutions that expressing their solution
    in a deterministic way can be a challenge. Nondeterministic algorithms can change
    the order of execution or some internal subprocess that leads to a change in the
    final result any time the algorithm is run. As such, with every run of a nondeterministic
    algorithm, the output of the algorithm is different. For instance, an algorithm
    that makes use of a probabilistic value will yield different outputs on successive
    execution depending on the value of the random number generated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性算法每次使用相同的输入运行算法时，都会产生相同的输出。有一些问题在设计解决方案时非常复杂，以确定性方式表达它们的解决方案可能是一个挑战。非确定性算法可以在每次运行算法时改变执行顺序或某些内部子过程，从而导致最终结果的变化。因此，每次运行非确定性算法时，算法的输出都不同。例如，使用概率值的算法在连续执行时，根据生成的随机数的值会产生不同的输出。
- en: Classification by complexity
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按复杂度分类
- en: To determine the complexity of an algorithm is to try to estimate how much space
    (memory) and time is used overall during the computation or program execution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个算法的复杂度是尝试估计在整个计算或程序执行过程中总共使用了多少空间（内存）和时间。
- en: '[Chapter 3](a98d7333-0a20-49b1-8bf1-3e007ddb9793.xhtml), *Principles of Algorithm
    Design*, presents more comprehensive coverage of the subject matter on complexity.
    We will summarize what we learned there here.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](a98d7333-0a20-49b1-8bf1-3e007ddb9793.xhtml)，《算法设计原理》，更全面地介绍了关于复杂性的主题。我们将在下面总结我们在那里学到的内容。'
- en: Complexity curves
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂度曲线
- en: Now consider a problem of magnitude *n*. To determine the time complexity of
    an algorithm, we denote it with **T**(n). The value may fall under **O**(*1*),
    **O**(*log n*), **O**(*n*), **O**(*n log(n)*), **O**(*n²*), **O**(*n³*), or **O**(*2^n*).
    Depending on the steps an algorithm performs, the time complexity may or may not
    be affected. The notation **O**(*n*) captures the growth rate of an algorithm.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个规模为*n*的问题。为了确定算法的时间复杂度，我们用**T**(n)表示它。这个值可能属于**O**(*1*)、**O**(*log n*)、**O**(*n*)、**O**(*n
    log(n*)、**O**(*n²*)、**O**(*n³*)或**O**(*2^n*)。根据算法执行的步骤，时间复杂度可能会或可能不会受到影响。**O**(*n*)的表示捕捉了算法的增长率。
- en: Let's now examine a practical scenario. By which means do we arrive at the conclusion
    that the bubble sort algorithm is slower than the quick sort algorithm? Or in
    general, how do we measure the efficiency of one algorithm against the other?
    Well, we can compare the Big O of any number of algorithms to determine their
    efficiency. It is this approach that gives us a time measure or the growth rate,
    which charts the behavior of the algorithm as *n* gets bigger.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来考察一个实际场景。我们是通过什么方式得出冒泡排序算法比快速排序算法慢的结论？或者一般而言，我们如何衡量一个算法相对于另一个算法的效率？嗯，我们可以比较任意数量算法的大O表示来决定它们的效率。正是这种方法给我们提供了一个时间度量或增长速率，它描绘了当*n*变大时算法的行为。
- en: 'Here is a graph of the different runtimes that an algorithm''s performance
    may fall under:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个图表，展示了算法性能可能落下的不同运行时：
- en: '![](img/image_12_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_12_001.jpg)'
- en: In ascending order, the list of runtimes from better to worse is given as **O**(1),
    **O**(log n), **O**(*n*), **O**(*n log n*), **O**(*n²*), **O**(*n³*), and **O**(*2^n*).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按升序排列，从好到差的运行时列表给出为 **O**(1)，**O**(log n)，**O**(*n*)，**O**(*n log n*)，**O**(*n²*)，**O**(*n³*)，以及
    **O**(*2^n*)。
- en: Classification by design
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计分类
- en: In this section, we will present the categories of algorithms based on the design
    of the various algorithms used in solving problems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将根据用于解决问题设计的各种算法的类别来介绍算法。
- en: A given problem may have a number of solutions. When the algorithms of these
    solutions are analyzed, it becomes evident that some implement a certain technique
    or pattern. It is these techniques that we will discuss here, and in a later section,
    in greater detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个给定的问题可能有多个解决方案。当分析这些解决方案的算法时，很明显，其中一些实现了一种特定的技术或模式。正是这些技术我们将在这里讨论，并在稍后的章节中更详细地讨论。
- en: Divide and conquer
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分而治之
- en: This approach to problem-solving is just as its name suggests. To solve (conquer)
    certain problems, this algorithm divides the problem into subproblems identical
    to the original problem that can easily be solved. Solutions to the subproblems
    are combined in such a way that the final solution is the solution of the origin
    problem.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决问题的方法正如其名所示。为了解决（征服）某些问题，该算法将问题分解成与原始问题相同且易于解决的子问题。子问题的解决方案以这种方式组合，使得最终解决方案是原始问题的解决方案。
- en: The way in which the problems are broken down into smaller chunks is mostly
    by recursion. We will examine this technique in detail in the upcoming sections.
    Some algorithms that use this technique include merge sort, quick sort, and binary
    search.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题分解成更小部分的方式主要是通过递归。我们将在接下来的章节中详细考察这种技术。使用这种技术的算法包括归并排序、快速排序和二分查找。
- en: Dynamic programming
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态规划
- en: This technique is similar to divide and conquer, in that a problem is broken
    down into smaller problems. In divide and conquer, each subproblem has to be solved
    before its results can be used to solve bigger problems. By contrast, dynamic
    programming does not compute the solution to an already encountered subproblem.
    Rather, it uses a remembering technique to avoid the recomputation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术类似于分而治之，因为问题被分解成更小的子问题。在分而治之的方法中，每个子问题必须在它的结果被用来解决更大的问题之前得到解决。相比之下，动态规划不会重新计算已经遇到的子问题的解。相反，它使用一种记忆技术来避免重复计算。
- en: Dynamic programming problems have two characteristics: **optimal substructure**
    and **overlapping subproblem**. We will talk more on this in the next section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划问题有两个特征：**最优子结构**和**重叠子问题**。我们将在下一节中进一步讨论这一点。
- en: Greedy algorithms
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪心算法
- en: For a certain category of problems, determining the best solution is really
    difficult. To make up for the lack of optimal solution, we resort to an approach
    where we select out of a bunch of options or choices the closest solution that
    is the most promising in obtaining a solution.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些类别的问题，确定最佳解决方案非常困难。为了弥补最优解的不足，我们采取从一系列选项或选择中挑选出最有可能获得解决方案的最近似解决方案的方法。
- en: Greedy algorithms are much easier to conceive because the guiding rule is for
    one to always select the solution that yields the most benefit and continue doing
    that, hoping to reach a perfect solution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法更容易构思，因为指导规则是选择带来最大利益的解决方案，并继续这样做，希望达到完美的解决方案。
- en: This technique aims to find a global optimal final solution by making a series
    of local optimal choices. The local optimal choice seems to lead to the solution.
    In real life, most of those local optimal choices made are suboptimal. As such,
    most greedy algorithms have a poor asymptotic time complexity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术旨在通过一系列局部最优选择来找到全局最优最终解决方案。局部最优选择似乎指向解决方案。在现实生活中，大多数这些局部最优选择都是次优的。因此，大多数贪心算法具有较差的渐近时间复杂度。
- en: Technical implementation
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术实现
- en: Let's dig into the implementation of some of the theoretical programming techniques
    that we discussed previously in this chapter. We will start with dynamic programming.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨本章前面讨论的一些理论编程技术的实现。我们将从动态规划开始。
- en: Dynamic programming
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态规划
- en: As we have already described, in this approach, we divide a problem into smaller
    subproblems. In finding the solutions to the subprograms, care is taken not to
    recompute any of the previously encountered subproblems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经描述的，在这种方法中，我们将问题划分为更小的子问题。在寻找子程序的解决方案时，注意不要重新计算之前遇到的任何子问题。
- en: This sounds a bit like recursion, but things are a little broader here. A problem
    may lend itself to being solved by using dynamic programming but will not necessarily
    take the form of making recursive calls.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来有点像递归，但在这里事情要宽泛一些。一个问题可能适合通过使用动态规划来解决，但并不一定采取递归调用的形式。
- en: A property of a problem that will make it an ideal candidate for being solved
    with dynamic programming is that it should have an overlapping set of subproblems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题具有的属性，使其成为使用动态规划解决的理想候选者，是它应该有一个重叠的子问题集。
- en: Once we realize that the form of subproblems has repeated itself during computation,
    we need not compute it again. Instead, we return the result of a pre-computed
    value of that subproblem previously encountered.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们意识到在计算过程中子问题的形式重复出现，我们就不需要再次计算它。相反，我们返回之前遇到的该子问题的预计算值的结果。
- en: To avoid a situation where we never have to re-evaluate a subproblem, we need
    an efficient way in which we can store the results of each subproblem. The following
    two techniques are readily available.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免出现我们永远不需要重新评估子问题的情况，我们需要一种有效的方法来存储每个子问题的结果。以下两种技术是现成的。
- en: Memoization
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: This technique starts from the initial problem set and divides it into small
    subproblems. After the solution to a subprogram has been determined, we store
    the result to that particular subproblem. In the future, when this subproblem
    is encountered, we only return its pre-computed result.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术从初始问题集开始，将其划分为小子问题。在确定子程序的解决方案后，我们将结果存储到特定的子问题中。在将来，当遇到这个子问题时，我们只返回其预计算的值。
- en: Tabulation
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格法
- en: In tabulation, we settle on an approach where we fill a table of solutions to
    subproblems and then combine them to solve bigger problems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格法中，我们采用了一种方法，即先填充一个子问题的解表，然后将它们组合起来解决更大的问题。
- en: The Fibonacci series
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斐波那契数列
- en: We will use the Fibonacci series to illustrate both memoization and tabulation
    techniques of generating the series.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用斐波那契数列来展示生成数列的缓存和表格技术。
- en: The Memoization technique
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存技术
- en: 'Let''s generate the Fibonacci series to the fifth term:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成到第五项的斐波那契数列：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A recursive style of a program to generate the sequence is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 生成序列的递归程序风格如下：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is very simple but a little tricky to read because of the recursive
    calls being made that end up solving the problem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单，但由于递归调用而变得有点难以阅读，这些递归调用最终解决了问题。
- en: When the base case is met, the `fib()` function returns 1\. If `n` is equal
    to or less than 2, the base case is met.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到基本情况时，`fib()` 函数返回 1。如果 `n` 等于或小于 2，则满足基本情况。
- en: 'If the base case is not met, we will call the `fib()` function again and this
    time supply the first call with `n-1` and the second with `n-2`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有遇到基本情况，我们将再次调用 `fib()` 函数，这次将第一个调用提供 `n-1`，第二个调用提供 `n-2`：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The layout of the strategy to solve the i^(th) term in the Fibonacci sequence
    is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 解决斐波那契数列的第 i 项的策略布局如下：
- en: '![](img/image_12_002.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_002.jpg)'
- en: A careful observation of the preceding tree shows some interesting patterns.
    The call to `f(1)` happens twice. The call to `f(1)` happens thrice. Also, the
    call to `f(3)` happens twice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察前面的树形图，可以发现一些有趣的模式。对 `f(1)` 的调用发生了两次。对 `f(1)` 的调用发生了三次。此外，对 `f(3)` 的调用也发生了两次。
- en: The return values of the function calls to all the times that `fib(2)` was called
    never changes. The same goes for `fib(1)` and `fib(3)`. The computational time
    is wasted since the same result is returned for the function calls with the same
    parameters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib(2)` 被调用时所有函数调用的返回值从未改变。对 `fib(1)` 和 `fib(3)` 也是如此。由于相同的参数和输出返回相同的结果，因此计算时间被浪费了。'
- en: These repeated calls to a function with the same parameters and output suggest
    that there is an overlap. Certain computations are reoccurring down in the smaller
    subproblems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些具有相同参数和输出的函数重复调用表明存在重叠。某些计算在较小的子问题中是重复发生的。
- en: A better approach would be to store the results of the computation of `fib(1)`
    the first time it is encountered. This also applies to `fib(2)` and `fib(3)`.
    Later, anytime we encounter a call to `fib(1)`, `fib(2)`, or `fib(3)`, we simply
    return their respective results.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是将`fib(1)`第一次遇到时的计算结果存储起来。这也适用于`fib(2)`和`fib(3)`。以后，每次我们遇到对`fib(1)`、`fib(2)`或`fib(3)`的调用时，我们只需返回它们各自的结果。
- en: 'The diagram of our `fib` calls will now look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`fib`调用的图现在看起来是这样的：
- en: '![](img/image_12_003.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_12_003.jpg)'
- en: 'We have now completely eliminated the need to compute `fib(3)`, `fib(2)`, and
    `fib(1)`. This typifies the memoization technique wherein breaking a problem into
    its subproblems, there is no recomputation of overlapping calls to functions.
    The overlapping function calls in our Fibonacci example are `fib(1)`, `fib(2)`,
    and `fib(3)`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完全消除了计算`fib(3)`、`fib(2)`和`fib(1)`的需求。这典型地代表了记忆化技术，其中将问题分解为其子问题，不会重新计算函数的重复调用。在我们的斐波那契示例中，重叠的函数调用是`fib(1)`、`fib(2)`和`fib(3)`：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create a list of 1,000 elements, we do the following and pass it to the
    lookup parameter of the `dyna_fib` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含1000个元素的列表，我们执行以下操作，并将其传递给`dyna_fib`函数的`lookup`参数：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This list will store the value of the computation of the various calls to the `dyna_fib()`
    function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表将存储对`dyna_fib()`函数的各种调用的计算值：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Any call to the `dyna_fib()` with `n` being less than or equal to 2 will return
    1\. When `dyna_fib(1)` is evaluated, we store the value at index 1 of `map_set`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当`n`小于或等于2时，对`dyna_fib()`的任何调用都将返回1。当`dyna_fib(1)`被评估时，我们将值存储在`map_set`的索引1处：
- en: 'Write the condition for `lookup[n]`, as the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`lookup[n]`的条件，如下所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We pass lookup so that it can be referenced when evaluating the subproblems.
    The calls to `dyna_fib(n-1, lookup)` and `dyna_fib(n-2, lookup)` are stored in
    `lookup[n]`. When we run our updated implementation of the function to find the
    i^(th) term of the Fibonacci series, we realize that there is considerable improvement.
    This implementation runs much faster than our initial implementation. Supply the
    value 20 to both implementations and witness the difference in the execution speed.
    The algorithm sacrificed space complexity for time because of the use of memory
    in storing the result to the function calls.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递`lookup`以便在评估子问题时可以引用它。对`dyna_fib(n-1, lookup)`和`dyna_fib(n-2, lookup)`的调用存储在`lookup[n]`中。当我们运行函数的更新实现以找到斐波那契数列的第i项时，我们发现有很大的改进。这种实现比我们的初始实现运行得快得多。将值20提供给两个实现，并观察执行速度的差异。由于在存储结果到函数调用中使用了内存，算法牺牲了空间复杂度以换取时间。
- en: The tabulation technique
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格技术
- en: There is a second technique in dynamic programming, which involves the use of
    a table of results or matrix in some cases to store results of computations for
    later use.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划中还有第二种技术，它涉及在某些情况下使用结果表或矩阵来存储用于后续使用的计算结果。
- en: 'This approach solves the bigger problem by first working out a route to the
    final solution. In the case of the `fib()` function, we will develop a table with
    the values of `fib(1)` and `fib(2)` predetermined. Based on these two values,
    we will work our way up to `fib(n)`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过首先找到最终解决方案的路径来解决更大的问题。在`fib()`函数的情况下，我们将开发一个包含`fib(1)`和`fib(2)`值的表，这些值预先确定。基于这两个值，我们将逐步计算到`fib(n)`：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `results` variable is at index 0, and 1 the values, 1 and 1\. This represents
    the return values of `fib(1)` and `fib(2)`. To calculate the values of the `fib()`
    function for higher than 2, we simply call the `for` loop appends the sum of the
    `results[i-1] + results[i-2]` to the list of results.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`results`变量位于索引0，值为1和1。这代表了`fib(1)`和`fib(2)`的返回值。为了计算`fib()`函数高于2的值，我们只需调用`for`循环，将`results[i-1]
    + results[i-2]`的和追加到结果列表中。'
- en: Divide and conquer
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解与征服
- en: This programming approach to problem-solving emphasizes the need to break down
    a problem into smaller problems of the same type or form of the original problem.
    These subproblems are solved and combined to solve the original problem. The following
    three steps are associated with this kind of programming.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程方法强调了解决问题时需要将问题分解成与原始问题相同类型或形式的更小问题。这些子问题被解决并组合起来以解决原始问题。与这种编程相关联的以下三个步骤：
- en: Divide
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解
- en: To divide means to break down an entity or problem. Here, we devise the means
    to break down the original problem into subproblems. We can achieve this through
    iterative or recursive calls.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 分割意味着将实体或问题分解。在这里，我们制定将原始问题分解为子问题的方法。我们可以通过迭代或递归调用实现这一点。
- en: Conquer
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 征服
- en: It is impossible to continue to break the problems into subproblems indefinitely.
    At some point, the smallest indivisible problem will return a solution. Once this
    happens, we can reverse our thought process and say that if we know the solution
    to the smallest problem possible, we can obtain the final solution to the original
    problem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能无限期地将问题分解为子问题。在某个时刻，最小的不可分割问题将返回一个解决方案。一旦发生这种情况，我们可以反转我们的思考过程，并说如果我们知道可能的最小问题的解决方案，我们就可以获得原始问题的最终解决方案。
- en: Merge
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并
- en: To obtain the final solution, we need to combine the smaller solutions to the
    smaller problems in order to solve the bigger problem.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最终解决方案，我们需要将解决较小问题的较小解决方案结合起来，以便解决更大的问题。
- en: There are other variants to the divide and conquer algorithm, such as merge
    and combine, and conquer and solve.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 分治算法还有其他变体，例如合并和组合，以及征服和解决。
- en: Algorithms that make use of the divide and conquer principle include merge sorting,
    quick sort, and Strassen's matrix multiplication. We will go through an implementation
    of the merge sort as we started earlier in [Chapter 3](a98d7333-0a20-49b1-8bf1-3e007ddb9793.xhtml),
    *Principles of Algorithm Design*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 利用分治原则的算法包括归并排序、快速排序和斯特拉斯矩阵乘法。我们将从[第3章](a98d7333-0a20-49b1-8bf1-3e007ddb9793.xhtml)
    *算法设计原理*中开始的归并排序实现进行讲解。
- en: Merge sort
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并排序
- en: 'The merge sort algorithm is based on the divide and conquer rule. Given a list
    of unsorted elements, we split the list into approximately two halves. We continue
    to divide the two halves recursively. After a while, the sublists created as a
    result of the recursive call will contain only one element. At that point, we
    begin to merge the solutions in the conquer or merge step:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法基于分治规则。给定一个未排序的元素列表，我们将列表分成大约两半。我们继续递归地分割这两半。经过一段时间，由递归调用创建的子列表将只包含一个元素。在那个时刻，我们开始在征服或合并步骤中合并解决方案：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our implementation starts by accepting the list of unsorted elements into the
    `merge_sort` function. The `if` statement is used to establish the base case,
    where if there is only one element in the `unsorted_list`, we simply return that
    list again. If there is more than one element in the list, we find the approximate
    middle using `mid_point = int((len(unsorted_list))/2)`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现首先通过将未排序的元素列表接受到`merge_sort`函数中开始。`if`语句用于建立基本情况，如果`unsorted_list`中只有一个元素，我们只需再次返回该列表。如果列表中有超过一个元素，我们使用`mid_point
    = int((len(unsorted_list))/2)`找到大约的中间值。
- en: 'Using this `mid_point`, we divide the list into two sublists, namely `first_half`
    and `second_half`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`mid_point`，我们将列表分为两个子列表，即`first_half`和`second_half`：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A recursive call is made by passing the two sublists to the `merge_sort` function
    again:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次将两个子列表传递给`merge_sort`函数，进行递归调用：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Enter the merge step. When `half_a` and `half_b` have been passed their values,
    we call the merge function that will merge or combine the two solutions stored
    in `half_a` and `half_b`, which are lists:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 进入合并步骤。当`half_a`和`half_b`已经传递了它们的值后，我们调用归并函数，该函数将合并或组合存储在`half_a`和`half_b`中的两个解决方案，它们是列表：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The merge function takes the two lists we want to merge together, `first_sublist`
    and `second_sublist`. The `i` and `j` variables are initialized to `0` and are
    used as pointers to tell us where in the two lists we are with respect to the
    merging process. The final `merged_list` will contain the merged list:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 归并函数接受我们想要合并的两个列表，即`first_sublist`和`second_sublist`。变量`i`和`j`被初始化为`0`，并用作指针，告诉我们合并过程中在两个列表中的位置。最终的`merged_list`将包含合并后的列表：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `while` loop starts comparing the elements in `first_sublist` and `second_sublist`.
    The `if` statement selects the smaller of the two, `first_sublist[i]` or `second_sublist[j]`,
    and appends it to `merged_list`. The `i` or `j` index is incremented to reflect
    the point we are at with the merging step. The `while` loop only when either sublist is
    empty.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环开始比较`first_sublist`和`second_sublist`中的元素。`if`语句选择两个中的较小者，即`first_sublist[i]`或`second_sublist[j]`，并将其追加到`merged_list`中。`i`或`j`索引增加以反映合并步骤中的位置。`while`循环仅在任一子列表为空时停止。'
- en: There may be elements left behind in either `first_sublist` or `second_sublist`.
    The last two `while` loops make sure that those elements are added to the `merged_list`
    before it is returned.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `first_sublist` 或 `second_sublist` 中可能会有元素被遗漏。最后的两个 `while` 循环确保在返回之前将这些元素添加到
    `merged_list` 中。
- en: The last call to `merge(half_a, half_b)` will return the sorted list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次调用 `merge(half_a, half_b)` 将返回排序后的列表。
- en: 'Let''s give the algorithm a dry run by playing the last step of merging the
    two sublists `[4, 6, 8]` and `[5, 7, 11, 40]`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过模拟合并两个子列表 `[4, 6, 8]` 和 `[5, 7, 11, 40]` 的最后一步来测试这个算法：
- en: '| **Step** | `first_sublist` | `second_sublist` | `merged_list` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | `first_sublist` | `second_sublist` | `merged_list` |'
- en: '| Step 0 | [**4** 6 8] | [**5** 7 11 40] | [] |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 第零步 | [**4** 6 8] | [**5** 7 11 40] | [] |'
- en: '| Step 1 | [ **6** 8] | [**5** 7 11 40] | [4] |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 第一步 | [ **6** 8] | [**5** 7 11 40] | [4] |'
- en: '| Step 2 | [ **6** 8] | [ **7** 11 40] | [4 5] |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 第二步 | [ **6** 8] | [ **7** 11 40] | [4 5] |'
- en: '| Step 3 | [ **8**] | [ **7** 11 40] | [4 5 6] |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 第三步 | [ **8**] | [ **7** 11 40] | [4 5 6] |'
- en: '| Step 4 | [ **8**] | [ **11** 40] | [4 5 6 7] |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 第四步 | [ **8**] | [ **11** 40] | [4 5 6 7] |'
- en: '| Step 5 | [ ] | [ **11** 40] | [4 5 6 7 8] |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 第五步 | [ ] | [ **11** 40] | [4 5 6 7 8] |'
- en: Note that the text in bold represents the current item referenced in the loops
    `first_sublist` (which uses the index `i`) and `second_sublist` (which uses the
    index `j`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，粗体的文本表示在 `first_sublist`（使用索引 `i`）和 `second_sublist`（使用索引 `j`）循环中引用的当前项。
- en: At this point in the execution, the third `while` loop in the merge function
    kicks in to move 11 and 40 into the `merged_list`. The returned `merged_list`
    will contain the fully sorted list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行的这个阶段，合并函数中的第三个 `while` 循环开始工作，将 11 和 40 移入 `merged_list`。返回的 `merged_list`
    将包含完全排序的列表。
- en: Greedy algorithms
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪婪算法
- en: As we said earlier, greedy algorithms make decisions that yield the largest
    benefit in the interim. It is the hope of this technique that by making these
    high yielding benefit choices, the total path will lead to an overall good solution
    or end.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，贪婪算法做出在短期内带来最大收益的决定。这个技术的希望是，通过做出这些高收益的选择，整个路径将导致一个整体上好的解决方案或结果。
- en: Examples of greedy algorithms include **Prim's algorithm** for finding the minimum
    spanning trees, the **Knapsack problem**, and the **Travelling Salesman problem**,
    just to mention a few.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪算法的例子包括用于找到最小生成树的 **Prim 算法**，**背包问题** 和 **旅行商问题**，仅举几例。
- en: Coin-counting problem
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬币计数问题
- en: Let's examine a very simple use of this greedy technique. In some arbitrary
    country, we have the denominations 1 GHC, 5 GHC, and 8 GHC. Given an amount such
    as 12 GHC, we may want to find the least possible number of denominations needed
    to provide change. Using the greedy approach, we pick the largest value from our
    denomination to divide 12 GHC. We use 8 because it yields the best possible means
    by which we can reduce the amount 12 GHC into lower denominations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察贪婪技术的一个非常简单的应用。在某个任意国家，我们有 1 GHC、5 GHC 和 8 GHC 的面额。给定一个像 12 GHC 这样的金额，我们可能希望找到所需的最少面额数量以提供零钱。使用贪婪方法，我们从面额中选择最大值来分割
    12 GHC。我们使用 8，因为它提供了将 12 GHC 减少到较低面额的最佳方式。
- en: The remainder, 4 GHC, cannot be divided by 5, so we try the 1 GHC denomination
    and realize that we can multiply it by 4 to obtain 4 GHC. At the end of the day,
    the least possible number of denominations to create 12 GHC is to get a one 8
    GHC and four 1 GHC notes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的 4 GHC 不能被 5 整除，所以我们尝试 1 GHC 的面额，并意识到我们可以将其乘以 4 来获得 4 GHC。最终，创建 12 GHC 所需的最少面额数量是得到一张
    8 GHC 和四张 1 GHC 的纸币。
- en: 'So far, our greedy algorithm seems to be doing pretty well. A function that
    returns the respective denominations is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的贪婪算法似乎做得相当不错。一个返回相应面额的函数如下：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This greedy algorithm always starts by using the largest denomination possible.
    `denom` is a list of denominations. `sorted(denom, reverse=True)` will sort the
    list in reverse so that we can obtain the largest denomination at index 0\. Now,
    starting from index 0 of the sorted list of denominations, `sorted_denominations`,
    we iterate and apply the greedy technique:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种贪婪算法始终从可能的最大面额开始。`denom` 是一个面额列表。`sorted(denom, reverse=True)` 将列表按逆序排序，这样我们就可以在索引
    0 处获得最大的面额。现在，从排序后的面额列表 `sorted_denominations` 的索引 0 开始，我们迭代并应用贪婪技术：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The loop will run through the list of denominations. Each time the loop runs,
    it obtains the quotient, `div`, by dividing the `total_amount` by the current
    denomination, `i`. `total_amount` is updated to store the remainder for further
    processing. If the quotient is greater than 0, we store it in `number_of_denoms`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 循环将遍历货币列表。每次循环运行时，它通过将`total_amount`除以当前货币`i`来获取商`div`。`total_amount`更新以存储剩余部分以供进一步处理。如果商大于0，我们将其存储在`number_of_denoms`中。
- en: Unfortunately, there are instances where our algorithm fails. For instance,
    when passed 14 GHS, our algorithm returns one 8 GHC and four 1 GHS. This output
    is, however, not the optimal solution. The right solution will be to use two 5
    GHC and two 1 GHC denominations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的算法在某些情况下会失败。例如，当传入14 GHS时，我们的算法返回一个8 GHC和四个1 GHS。然而，这个输出并不是最优解。正确的解决方案是使用两个5
    GHC和两个1 GHC的货币。
- en: 'A better greedy algorithm is presented here. This time, the function returns
    a list of tuples that allow us to investigate the better results:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了一个更好的贪婪算法。这次，函数返回一个元组列表，使我们能够调查更好的结果：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The outer `for` loop enables us to limit the denominations from which we find
    our solution:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 外部`for`循环使我们能够限制我们从中找到解决方案的货币：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Assuming that we have the list [5, 4, 3] in `sorted_denominations`, slicing
    it with `[j:]` helps us obtain the sublists [5, 4, 3], [4, 3], and [3], from which
    we try to get the right combination to create the change.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个列表[5, 4, 3]在`sorted_denominations`中，使用`[j:]`切片可以帮助我们获得子列表[5, 4, 3]，[4,
    3]和[3]，然后我们尝试从中得到正确的组合来创建零钱。
- en: Dijkstra's shortest path algorithm
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迪杰斯特拉最短路径算法
- en: We introduce and study Dijkstra's algorithm. This algorithm is an example of
    a greedy algorithm. It finds the shortest distance from a source to all other
    nodes or vertices in a graph. By the end of this section, you will come to understand
    why it is classified as a greedy algorithm.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍并研究迪杰斯特拉算法。这个算法是贪婪算法的一个例子。它找到从源点到图中所有其他节点或顶点的最短距离。在本节结束时，你将理解为什么它被归类为贪婪算法。
- en: 'Consider the following graph:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图：
- en: '![](img/CH_12_01.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/CH_12_01.png)'
- en: By inspection, the first answer to the question of finding the shortest path
    between node **A** and node **D** that comes to mind is the edge with value or
    distance 9\. From the diagram, it would seem that the straight path from node
    **A** to **D** would also yield the shortest route between the two nodes. But
    the assumption that the edge connecting the two nodes is the shortest route does
    not always hold true.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查，我们首先想到的从节点**A**到节点**D**的最短路径问题是具有值或距离9的边。从图中看，从节点**A**到**D**的直线路径似乎也会产生两个节点之间的最短路径。但连接两个节点的边是最短路径的假设并不总是成立。
- en: This shortsighted approach of selecting the first option when solving a problem
    is what gives the algorithm its name and class. Having found the supposed shortest
    route or distance, the algorithm continues to refine and improve its results.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在解决问题时选择第一个选项的短视方法赋予了算法其名称和类别。一旦找到所谓的最短路径或距离，算法就会继续优化和改进其结果。
- en: Other paths from node **A** to node **D** prove to be shorter than our initial
    pick. For instance, travelling from node **A** to node **B** to node **C** will
    incur a total distance of 10\. But the route through node **A** to **E**, **F**,
    and **D** is even shorter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点**A**到节点**D**的其他路径证明比我们最初的选择更短。例如，从节点**A**到节点**B**再到节点**C**的总距离为10。但通过节点**A**到**E**、**F**和**D**的路线甚至更短。
- en: We will implement the shortest path algorithm with a single source. Our result
    should help us determine the shortest path from the origin, which in this case
    is **A**, to any other node in the graph.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用单个源实现最短路径算法。我们的结果将帮助我们确定从起点，在本例中是**A**，到图中任何其他节点的最短路径。
- en: The shortest path from node **A** to node **C** is 7 through node **B**. Likewise,
    the shortest path to **F** is through node **E** with a total distance of 5.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点**A**到节点**C**的最短路径是通过节点**B**，总距离为7。同样，到**F**的最短路径是通过节点**E**，总距离为5。
- en: In order to come up with an algorithm to help us find the shortest path in a
    graph, let's solve the problem by hand. Thereafter, we will present the working
    solution in Python.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提出一个帮助我们找到图中最短路径的算法，让我们手动解决这个问题。然后，我们将以Python的形式展示解决方案。
- en: 'In the chapter on graphs, we saw how we could represent a graph with an adjacency
    list. We will use it with a slight modification to enable us capture the distance
    on every edge. A table will be used to also keep track of the shortest distance
    from the source in the graph to any other node. A Python dictionary will be used
    to implement this table. Here is one such table:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于图章节中，我们看到了如何使用邻接表来表示一个图。我们将对其进行轻微修改，以便我们能够捕捉到每条边的距离。我们将使用一个表格来跟踪图中从源节点到任何其他节点的最短距离。我们将使用Python字典来实现这个表格。下面是一个这样的表格：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **从源点到最短距离** | **前一个节点** |'
- en: '| A | 0 | None |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| A | 0 | None |'
- en: '| B | ∞ | None |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| B | ∞ | None |'
- en: '| C | ∞ | None |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| C | ∞ | None |'
- en: '| D | ∞ | None |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| D | ∞ | None |'
- en: '| E | ∞ | None |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| E | ∞ | None |'
- en: '| F | ∞ | None |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| F | ∞ | None |'
- en: 'The adjacency list for the diagram and table is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图和表格的邻接表如下：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The nested dictionary holds the distance and adjacent nodes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套字典包含距离和相邻节点。
- en: This table forms the basis for our effort as we try to solve the problem at
    hand. When the algorithm starts, we have no idea what the shortest distance from
    the source (**A**) to any of the nodes is. To play it safe, we set the values
    in that column to infinity with the exception of node **A**. From the starting
    node, the distance covered from node **A** to node **A** is 0\. So we can safely
    use this value as the shortest distance from node **A** to itself. No prior nodes
    have been visited when the algorithm begins. We therefore mark the previous node
    column of node as `None`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格是我们解决问题的努力的基础。当算法开始时，我们不知道从源节点（**A**）到任何节点的最短距离是多少。为了保险起见，我们将该列的值设置为无穷大，除了节点**A**。从起始节点开始，从节点**A**到节点**A**的距离是0。因此，我们可以安全地使用这个值作为节点**A**到自身的最短距离。算法开始时还没有访问任何前一个节点。因此，我们将节点的前一个节点列标记为`None`。
- en: In step 1 of the algorithm, we start by examining the adjacent nodes of node
    **A**. To find the shortest distance from node **A** to node **B**, we need to
    find the distance from the start node to the previous node of node B, which happens
    to be node **A**, and add it to the distance from node **A** to node **B**. We
    do this for other adjacent nodes of **A**, which are **B**, **E**, and **D**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的第1步中，我们首先检查节点**A**的相邻节点。为了找到节点**A**到节点**B**的最短距离，我们需要找到从起始节点到节点B的前一个节点的距离，这个前一个节点恰好是节点**A**，并将其添加到节点**A**到节点**B**的距离中。我们为**A**的其他相邻节点（**B**、**E**和**D**）做同样的事情。
- en: Using the adjacent node **B** as an example, the distance from the start node
    to the previous node is 0\. The distance from the previous node to the current
    node (**B**) is 5\. This sum is compared with the data in the shortest distance
    column of node B. Since 5 is less than infinity(**∞**), we replace **∞** with
    the smallest of the two, which is 5.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以相邻节点**B**为例，从起始节点到前一个节点的距离是0。从前一个节点到当前节点（**B**）的距离是5。这个总和与节点B的最短距离列中的数据进行比较。由于5小于无穷大（**∞**），我们将**∞**替换为这两个数中的最小值，即5。
- en: 'Any time the shortest distance of a node is replaced by a lesser value, we
    need to update the previous node column too. At the end of the first step, our
    table looks as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每当节点的最短距离被替换为一个更小的值时，我们还需要更新前一个节点列。在第一步结束时，我们的表格如下所示：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **从源点到最短距离** | **前一个节点** |'
- en: '| **A*** | 0 | None |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| B | 5 | A |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| B | 5 | A |'
- en: '| C | ∞ | None |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| C | ∞ | None |'
- en: '| D | 9 | A |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| D | 9 | A |'
- en: '| E | 2 | A |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| E | 2 | A |'
- en: '| F | ∞ | None |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| F | ∞ | None |'
- en: At this point, node **A** is considered visited. As such, we add node **A**
    to the list of visited nodes. In the table, we show that node **A** has been visited
    by making the text bold and appending an asterisk sign to it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，节点**A**被认为是已访问的。因此，我们将节点**A**添加到已访问节点的列表中。在表格中，我们通过使文本加粗并在其后附加一个星号来表示节点**A**已被访问。
- en: In the second step, we find the node with the shortest distance using our table
    as a guide. Node **E** with its value 2 has the shortest distance. This is what
    we can infer from the table about node **E**. To get to node **E**, we must visit
    node **A** and cover a distance of 2\. From node A, we cover a distance of 0 to
    get to the starting node, which is node **A** itself.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们使用表格作为指南找到具有最短距离的节点。具有值2的节点**E**具有最短距离。这就是我们从表格中关于节点**E**可以推断出的内容。要到达节点**E**，我们必须访问节点**A**并覆盖2的距离。从节点A，我们覆盖0的距离到达起始节点，即节点**A**本身。
- en: 'The adjacent nodes of node **E** are **A** and **F**. But node **A** has already
    been visited, so we only consider node **F**. To find the shortest route or distance
    to node **F**, we must find the distance from the starting node to node **E**
    and add it to the distance between node **E** and **F**. We can find the distance
    from the starting node to node **E** by looking at the shortest distance column
    of node **E**, which has the value 2\. The distance from node **E** to **F** can
    be obtained from the adjacency list we developed in Python earlier in this section.
    This distance is 3\. These two sum up to 5, which is less than infinity. Remember
    we are on examining the adjacent node **F**. Since there are more adjacent nodes
    of node **E**, we mark node **E** as visited. Our updated table will have the
    following values:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 节点**E**的相邻节点是**A**和**F**。但节点**A**已经被访问过，所以我们只考虑节点**F**。为了找到到节点**F**的最短路径或距离，我们必须找到从起始节点到节点**E**的距离，并将其加到节点**E**和**F**之间的距离上。我们可以通过查看节点**E**的最短距离列来找到从起始节点到节点**E**的距离，该列的值为2。从节点**E**到**F**的距离可以通过我们在本节前面开发的Python中的邻接表获得。这个距离是3。这两个相加等于5，小于无穷大。记住我们正在检查相邻节点**F**。由于节点**E**还有更多的相邻节点，我们标记节点**E**为已访问。我们的更新表格将具有以下值：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **从源节点到最短距离** | **前一个节点** |'
- en: '| **A*** | 0 | None |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| B | 5 | A |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| B | 5 | A |'
- en: '| C | ∞ | None |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| C | ∞ | None |'
- en: '| D | 9 | A |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| D | 9 | A |'
- en: '| **E*** | 2 | A |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **E*** | 2 | A |'
- en: '| F | 5 | E |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| F | 5 | E |'
- en: 'At this point, we initiate another step. The smallest value in the shortest
    distance column is 5\. We choose **B** instead of **F** purely on an alphabetical
    basis. The adjacent nodes of **B** are **A** and **C**, but node **A** has already
    been visited. Using the rule we established earlier, the shortest distance from
    **A** to **C** is 7\. We arrive at this number because the distance from the starting
    node to node **B** is 5, while the distance from node **B** to **C** is 2\. Since
    the sum, 7, is less than infinity, we update the shortest distance to 7 and update
    the previous node column with node **B**. Now **B** is also marked as visited.
    The new state of the table is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们开始下一步。最短距离列中的最小值是5。我们纯粹基于字母顺序选择**B**而不是**F**。**B**的相邻节点是**A**和**C**，但节点**A**已经被访问过。使用我们之前建立的规则，从**A**到**C**的最短距离是7。我们得到这个数字是因为从起始节点到节点**B**的距离是5，而从节点**B**到**C**的距离是2。由于总和7小于无穷大，我们更新最短距离为7，并在前一个节点列中更新为节点**B**。现在**B**也被标记为已访问。表格的新状态如下：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **从源节点到最短距离** | **前一个节点** |'
- en: '| **A*** | 0 | None |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| **B*** | 5 | A |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **B*** | 5 | A |'
- en: '| C | 7 | B |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| C | 7 | B |'
- en: '| D | 9 | A |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| D | 9 | A |'
- en: '| **E*** | 2 | A |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **E*** | 2 | A |'
- en: '| F | 5 | E |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| F | 5 | E |'
- en: 'The node with the shortest distance yet unvisited is node **F**. The adjacent
    nodes of **F** are nodes **D** and **E**. But node **E** has already been visited.
    As such, we focus on finding the shortest distance from the starting node to node
    **D**. We calculate this distance by adding the distance from node **A** to **F**
    to the distance from node **F** to **D**. This sums up to 7, which is less than
    9\. Thus, we update the 9 with 7 and replace **A** with **F** in node **D**''s
    previous node column. Node **F** is now marked as visited. Here is the updated
    table up to this point:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未访问的最短距离节点是节点**F**。**F**的相邻节点是节点**D**和**E**。但节点**E**已经被访问过。因此，我们专注于找到从起始节点到节点**D**的最短距离。我们通过将节点**A**到**F**的距离与节点**F**到**D**的距离相加来计算这个距离。总和为7，小于9。因此，我们将9更新为7，并在节点**D**的前一个节点列中将**A**替换为**F**。现在**F**也被标记为已访问。以下是到此为止更新的表格：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **从源节点到最短距离** | **前一个节点** |'
- en: '| **A*** | 0 | None |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| **B*** | 5 | A |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **B*** | 5 | A |'
- en: '| C | 7 | B |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| C | 7 | B |'
- en: '| D | 7 | F |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| D | 7 | F |'
- en: '| **E*** | 2 | A |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **E*** | 2 | A |'
- en: '| **F*** | 5 | E |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **F*** | 5 | E |'
- en: Now, the two unvisited nodes are **C** and **D**. In alphabetical order, we
    choose to examine **C** because both nodes have the same shortest distance from
    the starting node **A**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个未访问的节点是**C**和**D**。按字母顺序，我们选择检查**C**，因为这两个节点从起始节点**A**的最短距离相同。
- en: However, all the adjacent nodes of **C** have been visited. Thus, we have nothing
    to do but mark node C as visited. The table remains unchanged at this point.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，**C**的所有相邻节点都已访问过。因此，我们除了将节点**C**标记为已访问外，别无他法。此时表格保持不变。
- en: 'Lastly, we take node **D** and find out that all its adjacent nodes have been
    visited too. We only mark it as visited. The table remains unchanged:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们取节点**D**并发现它的所有相邻节点都已访问过。我们只将其标记为已访问。表保持不变：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **从源到最短距离** | **前一个节点** |'
- en: '| **A*** | 0 | None |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| **B*** | 5 | A |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **B*** | 5 | A |'
- en: '| **C*** | 7 | B |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **C*** | 7 | B |'
- en: '| **D*** | 7 | F |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **D*** | 7 | F |'
- en: '| **E*** | 2 | A |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **E*** | 2 | A |'
- en: '| **F*** | 5 | E |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **F*** | 5 | E |'
- en: Let's verify this table with our graph. From the graph, we know that the shortest
    distance from **A** to **F** is 5\. We will need to go through **E** to get to
    node **F**. According to the table, the shortest distance from the source column
    for node **F** is the value 5\. This is true. It is also tells us that to get
    to node **F**, we need to visit node **E**, and from **E**, node **A**, which
    is our starting node. This is actually the shortest path.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们的图来验证这个表。从图中，我们知道从**A**到**F**的最短距离是5。我们需要通过**E**到达节点**F**。根据表，节点**F**的源列的最短距离是值5。这是正确的。这也告诉我们，要到达节点**F**，我们需要访问节点**E**，然后从**E**到**A**，这是我们的起始节点。这实际上是
    shortest path。
- en: 'We begin the program for finding the shortest distance by representing the
    table that enables us to track the changes in our graph. For the given diagram
    we used, here is a dictionary representation of the table:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过表示一个表来开始寻找最短距离的程序，这个表使我们能够跟踪我们图中变化。对于我们使用的给定图，以下是表的字典表示：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The initial state of the table uses `float("inf")` to represent infinity. Each
    key in the dictionary maps to a list. At the first index of the list is stored
    the shortest distance from the source `A`. At the second index is the stored the
    previous node:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 表的初始状态使用`float("inf")`来表示无穷大。字典中的每个键都映射到一个列表。列表的第一个索引存储从源`A`的最短距离。第二个索引存储前一个节点：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To avoid the use of magic numbers, we use the preceding constants. The shortest
    path column's index is referenced by `DISTANCE`. The previous node column's index
    is referenced by `PREVIOUS_NODE`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用魔法数字，我们使用前面的常量。最短路径列的索引由`DISTANCE`引用。前一个节点列的索引由`PREVIOUS_NODE`引用。
- en: 'Now all is set for the main function. It will take the graph, represented by
    the adjacency list, the table, and the starting node as parameters:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有准备工作都已经完成，主函数将接受由邻接表表示的图、表和起始节点作为参数：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We keep the list of visited nodes in the list, `visited_nodes`. The `current_node`
    and `starting_node` variables will both point to the node in the graph we choose
    to make our starting node. The `origin` value is the reference point for all other
    nodes with respect to finding the shortest path.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将已访问节点的列表保存在`visited_nodes`列表中。`current_node`和`starting_node`变量都将指向我们选择的起始节点。`origin`值是相对于寻找最短路径的所有其他节点的参考点。
- en: 'The heavy lifting of the whole process is accomplished by the use of a `while`
    loop:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程的繁重工作是通过使用一个`while`循环来完成的：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's break down what the `while` loop is doing. In the body of the `while`
    loop, we obtain the current node in the graph we want to investigate with the
    line `adjacent_nodes = graph[current_node]`. `current_node` should have been set
    prior. The `if` statement is used to find out whether all the adjacent nodes of
    `current_node` have been visited. When the `while` loop is executed the fir*s*t
    time, `current_node` will contain A and `adjacent_nodes` will contain nodes B,
    D, and E. `visited_nodes` will be empty too. If all nodes have been visited, we
    only move on to the statements further down the program. Else, we begin a whole
    other step.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下`while`循环正在做什么。在`while`循环的主体中，我们通过`adjacent_nodes = graph[current_node]`这一行获取我们想要调查的图中的当前节点。`current_node`应该已经被设置。`if`语句用于确定`current_node`的所有相邻节点是否都已访问。当`while`循环第一次执行时，`current_node`将包含A，`adjacent_nodes`将包含节点B、D和E。`visited_nodes`也将为空。如果所有节点都已访问，我们则只继续程序中的后续语句。否则，我们开始另一个完整的步骤。
- en: 'The statement `set(adjacent_nodes).difference(set(visited_nodes))` returns
    the nodes that have not been visited. The loop iterates over this list of unvisited
    nodes:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`set(adjacent_nodes).difference(set(visited_nodes))`返回未访问的节点。循环遍历这个未访问节点的列表：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The helper method `get_shortest_distance(table, vertex)` will return the value
    stored in the shortest distance column of our table using one of the unvisited
    nodes referenced by `vertex`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法`get_shortest_distance(table, vertex)`将返回我们表中存储的最短距离列的值，使用由`vertex`引用的未访问节点之一：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we are examining the adjacent nodes of the starting node, `distance_from_starting_node
    == INFINITY and current_node == starting_node` will evaluate to True, in which
    case we only have to get the distance between the starting node and vertex by
    referencing the graph:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查起始节点的相邻节点时，如果 `distance_from_starting_node == INFINITY and current_node
    == starting_node` 评估为 True，那么我们只需通过引用图来获取起始节点和顶点之间的距离：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `get_distance` method is another helper method we use to obtain the value
    (distance) of the edge between `vertex` and `current_node`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_distance` 方法是我们用来获取 `vertex` 和 `current_node` 之间边（距离）值的另一个辅助方法。'
- en: If the condition fails, then we assign `total_distance` the sum of the distance
    from the starting node to `current_node` and the distance between `current_node`
    and `vertex`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件失败，那么我们将 `total_distance` 赋值为从起始节点到 `current_node` 的距离加上 `current_node`
    和 `vertex` 之间的距离。
- en: 'Once we have our total distance, we need to check whether this `total_distance`
    is less than the existing data in the shortest distance column in our table. If
    it is less, then we use the two helper methods to update that row:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了总距离，我们需要检查这个 `total_distance` 是否小于我们表中最短距离列中现有的数据。如果是的话，我们就使用两个辅助方法来更新那一行：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point, we add the `current_node` to the list of visited nodes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将 `current_node` 添加到已访问节点列表中：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If all nodes have been visited, then we must exit the `while` loop. To check
    whether all the nodes have been visited, we compare the length of the `visited_nodes`
    list to the number of keys in our table. If they have become equal, we simply
    exit the `while` loop.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有节点都已访问，那么我们必须退出 `while` 循环。为了检查是否所有节点都已访问，我们比较 `visited_nodes` 列表的长度与我们表中键的数量。如果它们已经相等，我们就简单地退出
    `while` 循环。
- en: The helper method, `get_next_node`, is used to fetch the next node to visit.
    It is this method that helps us find the minimum value in the shortest distance
    column from the starting nodes using our table.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法 `get_next_node` 用于获取要访问的下一个节点。正是这个方法帮助我们通过表找到从起始节点到最短距离列中的最小值。
- en: 'The whole method ends by returning the updated table. To print the table, we
    use the following statements:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 整个方法通过返回更新后的表来结束。为了打印表，我们使用以下语句：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Output for the preceding statement:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前述语句的输出：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For the sake of completeness, let''s find out what the helper methods are doing:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，让我们找出辅助方法在做什么：
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `get_shortest_distance` function returns the value stored in the zero^(th) index
    of our table. At that index, we always store the shortest distance from the starting
    node up to `vertex`. The `set_shortest_distance` function only sets this value
    by the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_shortest_distance` 函数返回我们表中的零（th）索引存储的值。在该索引处，我们始终存储从起始节点到 `vertex` 的最短距离。`set_shortest_distance`
    函数只通过以下方式设置此值：'
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we update the shortest distance of a node, we update its previous node
    using the following method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新一个节点的最短距离时，我们使用以下方法来更新其前一个节点：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Remember that the constant, `PREVIOUS_NODE`, equals 1\. In the table, we store
    the value of the `previous_node` at `table[vertex][PREVIOUS_NODE]`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，常数 `PREVIOUS_NODE` 等于 1。在表中，我们在 `table[vertex][PREVIOUS_NODE]` 存储前一个节点的值。
- en: 'To find the distance between any two nodes, we use the `get_distance` function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到任何两个节点之间的距离，我们使用 `get_distance` 函数：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last helper method is the `get_next_node` function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个辅助方法是 `get_next_node` 函数：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `get_next_node` function resembles a function to find the smallest item
    in a list.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_next_node` 函数类似于一个在列表中查找最小项的函数。'
- en: The function starts off by finding the unvisited nodes in our table by using
    `visited_nodes` to obtain the difference between the two sets of lists. The very
    first item in the list of `unvisited_nodes` is assumed to be the smallest in the
    shortest distance column of `table`. If a lesser value is found while the `for`
    loop runs, the `min_vertex` will be updated. The function then returns `min_vertex`
    as the unvisited vertex or node with the smallest shortest distance from the source.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先通过使用 `visited_nodes` 来获取表中的未访问节点，通过获取两组列表之间的差异。`unvisited_nodes` 列表中的第一个项目被认为是
    `table` 中最短距离列中最小的一个。如果在 `for` 循环运行期间找到更小的值，则 `min_vertex` 将被更新。然后函数将 `min_vertex`
    返回为未访问的顶点或从源点到具有最小最短距离的节点。
- en: The worst-case running time of Dijkstra's algorithm is **O**(*|E| + |V| log
    |V|*), where *|V|* is the number of vertices and *|E|* is the number of edges.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法的最坏情况运行时间是 **O**(*|E| + |V| log |V|*)，其中 *|V|* 是顶点的数量，*|E|* 是边的数量。
- en: Complexity classes
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂度类别
- en: The problems that computer algorithms try to solve fall within a range of difficulty
    by which their solutions are arrived at. In this section, we will discuss the
    complexity classes N, NP, NP-complete, and NP-hard problems.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机算法试图解决的问题范围很广，它们的解决方案是通过一系列逻辑步骤得出的。在本节中，我们将讨论 N、NP、NP-完全和 NP-难问题。
- en: P versus NP
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P 与 NP
- en: The advent of computers has sped up the rate at which certain tasks are performed.
    In general, computers are good at perfecting the art of calculation and all problems
    that can be reduced to a set of mathematical computations. However, this assertion
    is not entirely true. There are some nature or classes of problems that just take
    an enormous amount of time for the computer to make a sound guess, let alone find
    the right solution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的出现加快了某些任务执行的速度。一般来说，计算机擅长完善计算艺术以及所有可以归结为一系列数学计算的问题。然而，这个说法并不完全正确。有一些自然或问题类别，计算机需要花费大量时间才能做出合理的猜测，更不用说找到正确的解决方案了。
- en: In computer science, the class of problems that computers can solve within polynomial
    time using a step-wise process of logical steps is called P-type problems, where
    P stands for polynomial. These are relatively easy to solve.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，计算机可以在多项式时间内通过一系列逻辑步骤解决的问题类别被称为 P 类问题，其中 P 代表多项式。这些相对容易解决。
- en: Then there is another class of problems that is considered very hard to solve.
    The word "hard problem" is used to refer to the way in which problems increase
    in difficulty when trying to find a solution. However, the good thing is that
    despite the fact that these problems have a high growth rate of difficulty, it
    is possible to determine whether a proposed solution solves the problem in polynomial
    time. These are the NP-Type problems. NP here stands for nondeterministic polynomial
    time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有另一类被认为非常难以解决的问题。术语“难题”用来指代在寻找解决方案时问题难度增加的方式。然而，好事是尽管这些问题的难度增长速度很快，但可以确定一个提出的解决方案是否在多项式时间内解决了问题。这些都是
    NP 类问题。这里的 NP 代表非确定性多项式时间。
- en: Now the million dollar question is, does N = NP?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的百万美元问题就是，N 是否等于 NP？
- en: The proof for *N = NP* is one of the Millennium Prize Problems from the Clay
    Mathematics Institute that attract a $1,000,000 prize for a correct solution.
    These problems number 7 in number.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*N = NP* 的证明是克莱数学研究所的千禧年大奖难题之一，正确解决这些问题可以获得 100 万美元的奖金。这些问题共有 7 个。'
- en: 'The Travelling Salesman problem is an example of an NP-Type problem. The problem
    statement says: given that there are *n* number of cities in some country, find
    the shortest route between all the cities, thus making the trip a cost-effective
    one. When the number of cities is small, this problem can be solved in a reasonable
    amount of time. However, when the number of cities is above any two-digit number,
    the time taken by the computer is remarkably long.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行商问题是一个典型的 NP 类问题。问题陈述是这样的：假设某个国家有 *n* 个城市，找到所有城市之间的最短路线，从而使旅行变得经济高效。当城市数量较少时，这个问题可以在合理的时间内解决。然而，当城市数量超过任何两位数时，计算机所需的时间就非常长了。
- en: A lot of computer systems and cybersecurity is based on the RSA encryption algorithm.
    The strength of the algorithm and its security is due to the fact that it is based
    on the integer factoring problem, which is an NP-Type problem.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机系统和网络安全都基于 RSA 加密算法。该算法的强度及其安全性是由于它基于整数分解问题，这是一个 NP 类问题。
- en: 'Finding the prime factors of a prime number composed of many digits is very
    difficult. When two large prime numbers are multiplied, a large non-prime number
    is obtained with only two large prime factors. Factorization of this number is
    where many cryptographic algorithms borrow their strength:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 找出由许多数字组成的质数的质因数是非常困难的。当两个大质数相乘时，得到一个只有两个大质因数的大非质数。这个数的分解是许多加密算法借力的地方：
- en: '![](img/p_vs_np.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/p_vs_np.jpg)'
- en: All P-type problems are subsets of NP problems. This means that any problem
    that can be solved in polynomial time can also be verified in polynomial time.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 P 类问题都是 NP 问题的子集。这意味着任何可以在多项式时间内解决的问题也可以在多项式时间内验证。
- en: But the question, is P = NP? investigates whether problems that can be verified
    in polynomial time can also be solved in polynomial time. In particular, if they
    are equal, it would mean that problems that are solved by trying a number of possible
    solutions can be solved without the need to actually try all the possible solutions,
    invariably creating some sort of shortcut proof.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题，P = NP？探讨的是否存在可以在多项式时间内验证的问题也可以在多项式时间内解决。特别是，如果它们相等，这意味着可以通过尝试多种可能的解决方案来解决的问题，可以在不实际尝试所有可能的解决方案的情况下解决，从而不可避免地创造出某种形式的捷径证明。
- en: The proof, when finally discovered, will definitely have serious consequences
    in the fields of cryptography, game theory, mathematics, and many other fields.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当最终被发现时，这个证明无疑将在密码学、博弈论、数学以及许多其他领域产生严重影响。
- en: NP-Hard
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NP-Hard
- en: A problem is NP-Hard if all other problems in NP can be polynomial time reducible
    or mapped to it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个问题是NP-Hard，那么NP中的所有其他问题都可以在多项式时间内归约或映射到它。
- en: NP-Complete
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NP-Complete
- en: A problem is considered an NP-complete problem if it is first of all an NP hard
    and is also found in the `NP` class.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个问题首先是一个NP hard问题，并且也被发现在`NP`类中，那么它被认为是一个NP-complete问题。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this last chapter, we looked at the theories that support the computer science
    field. Without the use of too much mathematical rigor, we saw some of the main
    categories into which algorithms are classified. Other design techniques in the
    field, such as the divide and conquer, dynamic programming, and greedy algorithms,
    were also discussed, along with sample implementations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们研究了支持计算机科学领域的理论。没有使用过多的数学严谨性，我们看到了算法被分类的主要类别。该领域的其他设计技术，如分而治之、动态规划和贪心算法，也被讨论，并附有示例实现。
- en: Lastly, one of the outstanding problems yet to be solved in the field of mathematics
    was tackled. We saw how the proof for P = NP? will definitely be a game-changer
    in a number of fields, if such a proof is ever discovered.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数学领域尚未解决的众多突出问题之一得到了解决。我们看到了P = NP？的证明如何肯定会在多个领域产生变革，如果这样的证明被发现的话。
