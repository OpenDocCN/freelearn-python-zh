<html><head></head><body>
		<div id="_idContainer048">
			<h1 id="_idParaDest-88" class="chapter-number"><a id="_idTextAnchor091"/>5</h1>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor092"/>Testing the REST API</h1>
			<p>In software engineering, testing is a process to check whether the actual software product performs as expected and is <span class="No-Break">bug free.</span></p>
			<p>There are a lot of ways to test software through both manual and automated tests. But in this project, we’ll <a id="_idIndexMarker239"/>focus more on <strong class="bold">automated testing</strong>. However, we’ll first dive into the different ways of testing software, including their pros and their cons, and also talk about <a id="_idIndexMarker240"/>the concept of the <strong class="bold">testing pyramid</strong>. We’ll also check the tools needed to add tests to a Django application and add tests to the models and the viewsets. This chapter will help you understand testing for developers and also how to write tests for a <span class="No-Break">Django API.</span></p>
			<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What <span class="No-Break">is testing?</span></li>
				<li>Testing <span class="No-Break">in Django</span></li>
				<li>Configuring the <span class="No-Break">testing environment</span></li>
				<li>Writing tests for <span class="No-Break">Django models</span></li>
				<li>Writing tests for <span class="No-Break">Django viewsets</span></li>
			</ul>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor093"/>Technical requirements</h1>
			<p>You can find the code of the current chapter at this <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5"><span class="No-Break">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor094"/>What is testing?</h1>
			<p>To make <a id="_idIndexMarker241"/>it simple, testing is finding out how well <span class="No-Break">something works.</span></p>
			<p>However, the process comprises a group of techniques to determine the correctness of the application under a script or manual test directly on the user interface. The aim is to detect failures, including bugs and performance issues, in the application, so that they can <span class="No-Break">be corrected.</span></p>
			<p>Most of the time, testing is <a id="_idIndexMarker242"/>done by comparing the software requirements to the actual software product. If one of the requirements is to make sure that input only accepts numbers and not characters or files, a test will be conducted to check whether the input has a validation system to reject non-number values in <span class="No-Break">the input.</span></p>
			<p>However, testing also involves an examination of code and the execution of code in various environments <span class="No-Break">and conditions.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor095"/>What is software testing?</h2>
			<p>Software testing is the process of examining the behavior of the software under test for validation or verification. It considers the attributes of reliability, scalability, reusability, and usability <a id="_idIndexMarker243"/>to evaluate the execution of the software components (servers, database, application, and so on) and find software bugs, errors, <span class="No-Break">or defects.</span></p>
			<p>Software testing <a id="_idIndexMarker244"/>has a lot of benefits, some of which are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Cost effectiveness</strong>: Testing any software project helps the business save money in the long run. As the process helps detect bugs and check whether newly added features are working in the system without breaking things, it’s a great technical <span class="No-Break">debt reducer.</span></li>
				<li><strong class="bold">Security</strong>: If testing is done well, it can be a quick way to detect security risks and problems at an early stage before deploying a product to the <span class="No-Break">whole world.</span></li>
				<li><strong class="bold">Product quality</strong>: Testing helps with performance measurement, making sure that the requirements <span class="No-Break">are respected.</span></li>
			</ul>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor096"/>Why is software testing important?</h2>
			<p>Testing your <a id="_idIndexMarker245"/>software is important because it helps reduce the impact of bugs through bug identification and resolution. Some bugs can be quite dangerous and can lead to financial losses or endanger human life. Here are some <span class="No-Break">historical examples:</span></p>
			<p><span class="No-Break">Source: </span><a href="https://lexingtontechnologies.ng/software-testing/"><span class="No-Break">https://lexingtontechnologies.ng/software-testing/</span></a><span class="No-Break">.</span></p>
			<ul>
				<li>In April 1999, $1.2 billion were lost due to the failure of a military satellite launch. To date, this is the costliest accident in the history of <span class="No-Break">the world.</span></li>
				<li>In 2014, the giant Nissan recalled over 1 million cars from the market because of a software failure in the airbag <span class="No-Break">sensory detectors.</span></li>
				<li>In 2014,  some of Amazon's third-party retailers lost a lot of money because of a software glitch. The bug affected the price of the products, reducing them <span class="No-Break">to 1p.</span></li>
				<li>In 2015, a software failure in the <strong class="bold">Point of sales</strong> (<strong class="bold">POS</strong>) system of Starbucks stores caused the temporary closure of more than 60% of their stores in the US and Canada. </li>
				<li>In 2015, an F-35 fighter plane fell victim to a software bug, which prevented it from detecting or identifying targets correctly. The sensor on the plane was unable to identify threats even from their <span class="No-Break">own planes.</span></li>
				<li>In 2016, Google reported a bug affecting Windows 10 machines. The vulnerability allowed users to escape security sandboxes through a flow in the <span class="No-Break">win32k system.</span></li>
			</ul>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>What are the various types of testing?</h2>
			<p>Testing is <a id="_idIndexMarker246"/>typically classified into <span class="No-Break">three categories:</span></p>
			<ul>
				<li><strong class="bold">Functional testing</strong>: This <a id="_idIndexMarker247"/>type of testing comprises unit, integration, user acceptance, globalization, internationalization testing, and <span class="No-Break">so on</span></li>
				<li><strong class="bold">Non-functional testing</strong>: This <a id="_idIndexMarker248"/>type of testing checks for factors such as performance, volume, scalability, usability, <span class="No-Break">and load</span></li>
				<li><strong class="bold">Maintenance testing</strong>: This <a id="_idIndexMarker249"/>type of testing considers regression <span class="No-Break">and maintenance</span></li>
			</ul>
			<p>However, these tests <a id="_idIndexMarker250"/>can also be classified into two <span class="No-Break">different types:</span></p>
			<ul>
				<li><span class="No-Break">Automated tests</span></li>
				<li><span class="No-Break">Manual tests</span></li>
			</ul>
			<p>First, let’s see what manual <span class="No-Break">testing is.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor098"/>Understanding manual testing</h2>
			<p><strong class="bold">Manual testing</strong> is the <a id="_idIndexMarker251"/>process of testing software manually to find defects or bugs. It’s the process of testing the functionalities of an application without the help of <span class="No-Break">automation tools.</span></p>
			<p>An example of manual testing is when test users are called to test an application or a special feature. They can be asked to test a specific form, push the application to its limits when it comes to performance, and <span class="No-Break">much more.</span></p>
			<p>Manual testing <a id="_idIndexMarker252"/>has a lot <span class="No-Break">of advantages:</span></p>
			<ul>
				<li>It’s very useful to test user interface designs <span class="No-Break">and interactions</span></li>
				<li>It’s easier to learn for <span class="No-Break">new testers</span></li>
				<li>It takes user experience and usability <span class="No-Break">into consideration</span></li>
				<li><span class="No-Break">It’s cost-effective</span></li>
			</ul>
			<p>However, manual <a id="_idIndexMarker253"/>testing also has <span class="No-Break">some cons:</span></p>
			<ul>
				<li>It requires <span class="No-Break">human resources.</span></li>
				<li><span class="No-Break">It’s time-consuming.</span></li>
				<li>Testers consider test cases based on their skills and experience. This means that a beginner tester may not cover all <span class="No-Break">the functions.</span></li>
			</ul>
			<p>Even if manual testing sounds very appealing, it can be quite a time- and resource-consuming exercise, and developers definitely do not make really good manual testers. Let’s see how <a id="_idIndexMarker254"/>automated testing can erase the cons of manual testing and place better development at the center <span class="No-Break">of testing.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor099"/>Understanding automated testing</h2>
			<p><strong class="bold">Automated testing</strong> is simply <a id="_idIndexMarker255"/>the process of testing software using automation tools to find defects. These automation tools can be scripts written in the language <a id="_idIndexMarker256"/>used to <a id="_idIndexMarker257"/>build the application or some software <a id="_idIndexMarker258"/>or drivers (such as <strong class="bold">Selenium</strong>, <strong class="bold">WinRunner</strong>, and <strong class="bold">LoadRunner</strong>) to make automated testing easier <span class="No-Break">and faster.</span></p>
			<p>Automated testing <a id="_idIndexMarker259"/>fixes the cons of manual testing, and it also has more advantages, as shown in the <span class="No-Break">following list:</span></p>
			<ul>
				<li>Faster <span class="No-Break">in execution</span></li>
				<li>Cheaper than manual testing in the <span class="No-Break">long run</span></li>
				<li>More reliable, powerful, <span class="No-Break">and versatile</span></li>
				<li>Very useful in <span class="No-Break">regression testing</span></li>
				<li>Able to provide better <span class="No-Break">test coverage</span></li>
				<li>Possible to run without <span class="No-Break">human intervention</span></li>
				<li><span class="No-Break">Much cheaper</span></li>
			</ul>
			<p>However, automated <a id="_idIndexMarker260"/>testing is also inconvenient in <span class="No-Break">some ways:</span></p>
			<ul>
				<li>It is expensive at <span class="No-Break">the beginning</span></li>
				<li>It has a huge cost of maintenance when <span class="No-Break">requirements change</span></li>
				<li>Automated testing tools <span class="No-Break">are expensive</span></li>
			</ul>
			<p>The real value of automated testing and manual testing comes when each is used in the <span class="No-Break">right environment.</span></p>
			<p>For example, manual testing is much more useful on frontend projects where you want to test the usability and user experience. Automated testing can be useful to test methods or <a id="_idIndexMarker261"/>functions in the code and is very useful for finding bugs or <span class="No-Break">security issues.</span></p>
			<p>In this chapter, we’ll focus on writing automated tests in Python. As we are developing an API, we want to make sure that the system is reliable and behaves as we want it to, but it should also be secure against the possible issues of the next <span class="No-Break">added feature.</span></p>
			<p>This said, let’s talk <a id="_idIndexMarker262"/>about testing in Django and introduce the notion of <strong class="bold">test-driven </strong><span class="No-Break"><strong class="bold">development</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">TDD</strong></span><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor100"/>Testing in Django</h1>
			<p>Testing in Python, particularly in Django, is very simple and easy. The framework actually provides <a id="_idIndexMarker263"/>many tools and utilities you can use to write tests for the models, serializers, or views in <span class="No-Break">the application.</span></p>
			<p>However, the Python ecosystem for testing relies a lot on one tool to write tests, and this tool has <a id="_idIndexMarker264"/>deep integration with Django. The tool is named <strong class="bold">Pytest</strong> (<a href="https://docs.pytest.org">https://docs.pytest.org</a>) and is a framework for writing small and readable tests. Used with Django, Pytest is mainly used for API testing by writing code to test API endpoints, databases, and <span class="No-Break">user interfaces.</span></p>
			<p>But why use Pytest? Well, it has the <span class="No-Break">following advantages:</span></p>
			<ul>
				<li>It is free and <span class="No-Break">open source</span></li>
				<li>It has a simple syntax and is very easy to <span class="No-Break">start with</span></li>
				<li>It automatically detects test files, functions, <span class="No-Break">and classes</span></li>
				<li>It can run multiple tests in parallel, increasing the performance and the speed of <span class="No-Break">running tests</span></li>
			</ul>
			<p>We’ll use <a id="_idIndexMarker265"/>Pytest in <a id="_idIndexMarker266"/>this project to write two kinds of tests: <strong class="bold">integration tests</strong> and <span class="No-Break"><strong class="bold">unit tests</strong></span><span class="No-Break">.</span></p>
			<p>Before starting to code, let’s learn about integration testing and unit testing by considering the concepts of TDD and the <span class="No-Break">testing pyramid.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor101"/>The testing pyramid</h2>
			<p>The testing pyramid <a id="_idIndexMarker267"/>is a framework that can help developers start with testing to create high-quality software. Basically, the testing pyramid specifies the types of tests that should be included in an automated <span class="No-Break">test suite.</span></p>
			<p>First of all, remember <a id="_idIndexMarker268"/>that the testing pyramid operates at <span class="No-Break">three levels:</span></p>
			<ul>
				<li><span class="No-Break">Unit tests</span></li>
				<li><span class="No-Break">Integration tests</span></li>
				<li><span class="No-Break">End-to-end tests</span></li>
			</ul>
			<p>The following figure shows the positions of each of these levels in the pyramid and how they are prioritized in terms of the speed performance and level of integration <span class="No-Break">or isolation:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_5.1_B18221.jpg" alt="Figure 5.1 – The testing pyramid"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The testing pyramid</p>
			<p>In the preceding figure, the base level is occupied by unit testing. Unit tests target individual <a id="_idIndexMarker269"/>components or functionality to check whether they work as expected in isolated conditions. In our backend project, an example would be to test whether the <strong class="source-inline">like_post</strong> method on the <strong class="source-inline">User</strong> class model actually performs as intended. We are not testing the whole <strong class="source-inline">User</strong> model; we are testing one method of the <strong class="source-inline">User</strong> <span class="No-Break">model class.</span></p>
			<p>It’s definitely a good habit to write a lot of unit tests. They should comprise at least 60% of all the tests in your code base because they are fast, short, and test a lot <span class="No-Break">of components.</span></p>
			<p>On the second level, you have integration tests. If unit tests verify small pieces of a code base, integration tests test how this code interacts with other code or other parts of the software. A useful, albeit controversial, example of integration testing is writing a test for a viewset. When testing a viewset, you are also testing the permissions, the authentication classes, the serializers, the models, and the database if possible. It’s a test of how the different parts of the Django API <span class="No-Break">work together.</span></p>
			<p>An integration test can also be a test between your application and an external service, a payment API, <span class="No-Break">for example.</span></p>
			<p>On the third <a id="_idIndexMarker270"/>level at the top of the pyramid, you have end-to-end tests. These kinds of tests ensure that the software is working as required. They test how the application works from beginning <span class="No-Break">to end.</span></p>
			<p>In this book, we’ll focus on unit and integration testing. Note that integration tests are the subject of some misunderstandings that will be cleared up once we define them. According to my personal experience, unit tests in Django are written more on the model and serializer side of each application. They can be used for testing the creation of an object in the database as well as for retrieving, updating, <span class="No-Break">or deletion.</span></p>
			<p>Regarding viewset tests, I believe that they can act as integration tests because running them calls on permissions, authentication, serializers, validation, and also models, depending on the action you <span class="No-Break">are performing.</span></p>
			<p>Returning to unit tests, they are more effective when using TDD, which comprises software development practices that focus on writing unit test cases before developing the feature. Even if it <a id="_idIndexMarker271"/>sounds counter-intuitive, TDD has a lot <span class="No-Break">of advantages:</span></p>
			<ul>
				<li>It ensures <span class="No-Break">optimized code</span></li>
				<li>It ensures the application of design patterns and <span class="No-Break">better architecture</span></li>
				<li>It helps the developer understand the <span class="No-Break">business requirements</span></li>
				<li>It makes the code flexible and easier <span class="No-Break">to maintain</span></li>
			</ul>
			<p>However, we didn’t particularly respect the TDD rule in the book. We relied on the Django shell and a client to test the feature of the REST API we are building. For the next features that will be added to the project, tests will be written before coding <span class="No-Break">the feature.</span></p>
			<p>With concepts such as TDD, unit and integration testing, and testing pyramid understood, we can now configure the <span class="No-Break">testing environment.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor102"/>Configuring the testing environment</h1>
			<p>Pytest, taken alone, is simply a Python framework to write unit tests in Python programs. Thankfully, there is a plugin for Pytest to write tests in Django projects <span class="No-Break">and applications.</span></p>
			<p>Let’s install <a id="_idIndexMarker272"/>and configure the environment for testing by using the <span class="No-Break">following command:</span></p>
			<pre class="console">
pip install pytest-django</pre>
			<p>Once the package is installed, create a new file called <strong class="source-inline">pytest.ini</strong> at the root of the <span class="No-Break">Django project:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">pytest.ini</p>
			<pre class="source-code">
[pytest]
DJANGO_SETTINGS_MODULE=CoreRoot.settings
python_files=tests.py test_*.py *_tests.py</pre>
			<p>Once it’s done, run the <span class="No-Break"><strong class="source-inline">pytest</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
pytest</pre>
			<p>You’ll see the <span class="No-Break">following output:</span></p>
			<pre class="console">
======================== test session starts ============================
platform linux -- Python 3.10.2, pytest-7.0.1, pluggy-1.0.0
django: settings: CoreRoot.settings (from ini)
rootdir: /home/koladev/PycharmProjects/Full-stack-Django-and-React, configfile: pytest.ini
plugins: django-4.5.2
collected 0 items</pre>
			<p>Great! Pytest is installed in the project, and we can write the first test in the project to test <span class="No-Break">the configuration.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor103"/>Writing your first test</h2>
			<p>The Pytest <a id="_idIndexMarker273"/>environment is configured, so let’s see how we can write a simple test <span class="No-Break">using Pytest.</span></p>
			<p>At the root of the project, create a file called <strong class="source-inline">tests.py</strong>. We’ll simply write a test to test the sum of <span class="No-Break">a function.</span></p>
			<p>Following the TDD concept, we’ll write the test first and make <span class="No-Break">it fail:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">tests.py</p>
			<pre class="source-code">
def test_sum():
   assert add(1, 2) == 3</pre>
			<p>This function is written to check for a condition, justifying the usage of the <strong class="source-inline">assert</strong> Python keyword. If the condition after the <strong class="source-inline">assert</strong> is true, the script will continue or stop the execution. If that’s not the case, an assertion error will <span class="No-Break">be raised.</span></p>
			<p>If you run the <strong class="source-inline">pytest</strong> command, you’ll receive the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_5.2_B18221.jpg" alt="Figure 5.2 – Failing tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Failing tests</p>
			<p>From the preceding output, we are sure that the test has failed. Let’s now write the feature to pass <span class="No-Break">the test.</span></p>
			<p>In the same file, <strong class="source-inline">tests.py</strong>, add the <span class="No-Break">following function:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">tests.py</p>
			<pre class="source-code">
def add(a, b):
   return a + b
def test_sum():
   assert sum(1, 2) == 3</pre>
			<p>Now, run the <strong class="source-inline">pytest</strong> command <a id="_idIndexMarker274"/>again in the terminal. Everything should now <span class="No-Break">be green:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_5.3_B18221.jpg" alt="Figure 5.3 – ﻿Test passes successfully"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Test passes successfully</p>
			<p>Great! You have written the first test in the project using Pytest. In the next section, we’ll be writing tests for the models of <span class="No-Break">the project.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor104"/>Writing tests for Django models</h1>
			<p>When applying testing to a Django project, it’s always a good idea to start with writing tests for <a id="_idIndexMarker275"/>the models. But why test <span class="No-Break">the models?</span></p>
			<p>Well, it gives you better confidence in your code and the connections to the database. It’ll make sure that methods or attributes on the model are well represented in the database, but it can also help you with better code structure, resolving bugs, and <span class="No-Break">building documentation.</span></p>
			<p>Without further ado, let’s start by writing tests for the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> model.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor105"/>Writing tests for the User model</h2>
			<p>Inside <a id="_idIndexMarker276"/>the <strong class="source-inline">core/user</strong> directory, create a new <a id="_idIndexMarker277"/>file called <strong class="source-inline">tests.py</strong>. We’ll write tests to create a user and a <span class="No-Break">simple user:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests.py</p>
			<pre class="source-code">
import pytest
from core.user.models import User
data_user = {
   "username": "test_user",
   "email": "test@gmail.com",
   "first_name": "Test",
   "last_name": "User",
   "password": "test_password"
}</pre>
			<p>Once the <a id="_idIndexMarker278"/>imports and the data to <a id="_idIndexMarker279"/>create the user have been added, we can write the <span class="No-Break">test function:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests.py</p>
			<pre class="source-code">
@pytest.mark.django_db
def test_create_user():
   user = User.objects.create_user(**data_user)
   assert user.username == data_user["username"]
   assert user.email == data_user["email"]
   assert user.first_name == data_user["first_name"]
   assert user.last_name == data_user["last_name"]</pre>
			<p>Above the <strong class="source-inline">test_create_user</strong> function, you’ll probably notice some syntax. It’s called a decorator, and it’s basically a function that takes another function as its argument and returns <span class="No-Break">another function.</span></p>
			<p><strong class="source-inline">@pytest.mark.django_db</strong> gives us access to the Django database. Try to remove this decorator and run <span class="No-Break">the tests.</span></p>
			<p>You’ll get an error output with a similar message at <span class="No-Break">the end:</span></p>
			<pre class="console">
=================================================================== short test summary info ===================================================================
FAILED core/user/tests.py::test_create_user - RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixture...</pre>
			<p>Well, re-add the decorator and run the <strong class="source-inline">pytest</strong> command and all tests should <span class="No-Break">pass normally.</span></p>
			<p>Let’s do <a id="_idIndexMarker280"/>another test to make sure that the <a id="_idIndexMarker281"/>creation of <strong class="source-inline">superuser</strong> <span class="No-Break">works perfectly.</span></p>
			<p>Add a new dictionary containing the data needed to <span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">superuser</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests.py</p>
			<pre class="source-code">
data_superuser = {
   "username": "test_superuser",
   "email": "testsuperuser@gmail.com",
   "first_name": "Test",
   "last_name": "Superuser",
   "password": "test_password"
}</pre>
			<p>And here’s the function that tests the creation <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">superuser</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests.py</p>
			<pre class="source-code">
@pytest.mark.django_db
def test_create_superuser():
   user = User.objects.create_superuser(**data_superuser)
   assert user.username == data_superuser["username"]
   assert user.email == data_superuser["email"]
   assert user.first_name == data_superuser["first_name"]
   assert user.last_name == data_superuser["last_name"]
   assert user.is_superuser == True
   assert user.is_staff == True</pre>
			<p>Run the <a id="_idIndexMarker282"/>tests again, and everything should <a id="_idIndexMarker283"/><span class="No-Break">be green.</span></p>
			<p>Great! Now that we have a better understanding of how <strong class="source-inline">pytest</strong> works for tests, let’s write tests for the <span class="No-Break"><strong class="source-inline">Post</strong></span><span class="No-Break"> model.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor106"/>Writing tests for the Post model</h2>
			<p>To create a model, we need to have a user object ready. This will also be the same for the <strong class="source-inline">Comment</strong> model. To avoid repetition, we’ll simply <span class="No-Break">write </span><span class="No-Break"><strong class="bold">fixtures</strong></span><span class="No-Break">.</span></p>
			<p>A fixture <a id="_idIndexMarker284"/>is a function that will run before each <a id="_idIndexMarker285"/>test function to which it’s applied. In this case, the fixture will be used to feed some data to <span class="No-Break">the tests.</span></p>
			<p>To add fixtures in the project, create a new Python package called <strong class="source-inline">fixtures</strong> in the <span class="No-Break"><strong class="source-inline">core</strong></span><span class="No-Break"> directory.</span></p>
			<p>In the <strong class="source-inline">core/fixtures</strong> directory, create a file called <strong class="source-inline">user.py</strong>. This file will contain a <span class="No-Break">user fixture:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/fixtures/user.py</p>
			<pre class="source-code">
import pytest
from core.user.models import User
data_user = {
   "username": "test_user",
   "email": "test@gmail.com",
   "first_name": "Test",
   "last_name": "User",
   "password": "test_password"
}
@pytest.fixture
def user(db) -&gt; User:
   return User.objects.create_user(**data_user)</pre>
			<p>In the <a id="_idIndexMarker286"/>preceding code, the <strong class="source-inline">@pytest.fixture</strong> decorator <a id="_idIndexMarker287"/>labels the function as a fixture. We can now import the <strong class="source-inline">user</strong> function in any test and pass it as an argument to the <span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> function.</span></p>
			<p>Inside the <strong class="source-inline">core/post</strong> directory, create a new file called <strong class="source-inline">tests.py</strong>. This file will then test for the creation of <span class="No-Break">a post.</span></p>
			<p>Here’s <span class="No-Break">the code:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests.py</p>
			<pre class="source-code">
import pytest
from core.fixtures.user import user
from core.post.models import Post
@pytest.mark.django_db
def test_create_post(user):
   post = Post.objects.create(author=user,
                              body="Test Post Body")
   assert post.body == "Test Post Body"
   assert post.author == user</pre>
			<p>As you <a id="_idIndexMarker288"/>can see, we are importing the <strong class="source-inline">user</strong> function from <strong class="source-inline">user.py</strong> in the <a id="_idIndexMarker289"/>fixtures directory and passing it as an argument to the <strong class="source-inline">test_create_post</strong> <span class="No-Break">test function.</span></p>
			<p>Run the <strong class="source-inline">pytest</strong> command, and everything should <span class="No-Break">be green.</span></p>
			<p>Now that we have a working test for the <strong class="source-inline">Post</strong> model, let’s write tests for the <span class="No-Break"><strong class="source-inline">Comment</strong></span><span class="No-Break"> model.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor107"/>Writing tests for the Comment model</h2>
			<p>Writing tests for the <strong class="source-inline">Comment</strong> model requires the same steps as the tests for the <strong class="source-inline">Post</strong> model. First <a id="_idIndexMarker290"/>of all, create a new file called <strong class="source-inline">post.py</strong> in the <span class="No-Break"><strong class="source-inline">core/fixtures</strong></span><span class="No-Break"> directory.</span></p>
			<p>This file <a id="_idIndexMarker291"/>will contain the fixture of a post, as it’s needed to create <span class="No-Break">a comment.</span></p>
			<p>But the <strong class="source-inline">post</strong> fixture will also need a <strong class="source-inline">user</strong> fixture. Thankfully, it’s possible with Pytest to inject fixtures into <span class="No-Break">other fixtures.</span></p>
			<p>Here’s the code for the <span class="No-Break"><strong class="source-inline">post</strong></span><span class="No-Break"> fixture:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/fixtures/post.py</p>
			<pre class="source-code">
import pytest
from core.fixtures.user import user
from core.post.models import Post
@pytest.fixture
def post(db, user):
   return Post.objects.create(author=user,
                              body="Test Post Body")</pre>
			<p>Great! With <a id="_idIndexMarker292"/>the fixtures added, we can now <a id="_idIndexMarker293"/>write the test for <span class="No-Break">comment creation.</span></p>
			<p>Inside the <strong class="source-inline">core/comment/</strong> directory, create a new file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">tests.py</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests.py</p>
			<pre class="source-code">
import pytest
from core.fixtures.user import user
from core.fixtures.post import post
from core.comment.models import Comment
@pytest.mark.django_db
def test_create_comment(user, post):
   comment = Comment.objects.create(author=user, post=post,
     body="Test Comment Body")
   assert comment.author == user
   assert comment.post == post
   assert comment.body == "Test Comment Body"</pre>
			<p>Run the tests with the <strong class="source-inline">pytest</strong> command, and everything should <span class="No-Break">be green.</span></p>
			<p>Great! We’ve just written tests for all the models in the project. Let’s move on to writing tests for <span class="No-Break">the viewsets.</span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor108"/>Writing tests for your Django viewsets</h1>
			<p>Viewsets or endpoints are the interfaces of the business logic that the external clients will use <a id="_idIndexMarker294"/>to fetch data and create, modify, or delete data. It’s always a great habit to have tests to make sure that the whole system, starting from a request to the database, is working <span class="No-Break">as intended.</span></p>
			<p>Before starting to write the tests, let’s configure the Pytest environment to use the API client <span class="No-Break">from DRF.</span></p>
			<p>The API client is a class that handles different HTTP methods, as well as features such as authentication in testing, which can be very helpful for directly authenticating without a username and password to test some endpoints. Pytest provides a way to add configurations in a <span class="No-Break">testing environment.</span></p>
			<p>Create a file named <strong class="source-inline">conftest.py</strong> at the root of the project. Inside the file, we’ll create a fixture function for our <span class="No-Break">custom client:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">conftest.py</p>
			<pre class="source-code">
import pytest
from rest_framework.test import APIClient
@pytest.fixture
def client():
   return APIClient()</pre>
			<p>Great! We can now directly call this client in the <span class="No-Break">next tests.</span></p>
			<p>Let’s start by testing the <span class="No-Break">authentication endpoints.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor109"/>Writing tests for authentication</h2>
			<p>Inside <a id="_idIndexMarker295"/>the <strong class="source-inline">core/auth</strong> directory, create <a id="_idIndexMarker296"/>a file named <strong class="source-inline">tests.py</strong>. Instead of writing test functions directly, we write a class that will contain the testing methods <span class="No-Break">as follows:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/tests.py</p>
			<pre class="source-code">
import pytest
from rest_framework import status
from core.fixtures.user import user
class TestAuthenticationViewSet:
   endpoint = '/api/auth/'</pre>
			<p>Let’s <a id="_idIndexMarker297"/>add the <strong class="source-inline">test_login</strong> method <a id="_idIndexMarker298"/>to the <span class="No-Break"><strong class="source-inline">TestAuthenticationViewSet</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Core/auth/tests.py</p>
			<pre class="source-code">
...
   def test_login(self, client, user):
       data = {
           "username": user.username,
           "password": "test_password"
       }
       response = client.post(self.endpoint + "login/",
                              data)
       assert response.status_code == status.HTTP_200_OK
       assert response.data['access']
       assert response.data['user']['id'] ==
         user.public_id.hex
       assert response.data['user']['username'] ==
         user.username
       assert response.data['user']['email'] == user.email
  ...</pre>
			<p>This <a id="_idIndexMarker299"/>method basically tests the login <a id="_idIndexMarker300"/>endpoint. We are using the client fixture initialized in the <strong class="source-inline">conftest.py</strong> file to make a <strong class="source-inline">post</strong> request. Then, we test for the value of <strong class="source-inline">status_code</strong> of the response and the <span class="No-Break">response returned.</span></p>
			<p>Run the <strong class="source-inline">pytest</strong> command, and everything should <span class="No-Break">be green.</span></p>
			<p>Let’s add tests for the <strong class="source-inline">register</strong> and <span class="No-Break"><strong class="source-inline">refresh</strong></span><span class="No-Break"> endpoints:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/tests.py</p>
			<pre class="source-code">
...
   @pytest.mark.django_db
   def test_register(self, client):
       data = {
           "username": "johndoe",
           "email": "johndoe@yopmail.com",
           "password": "test_password",
           "first_name": "John",
           "last_name": "Doe"
       }
       response = client.post(self.endpoint + "register/",
                              data)
       assert response.status_code ==
         status.HTTP_201_CREATED
   def test_refresh(self, client, user):
      data = {
           "username": user.username,
           "password": "test_password"
       }
       response = client.post(self.endpoint + "login/",
                                data)
       assert response.status_code == status.HTTP_200_OK
       data_refresh = {
           "refresh":  response.data['refresh']
       }
       response = client.post(self.endpoint + "refresh/",
                              data_refresh)
       assert response.status_code == status.HTTP_200_OK
       assert response.data['access']</pre>
			<p>In the <a id="_idIndexMarker301"/>preceding code, within the <strong class="source-inline">test_refresh</strong> method, we log in to get a refresh token to make a request to get a new <a id="_idIndexMarker302"/><span class="No-Break">access token.</span></p>
			<p>Run the <strong class="source-inline">pytest</strong> command again to run the tests, and everything should <span class="No-Break">be green.</span></p>
			<p>Let’s move on to writing tests <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">PostViewSet</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor110"/>Writing tests for PostViewSet</h2>
			<p>Before starting to write the viewsets tests, let’s quickly refactor the code to simply write the <a id="_idIndexMarker303"/>tests and follow the DRY rule. Inside <a id="_idIndexMarker304"/>the <strong class="source-inline">core/post</strong> directory, create a Python package called <strong class="source-inline">tests</strong>. Once it’s done, rename the <strong class="source-inline">tests.py</strong> file in the <strong class="source-inline">core/post</strong> directory to <strong class="source-inline">test_models.py</strong> and move it to the <span class="No-Break"><strong class="source-inline">core/post/tests/</strong></span><span class="No-Break"> directory.</span></p>
			<p>Inside the same directory, create a new file called <strong class="source-inline">test_viewsets.py</strong>. This file will contain tests <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">PostViewSet</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
from rest_framework import status
from core.fixtures.user import user
from core.fixtures.post import post
class TestPostViewSet:
   endpoint = '/api/post/'</pre>
			<p><strong class="source-inline">PostViewSet</strong> handles <a id="_idIndexMarker305"/>requests for two types <span class="No-Break">of users:</span></p>
			<ul>
				<li><span class="No-Break">Authenticated users</span></li>
				<li><span class="No-Break">Anonymous users</span></li>
			</ul>
			<p>Each type of user has different permissions on the <strong class="source-inline">post</strong> resource. So, let’s make sure that these cases <span class="No-Break">are handled:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
...
   def test_list(self, client, user, post):
       client.force_authenticate(user=user)
       response = client.get(self.endpoint)
       assert response.status_code == status.HTTP_200_OK
       assert response.data["count"] == 1
   def test_retrieve(self, client, user, post):
       client.force_authenticate(user=user)
       response = client.get(self.endpoint +
                             str(post.public_id) + "/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data['id'] == post.public_id.hex
       assert response.data['body'] == post.body
       assert response.data['author']['id'] ==
         post.author.public_id.hex</pre>
			<p>For these tests, we are forcing authentication. We want to make sure that authenticated users <a id="_idIndexMarker306"/>have access to the post’s resources. Let’s <a id="_idIndexMarker307"/>now write a test method for post creation, updating, <span class="No-Break">and deletion:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
...
   def test_create(self, client, user):
       client.force_authenticate(user=user)
       data = {
           "body": "Test Post Body",
           "author": user.public_id.hex
       }
       response = client.post(self.endpoint, data)
       assert response.status_code ==
         status.HTTP_201_CREATED
       assert response.data['body'] == data['body']
       assert response.data['author']['id'] ==
         user.public_id.hex
   def test_update(self, client, user, post):
       client.force_authenticate(user=user)
       data = {
           "body": "Test Post Body",
           "author": user.public_id.hex
       }
       response = client.put(self.endpoint +
         str(post.public_id) + "/", data)
       assert response.status_code == status.HTTP_200_OK
       assert response.data['body'] == data['body']
   def test_delete(self, client, user, post):
       client.force_authenticate(user=user)
       response = client.delete(self.endpoint +
         str(post.public_id) + "/")
       assert response.status_code ==
         status.HTTP_204_NO_CONTENT</pre>
			<p>Run the tests, and the outcomes should be green. Now, for the anonymous users, we want them to access the resource in reading mode, so they can’t create, modify, or delete <a id="_idIndexMarker308"/>a resource. Let’s test and validate <a id="_idIndexMarker309"/><span class="No-Break">these features:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
...
   def test_list_anonymous(self, client, post):
       response = client.get(self.endpoint)
       assert response.status_code == status.HTTP_200_OK
       assert response.data["count"] == 1
   def test_retrieve_anonymous(self, client, post):
       response = client.get(self.endpoint +
         str(post.public_id) + "/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data['id'] == post.public_id.hex
       assert response.data['body'] == post.body
       assert response.data['author']['id'] ==
         post.author.public_id.hex</pre>
			<p>Run the tests to make sure everything is green. After that, let’s test the <span class="No-Break">forbidden methods:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
...
def test_create_anonymous(self, client):
       data = {
           "body": "Test Post Body",
           "author": "test_user"
       }
       response = client.post(self.endpoint, data)
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED
   def test_update_anonymous(self, client, post):
       data = {
           "body": "Test Post Body",
           "author": "test_user"
       }
       response = client.put(self.endpoint +
         str(post.public_id) + "/", data)
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED
   def test_delete_anonymous(self, client, post):
       response = client.delete(self.endpoint +
         str(post.public_id) + "/")
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED</pre>
			<p>Run <a id="_idIndexMarker310"/>the tests again. Great! We’ve just <a id="_idIndexMarker311"/>written tests for the post viewset. You should now have a better understanding of testing <span class="No-Break">with viewsets.</span></p>
			<p>Let’s quickly write tests <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">CommentViewSet</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor111"/>Writing tests for CommentViewSet</h2>
			<p>Before starting to write the viewset tests, let’s also quickly refactor the code for writing the tests. Inside the <strong class="source-inline">core/comment</strong> directory, create a Python package called <strong class="source-inline">tests</strong>. Once <a id="_idIndexMarker312"/>it’s done, rename the <strong class="source-inline">tests.py</strong> file in the <strong class="source-inline">core/post</strong> directory to <strong class="source-inline">test_models.py</strong> and move it to the <span class="No-Break"><strong class="source-inline">core/comment/tests/</strong></span><span class="No-Break"> directory.</span></p>
			<p>Inside <a id="_idIndexMarker313"/>the same directory, create a new file called <strong class="source-inline">test_viewsets.py</strong>. This file will contain tests <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">CommentViewSet</strong></span><span class="No-Break">.</span></p>
			<p>Just like in <strong class="source-inline">PostViewSet</strong>, we have two types of users, and we want to write test cases for each of <span class="No-Break">their permissions.</span></p>
			<p>However, before creating comments, we need to add comment fixtures. Inside the <strong class="source-inline">core/fixtures</strong> directory, create a new file called <strong class="source-inline">comment.py</strong> and add the <span class="No-Break">following content:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/fixtures/comment.py</p>
			<pre class="source-code">
import pytest
from core.fixtures.user import user
from core.fixtures.post import post
from core.comment.models import Comment
@pytest.fixture
def comment(db, user, post):
   return Comment.objects.create(author=user, post=post,
                                 body="Test Comment Body")</pre>
			<p>After that, inside <strong class="source-inline">core/comment/tests/test_viewsets.py</strong>, add the following <span class="No-Break">content first:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
from rest_framework import status
from core.fixtures.user import user
from core.fixtures.post import post
from core.fixtures.comment import comment
class TestCommentViewSet:
   # The comment resource is nested under the post resource
   endpoint = '/api/post/'</pre>
			<p>Next, let’s <a id="_idIndexMarker314"/>add tests to the list <a id="_idIndexMarker315"/>and retrieve comments as <span class="No-Break">authenticated users:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
...
def test_list(self, client, user, post, comment):
       client.force_authenticate(user=user)
       response = client.get(self.endpoint +
         str(post.public_id) + "/comment/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data["count"] == 1
   def test_retrieve(self, client, user, post, comment):
       client.force_authenticate(user=user)
       response = client.get(self.endpoint +
                             str(post.public_id) +
                             "/comment/" +
                             str(comment.public_id) + "/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data['id'] == comment.public_id.hex
       assert response.data['body'] == comment.body
       assert response.data['author']['id'] ==
         comment.author.public_id.hex</pre>
			<p>Make <a id="_idIndexMarker316"/>sure that these tests pass <a id="_idIndexMarker317"/>by running the <strong class="source-inline">pytest</strong> command. The next step is to add tests for comment creation, updating, <span class="No-Break">and deletion:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
...
    def test_create(self, client, user, post):
       client.force_authenticate(user=user)
       data = {
           "body": "Test Comment Body",
           "author": user.public_id.hex,
           "post": post.public_id.hex
       }
       response = client.post(self.endpoint +
         str(post.public_id) + "/comment/", data)
       assert response.status_code ==
         status.HTTP_201_CREATED
       assert response.data['body'] == data['body']
       assert response.data['author']['id'] ==
         user.public_id.hex
   def test_update(self, client, user, post, comment):
       client.force_authenticate(user=user)
       data = {
           "body": "Test Comment Body Updated",
           "author": user.public_id.hex,
           "post": post.public_id.hex
       }
       response = client.put(self.endpoint +
                             str(post.public_id) +
                             "/comment/" +
                             str(comment.public_id) +
                             "/", data)
       assert response.status_code == status.HTTP_200_OK
       assert response.data['body'] == data['body']
   def test_delete(self, client, user, post, comment):
       client.force_authenticate(user=user)
       response = client.delete(self.endpoint +
         str(post.public_id) + "/comment/" +
         str(comment.public_id) + "/")
       assert response.status_code ==
         status.HTTP_204_NO_CONTENT</pre>
			<p>Run the <a id="_idIndexMarker318"/>tests again to make sure <a id="_idIndexMarker319"/>everything is green. Let’s write tests for the anonymous <span class="No-Break">users now.</span></p>
			<p>First of all, we need to make sure that they can access the resources with the <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
...
   def test_list_anonymous(self, client, post, comment):
       response = client.get(self.endpoint +
                             str(post.public_id) +
                             "/comment/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data["count"] == 1
   def test_retrieve_anonymous(self, client, post,
     comment):
       response = client.get(self.endpoint +
         str(post.public_id) + "/comment/" +
         str(comment.public_id) + "/")
       assert response.status_code == status.HTTP_200_OK</pre>
			<p>Next, we need <a id="_idIndexMarker320"/>to make sure that an <a id="_idIndexMarker321"/>anonymous user can’t create, update, or delete <span class="No-Break">a comment:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
   def test_create_anonymous(self, client, post):
       data = {}
       response = client.post(self.endpoint +
         str(post.public_id) + "/comment/", data)
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED
   def test_update_anonymous(self, client, post, comment):
       data = {}
       response = client.put(self.endpoint +
         str(post.public_id) + "/comment/" +
         str(comment.public_id) + "/", data)
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED
   def test_delete_anonymous(self, client, post, comment):
       response = client.delete(self.endpoint +
         str(post.public_id) + "/comment/" +
         str(comment.public_id) + "/")
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED</pre>
			<p>In the <a id="_idIndexMarker322"/>preceding cases, the data <strong class="source-inline">dict</strong> is empty because we are expecting <span class="No-Break">error statuses.</span></p>
			<p>Run the <a id="_idIndexMarker323"/>tests again to make sure that everything <span class="No-Break">is green!</span></p>
			<p>And voilà. We’ve just written tests for <strong class="source-inline">CommentViewSet</strong>. We also need to write tests for the <strong class="source-inline">UserViewSet</strong> class, but this will be a small project <span class="No-Break">for you.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor112"/>Writing tests for the UserViewSet class</h2>
			<p>In this <a id="_idIndexMarker324"/>section, let’s do a quick <a id="_idIndexMarker325"/>hands-on exercise. You’ll write the code for the <strong class="source-inline">UserViewSet</strong> class. It’s quite similar to the other tests we’ve written for <strong class="source-inline">PostViewSet</strong> and <strong class="source-inline">CommentViewSet</strong>. I have provided you with the structure of the class, and all you have to do is to write the testing logic in the methods. The following is the structure you need to <span class="No-Break">build on:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests/test_viewsets.py</p>
			<pre class="source-code">
from rest_framework import status
from core.fixtures.user import user
from core.fixtures.post import post
class TestUserViewSet:
   endpoint = '/api/user/'
   def test_list(self, client, user):
       pass
   def test_retrieve(self, client, user):
       pass
   def test_create(self, client, user):
       pass
   def test_update(self, client, user):
       pass</pre>
			<p>Here <a id="_idIndexMarker326"/>are the requirements <a id="_idIndexMarker327"/>concerning <span class="No-Break">the tests:</span></p>
			<ul>
				<li><strong class="source-inline">test_list</strong>: An authenticated user should enable a list of <span class="No-Break">all users</span></li>
				<li><strong class="source-inline">test_retrieve</strong>: An authenticated user can retrieve resources concerning <span class="No-Break">a user</span></li>
				<li><strong class="source-inline">test_create</strong>: Users cannot create users directly with a <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> request</span></li>
				<li><strong class="source-inline">test_update</strong>: An authenticated user can update a <strong class="source-inline">user</strong> object with a <span class="No-Break"><strong class="source-inline">PATCH</strong></span><span class="No-Break"> request</span></li>
			</ul>
			<p>You can find the solution to this exercise <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py"><span class="No-Break">https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor113"/>Summary</h1>
			<p>In this chapter, we learned about testing, the different types of testing, and their advantages. We also introduced testing in Django using Pytest and wrote tests for the models and viewsets. These skills acquired in writing tests using the TDD method help you better design your code, prevent bugs tied to code architecture, and improve the quality of the software. Not to forget, they also give you a competitive advantage in the <span class="No-Break">job market.</span></p>
			<p>This is the last chapter of <em class="italic">Part 1</em>, <em class="italic">Technical Background</em>. The next part will be dedicated to React and connecting the frontend to the REST API we’ve just built. In the next chapter, we’ll learn more about frontend development and React, and we’ll also create a React project and <span class="No-Break">run it.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor114"/>Questions</h1>
			<ol>
				<li>What <span class="No-Break">is testing?</span></li>
				<li>What is a <span class="No-Break">unit test?</span></li>
				<li>What is the <span class="No-Break">testing pyramid?</span></li>
				<li>What <span class="No-Break">is Pytest?</span></li>
				<li>What is a <span class="No-Break">Pytest fixture?</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer049" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer050" class="Content">
			<h1 id="_idParaDest-112"><a id="_idTextAnchor115"/>Part 2: Building a Reactive UI with React</h1>
			<p>In <em class="italic">Part 1</em> of our book, we built the backend of the Postagram application using Django, with authentication features and post and comment management. In this part of the book, you will build a React application representing the UI interface of Postagram, where users will see posts and comments and be able to like posts or comments, upload profile pictures, and visit other users’ profiles. At the end of this part, you will have the required knowledge to use React to handle authentication from the frontend side, build UI components from scratch, work with React Hooks such as <strong class="source-inline">useState</strong>, <strong class="source-inline">useContext</strong>, and <strong class="source-inline">useMemo</strong>, and send requests to a REST API and handle the responses.  </p>
			<p>This section comprises the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18221_06.xhtml#_idTextAnchor116"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating a Project with React</em></li>
				<li><a href="B18221_07.xhtml#_idTextAnchor144"><em class="italic">Chapter 7</em></a>, <em class="italic">Building Login and Registration Forms</em></li>
				<li><a href="B18221_08.xhtml#_idTextAnchor164"><em class="italic">Chapter 8</em></a>, <em class="italic">Social Media Posts</em></li>
				<li><a href="B18221_09.xhtml#_idTextAnchor182"><em class="italic">Chapter 9</em></a>, <em class="italic">Post Comments</em></li>
				<li><a href="B18221_10.xhtml#_idTextAnchor205"><em class="italic">Chapter 10</em></a>, <em class="italic">User Profiles</em></li>
				<li><a href="B18221_11.xhtml#_idTextAnchor218"><em class="italic">Chapter 11</em></a>, <em class="italic">Effective UI Testing for React Components</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer051">
			</div>
		</div>
		<div>
			<div id="_idContainer052">
			</div>
		</div>
	</body></html>