<html><head></head><body>
		<div><h1 id="_idParaDest-88" class="chapter-number"><a id="_idTextAnchor091"/>5</h1>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor092"/>Testing the REST API</h1>
			<p>In software engineering, testing is a process to check whether the actual software product performs as expected and is bug free.</p>
			<p>There are a lot of ways to test software through both manual and automated tests. But in this project, we’ll <a id="_idIndexMarker239"/>focus more on <strong class="bold">automated testing</strong>. However, we’ll first dive into the different ways of testing software, including their pros and their cons, and also talk about <a id="_idIndexMarker240"/>the concept of the <strong class="bold">testing pyramid</strong>. We’ll also check the tools needed to add tests to a Django application and add tests to the models and the viewsets. This chapter will help you understand testing for developers and also how to write tests for a Django API.</p>
			<p>In this chapter, we’ll be covering the following topics:</p>
			<ul>
				<li>What is testing?</li>
				<li>Testing in Django</li>
				<li>Configuring the testing environment</li>
				<li>Writing tests for Django models</li>
				<li>Writing tests for Django viewsets</li>
			</ul>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor093"/>Technical requirements</h1>
			<p>You can find the code of the current chapter at this link: <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap5</a>.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor094"/>What is testing?</h1>
			<p>To make <a id="_idIndexMarker241"/>it simple, testing is finding out how well something works.</p>
			<p>However, the process comprises a group of techniques to determine the correctness of the application under a script or manual test directly on the user interface. The aim is to detect failures, including bugs and performance issues, in the application, so that they can be corrected.</p>
			<p>Most of the time, testing is <a id="_idIndexMarker242"/>done by comparing the software requirements to the actual software product. If one of the requirements is to make sure that input only accepts numbers and not characters or files, a test will be conducted to check whether the input has a validation system to reject non-number values in the input.</p>
			<p>However, testing also involves an examination of code and the execution of code in various environments and conditions.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor095"/>What is software testing?</h2>
			<p>Software testing is the process of examining the behavior of the software under test for validation or verification. It considers the attributes of reliability, scalability, reusability, and usability <a id="_idIndexMarker243"/>to evaluate the execution of the software components (servers, database, application, and so on) and find software bugs, errors, or defects.</p>
			<p>Software testing <a id="_idIndexMarker244"/>has a lot of benefits, some of which are as follows:</p>
			<ul>
				<li><strong class="bold">Cost effectiveness</strong>: Testing any software project helps the business save money in the long run. As the process helps detect bugs and check whether newly added features are working in the system without breaking things, it’s a great technical debt reducer.</li>
				<li><strong class="bold">Security</strong>: If testing is done well, it can be a quick way to detect security risks and problems at an early stage before deploying a product to the whole world.</li>
				<li><strong class="bold">Product quality</strong>: Testing helps with performance measurement, making sure that the requirements are respected.</li>
			</ul>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor096"/>Why is software testing important?</h2>
			<p>Testing your <a id="_idIndexMarker245"/>software is important because it helps reduce the impact of bugs through bug identification and resolution. Some bugs can be quite dangerous and can lead to financial losses or endanger human life. Here are some historical examples:</p>
			<p>Source: <a href="https://lexingtontechnologies.ng/software-testing/">https://lexingtontechnologies.ng/software-testing/</a>.</p>
			<ul>
				<li>In April 1999, $1.2 billion were lost due to the failure of a military satellite launch. To date, this is the costliest accident in the history of the world.</li>
				<li>In 2014, the giant Nissan recalled over 1 million cars from the market because of a software failure in the airbag sensory detectors.</li>
				<li>In 2014,  some of Amazon's third-party retailers lost a lot of money because of a software glitch. The bug affected the price of the products, reducing them to 1p.</li>
				<li>In 2015, a software failure in the <strong class="bold">Point of sales</strong> (<strong class="bold">POS</strong>) system of Starbucks stores caused the temporary closure of more than 60% of their stores in the US and Canada. </li>
				<li>In 2015, an F-35 fighter plane fell victim to a software bug, which prevented it from detecting or identifying targets correctly. The sensor on the plane was unable to identify threats even from their own planes.</li>
				<li>In 2016, Google reported a bug affecting Windows 10 machines. The vulnerability allowed users to escape security sandboxes through a flow in the win32k system.</li>
			</ul>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>What are the various types of testing?</h2>
			<p>Testing is <a id="_idIndexMarker246"/>typically classified into three categories:</p>
			<ul>
				<li><strong class="bold">Functional testing</strong>: This <a id="_idIndexMarker247"/>type of testing comprises unit, integration, user acceptance, globalization, internationalization testing, and so on</li>
				<li><strong class="bold">Non-functional testing</strong>: This <a id="_idIndexMarker248"/>type of testing checks for factors such as performance, volume, scalability, usability, and load</li>
				<li><strong class="bold">Maintenance testing</strong>: This <a id="_idIndexMarker249"/>type of testing considers regression and maintenance</li>
			</ul>
			<p>However, these tests <a id="_idIndexMarker250"/>can also be classified into two different types:</p>
			<ul>
				<li>Automated tests</li>
				<li>Manual tests</li>
			</ul>
			<p>First, let’s see what manual testing is.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor098"/>Understanding manual testing</h2>
			<p><strong class="bold">Manual testing</strong> is the <a id="_idIndexMarker251"/>process of testing software manually to find defects or bugs. It’s the process of testing the functionalities of an application without the help of automation tools.</p>
			<p>An example of manual testing is when test users are called to test an application or a special feature. They can be asked to test a specific form, push the application to its limits when it comes to performance, and much more.</p>
			<p>Manual testing <a id="_idIndexMarker252"/>has a lot of advantages:</p>
			<ul>
				<li>It’s very useful to test user interface designs and interactions</li>
				<li>It’s easier to learn for new testers</li>
				<li>It takes user experience and usability into consideration</li>
				<li>It’s cost-effective</li>
			</ul>
			<p>However, manual <a id="_idIndexMarker253"/>testing also has some cons:</p>
			<ul>
				<li>It requires human resources.</li>
				<li>It’s time-consuming.</li>
				<li>Testers consider test cases based on their skills and experience. This means that a beginner tester may not cover all the functions.</li>
			</ul>
			<p>Even if manual testing sounds very appealing, it can be quite a time- and resource-consuming exercise, and developers definitely do not make really good manual testers. Let’s see how <a id="_idIndexMarker254"/>automated testing can erase the cons of manual testing and place better development at the center of testing.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor099"/>Understanding automated testing</h2>
			<p><strong class="bold">Automated testing</strong> is simply <a id="_idIndexMarker255"/>the process of testing software using automation tools to find defects. These automation tools can be scripts written in the language <a id="_idIndexMarker256"/>used to <a id="_idIndexMarker257"/>build the application or some software <a id="_idIndexMarker258"/>or drivers (such as <strong class="bold">Selenium</strong>, <strong class="bold">WinRunner</strong>, and <strong class="bold">LoadRunner</strong>) to make automated testing easier and faster.</p>
			<p>Automated testing <a id="_idIndexMarker259"/>fixes the cons of manual testing, and it also has more advantages, as shown in the following list:</p>
			<ul>
				<li>Faster in execution</li>
				<li>Cheaper than manual testing in the long run</li>
				<li>More reliable, powerful, and versatile</li>
				<li>Very useful in regression testing</li>
				<li>Able to provide better test coverage</li>
				<li>Possible to run without human intervention</li>
				<li>Much cheaper</li>
			</ul>
			<p>However, automated <a id="_idIndexMarker260"/>testing is also inconvenient in some ways:</p>
			<ul>
				<li>It is expensive at the beginning</li>
				<li>It has a huge cost of maintenance when requirements change</li>
				<li>Automated testing tools are expensive</li>
			</ul>
			<p>The real value of automated testing and manual testing comes when each is used in the right environment.</p>
			<p>For example, manual testing is much more useful on frontend projects where you want to test the usability and user experience. Automated testing can be useful to test methods or <a id="_idIndexMarker261"/>functions in the code and is very useful for finding bugs or security issues.</p>
			<p>In this chapter, we’ll focus on writing automated tests in Python. As we are developing an API, we want to make sure that the system is reliable and behaves as we want it to, but it should also be secure against the possible issues of the next added feature.</p>
			<p>This said, let’s talk <a id="_idIndexMarker262"/>about testing in Django and introduce the notion of <strong class="bold">test-driven </strong><strong class="bold">development</strong> (<strong class="bold">TDD</strong>).</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor100"/>Testing in Django</h1>
			<p>Testing in Python, particularly in Django, is very simple and easy. The framework actually provides <a id="_idIndexMarker263"/>many tools and utilities you can use to write tests for the models, serializers, or views in the application.</p>
			<p>However, the Python ecosystem for testing relies a lot on one tool to write tests, and this tool has <a id="_idIndexMarker264"/>deep integration with Django. The tool is named <strong class="bold">Pytest</strong> (<a href="https://docs.pytest.org">https://docs.pytest.org</a>) and is a framework for writing small and readable tests. Used with Django, Pytest is mainly used for API testing by writing code to test API endpoints, databases, and user interfaces.</p>
			<p>But why use Pytest? Well, it has the following advantages:</p>
			<ul>
				<li>It is free and open source</li>
				<li>It has a simple syntax and is very easy to start with</li>
				<li>It automatically detects test files, functions, and classes</li>
				<li>It can run multiple tests in parallel, increasing the performance and the speed of running tests</li>
			</ul>
			<p>We’ll use <a id="_idIndexMarker265"/>Pytest in <a id="_idIndexMarker266"/>this project to write two kinds of tests: <strong class="bold">integration tests</strong> and <strong class="bold">unit tests</strong>.</p>
			<p>Before starting to code, let’s learn about integration testing and unit testing by considering the concepts of TDD and the testing pyramid.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor101"/>The testing pyramid</h2>
			<p>The testing pyramid <a id="_idIndexMarker267"/>is a framework that can help developers start with testing to create high-quality software. Basically, the testing pyramid specifies the types of tests that should be included in an automated test suite.</p>
			<p>First of all, remember <a id="_idIndexMarker268"/>that the testing pyramid operates at three levels:</p>
			<ul>
				<li>Unit tests</li>
				<li>Integration tests</li>
				<li>End-to-end tests</li>
			</ul>
			<p>The following figure shows the positions of each of these levels in the pyramid and how they are prioritized in terms of the speed performance and level of integration or isolation:</p>
			<div><div><img src="img/Figure_5.1_B18221.jpg" alt="Figure 5.1 – The testing pyramid"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The testing pyramid</p>
			<p>In the preceding figure, the base level is occupied by unit testing. Unit tests target individual <a id="_idIndexMarker269"/>components or functionality to check whether they work as expected in isolated conditions. In our backend project, an example would be to test whether the <code>like_post</code> method on the <code>User</code> class model actually performs as intended. We are not testing the whole <code>User</code> model; we are testing one method of the <code>User</code> model class.</p>
			<p>It’s definitely a good habit to write a lot of unit tests. They should comprise at least 60% of all the tests in your code base because they are fast, short, and test a lot of components.</p>
			<p>On the second level, you have integration tests. If unit tests verify small pieces of a code base, integration tests test how this code interacts with other code or other parts of the software. A useful, albeit controversial, example of integration testing is writing a test for a viewset. When testing a viewset, you are also testing the permissions, the authentication classes, the serializers, the models, and the database if possible. It’s a test of how the different parts of the Django API work together.</p>
			<p>An integration test can also be a test between your application and an external service, a payment API, for example.</p>
			<p>On the third <a id="_idIndexMarker270"/>level at the top of the pyramid, you have end-to-end tests. These kinds of tests ensure that the software is working as required. They test how the application works from beginning to end.</p>
			<p>In this book, we’ll focus on unit and integration testing. Note that integration tests are the subject of some misunderstandings that will be cleared up once we define them. According to my personal experience, unit tests in Django are written more on the model and serializer side of each application. They can be used for testing the creation of an object in the database as well as for retrieving, updating, or deletion.</p>
			<p>Regarding viewset tests, I believe that they can act as integration tests because running them calls on permissions, authentication, serializers, validation, and also models, depending on the action you are performing.</p>
			<p>Returning to unit tests, they are more effective when using TDD, which comprises software development practices that focus on writing unit test cases before developing the feature. Even if it <a id="_idIndexMarker271"/>sounds counter-intuitive, TDD has a lot of advantages:</p>
			<ul>
				<li>It ensures optimized code</li>
				<li>It ensures the application of design patterns and better architecture</li>
				<li>It helps the developer understand the business requirements</li>
				<li>It makes the code flexible and easier to maintain</li>
			</ul>
			<p>However, we didn’t particularly respect the TDD rule in the book. We relied on the Django shell and a client to test the feature of the REST API we are building. For the next features that will be added to the project, tests will be written before coding the feature.</p>
			<p>With concepts such as TDD, unit and integration testing, and testing pyramid understood, we can now configure the testing environment.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor102"/>Configuring the testing environment</h1>
			<p>Pytest, taken alone, is simply a Python framework to write unit tests in Python programs. Thankfully, there is a plugin for Pytest to write tests in Django projects and applications.</p>
			<p>Let’s install <a id="_idIndexMarker272"/>and configure the environment for testing by using the following command:</p>
			<pre class="console">
pip install pytest-django</pre>
			<p>Once the package is installed, create a new file called <code>pytest.ini</code> at the root of the Django project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">pytest.ini</p>
			<pre class="source-code">
[pytest]
DJANGO_SETTINGS_MODULE=CoreRoot.settings
python_files=tests.py test_*.py *_tests.py</pre>
			<p>Once it’s done, run the <code>pytest</code> command:</p>
			<pre class="console">
pytest</pre>
			<p>You’ll see the following output:</p>
			<pre class="console">
======================== test session starts ============================
platform linux -- Python 3.10.2, pytest-7.0.1, pluggy-1.0.0
django: settings: CoreRoot.settings (from ini)
rootdir: /home/koladev/PycharmProjects/Full-stack-Django-and-React, configfile: pytest.ini
plugins: django-4.5.2
collected 0 items</pre>
			<p>Great! Pytest is installed in the project, and we can write the first test in the project to test the configuration.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor103"/>Writing your first test</h2>
			<p>The Pytest <a id="_idIndexMarker273"/>environment is configured, so let’s see how we can write a simple test using Pytest.</p>
			<p>At the root of the project, create a file called <code>tests.py</code>. We’ll simply write a test to test the sum of a function.</p>
			<p>Following the TDD concept, we’ll write the test first and make it fail:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">tests.py</p>
			<pre class="source-code">
def test_sum():
   assert add(1, 2) == 3</pre>
			<p>This function is written to check for a condition, justifying the usage of the <code>assert</code> Python keyword. If the condition after the <code>assert</code> is true, the script will continue or stop the execution. If that’s not the case, an assertion error will be raised.</p>
			<p>If you run the <code>pytest</code> command, you’ll receive the following output:</p>
			<div><div><img src="img/Figure_5.2_B18221.jpg" alt="Figure 5.2 – Failing tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Failing tests</p>
			<p>From the preceding output, we are sure that the test has failed. Let’s now write the feature to pass the test.</p>
			<p>In the same file, <code>tests.py</code>, add the following function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">tests.py</p>
			<pre class="source-code">
def add(a, b):
   return a + b
def test_sum():
   assert sum(1, 2) == 3</pre>
			<p>Now, run the <code>pytest</code> command <a id="_idIndexMarker274"/>again in the terminal. Everything should now be green:</p>
			<div><div><img src="img/Figure_5.3_B18221.jpg" alt="Figure 5.3 – ﻿Test passes successfully"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Test passes successfully</p>
			<p>Great! You have written the first test in the project using Pytest. In the next section, we’ll be writing tests for the models of the project.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor104"/>Writing tests for Django models</h1>
			<p>When applying testing to a Django project, it’s always a good idea to start with writing tests for <a id="_idIndexMarker275"/>the models. But why test the models?</p>
			<p>Well, it gives you better confidence in your code and the connections to the database. It’ll make sure that methods or attributes on the model are well represented in the database, but it can also help you with better code structure, resolving bugs, and building documentation.</p>
			<p>Without further ado, let’s start by writing tests for the <code>User</code> model.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor105"/>Writing tests for the User model</h2>
			<p>Inside <a id="_idIndexMarker276"/>the <code>core/user</code> directory, create a new <a id="_idIndexMarker277"/>file called <code>tests.py</code>. We’ll write tests to create a user and a simple user:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests.py</p>
			<pre class="source-code">
import pytest
from core.user.models import User
data_user = {
   "username": "test_user",
   "email": "test@gmail.com",
   "first_name": "Test",
   "last_name": "User",
   "password": "test_password"
}</pre>
			<p>Once the <a id="_idIndexMarker278"/>imports and the data to <a id="_idIndexMarker279"/>create the user have been added, we can write the test function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests.py</p>
			<pre class="source-code">
@pytest.mark.django_db
def test_create_user():
   user = User.objects.create_user(**data_user)
   assert user.username == data_user["username"]
   assert user.email == data_user["email"]
   assert user.first_name == data_user["first_name"]
   assert user.last_name == data_user["last_name"]</pre>
			<p>Above the <code>test_create_user</code> function, you’ll probably notice some syntax. It’s called a decorator, and it’s basically a function that takes another function as its argument and returns another function.</p>
			<p><code>@pytest.mark.django_db</code> gives us access to the Django database. Try to remove this decorator and run the tests.</p>
			<p>You’ll get an error output with a similar message at the end:</p>
			<pre class="console">
=================================================================== short test summary info ===================================================================
FAILED core/user/tests.py::test_create_user - RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixture...</pre>
			<p>Well, re-add the decorator and run the <code>pytest</code> command and all tests should pass normally.</p>
			<p>Let’s do <a id="_idIndexMarker280"/>another test to make sure that the <a id="_idIndexMarker281"/>creation of <code>superuser</code> works perfectly.</p>
			<p>Add a new dictionary containing the data needed to create <code>superuser</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests.py</p>
			<pre class="source-code">
data_superuser = {
   "username": "test_superuser",
   "email": "testsuperuser@gmail.com",
   "first_name": "Test",
   "last_name": "Superuser",
   "password": "test_password"
}</pre>
			<p>And here’s the function that tests the creation of <code>superuser</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests.py</p>
			<pre class="source-code">
@pytest.mark.django_db
def test_create_superuser():
   user = User.objects.create_superuser(**data_superuser)
   assert user.username == data_superuser["username"]
   assert user.email == data_superuser["email"]
   assert user.first_name == data_superuser["first_name"]
   assert user.last_name == data_superuser["last_name"]
   assert user.is_superuser == True
   assert user.is_staff == True</pre>
			<p>Run the <a id="_idIndexMarker282"/>tests again, and everything should <a id="_idIndexMarker283"/>be green.</p>
			<p>Great! Now that we have a better understanding of how <code>pytest</code> works for tests, let’s write tests for the <code>Post</code> model.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor106"/>Writing tests for the Post model</h2>
			<p>To create a model, we need to have a user object ready. This will also be the same for the <code>Comment</code> model. To avoid repetition, we’ll simply write <strong class="bold">fixtures</strong>.</p>
			<p>A fixture <a id="_idIndexMarker284"/>is a function that will run before each <a id="_idIndexMarker285"/>test function to which it’s applied. In this case, the fixture will be used to feed some data to the tests.</p>
			<p>To add fixtures in the project, create a new Python package called <code>fixtures</code> in the <code>core</code> directory.</p>
			<p>In the <code>core/fixtures</code> directory, create a file called <code>user.py</code>. This file will contain a user fixture:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/fixtures/user.py</p>
			<pre class="source-code">
import pytest
from core.user.models import User
data_user = {
   "username": "test_user",
   "email": "test@gmail.com",
   "first_name": "Test",
   "last_name": "User",
   "password": "test_password"
}
@pytest.fixture
def user(db) -&gt; User:
   return User.objects.create_user(**data_user)</pre>
			<p>In the <a id="_idIndexMarker286"/>preceding code, the <code>@pytest.fixture</code> decorator <a id="_idIndexMarker287"/>labels the function as a fixture. We can now import the <code>user</code> function in any test and pass it as an argument to the <code>test</code> function.</p>
			<p>Inside the <code>core/post</code> directory, create a new file called <code>tests.py</code>. This file will then test for the creation of a post.</p>
			<p>Here’s the code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests.py</p>
			<pre class="source-code">
import pytest
from core.fixtures.user import user
from core.post.models import Post
@pytest.mark.django_db
def test_create_post(user):
   post = Post.objects.create(author=user,
                              body="Test Post Body")
   assert post.body == "Test Post Body"
   assert post.author == user</pre>
			<p>As you <a id="_idIndexMarker288"/>can see, we are importing the <code>user</code> function from <code>user.py</code> in the <a id="_idIndexMarker289"/>fixtures directory and passing it as an argument to the <code>test_create_post</code> test function.</p>
			<p>Run the <code>pytest</code> command, and everything should be green.</p>
			<p>Now that we have a working test for the <code>Post</code> model, let’s write tests for the <code>Comment</code> model.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor107"/>Writing tests for the Comment model</h2>
			<p>Writing tests for the <code>Comment</code> model requires the same steps as the tests for the <code>Post</code> model. First <a id="_idIndexMarker290"/>of all, create a new file called <code>post.py</code> in the <code>core/fixtures</code> directory.</p>
			<p>This file <a id="_idIndexMarker291"/>will contain the fixture of a post, as it’s needed to create a comment.</p>
			<p>But the <code>post</code> fixture will also need a <code>user</code> fixture. Thankfully, it’s possible with Pytest to inject fixtures into other fixtures.</p>
			<p>Here’s the code for the <code>post</code> fixture:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/fixtures/post.py</p>
			<pre class="source-code">
import pytest
from core.fixtures.user import user
from core.post.models import Post
@pytest.fixture
def post(db, user):
   return Post.objects.create(author=user,
                              body="Test Post Body")</pre>
			<p>Great! With <a id="_idIndexMarker292"/>the fixtures added, we can now <a id="_idIndexMarker293"/>write the test for comment creation.</p>
			<p>Inside the <code>core/comment/</code> directory, create a new file called <code>tests.py</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests.py</p>
			<pre class="source-code">
import pytest
from core.fixtures.user import user
from core.fixtures.post import post
from core.comment.models import Comment
@pytest.mark.django_db
def test_create_comment(user, post):
   comment = Comment.objects.create(author=user, post=post,
     body="Test Comment Body")
   assert comment.author == user
   assert comment.post == post
   assert comment.body == "Test Comment Body"</pre>
			<p>Run the tests with the <code>pytest</code> command, and everything should be green.</p>
			<p>Great! We’ve just written tests for all the models in the project. Let’s move on to writing tests for the viewsets.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor108"/>Writing tests for your Django viewsets</h1>
			<p>Viewsets or endpoints are the interfaces of the business logic that the external clients will use <a id="_idIndexMarker294"/>to fetch data and create, modify, or delete data. It’s always a great habit to have tests to make sure that the whole system, starting from a request to the database, is working as intended.</p>
			<p>Before starting to write the tests, let’s configure the Pytest environment to use the API client from DRF.</p>
			<p>The API client is a class that handles different HTTP methods, as well as features such as authentication in testing, which can be very helpful for directly authenticating without a username and password to test some endpoints. Pytest provides a way to add configurations in a testing environment.</p>
			<p>Create a file named <code>conftest.py</code> at the root of the project. Inside the file, we’ll create a fixture function for our custom client:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">conftest.py</p>
			<pre class="source-code">
import pytest
from rest_framework.test import APIClient
@pytest.fixture
def client():
   return APIClient()</pre>
			<p>Great! We can now directly call this client in the next tests.</p>
			<p>Let’s start by testing the authentication endpoints.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor109"/>Writing tests for authentication</h2>
			<p>Inside <a id="_idIndexMarker295"/>the <code>core/auth</code> directory, create <a id="_idIndexMarker296"/>a file named <code>tests.py</code>. Instead of writing test functions directly, we write a class that will contain the testing methods as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/tests.py</p>
			<pre class="source-code">
import pytest
from rest_framework import status
from core.fixtures.user import user
class TestAuthenticationViewSet:
   endpoint = '/api/auth/'</pre>
			<p>Let’s <a id="_idIndexMarker297"/>add the <code>test_login</code> method <a id="_idIndexMarker298"/>to the <code>TestAuthenticationViewSet</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Core/auth/tests.py</p>
			<pre class="source-code">
...
   def test_login(self, client, user):
       data = {
           "username": user.username,
           "password": "test_password"
       }
       response = client.post(self.endpoint + "login/",
                              data)
       assert response.status_code == status.HTTP_200_OK
       assert response.data['access']
       assert response.data['user']['id'] ==
         user.public_id.hex
       assert response.data['user']['username'] ==
         user.username
       assert response.data['user']['email'] == user.email
  ...</pre>
			<p>This <a id="_idIndexMarker299"/>method basically tests the login <a id="_idIndexMarker300"/>endpoint. We are using the client fixture initialized in the <code>conftest.py</code> file to make a <code>post</code> request. Then, we test for the value of <code>status_code</code> of the response and the response returned.</p>
			<p>Run the <code>pytest</code> command, and everything should be green.</p>
			<p>Let’s add tests for the <code>register</code> and <code>refresh</code> endpoints:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/tests.py</p>
			<pre class="source-code">
...
   @pytest.mark.django_db
   def test_register(self, client):
       data = {
           "username": "johndoe",
           "email": "johndoe@yopmail.com",
           "password": "test_password",
           "first_name": "John",
           "last_name": "Doe"
       }
       response = client.post(self.endpoint + "register/",
                              data)
       assert response.status_code ==
         status.HTTP_201_CREATED
   def test_refresh(self, client, user):
      data = {
           "username": user.username,
           "password": "test_password"
       }
       response = client.post(self.endpoint + "login/",
                                data)
       assert response.status_code == status.HTTP_200_OK
       data_refresh = {
           "refresh":  response.data['refresh']
       }
       response = client.post(self.endpoint + "refresh/",
                              data_refresh)
       assert response.status_code == status.HTTP_200_OK
       assert response.data['access']</pre>
			<p>In the <a id="_idIndexMarker301"/>preceding code, within the <code>test_refresh</code> method, we log in to get a refresh token to make a request to get a new <a id="_idIndexMarker302"/>access token.</p>
			<p>Run the <code>pytest</code> command again to run the tests, and everything should be green.</p>
			<p>Let’s move on to writing tests for <code>PostViewSet</code>.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor110"/>Writing tests for PostViewSet</h2>
			<p>Before starting to write the viewsets tests, let’s quickly refactor the code to simply write the <a id="_idIndexMarker303"/>tests and follow the DRY rule. Inside <a id="_idIndexMarker304"/>the <code>core/post</code> directory, create a Python package called <code>tests</code>. Once it’s done, rename the <code>tests.py</code> file in the <code>core/post</code> directory to <code>test_models.py</code> and move it to the <code>core/post/tests/</code> directory.</p>
			<p>Inside the same directory, create a new file called <code>test_viewsets.py</code>. This file will contain tests for <code>PostViewSet</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
from rest_framework import status
from core.fixtures.user import user
from core.fixtures.post import post
class TestPostViewSet:
   endpoint = '/api/post/'</pre>
			<p><code>PostViewSet</code> handles <a id="_idIndexMarker305"/>requests for two types of users:</p>
			<ul>
				<li>Authenticated users</li>
				<li>Anonymous users</li>
			</ul>
			<p>Each type of user has different permissions on the <code>post</code> resource. So, let’s make sure that these cases are handled:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
...
   def test_list(self, client, user, post):
       client.force_authenticate(user=user)
       response = client.get(self.endpoint)
       assert response.status_code == status.HTTP_200_OK
       assert response.data["count"] == 1
   def test_retrieve(self, client, user, post):
       client.force_authenticate(user=user)
       response = client.get(self.endpoint +
                             str(post.public_id) + "/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data['id'] == post.public_id.hex
       assert response.data['body'] == post.body
       assert response.data['author']['id'] ==
         post.author.public_id.hex</pre>
			<p>For these tests, we are forcing authentication. We want to make sure that authenticated users <a id="_idIndexMarker306"/>have access to the post’s resources. Let’s <a id="_idIndexMarker307"/>now write a test method for post creation, updating, and deletion:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
...
   def test_create(self, client, user):
       client.force_authenticate(user=user)
       data = {
           "body": "Test Post Body",
           "author": user.public_id.hex
       }
       response = client.post(self.endpoint, data)
       assert response.status_code ==
         status.HTTP_201_CREATED
       assert response.data['body'] == data['body']
       assert response.data['author']['id'] ==
         user.public_id.hex
   def test_update(self, client, user, post):
       client.force_authenticate(user=user)
       data = {
           "body": "Test Post Body",
           "author": user.public_id.hex
       }
       response = client.put(self.endpoint +
         str(post.public_id) + "/", data)
       assert response.status_code == status.HTTP_200_OK
       assert response.data['body'] == data['body']
   def test_delete(self, client, user, post):
       client.force_authenticate(user=user)
       response = client.delete(self.endpoint +
         str(post.public_id) + "/")
       assert response.status_code ==
         status.HTTP_204_NO_CONTENT</pre>
			<p>Run the tests, and the outcomes should be green. Now, for the anonymous users, we want them to access the resource in reading mode, so they can’t create, modify, or delete <a id="_idIndexMarker308"/>a resource. Let’s test and validate <a id="_idIndexMarker309"/>these features:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
...
   def test_list_anonymous(self, client, post):
       response = client.get(self.endpoint)
       assert response.status_code == status.HTTP_200_OK
       assert response.data["count"] == 1
   def test_retrieve_anonymous(self, client, post):
       response = client.get(self.endpoint +
         str(post.public_id) + "/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data['id'] == post.public_id.hex
       assert response.data['body'] == post.body
       assert response.data['author']['id'] ==
         post.author.public_id.hex</pre>
			<p>Run the tests to make sure everything is green. After that, let’s test the forbidden methods:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/tests/test_viewsets.py</p>
			<pre class="source-code">
...
def test_create_anonymous(self, client):
       data = {
           "body": "Test Post Body",
           "author": "test_user"
       }
       response = client.post(self.endpoint, data)
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED
   def test_update_anonymous(self, client, post):
       data = {
           "body": "Test Post Body",
           "author": "test_user"
       }
       response = client.put(self.endpoint +
         str(post.public_id) + "/", data)
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED
   def test_delete_anonymous(self, client, post):
       response = client.delete(self.endpoint +
         str(post.public_id) + "/")
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED</pre>
			<p>Run <a id="_idIndexMarker310"/>the tests again. Great! We’ve just <a id="_idIndexMarker311"/>written tests for the post viewset. You should now have a better understanding of testing with viewsets.</p>
			<p>Let’s quickly write tests for <code>CommentViewSet</code>.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor111"/>Writing tests for CommentViewSet</h2>
			<p>Before starting to write the viewset tests, let’s also quickly refactor the code for writing the tests. Inside the <code>core/comment</code> directory, create a Python package called <code>tests</code>. Once <a id="_idIndexMarker312"/>it’s done, rename the <code>tests.py</code> file in the <code>core/post</code> directory to <code>test_models.py</code> and move it to the <code>core/comment/tests/</code> directory.</p>
			<p>Inside <a id="_idIndexMarker313"/>the same directory, create a new file called <code>test_viewsets.py</code>. This file will contain tests for <code>CommentViewSet</code>.</p>
			<p>Just like in <code>PostViewSet</code>, we have two types of users, and we want to write test cases for each of their permissions.</p>
			<p>However, before creating comments, we need to add comment fixtures. Inside the <code>core/fixtures</code> directory, create a new file called <code>comment.py</code> and add the following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/fixtures/comment.py</p>
			<pre class="source-code">
import pytest
from core.fixtures.user import user
from core.fixtures.post import post
from core.comment.models import Comment
@pytest.fixture
def comment(db, user, post):
   return Comment.objects.create(author=user, post=post,
                                 body="Test Comment Body")</pre>
			<p>After that, inside <code>core/comment/tests/test_viewsets.py</code>, add the following content first:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
from rest_framework import status
from core.fixtures.user import user
from core.fixtures.post import post
from core.fixtures.comment import comment
class TestCommentViewSet:
   # The comment resource is nested under the post resource
   endpoint = '/api/post/'</pre>
			<p>Next, let’s <a id="_idIndexMarker314"/>add tests to the list <a id="_idIndexMarker315"/>and retrieve comments as authenticated users:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
...
def test_list(self, client, user, post, comment):
       client.force_authenticate(user=user)
       response = client.get(self.endpoint +
         str(post.public_id) + "/comment/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data["count"] == 1
   def test_retrieve(self, client, user, post, comment):
       client.force_authenticate(user=user)
       response = client.get(self.endpoint +
                             str(post.public_id) +
                             "/comment/" +
                             str(comment.public_id) + "/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data['id'] == comment.public_id.hex
       assert response.data['body'] == comment.body
       assert response.data['author']['id'] ==
         comment.author.public_id.hex</pre>
			<p>Make <a id="_idIndexMarker316"/>sure that these tests pass <a id="_idIndexMarker317"/>by running the <code>pytest</code> command. The next step is to add tests for comment creation, updating, and deletion:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
...
    def test_create(self, client, user, post):
       client.force_authenticate(user=user)
       data = {
           "body": "Test Comment Body",
           "author": user.public_id.hex,
           "post": post.public_id.hex
       }
       response = client.post(self.endpoint +
         str(post.public_id) + "/comment/", data)
       assert response.status_code ==
         status.HTTP_201_CREATED
       assert response.data['body'] == data['body']
       assert response.data['author']['id'] ==
         user.public_id.hex
   def test_update(self, client, user, post, comment):
       client.force_authenticate(user=user)
       data = {
           "body": "Test Comment Body Updated",
           "author": user.public_id.hex,
           "post": post.public_id.hex
       }
       response = client.put(self.endpoint +
                             str(post.public_id) +
                             "/comment/" +
                             str(comment.public_id) +
                             "/", data)
       assert response.status_code == status.HTTP_200_OK
       assert response.data['body'] == data['body']
   def test_delete(self, client, user, post, comment):
       client.force_authenticate(user=user)
       response = client.delete(self.endpoint +
         str(post.public_id) + "/comment/" +
         str(comment.public_id) + "/")
       assert response.status_code ==
         status.HTTP_204_NO_CONTENT</pre>
			<p>Run the <a id="_idIndexMarker318"/>tests again to make sure <a id="_idIndexMarker319"/>everything is green. Let’s write tests for the anonymous users now.</p>
			<p>First of all, we need to make sure that they can access the resources with the <code>GET</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
...
   def test_list_anonymous(self, client, post, comment):
       response = client.get(self.endpoint +
                             str(post.public_id) +
                             "/comment/")
       assert response.status_code == status.HTTP_200_OK
       assert response.data["count"] == 1
   def test_retrieve_anonymous(self, client, post,
     comment):
       response = client.get(self.endpoint +
         str(post.public_id) + "/comment/" +
         str(comment.public_id) + "/")
       assert response.status_code == status.HTTP_200_OK</pre>
			<p>Next, we need <a id="_idIndexMarker320"/>to make sure that an <a id="_idIndexMarker321"/>anonymous user can’t create, update, or delete a comment:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/tests/test_viewsets.py</p>
			<pre class="source-code">
   def test_create_anonymous(self, client, post):
       data = {}
       response = client.post(self.endpoint +
         str(post.public_id) + "/comment/", data)
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED
   def test_update_anonymous(self, client, post, comment):
       data = {}
       response = client.put(self.endpoint +
         str(post.public_id) + "/comment/" +
         str(comment.public_id) + "/", data)
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED
   def test_delete_anonymous(self, client, post, comment):
       response = client.delete(self.endpoint +
         str(post.public_id) + "/comment/" +
         str(comment.public_id) + "/")
       assert response.status_code ==
         status.HTTP_401_UNAUTHORIZED</pre>
			<p>In the <a id="_idIndexMarker322"/>preceding cases, the data <code>dict</code> is empty because we are expecting error statuses.</p>
			<p>Run the <a id="_idIndexMarker323"/>tests again to make sure that everything is green!</p>
			<p>And voilà. We’ve just written tests for <code>CommentViewSet</code>. We also need to write tests for the <code>UserViewSet</code> class, but this will be a small project for you.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor112"/>Writing tests for the UserViewSet class</h2>
			<p>In this <a id="_idIndexMarker324"/>section, let’s do a quick <a id="_idIndexMarker325"/>hands-on exercise. You’ll write the code for the <code>UserViewSet</code> class. It’s quite similar to the other tests we’ve written for <code>PostViewSet</code> and <code>CommentViewSet</code>. I have provided you with the structure of the class, and all you have to do is to write the testing logic in the methods. The following is the structure you need to build on:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/tests/test_viewsets.py</p>
			<pre class="source-code">
from rest_framework import status
from core.fixtures.user import user
from core.fixtures.post import post
class TestUserViewSet:
   endpoint = '/api/user/'
   def test_list(self, client, user):
       pass
   def test_retrieve(self, client, user):
       pass
   def test_create(self, client, user):
       pass
   def test_update(self, client, user):
       pass</pre>
			<p>Here <a id="_idIndexMarker326"/>are the requirements <a id="_idIndexMarker327"/>concerning the tests:</p>
			<ul>
				<li><code>test_list</code>: An authenticated user should enable a list of all users</li>
				<li><code>test_retrieve</code>: An authenticated user can retrieve resources concerning a user</li>
				<li><code>test_create</code>: Users cannot create users directly with a <code>POST</code> request</li>
				<li><code>test_update</code>: An authenticated user can update a <code>user</code> object with a <code>PATCH</code> request</li>
			</ul>
			<p>You can find the solution to this exercise here: <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py">https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/core/user/tests/test_viewsets.py</a>.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor113"/>Summary</h1>
			<p>In this chapter, we learned about testing, the different types of testing, and their advantages. We also introduced testing in Django using Pytest and wrote tests for the models and viewsets. These skills acquired in writing tests using the TDD method help you better design your code, prevent bugs tied to code architecture, and improve the quality of the software. Not to forget, they also give you a competitive advantage in the job market.</p>
			<p>This is the last chapter of <em class="italic">Part 1</em>, <em class="italic">Technical Background</em>. The next part will be dedicated to React and connecting the frontend to the REST API we’ve just built. In the next chapter, we’ll learn more about frontend development and React, and we’ll also create a React project and run it.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor114"/>Questions</h1>
			<ol>
				<li>What is testing?</li>
				<li>What is a unit test?</li>
				<li>What is the testing pyramid?</li>
				<li>What is Pytest?</li>
				<li>What is a Pytest fixture?</li>
			</ol>
		</div>
		<div><div></div>
		</div>
	

		<div><h1 id="_idParaDest-112"><a id="_idTextAnchor115"/>Part 2: Building a Reactive UI with React</h1>
			<p>In <em class="italic">Part 1</em> of our book, we built the backend of the Postagram application using Django, with authentication features and post and comment management. In this part of the book, you will build a React application representing the UI interface of Postagram, where users will see posts and comments and be able to like posts or comments, upload profile pictures, and visit other users’ profiles. At the end of this part, you will have the required knowledge to use React to handle authentication from the frontend side, build UI components from scratch, work with React Hooks such as <code>useState</code>, <code>useContext</code>, and <code>useMemo</code>, and send requests to a REST API and handle the responses.  </p>
			<p>This section comprises the following chapters:</p>
			<ul>
				<li><a href="B18221_06.xhtml#_idTextAnchor116"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating a Project with React</em></li>
				<li><a href="B18221_07.xhtml#_idTextAnchor144"><em class="italic">Chapter 7</em></a>, <em class="italic">Building Login and Registration Forms</em></li>
				<li><a href="B18221_08.xhtml#_idTextAnchor164"><em class="italic">Chapter 8</em></a>, <em class="italic">Social Media Posts</em></li>
				<li><a href="B18221_09.xhtml#_idTextAnchor182"><em class="italic">Chapter 9</em></a>, <em class="italic">Post Comments</em></li>
				<li><a href="B18221_10.xhtml#_idTextAnchor205"><em class="italic">Chapter 10</em></a>, <em class="italic">User Profiles</em></li>
				<li><a href="B18221_11.xhtml#_idTextAnchor218"><em class="italic">Chapter 11</em></a>, <em class="italic">Effective UI Testing for React Components</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>