["```py\nclass ErrorCode(Enum):\n    NOT_FOUND = \"NOT_FOUND\"\n    VALIDATION_ERROR = \"VALIDATION_ERROR\"\n    # Add other error codes as needed\n@dataclass(frozen=True)\nclass Error:\n    \"\"\"Standardized error information\"\"\"\n    code: ErrorCode\n    message: str\n    details: Optional[dict[str, Any]] = None\n    @classmethod\n    def not_found(cls, entity: str, entity_id: str) -> Self:\n        return cls(\n            code=ErrorCode.NOT_FOUND,\n            message=f\"{entity} with id {entity_id} not found\"\n        )\n\n    @classmethod\n    def validation_error(cls, message: str) -> Self:\n        return cls(\n            code=ErrorCode.VALIDATION_ERROR,\n            message=message\n        ) \n```", "```py\n@dataclass(frozen=True)\nclass Result:\n    \"\"\"Represents success or failure of a use case execution\"\"\"\n    value: Any = None \n    error: Optional[Error] = None\n\n    @property\n    def is_success(self) -> bool:\n        return self.error is None\n    @classmethod\n    def success(cls, value: Any) -> Self:\n        return cls(value=value)\n\n    @classmethod\n    def failure(cls, error: Error) -> Self:\n        return cls(error=error) \n```", "```py\ntry:\n    project = find_project(project_id)\n    task = create_task(task_details)\n    project.add_task(task)\n    notify_stakeholders(task)\n    return Result.success(TaskResponse.from_entity(task))\nexcept ProjectNotFoundError:\n    return Result.failure(Error.not_found(\"Project\", str(project_id)))\nexcept ValidationError as e:\n    return Result.failure(Error.validation_error(str(e))) \n```", "```py\n@dataclass(frozen=True)\nclass CompleteTaskUseCase:\n    \"\"\"Use case for marking a task as complete and notifying \n    stakeholders\"\"\"\n    task_repository: TaskRepository\ndef execute(\n        self,\n        task_id: UUID,\n        completion_notes: Optional[str] = None\n    ) -> Result:\n... \n```", "```py\ndef execute(\n        self,\n        task_id: UUID,\n        completion_notes: Optional[str] = None\n    ) -> Result:\n        try:\n            # Input validation\n            task = self.task_repository.get(task_id)\n            task.complete(\n                notes=completion_notes\n            )\n            self.task_repository.save(task)\n\n            # Return simplified task data\n            return Result.success({\n                \"id\": str(task.id),\n                \"status\": \"completed\",\n                \"completion_date\": task.completed_at.isoformat()\n            })\n\n        except TaskNotFoundError:\n            return Result.failure(Error.not_found(\"Task\", str(task_id)))\n        except ValidationError as e:\n            return Result.failure(Error.validation_error(str(e))) \n```", "```py\nclass TaskRepository(ABC):\n    \"\"\"Repository interface defined by the Application Layer\"\"\"\n    @abstractmethod\n    def get(self, task_id: UUID) -> Task:\n        \"\"\"Retrieve a task by its ID\"\"\"\n        pass\n\n    @abstractmethod\n    def save(self, task: Task) -> None:\n        \"\"\"Save a task to the repository\"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, task_id: UUID) -> None:\n        \"\"\"Delete a task from the repository\"\"\"\n        pass\nclass NotificationService(ABC):\n    \"\"\"Service interface for sending notifications\"\"\"\n    @abstractmethod\n    def notify_task_assigned(self, task_id: UUID) -> None:\n        \"\"\"Notify when a task is assigned\"\"\"\n        pass\n    @abstractmethod\n    def notify_task_completed(self, task: Task) -> None:\n        \"\"\"Notify when a task is completed\"\"\"\n        Pass \n```", "```py\nclass MongoDbTaskRepository(TaskRepository):\n    \"\"\"MongoDB implementation of the TaskRepository interface\"\"\"\n    def __init__(self, client: MongoClient):\n        self.client = client\n        self.db = client.task_management\n        self.tasks = self.db.tasks\n\n    def get(self, task_id: UUID) -> Task:\n        \"\"\"Retrieve a task by its ID\"\"\"\n        document = self.tasks.find_one({\"_id\": str(task_id)})\n        if not document:\n            raise TaskNotFoundError(task_id)\n        # ... remainder of method implementation\n\n    # Other interface methods implemented ... \n```", "```py\n@dataclass(frozen=True)\nclass CompleteProjectUseCase:\n    project_repository: ProjectRepository\n    task_repository: TaskRepository\n    notification_service: NotificationService\n    def execute(\n        self,\n        project_id: UUID,\n        completion_notes: Optional[str] = None\n    ) -> Result:\n        ... \n```", "```py\ndef execute(\n        self,\n        project_id: UUID,\n        completion_notes: Optional[str] = None\n    ) -> Result:\n        try:\n            # Validate project exists\n            project = self.project_repository.get(project_id)\n\n            # Complete all outstanding tasks\n            for task in project.incomplete_tasks:\n                task.complete()\n                self.task_repository.save(task)\n                self.notification_service.notify_task_completed(task)\n            # Complete the project itself\n            project.mark_completed(\n                notes=completion_notes\n            )\n            self.project_repository.save(project)\n\n            return Result.success({\n                \"id\": str(project.id),\n                \"status\": project.status,\n                \"completion_date\": project.completed_at,\n                \"task_count\": len(project.tasks),\n                \"completion_notes\": project.completion_notes,\n            })\n\n        except ProjectNotFoundError:\n            return Result.failure(Error.not_found(\n                \"Project\", str(project_id)))\n        except ValidationError as e:\n            return Result.failure(Error.validation_error(str(e))) \n```", "```py\n@dataclass(frozen=True)\nclass CompleteProjectRequest:\n    \"\"\"Data structure for project completion requests\"\"\"\n    project_id: str  # From API (will be converted to UUID)\n    completion_notes: Optional[str] = None\n    def __post_init__(self) -> None:\n        \"\"\"Validate request data\"\"\"\n        if not self.project_id.strip():\n            raise ValidationError(\"Project ID is required\")\n        if self.completion_notes and len(self.completion_notes) > 1000:\n            raise ValidationError(\n                \"Completion notes cannot exceed 1000 characters\")\n    def to_execution_params(self) -> dict:\n        \"\"\"Convert validated request data to use case parameters\"\"\"\n        return {\n            'project_id': UUID(self.project_id),\n            'completion_notes': self.completion_notes\n        } \n```", "```py\n@dataclass(frozen=True)\nclass CompleteProjectResponse:\n    \"\"\"Data structure for project completion responses\"\"\"\n    id: str\n    status: str\n    completion_date: str\n    task_count: int\n    completion_notes: Optional[str]\n    @classmethod\n    def from_entity(cls,\n                    project: Project,\n                    user_service: UserService\n    ) -> 'CompleteProjectResponse':\n        \"\"\"Create response from domain entities\"\"\"\n        return cls(\n            id=str(project.id),\n            status=project.status,\n            completion_date=project.completed_at,\n            task_count=len(project.tasks),\n            completion_notes=project.completion_notes,\n        ) \n```", "```py\n@dataclass(frozen=True)\nclass CompleteProjectUseCase:\n    project_repository: ProjectRepository\n    task_repository: TaskRepository\n    notification_service: NotificationService\n    # Using CompleteProjectRequest vs discreet parameters\n    def execute(self, request: CompleteProjectRequest) -> Result:\n        try:\n            params = request.to_execution_params()\n            project = self.project_repository.get(params[\"project_id\"])\n            project.mark_completed(notes=params[\"completion_notes\"])\n            # Complete all outstanding tasks\n            # ... Truncated for brevity \n            self.project_repository.save(project)\n            # using CompleteProjectResponse vs handbuilt dict\n            response = CompleteProjectResponse.from_entity(project)\n            return Result.success(response)\n        except ProjectNotFoundError:\n            return Result.failure(\n                Error.not_found(\"Project\", str(params[\"project_id\"]))\n            )\n        except ValidationError as e:\n            return Result.failure(Error.validation_error(str(e))) \n```", "```py\n# Port: Defines capability needed by Application Layer\nclass NotificationPort(ABC):\n\n    @abstractmethod\n    def notify_task_completed(self, task: Task) -> None:\n        \"\"\"Notify when a task is completed\"\"\"\n        pass\n    # other capabilities as needed \n```", "```py\n@dataclass\nclass SetTaskPriorityUseCase:\n    task_repository: TaskRepository\n    notification_service: NotificationPort # Depends on \n                                           # capability interface\n    def execute(self, request: SetTaskPriorityRequest) -> Result:\n        try:\n            params = request.to_execution_params()\n\n            task = self.task_repository.get(params['task_id'])\n            task.priority = params['priority']\n\n            self.task_repository.save(task)\n\n            if task.priority == Priority.HIGH:\n                self.notification_service.notify_task_high_priority(task)\n\n            return Result.success(TaskResponse.from_entity(task))\n        except ValidationError as e:\n            return Result.failure(Error.validation_error(str(e))) \n```", "```py\n@dataclass(frozen=True)\nclass TaskManagementUseCase:\n    task_repository: TaskRepository\n    notification_service: NotificationPort\n    _optional_services: dict[str, Any] = field(default_factory=dict)\n    def register_service(self, name: str, service: Any) -> None:\n        \"\"\"Register an optional service\"\"\"\n        self._optional_services[name] = service\n\n    def complete_task(self, task_id: UUID) -> Result:\n        try:\n            task = self.task_repository.get(task_id)\n            task.complete()\n            self.task_repository.save(task)\n\n            # Required notification\n            self.notification_service.notify_task_completed(task)\n\n            # Optional integrations\n            if analytics := self._optional_services.get('analytics'):\n                analytics.track_task_completion(task.id)\n            if audit := self._optional_services.get('audit'):\n                audit.log_task_completion(task.id)\n\n            return Result.success(TaskResponse.from_entity(task))\n        except ValidationError as e:\n            return Result.failure(Error.validation_error(str(e))) \n```", "```py\nclass ModernNotificationService:\n    \"\"\"Third-party service with a different interface\"\"\"\n    def send_notification(self, payload: dict) -> None:\n        # Modern service implementation\n        pass\nclass ModernNotificationAdapter(NotificationPort):\n    \"\"\"Adapts modern notification service to work with our interface\"\"\"\n    def __init__(self, modern_service: ModernNotificationService):\n        self._service = modern_service\n\n    def notify_task_completed(self, task: Task) -> None:\n        self._service.send_notification({\n            \"type\": \"TASK_COMPLETED\",\n            \"taskId\": str(task.id)\n        }) \n```"]