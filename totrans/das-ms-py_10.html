<html><head></head><body>
        

                            
                    <h1 class="header-title">Reactive Programming</h1>
                
            
            
                
<p>In the previous chapter, you learned about unit testing and the <kbd>unittest.mock</kbd> package. In this chapter, you will get a handle on the concepts of reactive programming and then take a look at the RxPY reactive programming framework. We'll work on solidifying your conceptual understanding of reactive programming and put together a very bare-bones reactive programming system from scratch.</p>
<p>In this chapter, we will coverÂ the following topics:</p>
<ul style="padding-left: 5px">
<li>What does reactive programming mean?</li>
<li>Building a simple reactive programming framework</li>
<li>Using the <strong>Reactive Extensions for Python</strong> (<strong>RxPY</strong>)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The concept of reactive programming</h1>
                
            
            
                
<p>There are a lot of different and valid ways that I could define reactive programming. It's a matter of perspective and focus. Which of them is the best definition? We're going to cover several in this section.</p>
<p>Perhaps, the most fundamental definition of reactive programming, at least in terms of what we need to think about to implement a reactive programming system, is that it's a publish/subscribe model of event handling. The following diagram illustrates the basic reactive event handling:</p>
<div><img height="278" width="528" class="image-border" src="img/992c7bdd-b087-4da6-848f-4f01fc3cd7be.jpg"/></div>
<p>In the traditional nomenclature of reactive programming, there are <strong>observables</strong> and <strong>observers</strong>, which encapsulate the behavior of event publishers and event subscribers, respectively. In a reactive programming system, everything, or at least as much as possible, is an observable or an observer. So far, so good, but the publish/subscribe model by itself isn't really that exciting.</p>
<p>Reactive programming comes into its own when we recognize that an observable is conceptually very similar to a list, which means functional programming tools, such as map and reduce, have powerful analogues that apply to observables. So, the second definition of reactive programming is that it's <strong>event-driven functional</strong> programming.</p>
<p>The idea that we could, for example, take two observables, map a function over one of them, merge the result with the other, and reduce that merge sequence to a new value is a powerful one. We could describe all of the operations we want to perform ahead of time and whenever a new value comes out of one of the root observables, it will cascade through our whole processing chain, without further effort on our part.</p>
<p>Functional programming operations are mostly stateless and when they're not, the state is at least easy to define and keep contained. This means that our event-driven, mostly-stateless reactive programming systems are very well-suited to asynchronous or parallel execution. Thus, our third definition of reactive programming is that it's a systematic way of writing high-performance asynchronous or parallel code.</p>
<p>So, what is reactive programming? Let's bundle those definitions together. Reactive programming is an event-driven paradigm in which event sources can have functional operators applied to them to create new event sources. This is desirable because it results in programs that work well in asynchronous or parallel execution environments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a simple reactive programming framework</h1>
                
            
            
                
<p>You have gained an understanding of what reactive programming means in a theoretical way. Now, we're going to get very concrete and build a simple reactive programming system, then build a demo so we can watch it in action. The roots of formalized reactive programming are in statically typed languages, particularly C#. That's of little concern to us as users of a language based around dynamic typing, but it does mean that the standard presentation of these ideas is heavily intertwined with types, templates, interfaces, and anonymous functions. We'll be a little less Pythonic here and perhaps a little more C#-ish. That said, let's move on to the coding.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Observers</h1>
                
            
            
                
<p>Arguably, the single most fundamental element of a reactive programming system is the observer interface. The definition of how we can notify an object that the next item in a sequence is watching it is available. What we're starting with in the following code example is an abstract base class, the closest Python equivalent to a C# interface:</p>
<div><img height="163" width="295" class="aligncenter size-full wp-image-793 image-border" src="img/4dea38a2-5d5b-40da-b390-3b93ddadf9ea.jpg"/></div>
<p>Our <kbd>Observer</kbd> class doesn't define any functionality at all, just method names and signatures, and guarantees that classes which inherit from it will have to implement at least the <kbd>on_event</kbd> method. For a complete functionality, they'd have to implement <kbd>on_exception</kbd> and <kbd>on_complete</kbd> as well, but that's not required.</p>
<p>So, the intent is that an <kbd>Observer</kbd> class will have its <kbd>on_event</kbd> method called once for each element of the sequence, followed by its <kbd>on_complete</kbd> method if the sequence terminates while the observer is watching it. If something goes sideways, the <kbd>on_exception</kbd> method would be called instead.</p>
<p>For an <kbd>Observer</kbd> class to be useful, there must also be an <kbd>Observable</kbd> class. So, let's see the beginning of that class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Observables</h1>
                
            
            
                
<p>Like <kbd>Observer</kbd>, <kbd>Observable</kbd> is an abstract base class, although in this case, we provide meaningful default implementations of all of its functionality.</p>
<p>The <kbd>subscribe</kbd> method, shown in the following code example, is how an <kbd>Observer</kbd> class connects to the <kbd>Observable</kbd> class, registering itself as a consumer of the events that the <kbd>Observable</kbd> class emits:</p>
<div><img height="117" width="483" class="aligncenter size-full wp-image-794 image-border" src="img/7b07d43e-abc6-4005-8c60-0ceb39272862.jpg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Emitting events</h1>
                
            
            
                
<p>There are three methods which take care of emitting events. These are as follows:</p>
<ul style="padding-left: 5px">
<li>One for sending normal events</li>
<li>One for sending exceptions</li>
<li>One for sending a "this sequence has ended" event</li>
</ul>
<p>These are shown in the following code example:</p>
<div><img height="324" width="493" class="aligncenter size-full wp-image-796 image-border" src="img/963c86ca-7b46-428f-a17e-2f2e3c118e6e.jpg"/></div>
<p>In each case, they do a bit of error checking, then loop through the registered observers and invoke the appropriate method. These methods have names prefixed with a single underscore (<kbd>_</kbd>), marking them as not part of the public interface of the <kbd>Observable</kbd> class. They are helpers to make subclasses easier to write.</p>
<p>That can't possibly be a complete reactive programming system, can it? Yes and no. It is fundamentally complete, but it's lacking a great many refinements and in no way is it ready for a production environment. It will serve nicely as the spine for our demo program though, so let's move on to that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the observable sequence</h1>
                
            
            
                
<p>For our demo, we'll make a program that prints messages loosely representing the sounds we might hear in a zoo. The animals will be represented as observables emitting events, representing sounds at random intervals. We'll use merging and mapping to combine and modify the event sequences, before finally printing out the resulting sequence.</p>
<p>So, first of all, we have our <kbd>Animal</kbd> class, which is an observable, and the <kbd>AnimalEvent</kbd> helper class. The <kbd>Animal</kbd> class contains some basic information and a coroutine, which will run asynchronously and occasionally send events to the observers of the <kbd>Animal</kbd> class as shown in the following code example:</p>
<div><img height="281" width="403" class="aligncenter size-full wp-image-797 image-border" src="img/d76f72c0-3a3a-4ab6-8516-003fcbe54a45.jpg"/></div>
<p>Looking at the preceding code, we can see that an animal is effectively a sequence of noise events, then a die event, immediately followed by the completion of the sequence.</p>
<p>We want some of our animals to be capable of creating loud noises. Instead of adding that capability to the <kbd>Animal</kbd> class, we'll create a mapping over the sequence of events, which replaces randomly selected noise events with loud noise events.</p>
<p>This mapping is both an observer, so that it can subscribe to the sequence of events, and an observable because the sequence of modified events is still a sequence of events and not much use if another observable can't subscribe to it.</p>
<p>This is fundamentally what happens in any reactive programming system when we apply an operator to an observable sequence to create a new observable sequence. However, in almost every case, a real reactive system provides us with a quicker, easier, and usually more efficient way of doing it.</p>
<p>Actually creating a class that's both observer and observable is rare indeed!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Illustrating a stream of animal events</h1>
                
            
            
                
<p>There's one more piece we need before we start putting things together and that's a way to display a stream of animal events. Another observer is the obvious choice for that and it turns out to be quite easy, as you can see in the following code example:</p>
<div><img height="134" width="310" class="aligncenter size-full wp-image-798 image-border" src="img/0f250761-dcdf-4a76-a28d-199333e5d487.jpg"/></div>
<p>The code for a new observer is similar to what we've already seen; all we need is a constructor and an appropriate <kbd>on_event</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Composing an observable sequence</h1>
                
            
            
                
<p>Now that we've got all the pieces, how do we put them together to achieve our goal? Well, first we make our animal objects and then use the <kbd>SometimesLoud</kbd> and <kbd>Output</kbd> classes to create our modified composite sequence and display it as shown in the following code example from <kbd>animals.py</kbd>:</p>
<p><img height="122" width="507" class="aligncenter size-full wp-image-799 image-border" src="img/862005ac-4c88-48a4-9552-1343a5265725.jpg"/></p>
<p>Then, we need to schedule the run methods of each animal for asynchronous execution via <kbd>asyncio</kbd>, which happens implicitly in this example when we pass them as parameters together in our <kbd>__main__.py</kbd> file:</p>
<div><img height="150" width="917" class="aligncenter size-full wp-image-806 image-border" src="img/1bf0ba87-74af-488a-8af6-d23a04f4bc72.jpg"/></div>
<p>Our <kbd>__main__.py</kbd> file actually runs the <kbd>asyncio</kbd> event loop. So, now we can just sit back and watch the pseudo cacophony of our imaginary zoo, as shown in the following output window:</p>
<div><img height="194" width="241" class="image-border" src="img/8c9dc959-ee3b-4480-815c-9c799a4798f4.png"/></div>
<p>Did you notice how the meat of our program is boiled down to a single line of code?</p>
<p>Sure, we have a whole file devoted to the framework, but that's reusable. We also have the <kbd>SometimesLoud</kbd> and <kbd>Output</kbd> classes, but the only reason they're here is so we can see exactly what happens at each step of this program.</p>
<p>In a real system, <kbd>Output</kbd> and <kbd>SometimesLoud</kbd> would have used built-in functionality that mapped the function on the sequence, as we'll see in the next section. All of this leaves us with a single line of code that composites several observable sequences and transformations, and defines most of the behavior of the program. This one line demonstrates the power of reactive programming.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the reactive extensions for Python (RxPY)</h1>
                
            
            
                
<p>Now that we have a basic understanding of reactive programming under our belts, let's look at one of the more widely used reactive programming frameworks called <strong>Reactive Extensions</strong>, which is often shortened to <strong>ReactiveX</strong>, or simply <strong>Rx</strong>.</p>
<p>Rx is not part of a standard Python installation, so we'll need to use <kbd>pip</kbd> to install it. No problem; it's only a single command, if you prefer to install to your Python system library instead of user library, or you are working in a virtual created by the <kbd>--user</kbd> from this command, as shown here:</p>
<div><img height="214" width="581" class="image-border" src="img/6a4d4269-fc26-4db2-b5f0-e7ab7f44b08b.png"/></div>
<p>Once we have Rx installed, we can move on to the fun stuff.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Translating our zoo demo into Rx</h1>
                
            
            
                
<p>Like our example in the previous section, Rx provides <kbd>Observer</kbd> and <kbd>Observable</kbd> classes, and they encompass the same basic functionality.</p>
<p>The largest visible difference is that the <kbd>Observable</kbd> class of Rx has a large number of factory methods that could be used to construct special-purpose observables, especially, observables that produce a sequence based on one or more other observable sequences. In other words, most of the operators and operations that we'll use to construct a reactive dataflow are methods of the <kbd>Observable</kbd> class.</p>
<p>Let's take a moment to rewrite our demo from the previous section in Rx and we'll see what that means in practice.</p>
<p>The <kbd>AnimalEvent</kbd> class can stay the same, since it's just a data structure and doesn't know anything about who's using it for what. Our <kbd>Animal</kbd> class changes quite a bit. The run coroutine method goes away and in its place we have a somewhat simpler <kbd>generate_event</kbd> method (refer to the following code example):</p>
<div><img height="249" width="470" class="aligncenter size-full wp-image-800 image-border" src="img/79366e77-2498-4d0e-9a3c-5418f9d1ab9c.jpg"/></div>
<p>That name isn't significant by the way; it's just a reasonable name I picked because it describes what the method does.</p>
<p>As shown in the preceding code, the <kbd>generate_event</kbd> method by itself doesn't encompass the entire functionality of the old run coroutine method, though. It knows how to emit an event, but it doesn't know how to wait a short while and do it again. That's where the <kbd>as_observable</kbd> method comes into play.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Observable factory methods</h1>
                
            
            
                
<p>The <kbd>as_observable</kbd> method uses one of the factory methods of the <kbd>Observable</kbd> class to create an observable sequence. This sequence is backed up by what is functionally a generator, although it's not implemented as one because that concept doesn't exist in every language that Rx is portable to.</p>
<p>So, instead of a real generator, we're providing it with a state variable, which in this case is just the animal instance, along with functions it could call to check whether the sequences continue, update the state, get the next value in the sequence, or determine how long to wait before producing the next value. The factory method also accepts a scheduler object, which we'll discuss later in this section. So, what we're asking for in this code is an observable that produces animal events at random intervals from 0 to 10 seconds. Now, the <kbd>Animal</kbd> class may be a little simpler than it used to be; there's not a big difference.</p>
<p>However, let's take a look at what happens with the <kbd>SometimesLoud</kbd> and <kbd>Output</kbd> classes (refer to the following code example); they're not classes anymore, just functions, and are significantly simpler:</p>
<div><img height="176" width="411" class="aligncenter size-full wp-image-802 image-border" src="img/a658e30b-d361-449d-9d5d-033be099cb95.jpg"/></div>
<p>The <kbd>sometimes_loud</kbd> function takes an event and returns an event, and we'll use it to map from one observable sequence of events into a new one, just as you'd expect in a functional programming environment. The <kbd>output</kbd> function takes an event and returns none, which is again what we'd expect for a <kbd>side_effect</kbd> in a functional system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Explaining the observable sequence of events</h1>
                
            
            
                
<p>So, now that we have our observable factory method and function to take and return an event; what do we need to do to put it all together? First, we will create an <kbd>asyncio</kbd> scheduler. Next comes the interesting part, where we will tell the computer how to combine and process those observable sequences.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an asyncio scheduler</h1>
                
            
            
                
<p>We can create an <kbd>asyncio</kbd> scheduler using a simple command, as shown here:</p>
<pre>
<strong>scheduler = rx.concurrency.AsyncIOScheduler ()</strong>  
</pre>
<p>This is an Rx scheduler that specifically integrates with an <kbd>asyncio</kbd> event loop. Rx contains quite a few different scheduler implementations that integrate with various event loops available in Python, as well as one that uses Python threads to implement scheduling.</p>
<p>Regardless of which scheduler we use, the scheduler's job will be to decide when time-based elements of our event pipeline occur. This means that in this example, the scheduler is going to be deciding when our animal observables produce new values.</p>
<p>After creating the scheduler, we create the animal objects and their observable sequence of events. The animal objects are the easy part, as shown here:</p>
<div><img height="51" width="515" class="aligncenter size-full wp-image-803 image-border" src="img/2cff40d7-a19a-4a9b-acb2-898c8c3bf090.jpg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Combining and processing observable sequences</h1>
                
            
            
                
<p>For combining and processing the observable sequences, we have three steps to follow. These are explained here:</p>
<ul style="padding-left: 5px">
<li>First, we merge the elephant and lion sequences into a single combined sequence, and process that sequence through our <kbd>sometimes_loud</kbd> function to create a new sequence we call <kbd>louder</kbd>, as shown in the following code example:</li>
</ul>
<pre>
      louder = rx.Observable.merge(elephant,<br/>      lion).select(sometimes_loud) 
</pre>
<p style="padding-left: 60px">The <kbd>select</kbd> method used in that line is the direct equivalent of the map function in a functional programming environment.</p>
<ul style="padding-left: 5px">
<li>Next, we merge the <kbd>louder</kbd> sequence with the remaining animal sequences and tell the system that whenever a new value arrives at the front of that merge sequence, it should call the output function on that value:</li>
</ul>
<pre>
      out = rx.Observable.merge(fox, snake, louder)<br/>      .do_action(on_next = output) 
</pre>
<p style="padding-left: 60px">The <kbd>do_action</kbd> method used in this example is not equivalent to map because it doesn't transform the sequence; it just performs an action on each element of it.</p>
<p>The <kbd>do_action</kbd> method is for side_effects.</p>
<ul style="padding-left: 5px">
<li>Finally, as shown as follows, we subscribe to the <kbd>on_completed</kbd> event on the out observable sequence, which is the same as the sequence merging all event streams into one, since the <kbd>do_action</kbd> operation returns its input sequence unchanged:</li>
</ul>
<pre>
      done = asyncio.Future() 
      out.subscribe(on_completed = (lambda:<br/>      done.set_result(True))) 
      return done 
</pre>
<p style="padding-left: 60px">When the sequence is complete, we set a result value on the <kbd>done</kbd> future. Since we used that feature as the perimeter to run until complete in our <kbd>main.py</kbd> file, setting its result value terminates the <kbd>asyncio</kbd> event loop and our program ends.</p>
<p>The complete code listing for the <kbd>animals.py</kbd> file in this section is as follows:</p>
<p class="mce-root"><img height="213" width="541" class="aligncenter size-full wp-image-804 image-border" src="img/550bfeb1-8b85-483c-92a2-5fc8e416179b.jpg"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Miscellaneous observable factory methods</h1>
                
            
            
                
<p>The demo that we just worked through has shown us the <kbd>merge</kbd>, <kbd>merge.select</kbd>, and <kbd>generate_with_relative_time</kbd> factory methods of <kbd>Observable</kbd>, but that's just the tip of the iceberg.</p>
<p>There are so many observable factories (a sample of which is shown in the following image) that it would take more time than we have, just to get a short description of each one:</p>
<div><img height="83" width="610" class="aligncenter size-full wp-image-1117 image-border" src="img/66acf3f8-e9b7-4e01-830f-026ea275a0ae.jpg"/></div>
<p>Each of them gives us a useful way of constructing an observable, usually, but not always, based on one or more other observables.</p>
<p>Python's interactive shell and <kbd>help</kbd> function are our friends here. There's a lot to be learned by poking around in the <kbd>Observable</kbd> class. In the meantime, we're going to talk about a few of the very best observable factory methods that we haven't seen yet.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Observable.create method</h1>
                
            
            
                
<p>First on that list is <kbd>Observable.create</kbd> shown in the following code example. This is the recommended way of creating a completely customized observable:</p>
<pre>
<strong>rx.Observable.create((lambda obs: obs.on_next('Hi!')))</strong> 
</pre>
<p>The <kbd>create</kbd> method has callable as its parameter and calls that callable each time an observer subscribes to the observable.</p>
<p>In the preceding code example, we created an observable that says <kbd>Hi!</kbd> when an observer subscribes and then never produces another value; not the most useful of sequences, but it serves to illustrate the idea.</p>
<p>We can take the basic framework and construct an observable with any behavior we like from it, without subclassing the observable class and without re-implementing, probably incorrectly, the internal machinery that keeps observables synchronized and functioning properly in an asynchronous or parallel environment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Observable.select_many method</h1>
                
            
            
                
<p>Next is <kbd>Observable.select_many</kbd>. This time, let's take a look at what Python's <kbd>help</kbd> function can show us, using following command:</p>
<pre>
<strong>help(rx.Observable.select_many) </strong> 
</pre>
<p>This should give you the following description:</p>
<div><img height="383" width="518" class="image-border" src="img/bd704f31-53a9-42d1-b55f-073a51f56c66.jpg"/></div>
<p>This observable factory method is a more generalized version of select. Here, select applies a function to each member of the sequence to create a new sequence from the function return values, and <kbd>select_many</kbd> expects a function that returns an observable sequence and concatenates those sequences.</p>
<p>This means that the function applied by <kbd>select_many</kbd> can remove elements from the sequence by returning an empty sequence and it can insert values by returning a sequence containing more than one element.</p>
<p>As with select, the values added to the result aren't necessarily the same values that were passed to the function either, so <kbd>select_many</kbd> can produce a sequence containing more or fewer values than the input sequence and the values can be determined however we choose.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Empty, return_value, and from_iterable factory methods</h1>
                
            
            
                
<p>Empty sequences and sequences of one value are easy to create using the <kbd>empty</kbd> and <kbd>return_value</kbd> factory methods, respectively. These can be shown using two commands, which are illustrated with their help pages respectively.</p>
<pre>
<strong>help (rx.Observable.empty)  </strong>
</pre>
<p>This command will lead us to the following help page:</p>
<div><img height="161" width="495" class="aligncenter size-full wp-image-1020 image-border" src="img/4014c686-12e0-4d38-9a51-f7abe4806bf4.jpg"/></div>
<p>Similarly, in the case of <kbd>return_value</kbd>, we can use this command:</p>
<pre>
<strong>help (rx.Observable.return_value)</strong>  
</pre>
<p>We'll get this help page explaining how to use the method:</p>
<div><img height="217" width="502" class="image-border" src="img/62a8165d-d02c-4e54-89c4-e88ba580ff94.png"/></div>
<p>Similarly, it's easy to construct an observable sequence of any already known series of objects using the <kbd>of</kbd> or <kbd>from_iterable</kbd> factory methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The where factory method</h1>
                
            
            
                
<p>While we could use <kbd>select_many</kbd> to remove unwanted events from an observable sequence, it's easier to use the <kbd>where</kbd> method. Let's look at the help information for the <kbd>where</kbd> method:</p>
<pre>
<strong>help (rx.Observable.where)</strong>  
</pre>
<p>This method applies a callable to each element of the input observable sequence and returns an observable sequence containing only those elements for which the callable returned true. The following image shows the help description:</p>
<div><img height="235" width="509" class="aligncenter size-full wp-image-1021 image-border" src="img/f537127e-1e7b-4672-8d55-4f57575244d7.jpg"/></div>
<p>Now we saw that there are fundamental ways to add and remove observable sequences, so what about processing them? We could just use <kbd>select</kbd> and <kbd>select_many</kbd> to do all of our processing, but Rx provides us with many more methods, such as <kbd>min</kbd>, <kbd>max</kbd>, <kbd>average</kbd>, <kbd>distinct</kbd>, <kbd>slice</kbd>, and <kbd>zip</kbd>, just to name a few of the tools available to us. I highly recommend that you investigate the Rx framework in more detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we discussed what reactive programming is and implemented a bare-bones reactive framework, and used it to implement a demo program to help us get a handle on the concepts. We looked at the Reactive Extensions for Python, and used them to re-implement our zoo demo. We finished by looking at some of the broader possibilities of the Rx framework.</p>
<p>In the next chapter, we'll look at microservices, which are very small server processes that are meant to work together to create the desired results.</p>


            

            
        
    </body></html>