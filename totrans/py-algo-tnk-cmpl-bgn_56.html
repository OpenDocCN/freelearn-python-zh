<html><head></head><body><div><div><h2>Chapter 38 <br/>Introduction to Object-Oriented Programming</h2>
<h3 id="toc_1">38.1 What is Object-Oriented Programming?</h3>
<p class="my_basic">In <a href="part07.html">Part VII</a> all the programs that you read or even wrote, were using subprograms (functions and void functions). This programming style is called procedural programming and most of the time it is just fine! But when it comes to writing large programs, or working in a big company such as Microsoft, Facebook, or Google, object-oriented programming is a must use programming style!</p>
<p class="my_basic">Object-oriented programming, usually referred to as OOP, is a style of programming that focuses on objects. In OOP, data and functionality are combined and encapsulated inside something called an object. Applying object-oriented programming principles enables you to maintain your code more easily, and write code that can be easily understood and used by others.</p>
<p class="my_basic">What does the statement “OOP focuses on objects” truly mean? Let's consider an example from the real world. Imagine a car. How would you describe a particular car? It has specific attributes, such as the brand, the model, the color, and the license plate. Additionally, there are specific actions this car can perform, or have performed on it. For instance, someone can turn it on or off, accelerate or apply the brakes, or park.</p>
<p class="my_basic">In OOP, this car can be represented as an object with specific attributes (commonly referred to as fields) that can perform specific actions (referred to as methods).</p>
<p class="my_basic">Obviously, you may now be asking yourself, “How can I create objects in the first place?” The answer is simple! All you need is a class. A class resembles a "rubber inkpad stamp”! In Figure 38-1 there is a stamp (this is the class) with four empty fields and three actions (methods).</p>
<p class="centered_image"><img alt="Image" class="width23" src="img/chapter38-01.png"/></p>
<p class="caption">Figure 38-1 A class resembles a “rubber inkpad stamp”</p>
<p class="my_basic">Someone who uses this stamp can stamp-out many cars (these are the objects). In Figure 38-2, for example, a little boy stamped-out those two cars and then he colored them and filled out each car's fields with specific attributes.</p>
<p class="centered_image"><img alt="Image" class="width35" src="img/chapter38-02.png"/></p>
<p class="caption">Figure 38-2 You can use the same rubber stamp as a template to stamp-out many cars</p>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>The process of creating a new object (a new instance of a class) is called “instantiation”.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>A class is a template and every object is created from a class. Each class should be designed to carry out one, and only one, task! This is why, most of the time, more than one class is used to build an entire application!</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>In OOP, the rubber stamp is the class. You can use the same class as a template to create (instantiate) many objects!</p>
</div>
<h3 id="toc_2">38.2 Classes and Objects in Python</h3>
<p class="my_basic">Now that you have a grasp of the theoretical concepts behind classes and objects, let's dive into writing a real class in Python! The following code fragment creates the class Car. There are four fields and three methods within the class.</p>
<div><p>class Car:</p>
<p>#Define four fields</p>
<p>brand = ""</p>
<p>model = ""</p>
<p>color = ""</p>
<p>licensePlate = ""</p>
<div></div>
<p>#Define method turnOn()</p>
<p>def turnOn(self):</p>
<div><blockquote><p>print("The car turns on")</p></blockquote></div>
<div></div>
<p>#Define method turnOff()</p>
<p>def turnOff(self):</p>
<div><blockquote><p>print("The car turns off")</p></blockquote></div>
<div></div>
<p>#Define method accelerate()</p>
<p>def accelerate(self):</p>
<div><blockquote><p>print("The car accelerates")</p></blockquote></div>
</div>
<p class="my_basic">And here's an interesting tidbit: Fields and methods within classes are essentially just ordinary variables and subprograms respectively!</p>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>In Object-Oriented Programming (OOP), the terms used are “methods” (instead of “functions”) and “void methods” (instead of “void functions”).</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>The class Car is just a template. No objects are created yet!</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>No need to wonder what this self keyword is, yet! It will be explained thoroughly in the next section (<a href="#toc_3">Section 38.3</a>).</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>The name of a class should follow the Upper Camel Case convention as well as all the rules for naming variables presented in <a href="chapter05.html#toc_4">Section 5.4</a>.</p>
</div>
<p class="my_basic">To create two objects (or in other words to create two instances of the class Car), you need the following two lines of code.</p>
<div><p>car1 = Car()</p>
<p>car2 = Car()</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>An object is nothing more than an instance of a class, and this is why, many times, it may be called a “class instance” or “class object”.</p>
<p class="notice"><img alt="" class="notice_image" src="img/remember.jpg"/>When you create a new object (a new instance of a class) the process is called “instantiation”.</p>
</div>
<p class="my_basic">Now that you have created (instantiated) two objects, you can assign values to their fields. To do so, use the dot notation. This means you need to write the name of the object, followed by a dot and then the name of the field or method you want to access. The following code fragment creates two objects, car1 and car2, and assigns values to their fields.</p>
<div><p>car1 = Car()</p>
<p>car2 = Car()</p>
<div></div>
<p>car1.brand = "Mazda"</p>
<p>car1.model = "6"</p>
<p>car1.color = "Gray"</p>
<p>car1.licensePlate = "AB1234"</p>
<div></div>
<p>car2.brand = "Ford"</p>
<p>car2.model = "Focus"</p>
<p>car2.color = "Blue"</p>
<p>car2.licensePlate = "XY9876"</p>
<div></div>
<p>print(car1.brand)    #It displays: Mazda</p>
<p>print(car2.brand)    #It displays: Ford</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>In the previous example, car1 and car2 are two instances of the same class. Using car1 and car2 with dot notation allows you to refer to only one instance at a time. If you make any changes to one instance they will not affect the other instance!</p>
</div>
<p class="my_basic">The next code fragment calls the methods turnOff() and accelerate() of the objects car1 and car2 respectively.</p>
<div><p>car1.turnOff()</p>
<p>car2.accelerate()</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/remember.jpg"/>A class is a template that cannot be executed, whereas an object is an instance of a class that can be executed!</p>
<p class="notice"><img alt="" class="notice_image" src="img/remember.jpg"/>One class can be used to create (instantiate) as many objects as you want!</p>
</div>
<h3 id="toc_3">38.3 The Constructor and the Keyword self</h3>
<p class="my_basic">In Python, there is a method that has a special role and is called constructor. The constructor method is executed automatically whenever an instance of a class (an object) is created. Any initialization that you want to do with your object can be done within this method. In Python, the constructor is a method whose name is __init__().</p>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Note that there is a double underscore  at the beginning of the name and another double underscore at the end of the name  __init__().</p>
</div>
<p class="my_basic">Take a look at the following example. The constructor method __init__() is called twice automatically, once when the object p1 is created and once when the object p2 is created, which means that the message “An object was created” is displayed twice.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.3a</div>
<div><p>class Person:</p>
<p>#Define the constructor</p>
<p>def __init__(self):</p>
<div><blockquote><p>print("An object was created")</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>p1 = Person()    #Create object p1</p>
<p>p2 = Person()    #Create object p2</p>
</div>
<p class="my_basic">As you may have noticed, in the formal argument list of the __init__() method, there is an argument named self. In object-oriented programming (OOP) with Python, this argument serves as a reference variable that points to the current object. Take a look at the following example.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.3b</div>
<div><p>class Person:</p>
<p>name = None</p>
<p>age = None</p>
<div></div>
<p>#Define the constructor</p>
<p>def __init__(self):</p>
<div><blockquote><p>print("An object was created")</p></blockquote></div>
<div></div>
<p>def sayInfo(self):</p>
<div><blockquote><p>print("I am", self.name)</p></blockquote></div>
<div><blockquote><p>print("I am", self.age, "years old")</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>person1 = Person()   #Create object person1</p>
<div></div>
<p>#Assign values to its fields</p>
<p>person1.name = "John"</p>
<p>person1.age = 14</p>
<div></div>
<p>person1.sayInfo()   #Call the method sayInfo() of the object person1</p>
</div>
<p class="my_basic">Even though there is no actual argument in the statement person1.sayInfo() where the method is called, a formal argument (the keyword self) does exist in the statement def sayInfo(self) where the method is defined. Obviously, it would be more correct if that call were made as person1.sayInfo(person1). Written this way, it would make better sense! This actual argument person1 would be passed (assigned) to the formal argument self! Yes, this is probably more correct, but always keep in mind that Python is a “write less, do more” language! So there is no need for you to pass the object itself. Python will do it for you!</p>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>If you don't remember what a formal or actual argument is, please re-read <a href="chapter35.html#toc_5">Section 35.5</a>.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Note that when declaring the fields name and age outside of a method (but within the class), you need to write the field name without dot notation. To access the fields, however, from within a method, you must use dot notation (for example, self.name and self.age).</p>
</div>
<p class="my_basic">A question that is probably spinning around in your head right now is “Why is it necessary to refer to these fields name and age within the method sayInfo() as self.name and self.age? Is it really necessary to use the keyword self in front of them?” A simple answer is that there is always a possibility that you could have two extra local variables of the same name (name and age) within the method. So you need a way to distinguish among those local variables and the object's fields. If you are confused, try to understand the following example. There is a field b within the class MyClass and a local variable b within the method myMethod() of the class. The self keyword is used to differentiate between the local variable and the field.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.3c</div>
<div><p>class FooClass:</p>
<p>b = None   #This is a field</p>
<div></div>
<p>def myMethod(self):</p>
<div><blockquote><p>b = "***"    #This is a local variable</p></blockquote></div>
<div><blockquote><p>print(b, self.b, b)</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>x = FooClass()    #Create object x</p>
<div></div>
<p>x.b = "Hello!"   #Assign a value to its field</p>
<p>x.myMethod()     #It displays: *** Hello! ***</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>The keyword self can be used to refer to any member (field or method) of a class from within a method of the class.</p>
</div>
<h3 id="toc_4">38.4 Passing Initial Values to the Constructor</h3>
<p class="my_basic">Any method, even the constructor method __init__(), can have formal arguments within its formal argument list. For example, in the constructor method you can use arguments to pass some initial values to the object during creation. The example that follows creates four objects, each of which represents a Titan<sup><a href="footnotes.html#Endnote_24" id="Link_To_Endnote_24">[24]</a></sup> from Greek mythology.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.4a</div>
<div><p>class Titan:</p>
<p>name = None</p>
<p>gender  = None</p>
<div></div>
<p>#Define the constructor</p>
<p>def __init__(self, n, g):</p>
<div><blockquote><p>self.name = n</p></blockquote></div>
<div><blockquote><p>self.gender = g</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>titan1 = Titan("Cronus", "male")   #Create object titan1</p>
<p>titan2 = Titan("Oceanus", "male")  #Create object titan2</p>
<p>titan3 = Titan("Rhea", "female")   #Create object titan3</p>
<p>titan4 = Titan("Phoebe", "female") #Create object titan4</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Note that, even though there are three formal arguments in the constructor, there are only two actual arguments in the statements that call the constructor. Since Python is a “do more, write less” computer language, there is no need to pass the object itself. Python will do it for you!</p>
</div>
<p class="my_basic">In Python, it is legal to have one field and one local variable (or even a formal argument) with the same name. So, the class Titan can also be written as follows</p>
<div><p>class Titan:</p>
<p>name = None</p>
<p>gender = None</p>
<div></div>
<p>#Define the constructor</p>
<p>def __init__(self, name, gender ):</p>
<div><blockquote><p>self.name = name  #Fields and arguments can have the same name</p></blockquote></div>
<div><blockquote><p>self.gender = gender</p></blockquote></div>
</div>
<p class="my_basic">The variables name and gender are arguments used to pass values to the constructor whereas self.name and self.gender are fields used to store values within the object.</p>
<p class="my_basic">Last but not least, in Python, you can simplify class Titan even more. The example that follows uses a simplified version of the class Titan.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.4b</div>
<div><p>class Titan:</p>
<p>#Define the constructor</p>
<p>def __init__(self, name, gender):</p>
<div><blockquote><p>self.name = name</p></blockquote></div>
<div><blockquote><p>self.gender = gender</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>titan1 = Titan("Cronus", "male")   #Create object titan1</p>
<p>titan2 = Titan("Oceanus", "male")  #Create object titan2</p>
<p>titan3 = Titan("Rhea", "female")   #Create object titan3</p>
<p>titan4 = Titan("Phoebe", "female") #Create object titan4</p>
<div></div>
<p>print(titan1.name, "-", titan1.gender)</p>
<p>print(titan2.name, "-", titan2.gender)</p>
<p>print(titan3.name, "-", titan3.gender)</p>
<p>print(titan4.name, "-", titan4.gender)</p>
</div>
<h3 id="toc_5">38.5 Class Fields vs Instance Fields</h3>
<p class="my_basic">Until this point, what you've learned is that it is not too bad to have fields declared outside of the constructor, as shown in the program that follows.</p>
<div><p>class HistoryEvents:</p>
<p>day = None  #This field is declared outside of the</p>
<div><blockquote><blockquote><blockquote><p>#constructor. It is called "class field"</p></blockquote></blockquote></blockquote></div>
<div></div>
<p>#Define the constructor</p>
<p>def __init__(self):</p>
<div><blockquote><p>print("Object Instantiation")</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>h1 = HistoryEvents()        #Create object h1</p>
<p>h1.day = "4th of July"</p>
<div></div>
<p>h2 = HistoryEvents()        #Create object h2</p>
<p>h2.day = "28th of October"</p>
<div></div>
<p>print(h1.day)</p>
<p>print(h2.day)</p>
</div>
<p class="my_basic">You have also learned that you can rewrite this code and declare the field day inside the constructor, as shown here.</p>
<div><p>class HistoryEvents:</p>
<p>#Define the constructor</p>
<p>def __init__(self, day):</p>
<div><blockquote><p>print("Object Intantiation")</p></blockquote></div>
<div><blockquote><p>self.day = day  #This field is declared inside the </p></blockquote></div>
<div><blockquote><blockquote><blockquote><blockquote><blockquote><p>#constructor. It is called "instance field"</p></blockquote></blockquote></blockquote></blockquote></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>h1 = HistoryEvents("4th of July")     #Create object h1</p>
<p>h2 = HistoryEvents("28th of October") #Create object h2</p>
<div></div>
<p>print(h1.day)</p>
<p>print(h2.day)</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>When a field is declared outside of the constructor, it is called a “class field” but when it is declared inside the constructor, it is called an “instance field”.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>A class field is shared by all instances of the class whereas an instance field is unique to each instance.</p>
</div>
<p class="my_basic">So, which programming style is better? They both seem to be okay! Well, the second one is not just better—you can say that this is the right way to write a class! Why? Because, in some cases, when mutable data structures (such as lists and dictionaries) are used as class fields, they may produce undesirable results. Take a look at the following example.</p>
<div><p>class HistoryEvents:</p>
<p>events = []         #Class field shared by all instances</p>
<div></div>
<p>#Define the constructor</p>
<p>def __init__(self, day):</p>
<div><blockquote><p>self.day = day  #Instance field unique to each instance</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>h1 = HistoryEvents("4th of July")  #Create object h1</p>
<div></div>
<p>#Assign values to the fields of h1</p>
<p>h1.events.append("1776: Declaration of Independence in United States")</p>
<p>h1.events.append("1810: French troops occupy Amsterdam")</p>
<div></div>
<p>h2 = HistoryEvents("28th of October")  #Create object h2</p>
<div></div>
<p>#Assign values to the fields of h2</p>
<p>h2.events.append("969: Byzantine troops occupy Antioch")</p>
<p>h2.events.append("1940: Ohi Day in Greece")</p>
<div></div>
<p>for event in h1.events:</p>
<p>print(event)</p>
</div>
<p class="my_basic">You may expect that the last for-loop displays only the two events of the 4<sup>th</sup> of July. Your thinking is correct, but the output result proves you wrong! The last for-loop displays four events, as shown in Figure 38-3.</p>
<p class="centered_image"><img alt="Image" class="width32" src="img/chapter38-03.png"/></p>
<p class="caption">Figure 38-3 When mutable data types are used as class fields, they may produce undesirable results</p>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>List events is a mutable data structure. In Python, mutable data structures should never be used as a class field, since they produces undesirable results.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>It is advised to utilize as few class fields as possible! Use instance fields instead! The less the number of class fields the better.</p>
</div>
<p class="my_basic">The next example, is the correct version of the previous one.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.5</div>
<div><p>class HistoryEvents:</p>
<p>#Define the constructor</p>
<p>def __init__(self, day):</p>
<div><blockquote><p>self.day = day   #Instance field unique to each instance</p></blockquote></div>
<div><blockquote><p>self.events = [] #Instance field unique to each instance</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>h1 = HistoryEvents("4th of July")     #Create object h1</p>
<div></div>
<p>#Assign values to the fields of h1</p>
<p>h1.events.append("1776: Declaration of Independence in United States")</p>
<p>h1.events.append("1810: French troops occupy Amsterdam")</p>
<div></div>
<p>h2 = HistoryEvents("28th of October") #Create object h2</p>
<div></div>
<p>#Assign values to the fields of h2</p>
<p>h2.events.append("969: Byzantine troops occupy Antioch")</p>
<p>h2.events.append("1940: Ohi Day in Greece")</p>
<div></div>
<p>for event in h1.events:</p>
<p>print(event)</p>
</div>
<h3 id="toc_6">38.6 Getter and Setter Methods vs Properties</h3>
<p class="my_basic">A field is a variable declared directly in a class. The principles of the object-oriented programming, though, state that the data of a class should be hidden and safe from accidental alteration. Think that one day you will probably be writing classes that other programmers will use in their programs. So, you don't want them to know what is inside your classes! The internal operation of your classes should be kept hidden from the outside world. By not exposing a field, you manage to hide the internal implementation of your class. Fields should be kept private to a class and accessed through get and set methods (or through properties).</p>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Generally speaking, programmers should use fields only for data that have private or protected accessibility. In Java, or C# you can set a field as private or protected using special keywords.</p>
</div>
<p class="my_basic">Let's try to understand all of this new stuff through an example. Suppose you write the following class that converts a degrees Fahrenheit temperature into its degrees Celsius equivalent.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.6a</div>
<div><p>class FahrenheitToCelsius:</p>
<p>def __init__(self, value):</p>
<div><blockquote><p>self.temperature = value</p></blockquote></div>
<div></div>
<p>#This method gets the temperature</p>
<p>def getTemperature(self):</p>
<div><blockquote><p>return 5.0 / 9.0 * (self.temperature - 32.0)</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>x = FahrenheitToCelsius(-68)   #Create object x</p>
<p>print(x.getTemperature())</p>
</div>
<p class="my_basic">This class is almost perfect but has a main disadvantage. It doesn't take into consideration that a temperature cannot go below −459.67 degrees Fahrenheit (−273.15 degrees Celsius). This temperature is called absolute zero. So a novice programmer who uses your class and knows absolutely nothing about physics, might pass a value of −500 degrees Fahrenheit to the constructor, as shown in the code fragment that follows</p>
<div><p>x = FahrenheitToCelsius(-500)   #Create object x</p>
<p>print(x.getTemperature())</p>
</div>
<p class="my_basic">Even though the program can run perfectly well and display a value of −295.55 degrees Celsius, unfortunately this temperature cannot exist in the entire universe! So a slightly different version of this class might partially solve the problem.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.6b</div>
<div><p>class FahrenheitToCelsius:</p>
<p>def __init__(self, value):</p>
<div><blockquote><p>self.setTemperature(value)  #Use a method to set the value of the field temperature</p></blockquote></div>
<div></div>
<p>#This method gets the temperature</p>
<p>def getTemperature(self):</p>
<div><blockquote><p>return 5.0 / 9.0 * (self.temperature - 32.0)</p></blockquote></div>
<div></div>
<p>#This method sets the temperature</p>
<p>def setTemperature(self, value):</p>
<div><blockquote><p>if value &gt;= -459.67:</p></blockquote></div>
<div><blockquote><blockquote><p>self.temperature = value</p></blockquote></blockquote></div>
<div><blockquote><p>else:</p></blockquote></div>
<div><blockquote><blockquote><p>raise ValueError("There is no temperature below -459.67")</p></blockquote></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>x = FahrenheitToCelsius(-50)   #Create object x. This calls the constructor which,</p>
<div><blockquote><blockquote><blockquote><blockquote><blockquote><p>#in turn, calls the setter.</p></blockquote></blockquote></blockquote></blockquote></blockquote></div>
<div></div>
<p>print(x.getTemperature())</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>The raise statement forces the program to throw an exception (a runtime error) causing the flow of execution to stop.</p>
</div>
<p class="my_basic">This time, a method named setTemperature() is used to set the value of the field temperature. This is better, but not exactly perfect, because the programmer must be careful and always remember to use this method each time they wish to change the value of the field temperature. The problem is that the value of the field temperature can still be directly changed using its name, as shown in the code fragment that follows.</p>
<div><p>x = FahrenheitToCelsius(-50) #Create object x</p>
<p>print(x.getTemperature())</p>
<div></div>
<p>x.setTemperature(-65)        #This is okay!</p>
<p>print(x.getTemperature())</p>
<div></div>
<p>x.temperature = -500         #Unfortunately, this is still permitted!</p>
<p>print(x.getTemperature())</p>
</div>
<p class="my_basic">This is where a property should be used! A property is a class member that provides a flexible mechanism to read, write, or compute the value of a field that you want to keep private. Properties expose fields, but hide implementation!</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.6c</div>
<div><p>class FahrenheitToCelsius:</p>
<p>def __init__(self, value):</p>
<div><blockquote><p>self.temperature = value  #Property is initialized. This calls the setter</p></blockquote></div>
<div></div>
<p>def getTemperature(self):</p>
<div><blockquote><p>return 5.0 / 9 * (self._temperature - 32)</p></blockquote></div>
<div></div>
<p>def setTemperature(self, value):</p>
<div><blockquote><p>if value &gt;= -459.67:</p></blockquote></div>
<div><blockquote><blockquote><p>self._temperature = value</p></blockquote></blockquote></div>
<div><blockquote><p>else:</p></blockquote></div>
<div><blockquote><blockquote><p>raise ValueError("There is no temperature below -459.67")</p></blockquote></blockquote></div>
<div></div>
<p>#Define a property</p>
<p>temperature = property(getTemperature, setTemperature)</p>
<div></div>
<p>#Main code starts here</p>
<p>x = FahrenheitToCelsius(-50)   #Create object x. This calls the constructor which,</p>
<div><blockquote><blockquote><blockquote><blockquote><blockquote><p>#in turn, calls the setter.</p></blockquote></blockquote></blockquote></blockquote></blockquote></div>
<div></div>
<p>print(x.temperature)     #This calls the getter</p>
<div></div>
<p>x.temperature = -65      #This calls the setter.</p>
<p>print(x.temperature)     #This calls the getter.</p>
<div></div>
<p>x.temperature = -500     #This calls the setter and throws an error</p>
<p>print(x.temperature)</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Note the underscore ( _ ) at the beginning of the field temperature. In Python, an underscore at the beginning of a variable name can be used to denote a “private field”.</p>
</div>
<p class="my_basic">So, what does the statement temperature = property(getTemperature, setTemperature) do anyway?</p>
<p class="my_basic">When a statement tries to access the value of the field temperature, the getTemperature() method is called automatically and similarly, when a statement tries to assign a value to the field temperature the setTemperature() method is called automatically! So, everything seems to be okay now! But is it, really?</p>
<p class="my_basic">One last thing can be done to make things even better! You can completely get rid of the methods getTemperature() and setTemperature() because you don't want to have two ways to access the value of the field temperature, as shown in the code fragment that follows</p>
<div><p>x = FahrenheitToCelsius(0)  #Create object x</p>
<div></div>
<p>#There are still two ways to access the value of the field _temperature</p>
<p>x.setTemperature(-100)  #Use the method</p>
<p>x.temperature = -100    #Use the property</p>
</div>
<p class="my_basic">In order to completely get rid of the methods getTemperature() and setTemperature() you can use some of the decorators that Python supports.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.6d</div>
<div><p>class FahrenheitToCelsius:</p>
<p>def __init__(self, value):</p>
<div><blockquote><p>self.temperature = value    #Property is initialized. This calls the setter</p></blockquote></div>
<div></div>
<p>#Use the decorator @property to define the getter</p>
<p>@property</p>
<p>def temperature(self):</p>
<div><blockquote><p>return 5.0 / 9 * (self._temperature - 32)</p></blockquote></div>
<div></div>
<p>#Use the decorator @field_name.setter to define the setter</p>
<p>@temperature.setter</p>
<p>def temperature(self, value):</p>
<div><blockquote><p>if value &gt;= -459.67:</p></blockquote></div>
<div><blockquote><blockquote><p>self._temperature = value</p></blockquote></blockquote></div>
<div><blockquote><p>else:</p></blockquote></div>
<div><blockquote><blockquote><p>raise ValueError("There is no temperature below -459.67")</p></blockquote></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>x = FahrenheitToCelsius(-50)  #Create object x. This calls the constructor which,</p>
<div><blockquote><blockquote><blockquote><blockquote><blockquote><p>#in turn, calls the setter.</p></blockquote></blockquote></blockquote></blockquote></blockquote></div>
<div></div>
<p>print(x.temperature)          #This calls the getter.</p>
<div></div>
<p>x.temperature = -65           #This calls the setter.</p>
<p>print(x.temperature)          #This calls the getter.</p>
<div></div>
<p>x.temperature = -500          #This calls the setter and throws an error</p>
<p>print(x.temperature)</p>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>Please note that the two methods and the field share the same name, temperature.</p>
<p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>A decorator is a function that takes another function as an argument and returns a new, prettier version of that function. Decorators allow you to change the behavior or extend the functionality of a function without changing the function's body.</p>
</div>
<h4 id="toc_7">Exercise 38.6-1 The Roman Numerals</h4>
<p class="my_exercise_wordings">Roman numerals are shown in the following table.</p>
<div><table border="0" cellpadding="3" cellspacing="0" class="my_table">
<tr>
<th class="center">Number</th>
<th class="center">Roman Numeral</th>
</tr>
<tr>
<td class="center"> 1</td>
<td class="center"> I</td>
</tr>
<tr>
<td class="center"> 2</td>
<td class="center"> II</td>
</tr>
<tr>
<td class="center"> 3</td>
<td class="center"> III</td>
</tr>
<tr>
<td class="center"> 4</td>
<td class="center"> IV</td>
</tr>
<tr>
<td class="center"> 5</td>
<td class="center"> V</td>
</tr>
</table>
</div>
<p class="my_exercise_wordings">Do the following:</p>
<p>i)Write a class named Romans which includes</p>
<p>a)a property named number. It will be used to get and set the value of a private field named _number in integer format. The setter must throw an error when the number is not recognized.</p>
<p>b)a property named roman. It will be used to get and set the value of the private field _number in Roman numeral format. The setter must throw an error when the Roman numeral is not recognized.</p>
<p>ii)Using the class cited above, write a Python program that displays the Roman numeral that corresponds to the value of 3 as well as the number that corresponds to the Roman numeral value of “V”.</p>
<p class="intense_quote">Solution</p>
<p class="my_basic">The getter and setter of the property number are very simple so there is nothing special to explain. The getter and setter of the property roman, however, need some explanation.</p>
<p class="my_basic">The getter of the property roman can be written as follows</p>
<div><p>#Define the getter</p>
<p>@property</p>
<p>def roman(self):</p>
<p>if self._number == 1</p>
<div><blockquote><p>return "I"</p></blockquote></div>
<p>elif self._number == 2</p>
<div><blockquote><p>return "II"</p></blockquote></div>
<p>elif self._number == 3</p>
<div><blockquote><p>return "III"</p></blockquote></div>
<p>elif self._number == 4</p>
<div><blockquote><p>return "IV"</p></blockquote></div>
<p>elif self._number == 5</p>
<div><blockquote><p>return "V"</p></blockquote></div>
</div>
<p class="my_basic">However, since you now know many about dictionaries, you can use a better approach, as shown in the code fragment that follows.</p>
<div><p>#Define the getter</p>
<p>@property</p>
<p>def roman(self):</p>
<p>number2roman = {1: "I", 2: "II", 3: "III", 4: "IV", 5: "V"}</p>
<p>return number2roman[self._number]</p>
</div>
<p class="my_basic">Accordingly, the setter can be as follows</p>
<div><p>#Define the setter</p>
<p>@roman.setter</p>
<p>def roman(self, key):</p>
<div><blockquote><p>roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}</p></blockquote></div>
<div><blockquote><p>if key in roman2number:</p></blockquote></div>
<div><blockquote><blockquote><p>self._number = roman2number[key]</p></blockquote></blockquote></div>
<div><blockquote><p>else:</p></blockquote></div>
<div><blockquote><blockquote><p>raise ValueError("Roman numeral not recognized")</p></blockquote></blockquote></div>
</div>
<p class="my_basic">The final Python program is as follows</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.6-1</div>
<div><p>class Romans:</p>
<p>#Define the getter</p>
<p>@property</p>
<p>def number(self):</p>
<div><blockquote><p>return self._number</p></blockquote></div>
<div></div>
<p>#Define the setter</p>
<p>@number.setter</p>
<p>def number(self, value):</p>
<div><blockquote><p>if value &gt;= 1 and value &lt;= 5:</p></blockquote></div>
<div><blockquote><blockquote><p>self._number = value</p></blockquote></blockquote></div>
<div><blockquote><p>else:</p></blockquote></div>
<div><blockquote><blockquote><p>raise ValueError("Number not recognized")</p></blockquote></blockquote></div>
<div></div>
<p>#Define the getter</p>
<p>@property</p>
<p>def roman(self):</p>
<div><blockquote><p>number2roman = {1: "I", 2: "II", 3: "III", 4: "IV", 5: "V"}</p></blockquote></div>
<div><blockquote><p>return number2roman[self._number]</p></blockquote></div>
<div></div>
<p>#Define the setter</p>
<p>@roman.setter</p>
<p>def roman(self, key):</p>
<div><blockquote><p>roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}</p></blockquote></div>
<div><blockquote><p>if key in roman2number:</p></blockquote></div>
<div><blockquote><blockquote><p>self._number = roman2number[key]</p></blockquote></blockquote></div>
<div><blockquote><p>else:</p></blockquote></div>
<div><blockquote><blockquote><p>raise ValueError("Roman numeral not recognized")</p></blockquote></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>x = Romans()        #Create object x</p>
<div></div>
<p>x.number = 3</p>
<p>print(x.number)     #It displays: 3</p>
<p>print(x.roman)      #It displays: III</p>
<div></div>
<p>x.roman = "V"</p>
<p>print(x.number)     #It displays: 5</p>
<p>print(x.roman)      #It displays: V</p>
</div>
<h3 id="toc_8">38.7 Can a Method Call Another Method of the Same Class?</h3>
<p class="my_basic">In <a href="chapter36.html#toc_2">Section 36.2</a> you learned that a subprogram can call another subprogram. Obviously, the same applies when it comes to methods—a method can call another method of the same class! Methods are nothing more than subprograms after all! So, if you want a method to call another method of the same class you should use the keyword self in front of the method that you want to call (using dot notation) as shown in the example that follows.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.7</div>
<div><p>class JustAClass:</p>
<p>def foo1(self):</p>
<div><blockquote><p>print("foo1 was called")</p></blockquote></div>
<div><blockquote><p>self.foo2()     #Call foo2() using dot notation</p></blockquote></div>
<div></div>
<p>def foo2(self):</p>
<div><blockquote><p>print("foo2 was called")</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>x = JustAClass()</p>
<p>x.foo1()    #Call foo1() which, in turn, will call foo2()</p>
</div>
<h4 id="toc_9">Exercise 38.7-1 Doing Math</h4>
<p class="my_exercise_wordings">Do the following:</p>
<p>i)Write a class named DoingMath which includes</p>
<p>a)a void method named square that accepts a number through its formal argument list and then calculates its square and displays the message “The square of XX is YY”, where XX and YY must be replaced by actual values.</p>
<p>b)a void method named squareRoot that accepts a number through its formal argument list and then calculates its square root and displays the message “The square root of XX is YY” where XX and YY must be replaced by actual values. However, if the number is less than zero, the method must display an error message.</p>
<p>c)a void method named displayResults that accepts a number through its formal argument list and then calls the methods square() and squareRoot() to display the results.</p>
<p>ii)Using the class cited above, write a Python program that prompts the user to enter a number. The program must then display the root and the square root of that number.</p>
<p class="intense_quote">Solution</p>
<p class="my_basic">This exercise is quite simple. The methods square(), squareRoot(), and displayResults() must have a formal argument within their formal argument list so as to accept a passed value. The solution is as follows.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.7-1</div>
<div><p>from math import sqrt</p>
<div></div>
<p>class DoingMath:</p>
<p>def square(self, x):          #Argument x accepts passed value</p>
<div><blockquote><p>print("The square of", x, "is", x ** 2)</p></blockquote></div>
<div></div>
<p>def squareRoot(self, x):     #Argument x accepts passed value</p>
<div><blockquote><p>if x &lt; 0:</p></blockquote></div>
<div><blockquote><blockquote><p>print("Cannot calculate square root")</p></blockquote></blockquote></div>
<div><blockquote><p>else:</p></blockquote></div>
<div><blockquote><blockquote><p>print("Square root of", x, "is", sqrt(x))</p></blockquote></blockquote></div>
<div></div>
<p>def displayResults(self, x): #Argument x accepts passed value</p>
<div><blockquote><p>self.square(x)</p></blockquote></div>
<div><blockquote><p>self.squareRoot(x)</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>dm = DoingMath()</p>
<div></div>
<p>b = float(input("Enter a number: "))</p>
<p>dm.displayResults(b)</p>
</div>
<h3 id="toc_10">38.8 Class Inheritance</h3>
<p class="my_basic">Class inheritance is one of the main concepts of OOP. It lets you write a class using another class as a base. When a class is based on another class, the programmers use to say “it inherits the other class”. The class that is inherited is called the parent class, the base class, or the superclass. The class that does the inheriting is called the child class, the derived class, or the subclass.</p>
<p class="my_basic">A child class automatically inherits all the methods and fields of the parent class.  The best part, however, is that you can add additional characteristics (methods or fields) to the child class. Therefore, you use inheritance when you have to write several classes that share many common characteristics but aren't entirely identical. To do this, you work as follows. First, you write a parent class containing all the common characteristics. Next, you write child classes that inherit all those common characteristics from the parent class. Finally, you add any additional and unique characteristics, specific to each child class. Just as with humans, it's these additional and unique characteristics that set a child apart from its parent, right?</p>
<p class="my_basic">Let's say that you want to write a program that keeps track of the teachers and students in a school. They have some characteristics in common, such as name and age, but they also have specific characteristics such as salary for teachers and final grade for students that are not in common. What you can do here is write a parent class named SchoolMember that contains all those characteristics that both teachers and students have in common. Then you can write two child classes named Teacher and Student, one for teachers and one for students. Both child classes can inherit the class SchoolMember but additional fields, named salary and finalGrade, must be added to the child classes Teacher and Student correspondingly.</p>
<p class="my_basic">The parent class SchoolMember is shown here</p>
<div><p>class SchoolMember:</p>
<p>def __init__(self, name, age):</p>
<div><blockquote><p>self.name = name</p></blockquote></div>
<div><blockquote><p>self.age = age</p></blockquote></div>
<div><blockquote><p>print("A school member was initialized")</p></blockquote></div>
</div>
<p class="my_basic">If you want a class to inherit the class SchoolMember, it must be defined as follows</p>
<div><p>class Name(SchoolMember):</p>
<p>def __init__(self, name, age [, …]):</p>
<div><blockquote><p>#Call the constructor of the class SchoolMember</p></blockquote></div>
<div><blockquote><p>super().__init__(name, age)</p></blockquote></div>
<div><blockquote><div><p>Define additional fields for this class</p></div></blockquote></div>
<div><blockquote><div><p>Additional statement or block of statements</p></div></blockquote></div>
<div></div>
<div><p>Define additional methods and/or properties for this class</p></div>
</div>
<p class="my_basic">where Name is the name of the child class.</p>
<p class="my_basic">So, the class Teacher can be as follows</p>
<div><p>class Teacher(SchoolMember):</p>
<p>def __init__(self, name, age, salary):</p>
<div><blockquote><p>#Call the constructor of the class SchoolMember</p></blockquote></div>
<div><blockquote><p>super().__init__(name, age)</p></blockquote></div>
<div></div>
<div><blockquote><p>self.salary = salary   #This is an additional field for this class</p></blockquote></div>
<div><blockquote><p>print("A teacher was initialized") #This is an additional statement for this constructor</p></blockquote></div>
<div></div>
<p>#This is an additional method for this class</p>
<p>def displayValues(self):</p>
<div><blockquote><p>print("Name:", self.name)</p></blockquote></div>
<div><blockquote><p>print("Age:", self.age)</p></blockquote></div>
<div><blockquote><p>print("Salary:", self.salary)</p></blockquote></div>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>The statement super().__init__(name, age) calls the constructor of the class SchoolMember and initializes the fields name and age of the class Teacher.</p>
</div>
<p class="my_basic">Similarly, the class Student can be as follows</p>
<div><p>class Student(SchoolMember):</p>
<p>def __init__(self, name, age, finalGrade):</p>
<div><blockquote><p>#Call the constructor of the class SchoolMember</p></blockquote></div>
<div><blockquote><p>super().__init__(name, age)</p></blockquote></div>
<div></div>
<div><blockquote><p>self.finalGrade = finalGrade  #This is an additional field for this class</p></blockquote></div>
<div><blockquote><p>print("A student was initialized") #This is an additional statement for this constructor</p></blockquote></div>
<div></div>
<p>#This is an additional method for this class</p>
<p>def displayValues(self):</p>
<div><blockquote><p>print("Name:", self.name)</p></blockquote></div>
<div><blockquote><p>print("Age:", self.age)</p></blockquote></div>
<div><blockquote><p>print("Final grade:", self.finalGrade)</p></blockquote></div>
</div>
<div><p class="notice"><img alt="" class="notice_image" src="img/notice.jpg"/>The statement super().__init__(name, age) calls the constructor of the class SchoolMember and initializes the fields name and age of the class Student.</p>
</div>
<p class="my_basic">The complete Python program is as follows.</p>
<div><img alt="" class="my_exercise_header_image" src="img/my_exercise_header.png"/> file_38.8</div>
<div><p>#Define the class SchoolMember.</p>
<p>class SchoolMember:</p>
<p>def __init__(self, name, age):</p>
<div><blockquote><p>self.name = name</p></blockquote></div>
<div><blockquote><p>self.age = age</p></blockquote></div>
<div><blockquote><p>print("A school member was initialized")</p></blockquote></div>
<div></div>
<p>#Define the class Teacher. It inherits the class SchoolMember.</p>
<p>class Teacher(SchoolMember):</p>
<p>def __init__(self, name, age, salary):</p>
<div><blockquote><p>#Call the constructor of the class SchoolMember</p></blockquote></div>
<div><blockquote><p>super().__init__(name, age)</p></blockquote></div>
<div></div>
<div><blockquote><p>self.salary = salary   #This is an additional field for this class</p></blockquote></div>
<div><blockquote><p>print("A teacher was initialized") #This is an additional statement for this constructor</p></blockquote></div>
<div></div>
<p>#This is an additional method for this class</p>
<p>def displayValues(self):</p>
<div><blockquote><p>print("Name:", self.name)</p></blockquote></div>
<div><blockquote><p>print("Age:", self.age)</p></blockquote></div>
<div><blockquote><p>print("Salary:", self.salary)</p></blockquote></div>
<div></div>
<p>#Define the class Student. It inherits the class SchoolMember.</p>
<p>class Student(SchoolMember):</p>
<p>def __init__(self, name, age, finalGrade):</p>
<div><blockquote><p>#Call the constructor of the class SchoolMember</p></blockquote></div>
<div><blockquote><p>super().__init__(name, age)</p></blockquote></div>
<div></div>
<div><blockquote><p>self.finalGrade = finalGrade  #This is an additional field for this class</p></blockquote></div>
<div><blockquote><p>print("A student was initialized") #This is an additional statement for this constructor</p></blockquote></div>
<div></div>
<p>#This is an additional method for this class</p>
<p>def displayValues(self):</p>
<div><blockquote><p>print("Name:", self.name)</p></blockquote></div>
<div><blockquote><p>print("Age:", self.age)</p></blockquote></div>
<div><blockquote><p>print("Final grade:", self.finalGrade)</p></blockquote></div>
<div></div>
<p>#Main code starts here</p>
<p>teacher1 = Teacher("Mr. John Scott", 43, 35000)</p>
<p>teacher2 = Teacher("Mrs. Ann Carter", 5, 32000)</p>
<div></div>
<p>student1 = Student("Peter Nelson", 14, "A")</p>
<p>student2 = Student("Helen Morgan", 13, "B")</p>
<div></div>
<p>teacher1.displayValues()</p>
<p>teacher2.displayValues()</p>
<p>student1.displayValues()</p>
<p>student2.displayValues()</p>
</div>
<h3 id="toc_11">38.9 Review Questions: True/False</h3>
<p class="my_basic">Choose true or false for each of the following statements.</p>
<p>1)Procedural programming is better than object-oriented programming when it comes to writing large programs.</p>
<p>2)Object-oriented programming focuses on objects.</p>
<p>3)An object combines data and functionality.</p>
<p>4)Object-oriented programming enables you to maintain your code more easily but your code cannot be used easily by others.</p>
<p>5)You can create an object without using a class.</p>
<p>6)The process of creating a new instance of a class is called “installation”.</p>
<p>7)In OOP, you always have to create at least two instances of the same class.</p>
<p>8)The __init__() method is executed when an object is instantiated.</p>
<p>9)When you create two instances of the same class, the __init__() method of the class will be executed twice.</p>
<p>10)When a field is declared outside of the constructor, it is called an “instance field”.</p>
<p>11)A class field is shared by all instances of the class.</p>
<p>12)The principles of the object-oriented programming state that the data of a class should be hidden and safe from accidental alteration.</p>
<p>13)A property is a class member that provides a flexible mechanism to read, write, or compute the value of a field.</p>
<p>14)A property exposes the internal implementation of a class.</p>
<p>15)Class inheritance is one of the main concepts of OOP.</p>
<p>16)When a class is inherited, it is called the “derived class”.</p>
<p>17)A parent class automatically inherits all the methods and fields of the child class.</p>
<h3 id="toc_12">38.10 Review Exercises</h3>
<p class="my_basic">Complete the following exercises.</p>
<p>1)Do the following</p>
<p>i)Write a class named Geometry that includes</p>
<p>a)a method named rectangleArea that accepts the base and the height of a rectangle through its formal argument list and then calculates and returns its area.</p>
<p>b)a method named triangleArea that accepts the base and the height of a triangle through its formal argument list and then calculates and returns its area. It is given that</p>
<p class="ptab5 centered_image KBHeading">.<img alt="Image" class="height4" src="img/chapter10-05.png"/></p>
<p>ii)Using the class cited above, write a Python program that prompts the user to enter the side of a square, the base and the height of a rectangle, and the base and the height of a triangle, and then displays the area for each one of them.</p>
<p>2)Do the following</p>
<p>i)Write a class named Pet which includes</p>
<p>a)a constructor</p>
<p>b)an instance field named kind</p>
<p>c)an instance field named legsNumber</p>
<p>d)a void method named startRunning that displays the message “Pet is running”</p>
<p>e)a void method named stopRunning that displays the message “Pet stopped”</p>
<p>ii)Write a Python program that creates two instances of the class Pet (for example, a dog and a monkey) and then calls some of their methods.</p>
<p>3)Do the following</p>
<p>i)In the class Pet of the previous exercise</p>
<p>a)alter the fields kind and legsNumber to private fields _kind and _legsNumber correspondingly.</p>
<p>b)add a property named kind. It will be used to get and set the value of the field _kind. The setter must throw an error when the field is set to an empty value.</p>
<p>c)add a property named legsNumber. It will be used to get and set the value of the field _legsNumber. The setter must throw an error when the field is set to a negative value.</p>
<p>d)alter the constructor to accept initial values for the properties kind and legsNumber through its formal argument list.</p>
<p>ii)Write a Python program that creates one instance of the class Pets (for example, a dog) and then calls both of its methods. Then try to set erroneous values for properties kind and legsNumber and see what happens.</p>
<p>4)Do the following</p>
<p>i)Write a class named Box that includes</p>
<p>a)a constructor that accepts initial values for three private fields named _width, _length, and _height through its formal argument list.</p>
<p>b)a void method named displayVolume that calculates and displays the volume of a box whose dimensions are _width, _length, and _height. It is given that</p>
<p class="my_basic ptab5 center KBHeading">volume = width × length × height</p>
<p>c)a void method named displayDimensions that displays box's dimensions.</p>
<p>ii)Using the class cited above, write a Python program that prompts the user to enter the dimensions of 30 boxes, and then displays their dimensions and their volume.</p>
<p class="my_basic ptab3 KBHeading">Hint: Create a list of 30 objects of the class Box.</p>
<p>5)In the class Box of the previous exercise add three properties named width, length, and height. They will be used to get and set the values of the fields _width, _length, and _height. The setters must throw an error when the corresponding field is set to a negative value or zero.</p>
<p>6)Do the following</p>
<p>i)Write a class named Cube that includes</p>
<p>a)a constructor that accepts an initial value for a private field named _edge through its formal argument list.</p>
<p>b)a void method named displayVolume that calculates and displays the volume of a cube whose edge length is edge. It is given that</p>
<p class="my_basic ptab5 center KBHeading">volume = edge<sup>3</sup></p>
<p>c)a void method named displayOneSurface that calculates and displays the surface area of one side of a cube whose edge length is _edge.</p>
<p>d)a void method named displayTotalSurface that calculates and displays the total surface area of a cube whose edge length is _edge. It is given that</p>
<p class="my_basic ptab5 center KBHeading">total surface = 6 × edge<sup>2</sup></p>
<p>ii)Using the class cited above, write a Python program that prompts the user to enter the edge length of a cube, and then displays its volume, the surface area of one of its sides, and its total surface area.</p>
<p>7)In the class Cube of the previous exercise add a property named edge. It will be used to get and set the value of the private field _edge. The setter must throw an error when the field is set to a negative value or zero.</p>
<p>8)Do the following</p>
<p>i)Write a class named Circle that includes</p>
<p>a)a constructor and a private field named _radius with an initial value of −1.</p>
<p>b)a property named radius. It will be used to get and set the value of the field _radius. The getter must throw an error when the field has not yet been set, and the setter must throw an error when the field is set to a negative value or zero.</p>
<p>c)a method named getDiameter that calculates and returns the diameter of a circle whose radius is _radius. It is given that</p>
<p class="my_basic ptab5 center KBHeading">diameter = 2 × radius</p>
<p>d)a method named getArea that calculates and returns the area of a circle whose radius is _radius. It is given that</p>
<p class="my_basic ptab5 center KBHeading">area = 3.14 × radius<sup>2</sup></p>
<p>e)a method named getPerimeter that calculates and returns the perimeter of a circle whose radius is _radius. It is given that</p>
<p class="my_basic ptab5 center KBHeading">perimeter = 2 × 3.14 × radius</p>
<p>ii)Write a subprogram named displayMenu that displays the following menu.</p>
<p>1)Enter radius</p>
<p>2)Display radius</p>
<p>3)Display diameter</p>
<p>4)Display area</p>
<p>5)Display perimeter</p>
<p>6)Exit</p>
<p>iii)Using the subprogram and the class cited above, write a Python program that displays the previously mentioned menu and prompts the user to enter a choice (of 1 to 6). If choice 1 is selected, the program must prompt the user to enter a radius. If choice 2 is selected, the program must display the radius entered in choice 1. If choices 3, 4, or 5 are selected, the program must display the diameter, the area, or the perimeter correspondingly of a circle whose radius is equal to the radius entered in choice 1. The process must repeat as many times as the user wishes.</p>
<p>9)Assume that you work in a computer software company that is going to create a word processor application. You are assigned to write a class that will be used to provide information to the user.</p>
<p>i)Write a class named Info that includes</p>
<p>a)a property named userText. It will be used to get and set the value of a private field named _userText. The setter must throw an error when the field is set to an empty value.</p>
<p>b)a  method named getSpacesCount that returns the total number of spaces that property userText contains.</p>
<p>c)a  method named getWordsCount that returns the total number of words that property userText contains.</p>
<p>d)a method named getVowelsCount that returns the total number of vowels that property userText contains.</p>
<p>e)a method named getLettersCount that returns the  total number of characters  (excluding spaces) that property userText contains.</p>
<p>ii)Using the class cited above, write a testing program that prompts the user to enter a text and then displays all available information. Assume that the user enters only space characters or letters (uppercase or lowercase) and the words are separated by a single space character.</p>
<p class="my_basic ptab1 KBHeading">Hint: In a text of three words, there are two spaces, which means that the total number of words is one more than the total number of spaces. Count the total number of spaces, and then you can easily find the total number of words!</p>
<p>10)During the Cold War after World War II, messages were encrypted so that if the enemies intercepted them, they could not decrypt them without the decryption key. A very simple encryption algorithm is alphabetic rotation. The algorithm moves all letters N steps "up" in the alphabet, where N is the encryption key. For example, if the encryption key is 2, you can encrypt a message by replacing the letter A with the letter C, the letter B with the letter D, the letter C with the letter E, and so on.  Do the following:</p>
<p>i)Write a class named EncryptDecrypt that includes</p>
<p>a)a constructor and a private field named _encrDecrKey with an initial value of −1.</p>
<p>b)a property named encrDecrKey. It will be used to get and set the value of the field _encrDecrKey. The getter must throw an error when the field has not yet been set, and the setter must throw an error when the field is not set to a value between 1 and 26.</p>
<p>c)a method named encrypt that accepts a message through its formal argument list and then returns the encrypted message.</p>
<p>d)a method named decrypt that accepts an encrypted message through its formal argument list and then returns the decrypted message.</p>
<p>ii)Write a subprogram named displayMenu that displays the following menu:</p>
<p>1)Enter encryption/decryption key</p>
<p>2)Encrypt a message</p>
<p>3)Decrypt a message</p>
<p>4)Exit</p>
<p>iii)Using the subprogram and the class cited above, write a Python program that displays the menu previously mentioned and then prompts the user to enter a choice (of 1 to 4). If choice 1 is selected, the program must prompt the user to enter an encryption/decryption key. If choice 2 is selected, the program must prompt the user to enter a message and then display the encrypted message. If choice 3 is selected, the program must prompt the user to enter an encrypted message and then display the decrypted message. The process must repeat as many times as the user wishes. Assume that the user enters only lowercase letters or a space for the message.</p>
<p>11)Do the following:</p>
<p>i)Write a parent class named Vehicle that includes</p>
<p>a)a constructor that accepts initial values for three instance fields named numberOfWheels, color, length, width, and height through its formal argument list.</p>
<p>b)two void methods named startEngine and stopEngine that display the messages “The engine started” and “The engine stopped”, correspondingly.</p>
<p>ii)Write a child class named Car that inherits the class Vehicle. Additionally, it includes</p>
<p>a)a constructor with an additional instance field named bootCapacity and an initial value of zero.</p>
<p>b)a void method named turnWindshieldWipersOn that displays the message “The windshield wipers have been turned on!”.</p>
<p>iii)Write a child class named Motorcycle that inherits the class Vehicle. Additionally, it must include</p>
<p>a)a constructor with an additional instance field named hasLuggage and an initial value of False.</p>
<p>b)a void method named doAWheelie that displays the message “I am doing a wheelie!!!”</p>
<p>iv)Using the classes cited above, write a Python program that creates two instances of the class Car and one instance of the class Motorcycle, assigns some values to their fields, and then calls all of their methods.</p>
<p>12)Alter the Python program of <a href="#toc_10">Section 38.8 - Class Inheritance</a> (file_38.8) as follows:</p>
<p>i)In the class SchoolMember, alter the fields name and age to private fields _name and _age correspondingly, and add getter and setter methods for both of them. The setter method of the field _name must throw an error when it is set to an empty value, whereas the setter method of the field _age must throw an error when it is set to a negative value or zero.</p>
<p>ii)In the class Teacher, alter the field salary to private field _salary, and add getter and setter methods for it. The setter method must throw an error when the field is set to a negative value.</p>
<p>iii)In the class Student, alter the field finalGrade to private field _finalGrade, and add getter and setter methods for it. The setter method must throw an error when the field is set to a value other than A, B, C, D, E, or F.</p>
<p>13)Alter the Python program of the previous exercise so that, instead of getter and setter methods, it uses properties.</p>
</div></div></body></html>