<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Gesture Recognition</h1>
                </header>
            
            <article>
                
<p class="mce-root">Since the beginning of time, humans have communicated with each other using gestures, even before there wasn't any formal language. Hand gestures were the primary way of communication, and it is also evident in the ancient sculptures found all across the world that the signs have been a successful way of transferring a huge amount of data in a very efficient way, sometimes, even more efficient than language itself. </p>
<p class="mce-root">Gestures are natural, and they can occur as a reflex to a certain situation. It also happens subconsciously even without our knowing. So, it becomes an ideal way of communication with various devices. However, the question remains, how? </p>
<p class="mce-root">We have used vision processing in our last few chapters, and we can be sure that if we are talking about gestures, then we would surely have to do a lot of programming to identify the gestures in the videos; furthermore, it would require a huge amount of processing power to make it happen as well. Hence, it is out of the question. We can build some basic gesture-recognition system using an array of proximity sensors. However, the range of gestures recognized would be very limited, and the overall ports being used would be multiple fold.</p>
<p class="mce-root">Hence, we need to find a solution that is easy to work with and does not cost more than what it would deliver. </p>
<p>This chapter will be covering the following topics:</p>
<ul>
<li>Electric field sensing</li>
<li>Using the Flick HAT</li>
<li>Gesture recognition-based automation</li>
</ul>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Electric field sensing</h1>
                </header>
            
            <article>
                
<p>Near-field sensing is a very interesting field of sensing. Be prepared for some interesting stuff. If you are feeling a little sleepy, or if you are lacking attention, then get some coffee because the working principle of this system is going to be a little new. </p>
<div class="page">
<p>Whenever there is a charge, there is an associated electrical field that comes along with it. These charges propagate through the space and go around an object. When that happens, the electric field associated with it has a specific characteristic. This characteristic will be the same till the time the environment around it is empty. </p>
<p class="layoutArea">For the gesture-recognition board that we are using, the field that would be sensed around it is only for about a few centimeters, so anything beyond that point can be disregarded. If there is nothing in that vicinity, then we can safely assume that the pattern of electric field being sensed would be unchanged. However, whenever an object such as our hand comes in the vicinity, then these waves are distorted. The distortion is directly linked to the position of the object and its position. With this distortion, we can sense where the finger is, and with constant sensing, we see what kind of motion is being performed. The board in question looks like this: </p>
<div class="layoutArea CDPAlignCenter CDPAlign"><img src="Images/60de2d05-9256-4afd-8463-efd2c9fc4c8c.jpg" style="width:39.08em;height:26.25em;"/></div>
</div>
<p>The central criss-crossed area on the board is the transmitter and on the extreme sides are rectangular structures that are four in number. These are the sensing elements. These sense the pattern of waves in the space. Based on it, they can derive what are the x, y, and z coordinates of the object. This is powered by a chip named MGC 3130. This does all the computation and delivers the raw reading to the user, regarding the coordinates. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the Flick HAT</h1>
                </header>
            
            <article>
                
<p>Flick HAT comes in the form of a shield, which you can simply plug into your Raspberry Pi and start using. However, once you do that, you will not be left with any GPIO pins. Hence, to save ourselves from that problem, we will be connecting it using male-to-female wires. This will give us access to the other GPIO pins and then we can have fun.</p>
<p>So, go ahead and connect it as follows. The following is a pin diagram of the Flick board:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b1f8cc67-60d5-4905-a6b6-2d7449c9c9a5.png" style="width:23.75em;height:33.50em;"/></div>
<p>Thereafter, make the connections as follows: </p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4ee5d33b-2203-475b-a489-8486f1691c4e.png" style="width:31.42em;height:48.33em;"/></div>
<p>Once the connection is done, simply upload this code and see what happens: </p>
<pre>import signal<br/>import flicklib<br/>import time<br/>def message(value):<br/>   print value<br/>@flicklib.move()<br/>def move(x, y, z):<br/>   global xyztxt<br/>   xyztxt = '{:5.3f} {:5.3f} {:5.3f}'.format(x,y,z)<br/>@flicklib.flick()<br/>def flick(start,finish):<br/>   global flicktxt<br/>   flicktxt = 'FLICK-' + start[0].upper() + finish[0].upper()<br/>   message(flicktxt)<br/>def main():<br/>   global xyztxt<br/>   global flicktxt<br/>   xyztxt = ''<br/>   flicktxt = ''<br/>   flickcount = 0<br/>   while True:<br/><br/>  xyztxt = ''<br/>  if len(flicktxt) &gt; 0 and flickcount &lt; 5:<br/>      flickcount += 1<br/>  else:<br/>      flicktxt = ''<br/>      flickcount = 0<br/>main()</pre>
<p>Now once you have uploaded  the code, lets go ahead and understand what this code is actually doing.</p>
<p>We are using a library called  <kbd>import flicklib</kbd> this is provided by the manufacturer of this board. The functions of this library would be used all over in this chapter for communicating with the flick board and getting the data </p>
<pre>def message(value):<br/>    print value</pre>
<p>Here, we are defining a function named <kbd>message(value)</kbd> what this would do is simply print whatever value would be passed on to the function in the argument:</p>
<pre>@flicklib.move()</pre>
<p>This has a special concept of decorators. <span>By definition, a decorator is a function that takes another function and extends the behavior of the latter function</span> without <span>explicitly modifying it. In the preceding line of code, we are declaring that it is a decorator </span><kbd>@</kbd>.</p>
<p>This has a special job: dynamically defines any function in a program. What this means in plain English is that the function defined using this methodology can work differently depending on how the user defines it. </p>
<p>The function <kbd>move()</kbd> will further be complimented by the function, which is getting defined after it. These kind of functions are named nested functions. That is functions inside a function:</p>
<pre>def move(x, y, z):<br/>    global xyztxt<br/>    xyztxt = '{:5.3f} {:5.3f} {:5.3f}'.format(x,y,z)</pre>
<p>Here, we are defining a function named <kbd>move()</kbd>, which has arguments as <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd>. Inside the function, we have defined a global variable named <kbd>xyztxt</kbd>; now, the value of <kbd>xyztxt</kbd> would be in a form of five digit, with a decimal after three places. How did we know that? As you can see, we are using a function named <kbd>format()</kbd>. What this function does is format the values of a given variable according to the way the user has requested it for. We have declared here the value as <kbd>{:5.3f}</kbd>. <kbd>:5</kbd> represents that it would be of five digits, and <kbd>3f</kbd> represents that the decimal places would be after three digits. Hence, the format would be <kbd>xxx.xx</kbd>:</p>
<pre>def flick(start,finish):<br/>    global flicktxt<br/>    flicktxt = 'FLICK-' + start[0].upper() + finish[0].upper()<br/>    message(flicktxt)</pre>
<p>Here, we have defined a function named <kbd>flick(start, finish)</kbd>. It has two arguments: <kbd>start</kbd> and <kbd>finish</kbd>. Using the line <span><kbd>flicktxt = 'FLICK-' + start[0].upper() + finish[0].upper()</kbd>, </span>this is slicing the characters as recognized by the gesture board. If a south–north swipe is detected, then the start will get south and finish is north. Now we are only using the first characters of the words:</p>
<pre>    global xyztxt<br/>    global flicktxt</pre>
<p>We are again defining the variables named <kbd>xyztxt</kbd> and <kbd>flicktxt</kbd> globally. Earlier, what we have done is that we have defined it in the function. Hence, it is important for us to define it in the main program:</p>
<pre>if len(flicktxt) &gt; 0 and flickcount &lt; 5:<br/>            flickcount += 1<br/>else:<br/>            flicktxt = ''<br/>            flickcount = 0</pre>
<p>The <kbd>flicktxt</kbd> variable would get a value corresponding to the gesture  when the gesture is detected. In case there is no gesture then <kbd>flicktxt</kbd> would be left empty. A variable named <kbd>flickcount</kbd> will count how many times its swiped. If the values are out of the range specified then the <kbd>flicktxt</kbd> would be cleared to empty string using the line <kbd>flicktxt = ''</kbd> and <kbd>flickcount</kbd> would be made 0.</p>
<p>The final output of this would be a text given to user providing in which direction the hand is flicked. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Gesture recognition-based automation</h1>
                </header>
            
            <article>
                
<p>Now we have interfaced the connections as per the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ff99fae1-1c6e-46aa-be14-52193face5e3.png"/></div>
<p>Let's go ahead and upload the following code:</p>
<pre>import signal<br/>import flicklib<br/>import time<br/>import RPi.GPIO as GPIO<br/>GIPO.setmode(GPIO.BCM)<br/>GPIO.setup(light, GPIO.OUT)<br/>GPIO.setup(fan,GPIO.OUT)<br/>pwm = GPIO.PWM(fan,100)<br/>def message(value):<br/>   print value<br/>@flicklib.move()<br/>def move(x, y, z):<br/>   global xyztxt<br/>   xyztxt = '{:5.3f} {:5.3f} {:5.3f}'.format(x,y,z)<br/>@flicklib.flick()<br/>def flick(start,finish):<br/>   global flicktxt<br/>   flicktxt = 'FLICK-' + start[0].upper() + finish[0].upper()<br/>   message(flicktxt)<br/>def main():<br/>   global xyztxt<br/>   global flicktxt<br/>   xyztxt = ''<br/>   flicktxt = ''<br/>   flickcount = 0<br/>   dc_inc = 0<br/>   dc_dec = 0<br/>   <br/>while True:<br/>  pwm.start(0)<br/>  xyztxt = ' '<br/>  if len(flicktxt) &gt; 0 and flickcount &lt; 5:<br/>    flickcount += 1<br/>  else:<br/>    flicktxt = ''<br/><br/>flickcount = 0<br/>if flicktxt ==”FLICK-WE”:<br/>  GPIO.output(light,GPIO.LOW)<br/>if flicktxt ==”FLICK-EW”:<br/>  GPIO.output(light,GPIO.HIGH)<br/>if flicktxt ==”FLICK-SN”:<br/>  if dc_inc &lt; 100:<br/>    dc_inc = dc_inc + 10<br/>    pwm.changeDutyCycle(dc_inc)<br/><br/>else:<br/>  Dc_inc = 10<br/>  if flicktxt ==”FLICK-NS”:<br/>    if dc_inc &gt;0:<br/>    dc_dec = dc_dec - 10<br/>    pwm.changeDutyCycle(dc_dec)<br/>main()</pre>
<p>The program is in addition to the program we have done before, as always we have some added functionality of using the data being received by the flick gesture board and using it to switch on or switch off the lights. </p>
<p>Like the previous program, we are taking in the gestures over the board in the form of the directions of swipes, and using a simple condition to switch off the lights, or switch them on. So, let's see what are the additions:</p>
<pre><span>       if flicktxt ==”FLICK-WE”:<br/><br/></span><span>           GPIO.output(light,GPIO.LOW)</span></pre>
<p>The first condition is simple. We are comparing the value of <kbd>flicktxt</kbd> to a given variable, which in our case is <kbd>FLICK-WE</kbd>, wherein <kbd>WE</kbd> stands for <strong>west</strong> to <strong>east</strong>. So when we flick from west to east, or in other words, when we flick from left to right, the lights would be switched off:</p>
<pre><span>       if flicktxt ==”FLICK-EW”:<br/></span><span>            GPIO.output(light,GPIO.HIGH)</span></pre>
<p>As before, we are again taking in a variable named <kbd>FLICK-EW</kbd>, which stands for flick from east to west. What it does is whenever we flick our hand from east to west, or from right to left, the lights will be switched on:</p>
<pre><span>       if flicktxt ==”FLICK-SN”:<br/></span><span>           if dc_inc &lt;= 100:<br/></span><span>               </span><span>dc_inc = dc_inc + 20<br/></span><span>               pwm.changeDutyCycle(dc_inc)</span></pre>
<p>Now we have put a dimmer along with a fan to control the speed of the fan as well; hence, we will have to give it a PWM corresponding to the speed that we want to drive it. Now whenever the user will flick his hand from south to north or from down to up. The condition <kbd>if dc_inc &lt;100</kbd> will check whether the value of the <kbd>dc_inc</kbd> is less than or equal to <kbd>100</kbd> or not. If it is, then it will increment the value of the <kbd>dc_inc</kbd> by <kbd>20</kbd> values. Using the function <kbd>ChangeDutyCycle()</kbd>, we are providing the different duty cycle to the dimmer; hence, changing the overall speed of the fan. Every time you swipe up the value of the fan, it will increase by 20%:</p>
<pre><span>        else:<br/></span><span>            Dc_inc = 10<br/></span><span>            if flicktxt ==”FLICK-NS”:<br/></span><span>            if dc_inc &gt;0:<br/></span><span>   </span><span>         </span><span>dc_dec = dc_dec - 10<br/></span><span>            pwm.changeDutyCycle(dc_dec)</span></pre>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are were able to understand the concept of how gesture recognition works via electric field detection. We also understood how easy it is to use a gesture-controlled board and control the home using gestures. We will cover the machine learning part in the next chapter.</p>


            </article>

            
        </section>
    </div></body></html>