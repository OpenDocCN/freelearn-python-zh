- en: Communication Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed loops, conditional statements, and functions in Python.
    We also discussed interfacing output devices and simple digital input devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following communication interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: UART – serial port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial Peripheral Interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I²C interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be making use of different sensors/electronic components to demonstrate
    writing code in Python for these interfaces. We leave it up to you to pick a component
    of your choice to explore these communication interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: UART - serial port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Universal Asynchronous Receiver/Transmitter** (**UART**), a serial port,
    is a communication interface where the data is transmitted serially in bits from
    a sensor to the host computer. Using a serial port is one of the oldest forms
    of communication protocol. It is used in data logging where microcontrollers collect
    data from sensors and transmit the data via a serial port. There are also sensors
    that transmit data via serial communication as responses to incoming commands.'
  prefs: []
  type: TYPE_NORMAL
- en: We will not go into the theory behind serial port communications (there's plenty
    of theory available on the Web at [https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter)).
    We will be discussing the use of the serial port to interface different sensors
    with the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi Zero's UART port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, UART ports consist of a receiver (*Rx*) and a transmitter (*Tx*)
    pin that receive and transmit data. The Raspberry Pi''s GPIO header comes with
    an UART port. The GPIO pins 14 (the *Tx* pin) and 15 (is the *Rx* pin) serve as
    the UART port for the Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'GPIO pins 14 and 15 are the UART pins (image source: https://www.rs-online.com/designspark/introducing-the-raspberry-pi-b-plus)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Raspberry Pi Zero serial port
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use the serial port to talk to sensors, the serial port login/console
    needs to be disabled. In the **Raspbian** OS image, this is enabled by default
    as it enables easy debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The serial port login can be disabled via `raspi-config`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the terminal and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Select Advanced Options from the main menu of `raspi-config`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_04_002.png)'
  prefs: []
  type: TYPE_IMG
- en: Select Advanced Options from the raspi-config menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the A8 Serial option from the drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_04_003.png)'
  prefs: []
  type: TYPE_IMG
- en: Select A8 Serial from the dropdown
  prefs: []
  type: TYPE_NORMAL
- en: 'Disable serial login:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_04_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Disable serial login
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish the configuration and reboot at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_04_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Save config and reboot
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 - interfacing a carbon dioxide sensor to the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be making use of the K30 carbon dioxide sensor (its documentation is
    available here, [http://co2meters.com/Documentation/Datasheets/DS30-01%20-%20K30.pdf](http://co2meters.com/Documentation/Datasheets/DS30-01%20-%20K30.pdf)).
    It has a range of 0-10,000 ppm, and the sensor provides it carbon dioxide concentration
    readings via serial port as a response to certain commands from the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the connections between the Raspberry Pi and the
    K30 carbon dioxide sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_006.png)'
  prefs: []
  type: TYPE_IMG
- en: K30 carbon dioxide sensor interfaced with the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: The receiver (*Rx*) pin of the sensor is connected to the transmitter (*Tx*-**GPIO
    14 (UART_TXD)**) pin of the Raspberry Pi Zero (the yellow wire in the preceding
    figure). The transmitter (*Tx*) pin of the sensor is connected to the receiver
    (*Rx*-**GPIO 15 (UART_RXD)**) pin of the Raspberry Pi Zero (the green wire in
    the preceding figure).
  prefs: []
  type: TYPE_NORMAL
- en: In order to power the sensor, the G+ pin of the sensor (the red wire in the
    preceding figure) is connected to the **5V** pin of the Raspberry Pi Zero. The
    G0 pin of the sensor is connected to the **GND** pin of the Raspberry Pi Zero
    (black wire in the earlier figure).
  prefs: []
  type: TYPE_NORMAL
- en: Typically, serial port communication is initiated by specifying the baud rate,
    the number of bits in a frame, stop bit, and flow control.
  prefs: []
  type: TYPE_NORMAL
- en: Python code for serial port communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make use of the **pySerial** library ([https://pyserial.readthedocs.io/en/latest/shortintro.html#opening-serial-ports](https://pyserial.readthedocs.io/en/latest/shortintro.html#opening-serial-ports))
    for interfacing the carbon dioxide sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the sensor''s documentation, the sensor output can be read by initiating
    the serial port at a baud rate of 9600, no parity, 8 bits, and 1 stop bit. The
    GPIO serial port is `ttyAMA0`. The first step in interfacing with the sensor is
    initiating serial port communication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the sensor documentation ([http://co2meters.com/Documentation/Other/SenseAirCommGuide.zip](http://co2meters.com/Documentation/Other/SenseAirCommGuide.zip)),
    the sensor responds to the following command for the carbon dioxide concentration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_04_007.png)'
  prefs: []
  type: TYPE_IMG
- en: Command to read carbon dioxide concentration from the sensor-borrowed from the
    sensor datasheet
  prefs: []
  type: TYPE_NORMAL
- en: 'The command can be transmitted to the sensor as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The sensor responds with a 7-byte response, which can be read as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The sensor''s response is in the following format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_04_008.png)'
  prefs: []
  type: TYPE_IMG
- en: Carbon dioxide sensor response
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the datasheet, the sensor data size is 2 bytes. Each byte can
    be used to store a value of 0 and 255\. Two bytes can be used to store values
    up to 65,535 (255 * 255). The carbon dioxide concentration could be calculated
    from the message as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Put it all together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save the code to a file and try executing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I2C communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inter-Integrated Circuit** (**I²C**) communication is a type of serial communication
    that allows interfacing multiple sensors to the computer. I²C communication consists
    of two wires of a clock and a data line. The Raspberry Pi Zero''s clock and data
    pins for I²C communication are **GPIO 3** (**SCL**) and **GPIO 2** (**SDA**),
    respectively. In order to communicate with multiple sensors over the same bus,
    sensors/actuators that communicate via I²C protocol are usually addressed by their
    7-bit address. It is possible to have two or more Raspberry Pi boards talking
    to the same sensor on the same I²C bus. This enables building a sensor network
    around the Raspberry Pi.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The I²C communication lines are open drain lines; hence, they are pulled up
    using resistors, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_009.png)'
  prefs: []
  type: TYPE_IMG
- en: I²C setup
  prefs: []
  type: TYPE_NORMAL
- en: Let's review an example of I²C communication using an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 - PiGlow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **PiGlow** is a piece of add-on hardware for the Raspberry Pi that consists
    of 18 LEDs interfaced with the **SN3218** chip. This chip permits controlling
    the LEDs via the I²C interface. The chip's 7-bit address is `0x54`.
  prefs: []
  type: TYPE_NORMAL
- en: To interface the add-on hardware, the **SCL** pin is connected to **GPIO 3**
    and **SDA** pin to **GPIO 2**; the ground pins and the power supply pins are connected
    to the counterparts of the add-on hardware, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PiGlow comes with a library that comes which abstracts the I²C communication:
    [https://github.com/pimoroni/piglow](https://github.com/pimoroni/piglow).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the library is a wrapper around the I²C interface for the library,
    we recommend reading through the code to understand the internal mechanism to
    operate the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PiGlow stacked on top of the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Installing libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PiGlow library may be installed by running the following from the command-line
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the completion of installation, switch to the example folder (`/home/pi/Pimoroni/piglow`)
    and run one of the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It should run *blinky* light effects as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Blinky lights on the PiGlow
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there are libraries to talk to real-time clocks, LCD displays, and
    so on using I²C communication. If you are interested in writing your own interface
    that provides the nitty-gritty detail of I²C communication with sensors/output
    devices, check out this book's accompanying website for some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3 - Sensorian add-on hardware for the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Sensorian** is an add-on hardware designed for the Raspberry Pi. This
    add-on hardware comes with different types of sensors, including a light sensor,
    barometer, accelerometer, LCD display interface, flash memory, capacitive touch
    sensors, and a real-time clock.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sensors on this add-on hardware is sufficient to learn using all the communication
    interfaces discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sensorian hardware stacked on top of the Raspberry Pi Zero
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss an example where we will measure the ambient
    light levels using a Raspberry Pi Zero via the I²C interface. The sensor on the
    add-on hardware board is the **APDS-9300** sensor ([www.avagotech.com/docs/AV02-1077EN](http://www.avagotech.com/docs/AV02-1077EN)).
  prefs: []
  type: TYPE_NORMAL
- en: I2C drivers for the lux sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The drivers are available from the GitHub repository for the Sensorian hardware
    ([https://github.com/sensorian/sensorian-firmware.git](https://github.com/sensorian/sensorian-firmware.git)).
    Let''s clone the repository from the command-line terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make use of the drivers (which is available in the ` ~/sensorian-firmware/Drivers_Python/APDS-9300`
    folder) to read the values from the two ADC channels of the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the ADC values available from both the channel, the ambient light value
    can be calculated by the driver using the following formula (retrieved from the
    sensor datasheet):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_013.png)'
  prefs: []
  type: TYPE_IMG
- en: Ambient light levels calculated using the ADC values
  prefs: []
  type: TYPE_NORMAL
- en: This calculation is performed by the attribute `getLuxLevel`. Under normal lighting
    conditions, the ambient light level (measured in lux) was around `2`. The measured
    output was `0` when we covered the lux sensor with the palm. This sensor could
    be used to measure ambient light and adjust the room lighting accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed measuring ambient light levels using the lux sensor. How do we
    make use of the lux output (ambient light levels) to control the room lighting?
  prefs: []
  type: TYPE_NORMAL
- en: The SPI interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another type of serial communication interface named the **Serial Peripheral
    Interface** (**SPI**). This interface has to be enabled via `raspi-config` (this
    is similar to enabling serial port interface earlier in this chapter). Using the
    SPI interface is similar to that of I²C interface and the serial port.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, an SPI interface consists of a clock line, data-in, data-out, and
    a **Slave Select** (**SS**) line. Unlike I²C communication (where we could connect
    multiple masters), there can be only one master (the Raspberry Pi Zero), but multiple
    slaves on the same bus. The **SS** pin enables selecting a specific sensor that
    the Raspberry Pi Zero is reading/writing data when there are multiple sensors
    connected to the same bus.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4 - writing to external memory chip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's review an example where we write to a flash memory chip on the Sensorian
    add-on hardware via the SPI interface. The drivers for the SPI interface and the
    memory chip are available from the same GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already have the drivers downloaded, let''s review an example available
    with drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s initialize and write the message `hello` to the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to read the data we just wrote to the external memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code sample is available for download with this chapter (`memory_test.py`).
  prefs: []
  type: TYPE_NORMAL
- en: We were able to demonstrate using the SPI to read/write to an external memory
    chip.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge to the reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the figure here, there is an LED strip ([https://www.adafruit.com/product/306](https://www.adafruit.com/product/306))
    interfaced to the SPI interface of the Raspberry Pi add on hardware using the
    Adafruit Cobbler ([https://www.adafruit.com/product/914](https://www.adafruit.com/product/914)).
    We are providing a clue on how to interface the LED strip to the Raspberry Pi
    Zero. We would like to see if you are able to find a solution to interface the
    LED strip by yourself. Refer to this book's website for the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_014.png)'
  prefs: []
  type: TYPE_IMG
- en: LED strip interfaced with the Adafruit Cobbler for the Raspberry Pi Zero
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed different communication interfaces that are
    available on the Raspberry Pi Zero. These interfaces include I²C, SPI, and UART.
    We will be making use of these interfaces in our final projects. We discussed
    these interfaces using a carbon dioxide sensor, LED driver, and a sensor platform.
    In the next chapter, we will discuss object-oriented programming and its distinct
    advantages. We will discuss the need for object-oriented programming using an
    example. Object-oriented programming can be especially helpful in scenarios where
    you have to write your own drivers to control a component of your robot or write
    an interface library for a sensor.
  prefs: []
  type: TYPE_NORMAL
