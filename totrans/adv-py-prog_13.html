<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer164">
			<h1 id="_idParaDest-210"><em class="italic"><a id="_idTextAnchor195"/>Chapter 11</em>: Building Communication Channels with asyncio</h1>
			<p>Communication channels are a big part of applied concurrency in the field of computer science. In this chapter, we will cover the fundamental theories of transports, which are classes provided by the <strong class="source-inline">asyncio</strong> module to abstract various forms of communication channels. We will also cover an implementation of a simple echoing server-client logic in Python, to further illustrate the use of <strong class="source-inline">asyncio</strong> and concurrency in communication systems. This chapter will help us frame what we have learned so far about asynchronous programming in the practical context of communication channels, and the code we work with will serve as a base for more complex applications.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>The ecosystem of communication channels</li>
				<li>Getting started with Python and Telnet</li>
				<li>Client-side communication with <strong class="source-inline">aiohttp</strong></li>
			</ul>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor196"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: </p>
			<p><a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter11">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter11</a></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor197"/>The ecosystem of communication channels</h1>
			<p>The term <em class="italic">communication channel</em> is used to denote both the physical wiring connection <a id="_idIndexMarker886"/>between different systems and the logical communication of data that facilitates computer networks. In this chapter, we will only be concerned with the latter, as it is a problem that is related to computing and is more germane to the idea of asynchronous programming.</p>
			<p>First, in this section, we will be discussing the general structure of a communication channel, and two <a id="_idIndexMarker887"/>specific elements in that structure that are particularly relevant to asynchronous programming. The first element is communication protocol layers.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor198"/>Communication protocol layers</h2>
			<p>Most data transmission processes that are done through communication channels are facilitated <a id="_idIndexMarker888"/>in the form of the <strong class="bold">Open Systems Interconnection</strong> (<strong class="bold">OSI</strong>) model protocol layers. The OSI model lays out <a id="_idIndexMarker889"/>the major layers and topics in an intersystem communication process.</p>
			<p>The following diagram shows the general structure of the OSI model:</p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/Figure_11.1_B17499.jpg" alt="Figure 11.1 – OSI model structure " width="1191" height="1191"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – OSI model structure</p>
			<p>As indicated, there are seven main layers of communication in a data transmission process, with <a id="_idIndexMarker890"/>varying degrees of <a id="_idIndexMarker891"/>computing level and specificity. We will not be going into the details of the purposes and specific functions of each layer, but it is still important that you understand the general ideas behind the media and host layers.</p>
			<p>The three bottom layers contain low-level operations that interact with the underlying process of the communication channel. The operations in the physical and data link layers include coding schemes, access schemes, low-level error detection and correction, bit synchronization, and so on. These operations are used to implement and specify the logic of processing and preparing data before transferring it. The network layer, on the other hand, handles forwarding packets of data from one system (for example, the server) to another (for example, the client) in a computer network, by determining the address of the recipient and which path of data transfer to take.</p>
			<p>On the other hand, the top layers deal with high-level data communication and manipulation. Among these layers, we will be focusing on the transport layer, as it is directly utilized by the <strong class="source-inline">asyncio</strong> module in the implementation of communication channels. This layer is often viewed as the conceptual transition between the media layers and the host layers (for example, the client and the server), responsible for sending data <a id="_idIndexMarker892"/>along with <strong class="bold">end-to-end</strong> (<strong class="bold">E2E</strong>) connections between different systems. Additionally, because packets of data (prepared by the network layer) might be lost or corrupted during transmission processes due to network errors, the transport layer is also in charge of detecting these errors via methods in error detection code.</p>
			<p>The other host <a id="_idIndexMarker893"/>layers implement <a id="_idIndexMarker894"/>mechanisms for handling, interpreting, and providing the data sent from another system. After receiving data from the transport layer, the session layer handles the authentication, authorization, and session restoration processes. The presentation layer then translates the same data and reorganizes it into an interpretable representation. Finally, the application layer displays that data in a user-friendly format. With that in mind, let's see how we can apply the framework of asynchronous programming to communication channels.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor199"/>Asynchronous programming for communication channels</h2>
			<p>The <a id="_idIndexMarker895"/>asynchronous programming <a id="_idIndexMarker896"/>model nicely complements the process of facilitating communication channels. For instance, in <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) communication, the server can asynchronously <a id="_idIndexMarker897"/>handle multiple clients at the same time: while it is waiting for a specific client to make an HTTP request, it can switch to another client and process that client's request. Similarly, if a client needs to make HTTP requests to multiple servers and must wait for large responses from some servers, it can consider the more lightweight responses, which have already been processed and were sent back to the client first. The following diagram shows an example of how servers and clients interact with each other asynchronously in HTTP requests:</p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/Figure_11.2_B17499.jpg" alt="Figure 11.2 – Asynchronous, interleaved HTTP requests " width="831" height="741"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Asynchronous, interleaved HTTP requests</p>
			<p>Overall, asynchronous <a id="_idIndexMarker898"/>programming <a id="_idIndexMarker899"/>is an attractive framework for building communication channels. As such, we will see how this can be done with the <strong class="source-inline">asyncio</strong> module.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor200"/>Transports and protocols in asyncio</h2>
			<p>The <strong class="source-inline">asyncio</strong> module provides several different transport classes. In essence, these classes <a id="_idIndexMarker900"/>are implementations of the functionalities of the transport layer that were discussed in the preceding <a id="_idIndexMarker901"/>section. As the transport <a id="_idIndexMarker902"/>layer plays an integral role in communication channels, the transport <a id="_idIndexMarker903"/>classes give <strong class="source-inline">asyncio</strong> (and, consequently, developers) more control over the process of implementing our own communication channels.</p>
			<p>The <strong class="source-inline">asyncio</strong> module combines the abstract of transports with the implementation of an asynchronous program. Specifically, even though transports are the central elements of communication channels, in order to utilize the transport classes and other relevant communication channel tools, we need to initiate and call an event loop, which is an instance of the <strong class="source-inline">asyncio.AbstractEventLoop</strong> class. The event loop itself will then create transports and manage the low-level communication procedures.</p>
			<p>It is important to note that a <strong class="source-inline">transport</strong> object in an established communication channel in <strong class="source-inline">asyncio</strong> is always associated with an instance of the <strong class="source-inline">asyncio.Protocol</strong> class. As the name suggests, the <strong class="source-inline">Protocol</strong> class specifies the underlying protocols that the communication channels use; for each connection made with another system, a new protocol <a id="_idIndexMarker904"/>object from this class <a id="_idIndexMarker905"/>will be created. While working closely with a <strong class="source-inline">transport</strong> object, a protocol object can call various methods <a id="_idIndexMarker906"/>from the <strong class="source-inline">transport</strong> object; this is where we can <a id="_idIndexMarker907"/>implement the specific inner workings of a communication channel.</p>
			<p>For this reason, we generally need to focus on the implementation of an <strong class="source-inline">asyncio.Protocol</strong> subclass and its methods while building a connection channel. In other words, we use <strong class="source-inline">asyncio.Protocol</strong> as a parent class to derive a subclass that meets the needs of our communication channel. To do this, we overwrite the following methods from the <strong class="source-inline">asyncio.Protocol</strong> base class in our own custom protocol subclass:</p>
			<ul>
				<li><strong class="source-inline">Protocol.connection_made(transport)</strong>: This method is automatically called whenever a connection from another system is made. The <strong class="source-inline">transport</strong> argument holds the <strong class="source-inline">transport</strong> object that is associated with the connection. Again, each <strong class="source-inline">transport</strong> object needs to be paired with a protocol; we generally store this <strong class="source-inline">transport</strong> object as an attribute of this specific protocol object in the <strong class="source-inline">connection_made()</strong> method.</li>
				<li><strong class="source-inline">Protocol.data_received(data)</strong>: This method is automatically called whenever the one system that we are connected to sends its data. Note that the <strong class="source-inline">data</strong> argument, which holds the sent information, is usually represented in bytes, so the <strong class="source-inline">encode()</strong> function of Python should be used before <strong class="source-inline">data</strong> is processed further.</li>
			</ul>
			<p>Next, let's consider other important methods from the transport classes from <strong class="source-inline">asyncio</strong>. All transport classes inherit from a parent transport class, called <strong class="source-inline">asyncio.BaseTransport</strong>, for which <a id="_idIndexMarker908"/>we have the following common methods:</p>
			<ul>
				<li><strong class="source-inline">BaseTransport.get_extra_info()</strong>: This method returns, as the name suggests, additional channel-specific information for the calling <strong class="source-inline">transport</strong> object. The result can include information regarding the socket, the pipe, and the subprocess associated with that transport. Later in this chapter, we will be calling <strong class="source-inline">BaseTransport.get_extra_info('peername')</strong> to obtain the remote address from which the transport traveled.</li>
				<li><strong class="source-inline">BaseTransport.close()</strong>: This method is used to close the calling <strong class="source-inline">transport</strong> object, after which the connections between different systems will be stopped. The corresponding protocol of the transport will automatically call its <strong class="source-inline">connection_lost()</strong> method.</li>
			</ul>
			<p>Out of <a id="_idIndexMarker909"/>the many implementations of transport classes, we will focus on the <strong class="source-inline">asyncio.WriteTransport</strong> class, which <a id="_idIndexMarker910"/>again inherits the methods from the <strong class="source-inline">BaseTransport</strong> class and additionally implements other methods <a id="_idIndexMarker911"/>that are used to facilitate write-only transport <a id="_idIndexMarker912"/>functionalities. Here, we will be using the <strong class="source-inline">WriteTransport.write()</strong> method, which will write the data that we would like to send to the other system that we communicate with via the <strong class="source-inline">transport</strong> object. As a part of the <strong class="source-inline">asyncio</strong> module, this method is not a blocking function; instead, it buffers and sends out the written data in an asynchronous way.</p>
			<p>Before we dive into a working example in Python, let's briefly discuss the big picture of what we are trying to accomplish—or, in other words, the general structure of our program.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor201"/>The big picture of asyncio's server client</h2>
			<p>As mentioned <a id="_idIndexMarker913"/>earlier, we need to implement <a id="_idIndexMarker914"/>a subclass of <strong class="source-inline">asyncio.Protocol</strong> to specify the underlying organization of our communication channel. There is an event loop at the heart of each asynchronous program, so we also need to create a server outside of the context of the protocol class and initiate that server inside of the event loop of our program. This process will set up the asynchronous architecture of our entire server and can be done via the <strong class="source-inline">asyncio.create_server()</strong> method, which we will look at in our upcoming example.</p>
			<p>Finally, we will run the event loop of our asynchronous program forever by using the <strong class="source-inline">AbstractEventLoop.run_forever()</strong> method. Similar to an actual, real-life server, we would like <a id="_idIndexMarker915"/>to keep our server running <a id="_idIndexMarker916"/>until it encounters a problem, in which case we will close the server gracefully. The following diagram illustrates this whole process:</p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/Figure_11.3_B17499.jpg" alt="Figure 11.3 – Asynchronous program structure in communication channels " width="1193" height="484"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Asynchronous program structure in communication channels</p>
			<p>And with that, we are ready to start building our application, starting from the next section.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor202"/>Getting started with Python and Telnet</h1>
			<p>Let's look <a id="_idIndexMarker917"/>at a specific Python example that implements a server that <a id="_idIndexMarker918"/>facilitates asynchronous communication.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor203"/>Starting a server</h2>
			<p>Let's <a id="_idIndexMarker919"/>look at the <strong class="source-inline">EchoServerClientProtocol</strong> class, as follows:</p>
			<p class="source-code">import asyncio</p>
			<p class="source-code">class EchoServerClientProtocol(asyncio.Protocol):</p>
			<p class="source-code">    def connection_made(self, transport):</p>
			<p class="source-code">        peername = transport.get_extra_info('peername')</p>
			<p class="source-code">        print('Connection from {}'.format(peername))</p>
			<p class="source-code">        self.transport = transport</p>
			<p class="source-code">    def data_received(self, data):</p>
			<p class="source-code">        message = data.decode()</p>
			<p class="source-code">        print('Data received: {!r}'.format(message))</p>
			<p>Here, our <strong class="source-inline">EchoServerClientProtocol</strong> class is a subclass of <strong class="source-inline">asyncio.Protocol</strong>. As we discussed earlier, inside of this class, we need to implement the <strong class="source-inline">connection_made(transport)</strong> and <strong class="source-inline">data_received(data)</strong> methods. In the <strong class="source-inline">connection_made()</strong> method, we simply obtain the address of the connected system via the <strong class="source-inline">get_extra_info()</strong> method (with the <strong class="source-inline">'peername'</strong> argument), print a message out with that information, and finally store the <strong class="source-inline">transport</strong> object in an attribute of the class. To print <a id="_idIndexMarker920"/>out a similar message in the <strong class="source-inline">data_received()</strong> method, we again use the <strong class="source-inline">decode()</strong> method to obtain a string object from byte data.</p>
			<p>Let's move on to the main program of our script, as follows:</p>
			<p class="source-code">loop = asyncio.get_event_loop()</p>
			<p class="source-code">coro = loop.create_server(EchoServerClientProtocol, \</p>
			<p class="source-code">  '127.0.0.1', 8888)</p>
			<p class="source-code">server = loop.run_until_complete(coro)</p>
			<p class="source-code"># Serve requests until Ctrl+C is pressed</p>
			<p class="source-code">print('Serving on {}'.format(server.sockets[0] \</p>
			<p class="source-code">  .getsockname()))</p>
			<p class="source-code">try:</p>
			<p class="source-code">    loop.run_forever()</p>
			<p class="source-code">except KeyboardInterrupt:</p>
			<p class="source-code">    pass</p>
			<p class="source-code"># Close the server</p>
			<p class="source-code">server.close()</p>
			<p class="source-code">loop.run_until_complete(server.wait_closed())</p>
			<p class="source-code">loop.close()</p>
			<p>We are using the familiar <strong class="source-inline">asyncio.get_event_loop()</strong> function to create an event loop for our <a id="_idIndexMarker921"/>asynchronous program. Then, we create a server for our communication by having that event loop call the <strong class="source-inline">create_server()</strong> method; this method takes in a subclass from the <strong class="source-inline">asyncio.Protocol</strong> class, an address for our server (in this case, it is our localhost: <strong class="source-inline">127.0.0.1</strong>), and finally, a port for that address (typically, <strong class="source-inline">8888</strong>).</p>
			<p>Note that this method does not create a server itself; it only initiates the process of creating a server asynchronously and returns a coroutine that will finish the process. For this reason, we need to store the returned coroutine from the method in a variable (<strong class="source-inline">coro</strong>, in our case) and have our event loop run that coroutine. After printing out a message using the <strong class="source-inline">sockets</strong> attribute of our server object, we will run the event loop forever, to keep the server running, except for the case of a <strong class="source-inline">KeyboardInterrupt</strong> exception being invoked.</p>
			<p>Finally, at the end of our program, we will handle the house-cleaning portion of the script, which is closing the server gracefully. This is typically done by having the server object call the <strong class="source-inline">close()</strong> method (to initiate the closing process of the server) and using the event loop to run the <strong class="source-inline">wait_closed()</strong> method on the server object, to make sure that the server is properly closed. Finally, we close the event loop.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor204"/>Installing Telnet</h2>
			<p>Before we can run our sample Python program, we have to install the Telnet program to correctly <a id="_idIndexMarker922"/>simulate a connection channel between a client and a server. Telnet is a program that provides Terminal commands that facilitate protocols for bidirectional, interactive, text-oriented communication. If you already have Telnet working on your computer, simply skip to the next section; otherwise, find the information appropriate to your system in this section.</p>
			<p>In Windows systems, Telnet is already installed, but might not be enabled. To enable it, you can either utilize the <strong class="bold">Turn Windows features on or off</strong> window and make sure that the <strong class="bold">Telnet Client</strong> box is checked, or run the following command:</p>
			<p class="source-code">dism /online /Enable-Feature /FeatureName:TelnetClient</p>
			<p>Linux systems typically come with Telnet preinstalled, so if you own a Linux system, simply move on to the next section.</p>
			<p>In macOS systems, it is possible that Telnet has already been installed on your computer. If not, you will need to do it via the Homebrew package management software, as follows:</p>
			<p class="source-code">brew install telnet</p>
			<p>Note that macOS systems do have <a id="_idIndexMarker923"/>a preinstalled alternative to Telnet, called Netcat. If you do not want Telnet installed on your macOS computer, simply use the <strong class="source-inline">nc</strong> command instead of <strong class="source-inline">telnet</strong> in the following examples, and you will achieve the same effect.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor205"/>Simulating a connection channel</h2>
			<p>There are <a id="_idIndexMarker924"/>multiple steps to running the following server example. First, we need to run the script to start the server, from which you will obtain the following output:</p>
			<p class="source-code">&gt; python example1.py</p>
			<p class="source-code">Serving on ('127.0.0.1', 8888)</p>
			<p>Notice that the program will run until you invoke the <em class="italic">Ctrl</em> + <em class="italic">C</em> key combination. With the program still running in one Terminal (this is our server Terminal), open another Terminal and connect to the server (<strong class="source-inline">127.0.0.1</strong>) at the specified port (<strong class="source-inline">8888</strong>), as illustrated here; this will serve as our client Terminal:</p>
			<p class="source-code">telnet 127.0.0.1 8888</p>
			<p>Now, you will see some changes in both the server and the client Terminals. Most likely, your client Terminal will have the following output:</p>
			<p class="source-code">&gt; telnet 127.0.0.1 8888</p>
			<p class="source-code">Trying 127.0.0.1...</p>
			<p class="source-code">Connected to localhost.</p>
			<p>This is <a id="_idIndexMarker925"/>from the interface of the Telnet program, which indicates that we have successfully connected to our local server. The more interesting output is on our server Terminal, which will be similar to the following:</p>
			<p class="source-code">&gt; python example1.py</p>
			<p class="source-code">Serving on ('127.0.0.1', 8888)</p>
			<p class="source-code">Connection from ('127.0.0.1', 60332)</p>
			<p>Recall that this is an information message that we implemented in our <strong class="source-inline">EchoServerClientProtocol</strong> class—specifically, in the <strong class="source-inline">connection_made()</strong> method. Again, as a connection between the server and a new client is made, this method will be called automatically to initiate the communication. From the output message, we know that the client is making their requests from port <strong class="source-inline">60332</strong> of server <strong class="source-inline">127.0.0.1</strong> (which is the same as the running server, since they are both local).</p>
			<p>Another feature that we implemented in the <strong class="source-inline">EchoServerClientProtocol</strong> class was in the <strong class="source-inline">data_received()</strong> method. Specifically, we print the decoded data that is sent from the client. To simulate this type of communication, simply type a message in your client Terminal and press the <em class="italic">Return</em> (<em class="italic">Enter</em>, for Windows) key. You will not see any changes in the client Terminal output, but the server Terminal should print out a message, as specified in the <strong class="source-inline">data_received()</strong> method of our protocol class.</p>
			<p>For example, this is my server Terminal output when I send the message <strong class="source-inline">Hello, World!</strong> from my client Terminal:</p>
			<p class="source-code">&gt; python example1.py</p>
			<p class="source-code">Serving on ('127.0.0.1', 8888)</p>
			<p class="source-code">Connection from ('127.0.0.1', 60332)</p>
			<p class="source-code">Data received: 'Hello, World!\r\n'</p>
			<p>The <strong class="source-inline">\r</strong> and <strong class="source-inline">\n</strong> characters are simply the return characters included in the message string. With our current protocol, you can send multiple messages to the server and can even have multiple clients send messages to the server. To implement this, simply open another <a id="_idIndexMarker926"/>Terminal and connect to the local server again. You will see from your server Terminal that a different client (from a different port) has made a connection to the server, while the original communication of our server with the old client is still being maintained. This is another result achieved from asynchronous programming, allowing multiple clients to communicate with the same server seamlessly, without using threading or multiprocessing.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor206"/>Sending messages back to clients</h2>
			<p>So, in our current example, we can have our asynchronous server receive, read, and process <a id="_idIndexMarker927"/>messages from clients. However, for our communication channel to be useful, we would also like to send messages from the server to the clients. In this section, we will update our server to an echo server, which, by definition, will send all data that it receives from a specific client back to the client.</p>
			<p>To do this, we will be using the <strong class="source-inline">write()</strong> method from the <strong class="source-inline">asyncio.WriteTransport</strong> class. Consider the <strong class="source-inline">data_received()</strong> method of the <strong class="source-inline">EchoServerClientProtocol</strong> class, as follows:</p>
			<p class="source-code">import asyncio</p>
			<p class="source-code">class EchoServerClientProtocol(asyncio.Protocol):</p>
			<p class="source-code">    def connection_made(self, transport):</p>
			<p class="source-code">        peername = transport.get_extra_info('peername')</p>
			<p class="source-code">        print('Connection from {}'.format(peername))</p>
			<p class="source-code">        self.transport = transport</p>
			<p class="source-code">    def data_received(self, data):</p>
			<p class="source-code">        message = data.decode()</p>
			<p class="source-code">        print('Data received: {!r}'.format(message))</p>
			<p class="source-code">        self.transport.write(('Echoed back: {}'.format \</p>
			<p class="source-code">          (message)).encode())</p>
			<p class="source-code">loop = asyncio.get_event_loop()</p>
			<p class="source-code">coro = loop.create_server(EchoServerClientProtocol, \</p>
			<p class="source-code">  '127.0.0.1', 8888)</p>
			<p class="source-code">server = loop.run_until_complete(coro)</p>
			<p class="source-code"># Serve requests until Ctrl+C is pressed</p>
			<p class="source-code">print('Serving on {}'.format(server.sockets[0] \</p>
			<p class="source-code">  .getsockname()))</p>
			<p class="source-code">try:</p>
			<p class="source-code">    loop.run_forever()</p>
			<p class="source-code">except KeyboardInterrupt:</p>
			<p class="source-code">    pass</p>
			<p class="source-code"># Close the server</p>
			<p class="source-code">server.close()</p>
			<p class="source-code">loop.run_until_complete(server.wait_closed())</p>
			<p class="source-code">loop.close()</p>
			<p>After receiving <a id="_idIndexMarker928"/>the data from the <strong class="source-inline">transport</strong> object and printing it out, we write a corresponding message to the <strong class="source-inline">transport</strong> object, which will go back to the original client. By running this script and simulating the same communication that we implemented in the last example with Telnet or Netcat, you will see that after typing a message in the client Terminal, the client receives an echoed message from the server. This is my output after initiating the communication channel and typing in the <strong class="source-inline">Hello, World!</strong> message:</p>
			<p class="source-code">&gt; telnet 127.0.0.1 8888</p>
			<p class="source-code">Trying 127.0.0.1...</p>
			<p class="source-code">Connected to localhost.</p>
			<p class="source-code">Hello, World!</p>
			<p class="source-code">Echoed back: Hello, World!</p>
			<p>In essence, this example illustrates the capability of a bidirectional communication channel <a id="_idIndexMarker929"/>that we can implement through a custom <strong class="source-inline">asyncio.Protocol</strong> class. While running a server, we can obtain data sent from various clients connected to the server, process the data, and finally send the desired result back to the appropriate clients.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor207"/>Closing transports</h2>
			<p>Occasionally, we will want to forcefully close a transport in a communication channel. For example, even <a id="_idIndexMarker930"/>with asynchronous programming and other forms of concurrency, it is possible for your server to be overwhelmed with constant communications from multiple clients. On the other hand, it is undesirable to have the server completely handle some of the sent requests and plainly reject the rest of the requests as soon as the server is at its maximum capacity.</p>
			<p>So, instead of keeping the communication open for each client connected to the server, we can specify in our protocol that each connection should be closed after a successful communication. We will do this by using the <strong class="source-inline">BaseTransport.close()</strong> method to forcefully close the calling <strong class="source-inline">transport</strong> object, which will stop the connection between the server and that specific client. Again, we are modifying the <strong class="source-inline">data_received()</strong> method of the <strong class="source-inline">EchoServerClientProtocol</strong> class, as follows:</p>
			<p class="source-code">import asyncio</p>
			<p class="source-code">class EchoServerClientProtocol(asyncio.Protocol):</p>
			<p class="source-code">    def connection_made(self, transport):</p>
			<p class="source-code">        peername = transport.get_extra_info('peername')</p>
			<p class="source-code">        print('Connection from {}'.format(peername))</p>
			<p class="source-code">        self.transport = transport</p>
			<p class="source-code">    def data_received(self, data):</p>
			<p class="source-code">        message = data.decode()</p>
			<p class="source-code">        print('Data received: {!r}'.format(message))</p>
			<p class="source-code">        self.transport.write(('Echoed back: \</p>
			<p class="source-code">          {}'.format(message)).encode())</p>
			<p class="source-code">        print('Close the client socket')</p>
			<p class="source-code">        self.transport.close()</p>
			<p class="source-code">loop = asyncio.get_event_loop()</p>
			<p class="source-code">coro = loop.create_server(EchoServerClientProtocol, \</p>
			<p class="source-code">  '127.0.0.1', 8888)</p>
			<p class="source-code">server = loop.run_until_complete(coro)</p>
			<p class="source-code"># Serve requests until Ctrl+C is pressed</p>
			<p class="source-code">print('Serving on {}'.format(server.sockets[0].getsockname()))</p>
			<p class="source-code">try:</p>
			<p class="source-code">    loop.run_forever()</p>
			<p class="source-code">except KeyboardInterrupt:</p>
			<p class="source-code">    pass</p>
			<p class="source-code"># Close the server</p>
			<p class="source-code">server.close()</p>
			<p class="source-code">loop.run_until_complete(server.wait_closed())</p>
			<p class="source-code">loop.close()</p>
			<p>Run the script, connect to the specified server, and type in some messages to see the changes that <a id="_idIndexMarker931"/>we implemented. With our current setup, after a client connects and sends a message to the server, it will receive an echoed message back, and its connection with the server will be closed. This is the output (again, from the interface of the Telnet program) that I obtained after simulating this process with our current implementation of the protocol:</p>
			<p class="source-code">&gt; telnet 127.0.0.1 8888</p>
			<p class="source-code">Trying 127.0.0.1...</p>
			<p class="source-code">Connected to localhost.</p>
			<p class="source-code">Hello, World!</p>
			<p class="source-code">Echoed back: Hello, World!</p>
			<p class="source-code">Connection closed by foreign host.</p>
			<p>So far, we have covered examples of implementing asynchronous communication channels with the <strong class="source-inline">asyncio</strong> module, mostly from the perspective of the server side of the communication process; in other words, we have been handling and processing requests sent from external systems. This, however, is only one side of the equation, and we also have the client side of communication to explore. In the next section, we will discuss applying asynchronous programming to make requests to servers.</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor208"/>Client-side communication with aiohttp</h1>
			<p>As you have most likely guessed, the end goal of this process is to efficiently collect data from external <a id="_idIndexMarker932"/>systems by asynchronously making requests to those systems. We will be revisiting the concept of web scraping, which is <a id="_idIndexMarker933"/>the process of automating HTTP requests to various websites and extracting specific information from their <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) source code. If you have not read <a href="B17499_09_Final_SS_ePub.xhtml#_idTextAnchor158"><em class="italic">Chapter 9</em></a>, <em class="italic">Concurrent Web Requests</em>, I highly recommend going through it before proceeding with this <a id="_idIndexMarker934"/>section, as that chapter covers the fundamental ideas of web scraping and other relevant, important concepts.</p>
			<p>In this section, you will also be introduced to another module that supports asynchronous <a id="_idIndexMarker935"/>programming options: <strong class="source-inline">aiohttp</strong> (which stands for <strong class="bold">asynchronous input/output (I/O) HTTP</strong>). This module provides high-level functionalities that streamline HTTP communication procedures, and it also works seamlessly with the <strong class="source-inline">asyncio</strong> module, to facilitate asynchronous programming.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor209"/>Installing aiohttp and aiofiles</h2>
			<p>The <strong class="source-inline">aiohttp</strong> module does not come preinstalled with your Python distribution; however, similarly to <a id="_idIndexMarker936"/>other packages, you can easily install the module <a id="_idIndexMarker937"/>by using the <strong class="source-inline">pip</strong> or <strong class="source-inline">conda</strong> commands. We will also be installing another module, <strong class="source-inline">aiofiles</strong>, which facilitates asynchronous file writing. If you use <strong class="source-inline">pip</strong> as your package manager, simply run the following commands:</p>
			<p class="source-code">pip install aiohttp</p>
			<p class="source-code">pip install aiofiles</p>
			<p>If you'd like to use Anaconda, run the following commands:</p>
			<p class="source-code">conda install aiohttp</p>
			<p class="source-code">conda install aiofiles</p>
			<p>As always, to confirm that you have successfully installed a package, open your Python interpreter and try to import the module. In this case, run the following code:</p>
			<p class="source-code">&gt;&gt;&gt; import aiohttp</p>
			<p class="source-code">&gt;&gt;&gt; import aiofiles</p>
			<p>There will be no error messages if the package has been successfully installed.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor210"/>Fetching a website's HTML code</h2>
			<p>First, let's look <a id="_idIndexMarker938"/>at how to make a request and obtain the HTML source code from a single website with <strong class="source-inline">aiohttp</strong>. Note that even with only one task (a website), our application remains asynchronous, and the structure of an asynchronous program still needs to be implemented as follows:</p>
			<p class="source-code">import aiohttp</p>
			<p class="source-code">import asyncio</p>
			<p class="source-code">async def get_html(session, url):</p>
			<p class="source-code">    async with session.get(url, ssl=False) as res:</p>
			<p class="source-code">        return await res.text()</p>
			<p class="source-code">async def main():</p>
			<p class="source-code">    async with aiohttp.ClientSession() as session:</p>
			<p class="source-code">        html = await get_html(session, ' \</p>
			<p class="source-code">          http://packtpub.com')</p>
			<p class="source-code">        print(html)</p>
			<p class="source-code">loop = asyncio.get_event_loop()</p>
			<p class="source-code">loop.run_until_complete(main())</p>
			<p>Let's consider the <strong class="source-inline">main()</strong> coroutine first. We are initiating an instance from the <strong class="source-inline">aiohttp.ClientSession</strong> class within a context manager; note that we are also placing the <strong class="source-inline">async</strong> keyword in front of this declaration since the whole context block itself will also be treated as a coroutine. Inside of this block, we are calling and waiting for the <strong class="source-inline">get_html()</strong> coroutine to process and return.</p>
			<p>Turning our attention to the <strong class="source-inline">get_html()</strong> coroutine, we can see that it takes in a session object and a <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) for the website that we want to extract <a id="_idIndexMarker939"/>the HTML source code from. Inside of this function, we make another context manager asynchronous, which is used to make a <strong class="source-inline">GET</strong> request <a id="_idIndexMarker940"/>and store the response from the server to the <strong class="source-inline">res</strong> variable. Finally, we return the HTML source code stored in the response. Since the response is an object returned from the <strong class="source-inline">aiohttp.ClientSession</strong> class, its methods are asynchronous functions, and therefore we need to specify the <strong class="source-inline">await</strong> keyword when we call the <strong class="source-inline">text()</strong> function.</p>
			<p>As you run the program, the entire HTML source code of Packt's website will be printed out. For example, here is a portion of my output:</p>
			<p class="source-code">&lt;!doctype html&gt;</p>
			<p class="source-code">&lt;html lang="en"&gt;</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">    var BASE_URL = 'https://www.packtpub.com/';</p>
			<p class="source-code">    var require = {</p>
			<p class="source-code">        "baseUrl": "https://www.packtpub.com/static</p>
			<p class="source-code">          /version1611744644/frontend/Packt/default/en_GB"</p>
			<p class="source-code">    };</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p class="source-code">&lt;meta charset="utf-8" /&gt;</p>
			<p class="source-code">&lt;meta name="title" content="Packt | Programming Books, eBooks </p>
			<p class="source-code">&amp;amp; Videos for Developers" /&gt;</p>
			<p class="source-code">&lt;meta name="description" content="Packt is the online </p>
			<p class="source-code">library and learning platform for professional developers. </p>
			<p class="source-code">Learn Python, JavaScript, Angular and more with eBooks, </p>
			<p class="source-code">videos and courses" /&gt;</p>
			<p class="source-code">&lt;meta name="robots" content="INDEX,FOLLOW" /&gt;</p>
			<p class="source-code">&lt;meta name="viewport" content="width=device-width, initial-</p>
			<p class="source-code">scale=1, maximum-scale=1, user-scalable=1, shrink-to-</p>
			<p class="source-code">fit=no" /&gt;</p>
			<p class="source-code">&lt;meta name="" content="charset=utf-8" /&gt;</p>
			<p class="source-code">&lt;title&gt;Packt | Programming Books, eBooks &amp;amp</p>
			<p class="source-code">…</p>
			<p>At this point, we can collect data by making requests to multiple websites asynchronously and print out the response HTML. Most of the time, simply printing out the HTML <a id="_idIndexMarker941"/>is inappropriate; instead, we'd like to write the returned HTML code to output files. In essence, this process is asynchronous downloading, which is also implemented in the underlying architecture of popular download managers. To do this, we will use the <strong class="source-inline">aiofiles</strong> module, in combination with <strong class="source-inline">aiohttp</strong> and <strong class="source-inline">asyncio</strong>.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor211"/>Writing files asynchronously</h2>
			<p>First, we <a id="_idIndexMarker942"/>will write a <strong class="source-inline">download_html()</strong> coroutine, as follows:</p>
			<p class="source-code">async def download_html(session, url):</p>
			<p class="source-code">    async with session.get(url, ssl=False) as res:</p>
			<p class="source-code">        filename = f'output/{os.path.basename(url)}.html'</p>
			<p class="source-code">        async with aiofiles.open(filename, 'wb') as f:</p>
			<p class="source-code">            while True:</p>
			<p class="source-code">                chunk = await res.content.read(1024)</p>
			<p class="source-code">                if not chunk:</p>
			<p class="source-code">                    break</p>
			<p class="source-code">                await f.write(chunk)</p>
			<p class="source-code">        return await res.release()</p>
			<p>This is an updated version of the <strong class="source-inline">get_html()</strong> coroutine from the last example. Instead of using an <strong class="source-inline">aiohttp.ClientSession</strong> instance to make a <strong class="source-inline">GET</strong> request and print out the returned HTML code, we now write the HTML code to the file using the <strong class="source-inline">aiofiles</strong> module. For example, to facilitate asynchronous file writing, we use the asynchronous <strong class="source-inline">open()</strong> function from <strong class="source-inline">aiofiles</strong> to read in a file in a context manager. Furthermore, we read the returned HTML in chunks, asynchronously, using the <strong class="source-inline">read()</strong> function for the <strong class="source-inline">content</strong> attribute of <a id="_idIndexMarker943"/>the response object; this means that after reading <strong class="source-inline">1024</strong> bytes of the current response, the execution flow will be released back to the event loop, and the task-switching event will take place.</p>
			<p>The <strong class="source-inline">main()</strong> coroutine and the main program of this example remain relatively the same as those in our last example, as we can see here:</p>
			<p class="source-code">async def main(url):</p>
			<p class="source-code">    async with aiohttp.ClientSession() as session:</p>
			<p class="source-code">        await download_html(session, url)</p>
			<p class="source-code">urls = [</p>
			<p class="source-code">    'http://packtpub.com',</p>
			<p class="source-code">    'http://python.org',</p>
			<p class="source-code">    'http://docs.python.org/3/library/asyncio',</p>
			<p class="source-code">    'http://aiohttp.readthedocs.io',</p>
			<p class="source-code">    'http://google.com'</p>
			<p class="source-code">]</p>
			<p class="source-code">loop = asyncio.get_event_loop()</p>
			<p class="source-code">loop.run_until_complete(</p>
			<p class="source-code">    asyncio.gather(*(main(url) for url in urls))</p>
			<p class="source-code">)</p>
			<p>The <strong class="source-inline">main()</strong> coroutine takes in a URL and passes it to the <strong class="source-inline">download_html()</strong> coroutine, along with an <strong class="source-inline">aiohttp.ClientSession</strong> instance. Finally, in our main program, we create an event loop and pass each item in a specified list of URLs to the <strong class="source-inline">main()</strong> coroutine. After running the program, your output should look like this, although the time it takes to run the program might vary:</p>
			<p class="source-code">&gt; python3 example5.py</p>
			<p class="source-code">Took 0.72 seconds.</p>
			<p>Additionally, a subfolder named <strong class="source-inline">output</strong> (inside of the <strong class="source-inline">Chapter18</strong> folder) will be filled with the downloaded HTML code from each website in our list of URLs. Again, these files were created <a id="_idIndexMarker944"/>and written asynchronously, via the functionalities of the <strong class="source-inline">aiofiles</strong> module, which we discussed earlier. As you can see, to compare the speed of this program and its corresponding synchronous version, we are also keeping track of the time it takes to run the entire program.</p>
			<p>Now, head to the <strong class="source-inline">Chapter11/example6.py</strong> file. This script contains the code of the synchronous version of our current program. Specifically, it makes HTTP <strong class="source-inline">GET</strong> requests to individual websites in order, and the process of file writing is also implemented sequentially. This script produced the following output:</p>
			<p class="source-code">&gt; python3 example6.py</p>
			<p class="source-code">Took 1.47 seconds.</p>
			<p>While it achieved the same results (downloading the HTML code and writing it to files), our sequential program took significantly more time than its asynchronous counterpart.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor212"/>Summary</h1>
			<p>Asynchronous programming can provide functionalities that complement the process of efficiently facilitating communication channels. Together with the <strong class="source-inline">aiohttp</strong> module, <strong class="source-inline">asyncio</strong> offers efficiency and flexibility regarding client-side communication processes. The <strong class="source-inline">aiofiles</strong> module, which can work in conjunction with the other two asynchronous programming modules, can also help to facilitate asynchronous file reading and writing.</p>
			<p>We have now explored three of the biggest, most important topics in concurrent programming: threading, multiprocessing, and asynchronous programming. We have shown how each of them can be applied to various programming problems and provide significant improvements in speed. The code we developed in this chapter serves as a base that may be easily modified to build more complex applications.</p>
			<p>In the next chapter of this book, we will start to discuss problems that concurrent programming commonly poses to developers and programmers, starting with deadlocks.</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor213"/>Questions</h1>
			<ol>
				<li>What is a communication channel? What is its connection to asynchronous programming?</li>
				<li>What are the two main parts of the OSI model protocol layers? What purpose does each of them serve?</li>
				<li>What is the transport layer? Why is it crucial to communication channels?</li>
				<li>How does <strong class="source-inline">asyncio</strong> facilitate the implementation of server-side communication channels?</li>
				<li>How does <strong class="source-inline">asyncio</strong> facilitate the implementation of client-side communication channels?</li>
				<li>What is <strong class="source-inline">aiofiles</strong>?</li>
			</ol>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor214"/>Further reading</h1>
			<p>For more information, you can refer to the following links:</p>
			<ul>
				<li><em class="italic">IoT Systems and Communication Channels</em> (br<strong class="source-inline">idgera.com/iot-communication-channels/</strong>), by <em class="italic">Bridgera</em></li>
				<li><em class="italic">Automate the Boring Stuff with Python: Practical Programming for Total Beginners</em>, <em class="italic">Al Sweigart</em>, <em class="italic">No Starch Press</em> </li>
				<li><em class="italic">Transports and protocols</em> (<strong class="source-inline">docs.python.org/3/library/asyncio-protocol</strong>), Python documentation</li>
			</ul>
		</div>
	</div>
</div>
</body></html>