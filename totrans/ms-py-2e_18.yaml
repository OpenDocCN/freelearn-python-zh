- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging – Creating Your Own Libraries or Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chapters thus far have covered how to write, test, and debug Python code.
    With all of that, there is only one thing that remains: packaging and distributing
    your Python libraries and applications. To create installable packages, we will
    use the `setuptools` package, which is bundled with Python these days. If you
    have created packages before, you might remember `distribute` and `distutils2`,
    but it is very important to remember that these have been replaced by `setuptools` and `distutils` and
    you shouldn’t use them anymore!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have several types of packages and packaging methods to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Building new-style packages using the PEP 517/518 `pyproject.toml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced package building using the `setup.py` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Package types: wheels, eggs, source packages, and others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing executables and custom `setuptools` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages containing C/C++ extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests on the package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a very messy history when it comes to packaging. Over the decades
    that Python has existed, we have (had) libraries such as `distutils`, `distutils2`,
    `distribute`, `buildout`, `setuptools`, `packaging`, `distlib`, `poetry`, and
    several others. All of these projects were started with the best intentions to
    improve upon the status quo, unfortunately with varying degrees of success. And
    that is not to mention all the different package types such as wheels, source
    packages, and binary packages such as eggs, Red Hat `.rpm` files, and Windows
    `.exe`/`.msi` files.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that even though packaging has had a complicated history, things
    have started to settle over the last few years and the situation has improved
    greatly. Building packages has become much easier, and maintaining a stable project
    dependency state is now easily possible.
  prefs: []
  type: TYPE_NORMAL
- en: Types of packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has (had) a whole bunch of package types, but there are only two that
    really matter these days:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wheels**: These are small, ready-to-install `.zip` files with a `.whl` extension
    that only need extraction as opposed to the building a source package would need.
    Additionally, these can be either source or binary, depending on the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source packages**: These can have many extensions such as `.zip`, `.tar`,
    `.tar.gz`, `.tar.bz2`, `.tar.xz`, and `.tar.Z`. They contain the Python/C/etc.
    source and data files needed to install and build the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we’ll go into a bit more detail about the formats.
  prefs: []
  type: TYPE_NORMAL
- en: Wheels – The new eggs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For pure Python packages, the source packages have always been enough. For binary
    C/C++ packages, however, it is a much less convenient option. The problem with
    C/C++ source packages is that compilation is needed, which requires not only a
    compiler but often headers and libraries on the system as well. With binary packages,
    you usually don’t need a compiler or any other libraries installed because the
    required libraries are bundled with the package; Python itself is enough.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, Python used the `.egg` format for binary packages. The `.egg`
    format is, in essence, just a renamed `.zip` file containing the source code and
    metadata, and in the case of binary `.egg` files also the compiled binaries. While
    the idea was great, `.egg` files never really solved the problem quite right;
    an `.egg` file could match multiple environments, but that was no guarantee of
    it actually running on those systems.
  prefs: []
  type: TYPE_NORMAL
- en: That is why the `wheel` format was introduced (`PEP-427`), a package format
    that can contain both source and binary files and can be installed on Windows,
    Linux, macOS X, and other systems without requiring a compiler.
  prefs: []
  type: TYPE_NORMAL
- en: As an added bonus, wheels can install both pure Python and binary packages more
    quickly because there are no build, install, or post-processing steps and because
    they are smaller. Installing a wheel only requires extracting the `.whl` file
    to the `site-packages` directory of your Python environment and you are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest issue binary wheels solve over eggs is the naming of files. With
    wheels, this is done in a simple and consistent way so that checking for the existence
    of a compatible wheel can be done by filename alone. The files use the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s dive into these fields and look at what their possible values are. But
    first, the syntax. The names between the `{` and `}` parentheses are the fields,
    and the `[` and `]` parentheses indicate an optional field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`distribution`: The name of the package, e.g. `numpy`, `scipy`, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: The version of the package, e.g. `1.2.3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build tag`: An optional build number as a tie-breaker if multiple wheels match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python tag`: The Python version and platform. In the case of CPython 3.10,
    this would be `cp310`. For PyPy 3.10, this would be `pp310`. You can read more
    about this in `PEP-425`. For pure Python packages, this is either `py3` for Python
    3 support or `py2.py3` for universal packages that support both Python 2 and Python
    3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abi tag`: The ABI (application binary interface) tag indicates the required
    Python ABI. `cp310d` would be CPython 3.10 with debugging enabled, for example.
    More details can be found in `PEP-3149`. In the case of a pure Python package,
    this is usually `none`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`platform tag`: The platform tag tells you the operating systems it will run
    on. This can be `win32` or `win_amd64` for 32-bit or 64-bit Windows respectively.
    For macOS X, this could be something like `macosx_11_0_arm64`. For pure Python
    packages, this is usually `any`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of these different options, you can probably guess that to support
    many platforms you will need many wheels. This is actually a good thing, as it
    solves one of the big issues of egg files, namely that installable files did not
    always work. If you can find a matching wheel for your system, you can expect
    it to work without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: The downside is the build time required for all of these wheels. The `numpy`
    package, for example, has 29 different wheels at the time of writing. Each of
    these wheels takes between 15 and 45 minutes to build, so if we take an average
    of 30 minutes per wheel, we end up with 15 hours of build time for each `numpy`
    release. Naturally, they can be built in parallel, but it is something to take
    into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we have 29 different wheels available for `numpy`, there is still
    no support for many platforms, such as FreeBSD, so the need for a source package
    also remains.
  prefs: []
  type: TYPE_NORMAL
- en: Source packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Source packages are the most versatile out of all the types of Python packages.
    They contain the source, build scripts, and potentially many other files such
    as documentation and tests. These allow you to build and/or compile the package
    for your system. Source packages can have many different extensions, such as `.zip`
    and `.tar.bz2`, but are basically a slightly stripped-down version of the entire
    project directory and related files.
  prefs: []
  type: TYPE_NORMAL
- en: Since these packages often contain not only the straight-up source files but
    also tests and documentation, they take up more space and are slower to install
    than wheels. Looking at the source package for `numpy`, for example, I currently
    see 1941 files, whereas the wheel only contains 710 files. This difference can
    actually be useful as well because you might have a use for the test files or
    the documentation. If you wish to skip the binary files because you wish to have
    the original sources or if you want an optimized build for your specific system,
    you can opt for installing the source files by telling `pip` to skip the binary
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the package from the source instead of the binaries can result in
    a smaller and/or faster binary because it will only link to the libraries available
    on your system instead of being universal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `psycopg` package for connecting to PostgreSQL databases is a good example
    of this. It offers three possible installation options to install through `pip`
    in descending order of preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`psycopg[c]`: Both the Python and the C source files for building and compiling
    locally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`psycopg[binary]`: The Python source and precompiled binaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`psycopg`: The Python source only; in this case, you need to have the `libpq`
    library installed on your system, which is accessed through `ctypes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install without any pre-compiled binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since a source package comes with a build script, the installation alone can
    already be dangerous. While a wheel will only unpack and not run anything, a source
    package will execute the build scripts during installation. At one point, there
    was even a Russian Roulette package on PyPI that would have a 1/6 chance of deleting
    files on your system during installation to illustrate the dangers of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: I personally think the security risk of executing build scripts during installion
    is of much less importance than vetting a package before you even plan to install
    it. Installing potentially malicious packages on your system is a bad idea, whether
    or not you actually execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: Package tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what tools do we still need and use for installation these days?
  prefs: []
  type: TYPE_NORMAL
- en: The `distribute`, `distutils`, and `distutils2` packages have largely been replaced
    by `setuptools`. To install a `setup.py` based source package, you usually need
    `setuptools`, and `setuptools` comes bundled with `pip`, so that is a requirement
    you should already have available. When it comes to installing wheels, you need
    the `wheel` package; this is also conveniently bundled with `pip`. On most systems,
    this means that you should have everything you need to install extra packages
    once Python is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ubuntu Linux distribution is unfortunately a notable exception which ships
    with a mutilated Python installation that lacks both the `pip` and `ensurepip`
    commands. This can be fixed by installing `pip` separately using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If that does not work, you can always install `pip` by running the `get-pip.py`
    script: [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `setuptools` and `pip` have seen quite a lot of development over the
    last few years, it might be a good idea to upgrade these packages in any case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the prerequisites installed, we can continue with building
    our own packages.
  prefs: []
  type: TYPE_NORMAL
- en: Package versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are many versioning schemes available, many Python packages, and
    Python itself, use PEP-440 for the version specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Some people adhere to the slightly stricter version called **semantic versioning**
    (**SemVer**), but the two are largely compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The short and simplified explanation is that version numbers such as `1.2`
    or `1.2.3` are used. For instance, looking at version `1.2.3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` is the major version and indicates API-breaking incompatible changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` is the minor version and indicates backward-compatible functionality addition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` is the patch version, which is used for backward-compatible bugfixes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of major versions, some libraries opt for making the versions non-contiguous
    and use dates for the versions, such as `2022.5`.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-releases such as alphas and betas can be specified through the minor version
    with letters. The options are `a` for alpha, `b` for beta, and `rc` for release
    candidate. This results in `1.2a3` for `1.2 alpha 3`, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of semantic versioning, this is handled by adding a pre-release
    identifier to the end, such as `1.2.3-beta` or `1.2.3-beta.1` for multiple betas.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, PEP-440 allows the use of post-releases using `1.2.post3` instead of
    `1.2.3` for minor bugfixes, and similarly `1.2.dev2` for development releases.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever versioning system you use, think about it carefully before starting
    your project. Not taking the future into account can certainly cause problems
    in the long run. An example of this is Windows. Some applications had trouble
    supporting Windows 10 because an alphabetical sort of version number puts Windows
    10 below Window 8 (after all, 1 is smaller than 8).
  prefs: []
  type: TYPE_NORMAL
- en: Building packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python packages were traditionally built using a `setup.py` file that contained
    (part of) the build script. This method usually depends on `setuptools` and is
    still the standard for most packages, but we have easier methods available these
    days. If your project is not too demanding, you can use a small `pyproject.toml`
    file instead, which can be much easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s give both methods a try and see how easy it is to build a basic Python
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging using pyproject.toml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pyproject.toml` file allows for really easy packaging depending on the
    tooling used. It was introduced in 2015 through `PEP-517` and `PEP-518`. This
    method was created to improve upon the `setup.py` file by introducing build-time
    dependencies, automatic configuration, and making it easier to work in a DRY (Don’t
    Repeat Yourself) manner.
  prefs: []
  type: TYPE_NORMAL
- en: TOML stands for “Tom’s Obvious, Minimal Language” and is somewhat comparable
    to YAML and INI files, but a bit simpler. Since it is such a simple language,
    it can easily be included in packages such as `pip` with little overhead. This
    makes it perfect for scenarios where you need a flat structure and have no need
    for complicated features such as inheritance and includes.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, we need to clarify a few things. When we talk about the
    `setup.py` file, we are often actually talking about the `setuptools` library
    instead. The `distutils` library, which is bundled with Python, can be used as
    well, but since `pip` depends on `setuptools` it is often the better option; it
    has more features, and updates together with `pip` instead of with your Python
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to how `setup.py` usually means `setuptools`, with `pyproject.toml`
    we also have multiple libraries available for building and managing `PEP-517`
    style packages. This approach to creating a standard and relying on community
    projects for the implementations has worked quite well for Python in the past,
    which makes it a sound choice. An example of this approach is the Python Web Server
    Gateway Interface (WSGI), which was introduced as `PEP-333` and currently has
    several great implementations available.
  prefs: []
  type: TYPE_NORMAL
- en: The reference solution for `PEP-517` is the `pep517` library, which works but
    is rather limited. Another option is the `build` library, which is maintained
    by the Python Package Authority (PyPA), which also maintains the Python Package
    Index (PyPI). While that library works, it is also really limited in terms of
    features and not an option I would recommend either.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best option by far, in my opinion, is the `poetry` tool. The `poetry` tool
    not only handles the building of packages for you but also takes care of:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast installing of dependencies in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating virtual environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating easy access points for runnable scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependencies by specifying smart version constraints (for example,
    major and minor versions, covered in detail later in this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing to PyPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple Python versions using `pyenv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For most cases, `pyproject.toml` can replace the traditional `setup.py` files
    completely, but there are a few cases where you will need some extra tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of building C/C++ extensions and others, you either need a `setup.py`
    file or to specify how to build the extensions some other way. One option for
    this is to use the `poetry` tool and add a build script to the `pyproject.toml`
    tool. We will discuss this more later on, in the section about C/C++ extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Editable installs (i.e. `pip install -e ...`) were not possible until 2021,
    but that has been remedied by PEP-660.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by using `poetry` to create a basic `pyproject.toml` file in our
    current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since our parent directory is called `t_00_basic_pyproject`, `poetry` automatically
    makes that the new project name. Alternatively, you can also do `poetry new some_project_name`
    and it will create a directory for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `poetry` command created the following files for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very simple boilerplate that contains enough to get your project started.
    The `t_00_basic_pyproject/__init__.py` file contains the version (which defaults
    to `0.1.0`) and the `tests/test_t_00_basic_pyproject.py` file tests for this version
    as an example test. The more interesting part is the `pyproject.toml` file, however,
    so let’s look at that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `poetry` has automatically configured the name and version.
    It also added me as an author by looking at the `git` config on my system. You
    can easily configure this yourself by running these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we can see that it automatically set Python 3.10 as a requirement and
    added `pytest` 5.2 as a development dependency. For building the package, it added
    `poetry-core` as a dependency, which is the `poetry` equivalent of `setuptools`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages for development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For development purposes, we usually install a package in **editable mode**.
    In editable mode, the package is not copied to your `site-packages` directory,
    but a link is made to your source directory so all changes to your source directory
    apply immediately. Without editable mode, you would have to do a `pip install`
    every time you made a change to your package, which is very inconvenient for development.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `pip`, you can install in editable mode with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For installing in the current directory, you can use `.` as the directory,
    resulting in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `poetry` command, installing in editable mode (or something similar
    for older versions of `poetry`) happens automatically. It also handles the creation
    of a virtual environment for us while making use of `pyenv` for the Python version
    specified in the `pyproject.toml` file. To install the package and all of its
    requirements, you only need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to have direct access to all of the commands in the virtual environment
    created, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `poetry shell` command spawns a new shell with the name of the current project
    added to your command-line prefix and with the virtual environment scripts directory
    added to your `PATH` environment variable. This results in commands such as `python`
    and `pip` executing within your virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding code and data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the basic example, we didn’t have anything specifying which directory contains
    the source or that the `t_00_basic_pyproject` directory has to be included in
    the directory. By default, that is handled implicitly, but we can modify the `pyproject.toml`
    file to explicitly include directories or file patterns as the Python source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that adding the `packages` argument disables the automatic detection of
    packages, so you will need to specify all included packages at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include other data files such as documentation, we can use the `include`
    and `exclude` parameters. The `exclude` parameter overrides the files included
    by the `packages` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For a basic project, you might not need to look at this. But, as always, explicit
    is better than implicit, so I recommend that you do take a quick look to prevent
    unwanted surprises where the wrong files are accidentally included in your package.
  prefs: []
  type: TYPE_NORMAL
- en: Adding executable commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some packages such as `numpy` are libraries only, meaning they are imported
    but have no runnable commands. Other packages such as `pip` and `poetry` contain
    runnable scripts which are installed as new commands during installion. After
    all, when the `poetry` package is installed, you can use the `poetry` command
    from your shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our own commands, we need to specify the name of the new command,
    the module, and the corresponding function, so `poetry` will know what to run.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This would execute the `run()` function in a file called `T_00_basic_pyproject/main.py`.
    After installing the package, you could execute `our_command` from your shell
    to run the script. During development with `poetry`, you can use `poetry run our_command`,
    which automatically runs the command in the `poetry`-created virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pyproject.toml` file we created already had a few requirements for both
    development and building, but you might also want to add other dependencies to
    your project. For example, if we wanted to add a progress bar we could run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This automatically installs the `progressbar2` package for us and adds it to
    the `pyproject.toml` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, `poetry` will create or update a `poetry.lock` file, which contains
    the exact package versions that are installed, so an installation in a new environment
    can easily be reproduced. In the case above, we simply told `poetry` to install
    any version of `progressbar2` which resulted in `poetry` setting the version requirement
    to `^4.0.0`, but we can relax those requirements so `poetry` will automatically
    install the latest patch, minor, or major version of the package.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `poetry` will add the dependencies to the `[tool.poetry.dependencies]`
    section, but you can also add them as development dependencies using the `--dev`
    or `-D` command-line arguments. If you want to add other types of dependencies
    such as the `build-system` dependencies or test dependencies, you will need to
    manually edit the `pyproject.toml` file, however.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version specifiers expect SemVer-compatible versions and work as follows.
    For allowing newer non-major versions, you can use the caret (`^`). This looks
    at the first non-zero number, so the behavior of `^1.2.3` is different from `^0.1.2`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^1.2.3` means `>=1.2.3` and `<2.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^1.2` means `>=1.2.0` and `<2.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^1` means `>=1.0.0` and `<2.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^0.1.2` means `>=0.1.2` and `<0.2.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next up are the tilde (`~`) requirements, which specify the minimal version
    but allow for minor updates. They are a bit simpler than the caret versions and
    effectively specify what the number should start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`~1.2.3` means `>=1.2.3` and `<1.3.0.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~1.2` means `>=1.2.0` and `<1.3.0.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~1` means `>=1.0.0` and `<2.0.0`. Note that the two options above both allow
    minor version updates, and this is the only one that allows major version updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wildcard requirements are also possible using an asterisk (`*`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`1.2.*` means `>=1.2.0` and `<1.3.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.*` means `>=1.0.0` and `<2.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The versioning system is compatible with the format used by `requirements.txt`
    as well, which allows for versions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>= 1.2.3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>= 1.2.3, <1.4.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>= 1.2.3, <1.4.0, != 1.3.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!= 1.5.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I personally prefer this last syntax since it’s clear and doesn’t require much
    prior knowledge, but you are free to use whichever you prefer. By default, `poetry`
    will use a `^1.2.3` format when adding dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s say we have a requirement like `progressbar2 = "^3.5"` and we have
    version `3.5.0` in our `poetry.lock` file. If we run `poetry install`, it will
    install exactly version `3.5.0` because we know that version to be good.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, you might want to update that dependency to a newer version
    so you can test if newer versions also work. This is also something we can ask
    of `poetry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now `poetry` will automatically upgrade the package and update the `poetry.lock`
    file within the constraints of `pyproject.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have our `pyproject.toml` file configured and the dependencies
    we want, we can build the package. This is trivially easy using `poetry`, luckily.
    Building the package takes a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With just that single command, `poetry` created a source package and a wheel
    for us. So, if you have been keeping track, you’ll realize we can essentially
    create and build a package with just two commands: `poetry new` and `poetry build`.'
  prefs: []
  type: TYPE_NORMAL
- en: Building C/C++ extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start with this section, I need to provide a little disclaimer. Building
    C/C++ extensions is at the time of writing (the end of 2021) not a stable and
    supported feature by `poetry`, which means it could be replaced by a different
    mechanism in the future. For the time being, however, there is a working solution
    available for building C/C++ extensions and future versions are likely to work
    in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking for a stable and well-supported solution right now, I would
    suggest going with a `setup.py` based project instead as covered later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to start by modifying our `pyproject.toml` file and adding the following
    line to the `[tool.poetry]` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you don’t name the file `build.py` if you ever wish to use the PyPA
    build command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, `poetry` will execute the `build_extension.py` file when
    we run `poetry build`, so now we need to create the `build_extension.py` file
    so `setuptools` can build the extension for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This script is largely the same as what you would put in the `setup.py` file.
    The reason for this is that it’s actually injecting into the same function call.
    If you look carefully at the `build()` function, you will see that it updates
    `setup_kwargs` and sets the `ext_modules` item within that. That argument is fed
    to the `setuptools.setup()` function verbatim. Essentially, we are just emulating
    the use of a `setup.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for our C file we used the `sum_of_squares.c` file from *Chapter 17,*
    *Extensions in C/C++, System Calls, and C/C++ Libaries*. You will see that the
    rest of the code largely resembles the `setup.py` file we used in *Chapter 17*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute the `poetry build` command, `poetry` will automatically call
    `setuptools` internally and build the binary wheel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With that, we are done. We now have a wheel file containing the built C extension.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging using setuptools with setup.py or setup.cfg
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setup.py` file is the traditional method of building Python packages, but
    is still used quite extensively and is a very flexible method of creating packages.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 17* has already shown us a couple of examples when building extensions,
    but let’s reiterate and review what the most important parts actually do. The
    core function you will be using in this entire chapter is `setuptools.setup()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `distutils` package bundled with Python will be sufficient as well in most
    cases, but I recommend `setuptools` regardless. The `setuptools` package has many
    great features that `distutils` lacks and nearly all Python environments will
    have `setuptools` available as it is included with `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, it is always a good idea to make sure you have the latest
    version of `pip`, `wheel`, and `setuptools`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `setuptools` and `distutils` packages have changed significantly over the
    last few years and the documentation/examples written before 2014 are most likely
    out of date. Be careful not to implement deprecated examples, and I would recommend
    skipping any documentation/examples using `distutils`.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative or addition to the `setup.py` file, you can also configure
    all metadata using a `setup.cfg` file. This uses the INI format and can be a bit
    more convenient for simple metadata where you do not need (or want) the overhead
    of the Python syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even choose to use `setup.cfg` alone and skip `setup.py`; however,
    if you did, you would need a separate building utility. For those cases, I would
    recommend installing PyPA’s `build` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Creating a basic package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have all the prerequisites, let’s create a package using a `setup.py`
    file. While the most basic `setuptools.setup()` call technically doesn’t require
    any parameters, you should really include at least the `name`, `version`, `packages`,
    `url`, `author`, and `author_email` fields if you plan to publish the package
    to PyPI. Here’s a really basic example containing these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative to configuring these as `setup()` parameters, you can also
    use a `setup.cfg` file, which uses the INI format but works in effectively the
    same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The main advantage of `setup.cfg` is that it is a more concise and simpler file
    format than the `setup.py` file is. Take a look at the `packages` section, for
    example; `setuptools.find_packages()` is quite a bit more verbose than `find:`.
  prefs: []
  type: TYPE_NORMAL
- en: The downside is that you need to pair a `setup.cfg` file with either a `setup.py`
    or `pyproject.toml` file to be able to build it. `setup.cfg` alone is not enough
    for a package, which makes `setup.cfg` a nice and clean way to separate your metadata
    from your setup code. Additionally, many libraries such as `pytest` and `tox`
    have native support for the `setup.cfg` file, so these can be configured through
    the file as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pair `setup.cfg` and/or `setup.py` with a `pyproject.toml` file, we need
    to add these lines to the `pyproject.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that a `pyproject.toml` file by itself won’t give you `poetry` support;
    for `poetry` support, you need to add a `[tool.poetry]` section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the package for development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install the package for local development, we can once again use the `-e`
    or `--editable` flag, as explained in the `poetry` section of this chapter. This
    installs a link from your source directory to the `site-packages` directory so
    the actual source is used, instead of having `setuptools` copy all of the source
    files to the `site-packages` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, from the project directory you can either use the `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Adding packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the basic example, you could see that we used `find_packages()` as the argument
    for packages. This automatically detects all source directories and is usually
    fine as a default, but sometimes you need more control. The `find_packages()`
    function also allows you to add an `include` or `exclude` parameter if you wish
    to exclude tests and other files from the package, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments to `find_packages()` can also be translated to a `setup.cfg`
    file with a slightly different syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Adding package data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most scenarios, you probably won’t have to include the package data such
    as test data or documentation files, but there are cases where you need extra
    files. Web applications, for example, might come bundled with `html`, `javascript`,
    and `css` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few different options for including extra files with your package.
    First, it is important to know which files are included in your source package
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: Python source files in the package directories and all their subdirectories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setup.py`, `setup.cfg`, and `pyproject.toml` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readme files if available, such as `README.rst`, `README.txt`, and `README.md`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata files containing the package name, version, entry points, file hashes,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Python wheels the list is even shorter, and only the Python source and the
    metadata files will be packaged by default.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if we want to include other files, we need to specify that those
    need to be added. We have two different options for adding other types of data
    to our package.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we can enable the `include_package_data` flag as an argument
    to `setup()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that flag is enabled, we can specify what file patterns we want in a `MANIFEST.in`
    file. This file contains patterns to include, exclude, and more. The `include` and `exclude` commands
    use patterns to match. These patterns are glob-style patterns (see the `glob` module
    for documentation: [https://docs.python.org/3/library/glob.html](https://docs.python.org/3/library/glob.html))
    and have three variants for both the `include` and `exclude` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`include`/`exclude`: These commands only work for the given path and nothing
    else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recursive-include`/`recursive-exclude`: These commands are similar to the `include`/`exclude` commands, but
    process the given paths recursively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`global-include`/`global-exclude`: Be very careful with these, as they will
    include or exclude these files anywhere within the source tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides the `include`/`exclude` commands, there are also two others: the `graft` and `prune` commands,
    which include or exclude directories including all the files under a given directory.
    This can be useful for tests and documentation, since they can include non-standard
    files. Beyond those examples, it’s almost always better to explicitly include
    the files you need and ignore all the others. Here’s an example `MANIFEST.in`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the `package_data` and `exclude_package_data` arguments
    and add them to `setup.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, these also have an equivalent `setup.cfg` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that these parameters use `package_data` instead of `data` for a reason.
    All of these require you to use a package. That means that data will only be included
    if it’s inside a proper Python package (in other words, if it contains an `__init__.py`).
  prefs: []
  type: TYPE_NORMAL
- en: You can choose whichever format and method you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are using a `setup.py` or `setup.cfg` file, you don’t get the easy
    dependency management that `poetry` provides. Adding new dependencies is not much
    harder, except that you need to add the requirement and install the package yourself
    instead of doing it all in a single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is the case with `pyproject.toml`, there are multiple types of dependencies
    that you can declare:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[build-system] requires`: These are the requirements to build the project.
    These are usually `setuptools` and `wheel` for `setuptools-b`ased packages; for
    `poetry` this would be `poetry-core`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[options] install_requires`: These are the requirements to be able to run
    the package. A project such as `pandas` will have a requirement for `numpy`, for
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[options.extras_require] NAME_OF_EXTRA`: If your project has optional dependencies
    for specific circumstances, the extras can help. For example, to install `portalocker`
    with `redis` support, you can run this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you have experience with creating packages, you might wonder why `tests_require`
    is not shown here. The reason is that there is no real need for it anymore since
    `extras_require` was added. You can simply add an extra requirement for `tests`
    and `docs` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of adding a few requirements to a `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the equivalent in a `setup.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Adding executable commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As is the case with a `pyproject.toml`-based project, we can specify executable
    commands using the `setup.py` or `setup.cfg` files as well. To add a basic executable
    command similar to how we can run the `pip` or `ipython` commands, we can add
    `entry_points` to our `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the `setup.cfg` equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Once you have installed this package you can run `our_command` from your shell,
    similar to how you would run a command like `pip` or `ipython`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the examples above, you might wonder if we have other options besides
    `console_scripts`, and the answer is yes. One example is `distutils.commands`,
    which can be used to add extra commands to `setup.py`. By adding a command in
    that namespace, you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The most prominent example of this behavior, however, is the `pytest` library.
    The `pytest` library uses these entry points to automatically detect plugins that
    are compatible with `pytest`. We could easily create our own equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have packages like these installed, you can query them through `importlib`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is a very useful feature for automatically registering plugins across libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Building the package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To actually build the package, we have a few options. I personally use the
    `setup.py` file if it is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you only have a `setup.cfg` and `pyproject.toml` available, you will need
    to install a package to invoke the builder. In addition to `poetry`, PyPA provides
    a tool called `build` for this, which creates an isolated environment for building
    the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Both the wheel and the source package are written to the `dist` directory and
    they are ready for publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the packages built, we need to actually publish them to PyPI.
    There are several different options we can use, but let’s discuss some optional
    package metadata first.
  prefs: []
  type: TYPE_NORMAL
- en: Adding URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `setup.py` and `setup.cfg` files already contained a `url` parameter that
    will be used as the package homepage on PyPI. However, we can add more relevant
    URLs by configuring the `project_urls` setting, which is an arbitrary map of name/URL
    pairs. For `settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for `settings.cfg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for `pyproject.toml` using `poetry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: PyPI trove classifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To increase the exposure of your package on PyPI, it can be useful to add a
    few classifiers. Some classifiers such as the Python version and the license are
    automatically added for you, but it can be useful to specify what kind of library
    or application you are writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many examples of useful classifiers for people interested in your
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development status**: This can vary from “planning” to “mature” and tells
    your users whether an application is ready for production. People’s definitions
    of what is stable or beta differs, of course, so this is usually considered a
    hint at most.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framework**: The framework(s) you are using or extending. This could be Jupyter,
    IPython, Django, Flask, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topic**: Whether this is a software development package, scientific, a game,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A full list of classifiers can be found on the PyPI website: [https://pypi.org/classifiers/](https://pypi.org/classifiers/)'
  prefs: []
  type: TYPE_NORMAL
- en: Uploading to PyPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Uploading and publishing your package to PyPI is really easy. Perhaps too easy,
    as we will see in the case of `twine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, to prevent you from accidentally publishing your package
    to PyPI, you should be aware of the PyPI test server: [https://packaging.python.org/en/latest/guides/using-testpypi/](https://packaging.python.org/en/latest/guides/using-testpypi/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `poetry`, we can configure the test repository like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, if you are using `poetry` it is as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re not using `poetry` and don’t want to use a `poetry-c`ompatible `pyproject.toml`,
    you’ll need a different solution. The official solution from PyPA is to use the
    `twine` tool, maintained by the PyPA. After you have used `python3 -m build` to
    build the package, you can use `twine` for uploading:'
  prefs: []
  type: TYPE_NORMAL
- en: Warning! This command will immediately register and upload the package to `pypi.org`
    if you are already authenticated. That’s why `--repository testpypi` was added
    to upload to the test PyPI server instead. If you drop that argument, you will
    immediately publish your package to PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you start publishing your packages to PyPI, you should ask yourself
    a couple of questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the package in a working state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you plan to support the package?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PyPI repository is unfortunately full of empty packages from people that
    are claiming usable package names for no apparent reason.
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter and earlier sections in this chapter have already covered
    the compilation of C/C++ components lightly, but this topic is complicated enough
    to warrant its own section with more in-depth explanations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, we will start with a basic `setup.py` file that compiles a
    C extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you start with these extensions, you should learn the following `setup.py`
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build_ext`: This command builds the C/C++ extension so it can be used when
    the package is installed in development/editable mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clean`: This cleans the results from the `build` command. This is generally
    not needed, but sometimes the detection of files that need to be recompiled to
    work is incorrect. If you encounter strange or unexpected issues, try cleaning
    the project first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of using `python3 setup.py build_ext`, you can also choose to use the
    PyPA `build` command, but that is not a convenient option for development. If
    you use `python3 setup.py build` you can re-use your `build` directory and selectively
    build your C/C++ extensions, which saves you a lot of time for larger C/C++ modules.
    The PyPA `build` command is meant to produce clean, production-ready packages,
    which is strongly recommended for deploying and publishing, but not for development.
  prefs: []
  type: TYPE_NORMAL
- en: Regular C/C++ extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setuptools.Extension` class tells `setuptools` that a module named `sum_of_squares` uses
    the source file `sum_of_squares.c`. This is just the simplest version of an extension
    – a name and a list of sources – but often you are going to need not just the
    C file but also some headers from other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: A prime example is the `pillow` library for image manipulation. When the library
    is building, it automatically detects the libraries available on the system and
    adds extensions based on that. For `.jpeg` support you need to have `libjpeg`
    installed; for `.tiff` images you need `libtiff`; and so on. As these extensions
    include binary libraries, some extra compilation flags and C header files are
    required. The basic PIL module itself doesn’t appear too involved, but the `setup.py`
    file is filled with auto-detection code to detect which `libs` (libraries) are
    available, with the matching C macro definitions to enable these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macros in C are preprocessor directives. These directives are executed before
    the actual compilation step occurs, which makes them ideal for conditional code.
    You could have a conditional block of debug code dependent on a `DEBUG` flag,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If `DEBUG` is set, the code will be part of the compiled binary. If the flag
    is not set, the block of code will never end up in the resulting binary. This
    results in smaller and faster binaries because these conditionals happen at compile
    time as opposed to runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a partial example `Extension` from an older version of the `pillow`
    `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The newer versions are quite different and the `setup.py` file for the `pillow`
    project is currently over 1,000 lines. The `freetype` extension has something
    similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Adding and compiling C/C++ extensions can certainly be challenging, so I would
    recommend taking inspiration from projects such as `pillow` and `numpy` if you
    need to take care of this. They are perhaps a bit too complicated, but should
    provide you with a nice starting point that covers nearly all scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Cython extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setuptools` library is a bit smarter than the regular `distutils` library
    when it comes to extensions: it actually adds a little trick to the `Extension` class.
    Remember the brief introduction to `cython` in *Chapter 12*, about performance?
    The `setuptools` library makes it a bit more convenient to compile Cython extensions.
    The Cython manual recommends that you use something similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this approach is that `setup.py` will break with an `ImportError`
    unless you have Cython installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent that issue, we are just going to let `setuptools` handle the Cython
    compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Cython will automatically be installed if needed and the code will work
    just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For development purposes, however, Cython also offers a simpler method that
    doesn’t require manual building, `pyximport`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: That’s how easy it is to run the `pyx` files without explicit compiling.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 10*, *Testing and Logging – Preparing for Bugs*, we saw a few of
    the many testing systems for Python. As you might suspect, at least some of these
    have `setup.py` integration. It should be noted that `setuptools` even has a dedicated
    `test` command (at the time of writing), but this command has been deprecated
    and the `setuptools` documentation now recommends using `tox`. While I am a huge
    fan of `tox`, for immediate local development it often incurs quite a bit of overhead.
    I find that executing `py.test` directly is faster, because you can really quickly
    test only the bits of the code that you changed.
  prefs: []
  type: TYPE_NORMAL
- en: unittest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start, we should create a test script for our package. For actual
    tests please look at *Chapter 10*; in this case, we will just use a no-op test,
    `test.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard `python setup.py test` command has been deprecated, so we will
    run `unittest` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `unittest` library is still rather limited, however, so I recommend skipping
    straight to `py.test` instead.
  prefs: []
  type: TYPE_NORMAL
- en: py.test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `py.test` package currently automatically registers as an extra command
    in `setuptools`, so after installing you can run `python3 setup.py pytest`. However,
    since `setuptools` is actively trying to reduce all interaction with `setup.py`,
    I would recommend using a `py.test` or `tox` call directly instead.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, it is recommended to use `tox` for bootstrapping your
    environment and fully testing the project. For fast local development, however,
    I would suggest installing the `pytest` module and running the tests directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there might still be old documentation floating around suggesting
    the use of `pytest-runner`, `python setup.py test` with an alias or custom command,
    or the generation of a `runtests.py` file, but all of these solutions have been
    deprecated and should not be used anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure `py.test` we have several options depending on your preferences.
    All of the following files will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest.ini`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyproject.toml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tox.ini`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setup.cfg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the projects I maintain, I have the test requirements defined as an extra
    so these can be installed using (for example) `pip3 install -e "./progressbar2[tests]"`.
    After that, you can easily run `py.test` to run the tests identically to how `tox`
    would run them. Naturally, `tox` can also install the requirements using the same
    extras, which ensures you are using the same test environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this in your `setup.cfg` (or the equivalent for `setup.py` / `pyproject.toml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'For local development, we can now install the package and the extras in editable
    mode for quick testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'That should be enough to be able to test using `py.test` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: To test using `tox`, you will need to create a `tox.ini` file, but for that,
    I suggest you take a look at *Chapter 10*.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have reached the end of the book, there are many things to try,
    of course. You can build and publish your own applications and libraries, or extend
    existing libraries and applications.
  prefs: []
  type: TYPE_NORMAL
- en: While trying out the examples in this chapter, be careful not to accidentally
    publish packages to PyPI if that was not your intention. It just takes a single
    `twine` command to accidentally register and upload a package, and PyPI is already
    too crowded with packages that do nothing useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some practical exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `setuptools` command to bump the version in your package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the version bumping command by interactively asking for a major, minor,
    or patch upgrade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try and convert existing projects from `setup.py` to a `pyproject.toml` structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_18.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should be able to create Python packages containing
    not only pure-Python files but also extra data, compiled C/C++ extensions, documentation,
    and tests. With all these tools at your disposal, you are now able to make high-quality
    Python packages that can easily be reused in other projects and packages.
  prefs: []
  type: TYPE_NORMAL
- en: The Python infrastructure makes it really quite easy to create new packages
    and split your project into multiple subprojects. This allows you to create simple
    and reusable packages with fewer bugs because everything is easily testable. While
    you shouldn’t go overboard with splitting up the packages, if a script or module
    has a purpose of its own then it’s a candidate for packaging separately.
  prefs: []
  type: TYPE_NORMAL
- en: '*'
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we have come to the end of the book. I sincerely hope you
    enjoyed reading it and have learned about some new and interesting topics. Any
    and all feedback is greatly appreciated, so feel free to contact me through my
    website at [https://wol.ph/](https://wol.ph/).
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
