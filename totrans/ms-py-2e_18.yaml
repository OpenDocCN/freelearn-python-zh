- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Packaging – Creating Your Own Libraries or Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包 – 创建您自己的库或应用程序
- en: 'The chapters thus far have covered how to write, test, and debug Python code.
    With all of that, there is only one thing that remains: packaging and distributing
    your Python libraries and applications. To create installable packages, we will
    use the `setuptools` package, which is bundled with Python these days. If you
    have created packages before, you might remember `distribute` and `distutils2`,
    but it is very important to remember that these have been replaced by `setuptools` and `distutils` and
    you shouldn’t use them anymore!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的章节已经涵盖了如何编写、测试和调试 Python 代码。有了这一切，只剩下了一件事：打包和分发您的 Python 库和应用程序。为了创建可安装的包，我们将使用随
    Python 一起打包的 `setuptools` 包。如果您之前创建过包，可能会记得 `distribute` 和 `distutils2`，但非常重要的一点是，这些已经被
    `setuptools` 和 `distutils` 取代，您不应再使用它们！
- en: 'We have several types of packages and packaging methods to cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种包类型和打包方法需要涵盖：
- en: Building new-style packages using the PEP 517/518 `pyproject.toml` file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PEP 517/518 的 `pyproject.toml` 文件构建新式包
- en: Advanced package building using the `setup.py` file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `setup.py` 文件进行高级包构建
- en: 'Package types: wheels, eggs, source packages, and others'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包类型：wheels、eggs、源码包和其他
- en: Installing executables and custom `setuptools` commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装可执行文件和自定义 `setuptools` 命令
- en: Packages containing C/C++ extensions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 C/C++ 扩展的包
- en: Running tests on the package
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包上运行测试
- en: Introduction to packages
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包的介绍
- en: Python has a very messy history when it comes to packaging. Over the decades
    that Python has existed, we have (had) libraries such as `distutils`, `distutils2`,
    `distribute`, `buildout`, `setuptools`, `packaging`, `distlib`, `poetry`, and
    several others. All of these projects were started with the best intentions to
    improve upon the status quo, unfortunately with varying degrees of success. And
    that is not to mention all the different package types such as wheels, source
    packages, and binary packages such as eggs, Red Hat `.rpm` files, and Windows
    `.exe`/`.msi` files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到打包时，Python 的历史非常混乱。在 Python 存在的几十年里，我们有过 `distutils`、`distutils2`、`distribute`、`buildout`、`setuptools`、`packaging`、`distlib`、`poetry`
    以及其他几个库。所有这些项目都是出于改善现状的最好意图而开始的，不幸的是，它们的成功程度各不相同。而且，这还不包括所有不同的包类型，如 wheels、源码包和二进制包，如
    eggs、Red Hat `.rpm` 文件和 Windows `.exe`/`.msi` 文件。
- en: The good news is that even though packaging has had a complicated history, things
    have started to settle over the last few years and the situation has improved
    greatly. Building packages has become much easier, and maintaining a stable project
    dependency state is now easily possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，尽管打包有着复杂的历史，但近几年来情况已经有所改善，并且有了很大的进步。构建包变得更加容易，现在维护一个稳定的项目依赖状态也变得容易可行。
- en: Types of packages
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包的类型
- en: 'Python has (had) a whole bunch of package types, but there are only two that
    really matter these days:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有（曾经有）许多种包类型，但如今真正重要的只有两种：
- en: '**Wheels**: These are small, ready-to-install `.zip` files with a `.whl` extension
    that only need extraction as opposed to the building a source package would need.
    Additionally, these can be either source or binary, depending on the package.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wheels**：这些是小型、可直接安装的 `.zip` 文件，扩展名为 `.whl`，只需解压即可，而无需像构建源包那样进行编译。此外，这些可以是源码或二进制，具体取决于包的类型。'
- en: '**Source packages**: These can have many extensions such as `.zip`, `.tar`,
    `.tar.gz`, `.tar.bz2`, `.tar.xz`, and `.tar.Z`. They contain the Python/C/etc.
    source and data files needed to install and build the package.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源码包**：这些可以有许多扩展，例如 `.zip`、`.tar`、`.tar.gz`、`.tar.bz2`、`.tar.xz` 和 `.tar.Z`。它们包含安装和构建包所需的
    Python/C 等 source 和数据文件。'
- en: Now we’ll go into a bit more detail about the formats.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更详细地介绍这些格式。
- en: Wheels – The new eggs
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Wheels – 新的 eggs
- en: For pure Python packages, the source packages have always been enough. For binary
    C/C++ packages, however, it is a much less convenient option. The problem with
    C/C++ source packages is that compilation is needed, which requires not only a
    compiler but often headers and libraries on the system as well. With binary packages,
    you usually don’t need a compiler or any other libraries installed because the
    required libraries are bundled with the package; Python itself is enough.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于纯 Python 包，源码包一直足够使用。然而，对于二进制 C/C++ 包，这却是一个不太方便的选项。C/C++ 源码包的问题在于需要编译，这需要不仅需要一个编译器，还经常需要系统上的头文件和库。而二进制包通常不需要编译器或安装任何其他库，因为所需的库已经包含在包中；Python
    本身就足够了。
- en: Traditionally, Python used the `.egg` format for binary packages. The `.egg`
    format is, in essence, just a renamed `.zip` file containing the source code and
    metadata, and in the case of binary `.egg` files also the compiled binaries. While
    the idea was great, `.egg` files never really solved the problem quite right;
    an `.egg` file could match multiple environments, but that was no guarantee of
    it actually running on those systems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Python 使用 `.egg` 格式用于二进制软件包。`.egg` 格式本质上是一个重命名的 `.zip` 文件，包含源代码和元数据，在二进制
    `.egg` 文件的情况下还包含编译后的二进制文件。虽然这个想法很棒，但 `.egg` 文件从未真正完全解决问题；一个 `.egg` 文件可能匹配多个环境，但这并不能保证它实际上能在那些系统上运行。
- en: That is why the `wheel` format was introduced (`PEP-427`), a package format
    that can contain both source and binary files and can be installed on Windows,
    Linux, macOS X, and other systems without requiring a compiler.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，引入了 `wheel` 格式（`PEP-427`），这是一种可以包含源代码和二进制文件的软件包格式，可以在 Windows、Linux、macOS
    X 和其他系统上安装，而无需编译器。
- en: As an added bonus, wheels can install both pure Python and binary packages more
    quickly because there are no build, install, or post-processing steps and because
    they are smaller. Installing a wheel only requires extracting the `.whl` file
    to the `site-packages` directory of your Python environment and you are done.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，轮子可以更快地安装纯 Python 和二进制软件包，因为没有构建、安装或后处理步骤，并且它们更小。安装轮子只需将 `.whl` 文件提取到
    Python 环境的 `site-packages` 目录，然后您就完成了。
- en: 'The biggest issue binary wheels solve over eggs is the naming of files. With
    wheels, this is done in a simple and consistent way so that checking for the existence
    of a compatible wheel can be done by filename alone. The files use the following
    format:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制轮子相对于蛋文件（eggs）解决的最大问题是文件命名。使用轮子（wheels），这一过程简单且一致，因此仅通过文件名就可以检查是否存在兼容的轮子。文件使用以下格式：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s dive into these fields and look at what their possible values are. But
    first, the syntax. The names between the `{` and `}` parentheses are the fields,
    and the `[` and `]` parentheses indicate an optional field:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些字段，看看它们的可能值。但首先，语法。花括号 `{}` 和 `}` 之间的名称是字段，方括号 `[` 和 `]` 之间的括号表示可选字段：
- en: '`distribution`: The name of the package, e.g. `numpy`, `scipy`, etc.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`分发`: 软件包的名称，例如 `numpy`、`scipy` 等。'
- en: '`version`: The version of the package, e.g. `1.2.3`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`版本`: 该软件包的版本，例如 `1.2.3`。'
- en: '`build tag`: An optional build number as a tie-breaker if multiple wheels match.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`构建标签`: 作为多个匹配轮子的一个可选的区分器。'
- en: '`python tag`: The Python version and platform. In the case of CPython 3.10,
    this would be `cp310`. For PyPy 3.10, this would be `pp310`. You can read more
    about this in `PEP-425`. For pure Python packages, this is either `py3` for Python
    3 support or `py2.py3` for universal packages that support both Python 2 and Python
    3.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python 标签`: Python 版本和平台。对于 CPython 3.10，这将是一个 `cp310`。对于 PyPy 3.10，这将是一个
    `pp310`。更多关于这个话题的信息可以在 `PEP-425` 中找到。对于纯 Python 软件包，这可以是支持 Python 3 的 `py3`，或者支持
    Python 2 和 Python 3 的通用软件包的 `py2.py3`。'
- en: '`abi tag`: The ABI (application binary interface) tag indicates the required
    Python ABI. `cp310d` would be CPython 3.10 with debugging enabled, for example.
    More details can be found in `PEP-3149`. In the case of a pure Python package,
    this is usually `none`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abi 标签`: ABI（应用程序二进制接口）标签表示所需的 Python ABI。例如，`cp310d` 表示启用调试的 CPython 3.10。更多详情可以在
    `PEP-3149` 中找到。对于纯 Python 软件包，这通常是 `none`。'
- en: '`platform tag`: The platform tag tells you the operating systems it will run
    on. This can be `win32` or `win_amd64` for 32-bit or 64-bit Windows respectively.
    For macOS X, this could be something like `macosx_11_0_arm64`. For pure Python
    packages, this is usually `any`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`平台标签`: 平台标签告诉您它将在哪些操作系统上运行。这可以是 32 位或 64 位 Windows 的 `win32` 或 `win_amd64`。对于
    macOS X，这可能类似于 `macosx_11_0_arm64`。对于纯 Python 软件包，这通常是 `any`。'
- en: With all of these different options, you can probably guess that to support
    many platforms you will need many wheels. This is actually a good thing, as it
    solves one of the big issues of egg files, namely that installable files did not
    always work. If you can find a matching wheel for your system, you can expect
    it to work without any issues.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些不同选项中，你可能已经猜到，为了支持许多平台，你需要许多轮子。这实际上是一件好事，因为它解决了蛋文件（egg files）的一个大问题，即可安装文件并不总是能正常工作。如果你能找到适合你系统的匹配轮子，你可以期待它没有任何问题就能运行。
- en: The downside is the build time required for all of these wheels. The `numpy`
    package, for example, has 29 different wheels at the time of writing. Each of
    these wheels takes between 15 and 45 minutes to build, so if we take an average
    of 30 minutes per wheel, we end up with 15 hours of build time for each `numpy`
    release. Naturally, they can be built in parallel, but it is something to take
    into consideration.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些轮子的构建时间是一个缺点。例如，`numpy` 包在写作时拥有 29 个不同的轮子。每个轮子的构建时间在 15 到 45 分钟之间，如果我们按每个轮子平均
    30 分钟来计算，那么每个 `numpy` 发布版本就需要 15 小时的构建时间。当然，它们可以并行构建，但这仍然是一个需要考虑的因素。
- en: Even though we have 29 different wheels available for `numpy`, there is still
    no support for many platforms, such as FreeBSD, so the need for a source package
    also remains.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有 29 个不同的轮子可供 `numpy` 使用，但仍有许多平台，如 FreeBSD，没有支持，因此源包的需求仍然存在。
- en: Source packages
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源包
- en: Source packages are the most versatile out of all the types of Python packages.
    They contain the source, build scripts, and potentially many other files such
    as documentation and tests. These allow you to build and/or compile the package
    for your system. Source packages can have many different extensions, such as `.zip`
    and `.tar.bz2`, but are basically a slightly stripped-down version of the entire
    project directory and related files.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 源包是所有 Python 包类型中最灵活的。它们包含源代码、构建脚本，以及可能包含许多其他文件，如文档和测试。这些允许你在你的系统上构建和/或编译包。源包可能有多种不同的扩展名，如
    `.zip` 和 `.tar.bz2`，但基本上是整个项目目录和相关文件的一个略微精简版本。
- en: Since these packages often contain not only the straight-up source files but
    also tests and documentation, they take up more space and are slower to install
    than wheels. Looking at the source package for `numpy`, for example, I currently
    see 1941 files, whereas the wheel only contains 710 files. This difference can
    actually be useful as well because you might have a use for the test files or
    the documentation. If you wish to skip the binary files because you wish to have
    the original sources or if you want an optimized build for your specific system,
    you can opt for installing the source files by telling `pip` to skip the binary
    files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些包通常不仅包含直接的源文件，还包含测试和文档，因此它们占用的空间更多，安装速度比轮子慢。以 `numpy` 的源包为例，我目前看到有 1941
    个文件，而轮子只包含 710 个文件。这种差异实际上也可能是有用的，因为你可能需要测试文件或文档。如果你希望跳过二进制文件，因为你希望有原始源代码，或者如果你想为你的特定系统进行优化构建，你可以选择通过告诉
    `pip` 跳过二进制文件来安装源文件。
- en: Installing the package from the source instead of the binaries can result in
    a smaller and/or faster binary because it will only link to the libraries available
    on your system instead of being universal.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码而不是二进制文件安装包可以导致二进制文件更小和/或更快，因为它只会链接到系统上可用的库，而不是通用库。
- en: 'The `psycopg` package for connecting to PostgreSQL databases is a good example
    of this. It offers three possible installation options to install through `pip`
    in descending order of preference:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 PostgreSQL 数据库的 `psycopg` 包是这方面的一个好例子。它提供了三种可能的安装选项，通过 `pip` 安装，优先级从高到低：
- en: '`psycopg[c]`: Both the Python and the C source files for building and compiling
    locally'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psycopg[c]`: 用于本地构建和编译的 Python 和 C 源代码'
- en: '`psycopg[binary]`: The Python source and precompiled binaries'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psycopg[binary]`: Python 源代码和预编译的二进制文件'
- en: '`psycopg`: The Python source only; in this case, you need to have the `libpq`
    library installed on your system, which is accessed through `ctypes`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psycopg`: 仅 Python 源代码；在这种情况下，你需要在你的系统上安装 `libpq` 库，它通过 `ctypes` 访问'
- en: 'To install without any pre-compiled binaries:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装而不使用任何预编译的二进制文件：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since a source package comes with a build script, the installation alone can
    already be dangerous. While a wheel will only unpack and not run anything, a source
    package will execute the build scripts during installation. At one point, there
    was even a Russian Roulette package on PyPI that would have a 1/6 chance of deleting
    files on your system during installation to illustrate the dangers of this approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于源包附带构建脚本，仅安装本身就可能存在风险。虽然轮子只会解压而不会运行任何内容，但源包在安装过程中会执行构建脚本。曾经有一个名为俄罗斯轮盘赌的包在
    PyPI 上，安装时会有 1/6 的几率删除系统上的文件，以此来展示这种方法的危险性。
- en: I personally think the security risk of executing build scripts during installion
    is of much less importance than vetting a package before you even plan to install
    it. Installing potentially malicious packages on your system is a bad idea, whether
    or not you actually execute the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人认为，在安装过程中执行构建脚本的安全风险远不如在计划安装之前对包进行审查重要。无论您是否实际执行代码，在您的系统上安装可能有害的包都是一件坏事。
- en: Package tools
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包工具
- en: So, what tools do we still need and use for installation these days?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们今天还需要和使用的安装工具是什么？
- en: The `distribute`, `distutils`, and `distutils2` packages have largely been replaced
    by `setuptools`. To install a `setup.py` based source package, you usually need
    `setuptools`, and `setuptools` comes bundled with `pip`, so that is a requirement
    you should already have available. When it comes to installing wheels, you need
    the `wheel` package; this is also conveniently bundled with `pip`. On most systems,
    this means that you should have everything you need to install extra packages
    once Python is installed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`distribute`、`distutils`和`distutils2`包已被`setuptools` largely取代。要安装基于`setup.py`的源包，通常需要`setuptools`，而`setuptools`与`pip`捆绑在一起，因此您应该已经具备了这个要求。当涉及到安装wheel时，需要`wheel`包；这也方便地捆绑在`pip`中。在大多数系统上，这意味着一旦安装了Python，您就应该拥有安装额外包所需的一切。'
- en: 'The Ubuntu Linux distribution is unfortunately a notable exception which ships
    with a mutilated Python installation that lacks both the `pip` and `ensurepip`
    commands. This can be fixed by installing `pip` separately using:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Ubuntu Linux发行版是一个值得注意的例外，它附带了一个损坏的Python安装，缺少`pip`和`ensurepip`命令。这可以通过单独安装`pip`来修复：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If that does not work, you can always install `pip` by running the `get-pip.py`
    script: [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不起作用，您可以通过运行`get-pip.py`脚本安装`pip`：[https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py)
- en: 'Since `setuptools` and `pip` have seen quite a lot of development over the
    last few years, it might be a good idea to upgrade these packages in any case:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`setuptools`和`pip`在过去几年中已经得到了相当多的开发，因此无论如何升级这些包都是一个好主意：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have all the prerequisites installed, we can continue with building
    our own packages.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有先决条件，我们可以继续构建自己的包。
- en: Package versioning
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包版本控制
- en: While there are many versioning schemes available, many Python packages, and
    Python itself, use PEP-440 for the version specifications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有众多版本控制方案可用，但许多Python包以及Python本身都使用PEP-440进行版本规范。
- en: Some people adhere to the slightly stricter version called **semantic versioning**
    (**SemVer**), but the two are largely compatible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人坚持使用稍微严格一点的版本，称为**语义版本控制**（**SemVer**），但两者在很大程度上是兼容的。
- en: 'The short and simplified explanation is that version numbers such as `1.2`
    or `1.2.3` are used. For instance, looking at version `1.2.3`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 简短而简化的解释是使用如 `1.2` 或 `1.2.3` 这样的版本号。例如，查看版本 `1.2.3`：
- en: '`1` is the major version and indicates API-breaking incompatible changes'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 是主版本，表示破坏API的不兼容更改'
- en: '`2` is the minor version and indicates backward-compatible functionality addition'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` 是次要版本，表示向后兼容的功能添加'
- en: '`3` is the patch version, which is used for backward-compatible bugfixes'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3` 是补丁版本，用于向后兼容的bug修复'
- en: In the case of major versions, some libraries opt for making the versions non-contiguous
    and use dates for the versions, such as `2022.5`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在主版本的情况下，一些库选择使版本非连续，并使用日期作为版本，例如 `2022.5`。
- en: Pre-releases such as alphas and betas can be specified through the minor version
    with letters. The options are `a` for alpha, `b` for beta, and `rc` for release
    candidate. This results in `1.2a3` for `1.2 alpha 3`, for instance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 预发布版本，如alpha和beta，可以通过次要版本中的字母来指定。选项有 `a` 表示alpha，`b` 表示beta，`rc` 表示发布候选。例如，对于
    `1.2 alpha 3`，结果是 `1.2a3`。
- en: In the case of semantic versioning, this is handled by adding a pre-release
    identifier to the end, such as `1.2.3-beta` or `1.2.3-beta.1` for multiple betas.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在语义版本控制的情况下，这通过在末尾添加预发布标识符来处理，例如 `1.2.3-beta` 或 `1.2.3-beta.1` 用于多个beta版本。
- en: Lastly, PEP-440 allows the use of post-releases using `1.2.post3` instead of
    `1.2.3` for minor bugfixes, and similarly `1.2.dev2` for development releases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，PEP-440 允许使用后发布版本，例如使用 `1.2.post3` 代替 `1.2.3` 进行次要bug修复，以及类似地使用 `1.2.dev2`
    进行开发版本。
- en: Whichever versioning system you use, think about it carefully before starting
    your project. Not taking the future into account can certainly cause problems
    in the long run. An example of this is Windows. Some applications had trouble
    supporting Windows 10 because an alphabetical sort of version number puts Windows
    10 below Window 8 (after all, 1 is smaller than 8).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种版本控制系统，在开始你的项目之前都要仔细考虑。不考虑未来可能会在长期内造成问题。一个例子是 Windows。一些应用程序在支持 Windows
    10 时遇到了麻烦，因为版本号的字母顺序将 Windows 10 放在 Windows 8 之下（毕竟，1 小于 8）。
- en: Building packages
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建包
- en: Python packages were traditionally built using a `setup.py` file that contained
    (part of) the build script. This method usually depends on `setuptools` and is
    still the standard for most packages, but we have easier methods available these
    days. If your project is not too demanding, you can use a small `pyproject.toml`
    file instead, which can be much easier to maintain.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包传统上使用包含（部分）构建脚本的 `setup.py` 文件进行构建。这种方法通常依赖于 `setuptools`，并且仍然是大多数包的标准，但如今我们有更简单的方法可用。如果你的项目要求不高，你可以使用一个小的
    `pyproject.toml` 文件，这可能会更容易维护。
- en: Let’s give both methods a try and see how easy it is to build a basic Python
    package.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试这两种方法，看看构建一个基本的 Python 包有多容易。
- en: Packaging using pyproject.toml
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pyproject.toml 进行打包
- en: The `pyproject.toml` file allows for really easy packaging depending on the
    tooling used. It was introduced in 2015 through `PEP-517` and `PEP-518`. This
    method was created to improve upon the `setup.py` file by introducing build-time
    dependencies, automatic configuration, and making it easier to work in a DRY (Don’t
    Repeat Yourself) manner.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyproject.toml` 文件允许根据所使用的工具轻松地进行打包。它是在 2015 年通过 `PEP-517` 和 `PEP-518` 引入的。这种方法是为了改进
    `setup.py` 文件而创建的，通过引入构建时依赖项、自动配置，并使其更容易以 DRY（不要重复自己）的方式工作。'
- en: TOML stands for “Tom’s Obvious, Minimal Language” and is somewhat comparable
    to YAML and INI files, but a bit simpler. Since it is such a simple language,
    it can easily be included in packages such as `pip` with little overhead. This
    makes it perfect for scenarios where you need a flat structure and have no need
    for complicated features such as inheritance and includes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: TOML 代表“Tom 的明显、最小化语言”，在某种程度上与 YAML 和 INI 文件相似，但更简单。由于它是一种如此简单的语言，它可以很容易地包含在像
    `pip` 这样的包中，几乎没有开销。这使得它在需要扁平结构且不需要复杂功能（如继承和包含）的场景中非常完美。
- en: Before we continue, we need to clarify a few things. When we talk about the
    `setup.py` file, we are often actually talking about the `setuptools` library
    instead. The `distutils` library, which is bundled with Python, can be used as
    well, but since `pip` depends on `setuptools` it is often the better option; it
    has more features, and updates together with `pip` instead of with your Python
    installation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要澄清一些事情。当我们谈论 `setup.py` 文件时，我们通常实际上是在谈论 `setuptools` 库。与 Python
    打包在一起的 `distutils` 库也可以使用，但由于 `pip` 依赖于 `setuptools`，它通常是更好的选择；它具有更多功能，并且与 `pip`
    一起更新，而不是与你的 Python 安装一起更新。
- en: Similar to how `setup.py` usually means `setuptools`, with `pyproject.toml`
    we also have multiple libraries available for building and managing `PEP-517`
    style packages. This approach to creating a standard and relying on community
    projects for the implementations has worked quite well for Python in the past,
    which makes it a sound choice. An example of this approach is the Python Web Server
    Gateway Interface (WSGI), which was introduced as `PEP-333` and currently has
    several great implementations available.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `setup.py` 通常意味着 `setuptools`，使用 `pyproject.toml` 我们也有多个库可用于构建和管理 `PEP-517`
    风格的包。这种方法创建标准并依赖社区项目进行实现，在 Python 中过去已经工作得相当好，这使得它是一个明智的选择。这种方法的例子是 Python 网络服务器网关接口（WSGI），它作为
    `PEP-333` 引入，目前有几种优秀的实现可用。
- en: The reference solution for `PEP-517` is the `pep517` library, which works but
    is rather limited. Another option is the `build` library, which is maintained
    by the Python Package Authority (PyPA), which also maintains the Python Package
    Index (PyPI). While that library works, it is also really limited in terms of
    features and not an option I would recommend either.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`PEP-517` 的参考解决方案是 `pep517` 库，它虽然可用但功能相当有限。另一个选择是 `build` 库，由 Python 包权威机构（PyPA）维护，它也维护了
    Python 包索引（PyPI）。虽然这个库可用，但在功能方面也相当有限，我并不推荐使用。'
- en: 'The best option by far, in my opinion, is the `poetry` tool. The `poetry` tool
    not only handles the building of packages for you but also takes care of:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，最好的选择无疑是 `poetry` 工具。`poetry` 工具不仅为你处理包的构建，还负责：
- en: Fast installing of dependencies in parallel
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行快速安装依赖项
- en: Creating virtual environments
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: Creating easy access points for runnable scripts
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为可运行的脚本创建易于访问的入口点
- en: Managing dependencies by specifying smart version constraints (for example,
    major and minor versions, covered in detail later in this chapter)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定智能版本约束（例如，主版本和次版本，将在本章后面详细说明）来管理依赖项
- en: Building packages
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建包
- en: Publishing to PyPI
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到 PyPI
- en: Handling multiple Python versions using `pyenv`
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pyenv` 处理多个 Python 版本
- en: For most cases, `pyproject.toml` can replace the traditional `setup.py` files
    completely, but there are a few cases where you will need some extra tools.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，`pyproject.toml` 可以完全替代传统的 `setup.py` 文件，但也有一些情况你需要一些额外的工具。
- en: In the case of building C/C++ extensions and others, you either need a `setup.py`
    file or to specify how to build the extensions some other way. One option for
    this is to use the `poetry` tool and add a build script to the `pyproject.toml`
    tool. We will discuss this more later on, in the section about C/C++ extensions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 C/C++ 扩展和其他情况时，你可能需要一个 `setup.py` 文件或以其他方式指定如何构建扩展。这个选项之一是使用 `poetry` 工具并将构建脚本添加到
    `pyproject.toml` 工具中。我们将在关于 C/C++ 扩展的部分进一步讨论这个问题。
- en: Editable installs (i.e. `pip install -e ...`) were not possible until 2021,
    but that has been remedied by PEP-660.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可编辑安装（即 `pip install -e ...`）直到 2021 年才成为可能，但已被 PEP-660 解决。
- en: Creating a basic package
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个基本包
- en: 'Let’s start by using `poetry` to create a basic `pyproject.toml` file in our
    current directory:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用 `poetry` 在当前目录中创建一个基本的 `pyproject.toml` 文件开始：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since our parent directory is called `t_00_basic_pyproject`, `poetry` automatically
    makes that the new project name. Alternatively, you can also do `poetry new some_project_name`
    and it will create a directory for you.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的父目录名为 `t_00_basic_pyproject`，`poetry` 自动将其作为新项目名称。或者，你也可以执行 `poetry new
    some_project_name`，它将为你创建一个目录。
- en: 'The `poetry` command created the following files for us:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`poetry` 命令为我们创建了以下文件：'
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is very simple boilerplate that contains enough to get your project started.
    The `t_00_basic_pyproject/__init__.py` file contains the version (which defaults
    to `0.1.0`) and the `tests/test_t_00_basic_pyproject.py` file tests for this version
    as an example test. The more interesting part is the `pyproject.toml` file, however,
    so let’s look at that now:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的模板，包含足够的内容来启动你的项目。`t_00_basic_pyproject/__init__.py` 文件包含版本（默认为 `0.1.0`）和
    `tests/test_t_00_basic_pyproject.py` 文件作为示例测试来测试这个版本。然而，更有趣的部分是 `pyproject.toml`
    文件，所以现在让我们看看它：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, `poetry` has automatically configured the name and version.
    It also added me as an author by looking at the `git` config on my system. You
    can easily configure this yourself by running these commands:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`poetry` 已经自动配置了名称和版本。它还通过查看我的系统上的 `git` 配置将我添加为作者。你可以通过运行以下命令轻松配置：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next up, we can see that it automatically set Python 3.10 as a requirement and
    added `pytest` 5.2 as a development dependency. For building the package, it added
    `poetry-core` as a dependency, which is the `poetry` equivalent of `setuptools`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到它自动将 Python 3.10 设置为要求，并添加 `pytest` 5.2 作为开发依赖项。对于构建包，它添加了 `poetry-core`
    作为依赖项，这是 `poetry` 的 `setuptools` 等价物。
- en: Installing packages for development
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装开发包
- en: For development purposes, we usually install a package in **editable mode**.
    In editable mode, the package is not copied to your `site-packages` directory,
    but a link is made to your source directory so all changes to your source directory
    apply immediately. Without editable mode, you would have to do a `pip install`
    every time you made a change to your package, which is very inconvenient for development.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发目的，我们通常以 **可编辑模式** 安装包。在可编辑模式下，包不会被复制到你的 `site-packages` 目录，而是创建到你的源目录的链接，因此所有对源目录的更改都会立即生效。如果没有可编辑模式，每次你对包进行更改时，你都需要执行
    `pip install`，这对于开发来说非常不方便。
- en: 'With `pip`, you can install in editable mode with the command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pip`，你可以通过以下命令以可编辑模式安装：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For installing in the current directory, you can use `.` as the directory,
    resulting in:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在当前目录中安装，你可以使用 `.` 作为目录，结果如下：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the `poetry` command, installing in editable mode (or something similar
    for older versions of `poetry`) happens automatically. It also handles the creation
    of a virtual environment for us while making use of `pyenv` for the Python version
    specified in the `pyproject.toml` file. To install the package and all of its
    requirements, you only need to run:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `poetry` 命令，以可编辑模式安装（或对于 `poetry` 的旧版本，可能是类似的功能）会自动发生。它还为我们处理虚拟环境的创建，同时使用
    `pyenv` 来处理 `pyproject.toml` 文件中指定的Python版本。要安装包及其所有依赖项，您只需运行：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you wish to have direct access to all of the commands in the virtual environment
    created, you can use:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望直接访问创建的虚拟环境中的所有命令，您可以使用：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `poetry shell` command spawns a new shell with the name of the current project
    added to your command-line prefix and with the virtual environment scripts directory
    added to your `PATH` environment variable. This results in commands such as `python`
    and `pip` executing within your virtual environment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`poetry shell` 命令会启动一个新的shell，将当前项目的名称添加到您的命令行前缀中，并将虚拟环境脚本目录添加到您的 `PATH` 环境变量中。这会导致
    `python` 和 `pip` 等命令在您的虚拟环境中执行。'
- en: Adding code and data
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加代码和数据
- en: 'In the basic example, we didn’t have anything specifying which directory contains
    the source or that the `t_00_basic_pyproject` directory has to be included in
    the directory. By default, that is handled implicitly, but we can modify the `pyproject.toml`
    file to explicitly include directories or file patterns as the Python source:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本示例中，我们没有指定哪个目录包含源代码，或者 `t_00_basic_pyproject` 目录必须包含在目录中。默认情况下，这会隐式处理，但我们可以修改
    `pyproject.toml` 文件来显式包含目录或文件模式作为Python源：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that adding the `packages` argument disables the automatic detection of
    packages, so you will need to specify all included packages at this point.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，添加 `packages` 参数会禁用自动检测包，因此您需要在此处指定所有包含的包。
- en: 'To include other data files such as documentation, we can use the `include`
    and `exclude` parameters. The `exclude` parameter overrides the files included
    by the `packages` argument:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含其他数据文件，例如文档，我们可以使用 `include` 和 `exclude` 参数。`exclude` 参数会覆盖由 `packages` 参数包含的文件：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For a basic project, you might not need to look at this. But, as always, explicit
    is better than implicit, so I recommend that you do take a quick look to prevent
    unwanted surprises where the wrong files are accidentally included in your package.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个基本项目，您可能不需要查看这个。但，就像往常一样，明确总是优于隐式，所以我建议您快速查看一下，以防止意外地将错误的文件包含在您的包中。
- en: Adding executable commands
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加可执行命令
- en: Some packages such as `numpy` are libraries only, meaning they are imported
    but have no runnable commands. Other packages such as `pip` and `poetry` contain
    runnable scripts which are installed as new commands during installion. After
    all, when the `poetry` package is installed, you can use the `poetry` command
    from your shell.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包，如 `numpy`，仅是库，这意味着它们被导入但没有可运行的命令。其他包，如 `pip` 和 `poetry`，包含可运行的脚本，在安装过程中作为新命令安装。毕竟，当
    `poetry` 包被安装后，您可以从shell中使用 `poetry` 命令。
- en: 'To create our own commands, we need to specify the name of the new command,
    the module, and the corresponding function, so `poetry` will know what to run.
    For example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们自己的命令，我们需要指定新命令的名称、模块和相应的函数，这样 `poetry` 就会知道要运行什么。例如：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This would execute the `run()` function in a file called `T_00_basic_pyproject/main.py`.
    After installing the package, you could execute `our_command` from your shell
    to run the script. During development with `poetry`, you can use `poetry run our_command`,
    which automatically runs the command in the `poetry`-created virtual environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行名为 `T_00_basic_pyproject/main.py` 的文件中的 `run()` 函数。安装包后，您可以从您的shell中执行 `our_command`
    来运行脚本。在 `poetry` 开发期间，您可以使用 `poetry run our_command`，这将自动在 `poetry` 创建的虚拟环境中运行命令。
- en: Managing dependencies
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: 'The `pyproject.toml` file we created already had a few requirements for both
    development and building, but you might also want to add other dependencies to
    your project. For example, if we wanted to add a progress bar we could run the
    following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 `pyproject.toml` 文件已经为开发和构建添加了一些要求，但您可能还想向项目中添加其他依赖项。例如，如果我们想添加进度条，我们可以运行以下命令：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This automatically installs the `progressbar2` package for us and adds it to
    the `pyproject.toml` file like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这会自动为我们安装 `progressbar2` 包，并将其添加到 `pyproject.toml` 文件中，如下所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Additionally, `poetry` will create or update a `poetry.lock` file, which contains
    the exact package versions that are installed, so an installation in a new environment
    can easily be reproduced. In the case above, we simply told `poetry` to install
    any version of `progressbar2` which resulted in `poetry` setting the version requirement
    to `^4.0.0`, but we can relax those requirements so `poetry` will automatically
    install the latest patch, minor, or major version of the package.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，`poetry` 将创建或更新一个 `poetry.lock` 文件，其中包含已安装的确切包版本，因此在新环境中可以轻松地重现安装。在上面的例子中，我们只是告诉
    `poetry` 安装 `progressbar2` 的任何版本，这导致 `poetry` 将版本要求设置为 `^4.0.0`，但我们也可以放宽这些要求，这样
    `poetry` 将自动安装包的最新补丁、小版本或主要版本。 '
- en: By default, `poetry` will add the dependencies to the `[tool.poetry.dependencies]`
    section, but you can also add them as development dependencies using the `--dev`
    or `-D` command-line arguments. If you want to add other types of dependencies
    such as the `build-system` dependencies or test dependencies, you will need to
    manually edit the `pyproject.toml` file, however.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`poetry` 将将依赖项添加到 `[tool.poetry.dependencies]` 部分，但您也可以使用 `--dev` 或 `-D`
    命令行参数将它们添加为开发依赖项。如果您想添加其他类型的依赖项，例如 `build-system` 依赖项或测试依赖项，那么您需要手动编辑 `pyproject.toml`
    文件。
- en: 'The version specifiers expect SemVer-compatible versions and work as follows.
    For allowing newer non-major versions, you can use the caret (`^`). This looks
    at the first non-zero number, so the behavior of `^1.2.3` is different from `^0.1.2`,
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 版本指定符期望与 SemVer 兼容的版本，并按以下方式工作。为了允许更新非主要版本，您可以使用连字符 (`^`)。它查看第一个非零数字，因此 `^1.2.3`
    的行为与 `^0.1.2` 不同，如下所示：
- en: '`^1.2.3` means `>=1.2.3` and `<2.0.0`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^1.2.3` 表示 `>=1.2.3` 且 `<2.0.0`'
- en: '`^1.2` means `>=1.2.0` and `<2.0.0`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^1.2` 表示 `>=1.2.0` 且 `<2.0.0`'
- en: '`^1` means `>=1.0.0` and `<2.0.0`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^1` 表示 `>=1.0.0` 且 `<2.0.0`'
- en: '`^0.1.2` means `>=0.1.2` and `<0.2.0`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^0.1.2` 表示 `>=0.1.2` 且 `<0.2.0`'
- en: 'Next up are the tilde (`~`) requirements, which specify the minimal version
    but allow for minor updates. They are a bit simpler than the caret versions and
    effectively specify what the number should start with:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是波浪号 (`~`) 要求，它们指定了最小版本，但允许进行小版本更新。它们比连字符版本简单一些，实际上指定了数字应该从哪里开始：
- en: '`~1.2.3` means `>=1.2.3` and `<1.3.0.`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~1.2.3` 表示 `>=1.2.3` 且 `<1.3.0>`'
- en: '`~1.2` means `>=1.2.0` and `<1.3.0.`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~1.2` 表示 `>=1.2.0` 且 `<1.3.0>`'
- en: '`~1` means `>=1.0.0` and `<2.0.0`. Note that the two options above both allow
    minor version updates, and this is the only one that allows major version updates.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~1` 表示 `>=1.0.0` 且 `<2.0.0`。请注意，上述两个选项都允许进行小版本更新，而这是唯一允许进行主要版本更新的选项。'
- en: 'Wildcard requirements are also possible using an asterisk (`*`):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用星号 (`*`) 也可以进行通配符要求：
- en: '`1.2.*` means `>=1.2.0` and `<1.3.0`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.2.*` 表示 `>=1.2.0` 且 `<1.3.0`'
- en: '`1.*` means `>=1.0.0` and `<2.0.0`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.*` 表示 `>=1.0.0` 且 `<2.0.0`'
- en: 'The versioning system is compatible with the format used by `requirements.txt`
    as well, which allows for versions such as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统与 `requirements.txt` 中使用的格式兼容，允许使用如下版本：
- en: '`>= 1.2.3`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>= 1.2.3`'
- en: '`>= 1.2.3, <1.4.0`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>= 1.2.3, <1.4.0`'
- en: '`>= 1.2.3, <1.4.0, != 1.3.0`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>= 1.2.3, <1.4.0, != 1.3.0`'
- en: '`!= 1.5.0`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!= 1.5.0`'
- en: I personally prefer this last syntax since it’s clear and doesn’t require much
    prior knowledge, but you are free to use whichever you prefer. By default, `poetry`
    will use a `^1.2.3` format when adding dependencies.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人更喜欢这种最后的语法，因为它很清晰，不需要太多的先验知识，但您当然可以使用您喜欢的任何一种。默认情况下，`poetry` 在添加依赖项时会使用 `^1.2.3`
    格式。
- en: Now, let’s say we have a requirement like `progressbar2 = "^3.5"` and we have
    version `3.5.0` in our `poetry.lock` file. If we run `poetry install`, it will
    install exactly version `3.5.0` because we know that version to be good.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个类似 `progressbar2 = "^3.5"` 的要求，并且我们在 `poetry.lock` 文件中有 `3.5.0` 版本。如果我们运行
    `poetry install`，它将安装确切的 `3.5.0` 版本，因为我们知道这个版本是好的。
- en: 'As a developer, you might want to update that dependency to a newer version
    so you can test if newer versions also work. This is also something we can ask
    of `poetry`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，您可能希望将那个依赖项更新到新版本，以便测试新版本是否也能正常工作。这也是我们可以向 `poetry` 提出的要求：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now `poetry` will automatically upgrade the package and update the `poetry.lock`
    file within the constraints of `pyproject.toml`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `poetry` 将会自动在 `pyproject.toml` 的约束范围内升级包并更新 `poetry.lock` 文件。
- en: Building the package
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建包
- en: 'Now that we have our `pyproject.toml` file configured and the dependencies
    we want, we can build the package. This is trivially easy using `poetry`, luckily.
    Building the package takes a single command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了 `pyproject.toml` 文件和所需的依赖项，我们可以使用 `poetry` 构建包。幸运的是，这非常简单。构建包只需要一个命令：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With just that single command, `poetry` created a source package and a wheel
    for us. So, if you have been keeping track, you’ll realize we can essentially
    create and build a package with just two commands: `poetry new` and `poetry build`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一个命令，`poetry` 就为我们创建了一个源包和一个 wheel。所以，如果您一直在关注，您会意识到我们实际上可以用两个命令创建和构建一个包：`poetry
    new` 和 `poetry build`。
- en: Building C/C++ extensions
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 C/C++ 扩展
- en: Before we start with this section, I need to provide a little disclaimer. Building
    C/C++ extensions is at the time of writing (the end of 2021) not a stable and
    supported feature by `poetry`, which means it could be replaced by a different
    mechanism in the future. For the time being, however, there is a working solution
    available for building C/C++ extensions and future versions are likely to work
    in a similar fashion.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始本节之前，我需要提供一点免责声明。截至撰写本文时（2021 年底），构建 C/C++ 扩展并不是 `poetry` 的稳定和受支持的功能，这意味着它将来可能会被不同的机制所取代。然而，目前有一个可用的解决方案用于构建
    C/C++ 扩展，并且未来的版本可能会以类似的方式工作。
- en: If you are looking for a stable and well-supported solution right now, I would
    suggest going with a `setup.py` based project instead as covered later in this
    chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在正在寻找一个稳定且受良好支持的解决方案，我建议您选择基于 `setup.py` 的项目，这将在本章后面进行介绍。
- en: 'We need to start by modifying our `pyproject.toml` file and adding the following
    line to the `[tool.poetry]` section:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先修改我们的 `pyproject.toml` 文件，并在 `[tool.poetry]` 部分添加以下行：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Make sure you don’t name the file `build.py` if you ever wish to use the PyPA
    build command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用 PyPA 构建命令，请确保不要将文件命名为 `build.py`。
- en: 'Once this is done, `poetry` will execute the `build_extension.py` file when
    we run `poetry build`, so now we need to create the `build_extension.py` file
    so `setuptools` can build the extension for us:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，当我们运行 `poetry build` 时，`poetry` 将会执行 `build_extension.py` 文件，因此现在我们需要创建
    `build_extension.py` 文件，以便 `setuptools` 为我们构建扩展：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This script is largely the same as what you would put in the `setup.py` file.
    The reason for this is that it’s actually injecting into the same function call.
    If you look carefully at the `build()` function, you will see that it updates
    `setup_kwargs` and sets the `ext_modules` item within that. That argument is fed
    to the `setuptools.setup()` function verbatim. Essentially, we are just emulating
    the use of a `setup.py` file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本基本上与您会放入 `setup.py` 文件中的内容相同。原因是它实际上是在注入相同的函数调用。如果您仔细查看 `build()` 函数，您会看到它更新了
    `setup_kwargs` 并在该函数中设置了 `ext_modules` 项。该参数直接传递给 `setuptools.setup()` 函数。本质上，我们只是在模拟使用
    `setup.py` 文件。
- en: Note that for our C file we used the `sum_of_squares.c` file from *Chapter 17,*
    *Extensions in C/C++, System Calls, and C/C++ Libaries*. You will see that the
    rest of the code largely resembles the `setup.py` file we used in *Chapter 17*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于我们的 C 文件，我们使用了来自 *第 17 章*，*C/C++ 扩展、系统调用和 C/C++ 库* 的 `sum_of_squares.c`
    文件。您会看到其余的代码在很大程度上与我们在 *第 17 章* 中使用的 `setup.py` 文件相似。
- en: 'When we execute the `poetry build` command, `poetry` will automatically call
    `setuptools` internally and build the binary wheel:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `poetry build` 命令时，`poetry` 将会内部调用 `setuptools` 并构建二进制轮：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With that, we are done. We now have a wheel file containing the built C extension.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了。我们现在有一个包含构建的 C 扩展的 wheel 文件。
- en: Packaging using setuptools with setup.py or setup.cfg
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 setuptools 和 setup.py 或 setup.cfg 打包
- en: The `setup.py` file is the traditional method of building Python packages, but
    is still used quite extensively and is a very flexible method of creating packages.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py` 文件是构建 Python 包的传统方法，但仍然被广泛使用，并且是一种创建包的非常灵活的方法。'
- en: '*Chapter 17* has already shown us a couple of examples when building extensions,
    but let’s reiterate and review what the most important parts actually do. The
    core function you will be using in this entire chapter is `setuptools.setup()`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 17 章* 已经向我们展示了构建扩展时的几个示例，但让我们重申并回顾一下实际上最重要的部分做了什么。您将在整个章节中使用的核心函数是 `setuptools.setup()`。'
- en: The `distutils` package bundled with Python will be sufficient as well in most
    cases, but I recommend `setuptools` regardless. The `setuptools` package has many
    great features that `distutils` lacks and nearly all Python environments will
    have `setuptools` available as it is included with `pip`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Python附带的标准`distutils`包在大多数情况下也足够使用，但我仍然推荐使用`setuptools`。`setuptools`包具有许多`distutils`所缺乏的出色功能，并且由于它包含在`pip`中，几乎所有的Python环境都会提供`setuptools`。
- en: 'Before we continue, it is always a good idea to make sure you have the latest
    version of `pip`, `wheel`, and `setuptools`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，确保您拥有`pip`、`wheel`和`setuptools`的最新版本总是一个好主意：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `setuptools` and `distutils` packages have changed significantly over the
    last few years and the documentation/examples written before 2014 are most likely
    out of date. Be careful not to implement deprecated examples, and I would recommend
    skipping any documentation/examples using `distutils`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools`和`distutils`包在过去几年中发生了显著变化，2014年之前编写的文档/示例很可能已经过时。请小心不要实现已弃用的示例，并且我建议跳过任何使用`distutils`的文档/示例。'
- en: As an alternative or addition to the `setup.py` file, you can also configure
    all metadata using a `setup.cfg` file. This uses the INI format and can be a bit
    more convenient for simple metadata where you do not need (or want) the overhead
    of the Python syntax.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`setup.py`文件的替代或补充，您还可以使用`setup.cfg`文件来配置所有元数据。这使用INI格式，对于不需要（或不想）Python语法开销的简单元数据来说可能更方便一些。
- en: 'You can even choose to use `setup.cfg` alone and skip `setup.py`; however,
    if you did, you would need a separate building utility. For those cases, I would
    recommend installing PyPA’s `build` library:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以选择仅使用`setup.cfg`并跳过`setup.py`；然而，如果您这样做，您将需要一个单独的构建工具。对于这些情况，我建议安装PyPA的`build`库：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating a basic package
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个基本包
- en: 'Now that we have all the prerequisites, let’s create a package using a `setup.py`
    file. While the most basic `setuptools.setup()` call technically doesn’t require
    any parameters, you should really include at least the `name`, `version`, `packages`,
    `url`, `author`, and `author_email` fields if you plan to publish the package
    to PyPI. Here’s a really basic example containing these fields:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了所有先决条件，让我们使用`setup.py`文件创建一个包。虽然最基础的`setuptools.setup()`调用在技术上不需要任何参数，但如果您计划将包发布到PyPI，您确实应该包括至少`name`、`version`、`packages`、`url`、`author`和`author_email`字段。以下是一个包含这些字段的非常基础的示例：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As an alternative to configuring these as `setup()` parameters, you can also
    use a `setup.cfg` file, which uses the INI format but works in effectively the
    same way:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为将这些配置为`setup()`参数的替代方案，您还可以使用一个`setup.cfg`文件，它使用INI格式，但实际工作方式与之前相同：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The main advantage of `setup.cfg` is that it is a more concise and simpler file
    format than the `setup.py` file is. Take a look at the `packages` section, for
    example; `setuptools.find_packages()` is quite a bit more verbose than `find:`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.cfg`的主要优势是它比`setup.py`文件更简洁、更简单的文件格式。例如，看看`packages`部分；`setuptools.find_packages()`比`find:`要详细得多。'
- en: The downside is that you need to pair a `setup.cfg` file with either a `setup.py`
    or `pyproject.toml` file to be able to build it. `setup.cfg` alone is not enough
    for a package, which makes `setup.cfg` a nice and clean way to separate your metadata
    from your setup code. Additionally, many libraries such as `pytest` and `tox`
    have native support for the `setup.cfg` file, so these can be configured through
    the file as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是您需要将一个`setup.cfg`文件与一个`setup.py`或`pyproject.toml`文件配对，才能构建它。仅凭`setup.cfg`本身不足以构建一个包，这使得`setup.cfg`成为将元数据与设置代码分离的一种既简洁又清晰的方式。此外，许多库如`pytest`和`tox`都原生支持`setup.cfg`文件，因此您也可以通过该文件进行配置。
- en: 'To pair `setup.cfg` and/or `setup.py` with a `pyproject.toml` file, we need
    to add these lines to the `pyproject.toml` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`setup.cfg`和/或`setup.py`与`pyproject.toml`文件配对，我们需要将这些行添加到`pyproject.toml`文件中：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that a `pyproject.toml` file by itself won’t give you `poetry` support;
    for `poetry` support, you need to add a `[tool.poetry]` section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仅凭一个`pyproject.toml`文件本身并不能为您提供`poetry`支持；为了获得`poetry`支持，您需要添加一个`[tool.poetry]`部分。
- en: Installing the package for development
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装开发版本的包
- en: To install the package for local development, we can once again use the `-e`
    or `--editable` flag, as explained in the `poetry` section of this chapter. This
    installs a link from your source directory to the `site-packages` directory so
    the actual source is used, instead of having `setuptools` copy all of the source
    files to the `site-packages` directory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装用于本地开发的包，我们可以再次使用 `-e` 或 `--editable` 标志，如本章中 `poetry` 部分所述。这将在你的源目录和 `site-packages`
    目录之间创建一个链接，以便实际使用源文件，而不是让 `setuptools` 将所有源文件复制到 `site-packages` 目录。
- en: 'In short, from the project directory you can either use the `setup.py` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，从项目目录中，你可以使用 `setup.py` 文件：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or `pip`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 `pip`：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Adding packages
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加包
- en: 'In the basic example, you could see that we used `find_packages()` as the argument
    for packages. This automatically detects all source directories and is usually
    fine as a default, but sometimes you need more control. The `find_packages()`
    function also allows you to add an `include` or `exclude` parameter if you wish
    to exclude tests and other files from the package, like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本示例中，你可以看到我们使用 `find_packages()` 作为包的参数。这个函数会自动检测所有源目录，通常作为默认值是足够的，但有时你需要更多的控制。`find_packages()`
    函数还允许你添加 `include` 或 `exclude` 参数，如果你希望从包中排除测试和其他文件，例如这样：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The arguments to `find_packages()` can also be translated to a `setup.cfg`
    file with a slightly different syntax:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_packages()` 的参数也可以翻译到具有不同语法的 `setup.cfg` 文件中：'
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Adding package data
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加包数据
- en: In most scenarios, you probably won’t have to include the package data such
    as test data or documentation files, but there are cases where you need extra
    files. Web applications, for example, might come bundled with `html`, `javascript`,
    and `css` files.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你可能不需要包含包数据，例如测试数据或文档文件，但有些情况下需要额外的文件。例如，Web 应用程序可能附带 `html`、`javascript`
    和 `css` 文件。
- en: 'There are a few different options for including extra files with your package.
    First, it is important to know which files are included in your source package
    by default:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含与你的包一起的额外文件方面，有几个不同的选项。首先，了解你的源包默认包含哪些文件是很重要的：
- en: Python source files in the package directories and all their subdirectories
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包目录中的 Python 源文件及其所有子目录
- en: The `setup.py`, `setup.cfg`, and `pyproject.toml` files
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py`、`setup.cfg` 和 `pyproject.toml` 文件'
- en: Readme files if available, such as `README.rst`, `README.txt`, and `README.md`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，包括自述文件，例如 `README.rst`、`README.txt` 和 `README.md`
- en: Metadata files containing the package name, version, entry points, file hashes,
    and so on
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含包名称、版本、入口点、文件哈希等元数据文件的元数据文件
- en: For Python wheels the list is even shorter, and only the Python source and the
    metadata files will be packaged by default.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 轮子（wheels），列表甚至更短，默认情况下只打包 Python 源文件和元数据文件。
- en: This means that if we want to include other files, we need to specify that those
    need to be added. We have two different options for adding other types of data
    to our package.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们想包含其他文件，我们需要指定这些文件需要被添加。我们有两种不同的选项来将其他类型的数据添加到我们的包中。
- en: 'First of all, we can enable the `include_package_data` flag as an argument
    to `setup()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将 `include_package_data` 标志作为 `setup()` 的参数启用：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once that flag is enabled, we can specify what file patterns we want in a `MANIFEST.in`
    file. This file contains patterns to include, exclude, and more. The `include` and `exclude` commands
    use patterns to match. These patterns are glob-style patterns (see the `glob` module
    for documentation: [https://docs.python.org/3/library/glob.html](https://docs.python.org/3/library/glob.html))
    and have three variants for both the `include` and `exclude` commands:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用该标志，我们就可以在 `MANIFEST.in` 文件中指定我们想要的文件模式。此文件包含包含、排除和其他模式的模式。`include` 和 `exclude`
    命令使用模式进行匹配。这些模式是 glob-style 模式（有关文档，请参阅 `glob` 模块：[https://docs.python.org/3/library/glob.html](https://docs.python.org/3/library/glob.html)），对于
    `include` 和 `exclude` 命令都有三种变体：
- en: '`include`/`exclude`: These commands only work for the given path and nothing
    else'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`/`exclude`：这些命令只针对给定的路径，不涉及其他'
- en: '`recursive-include`/`recursive-exclude`: These commands are similar to the `include`/`exclude` commands, but
    process the given paths recursively'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recursive-include`/`recursive-exclude`：这些命令与 `include`/`exclude` 命令类似，但会递归地处理给定的路径'
- en: '`global-include`/`global-exclude`: Be very careful with these, as they will
    include or exclude these files anywhere within the source tree'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`global-include`/`global-exclude`：对这些要非常小心，因为它们会在源树中的任何位置包含或排除这些文件'
- en: 'Besides the `include`/`exclude` commands, there are also two others: the `graft` and `prune` commands,
    which include or exclude directories including all the files under a given directory.
    This can be useful for tests and documentation, since they can include non-standard
    files. Beyond those examples, it’s almost always better to explicitly include
    the files you need and ignore all the others. Here’s an example `MANIFEST.in`
    file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `include`/`exclude` 命令之外，还有两个其他命令：`graft` 和 `prune` 命令，它们包括或排除给定目录下的所有目录。这对于测试和文档可能很有用，因为它们可以包含非标准文件。除了这些示例之外，几乎总是更好的做法是明确包含你需要的文件，并忽略所有其他文件。以下是一个示例
    `MANIFEST.in` 文件：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Alternatively, we can use the `package_data` and `exclude_package_data` arguments
    and add them to `setup.py`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `package_data` 和 `exclude_package_data` 参数，并将它们添加到 `setup.py` 中：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Naturally, these also have an equivalent `setup.cfg` format:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，这些也有等效的 `setup.cfg` 格式：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that these parameters use `package_data` instead of `data` for a reason.
    All of these require you to use a package. That means that data will only be included
    if it’s inside a proper Python package (in other words, if it contains an `__init__.py`).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些参数使用 `package_data` 而不是 `data` 是有原因的。所有这些都需要你使用一个包。这意味着数据只有在它位于一个合适的 Python
    包（换句话说，如果它包含一个 `__init__.py`）中时才会被包含。
- en: You can choose whichever format and method you prefer.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择你喜欢的任何格式和方法。
- en: Managing dependencies
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: When you are using a `setup.py` or `setup.cfg` file, you don’t get the easy
    dependency management that `poetry` provides. Adding new dependencies is not much
    harder, except that you need to add the requirement and install the package yourself
    instead of doing it all in a single command.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `setup.py` 或 `setup.cfg` 文件时，你不会得到 `poetry` 提供的简单依赖项管理。添加新的依赖项并不困难，除了你需要添加要求并自己安装包，而不是在一个命令中完成所有操作。
- en: 'As is the case with `pyproject.toml`, there are multiple types of dependencies
    that you can declare:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `pyproject.toml` 一样，你可以声明多种类型的依赖项：
- en: '`[build-system] requires`: These are the requirements to build the project.
    These are usually `setuptools` and `wheel` for `setuptools-b`ased packages; for
    `poetry` this would be `poetry-core`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[build-system] requires`：这是构建项目所需的依赖项。这些通常是 `setuptools` 和 `wheel`，对于基于 `setuptools`
    的包；对于 `poetry`，这将是一个 `poetry-core`。'
- en: '`[options] install_requires`: These are the requirements to be able to run
    the package. A project such as `pandas` will have a requirement for `numpy`, for
    example.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[options] install_requires`：这些是运行包所需的依赖项。例如，像 `pandas` 这样的项目将需要 `numpy`。'
- en: '`[options.extras_require] NAME_OF_EXTRA`: If your project has optional dependencies
    for specific circumstances, the extras can help. For example, to install `portalocker`
    with `redis` support, you can run this command:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[options.extras_require] NAME_OF_EXTRA`：如果你的项目在特定情况下有可选的依赖项，额外的依赖项可以帮助。例如，要安装具有
    `redis` 支持的 `portalocker`，你可以运行此命令：'
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you have experience with creating packages, you might wonder why `tests_require`
    is not shown here. The reason is that there is no real need for it anymore since
    `extras_require` was added. You can simply add an extra requirement for `tests`
    and `docs` instead.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有过创建包的经验，你可能想知道为什么这里没有显示 `tests_require`。原因是自从添加了 `extras_require` 之后，就不再真正需要它了。你可以简单地添加一个额外的
    `tests` 和 `docs` 的要求。
- en: 'Here’s an example of adding a few requirements to a `setup.py` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个向 `setup.py` 文件添加一些要求的示例：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the equivalent in a `setup.cfg` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setup.cfg` 文件中，这是等效的：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Adding executable commands
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加可执行命令
- en: 'As is the case with a `pyproject.toml`-based project, we can specify executable
    commands using the `setup.py` or `setup.cfg` files as well. To add a basic executable
    command similar to how we can run the `pip` or `ipython` commands, we can add
    `entry_points` to our `setup.py` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基于 `pyproject.toml` 的项目一样，我们也可以使用 `setup.py` 或 `setup.cfg` 文件来指定可执行命令。要添加一个类似于我们可以运行
    `pip` 或 `ipython` 命令的基本可执行命令，我们可以在 `setup.py` 文件中添加 `entry_points`：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or the `setup.cfg` equivalent:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 `setup.cfg` 的等效格式：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once you have installed this package you can run `our_command` from your shell,
    similar to how you would run a command like `pip` or `ipython`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了这个包，你就可以从你的 shell 中运行 `our_command`，就像你运行 `pip` 或 `ipython` 命令一样。
- en: 'From the examples above, you might wonder if we have other options besides
    `console_scripts`, and the answer is yes. One example is `distutils.commands`,
    which can be used to add extra commands to `setup.py`. By adding a command in
    that namespace, you can do:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的示例中，您可能会想知道我们是否有除了`console_scripts`之外的其他选项，答案是肯定的。一个例子是`distutils.commands`，它可以用来向`setup.py`添加额外的命令。通过在那个命名空间中添加一个命令，您可以这样做：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The most prominent example of this behavior, however, is the `pytest` library.
    The `pytest` library uses these entry points to automatically detect plugins that
    are compatible with `pytest`. We could easily create our own equivalent:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种行为最突出的例子是`pytest`库。`pytest`库使用这些入口点来自动检测与`pytest`兼容的插件。我们可以轻松地创建自己的等效版本：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once you have packages like these installed, you can query them through `importlib`
    like so:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了这样的软件包，您可以通过`importlib`查询它们，如下所示：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is a very useful feature for automatically registering plugins across libraries.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的功能，可以自动在库之间注册插件。
- en: Building the package
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建软件包
- en: 'To actually build the package, we have a few options. I personally use the
    `setup.py` file if it is available:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际构建软件包，我们有几种选择。如果可用，我个人会使用`setup.py`文件：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you only have a `setup.cfg` and `pyproject.toml` available, you will need
    to install a package to invoke the builder. In addition to `poetry`, PyPA provides
    a tool called `build` for this, which creates an isolated environment for building
    the package:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只有`setup.cfg`和`pyproject.toml`可用，您需要安装一个包来调用构建器。除了`poetry`之外，PyPA还提供了一个名为`build`的工具，用于创建构建软件包的隔离环境：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Both the wheel and the source package are written to the `dist` directory and
    they are ready for publishing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 轮和源包都写入到`dist`目录，它们已准备好发布。
- en: Publishing packages
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布软件包
- en: Now that we have the packages built, we need to actually publish them to PyPI.
    There are several different options we can use, but let’s discuss some optional
    package metadata first.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了软件包，我们需要将它们实际发布到PyPI。我们可以使用几种不同的选项，但让我们先讨论一些可选的软件包元数据。
- en: Adding URLs
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加URL
- en: 'Our `setup.py` and `setup.cfg` files already contained a `url` parameter that
    will be used as the package homepage on PyPI. However, we can add more relevant
    URLs by configuring the `project_urls` setting, which is an arbitrary map of name/URL
    pairs. For `settings.py`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`setup.py`和`setup.cfg`文件已经包含了一个`url`参数，该参数将用作PyPI上的软件包主页。然而，我们可以通过配置`project_urls`设置添加更多相关的URL，这是一个名称/URL对的任意映射。对于`settings.py`：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or for `settings.cfg`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于`settings.cfg`：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Similarly, for `pyproject.toml` using `poetry`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于使用`poetry`的`pyproject.toml`：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: PyPI trove classifiers
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyPI trove分类器
- en: To increase the exposure of your package on PyPI, it can be useful to add a
    few classifiers. Some classifiers such as the Python version and the license are
    automatically added for you, but it can be useful to specify what kind of library
    or application you are writing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高您的软件包在PyPI上的曝光度，添加一些分类器可能很有用。一些分类器，如Python版本和许可证，会自动为您添加，但指定您正在编写的库或应用程序的类型可能很有用。
- en: 'There are many examples of useful classifiers for people interested in your
    packages:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对您的软件包感兴趣的人，有许多有用的分类器示例：
- en: '**Development status**: This can vary from “planning” to “mature” and tells
    your users whether an application is ready for production. People’s definitions
    of what is stable or beta differs, of course, so this is usually considered a
    hint at most.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发状态**：这可以从“规划”到“成熟”不等，告诉用户应用程序是否已准备好投入生产。当然，人们对什么是稳定或测试版的定义各不相同，所以这通常只被视为一个提示。'
- en: '**Framework**: The framework(s) you are using or extending. This could be Jupyter,
    IPython, Django, Flask, and so on.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架**：您正在使用或扩展的框架。这可能包括Jupyter、IPython、Django、Flask等等。'
- en: '**Topic**: Whether this is a software development package, scientific, a game,
    and so on.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：这是否是一个软件开发包、科学、游戏等等。'
- en: 'A full list of classifiers can be found on the PyPI website: [https://pypi.org/classifiers/](https://pypi.org/classifiers/)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在PyPI网站上找到完整的分类器列表：[https://pypi.org/classifiers/](https://pypi.org/classifiers/)
- en: Uploading to PyPI
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传到PyPI
- en: Uploading and publishing your package to PyPI is really easy. Perhaps too easy,
    as we will see in the case of `twine`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的软件包上传并发布到PyPI非常简单。也许太简单了，正如我们将在`twine`的案例中看到的那样。
- en: 'Before we get started, to prevent you from accidentally publishing your package
    to PyPI, you should be aware of the PyPI test server: [https://packaging.python.org/en/latest/guides/using-testpypi/](https://packaging.python.org/en/latest/guides/using-testpypi/)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，为了防止你意外地将你的包发布到 PyPI，你应该了解 PyPI 测试服务器：[https://packaging.python.org/en/latest/guides/using-testpypi/](https://packaging.python.org/en/latest/guides/using-testpypi/)
- en: 'In the case of `poetry`, we can configure the test repository like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `poetry` 的情况下，我们可以这样配置测试仓库：
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'First of all, if you are using `poetry` it is as simple as:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你使用 `poetry`，那么它就像这样简单：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you’re not using `poetry` and don’t want to use a `poetry-c`ompatible `pyproject.toml`,
    you’ll need a different solution. The official solution from PyPA is to use the
    `twine` tool, maintained by the PyPA. After you have used `python3 -m build` to
    build the package, you can use `twine` for uploading:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用 `poetry` 并且不想使用兼容 `poetry` 的 `pyproject.toml`，你需要一个不同的解决方案。PyPA 的官方解决方案是使用由
    PyPA 维护的 `twine` 工具。在你使用 `python3 -m build` 构建包之后，你可以使用 `twine` 进行上传：
- en: Warning! This command will immediately register and upload the package to `pypi.org`
    if you are already authenticated. That’s why `--repository testpypi` was added
    to upload to the test PyPI server instead. If you drop that argument, you will
    immediately publish your package to PyPI.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！如果你已经认证，此命令将立即注册并上传包到 `pypi.org`。这就是为什么添加了 `--repository testpypi` 来上传到测试
    PyPI 服务器的原因。如果你省略该参数，你将立即将你的包发布到 PyPI。
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Before you start publishing your packages to PyPI, you should ask yourself
    a couple of questions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始将你的包发布到 PyPI 之前，你应该问自己几个问题：
- en: Is the package in a working state?
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包是否处于工作状态？
- en: Do you plan to support the package?
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你计划支持这个包吗？
- en: The PyPI repository is unfortunately full of empty packages from people that
    are claiming usable package names for no apparent reason.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，PyPI 仓库充满了声称有可用包名的人的空包。
- en: C/C++ extensions
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C/C++ 扩展
- en: The previous chapter and earlier sections in this chapter have already covered
    the compilation of C/C++ components lightly, but this topic is complicated enough
    to warrant its own section with more in-depth explanations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章和本章前面的部分已经简要介绍了 C/C++ 组件的编译，但这个主题足够复杂，足以拥有一个单独的部分，提供更深入的说明。
- en: 'For convenience, we will start with a basic `setup.py` file that compiles a
    C extension:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们将从一个基本的 `setup.py` 文件开始，该文件编译一个 C 扩展：
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Before you start with these extensions, you should learn the following `setup.py`
    commands:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用这些扩展之前，你应该学习以下 `setup.py` 命令：
- en: '`build_ext`: This command builds the C/C++ extension so it can be used when
    the package is installed in development/editable mode.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_ext`：此命令构建 C/C++ 扩展，以便在包以开发/可编辑模式安装时使用。'
- en: '`clean`: This cleans the results from the `build` command. This is generally
    not needed, but sometimes the detection of files that need to be recompiled to
    work is incorrect. If you encounter strange or unexpected issues, try cleaning
    the project first.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clean`：这个命令会清理 `build` 命令的结果。这通常不是必需的，但有时检测需要重新编译以工作的文件是不正确的。如果你遇到奇怪或意外的错误，请先尝试清理项目。'
- en: Instead of using `python3 setup.py build_ext`, you can also choose to use the
    PyPA `build` command, but that is not a convenient option for development. If
    you use `python3 setup.py build` you can re-use your `build` directory and selectively
    build your C/C++ extensions, which saves you a lot of time for larger C/C++ modules.
    The PyPA `build` command is meant to produce clean, production-ready packages,
    which is strongly recommended for deploying and publishing, but not for development.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择使用 PyPA 的 `build` 命令来代替 `python3 setup.py build_ext`，但这并不是一个方便的开发选项。如果你使用
    `python3 setup.py build`，你可以重用你的 `build` 目录并选择性地构建你的 C/C++ 扩展，这为你节省了大量时间，特别是对于较大的
    C/C++ 模块。PyPA 的 `build` 命令旨在生成干净、可用于生产的包，强烈推荐用于部署和发布，但不推荐用于开发。
- en: Regular C/C++ extensions
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正规的 C/C++ 扩展
- en: The `setuptools.Extension` class tells `setuptools` that a module named `sum_of_squares` uses
    the source file `sum_of_squares.c`. This is just the simplest version of an extension
    – a name and a list of sources – but often you are going to need not just the
    C file but also some headers from other libraries.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools.Extension` 类告诉 `setuptools`，名为 `sum_of_squares` 的模块使用源文件 `sum_of_squares.c`。这只是扩展的最简单版本——一个名称和一组源文件——但通常你需要的不仅仅是
    C 文件，还需要来自其他库的一些头文件。'
- en: A prime example is the `pillow` library for image manipulation. When the library
    is building, it automatically detects the libraries available on the system and
    adds extensions based on that. For `.jpeg` support you need to have `libjpeg`
    installed; for `.tiff` images you need `libtiff`; and so on. As these extensions
    include binary libraries, some extra compilation flags and C header files are
    required. The basic PIL module itself doesn’t appear too involved, but the `setup.py`
    file is filled with auto-detection code to detect which `libs` (libraries) are
    available, with the matching C macro definitions to enable these libraries.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是用于图像处理的 `pillow` 库。当库正在构建时，它会自动检测系统上可用的库，并基于此添加扩展。对于 `.jpeg` 支持，你需要安装
    `libjpeg`；对于 `.tiff` 图像，你需要 `libtiff`；等等。由于这些扩展包括二进制库，因此需要一些额外的编译标志和 C 头文件。基本的
    PIL 模块本身并不太复杂，但 `setup.py` 文件充满了自动检测代码，用于检测哪些 `libs`（库）可用，以及匹配的 C 宏定义以启用这些库。
- en: 'Macros in C are preprocessor directives. These directives are executed before
    the actual compilation step occurs, which makes them ideal for conditional code.
    You could have a conditional block of debug code dependent on a `DEBUG` flag,
    for example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: C 中的宏是预处理器指令。这些指令在真正的编译步骤发生之前执行，这使得它们非常适合条件代码。例如，你可以有一个依赖于 `DEBUG` 标志的调试代码的条件块：
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If `DEBUG` is set, the code will be part of the compiled binary. If the flag
    is not set, the block of code will never end up in the resulting binary. This
    results in smaller and faster binaries because these conditionals happen at compile
    time as opposed to runtime.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `DEBUG`，代码将成为编译二进制的一部分。如果没有设置此标志，代码块将永远不会出现在最终的二进制文件中。这导致二进制文件更小、运行更快，因为这些条件是在编译时而不是在运行时发生的。
- en: 'Here’s a partial example `Extension` from an older version of the `pillow`
    `setup.py` file:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个来自较旧版本的 `pillow` `setup.py` 文件的 `Extension` 部分示例：
- en: '[PRE53]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The newer versions are quite different and the `setup.py` file for the `pillow`
    project is currently over 1,000 lines. The `freetype` extension has something
    similar:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 新的版本相当不同，`pillow` 项目的 `setup.py` 文件目前有超过 1,000 行。`freetype` 扩展也有类似之处：
- en: '[PRE54]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Adding and compiling C/C++ extensions can certainly be challenging, so I would
    recommend taking inspiration from projects such as `pillow` and `numpy` if you
    need to take care of this. They are perhaps a bit too complicated, but should
    provide you with a nice starting point that covers nearly all scenarios.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和编译 C/C++ 扩展确实可能具有挑战性，所以如果你需要处理这个问题，我建议从像 `pillow` 和 `numpy` 这样的项目中汲取灵感。它们可能有点复杂，但应该为你提供一个很好的起点，几乎涵盖了所有场景。
- en: Cython extensions
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cython 扩展
- en: 'The `setuptools` library is a bit smarter than the regular `distutils` library
    when it comes to extensions: it actually adds a little trick to the `Extension` class.
    Remember the brief introduction to `cython` in *Chapter 12*, about performance?
    The `setuptools` library makes it a bit more convenient to compile Cython extensions.
    The Cython manual recommends that you use something similar to the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理扩展方面，`setuptools` 库比常规的 `distutils` 库要聪明一些：它实际上为 `Extension` 类增加了一个小技巧。还记得在第
    12 章中对 `cython` 的简要介绍吗？关于性能？`setuptools` 库使得编译 Cython 扩展变得更加方便。Cython 手册建议使用以下类似代码：
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The problem with this approach is that `setup.py` will break with an `ImportError`
    unless you have Cython installed:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，如果没有安装 Cython，`setup.py` 将会因为 `ImportError` 而出错：
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To prevent that issue, we are just going to let `setuptools` handle the Cython
    compilation:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，我们将让 `setuptools` 处理 Cython 编译：
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now Cython will automatically be installed if needed and the code will work
    just fine:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果需要，Cython 将会自动安装，代码将正常工作：
- en: '[PRE58]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For development purposes, however, Cython also offers a simpler method that
    doesn’t require manual building, `pyximport`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了开发目的，Cython 也提供了一种更简单的方法，不需要手动构建，即 `pyximport`：
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That’s how easy it is to run the `pyx` files without explicit compiling.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以轻松地运行 `pyx` 文件而无需显式编译。
- en: Testing
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: In *Chapter 10*, *Testing and Logging – Preparing for Bugs*, we saw a few of
    the many testing systems for Python. As you might suspect, at least some of these
    have `setup.py` integration. It should be noted that `setuptools` even has a dedicated
    `test` command (at the time of writing), but this command has been deprecated
    and the `setuptools` documentation now recommends using `tox`. While I am a huge
    fan of `tox`, for immediate local development it often incurs quite a bit of overhead.
    I find that executing `py.test` directly is faster, because you can really quickly
    test only the bits of the code that you changed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第10章*的*测试和日志记录 – 准备错误*中，我们看到了许多 Python 测试系统中的几个。正如您所怀疑的，其中至少有一些与 `setup.py`
    集成。应该注意的是，`setuptools` 甚至有一个专门的 `test` 命令（在撰写本文时），但此命令已被弃用，`setuptools` 文档现在建议使用
    `tox`。虽然我是 `tox` 的忠实粉丝，但对于即时本地开发，它通常会带来相当大的开销。我发现直接执行 `py.test` 会更快，因为您可以快速测试仅更改的代码部分。
- en: unittest
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unittest
- en: 'Before we start, we should create a test script for our package. For actual
    tests please look at *Chapter 10*; in this case, we will just use a no-op test,
    `test.py`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们应该为我们的包创建一个测试脚本。对于实际的测试，请参阅*第10章*；在这种情况下，我们只是使用一个空操作测试，`test.py`：
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The standard `python setup.py test` command has been deprecated, so we will
    run `unittest` directly:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 `python setup.py test` 命令已被弃用，因此我们将直接运行 `unittest`：
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `unittest` library is still rather limited, however, so I recommend skipping
    straight to `py.test` instead.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 库仍然相当有限，因此我建议直接跳转到 `py.test`。'
- en: py.test
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: py.test
- en: The `py.test` package currently automatically registers as an extra command
    in `setuptools`, so after installing you can run `python3 setup.py pytest`. However,
    since `setuptools` is actively trying to reduce all interaction with `setup.py`,
    I would recommend using a `py.test` or `tox` call directly instead.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`py.test` 包目前会自动注册为 `setuptools` 中的一个额外命令，因此安装后您可以直接运行 `python3 setup.py pytest`。然而，由于
    `setuptools` 正在积极减少与 `setup.py` 的所有交互，我建议直接使用 `py.test` 或 `tox` 调用。'
- en: As mentioned earlier, it is recommended to use `tox` for bootstrapping your
    environment and fully testing the project. For fast local development, however,
    I would suggest installing the `pytest` module and running the tests directly.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，建议使用 `tox` 来初始化环境并全面测试项目。然而，对于快速本地开发，我建议安装 `pytest` 模块并直接运行测试。
- en: Note that there might still be old documentation floating around suggesting
    the use of `pytest-runner`, `python setup.py test` with an alias or custom command,
    or the generation of a `runtests.py` file, but all of these solutions have been
    deprecated and should not be used anymore.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可能仍然有一些旧的文档建议使用 `pytest-runner`、带有别名或自定义命令的 `python setup.py test`，或者生成一个
    `runtests.py` 文件，但所有这些解决方案都已弃用，不应再使用。
- en: 'To configure `py.test` we have several options depending on your preferences.
    All of the following files will work:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 `py.test` 时，我们有几种选项取决于您的偏好。以下所有文件都将有效：
- en: '`pytest.ini`'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest.ini`'
- en: '`pyproject.toml`'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyproject.toml`'
- en: '`tox.ini`'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tox.ini`'
- en: '`setup.cfg`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.cfg`'
- en: For the projects I maintain, I have the test requirements defined as an extra
    so these can be installed using (for example) `pip3 install -e "./progressbar2[tests]"`.
    After that, you can easily run `py.test` to run the tests identically to how `tox`
    would run them. Naturally, `tox` can also install the requirements using the same
    extras, which ensures you are using the same test environment.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我维护的项目，我已经将测试需求定义为额外的依赖项，因此可以使用（例如）`pip3 install -e "./progressbar2[tests]"`
    来安装。之后，您可以轻松地运行 `py.test` 来以 `tox` 运行测试的方式运行测试。当然，`tox` 也可以使用相同的额外依赖项来安装需求，这确保了您使用的是相同的测试环境。
- en: 'To enable this in your `setup.cfg` (or the equivalent for `setup.py` / `pyproject.toml`):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 `setup.cfg`（或 `setup.py` / `pyproject.toml` 的等效文件）中启用此功能：
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For local development, we can now install the package and the extras in editable
    mode for quick testing:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地开发，我们现在可以以可编辑模式安装包和额外依赖项以进行快速测试：
- en: '[PRE63]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'That should be enough to be able to test using `py.test` directly:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就足以能够直接使用 `py.test` 进行测试：
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: To test using `tox`, you will need to create a `tox.ini` file, but for that,
    I suggest you take a look at *Chapter 10*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `tox` 进行测试，您需要创建一个 `tox.ini` 文件，但为此，我建议您查看*第10章*。
- en: Exercises
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now that you have reached the end of the book, there are many things to try,
    of course. You can build and publish your own applications and libraries, or extend
    existing libraries and applications.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经到达了本书的结尾，当然有很多事情可以尝试。您可以构建和发布自己的应用程序和库，或者扩展现有的库和应用。
- en: While trying out the examples in this chapter, be careful not to accidentally
    publish packages to PyPI if that was not your intention. It just takes a single
    `twine` command to accidentally register and upload a package, and PyPI is already
    too crowded with packages that do nothing useful.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试本章的示例时，请注意不要意外地将包发布到PyPI，如果不是你的意图。只需一个`twine`命令就可能导致意外注册和上传包，而PyPI上已经充斥着没有实际用途的包。
- en: 'For some practical exercises:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些实际练习：
- en: Create a `setuptools` command to bump the version in your package
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`setuptools`命令来提升你包的版本
- en: Extend the version bumping command by interactively asking for a major, minor,
    or patch upgrade
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交互式询问进行主要、次要或补丁升级来扩展版本提升命令
- en: Try and convert existing projects from `setup.py` to a `pyproject.toml` structure
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将现有的项目从`setup.py`转换为`pyproject.toml`结构
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_18.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](Chapter_18.xhtml)。我们鼓励你提交自己的解决方案，并从他人的解决方案中学习。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you should be able to create Python packages containing
    not only pure-Python files but also extra data, compiled C/C++ extensions, documentation,
    and tests. With all these tools at your disposal, you are now able to make high-quality
    Python packages that can easily be reused in other projects and packages.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完这一章后，你应该能够创建包含纯Python文件、额外数据、编译的C/C++扩展、文档和测试的Python包。有了所有这些工具，你现在能够制作出高质量的Python包，这些包可以轻松地在其他项目和包中重用。
- en: The Python infrastructure makes it really quite easy to create new packages
    and split your project into multiple subprojects. This allows you to create simple
    and reusable packages with fewer bugs because everything is easily testable. While
    you shouldn’t go overboard with splitting up the packages, if a script or module
    has a purpose of its own then it’s a candidate for packaging separately.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Python基础设施使得创建新包并将你的项目拆分为多个子项目变得非常简单。这允许你创建简单且可重用的包，因为一切都可以轻松测试，从而减少错误。虽然你不应该过度拆分包，但如果一个脚本或模块有其自身的目的，那么它就是单独打包的候选者。
- en: '*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*'
- en: With this chapter, we have come to the end of the book. I sincerely hope you
    enjoyed reading it and have learned about some new and interesting topics. Any
    and all feedback is greatly appreciated, so feel free to contact me through my
    website at [https://wol.ph/](https://wol.ph/).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的结束，我们来到了这本书的结尾。我真诚地希望你喜欢阅读它，并了解了一些新的有趣的话题。任何和所有的反馈都将非常受重视，所以请随时通过我的网站[https://wol.ph/](https://wol.ph/)联系我。
- en: Join our community on Discord
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code156081100001293319171.png)'
