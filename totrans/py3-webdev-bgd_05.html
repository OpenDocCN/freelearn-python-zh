<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 5. Entities and Relations"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Entities and Relations</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>Most real life applications sport more than one entity and often many of these entities are related. Modeling these relations is one of the strong points of a relational database. In this chapter, we will develop an application to maintain lists of books for multiple users.</p></blockquote></div><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Design and implement a data model consisting of several entities and relations</li><li class="listitem" style="list-style-type: disc">Implement reusable entity and relation modules</li><li class="listitem" style="list-style-type: disc">Look in depth at the necessity of clearly separating layers of functionality</li><li class="listitem" style="list-style-type: disc">And encounter jQuery UI's autocomplete widget</li></ul></div><p>So let's get started with it...</p><div class="section" title="Designing a book database"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec01"/>Designing a book database</h1></div></div></div><p>Before we start to design our application, let's have a good look at the different entities that need to be handled by it. The entities we recognize are a book, an author, and a user. A book may have many attributes, but here we limit ourselves to a title, an ISBN (International Standard Book Number), and a publisher. An author has just a name, but of course, if we would like to extend that with extra attributes, like the date of birth or nationality, we can always add that later. Finally, a user is an entity with a single attribute as well, the user ID.<a id="id216" class="indexterm"/>
</p><p>The next important part is to have a clear understanding of the relations between these entities. A book may be written by one or more authors, so we need to define a relation between a book entity and an author entity. Also, any number of users may own a copy of a book. This is another relation we have to define, this time, between a book entity and a user entity. The following diagram may help to see those entities and their relations more clearly:<a id="id217" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746OS_05_01.jpg" height="36" alt="Designing a book database"/></div><p>These three entities and the relations between them need to be represented in two realms: as database tables and as Python classes. Now we could model each entity and relation separately, like we did in the previous chapter for the<code class="literal"> tasklist</code> application, but all entities share a lot of common functionality so there are ample opportunities for reuse. Reuse means less code and less code equals less maintenance and often better readability. So let's see what we need to define a reusable<code class="literal"> Entity</code> class.<a id="id218" class="indexterm"/>
</p><div class="section" title="The Entity class"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec01"/>The Entity class</h2></div></div></div><p>From what we learned in the previous chapters, we already know there is a shared body of functionality that each class that represents an entity needs to implement:<a id="id219" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It needs to be able to verify that a corresponding table exists in the database and create one if it doesn't.</li><li class="listitem" style="list-style-type: disc">It needs to implement a way to manage database connections in a thread-safe manner.</li></ul></div><p>Also, each entity should present us with a<span class="strong"><strong> CRUD</strong></span> interface:<a id="id220" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Create</em></span> new object instances</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Retrieve</em></span> individual object instances and find instances that match some criteria</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Update</em></span> the attributes of an object instance and synchronize this data to the database</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Delete</em></span> an object instance</li></ul></div><p>That is a lot of shared functionality, but of course a book and an author are not identical: They differ in the number and type of their attributes. Before we look at the implementation, let's illustrate how we would like to use an<code class="literal"> Entity</code> class to define a specific entity, for example, a car.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action using the Entity class"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Time for action using the Entity class</h1></div></div></div><p>Let us first define for ourselves how we want to use an<code class="literal"> Entity</code> class, because the interface we create must match as closely as possible the things we would like to express in our code. The following example shows what we have in mind (available as<code class="literal"> carexample.py):</code>
<a id="id221" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/carexample.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
from entity import Entity
class Car(Entity): pass<span class="strong"><strong>
Car.threadinit('c:/tmp/cardatabase.db')</strong></span>
Car.inittable(make="",model="",licenseplate="unique")
mycar = Car(make="Volvo",model="C30",licenseplate="12-abc-3")
yourcar = Car(make="Renault",model="Twingo",licenseplate="ab-cd-12")
allcars = Car.list()
for id in allcars:
	car=Car(id=id)
	print(car.make, car.model, car.licenseplate)
</pre></div><p>The idea is to create a<code class="literal"> Car</code> class that is a subclass of<code class="literal"> Entity</code>. We therefore have to take the following steps:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Import the<code class="literal"> Entity</code> class from the<code class="literal"> entity</code> module.</li><li class="listitem">Define the<code class="literal"> Car</code> class. The body of this class is completely empty as we simply inherit all functionality from the<code class="literal"> Entity</code> class. We could, of course, augment this with specific functionality, but in general, this shouldn't be necessary.</li><li class="listitem">Initialize a connection to the database. Before we can work with the<code class="literal"> Car</code> instances, an application has to initialize a connection to the database for each thread. In this example, we do not create extra threads, so there is just the single main thread of the application that needs a connection to the database. We create one here with the<code class="literal"> threadinit()</code> method (highlighted).</li><li class="listitem">Make sure an appropriate table with the necessary columns exists in the database. Therefore, we call the<code class="literal"> inittable()</code> method with arguments that specify the attributes of our entity with possibly extra information on how to define them as columns in a database table. Here we define three columns:<code class="literal"> make, model</code>, and<code class="literal"> licenseplate</code>. Remember that SQLite doesn't need explicit typing, so<code class="literal"> make</code> and<code class="literal"> model</code> are passed as arguments with just an empty string as the value. The<code class="literal"> licenseplate</code> attribute, however, is adorned with a<code class="literal"> unique</code> constraint in this example.</li></ol></div><p>Now we can work with<code class="literal"> Car</code> instances, as illustrated in the lines that create two different objects or in the last few lines that retrieve the IDs of all<code class="literal"> Car</code> records in the database and instantiate<code class="literal"> Car</code> instances with those IDs to print the various attributes of a<code class="literal"> Car</code>.<a id="id222" class="indexterm"/>
</p><p>That is the way we would like it to work. The next step is to implement this.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec02"/>What just happened?</h2></div></div></div><p>The previous example showed how we could derive the<code class="literal"> Car</code> class from<code class="literal"> Entity</code> and use it. But what does that<code class="literal"> Entity</code> class look like?</p><p>The definition for the<code class="literal"> Entity</code> class starts off with defining a class variable<code class="literal"> threadlocal</code> and a class method<code class="literal"> threadinit()</code> to initialize this variable with an object that holds data that is local to each thread (the full code is available as<code class="literal"> entity.py)</code>.</p><p>If this<code class="literal"> threadlocal</code> object does not yet have a<code class="literal"> connection</code> attribute, a new connection to the database is created (highlighted) and we configure this connection by setting its<code class="literal"> row_factory</code> attribute to<code class="literal"> sqlite.Row</code>, as this will enable us to access columns in the results by name.</p><p>We also execute a single<code class="literal"> pragma foreign_keys=1</code> statement to enable the enforcing of foreign keys. As we will see, when we discuss the implementation of relations, this is vital in maintaining a database without dangling references. This<code class="literal"> pragma</code> must be set for each connection separately; therefore, we put it in the thread initialization method.</p><p>
<span class="strong"><strong>Chapter5/entity.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
import sqlite3 as sqlite
import threading
class Entity:
	threadlocal = threading.local()
	@classmethod
	def threadinit(cls,db):<span class="strong"><strong>
			if not hasattr(cls.threadlocal,'connection') or 
cls.threadlocal.connection is None:</strong></span>
				cls.threadlocal.connection=sqlite.connect(db)
				cls.threadlocal.connection.row_factory = sqlite.Row
				cls.threadlocal.connection.execute("pragma foreign_
keys=1")
			else:
				pass #print('threadinit thread has a connection 
object already')
</pre></div><p>Next is the<code class="literal"> inittable()</code> method. This should be called once to verify that the table necessary for this entity already exists or to define a table with suitable columns if it doesn't. It takes any number of keyword arguments. The names of the keywords correspond to the names of the columns and the value of such a keyword may be an empty string or a string with additional attributes for the column, for example,<code class="literal"> unique</code> or an explicit type like<code class="literal"> float</code>.<a id="id223" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note18"/>Note</h3><p>Although SQLite allows you to store a value of any type in a column, you may still define a type. This type (or more accurately,<span class="strong"><strong> affinity)</strong></span> is what SQLite tries to convert a value to when it is stored in a column. If it doesn't succeed, the value is stored as is. Defining a column as float, for example, may save a lot of space. More on these affinities can be found on<a class="ulink" href="http://www.sqlite.org/datatype3.html"> http://www.sqlite.org/datatype3.html</a>.</p></div><p>
<span class="strong"><strong>Chapter5/entity.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@classmethod
def inittable(cls,**kw):
		cls.columns=kw
		connection=cls.threadlocal.connection
		coldefs=",".join(k+' '+v for k,v in kw.items())<span class="strong"><strong>
		sql="create table if not exists %s (%s_id integer primary 
key autoincrement, %s);"%(cls.__name__,cls.__name__,coldefs)</strong></span>
		connection.execute(sql)
		connection.commit()
</pre></div><p>The column definitions are stored in the<code class="literal"> columns</code> class variable for later use by the<code class="literal"> __init__()</code> method and joined together to a single string. This string, together with the name of the class (available in the<code class="literal"> __name__</code> attribute of a (possibly derived) class) is then used to compose a SQL statement to create a table (highlighted).</p><p>Besides the columns that we defined based on the keyword arguments, we can also create a primary key column that will be filled with a unique integer automatically. This way, we ensure that we can refer to each individual row in the table later on, for example, from a bridging table that defines a relation.</p><p>When we take our previous car example, we see that a Python statement like:</p><div class="informalexample"><pre class="programlisting">
Car.inittable(make="",model="",licenseplate="unique")
</pre></div><p>Is converted to the following SQL statement:</p><div class="informalexample"><pre class="programlisting">
create table if not exists Car (
Car_id integer primary key autoincrement,
make ,
licenseplate unique,
model
);
</pre></div><p>Note that the order in which we pass the keyword arguments to the<code class="literal"> inittable()</code> method is not necessarily preserved as these arguments are stored in a<code class="literal"> dict</code> object, and regular<code class="literal"> dict</code> objects do not preserve the order of their keys.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note19"/>Note</h3><p>Sometimes preserving the order of the keys in a dictionary is very desirable. In this case, column order doesn't matter much, but Python does have an<code class="literal"> OrderedDict</code> class available in its<code class="literal"> collections</code> module (see<a class="ulink" href="http://docs.python.org/library/collections.html#collections.OrderedDict)"> http://docs.python.org/library/collections.html#collections.OrderedDict)</a> that we could have used. However, this would prevent us from using keywords to define each column.</p></div><p>Also note that there isn't any form of sanity checking implemented: anything may be passed as a value for one of the column definitions. Judging whether that is anything sensible is left to SQLite when we pass the SQL statement to the database engine with the<code class="literal"> execute()</code> method.<a id="id224" class="indexterm"/>
</p><p>This method will raise an<code class="literal"> sqlite3.OperationalError</code> if there is a syntax error in the SQL statement. However, many issues are simply ignored. If we pass an argument like<code class="literal"> licenseplate="foo</code>", it would happily proceed, assuming<code class="literal"> foo</code> to be a type it doesn't recognize, so it is simply ignored! If the execution didn't raise an exception, we finish by committing our changes to the database.</p></div><div class="section" title="Have a go hero checking your input"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec03"/>Have a go hero checking your input</h2></div></div></div><p>Silently ignoring things passed as arguments is not considered a good habit. Without explicit checking, a developer might not even know he/she has done something wrong, something that might backfire later.</p><p>How would you implement code to restrict the value to a limited set of directives?</p><p>Hint: Types and constraints in a SQL column definition mostly consist of single words. You could check each word against a list of allowable types, for example.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action creating instances"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Time for action creating instances</h1></div></div></div><p>The next method we look at is the constructor the<code class="literal"> __init__()</code> method. It will be used to create individual instances of an entity. The constructor can be called in two ways:<a id="id225" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">With a single<code class="literal"> id</code> argument, in which case, an existing record will be retrieved from the database and the instance initialized with the column values of this record, or</li><li class="listitem" style="list-style-type: disc">With a number of keyword arguments to create a new instance and save this as a new database record</li></ul></div><p>The code to implement this behavior looks like the following:</p><p>
<span class="strong"><strong>Chapter5/entity.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def __init__(self,id=None,**kw):<span class="strong"><strong>
		for k in kw:
			if not k in self.__class__.columns :
				raise KeyError("unknown column")</strong></span>
		cursor=self.threadlocal.connection.cursor()
		if id:
			if len(kw):
				raise KeyError("columns specified on 
retrieval")
			sql="select * from %s where %s_id = ?"%(
			self.__class__.__name__,self.__class__.__name__)
			cursor.execute(sql,(id,))
			entities=cursor.fetchall()<span class="strong"><strong>
			if len(entities)!=1 :
</strong></span>
				raise ValueError("not a singular entity")
			self.id=id
			for k in self.__class__.columns:<span class="strong"><strong>
				setattr(self,k,entities[0][k])</strong></span>
		else:
			cols=[]
			vals=[]
			for c,v in kw.items():
				cols.append(c)
				vals.append(v)
				setattr(self,c,v)
			cols=",".join(cols)
			nvals=",".join(["?"]*len(vals))<span class="strong"><strong>
			sql="insert into %s (%s) values(%s)"%(</strong></span>
			self.__class__.__name__,cols,nvals)
			try:
				with self.threadlocal.connection as conn:
					cursor=conn.cursor()<span class="strong"><strong>
					cursor.execute(sql,vals)</strong></span>
					self.id=cursor.lastrowid
			except sqlite.IntegrityError:
					raise ValueError("duplicate value for unique 
col")
</pre></div><p>The code reflects this dual use. After checking that all keywords indeed refer to the previously defined columns (highlighted), it checks whether it was passed an<code class="literal"> id</code> argument. If it was, there shouldn't be any other keyword arguments. If there are additional keywords, an exception is raised. If the<code class="literal"> id</code> argument is present, an SQL statement is constructed next that will retrieve the records from the associated table. Each record's primary key should match the ID.<a id="id226" class="indexterm"/>
</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec04"/>What just happened?</h2></div></div></div><p>Because the primary key is unique, this will match at most a single record, something that is verified after we retrieve the matching records. If we didn't fetch exactly one (1) record, an exception is raised (highlighted).</p><p>If everything went well, we initialize the attributes of the instance we are creating with the built-in<code class="literal"> setattr()</code> function. The columns of the record we retrieved can be accessed by name because we initialized the<code class="literal"> row_factory</code> attribute of the connection object to a<code class="literal"> sqlite3.Row</code>. We also stored the names of the columns in the<code class="literal"> columns</code> class variable and this lets us initialize the instance's attributes with the values of the corresponding column names (highlighted).</p><p>Creating a<code class="literal"> Car</code> instance with:</p><div class="informalexample"><pre class="programlisting">Car(id=1)
</pre></div><p>Will result in a SQL statement like this:</p><div class="informalexample"><pre class="programlisting">select * from Car where Car_id = ?
</pre></div><p>Where the question mark is a placeholder for the actual value that is passed to the<code class="literal"> execute()</code> method.</p><p>The second branch of the code (starting at the<code class="literal"> else</code> clause) is executed if no<code class="literal"> id</code> argument was present. In this case, we separate the keyword names and values and set the attributes of the instance we are creating. The keyword names and values are then used to construct an SQL statement to insert a new row in the table associated with this<code class="literal"> Entity</code> (highlighted). For example:</p><div class="informalexample"><pre class="programlisting">Car(make="Volvo", model="C30", licenseplate="12-abc-3")
</pre></div><p>Will give us:</p><div class="informalexample"><pre class="programlisting">insert into Car (make,model,licenseplate) values(?,?,?)
</pre></div><p>The question marks are again placeholders for the values we pass to the<code class="literal"> execute()</code> method.<a id="id227" class="indexterm"/>
</p><p>If calling the<code class="literal"> execute()</code> method (highlighted) went well, we initialize the<code class="literal"> id</code> attribute of the instance we are creating with the value of the<code class="literal"> lastrowid</code> attribute. Because we defined the primary key as a<code class="literal"> primary key integer autoincrement</code> column and did not specify it in the insert statement, the primary key will hold a new unique integer and this integer is available as the<code class="literal"> lastrowid</code> attribute.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note20"/>Note</h3><p>This is very SQLite-specific and the primary key should be defined in exactly this way for this to hold true. More on this can be found at<a class="ulink" href="http://www.sqlite.org/lang_createtable.html#rowid"> http://www.sqlite.org/lang_createtable.html#rowid</a>
</p></div><p>Any<code class="literal"> sqlite3.IntegrityError</code> that might be raised due to the violation of a uniqueness constraint is caught and re-raised as a<code class="literal"> ValueError</code> with slightly more meaningful text.</p><p>The<code class="literal"> update()</code> method is used to synchronize an instance with the database. It can be used in two ways: we can alter any attributes of an instance first and then call<code class="literal"> update()</code>, or we may pass keyword arguments to<code class="literal"> update()</code> to let<code class="literal"> update()</code> alter the corresponding attributes and synchronize the instance to the database. These two ways may even be combined. Either way, the database will hold the most current values of all attributes corresponding to a column once the<code class="literal"> update()</code> returns. The following two pieces of code are therefore equivalent:</p><div class="informalexample"><pre class="programlisting">car.update(make='Peugeot')
</pre></div><p>And:</p><div class="informalexample"><pre class="programlisting">car.make='Peugeot'
car.update()
</pre></div><p>Any keyword arguments we pass to<code class="literal"> update()</code> should match a column name, otherwise an exception is raised (highlighted).</p><p>
<span class="strong"><strong>Chapter5/entity.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def update(self,**kw):<span class="strong"><strong>
		for k in kw:
			if not k in self.__class__.columns :
				raise KeyError("unknown column")</strong></span>
		for k,v in kw.items():
			setattr(self,k,v)
		updates=[]
		values=[]
		for k in self.columns:
			updates.append("%s=?"%k)
			values.append(getattr(self,k))
		updates=",".join(updates)
		values.append(self.id)
		sql="update %s set %s where %s_id = ?"%(
		self.__class__.__name__, updates, self.__class__.__name__)
		with self.threadlocal.connection as conn:
			cursor=conn.cursor()
			cursor.execute(sql, values)<span class="strong"><strong>
			if cursor.rowcount != 1 :</strong></span>
				raise ValueError(
				"number of updated entities not 1 (%d)" %
				cursor.rowcount)
</pre></div><p>The column names and the values of the corresponding attributes are then used to construct an SQL statement to update records with these values, but only for the single record whose primary key matches the ID of the instance we are updating. The SQL statement might look like this:<a id="id228" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">update Car set make=?, model=?, licenseplate=? where Car_id = ?
</pre></div><p>The question marks again are placeholders for the values we pass to the<code class="literal"> execute()</code> method.</p><p>After we execute this statement, we do a sanity check by validating that the number of affected records is indeed one. Just as for an insert statement, this number is available as the<code class="literal"> rowcount</code> attribute of the cursor object after an update statement (highlighted).</p><p>Deleting an instance is implemented by the<code class="literal"> delete()</code> method of the<code class="literal"> Entity</code> class and consists primarily of composing an SQL statement that will delete the record with a primary key equal to the<code class="literal"> id</code> attribute of the instance. The resulting SQL looks like this:</p><div class="informalexample"><pre class="programlisting">delete from Car where Car_id = ?
</pre></div><p>Just like in the<code class="literal"> update()</code> method, we end with a sanity check to verify that just a single record was affected (highlighted). Note that<code class="literal"> delete()</code> will only remove the record in the database, not the Python instance it is called on. If nothing references this object instance, it will be automatically removed by the Python's garbage collector:</p><p>
<span class="strong"><strong>Chapter5/entity.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def delete(self):
		sql="delete from %s where %s_id = ?"%(
		self.__class__.__name__,self.__class__.__name__)
		with self.threadlocal.connection as conn:
				cursor=conn.cursor()
				cursor.execute(sql,(self.id,))<span class="strong"><strong>
				if cursor.rowcount != 1 :</strong></span>
					raise ValueError(
					"number of deleted entities not 1 (%d)" %
					cursor.rowcount)
</pre></div><p>The final method we encounter is the class method<code class="literal"> list()</code>. This method may be used to retrieve the IDs of all instances of an entity when called without arguments or to retrieve the IDs of instances that match certain criteria passed as arguments. For example:</p><div class="informalexample"><pre class="programlisting">Car.list()
</pre></div><p>Will return a list of IDs of all cars in the database, whereas:</p><div class="informalexample"><pre class="programlisting">Car.list(make='Volvo')
</pre></div><p>Will return the IDs of all the Volvos in the database.<a id="id229" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/entity.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@classmethod
def list(cls,**kw):<span class="strong"><strong>
		sql="select %s_id from %s"%(cls.__name__,cls.__name__)
</strong></span>
		cursor=cls.threadlocal.connection.cursor()
		if len(kw):
				cols=[]
				values=[]
				for k,v in kw.items():
						cols.append(k)
						values.append(v)<span class="strong"><strong>
				whereclause = " where "+",".join(c+"=?" for c in 
cols)</strong></span>
				sql += whereclause
				cursor.execute(sql,values)
		else:
				cursor.execute(sql)
		for row in cursor.fetchall():
				yield row[0]
</pre></div><p>The implementation is straightforward and starts off with creating an SQL statement to select all IDs from the table (highlighted). An example would be:</p><div class="informalexample"><pre class="programlisting">select Car_id from Car
</pre></div><p>If there were any keyword arguments passed to the<code class="literal"> list()</code> method, these are then used to construct a<code class="literal"> where</code> clause that will restrict the IDs returned to those of the records that match. This<code class="literal"> where</code> clause is appended to our general select statement (highlighted). For example:</p><div class="informalexample"><pre class="programlisting">select Car_id from Car where make=?
</pre></div><p>After invocation of the<code class="literal"> execute()</code> method, we yield all the IDs. By using the<code class="literal"> yield</code> statement, we have identified the<code class="literal"> list()</code> method as a<span class="strong"><strong> generator</strong></span> that will return the IDs found one-by-one rather than in one go. We still can manipulate this generator just like a list if we wish, but for very large result sets, a generator might be a better option as it does consume less memory, for example.<a id="id230" class="indexterm"/>
</p></div><div class="section" title="The Relation class"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec05"/>The Relation class</h2></div></div></div><p>The<code class="literal"> Relation</code> class is used to manage relations between individual instances of entities. If we have<code class="literal"> Car</code> entities as well as<code class="literal"> Owner</code> entities, we might like to define a<code class="literal"> CarOwner</code> class that provides us with the functionality to identify the ownership of a certain car by a specific owner.<a id="id231" class="indexterm"/>
</p><p>Like entities, generic relations share a lot of common functionality: we must be able to create a new relation between two entities, delete a relation, and list related entities given a primary entity, for example, list all owners of a given car or all cars of a certain owner.</p><p>Relations are stored in the database in a table, often called a<span class="strong"><strong> bridging table</strong></span>, consisting of records with columns that store the IDs of both related entities. When an application starts using a (subclass of) the<code class="literal"> Relation</code> class, we must verify that the corresponding table exists, and if not, create it.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action using the Relation class"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec04"/>Time for action using the Relation class</h1></div></div></div><p>Let's have a look at how we would like to use our<code class="literal"> Relation</code> class:<a id="id232" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/carexample2.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
from entity import Entity
from relation import Relation
class Car(Entity): pass
class Owner(Entity): pass
Car.threadinit('c:/tmp/cardatabase2.db')
Car.inittable(make="",model="",licenseplate="unique")
Owner.threadinit('c:/tmp/cardatabase2.db')
Owner.inittable(name="")<span class="strong"><strong>
class CarOwner(Relation): pass
CarOwner.threadinit('c:/tmp/cardatabase2.db')
CarOwner.inittable(Car,Owner)</strong></span>
mycar = Car(make="Volvo",model="C30",licenseplate="12-abc-3")
mycar2 = Car(make="Renault",model="Coupe",licenseplate="45-de-67")
me = Owner(name="Michel")<span class="strong"><strong>
CarOwner.add(mycar,me)
CarOwner.add(mycar2,me)</strong></span>
owners = CarOwner.list(mycar)
for r in owners:
	print(Car(id=r.a_id).make,'owned by',Owner(id=r.b_id).name)
owners = CarOwner.list(me)
for r in owners:
	print(Owner(id=r.b_id).name,'owns a',Car(id=r.a_id).make)
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Like before, we first define a<code class="literal"> Car</code> class and then an<code class="literal"> Owner</code> class because the<code class="literal"> CarOwner</code> class we define and initialize in the first highlighted lines are only meaningful if the entities in the relation exist. The highlighted lines show that defining and initializing a relation follows the same general pattern as initializing the entities.<a id="id233" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">We then create two<code class="literal"> Car</code> entities and an<code class="literal"> Owner</code> and establish a relation between these (second set of highlighted lines).</li><li class="listitem" style="list-style-type: disc">The final lines show how we can find and print the owners of a car or the cars belonging to an owner.</li></ul></div><p>Many of these requirements for the<code class="literal"> Relation</code> class are similar to those of the<code class="literal"> Entity</code> class, so when we take a look at the code, some pieces will look familiar.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec06"/>What just happened?</h2></div></div></div><p>The first method we encounter is the<code class="literal"> threadinit()</code> class method (the full code is available as<code class="literal"> relation.py)</code>. It is identical to the one we encountered in the<code class="literal"> Entity</code> class and should be called once for every thread.</p><p>
<span class="strong"><strong>Chapter5/relation.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@classmethod
def threadinit(cls,db):
		if not hasattr(cls.threadlocal,'connection') or 
cls.threadlocal.connection is None:
				cls.threadlocal.connection=sqlite.connect(db)
				cls.threadlocal.connection.row_factory = sqlite.Row
				cls.threadlocal.connection.execute(
													"pragma 
foreign_keys=1")
</pre></div><p>The<code class="literal"> inittable()</code> class method is the method that should be called once when we start an application:</p><p>
<span class="strong"><strong>Chapter5/relation.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@classmethod
def inittable(cls, entity_a, entity_b,
							reltype="N:N", cascade=None):<span class="strong"><strong>
	sql='''create table if not exists %(table)s (
			%(a)s_id references %(a)s on delete cascade,
			%(b)s_id references %(b)s on delete cascade,
			unique(%(a)s_id,%(b)s_id)
	);
	'''%{'table':cls.__name__,
				'a':entity_a.__name__,'b':entity_b.__name__}</strong></span>
	with cls.threadlocal.connection as conn:
			cursor=conn.cursor()
			cursor.execute(sql)
	cls.columns=[entity_a.__name__,entity_b.__name__]
</pre></div><p>It takes the two classes involved in the relations as arguments to construct a proper SQL statement to create a bridging table if it does not exist yet (highlighted).<a id="id234" class="indexterm"/>
</p><p>For example,<code class="literal"> CarOwner.inittable(Car,Owner)</code> will result in a statement like this:</p><div class="informalexample"><pre class="programlisting">
create table if not exists CarOwner (
				Car_id references Car on delete cascade,
				Owner_id references Owner on delete cascade,
				unique(Car_id,Owner_id)
</pre></div><p>There are a couple of interesting things to note here. There are two columns each referring to a table by way of the<code class="literal"> references</code> clause. Because we do not explicitly state<span class="emphasis"><em> which</em></span> column we reference inside the table, the reference is made to the primary key. This is a convenient way to write this down and works because we always define a proper primary key for any table that represents an entity.</p><p>Another thing to note is the<code class="literal"> on delete cascade</code> clause. This helps us to maintain something called<span class="strong"><strong> referential integrity</strong></span>. It ensures that when the record that is referenced is deleted, the records in the bridging table that refer to it are deleted as well. This way, there will never be entries in a table that represent a relation that points to non-existing entities. To ensure that this referential integrity checking is actually performed, it is necessary to execute a<code class="literal"> pragma foreign_keys = 1</code> instruction for each connection to the database. This is taken care of in the<code class="literal"> threadinit()</code> method.</p><p>Finally, there is a<code class="literal"> unique</code> constraint over both the columns. This effectively ensures that we only maintain, at most, a single entry in this table for each relation between two entities. That is, if I own a car, I can enter this specific relation only once.</p><p>If the execution of this statement went well,<code class="literal"> inittable()</code> finishes with storing the names of the entity classes that this relation refers to in the<code class="literal"> columns</code> class variable.<a id="id235" class="indexterm"/>
</p></div><div class="section" title="Pop quiz how to check a class"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec07"/>Pop quiz how to check a class</h2></div></div></div><p>How can we make sure that the classes we are passing as arguments to the<code class="literal"> initdb()</code> method are subclasses of<code class="literal"> Entity?</code>
</p></div><div class="section" title="Relation instances"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec08"/>Relation instances</h2></div></div></div><p>The<code class="literal"> __init__()</code> method constructs an instance of a<code class="literal"> Relation</code>, that is, we use it to record the relation between two specific entities.<a id="id236" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/relation.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def __init__(self,a_id,b_id,stub=False):
		self.a_id=a_id
		self.b_id=b_id
		if stub : return
		cols=self.columns[0]+"_id,"+self.columns[1]+"_id"
		sql='insert or replace into %s (%s) values(?,?)'%(
			self.__class__.__name__,cols)
		with self.threadlocal.connection as conn:
			cursor=conn.cursor()
			cursor.execute(sql,(a_id,b_id))
			if cursor.rowcount!=1:
					raise ValueError()
</pre></div><p>It takes the IDs of both<code class="literal"> Entity</code> instances that are involved in this specific relation and a<code class="literal"> stub</code> parameter.</p><p>The<code class="literal"> __init__()</code> method is not meant to be called directly as it doesn't know nor check whether the IDs passed to it make any sense. It simply stores those IDs if the<code class="literal"> stub</code> parameter is true or inserts a record in the table if it isn't.</p><p>Normally, we would use the<code class="literal"> add()</code> method to create a new relationship with all necessary type checking. Separating this makes sense as all this checking is expensive and is unnecessary if we know that the IDs we pass are correct. The<code class="literal"> list()</code> method of the<code class="literal"> Relation</code> class for example retrieves only pairs of valid IDs so that we can use the<code class="literal"> __init__()</code> method without the need for costly additional checks.</p><p>The SQL statement that is constructed may look like this for a new<code class="literal"> CarOwner</code> relation:<a id="id237" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">insert or replace into CarOwner (Car_id,Owner_id) values(?,?)
</pre></div><p>If we would try to insert a second relation between the same entities, the<code class="literal"> unique</code> constraint on both columns together would be violated. If so, the<code class="literal"> insert or replace</code> clause would make sure that the insert statement wouldn't fail, but there still would be just one record with these two IDs.</p><p>Note that the insert statement could fail for another reason. If either of the IDs we try to insert does not refer to an existing record in the table it refers to, it would fail with an exception<code class="literal"> sqlite3.IntegrityError: foreign key constraint failed</code>.</p><p>The final sanity check in the last line is to use the<code class="literal"> rowcount</code> attribute to verify that just one record was inserted.</p><p>The<code class="literal"> add()</code> method<span class="emphasis"><em> does</em></span> make sure that the instances passed to it are in the correct order by checking the names of the classes against the names of the columns stored by the<code class="literal"> inittable()</code> method. It raises a<code class="literal"> ValueError()</code> if this is not correct, otherwise it instantiates a new relation by calling the class constructor with both IDs.</p><p>
<span class="strong"><strong>Chapter5/relation.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@classmethod
def add(cls,instance_a,instance_b):
		if instance_a.__class__.__name__ != cls.columns[0] :
				raise ValueError("instance a, wrong class")
		if instance_b.__class__.__name__ != cls.columns[1] :
				raise ValueError("instance b, wrong class")
		return cls(instance_a.id,instance_b.id)
</pre></div><p>The<code class="literal"> list()</code> method is meant to return a list of zero or more<code class="literal"> Relation</code> objects.</p><p>
<span class="strong"><strong>Chapter5/relation.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@classmethod
def list(cls,instance):
		sql='select %s_id,%s_id from %s where %s_id = ?'%(
				cls.columns[0],cls.columns[1],
				cls.__name__,instance.__class__.__name__)
		with cls.threadlocal.connection as conn:
				cursor=conn.cursor()
				cursor.execute(sql,(instance.id,))
				return [cls(r[0],r[1],stub=True)
								for r in cursor.fetchall()]
</pre></div><p>It needs to work for both sides of the relation: if we pass a<code class="literal"> Car</code> instance, for example, to the<code class="literal"> list()</code> method of the<code class="literal"> CarOwner</code> class, we should find all records where the<code class="literal"> Car_id</code> column matches the<code class="literal"> id</code> attribute of the<code class="literal"> Car</code> instance.<a id="id238" class="indexterm"/>
</p><p>Likewise, if we pass an<code class="literal"> Owner</code> instance, we should find all records where the<code class="literal"> Owner_id</code> column matches the<code class="literal"> id</code> attribute of the<code class="literal"> Owner</code> instance. But precisely because we gave the columns in the table that represents the relation meaningful names derived from the names of the classes and hence the tables, this is rather straightforward. For example, the SQL constructed for<code class="literal"> CarOwner.list(car)</code> might look like the following:</p><div class="informalexample"><pre class="programlisting">select Car_id,Owner_id from CarOwner where Car_id = ?
</pre></div><p>Whereas the SQL for<code class="literal"> CarOwner.list(owner)</code> would look like the following:</p><div class="informalexample"><pre class="programlisting">select Car_id,Owner_id from CarOwner where Owner_id = ?
</pre></div><p>This is accomplished by referring to the class name of the instance passed as argument (highlighted).</p><p>After executing this SQL statement, the results are fetched with the<code class="literal"> fetchall()</code> method and returned as a list of relation instances. Note that this list may be of zero length if there weren't any matching relations.</p><p>The last method of note defined for the<code class="literal"> Relation</code> class is the<code class="literal"> delete()</code> method.</p><p>
<span class="strong"><strong>Chapter5/relation.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def delete(self):
		sql='delete from %s where %s_id = ? and %s_id = ?'%(
			self.__class__.__name__,self.columns[0],self.columns[1])
		with self.threadlocal.connection as conn:
			cursor=conn.cursor()
			cursor.execute(sql,(self.a_id,self.b_id))
			if cursor.rowcount!=1:
					raise ValueError()
</pre></div><p>It constructs an SQL delete statement which, in our<code class="literal"> CarOwner</code> example, may look like this:</p><div class="informalexample"><pre class="programlisting">delete from CarOwner where Car_id = ? and Owner_id = ?
</pre></div><p>The sanity check we perform in the last line means that an exception is raised if the number of deleted records is not exactly one.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note21"/>Note</h3><p>If there was not exactly one record deleted, what would that signify?</p><p>If it would be more than one, that would indicate a serious problem because all the constraints are there to prevent that there is never more than one record describing the same relationship, but if it would be zero, this would probably mean we try to delete the same relationship more than once.</p><p>You might wonder why there isn't any method to update a<code class="literal"> Relation</code> object in any way. The reason is that this hardly makes any sense: either there is a relation between two entity instances or there isn't. If we would like to transfer ownership of a car, for example, it is just as simple to delete the relation between the car and the current owner and then add a new relation between the car and the new owner.</p></div><p>Now that we have a simple Entity and Relation framework, let's look at how we can use this to implement the foundation of our books application.<a id="id239" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action defining the Books database"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec05"/>Time for action defining the Books database</h1></div></div></div><p>The next step is to create a module<code class="literal"> booksdb.py</code> that uses the<code class="literal"> entity</code> and<code class="literal"> relation</code> modules to construct a data model that can be used conveniently by the delivery layer (the parts of the web application that deal with providing content to the client). We therefore have to define<code class="literal"> Book, Author</code>, and<code class="literal"> User</code> entities as well as a<code class="literal"> BookAuthor</code> relation and a<code class="literal"> UserBook</code> relation.<a id="id240" class="indexterm"/>
</p><p>We will also provide some functions that are bit more high-level, for example, a<code class="literal"> newbook()</code> function that checks whether a book with a given title already exists and that only creates a new<code class="literal"> Book</code> instance if the authors are different (presumably because they wrote a book with the same title).</p><p>Having a separate layer that models data in terms that are meaningful in the context makes it easier to understand what is going on. It also keeps the delivery layer less cluttered and therefore easier to maintain.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec09"/>What just happened?</h2></div></div></div><p>After importing the<code class="literal"> Entity</code> and<code class="literal"> Relation</code> class, the first thing we do is define the appropriate entities and relations (the full code is available as<code class="literal"> booksdb.py)</code>. The first function we encounter is<code class="literal"> threadinit()</code> (highlighted). It is a convenience function that calls all the individual<code class="literal"> threadinit()</code> methods of the different entities and relations we have defined:</p><p>
<span class="strong"><strong>Chapter5/booksdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
from entity import Entity
from relation import Relation
class Book(Entity):
	pass
class Author(Entity):
	pass
class User(Entity):
	pass
class BookAuthor(Relation):
	pass
class UserBook(Relation):
	pass<span class="strong"><strong>
def threadinit(db):</strong></span>
	Book.threadinit(db)
	Author.threadinit(db)
	User.threadinit(db)
	BookAuthor.threadinit(db)
	UserBook.threadinit(db)
</pre></div><p>Likewise, the<code class="literal"> inittable()</code> function is a convenience function that calls all the necessary<code class="literal"> inittable()</code> methods:<a id="id241" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/booksdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def inittable():
	Book.inittable(title="",isbn="unique",publisher="")
	Author.inittable(name="")
	User.inittable(userid="unique not null")
	BookAuthor.inittable(Book,Author)
	UserBook.inittable(User,Book)
</pre></div><p>It defines a<code class="literal"> Book</code> as a subclass of<code class="literal"> Entity</code> having a<code class="literal"> title</code>, a<code class="literal"> unique isbn</code>, and a<code class="literal"> publisher</code> attribute. An<code class="literal"> Author</code> is defined as a subclass of<code class="literal"> Entity</code> with just a<code class="literal"> name</code> attribute and a<code class="literal"> User</code> as an<code class="literal"> Entity</code> with just a<code class="literal"> userid</code> that must be unique and cannot be null. Also, the relations that exist between<code class="literal"> Book</code> and<code class="literal"> Author</code>, and<code class="literal"> User</code> and<code class="literal"> Book</code> are initialized here.</p><p>The<code class="literal"> newbook()</code> function should be used to add a new book to the database:</p><p>
<span class="strong"><strong>Chapter5/booksdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def newbook(title,authors,**kw):
	if not isinstance(title,str) :
			raise TypeError("title is not a str")
	if len(title)&lt;1 :
			raise ValueError("title is empty")
	for a in authors :
			if not isinstance(a,Author) :
				raise TypeError("authors should be of type Author")
bl=list(Book.list(title=title,**kw))<span class="strong"><strong>
if len(bl) == 0:
				b=Book(title=title,**kw)</strong></span>
elif len(bl) == 1:
				b=Book(id=bl[0])
else:
	raise ValueError("multiple books match criteria")
lba=list(BookAuthor.list(b))
if len(authors):
	lba=[Author(id=r.b_id) for r in lba]
	for a in authors:
			known=False
			for a1 in lba:
					if a.id == a1.id :
							known=True
							break
			if not known:
					r=BookAuthor.add(b,a)
return b
</pre></div><p>It takes a<code class="literal"> title</code> argument and a list of<code class="literal"> Author</code> objects and any number of optional keywords to select a unique book if the title is not sufficient to identify a book. If a book with the given title and additional keywords cannot be found, a new<code class="literal"> Book</code> object is created (highlighted). If more than one book is found that matches the criteria, an exception is raised.<a id="id242" class="indexterm"/>
</p><p>The next step is to retrieve a list of authors associated with this book. This list is used to check if any author in the list of authors passed to the<code class="literal"> newbook()</code> function is not already associated with this book. If not, this new author is added. This ensures we do not attempt to associate an author more than once with the same book, but it also makes it possible to add authors to the list of authors associated with an existing book.</p><p>The<code class="literal"> newauthor()</code> function verifies that the name passed as an argument is not empty and is indeed a string (highlighted):</p><p>
<span class="strong"><strong>Chapter5/booksdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def newauthor(name):<span class="strong"><strong>
	if not isinstance(name,str) :
			raise TypeError("name is not a str")</strong></span>
	if len(name)&lt;1 :
			raise ValueError("name is empty")
	al=list(Author.list(name=name))
	if len(al) == 0:
				a=Author(name=name)
	elif len(al) == 1:
				a=Author(id=al[0])
	else:
			raise ValueError("multiple authors match criteria")
	return a
</pre></div><p>Then it checks whether an author with such a name already exists. If it doesn't, a new<code class="literal"> Author</code> object is created and returned. If only one<code class="literal"> Author</code> was found, that one is returned without creating a new one. If the same name matched more than one<code class="literal"> Author</code>, an exception is raised because our current data model does not provide the notion of more than one author with the same name.<a id="id243" class="indexterm"/>
</p><p>An application to register books is most often used to see if we already own a book. A function to list books matching a set of criteria should therefore be quite flexible to provide the end user with enough functionality to make finding books as simple as possible, even if the books number is in the thousands.</p><p>The<code class="literal"> listbooks()</code> function tries to encapsulate the necessary functionality. It takes a number of keyword arguments used to match any number of books. If the<code class="literal"> user</code> argument is present, the results returned are limited to those books that are owned by that user. Likewise, the<code class="literal"> author</code> argument limits the results to books by that author. The<code class="literal"> pattern</code> argument may be a string that limits the books returned to those whose title contains the text in the<code class="literal"> pattern</code> argument.</p><p>Because the number of books matching the criteria could be very large,<code class="literal"> listbooks()</code> takes two additional parameters to return a smaller subset. This way, the delivery layer can offer the list of results in a page-by-page manner. The<code class="literal"> offset</code> argument determines the start of the subset and<code class="literal"> limit</code> of the number of results returned. If<code class="literal"> limit</code> is<code class="literal"> -1</code>, all results starting at the given<code class="literal"> offset</code> are returned. For example:</p><div class="informalexample"><pre class="programlisting">booksdb.listbooks(user=me,pattern="blind",limit=3)
</pre></div><p>Would return the first three books I own that have the text blind in their title.</p><p>Given these requirements, the implementation of<code class="literal"> listbooks()</code> is rather straightforward:<a id="id244" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/booksdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def listbooks(user=None,author=None,offset=0,limit=-1,pattern=""):
	lba={}
	lbu={}
	if not user is None:
			if not isinstance(user,User):
					raise TypeError("user argument not a User")<span class="strong"><strong>
			lbu={r.b_id for r in UserBook.list(user)}</strong></span>
	if not author is None:
			if not isinstance(author,Author):
					raise TypeError("author argument not an Author")
			lba={r.a_id for r in BookAuthor.list(author)}
	if user is None and author is None:<span class="strong"><strong>
			lb={b for b in Book.list()}</strong></span>
	else:
			if len(lbu)==0 : lb=lba
			elif len(lba)==0 : lb=lbu
			else : lb = lba &amp; lbu
	books = [Book(id=id) for id in lb]<span class="strong"><strong>
	books = sorted(books,key=lambda book:book.title.lower())</strong></span>
	if pattern != "" :
			pattern = pattern.lower()
			books = [b for b in books
								if b.title.lower().find(pattern)&gt;=0 ]
	if limit&lt;0 :
			limit=len(books)
	else:
			limit=offset+limit
	return len(books),books[offset:limit]
</pre></div><p>It starts by checking that any<code class="literal"> user</code> argument is indeed an instance of a<code class="literal"> User</code> entity and then finds all books owned by this user (highlighted) and converts this list to a<span class="strong"><strong> set</strong></span>. It checks any<code class="literal"> author</code> argument in a similar way. If neither an author nor a user was specified, we simply retrieve a list of all books (highlighted) and convert it to a set as well.<a id="id245" class="indexterm"/>
</p><p>Working with sets is convenient, as sets will never contain duplicates and can easily be manipulated. For example, if we have a non-empty set of books associated with an author and a non-empty set of books owned by a user, we can obtain the<span class="strong"><strong> intersection</strong></span> (that is, books both owned by the given owner and written by the given author) with the<code class="literal">&amp;</code> operator.</p><p>Either way, we end up with a list of book IDs in<code class="literal"> lb</code>. This list of IDs is then converted to<code class="literal"> Book</code> objects and sorted on the title to ensure consistent results when dealing with offsets (highlighted). The next step is to reduce the number of results to those books whose title contains the text in the<code class="literal"> pattern</code> argument.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note22"/>Note</h3><p>All this matching, sorting, and filtering could have been done with SQL as well and probably in a more efficient manner too. However, this would mean the SQL would be rather complicated and we would ruin the clear distinction between the low-level database operations defined in the<code class="literal"> entity</code> and<code class="literal"> relation</code> modules and the more high-level operations defined here in<code class="literal"> booksdb</code>. If efficiency was more important, that would be a valid argument, but here we choose for a clear separation to aid understanding, as Python is a lot easier to read than SQL.</p></div><p>All that is left now is to return the proper slice from the list of books based on the<code class="literal"> offset</code> and<code class="literal"> limit</code> arguments, as shown in the last line of the<code class="literal"> listbooks()</code> function. Note that we actually return a tuple, the first item being the total number of matching books, the second item the actual list of matching books. This makes it simple to present information to the end user like 'showing items 20-29 of 311'.</p><p>The<code class="literal"> listauthors()</code> function either returns a list of authors associated with a book if a<code class="literal"> book</code> argument is given or a list of all authors:</p><p>
<span class="strong"><strong>Chapter5/booksdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def listauthors(book=None):
	if not book is None:
			if not isinstance(book,Book):
					raise TypeError("book argument not a Book")
			la=[r.b_id for r in BookAuthor.list(book)]
	else:
			la=Author.list()
	return [Author(id=id) for id in la]
</pre></div><p>It does make sure that any<code class="literal"> book</code> argument is indeed an instance of a<code class="literal"> Book</code> entity.</p><p>
<code class="literal">checkuser()</code> may be called to see if there already exists a user with the given username and if not creates one:</p><p>
<span class="strong"><strong>Chapter5/booksdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def checkuser(username):
	users=list(User.list(userid=username))
	if len(users):
			return User(id=users[0])
	return User(userid=username)
</pre></div><p>Any user that uses this application should have a corresponding<code class="literal"> User</code> entity, if he/she wants to be able to register his/her ownership of a book. This function makes sure this is possible.<a id="id246" class="indexterm"/>
</p><p>Note that our application does not<span class="emphasis"><em> authenticate</em></span> a user at this level, that is left to the delivery layer as we will see. Any authentication database the delivery layer uses is completely separate from the<code class="literal"> User</code> entity in our books database. The delivery layer may, for example, use the system password database to authenticate a user and pass the username to this layer if the authentication was successful. If, at that point, the user does not yet exist in our books database, we can make sure he does by calling the<code class="literal"> checkuser()</code> function.</p><p>The<code class="literal"> addowner()</code> and<code class="literal"> delowner()</code> functions are used to establish or remove a specific ownership relation between a book and a user. Both are thin wrappers around the underlying methods in the<code class="literal"> Relation</code> class, but add some additional type checking.</p><p>
<span class="strong"><strong>Chapter5/booksdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def addowner(book,user):
	if not isinstance(book,Book):
			raise TypeError("book argument not a Book")
	if not isinstance(user,User):
			raise TypeError("user argument not a User")
	return UserBook.add(user,book)
def delowner(book,user):
	if not isinstance(book,Book):
			raise TypeError("book argument not a Book")
	if not isinstance(user,User):
			raise TypeError("user argument not a User")
	UserBook(user.id,book.id,stub=True).delete()
</pre></div><p>This foundation will be put to good use in the next section where we will implement the delivery layer.</p></div><div class="section" title="Pop quiz how to select a limited number of books"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec10"/>Pop quiz how to select a limited number of books</h2></div></div></div><p>How would you select the third page of 10 books from a list of all books in the database?</p></div><div class="section" title="Have a go hero cleaning up the books database"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec11"/>Have a go hero cleaning up the books database</h2></div></div></div><p>
<code class="literal">booksdb.py</code> lacks a<code class="literal"> delbooks()</code> function because we won't be providing this functionality in our final application. It is not a disadvantage to just remove ownership and leave the book as is, even if it doesn't have any owners because other users may register ownership by referring to this existing book without the need to enter it again. However, occasionally we might want to clean up the database. How would you implement a function that removes all books without an owner?<a id="id247" class="indexterm"/>
</p></div><div class="section" title="The delivery layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec12"/>The delivery layer</h2></div></div></div><p>Because we laid a substantial foundation with the<code class="literal"> entity, relation</code>, and<code class="literal"> booksdb</code> modules, we can now cleanly separate the delivery layer from the rest of the application. The delivery layer consists of just a couple of CherryPy applications. To authenticate a user, we will reuse the logon application we encountered in previous chapters and the rest of the application consists of a single<code class="literal"> Books</code> class with the necessary methods to provide two main screens: a navigable and filterable list of books and a screen to add new books to the database.<a id="id248" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action designing the delivery layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec06"/>Time for action designing the delivery layer</h1></div></div></div><p>To design these screens it is often convenient to make some drawings to have a visual representation of the screen. This makes it a lot easier to discuss functionality with your client.</p><p>There exist a number of good applications to assist you with drawing up some mock ups (for example, Microsoft's Expression Blend or Kaxaml<a class="ulink" href="http://kaxaml.com/)"> http://kaxaml.com/)</a> but often, especially in the early stages of designing an application, a simple drawing will do, even if it's hand drawn. The illustrations show the sketches I used in making a rough draft, both done with the GIMP (http://www.gimp.org/):</p><div class="mediaobject"><img src="images/3746_05_002.jpg" width="372" alt="Time for action designing the delivery layer"/></div><p>The first image is a sketch of the screen that lets the user interact with a list of books, the second image shows what a screen to add a new book could look like.<a id="id249" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746_05_003.jpg" height="188" alt="Time for action designing the delivery layer"/></div><p>Such images are easy to print and annotate during a discussion without the need for a computer application, all you need is a pen or pencil. Another useful designing technique is to draw some outline on a whiteboard and add details while you discuss functionality. At the end of the session, you can take a picture of the whiteboard with your cell phone and use that as a starting point. The design will likely change anyway during the development and starting with this simple approach saves a lot of effort that might have to be undone later on.</p><p>When we take a look at the design for the screen that lists the books we see immediately that the key functionality is all in the<span class="strong"><strong> button bar</strong></span>. Notably, we will have to implement functionality to:<a id="id250" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Show a list of books</li><li class="listitem" style="list-style-type: disc">Page forward and backward through this list</li><li class="listitem" style="list-style-type: disc">Limit the list of books to those owned by the current user</li><li class="listitem" style="list-style-type: disc">Filter the list of books on words occurring in the title</li></ul></div><p>The screen to add a new book is deceptively simple. The user must be able to enter a title and an author to indicate he owns a book, but this means that in the background, we have at least the following scenarios to check:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is no book in the database with the given title</li><li class="listitem" style="list-style-type: disc">There is a book with the given title but without the given author</li><li class="listitem" style="list-style-type: disc">The combination of book and author is known</li></ul></div><p>In the first situation, we have to create a new<code class="literal"> Book</code> entity, and possibly a new<code class="literal"> Author</code> entity if the author is unknown.</p><p>In the second situation, we will create a new<code class="literal"> Book</code> entity as well, because it is very well possible that different authors write books with the same title. In a more elaborate application, we might be able to make a distinction based on the ISBN.</p><p>In the last situation, we do not have to create a new<code class="literal"> Book</code> or an<code class="literal"> Author</code> entity, but we still have to make sure that we register ownership of that specific book.</p><p>The final requirement is one of convenience to the user. If there are many users entering books in the database, chances will grow that if someone registers a new book he/she owns, that book is already present in the database. To save the user some typing, it would be nice if we could present the user with a list of possible titles and authors while he/she types along. This is called auto completion and is fairly straightforward to implement with a combination of jQuery UI and Python.<a id="id251" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746_05_004.jpg" height="121" alt="Time for action designing the delivery layer"/></div><p>When<code class="literal"> booksweb.py</code> is started, the list of books will look like the preceding image and the page to add a new book is shown next. We will enhance these looks in the last section of this chapter, but we focus on the implementation of the delivery layer in<code class="literal"> booksweb.py</code> first.</p><div class="mediaobject"><img src="images/3746_05_005.jpg" height="49" alt="Time for action designing the delivery layer"/></div><p>Auto completion is a close companion of client-side input validation. By presenting the user with a list of possibilities to choose from, we lower the risk of a user entering a similar title with a slightly different spelling. Of course there are some additional checks to make: a title may not be empty, for example. If the user does make an erroneous entry, there should also be some sort of feedback so he/she can correct his mistake.<a id="id252" class="indexterm"/>
</p><p>Of course, client-side validation is a useful tool to enhance the user experience, but it doesn't protect us from malicious attempts to corrupt our data. Therefore, we have implemented some server-side checks as well.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec13"/>What just happened?</h2></div></div></div><p>We start off by creating a global variable that holds the basic HTML that we will use both in the booklist screen as well as in the add book screen (the full code is available as<code class="literal"> booksweb.py):</code>
<a id="id253" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/booksweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
with open('basepage.html') as f:
	basepage=f.read(-1)
</pre></div><p>We read it in from a separate file instead of storing it inside the module as a string. Storing the HTML in a separate file makes it a lot easier to edit because the editor can use syntax highlighting for HTML instead of just marking it as a string literal in Python. The file is available as<code class="literal"> basepage.html:</code>
</p><p>
<span class="strong"><strong>Chapter5/basepage.html</strong></span>
</p><div class="informalexample"><pre class="programlisting">
&lt;html&gt;&lt;head&gt;&lt;title&gt;Books&lt;/title&gt;<span class="strong"><strong>
&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.
min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.3/
jquery-ui.min.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/
jqueryui/1.8.3/themes/smoothness/jquery-ui.css" type="text/css" 
media="all" /&gt;</strong></span>
&lt;link rel="stylesheet" href="http:///books.css" type="text/css" media="all" 
/&gt;
&lt;/head&gt;&lt;body&gt;
&lt;div id="content"&gt;%s&lt;/div&gt;
&lt;script src="/booksweb.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>This time, we choose to incorporate all external libraries from Google's content delivery network (highlighted).</p><p>You might not want to depend on an external agency for your production application, but for development, this is an advantage as you don't have to lug around those files. But even in a production environment, this choice may make sense as this option will reduce the number of requests made to your server and minimize the bandwidth. Likewise, we refer to the cascading style sheets and accompanying files for our chosen theme (Smoothness) on Google's content delivery network.<a id="id254" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note23"/>Note</h3><p>Besides Google, a number of other large players offer a Content Delivery Network (CDN) that you may use. Even Microsoft (http://www.asp.net/ajaxlibrary/cdn.ashx) offers free access to the jQuery and jQuery UI libraries on its CDN.</p></div><p>The head section also contains a link to an additional style sheet<code class="literal"> books.css</code> that will be used to tweak the layout and style of the elements that are not jQuery UI widgets.</p><p>The body is a single<code class="literal">&lt;div&gt;</code> element with a<code class="literal"> %s</code> placeholder to be filled with different relevant markup for the booklist and new book pages, followed by a<code class="literal">&lt;script&gt;</code> tag that will provide other script elements within the specific pages with common functionality.</p><p>
<code class="literal">booksweb.py</code> continues with the definition of the<code class="literal"> Books</code> class that will act as the central application in the CherryPy framework for this application.</p><p>
<span class="strong"><strong>Chapter5/booksweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
class Books():
	def __init__(self,logon,logoffpath):
			self.logon=logon
			self.logoffpath=logoffpath
	@cherrypy.expose
	def index(self):
			username = self.logon.checkauth()
			return basepage % '&lt;div id="booklist"&gt;&lt;/div&gt;'
</pre></div><p>The<code class="literal"> index()</code> function serves<code class="literal"> basepage.html</code> with a single<code class="literal">&lt;div&gt;</code> element that will hold the content.</p><p>The<code class="literal"> list()</code> method will be called from JavaScript functions defined in<code class="literal"> booksweb.js</code> once it loads and will be used to fill the content<code class="literal">&lt;div&gt;</code> initially, as well as refresh the contents of this div when the buttons in the navigation button bar are pressed.</p><p>Before we examine the<code class="literal"> list()</code> and<code class="literal"> addbook()</code> methods, let's have a look at the JavaScript in<code class="literal"> booksweb.js</code> to see how these methods are invoked from the AJAX calls in the client (the full JavaScript code is available as<code class="literal"> booksweb.js)</code>.</p><p>
<span class="strong"><strong>Chapter5/booksweb.js</strong></span>
</p><div class="informalexample"><pre class="programlisting">
$.ajaxSetup({cache:false,type:"GET"});
</pre></div><p>The first activity we encounter in<code class="literal"> booksweb.js</code> is setting global defaults for all AJAX calls. We disable caching to make sure the browser executes an AJAX call every time we ask it to, without checking if it made a call to the same URL earlier, because otherwise we would not actually refresh the content of our list of books.<a id="id255" class="indexterm"/>
</p><p>For debugging purposes, we also make sure every AJAX call uses the HTTP<code class="literal"> GET</code> method because arguments to a<code class="literal"> POST</code> call are not logged normally while arguments to a<code class="literal"> GET</code> are part of the URL of the request.</p><p>The<code class="literal"> prepnavbar()</code> function we encounter next is our workhorse: every time we make the URL<code class="literal"> /books/list</code> get a list of books,<code class="literal"> prepnavbar()</code> is called once the request is completed.</p><p>
<span class="strong"><strong>Chapter5/booksweb.js</strong></span>
</p><div class="informalexample"><pre class="programlisting">
function prepnavbar(response, status, XMLHttpRequest){
	$("#firstpage").button({
				text: false,
				icons: {
						primary: "ui-icon-seek-start"
				}
	});
	$("#previouspage").button({
				text: false,
				icons: {
						primary: "ui-icon-seek-prev"
				}
	});
	$("#mine").button({
				text: false,
				icons: {
						primary: "ui-icon-tag"
				}
	});
	$("#nextpage").button({
				text: false,
				icons: {
						primary: "ui-icon-seek-next"
				}
	});
	$("#lastpage").button({
				text: false,
				icons: {
						primary: "ui-icon-seek-end"
				}
	});
	$("#addbook").button({
				text: false,
				icons: {
						primary: "ui-icon-plusthick"
				}
	});
	t=$("#toolbar").buttonset();
	$("span",t).css({padding:"0px"});
	$(".bookrow:odd").addClass('oddline');
};
$("#booklist").load('/books/list',prepnavbar);$("#booklist").load('/
books/list',prepnavbar);
</pre></div><p>The HTML returned by<code class="literal"> /books/list</code> not only contains the matching books, but also the navigation buttons themselves together with additional information on the number of matching books returned. These navigation buttons are not yet styled and configuring this is the task of the<code class="literal"> prepnavbar()</code> function.<a id="id256" class="indexterm"/>
</p><p>It styles each button (except for the input button that is used to filter on text) as a jQuery UI button widget without text but with an appropriate icon. It also adds the<code class="literal"> oddline</code> class to each odd row of the<code class="literal"> bookrow</code> class, so we can refer to this class in our style sheet to give it distinctive zebra stripes, for example.</p><p>When<code class="literal"> booksweb.js</code> is executed, the content of the page consists of an empty<code class="literal">&lt;div&gt;</code>. This<code class="literal">&lt;div&gt;</code> element is filled with HTML returned by calling the<code class="literal"> /books/list</code> URL with parameters (last line). The<code class="literal"> prepnavbar()</code> function is passed as the second argument to the<code class="literal"> load()</code> method and will be called once loading the data is completed.</p><p>The remaining part of<code class="literal"> booksweb.js</code> is filled with adding live click handlers to all navigation buttons.</p><p>
<span class="strong"><strong>Chapter5/booksweb.js</strong></span>
</p><div class="informalexample"><pre class="programlisting">
function getparams(){
	var m=0;
	// apparently the checked attr of a checkbox is magic:
// it returns true/false, not the contents!
	if ( $("#mine").attr("checked")==true ) { m = 1}
	return { offset:Number($("#firstid").text()),
			limit:Number($("#limitid").text()),
				filter:$("#filter").val(),
				mine:m
			};
};
$("#mine").live('click',function(){
	// this function is fired *after* the click
// toggled the checked attr
	var data = getparams();
	if (data.mine) {
			$("#mine").removeAttr("checked");
	} else {
			$("#mine").attr("checked","yes");
	}
	$("#booklist").load('/books/list',data,prepnavbar);
	return true;
});<span class="strong"><strong>
$("#firstpage").live('click',function(){
	var data = getparams();
	data.offset=0;
	$("#booklist").load('/books/list',data,prepnavbar);
	return true;
});</strong></span>
$("#previouspage").live('click',function(){
	var data = getparams();
	data.offset -= data.limit;
	if(data.offset&lt;0){ data.offset=0;}
	$("#booklist").load('/books/list',data,prepnavbar);
	return true;
});
$("#nextpage").live('click',function(){
	var data = getparams();
	var n=Number($("#nids").text())
	data.offset += data.limit;
	if(data.offset&gt;=n){ data.offset=n-data.limit;}
	if(data.offset&lt;0){ data.offset=0;}
	$("#booklist").load('/books/list',data,prepnavbar);
	return true;
});
$("#lastpage").live('click',function(){
	var data = getparams();
	var n=Number($("#nids").text())
	data.offset = n-data.limit;
	if(data.offset&lt;0){ data.offset=0;}
	$("#booklist").load('/books/list',data,prepnavbar);
	return true;
});
$("#filter").live('keyup',function(event){
	if (event.keyCode == '13') {
			event.preventDefault();
			data = getparams();
			data.offset=0;
			$("#booklist").load('/books/list',data,prepnavbar);
	}
	return true;
});
$("#addbook").live('click',function(){
	window.location.href="http:///books/addbook";
	return true;
});
</pre></div><p>A live handler will be attached to any element that matches its selector, even elements that are not present yet in the documents. This will ensure that when we reload the list of books complete with new navigation buttons, the click handlers we define here will be bound to these new buttons as well.<a id="id258" class="indexterm"/>
</p><p>Each of these handlers call the<code class="literal"> getparams()</code> function to retrieve the information contained in the<code class="literal">&lt;p&gt;</code> element with the<code class="literal"> id="info</code>". This data is returned as a JavaScript object that may be passed to the<code class="literal"> load()</code> method. The<code class="literal"> load()</code> method will append the attributes in this object as parameters to the URL it calls. The information in the object reflects the currently listed books and each handler modifies this data according to its function.</p><p>For example, the handler for the<code class="literal"> #firstpage</code> button (highlighted) modifies the<code class="literal"> offset</code> attribute. It simply sets it to zero before calling<code class="literal"> /books/load</code> to retrieve the first set of books.</p><p>The handler for the<code class="literal"> #previouspage</code> button subtracts the value of the<code class="literal"> limit</code> attribute from offset to get the previous page full of books, but makes sure that the offset is not smaller than zero. The handlers for the other clickable buttons perform similar actions before calling<code class="literal"> /books/load</code>.</p><p>The exception is the handler for the<code class="literal"> #mine</code> button, that does not manipulate offsets but toggles the<code class="literal"> checked</code> attribute.</p><p>The<code class="literal"> #pattern</code> input element is different as well. It doesn't act on a click, but reacts on pressing the<span class="emphasis"><em> return</em></span> key. If that key is pressed, it also calls<code class="literal"> getparams()</code> just like the other handlers. The object retrieved this way will also contain a<code class="literal"> pattern</code> attribute, which holds the value of the<code class="literal"> #pattern</code> input element that was just entered by the user. The<code class="literal"> offset</code> attribute is set to zero to ensure that when we pass on a new pattern value, we start viewing the resulting list at the start.</p><p>Let's return to the server-side in<code class="literal"> booksweb.py</code> and see how the<code class="literal"> list()</code> method is implemented.<a id="id259" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/booksweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def list(self,offset=0,limit=10,mine=1,pattern="",_=None):
		username = self.logon.checkauth()
		userid=booksdb.checkuser(username)
		try:
			offset=int(offset)<span class="strong"><strong>
			if offset&lt;0 : raise ValueError("offset &lt; 0")</strong></span>
		except ValueError:
			raise TypeError("offset not an integer")
		try:
			limit=int(limit)
			if limit&lt;-1 : raise ValueError("limit &lt; -1")
		except ValueError:
			raise TypeError("limit not an integer")
		try:
			mine=int(mine)
		except ValueError:
			raise TypeError("mine not an integer")
		if not mine in (0,1) :
			raise ValueError("mine not in (0,1)")
		if len(pattern)&gt;100 :
			raise ValueError("length of pattern &gt; 100")
		# show titles
		yield '&lt;div class="columnheaders"&gt;&lt;div class="title"&gt;Title&lt;/
div&gt;&lt;div class="author"&gt;Author&lt;/div&gt;&lt;/div&gt;'
		# get matching books
		if mine==0 : userid=None
		n,books = booksdb.listbooks(user=userid,
				offset=offset,limit=limit,pattern=pattern)
		# yield them as a list of divs
		for b in books:<span class="strong"><strong>
				a1=booksdb.listauthors(b)[0]</strong></span>
				yield '''&lt;div id="%d" class="bookrow"&gt;
&lt;div class="title"&gt;%s&lt;/div&gt;
&lt;div class="author"&gt;%s&lt;/div&gt;
&lt;/div&gt;'''%(b.id,b.title,a1.name)
		# yield a line of navigation buttons
		yield '''&lt;div id="navigation"&gt;
&lt;p id="info"&gt;Showing
&lt;span id="limitid"&gt;%d&lt;/span&gt; of
&lt;span id="nids"&gt;%d&lt;/span&gt; items,
owned by &lt;span id="owner"&gt;%s&lt;/span&gt; starting at
&lt;span id="firstid"&gt;%d&lt;/span&gt;
&lt;/p&gt;
&lt;div id="toolbar"&gt;
&lt;button id="firstpage" value="First"&gt;First&lt;/button&gt;
&lt;button id="previouspage" value="Previous"&gt;Prev&lt;/button&gt;
&lt;input id="mine" type="checkbox" %s /&gt;&lt;label for="mine"&gt;Mine&lt;/label&gt;
&lt;input id="pattern" type="text" value="%s" /&gt;
&lt;button id="nextpage" value="Next" &gt;Next&lt;/button&gt;
&lt;button id="lastpage" value="Last" &gt;Last&lt;/button&gt;
&lt;button id="addbook" value="Add"&gt;Add&lt;/button&gt;
&lt;/div&gt;
&lt;/div&gt;'''%(limit,n,username if mine else "all",
					offset,'checked="yes"'if mine else "", pattern)
</pre></div><p>The<code class="literal"> list()</code> method takes a number of keyword arguments to determine which books to return. It doesn't return a complete HTML page but just a list of<code class="literal">&lt;div&gt;</code> elements representing the selection of books together with some additional information on the number of books selected and the button elements used to browse through the list:<a id="id260" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<code class="literal"> offset</code> argument determines where the list of matching books will start. Counting starts at 0.</li><li class="listitem" style="list-style-type: disc">The<code class="literal"> limit</code> argument determines the number of matching books to return. This is a maximum, less books will be returned if they are not available. When we have 14 matching books, an offset of 10, with a limit of 10, will return 10 books through 13.</li><li class="listitem" style="list-style-type: disc">If the<code class="literal"> mine</code> argument is non-zero, the list of matching books is limited to the ones owned by the user issuing the request.</li><li class="listitem" style="list-style-type: disc">if the<code class="literal"> pattern</code> argument is not an empty string, the list of matching books is limited to the ones that contain the pattern string in their title.<a id="id261" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">The<code class="literal"> _</code> (underscore) argument is ignored. We configured our AJAX calls not to be cached (in<code class="literal"> booksweb.js)</code> and jQuery prevents caching by appending each time an<code class="literal"> _</code> argument with a random value to the URL it requests. The URL will look different each time to the browser this way, and this will prevent caching.</li></ul></div><p>The implementation of the<code class="literal"> list()</code> method starts off by validating that the user is logged in and then retrieving the corresponding<code class="literal"> User</code> object. The next steps systematically validate the arguments passed to the method and raise a<code class="literal"> ValueError</code> or<code class="literal"> TypeError</code> if something fails to validate. The<code class="literal"> offset</code> argument, for example, should be larger or equal to zero (highlighted).</p><p>Once the arguments are validated, these are handed off to the<code class="literal"> booksdb.listbooks()</code> function, that will take care of the actual selection and will return a tuple consisting of the number of matching books and the actual list of books sorted on their title.</p><p>This list of books is used to step through and generate the appropriate HTML markup. For each book, we fetch the authors of the book (highlighted) and then yield a string with HTML markup. This HTML contains the title of the book and the name of the first author. If there is more information we would like to present, for example, the ISBN of the book, we could easily add it here. By using<code class="literal"> yield</code> to return the results one-by one, we save ourselves the trouble of constructing a complete string first before returning it in one go.</p><p>The final<code class="literal"> yield</code> statement contains a<code class="literal">&lt;div&gt;</code> element with the<code class="literal"> id="navigation</code>". We choose to return the complete navigation markup, including buttons, to enable us to easily set the values of these buttons. The pattern<code class="literal">&lt;input&gt;</code> element, for example, should display the current text we filter on. We could pass this as separate information and use client-side JavaScript to set these values but this would complicate the JavaScript quite a bit.<a id="id262" class="indexterm"/>
</p><p>Still, the<code class="literal"> offset</code> and<code class="literal"> limit</code> values together with the total number of matching books is returned inside a<code class="literal">&lt;p&gt;</code> element. This serves two goals: we can display this as an informational message to the user, but it is also necessary information for the navigation buttons to function.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action adding a new book"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec07"/>Time for action adding a new book</h1></div></div></div><p>The screen to add a new book to the database is a simple form. What we need to implement is:<a id="id263" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Some HTML to make it possible to display the form</li><li class="listitem" style="list-style-type: disc">A method in our CherryPy application that will produce this HTML</li><li class="listitem" style="list-style-type: disc">A method to process the input once this form is submitted</li></ul></div><p>There is no need to implement two different methods here because based on the arguments passed to the method we can decide whether to return a form or to process the submitted contents of the same form. Although it may be considered bad form to design a method to do two things, it does keep related functionality together.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec14"/>What just happened?</h2></div></div></div><p>The<code class="literal"> addbookform</code> class variable contains the template that refers to a number of string variables to interpolate. There is also a<code class="literal">&lt;script&gt;</code> element to add some extra functionality that we examine later:</p><p>
<span class="strong"><strong>Chapter5/booksweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
	addbookform='''&lt;div id="newbook"&gt;
&lt;form action="addbook" method="get"&gt;
&lt;fieldset&gt;&lt;legend&gt;Add new book&lt;/legend&gt;
&lt;input name="title" id="title" type="text" value="%(title)s" 
%(titleerror)s /&gt;
&lt;label for="title"&gt;Title&lt;/label&gt;
&lt;input name="author" id="author" type="text" value="%(author)s" 
%(authorerror)s /&gt;
&lt;label for="author"&gt;Author&lt;/label&gt;
&lt;/fieldset&gt;
&lt;div class="buttonbar"&gt;
&lt;button name="submit" type="submit" value="Add"&gt;Add&lt;/button&gt;
&lt;button name="cancel" type="submit" value="Cancel"&gt;Cancel&lt;/button&gt;
&lt;/div&gt;
&lt;/form&gt;
&lt;div id="errorinfo"&gt;&lt;/div&gt;
&lt;/div&gt;'''
</pre></div><p>The<code class="literal"> addbook()</code> method itself is used both to display the initial screen and to process the results, that is, it acts as the target of the<code class="literal">&lt;form&gt;</code> element's action attribute and processes the values from the various<code class="literal">&lt;input&gt;</code> and<code class="literal">&lt;button&gt;</code> elements.</p><p>All arguments are therefore keyword arguments with default values. If they are all missing,<code class="literal"> addbook()</code> will construct an empty form, otherwise it will check and process the information. In the latter case, there will be two possible scenarios: the values are ok, in which case a new book will be added and the user will be returned to the page with the book listing, or one or more of the values are not ok, in which case, the form is presented again, with suitable error markings, but with the entered values still in place for the user to edit.<a id="id264" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/booksweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def addbook(self,title=None,author=None,submit=None,cancel=None):
		username = self.logon.checkauth()
		userid=booksdb.checkuser(username)
		if not cancel is None: raise cherrypy.HTTPRedirect("/books")
		data=defaultdict(str)
		if submit is None:
				return basepage%(Books.addbookform%data)
		if title is None or author is None:
				raise cherrypy.HTTPError(400,'missing argument')
		data['title']=title
		data['author']=author
		try:
				a=booksdb.newauthor(author)
				try:
						b=booksdb.newbook(title,[a])
						booksdb.addowner(b,userid)
						raise cherrypy.HTTPRedirect("/books")
				except ValueError as e:
data['titleerror']= 'class="inputerror ui-state-error" 
title="%s"'%str(e)
			except ValueError as e:
data['authorerror']= 'class="inputerror ui-state-error" 
title="%s"'%str(e)
			return basepage%(Books.addbookform%data)
</pre></div><p>The<code class="literal"> addbook()</code> method first verifies if the user is logged in, and if so, fetches the corresponding<code class="literal"> User</code> object. The next step is to check if the cancel button contained in the form was clicked, in which case the<code class="literal"> cancel</code> argument will contain a value and the user will be redirected to the list of books (highlighted).</p><p>Next, we create a default dictionary that will return an empty string for every missing key that is accessed. This default dictionary will be used as interpolation data for strings in<code class="literal"> addbookform</code>. This way we can set a number of interpolation variables if we want to (for example,<code class="literal"> %(title)s</code> in the<code class="literal"> value</code> attribute of the<code class="literal">&lt;input&gt;</code> element for a title), but if we leave anything out, it will be automatically replaced by an empty string.</p><p>If the<code class="literal"> submit</code> argument is equal to None, this means it wasn't present, so<code class="literal"> addbook()</code> was called to display just the empty form and that is just what is done (highlighted). Because<code class="literal"> data</code> contains no keys at all at this moment,<span class="emphasis"><em> all</em></span> interpolation variables will yield an empty string resulting in an empty form.<a id="id265" class="indexterm"/>
</p><p>If the<code class="literal"> submit</code> argument was not None, we are processing the values in the form. First we perform a sanity check. If either the<code class="literal"> title</code> or the<code class="literal"> author</code> argument is missing, we raise an exception (highlighted). Even if the user failed to enter either of them, the corresponding values would be present in the arguments but as empty strings. So, if either of these arguments is missing completely, this cannot be the result of a user action and therefore it is sensible to raise an exception.</p><p>If both arguments are present, we save them in the default dictionary so that we can redisplay them as default values in the form, if we need to present the form again.</p><p>The next step is to try the<code class="literal"> newauthor()</code> function from the<code class="literal"> booksdb</code> module. It either returns a valid<code class="literal"> Author</code> object (because we already know the author or a new one was created) or it raises an exception. Such an exception is caught and the error text is added to the<code class="literal"> authorerror</code> key in the dictionary together with some HTML class attributes that will enable us to display the corresponding<code class="literal">&lt;input&gt;</code> element in a suitable manner to indicate the error condition.</p><p>Once we have a valid<code class="literal"> Author</code> object, the same approach is used to retrieve a valid<code class="literal"> Book</code> object. This may fail (mainly if the<code class="literal"> title</code> argument is an empty string) in which case we set the<code class="literal"> titleerror</code> key in the dictionary.</p><p>We end with establishing an ownership relation between the user and the book with a call to the<code class="literal"> addowner()</code> function and then redirect the user to the page that lists the books.</p><p>If anything goes wrong, we catch some exception and we end up at the return statement which will return the form again, only this time the dictionary will hold some keys that will be interpolated, resulting in suitable default values (for example, if a<code class="literal"> title</code> argument was empty, but the<code class="literal"> author</code> argument wasn't, the user doesn't have to enter the name of the author again) and information on the errors encountered.</p><p>All this string interpolation business might be a bit daunting, so let's have a brief look at an example. The definition for the title<code class="literal">&lt;input&gt;</code> element in the<code class="literal"> addbookform</code> variable looks like this:</p><div class="informalexample"><pre class="programlisting">
&lt;input name="title" id="title" type="text" value="%(title)s" 
%(titleerror)s /&gt;
</pre></div><p>If we want to present the user with an empty form, the string is interpolated with a default dictionary that holds no keys. The references<code class="literal"> %(title)s</code> and<code class="literal"> %(titlerror)s</code> will therefore come up with empty strings resulting in:</p><div class="informalexample"><pre class="programlisting">
&lt;input name="title" id="title" type="text" value="" /&gt;
</pre></div><p>A plain<code class="literal">&lt;input&gt;</code> element without a default value.<a id="id266" class="indexterm"/>
</p><p>Now if something went wrong with locating or creating an author, the dictionary would hold a<code class="literal"> title</code> key but no<code class="literal"> titleerror</code> key (but it would have an<code class="literal"> authorrerror</code> key). Assuming that the title entered by the user was "A book title", the resulting interpolation would therefore look like this:</p><div class="informalexample"><pre class="programlisting">
&lt;input name="title" id="title" type="text" value="A book title" /&gt;
</pre></div><p>Finally, if there was an error with the title, for example, because no book title was entered by the user, both the<code class="literal"> title</code> key would be present (albeit, in this case, as an empty string) and the<code class="literal"> titleerror</code> key. The value of the<code class="literal"> titleerror</code> key holds both the error message as an HTML<code class="literal"> title</code> attribute together with an HTML<code class="literal"> class</code> attribute that looks like this:</p><div class="informalexample"><pre class="programlisting">class="inputerror ui-state-error" title="title is empty"
</pre></div><p>So the final interpolation would result in:</p><div class="informalexample"><pre class="programlisting">
&lt;input name="title" id="title" type="text" value="" class="inputerror 
ui-state-error" title="title is empty" /&gt;
</pre></div></div><div class="section" title="Auto completion"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec15"/>Auto completion</h2></div></div></div><p>When we presented the HTML markup for the page that shows a form to add a new book, we skipped over the<code class="literal">&lt;script&gt;</code> element at the end. That script element is used to augment the title and author<code class="literal">&lt;input&gt;</code> elements with<span class="strong"><strong> auto completion</strong></span>.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action using input fields with auto completion"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec08"/>Time for action using input fields with auto completion</h1></div></div></div><p>With the<code class="literal">&lt;script&gt;</code> element in place, the input elements can now retrieve possible completions with an AJAX call. Now, when we enter a few characters in an input field, we are presented with a list of choices, as shown in the image:<a id="id267" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746_05_006.jpg" height="48" alt="Time for action using input fields with auto completion"/></div><p>Let's look in some detail at how this is implemented in, remarkably, a few lines of JavaScript.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec16"/>What just happened?</h2></div></div></div><p>If we look at the code again, we see that we call the<code class="literal"> autocomplete()</code> method on both the<code class="literal"> #title</code> and<code class="literal"> #author &lt;input&gt;</code> elements, but each with a different source argument. The<span class="strong"><strong> autocomplete widget</strong></span> in jQuery UI is very versatile and simple to apply (The code shown is part of<code class="literal"> booksweb.py</code>, but we skipped this earlier):<a id="id268" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/booksweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
&lt;script&gt;
$("#title" ).autocomplete({ source:'/books/gettitles',
											minLength:2}).focus();
$("#author").autocomplete({ source:'/books/getauthors',
											minLength:2});
&lt;/script&gt;
</pre></div><p>The<code class="literal"> source</code> attribute of the options object we pass to the<code class="literal"> autocomplete()</code> method holds a URL that will be used to retrieve a list of possible completions for the characters entered so far.</p><p>The<code class="literal"> minLength</code> attribute ensures that we only start looking for possible completions once the user has entered at least two characters, otherwise the list would probably be enormous and not much of a help. Note that it is still possible to enter a completely new value into an input field. The user is not obliged to pick an item from the list presented and can keep on typing.</p><p>The autocomplete widget adds the text entered so far as the<code class="literal"> term</code> argument to the<code class="literal"> source</code> URL. When the user has typed 'foo' in the<code class="literal"> #author &lt;input&gt;</code> element, this will result in a call to a URL like<code class="literal"> /books/getauthors?term=foo&amp;_=12345678</code>.</p><p>This means that the<code class="literal"> gettitles()</code> and<code class="literal"> getauthors()</code> methods will both take a<code class="literal"> term</code> argument (and an<code class="literal"> _</code> (underscore) argument to ensure nothing is cached):</p><p>
<span class="strong"><strong>Chapter5/booksweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
	def getauthors(self,term,_=None):
			return json.dumps(booksdb.getauthors(term))
@cherrypy.expose
def gettitles(self,term,_=None):
			titles=json.dumps(booksdb.gettitles(term))
			return titles
</pre></div><p>Both methods simply pass on the request to the corresponding<code class="literal"> booksdb</code> functions, but because autocomplete widgets expect the result as a JSON encoded string, we convert the list with the<code class="literal"> json.dumps()</code> function before returning it:<a id="id269" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter5/booksdb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def gettitles(term):
	titles=Book.getcolumnvalues('title')
	re=compile(term,IGNORECASE)
	return list(takewhile(lambda x:re.match(x),
							dropwhile(lambda x:not re.match(x),titles)))
def getauthors(term):
	names=Author.getcolumnvalues('name')
	re=compile(term,IGNORECASE)
	return list(takewhile(lambda x:re.match(x),
							dropwhile(lambda x:not re.match(x),names)))
</pre></div><p>The functions<code class="literal"> getauthors()</code> and<code class="literal"> gettitles()</code> in<code class="literal"> booksdb.py</code> could have simply retrieved a list of<code class="literal"> Author</code> or<code class="literal"> Book</code> objects respectively and extracted the<code class="literal"> name</code> or<code class="literal"> title</code> attributes. This would have been fairly slow, however, as creating potentially a lot of objects is costly in terms of processing power. Moreover, since we are really interested in just a list of strings and not in whole objects, it is worthwhile to implement a<code class="literal"> getcolumnvalues()</code> method in the<code class="literal"> Entity</code> class:</p><p>
<span class="strong"><strong>Chapter5/entity.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@classmethod
def getcolumnvalues(cls,column):
		if not column in cls.columns :
				raise KeyError('unknown column '+column)<span class="strong"><strong>
		sql="select %s from %s order by lower(%s)"%(column,
				cls.__name__,column)</strong></span>
		cursor=cls.threadlocal.connection.cursor()
		cursor.execute(sql)
		return [r[0] for r in cursor.fetchall()]
</pre></div><p>
<code class="literal">getcolumnvalues()</code> first checks if the requested column exists in this<code class="literal"> Entity</code> (sub)class and raises an exception if it doesn't. Then it constructs a SQL statement to return the values in the requested column, sorted without regard for case (highlighted). The result is a list of tuples consisting of a single item and this is converted to a simple list of items before returning it.<a id="id270" class="indexterm"/>
</p></div><div class="section" title="The presentation layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec17"/>The presentation layer</h2></div></div></div><p>Now that we have implemented the delivery layer, the application is almost usable, but looks a bit rough on the edges. Although some components already look quite good due to the styling inherent in the jQuery UI widgets used, other parts need some serious tweaking.<a id="id271" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action using an enhanced presentation layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec09"/>Time for action using an enhanced presentation layer</h1></div></div></div><p>The additional JavaScript code and CSS information is part of<code class="literal"> booksweb.js</code> and<code class="literal"> booksweb.css</code> respectively. The following illustrations show the end results for the page with the list of books and the page to add a new book:<a id="id272" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746_05_007.jpg" height="133" alt="Time for action using an enhanced presentation layer"/></div><p>We added some zebra stripes to aid readability and changed the look of the column headings.</p><div class="mediaobject"><img src="images/3746_05_008.jpg" height="108" alt="Time for action using an enhanced presentation layer"/></div><p>The page to add a book had its buttons styled in the same style as the buttons on the page with the list of books. Also, the layout was cleaned up and functionality was added to present any errors returned in a clearly visible way (in the last example, the title is empty so the background is red).<a id="id273" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746_05_009.jpg" height="106" alt="Time for action using an enhanced presentation layer"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec18"/>What just happened?</h2></div></div></div><p>To effect the changes seen in the previous images, we added the following lines of JavaScript to<code class="literal"> booksweb.js:</code>
</p><p>
<span class="strong"><strong>Chapter5/booksweb.js</strong></span>
</p><div class="informalexample"><pre class="programlisting">
$(".buttonbar").buttonset();
$("#newbook button[name=submit]").button({
				text: false,
				icons: {
						primary: "ui-icon-plusthick"
				}
});
$("#newbook button[name=cancel]").button({
				text: false,
				icons: {
						primary: "ui-icon-trash"
				}
});
</pre></div><p>The effect is just to alter the appearance of the buttons, not to add to their functionality with some sort of event handler because there is no need for this. The page contains a regular<code class="literal">&lt;form&gt;</code> element with a valid<code class="literal"> action</code> attribute, so our submit and cancel buttons will behave as expected.<a id="id274" class="indexterm"/>
</p><p>The rest of the changes, including borders, fonts, and colors are implemented in<code class="literal"> booksweb.css</code>, which we do not examine here as the CSS contained in it is very straightforward.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec10"/>Summary</h1></div></div></div><p>We have learned a lot in this chapter about designing and implementing a web application around a data model consisting of several entities and relations.</p><p>Specifically, we covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to design the data model</li><li class="listitem" style="list-style-type: disc">How to create a reusable entity and relation framework</li><li class="listitem" style="list-style-type: disc">How to maintain a clear separation between database, object layer, and delivery layer</li><li class="listitem" style="list-style-type: disc">How to implement auto completion using jQuery UI's autocomplete widget</li></ul></div><p>We also discussed the importance of input validation, both client-side and server-side.</p><p>We did not yet wield the full power of our entity and relation framework and input validation might be much more involved. To exercise our new skills and expand them, the next chapter will be about designing and building a wiki application.</p></div></div>
</body></html>