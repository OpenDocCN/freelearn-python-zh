- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: The Toolz Package
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 工具包
- en: The `toolz` package, offered by the pytoolz project on GitHub, contains a number
    of functional programming features. Specifically, these libraries offer iteration
    tools, higher-order function tools, and even some components to work with stateful
    dictionaries in an otherwise stateless function application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 上 pytoolz 项目提供的 `toolz` 包包含许多函数式编程特性。具体来说，这些库提供了迭代工具、高阶函数工具，甚至在无状态函数应用中与状态字典一起工作的组件。
- en: 'There is some overlap between the `toolz` package and components of the standard
    library. The `toolz` project decomposes into three significant parts: `itertoolz`,
    `functoolz`, and `dicttoolz`. The `itertoolz` and `functoolz` modules are designed
    to mirror the standard library modules `itertools` and `functools`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`toolz` 包与标准库的组件之间有一些重叠。`toolz` 项目分解为三个重要的部分：`itertoolz`、`functoolz` 和 `dicttoolz`。`itertoolz`
    和 `functoolz` 模块被设计成与标准库模块 `itertools` 和 `functools` 相对应。'
- en: 'We’ll look at the following list of topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中查看以下主题列表：
- en: We’ll start with star-mapping, where a `f(*args)` is used to provide multiple
    arguments to a mapping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从星映射开始，其中使用 `f(*args)` 为映射提供多个参数。
- en: We’ll also look at some additional `functools.reduce()` topics using the `operator`
    module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将使用 `operator` 模块查看一些额外的 `functools.reduce()` 主题。
- en: We’ll look at the `toolz` package, which provides capabilities similar to the
    built-in `itertools` and `functools` packages, but offers a higher level of functional
    purity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将查看 `toolz` 包，它提供了类似于内置的 `itertools` 和 `functools` 包的功能，但提供了更高层次的函数纯度。
- en: We’ll also look at the `operator` module and how it leads to some simplification
    and potential clarification when defining higher-order functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将查看 `operator` 模块以及它如何有助于在定义高阶函数时简化并可能澄清某些内容。
- en: We’ll start with some more advanced use of `itertools` and `functools.reduce()`.
    These two topics will introduce the use cases for the `toolz` package.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `itertools` 和 `functools.reduce()` 的更多高级用法开始。这两个主题将介绍 `toolz` 包的使用案例。
- en: 11.1 The itertools star map function
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1 itertools 星映射函数
- en: The `itertools.starmap()` function is a variation of the `map()` higher-order
    function. The `map()` function applies a function against each item from a sequence.
    The `starmap(f,`` S)` function presumes each item, `i`, from the sequence, `S`,
    is a tuple, and uses `f(*i)`. The number of items in each tuple must match the
    number of parameters in the given function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.starmap()` 函数是 `map()` 高阶函数的一种变体。`map()` 函数将函数应用于序列中的每个项目。`starmap(f,
    S)` 函数假设序列 `S` 中的每个项目 `i` 都是一个元组，并使用 `f(*i)`。每个元组中的项目数必须与给定函数中的参数数相匹配。'
- en: 'Here’s an example that uses a number of features of the `starmap()` function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `starmap()` 函数多个特性的示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `itertools.zip_longest()` function will create a sequence of pairs, `[(60,`
    `0)``,` `(60,` `1)``,` `(60,` `2)``,` `(60,` `3)``]`. It does this because we
    provided two sequences: the `[]` brackets and the `range(4)` parameter. The `fillvalue`
    parameter is used when the shorter sequence runs out of data.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.zip_longest()` 函数将创建一个包含对的序列，`[(60, 0), (60, 1), (60, 2), (60, 3)]`。它这样做是因为我们提供了两个序列：空方括号和
    `range(4)` 参数。当较短的序列数据耗尽时，使用 `fillvalue` 参数。'
- en: When we use the `starmap()` function, each pair becomes the argument to the
    given function. In this case, we used the the built-in `pow()` function, which
    is the `**` operator (we can also import this from the `operator()` module; the
    definition is in both places). This expression calculates values for `[60**0,`` 60**1,`` 60**2,`` 60**3]`.
    The value of the `d` variable is `[1,`` 60,`` 3600,`` 216000]`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `starmap()` 函数时，每一对都成为给定函数的参数。在这种情况下，我们使用了内置的 `pow()` 函数，它就是 `**` 操作符（我们也可以从
    `operator()` 模块中导入这个函数；定义在两个地方）。这个表达式计算 `[60**0, 60**1, 60**2, 60**3]` 的值。`d`
    变量的值是 `[1, 60, 3600, 216000]`。
- en: The `starmap()` function expects a sequence of tuples. We have a tidy equivalence
    between the `map(f,`` x,`` y)` and `starmap(f,`` zip(x,`` y))` functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`starmap()` 函数期望一个元组的序列。我们在 `map(f, x, y)` 和 `starmap(f, zip(x, y))` 函数之间有一个整洁的等价性。'
- en: 'Here’s a continuation of the preceding example of the `itertools.starmap()`
    function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `itertools.starmap()` 函数先前示例的延续：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ve zipped together two sequences of four values. The value of the `d` variable
    was computed above using `starmap()`. The `p` variable refers to a simple list
    of literal items. We zipped these to make pairs of items. We used the `starmap()`
    function with the `operator.truediv()` function, which is the `/` operator. This
    will compute a sequence of fractions that we sum. The sum is an approximation
    of π ≈![-3- 600](img/file105.jpg) + ![-8- 601](img/file106.jpg) + ![29- 602](img/file107.jpg)
    + ![-44- 603](img/file108.jpg).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个四个值的序列组合在一起。`d`变量的值是在上面使用`starmap()`计算的。`p`变量指的是一个简单的字面项列表。我们将这些项组合成对。我们使用`starmap()`函数与`operator.truediv()`函数（即`/`运算符）一起使用，这将计算一个分数序列，我们将对其进行求和。这个和是π
    ≈![-3- 600](img/file105.jpg) + ![-8- 601](img/file106.jpg) + ![29- 602](img/file107.jpg)
    + ![-44- 603](img/file108.jpg)的近似值。
- en: 'Here’s a slightly simpler version that uses the `map(f,`` x,`` y)` function
    instead of the `starmap(f,`` zip(x,y))` function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个稍微简单一点的版本，它使用`map(f, x, y)`函数而不是`starmap(f, zip(x, y))`函数：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we effectively converted a base 60 fractional value to base
    10\. The sequence of values in the `d` variable are the appropriate denominators.
    A technique similar to the one explained earlier in this section can be used to
    convert other bases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有效地将60进制的分数值转换为10进制。`d`变量中的值序列是适当的分母。可以使用本节之前解释的类似技术将其他进制转换。
- en: Some approximations involve potentially infinite sums (or products). These can
    be evaluated using similar techniques explained previously in this section. We
    can leverage the `count()` function in the `itertools` module to generate an arbitrary
    number of terms in an approximation. We can then use the `takewhile()` function
    to only accumulate values that contribute a useful level of precision to the answer.
    Looked at another way, `takewhile()` yields a stream of significant values, and
    stops consuming values from the stream when an insignificant value is found.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些近似涉及可能无限的和（或积）。这些可以使用本节之前解释的类似技术进行评估。我们可以利用`itertools`模块中的`count()`函数在近似中生成任意数量的项。然后我们可以使用`takewhile()`函数只累积对答案有有用精度水平的值。从另一个角度来看，`takewhile()`产生一系列显著值，并在找到不显著值时停止从流中消耗值。
- en: For our next example, we’ll leverage the `fact()` function defined in [Chapter 6](Chapter_06.xhtml#x1-1260006),
    [Recursions and Reductions](Chapter_06.xhtml#x1-1260006). Look at the [Implementing
    manual tail-call optimization](Chapter_06.xhtml#x1-1280001) section for the relevant
    code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个例子中，我们将利用[第6章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)中定义的`fact()`函数。查看[实现尾部调用优化](Chapter_06.xhtml#x1-1280001)部分以获取相关代码。
- en: 'We’ll introduce a very similar function, the semifactorial, also called double
    factorial, denoted by the !! symbol. The definition of semifactorial is similar
    to the definition of factorial. The important difference is that it is the product
    of alternate numbers instead of all numbers. For example, take a look at the following
    formulas:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍一个非常类似的功能，半阶乘，也称为双阶乘，用!!符号表示。半阶乘的定义与阶乘的定义类似。重要的区别是它是交替数的乘积，而不是所有数的乘积。例如，看看以下公式：
- en: 5!! = 5 × 3 × 1
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5!! = 5 × 3 × 1
- en: 7!! = 7 × 5 × 3 × 1
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7!! = 7 × 5 × 3 × 1
- en: 'Here’s the essential function definition:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是基本函数定义：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s an example of computing a sum from a potentially infinite sequence of
    fractions using the `fact()` and `semifact()` functions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`fact()`和`semifact()`函数从一个潜在无限序列的分数中计算总和的例子：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `num` variable is a potentially infinite sequence of numerators, based on
    the `fact()` function. The `count()` function returns ascending values, starting
    from zero and continuing indefinitely. The `den` variable is also a potentially
    infinite sequence of denominators, based on the semifactorial function. This `den`
    computation also uses `count()` to create a potentially infinite series of values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`num`变量是基于`fact()`函数的潜在无限序列的分子，`count()`函数返回从零开始的递增值，并无限期地继续。`den`变量也是基于半阶乘函数的潜在无限序列的分母。这个`den`计算也使用`count()`来创建一个潜在无限值的序列。'
- en: To create terms, we used the `map()` function to apply the `operator.truediv()`
    function, the `/` operator, to each pair of values. We wrapped this in a `takewhile()`
    function so that we only take terms from the `map()` output while the value is
    greater than some relatively small value, in this case, 10^(−10).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建项，我们使用了 `map()` 函数来应用 `operator.truediv()` 函数，即 `/` 运算符，到每一对值。我们用 `takewhile()`
    函数包装这个操作，这样我们只从 `map()` 输出中取值，直到值大于某个相对较小的值，在这个例子中是 10^(-10)。
- en: 'This is a series expansion based on this definition:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于此定义的级数展开：
- en: '![ ∑ ---n!---- 4 arctan (1) = π = 2 (2n + 1)!! 0≤n <∞ ](img/file109.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ ---n!---- 4 arctan (1) = π = 2 (2n + 1)!! 0≤n <∞ ](img/file109.jpg)'
- en: An interesting variation of the series expansion theme is to replace the `operator.truediv()`
    function with the `fractions.Fraction()` function. This will create exact rational
    values that don’t suffer from the limitations of floating-point approximations.
    We’ve left the implementation as an exercise for the reader.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 级数展开主题的一个有趣的变化是将 `operator.truediv()` 函数替换为 `fractions.Fraction()` 函数。这将创建精确的有理数，不受浮点近似限制。我们将实现留给读者作为练习。
- en: All the built-in Python operators are available in the `operator` module. This
    includes all of the bit-fiddling operators as well as the comparison operators.
    In some cases, a generator expression may be more succinct or expressive than
    a rather complicated-looking `starmap()` function with a function that represents
    an operator.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内置的 Python 运算符都在 `operator` 模块中可用。这包括所有位操作符以及比较运算符。在某些情况下，生成器表达式可能比看起来相当复杂的
    `starmap()` 函数和表示运算符的函数更简洁或更易于表达。
- en: The `operator` module offers functions that can be more terse than a lambda.
    We can use the `operator.add` method instead of the `add=lambda`` a,`` b:`` a+b`
    form. If we have expressions more complex than a single operator, then the lambda
    object is the only way to write them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator` 模块提供了比 lambda 更简洁的函数。我们可以使用 `operator.add` 方法而不是 `add=lambda a,
    b: a+b` 形式。如果我们有比单个运算符更复杂的表达式，那么 lambda 对象是唯一可以编写它们的途径。'
- en: 11.2 Reducing with operator module functions
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2 使用运算符模块函数进行归约
- en: 'We’ll look at one more way that we can use the `operator` module definitions:
    we can use them with the built-in `functools.reduce()` function. The `sum()` function,
    for example, can be implemented as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨另一种使用 `operator` 模块定义的方法：我们可以使用它们与内置的 `functools.reduce()` 函数一起。例如，`sum()`
    函数可以如下实现：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This creates a partially evaluated version of the `reduce()` function with the
    first argument supplied. In this case, it’s the `+` operator, implemented via
    the `operator.add()` function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个部分评估的 `reduce()` 函数版本，其中第一个参数已提供。在这种情况下，它是 `+` 运算符，通过 `operator.add()`
    函数实现。
- en: 'If we have a requirement for a similar function that computes a product, we
    can define it like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个类似的函数来计算乘积，我们可以这样定义它：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This follows the pattern shown in the previous example. We have a partially
    evaluated `reduce()` function with the first argument of the `*` operator, as
    implemented by the `operator.mul()` function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了前面示例中显示的模式。我们有一个部分评估的 `reduce()` 函数，其第一个参数是 `*` 运算符，由 `operator.mul()` 函数实现。
- en: It’s not clear whether we can do similar things with too many of the other operators.
    We might be able to find a use for the `operator.concat()` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以用太多其他运算符做类似的事情还不清楚。我们可能能够找到 `operator.concat()` 函数的用途。
- en: The `and()` and `or()` functions are the bit-wise `&` and `|` operators. These
    are designed to create integer results.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`and()` 和 `or()` 函数是位运算符 `&` 和 `|`。这些函数旨在生成整数结果。'
- en: If we want to perform a reduce using the proper Boolean operations, we should
    use the `all()` and `any()` functions instead of trying to create something with
    the `reduce()` function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用正确的布尔运算进行归约，我们应该使用 `all()` 和 `any()` 函数，而不是尝试使用 `reduce()` 函数来创建某些内容。
- en: 'Once we have a `prod()` function, this means that the factorial can be defined
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `prod()` 函数，这意味着阶乘可以如下定义：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This has the advantage of being succinct: it provides a single-line definition
    of factorial. It also has the advantage of not relying on recursion and avoids
    any problem with stack limitations.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有简洁的优点：它提供了一个单行定义的阶乘。它还有不依赖于递归的优点，避免了任何与栈限制相关的问题。
- en: It’s not clear that this has any dramatic advantages over the many alternatives
    we have in Python. However, the concept of building a complex function from primitive
    pieces such as the `partial()` and `reduce()` functions and the `operator` module
    is very elegant. This is an important design strategy for writing functional programs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不明显比我们拥有的许多 Python 替代方案有戏剧性的优势。然而，从 `partial()` 和 `reduce()` 函数以及 `operator`
    模块等原始组件构建复杂函数的概念非常优雅。这是编写函数式程序的重要设计策略。
- en: Some of the designs can be simplified by using features of the `toolz` package.
    We’ll look at some of the `toolz` package in the next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设计可以通过使用 `toolz` 包的功能来简化。我们将在下一节中查看一些 `toolz` 包的内容。
- en: 11.3 Using the toolz package
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3 使用 toolz 包
- en: The `toolz` package comprises functions that are similar to some of the functions
    in the built-in `itertools` and `functools` modules. The `toolz` package adds
    some functions to perform sophisticated processing on dictionary objects. This
    package has a narrow focus on iterables, dictionaries, and functions. This overlaps
    nicely with the data structures available in JSON and CSV documents. The idea
    of processing iterables that come from files or databases allows a Python program
    to deal with vast amounts of data without the complication of filling memory with
    the entire collection of objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`toolz` 包包含与内置的 `itertools` 和 `functools` 模块中的一些函数类似的功能。`toolz` 包添加了一些函数来对字典对象进行复杂的处理。这个包专注于可迭代对象、字典和函数。这与
    JSON 和 CSV 文档中可用的数据结构很好地重叠。处理来自文件或数据库的可迭代对象的想法允许 Python 程序在不填充整个对象集合的情况下处理大量数据。'
- en: We’ll look at a few example functions from the various subsections of the `toolz`
    package. There are over sixty individual functions in the current release. Additionally,
    there is a `cytoolz` implementation written in Cython that provides higher performance
    than the pure Python `toolz` package.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看 `toolz` 包各个子节中的几个示例函数。当前版本中包含六十多个单独的函数。此外，还有一个用 Cython 编写的 `cytoolz` 实现，它比纯
    Python 的 `toolz` 包提供了更高的性能。
- en: 11.3.1 Some itertoolz functions
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1 一些 itertoolz 函数
- en: We’ll look at a common data analysis problem of cleaning and organizing data
    from a number of datasets. In [Chapter 9](Chapter_09.xhtml#x1-1990009), [Itertools
    for Combinatorics – Permutations and Combinations](Chapter_09.xhtml#x1-1990009),
    we mentioned several datasets available at [https://www.tylervigen.com](https://www.tylervigen.com).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一个常见的数据分析问题，即从多个数据集中清理和组织数据。在[第9章](Chapter_09.xhtml#x1-1990009)中，[组合学中的迭代工具
    – 排列和组合](Chapter_09.xhtml#x1-1990009)，我们提到了一些可在[https://www.tylervigen.com](https://www.tylervigen.com)找到的数据集。
- en: 'Each correlation includes a table of the relevant data. The tables often look
    like the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个相关性都包含一个相关数据的表格。这些表格通常看起来像以下示例：
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | 2000 | 2001 | 2002 | ... |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  | 2000 | 2001 | 2002 | ... |'
- en: '|'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Per capita consumption of cheese (US) | 29.8 | 30.1 | 30.5 | ... |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 每人奶酪消费量（美国） | 29.8 | 30.1 | 30.5 | ... |'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Number of people who died by becoming |  |  |  |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 死于床上缠绵的人数 |  |  |  |  |'
- en: '| tangled in their bedsheets | 327 | 456 | 509 | ... |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 在床上缠绵而死亡的人数 | 327 | 456 | 509 | ... |'
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |  |  |  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |'
- en: There are generally three rows of data in each example of a spurious correlation.
    Each row has 10 columns of data, a title, and an empty column that acts as a handy
    delimiter. A small parsing function, using Beautiful Soup, can extract the essential
    data from the HTML. This extract isn’t immediately useful; more transformations
    are required.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚假相关性的每个例子中，通常有三行数据。每行有10列数据，一个标题，以及一个用作方便分隔符的空列。一个小的解析函数，使用 Beautiful Soup，可以从中提取必要的数据。这个提取出来的数据并不立即有用；还需要更多的转换。
- en: 'Here’s the core function for extracting the relevant text from HTML:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提取 HTML 中相关文本的核心函数：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This `html_data_iter()` function uses `urllib` to read the HTML pages. It creates
    a `BeautifulSoup` instance from the raw data. The `soup.html.body.table.table`
    expression provides a navigation path into the HTML structure. This digs down
    into nested `<table>` tags to locate the data of interest. Within the nested table,
    there will be other sub-tables that contain rows and columns. Because the various
    structures can be somewhat inconsistent, it seems best to extract the text and
    impose a meaningful structure on the text separately.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`html_data_iter()`函数使用`urllib`读取HTML页面。它从原始数据创建一个`BeautifulSoup`实例。`soup.html.body.table.table`表达式提供了进入HTML结构的导航路径。这深入到嵌套的`<table>`标签中，以定位感兴趣的数据。在嵌套的表格中，将会有其他子表格，包含行和列。由于各种结构可能有些不一致，因此似乎最好分别提取文本并对文本施加有意义的结构。
- en: 'This `html_data_iter()` function is used like this to acquire data from an
    HTML page:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`html_data_iter()`函数是这样用来从HTML页面获取数据的：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result of this expression is a sequence of strings of text. Many examples
    have 37 individual strings. These strings can can be divided into 3 rows of 12
    strings and a fourth row with a single string value. We can understand these rows
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的结果是文本字符串序列。许多例子有37个单独的字符串。这些字符串可以被分成3行，每行12个字符串，以及一个包含单个字符串值的第四行。我们可以这样理解这些行：
- en: The first row has an empty string, ten values of years, plus one more zero-length
    string.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行有一个空字符串，十个年份值，以及一个额外的零长度字符串。
- en: The second row has the first data series title, ten values, and an extra zero-length
    string.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行有第一个数据序列的标题，十个值，以及一个额外的零长度字符串。
- en: The third row, like the second, has the second data series title, ten values,
    and an extra string.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行，就像第二行一样，有第二个数据序列的标题，十个值，以及一个额外的字符串。
- en: A fourth row has a single string with the correlation value between the two
    series.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四行包含一个字符串，其中包含两个序列之间的相关性值。
- en: This requires some reorganization to create a set of sample values we can work
    with.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些重新组织，以创建我们可以工作的样本值集。
- en: 'We can use `toolz.itertoolz.partition` to divide the sequence of values into
    groups of 12\. If we interleave the three collections using `toolz.itertoolz.interleave`,
    it will create a sequence with a value from each of the three rows: year, series
    one, and series two. If this is partitioned into groups of three, each year and
    the two sample values will be a small three-tuple. We’ll quietly drop the additional
    row with the correlation value.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`toolz.itertoolz.partition`将值序列分成每组12个的组。如果我们使用`toolz.itertoolz.interleave`交错这三个集合，它将创建一个包含每个三行值的序列：年份、第一序列和第二序列。如果将其分成每组三的组，每个年份和两个样本值将是一个小的三元素元组。我们将默默地丢弃包含相关性值的额外行。
- en: 'This isn’t the ideal form of the data, but it gets us started on creating useful
    objects. In the long run, the `toolz` framework encourages us to create dictionaries
    to contain the sample data. We’ll get to the dictionaries later. For now, we’ll
    start with rearranging the source data of the first 36 strings into 3 groups of
    12 strings, and then 12 groups of 3 strings. This initial restructuring looks
    like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是数据的理想形式，但它使我们开始创建有用的对象。从长远来看，`toolz`框架鼓励我们创建字典来包含样本数据。我们将在稍后讨论字典。现在，我们将从重新排列前36个字符串的源数据开始，将其分为3组，每组12个字符串，然后是12组，每组3个字符串。这种初始重构看起来是这样的：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first row, awkwardly, doesn’t have a title for the year column. Because
    this is the very first item in the sequence, we can use a pair of `itertoolz`
    functions to drop the initial string, which is always `""`, and replace it with
    something more useful, `"year"`. The resulting sequence will then have empty cells
    only at the end of each row, allowing us to use `partitionby()` to decompose the
    long series of strings into four separate rows. The following function definition
    can be used to break the source data on empty strings into parallel sequences:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行尴尬的是，年份列没有标题。因为这是序列中的第一个项目，我们可以使用一对`itertoolz`函数来删除初始字符串，该字符串始终为`""`，并将其替换为更有用的内容，即`"year"`。结果序列将只在每行的末尾有空白单元格，这样我们就可以使用`partitionby()`将长字符串序列分解为四个单独的行。以下函数定义可以用来将源数据在空字符串上分割成并行序列：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `row_counter()` function uses a global variable, `ROW_COUNT`, to maintain
    a stateful count of end-of-row strings. A slightly better design would use a callable
    object to encapsulate the state information into a class definition. We’ve left
    this variant as an exercise for the reader. Using an instance variable in a class
    with a `__call__()` method has numerous advantages over a global; redesigning
    this function is helpful because it shows how to limit side effects to the state
    of objects. We can also use class-level variables and a `@classmethod` to achieve
    the same kind of isolation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`row_counter()` 函数使用全局变量 `ROW_COUNT` 来维护行尾字符串的状态计数。一个稍微更好的设计会使用可调用对象将状态信息封装到类定义中。我们将这个变体留给了读者作为练习。在具有
    `__call__()` 方法的类中使用实例变量比全局变量有诸多优势；重新设计这个函数是有帮助的，因为它展示了如何将副作用限制到对象的状态。我们还可以使用类级别变量和
    `@classmethod` 来实现相同类型的隔离。'
- en: 'The following snippet shows how this function is used to partition the input:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用此函数对输入进行分区：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `row_counter()` function is called with each individual string, of which
    only a few are end-of-row. This allows each row to be partitioned into a separate
    sequence by the `partitionby()` function. The resulting three sequences are then
    combined via `zip()` to create a sequence of three-tuples.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`row_counter()` 函数对每个单独的字符串进行调用，其中只有少数是行尾。这使得每个行可以通过 `partitionby()` 函数分割成单独的序列。然后通过
    `zip()` 将这三个序列组合起来，创建一个三个元组的序列。'
- en: This result is identical to the previous example. This variant, however, doesn’t
    depend on there being precisely three rows of 12 values. This variation depends
    on being able to detect a cell that’s at the end of each row. This offers flexibility.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此结果与前面的示例相同。然而，这个变体不依赖于恰好有三行12个值。这种变化依赖于能够检测到每行的末尾单元格。这提供了灵活性。
- en: 'A more useful form for the result is a dictionary for each sample with keys
    for `year`, `series_1`, and `series_2`. We can transform the sequence of three-tuples
    into a sequence of dictionaries with a generator expression. The following example
    builds a sequence of dictionaries:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的更有用形式是每个样本的字典，其中包含 `year`、`series_1` 和 `series_2` 的键。我们可以使用生成器表达式将三个元组的序列转换为字典序列。以下示例构建了一个字典序列：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `make_samples()` function creates a sequence of dictionaries. This, in
    turn, lets us then use other tools to extract sequences that can be used to compute
    the coefficient of correlation among the two series. The essential patterns for
    some of the `itertoolz` functions are similar to the built-in `itertools`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_samples()` 函数创建了一个字典序列。这反过来又允许我们使用其他工具提取可以用来计算两个系列之间相关系数的序列。一些 `itertoolz`
    函数的基本模式与内置的 `itertools` 相似。'
- en: In some cases, function names conflict with each other, and the semantics are
    different. For example, `itertoolz.count()` and `itertools.count()` have radically
    different definitions. The `itertoolz` function is similar to `len()`, while the
    standard library `itertools` function is a variation of `enumerate()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，函数名称之间会发生冲突，其语义也各不相同。例如，`itertoolz.count()` 和 `itertools.count()` 具有根本不同的定义。`itertoolz`
    函数类似于 `len()`，而标准库中的 `itertools` 函数是 `enumerate()` 的变体。
- en: It can help to have the reference documentation for both libraries open when
    designing an application. This can help you to pick and choose the most useful
    option between the `itertoolz` package and the standard library `itertools` package.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，同时打开这两个库的参考文档可能会有所帮助。这可以帮助您在 `itertoolz` 包和标准库 `itertools` 包之间选择最有用的选项。
- en: Note that completely free mixing and matching between these two packages isn’t
    easy. The general approach is to choose the one that offers the right mix of features
    and use it consistently.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这两个包之间完全自由混合并不容易。一般的方法是选择提供正确功能组合的一个，并始终如一地使用它。
- en: 11.3.2 Some dicttoolz functions
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2 一些 dicttoolz 函数
- en: One of the ideas behind the `dicttoolz` module of `toolz` is to make dictionary
    state changes into functions that have side effects. This allows a higher-order
    function like `map()` to apply a number of updates to a dictionary as part of
    a larger expression. It makes it slightly easier to manage caches of values, for
    example, or to accumulate summaries.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`toolz` 模块中的 `dicttoolz` 模块背后的一个想法是将字典状态更改转换为具有副作用的函数。这使得像 `map()` 这样的高阶函数可以将多个更新应用到字典中，作为更大表达式的一部分。这使得管理值缓存或累积摘要等操作稍微容易一些。'
- en: For example, the `get_in()` function uses a sequence of key values to navigate
    down into deeply nested dictionary objects. When working with complex JSON documents,
    using `get_in(["k1",`` "k2"])` can be easier than writing a `["k1"]["k2"]` expression.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`get_in()` 函数使用一系列键值来导航到深层嵌套的字典对象中。当处理复杂的JSON文档时，使用 `get_in(["k1",`` "k2"])`
    可能比编写 `["k1"]["k2"]` 表达式更容易。
- en: 'In the previous examples, we created a sequence of sample dictionaries, named
    `samples`. We can extract the various series values from each dictionary and use
    this to compute a correlation coefficient, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们创建了一个名为 `samples` 的样本字典序列。我们可以从每个字典中提取各种系列值，并使用这些值来计算相关系数，如下所示：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, our relatively flat document means we could use `s[’series_1’]`
    instead of `get_in([’series_1’],`` s)`. There’s no dramatic advantage to the `get_in()`
    function. Using `get_in()` does, however, permit future flexibility in situations
    where the sample’s structure needs to become more deeply nested to reflect a shift
    in the problem domain.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的相对扁平的文档意味着我们可以使用 `s[’series_1’]` 而不是 `get_in([’series_1’],`` s)`。`get_in()`
    函数并没有带来显著的优势。然而，使用 `get_in()` 允许在样本结构需要更深层次嵌套以反映问题领域变化的情况下，提供未来的灵活性。
- en: The data, `s7`, is described in [Some itertoolz functions](#x1-2390001). It
    comes from the Spurious Correlations website.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 数据 `s7` 在 [Some itertoolz functions](#x1-2390001) 中描述。它来自 Spurious Correlations
    网站。
- en: We can set a path `field`` =`` ["domain",`` "example",`` "series_1"]` and then
    use this path in a `get_in(path,`` document)` expression. This isolates the path
    through the data structure and makes changes easier to manage. This path to the
    relevant data can even become a configuration parameter if data structures change
    frequently.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置一个路径 `field`` =`` ["domain",`` "example",`` "series_1"]`，然后在 `get_in(path,`` document)`
    表达式中使用这个路径。这通过数据结构隔离路径，使得更改更容易管理。这个到相关数据的路径甚至可以成为配置参数，如果数据结构经常变化的话。
- en: 11.3.3 Some functoolz functions
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3 一些 functoolz 函数
- en: The `functoolz` module of `toolz` has a number of functions that can help with
    functional design. One idea behind these functions is to provide some names that
    match the Clojure language, permitting easier transitioning between the two languages.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`toolz` 的 `functoolz` 模块包含许多有助于函数式设计的函数。这些函数背后的一个想法是提供一些与 Clojure 语言匹配的名称，以便更容易地在两种语言之间进行转换。'
- en: For example, the `@functoolz.memoize` decorator is essentially the same as the
    standard library `functools.cache`. The word ”memoize” matches the Clojure language,
    which some programmers find helpful.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`@functoolz.memoize` 装饰器本质上与标准库 `functools.cache` 相同。单词 “memoize” 与 Clojure
    语言相匹配，一些程序员认为这很有帮助。
- en: One significant feature of the `@functoolz` module is the ability to compose
    multiple functions. This is perhaps the most flexible way to approach functional
    composition in Python.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`@functoolz` 模块的一个显著特性是能够组合多个函数。这可能是在 Python 中处理函数式组合的最灵活方法。'
- en: Consider the earlier example of using the expression `partition``(3,` `interleave``(``partition``(12,`
    `s7``)``)``)` to restructure source data from a sequence of 37 values to 12 three-tuples.
    The final string is quietly dropped.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到之前使用表达式 `partition``(3,` `interleave``(``partition``(12,` `s7``)``)``)` 来重构源数据，将37个值的序列重新组织成12个三元组。最后的字符串被静默地丢弃。
- en: 'This is in effect a composition of three functions. We can look at it as the
    following abstract formula:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是由三个函数组成的组合。我们可以将其视为以下抽象公式：
- en: '![( ) p(3)∘i ∘p(12) (s7) ](img/file110.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![( ) p(3)∘i ∘p(12) (s7) ](img/file110.jpg)'
- en: In the above, p(3) is `partition(3,`` x)`, i is `interleave(y)`, and p(12) is
    `partition(12,`` z)`. This sequence of functions is applied to the source data
    sequence, s[7].
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，p(3) 是 `partition(3,`` x)`, i 是 `interleave(y)`, 而 p(12) 是 `partition(12,`` z)`.
    这个函数序列被应用到源数据序列 s[7] 上。
- en: 'We can more directly implement the abstraction using `functoolz.compose()`.
    Before we can look at the `functoolz.compose()` solution, we need to look at the
    `curry()` function. In [Chapter 10](Chapter_10.xhtml#x1-21700010), [The Functools
    Module](Chapter_10.xhtml#x1-21700010), we looked at the `functools.partial()`
    function. This is similar to the concept behind the `functoolz.curry()` function,
    with a small difference. When a curried function is evaluated with incomplete
    arguments, it returns a new curried function with more argument values supplied.
    When a curried function is evaluated with all of the arguments required, it computes
    a result:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`functoolz.compose()`更直接地实现抽象。在我们能够查看`functoolz.compose()`解决方案之前，我们需要查看`curry()`函数。在第10章[The
    Functools Module](Chapter_10.xhtml#x1-21700010)中，我们看到了`functools.partial()`函数。这与`functoolz.curry()`函数背后的概念类似，但有一个小的区别。当一个柯里化函数用不完整的参数评估时，它返回一个新的柯里化函数，并提供了更多的参数值。当一个柯里化函数用所有必要的参数评估时，它计算一个结果：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The initial evaluation of `curry(some_model)` created a curried function, which
    we assigned to the `curried_model` variable. This function needs three argument
    values. When we evaluated `curried_model(1.0134)`, we provided one of the three.
    The result of this evaluation is a new curried function with a value for the `a`
    parameter. The evaluation of `cm_a(0.7724)` provided the second of the three parameter
    values; this resulted in a new function with values for both the `a` and `b` parameters.
    We’ve provided the parameters incrementally to show how a curried function can
    either act as a higher-order function and return another curried function, or—if
    all the parameters have values—compute the expected result.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 初始评估`curry(some_model)`创建了一个柯里化函数，我们将它赋值给`curried_model`变量。这个函数需要三个参数值。当我们评估`curried_model(1.0134)`时，我们提供了其中的一个。这次评估的结果是一个新的柯里化函数，其中`a`参数有了一个值。评估`cm_a(0.7724)`提供了第三个参数值；这导致了一个新的函数，其中`a`和`b`参数都有值。我们逐步提供参数以展示柯里化函数可以作为一个高阶函数并返回另一个柯里化函数，或者如果所有参数都有值，则计算预期的结果。
- en: We’ll revisit currying again in [Chapter 13](Chapter_13.xhtml#x1-26600013),
    [The PyMonad Library](Chapter_13.xhtml#x1-26600013). This will provide another
    perspective on this idea of using a function and argument values to create a new
    function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第13章](Chapter_13.xhtml#x1-26600013)，[PyMonad库](Chapter_13.xhtml#x1-26600013)中再次回顾柯里化。这将提供对这个想法的另一个视角，即使用函数和参数值来创建一个新的函数。
- en: It’s common to see expressions like `model`` =`` curry(some_model,`` 1.0134,`` 0.7724)`
    to bind two parameters. Then the expression `model(1500)` will provide a result
    because all three parameters have values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 常常可以看到像`model = curry(some_model, 1.0134, 0.7724)`这样的表达式来绑定两个参数。然后表达式`model(1500)`将提供一个结果，因为所有三个参数都有值。
- en: 'The following example shows how to compose a larger function from three separate
    functions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何从三个单独的函数组合出一个更大的函数：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Because the `partition()` function requires two parameters, we used the `curry()`
    function to bind one parameter value. The `interleave()` function, on the other
    hand, doesn’t require multiple parameters, and there’s no real need to curry this.
    While there’s no harm done by currying this function, there’s no compelling reason
    to curry it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`partition()`函数需要两个参数，我们使用了`curry()`函数来绑定一个参数值。另一方面，`interleave()`函数不需要多个参数，实际上也没有必要柯里化这个函数。虽然柯里化这个函数没有造成伤害，但也没有充分的理由去柯里化它。
- en: The overall `functoolz.compose()` function combines the three individual steps
    into a single function, which we’ve assigned to the variable `xform`. The `s7`
    sequence of strings is provided to the composite function. This applies the functions
    in right-to-left order, following conventional mathematical rules. The expression
    (f ∘ g ∘ h)(x) means f(g(h(x))); the right-most function in the composition is
    applied first.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 整体`functoolz.compose()`函数将三个单独的步骤组合成一个单一函数，我们将它赋值给变量`xform`。字符串序列`s7`被提供给组合函数。这按照从右到左的顺序应用函数，遵循传统的数学规则。表达式(f
    ∘ g ∘ h)(x)意味着f(g(h(x)))；组合中的最右边的函数首先应用。
- en: There is a `functoolz.compose_left()` function that doesn’t follow the mathematical
    convention. Additionally, there’s a `functoolz.pipe()` function that many people
    find easier to visualize.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`functoolz.compose_left()`函数，它不遵循数学惯例。此外，还有一个`functoolz.pipe()`函数，许多人发现它更容易可视化。
- en: 'Here’s an example of using the `functoolz.pipe()` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`functoolz.pipe()`函数的一个例子：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This shows the processing steps in the pipeline in left-to-right order. First,
    `partition(12,`` s7)` is evaluated. The results of this are presented to `interleave()`.
    The interleaved results are presented to `curry(partition(3))`. This pipeline
    concept can be a very flexible way to transform very large volumes of data using
    the `toolz.itertoolz` library.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了管道中的处理步骤按从左到右的顺序。首先，`partition(12, "s7")`被评估。这些结果被呈现给`interleave()`。交错的结果被呈现给`curry(partition(3))`。这种管道概念可以是一个非常灵活的方式来使用`toolz.itertoolz`库转换大量数据。
- en: In this section, we’ve seen a number of the functions in the `toolz` package.
    These functions provide extensive and sophisticated functional programming support.
    They complement functions that are part of the standard `itertools` and `functools`
    libraries. It’s common to use functions from both libraries to build applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了`toolz`包中的许多函数。这些函数提供了广泛的复杂函数式编程支持。它们补充了标准`itertools`和`functools`库中的函数。通常，我们会使用这两个库中的函数来构建应用程序。
- en: 11.4 Summary
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4 概述
- en: We started with a quick look at some `itertools` and `functools` component features
    that overlap with components of the `toolz` package. A great many design decisions
    involve making choices. It’s important to know what’s built in via Python’s Standard
    Library. This makes it easier to see what the benefits of reaching out to another
    package might be.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速浏览了一些与`toolz`包重叠的`itertools`和`functools`组件功能。许多设计决策涉及选择。了解通过Python标准库内置的内容很重要。这有助于看到扩展到另一个包可能带来的好处。
- en: The central topic of this chapter was a look at the `toolz` package. This complements
    the built-in `itertools` and `functools` modules. The `toolz` package extends
    the essential concepts using terminology that’s somewhat more accessible to folks
    with experience in other languages. It also provides a helpful focus on the data
    structures used by JSON and CSV.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的核心主题是查看`toolz`包。它补充了内置的`itertools`和`functools`模块。`toolz`包使用对其他语言有经验的术语扩展了基本概念，同时也提供了对JSON和CSV使用的数据结构的关注。
- en: In the following chapters, we’ll look at how we can build higher-order functions
    using decorators. These higher-order functions can lead to slightly simpler and
    clearer syntax. We can use decorators to define an isolated aspect that we need
    to incorporate into a number of other functions or classes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何使用装饰器构建高阶函数。这些高阶函数可以导致略微简单和清晰的语法。我们可以使用装饰器来定义一个需要将其纳入多个其他函数或类中的独立方面。
- en: 11.5 Exercises
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于GitHub上Packt Publishing提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到GitHub上提供的代码包含了一些练习的部分解决方案。这些作为提示，允许读者探索其他解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。这些通常与GitHub仓库中已经提供的单元测试用例相同。读者应将书籍中的示例函数名称替换为自己的解决方案以确认其是否有效。
- en: 11.5.1 Replace true division with a fraction
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.1 用分数替换真除法
- en: In the [The itertools star map function](#x1-2360001) section, we computed a
    sum of fractions computed using the `/` true division operator, available from
    the `operator` module as the `operator.truediv()` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在[The itertools star map function](#x1-2360001)部分，我们计算了使用`/`真除法运算符计算出的分数之和，该运算符作为`operator`模块中的`operator.truediv()`函数提供。
- en: An interesting variation of the series expansion theme is to replace the `operator.truediv()`
    function—which creates `float` objects—with the `fractions.Fraction()` function,
    which will create `Fraction` objects. Doing this will create exact rational values
    that don’t suffer from the limitations of floating-point approximations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 系列展开主题的一个有趣变化是，用`operator.truediv()`函数——它创建`float`对象——替换`fractions.Fraction()`函数，后者将创建`Fraction`对象。这样做将创建精确的有理数，不会受到浮点近似限制的困扰。
- en: Change this operator and be sure the summation still approximates π.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 更改此运算符并确保求和仍然近似π。
- en: 11.5.2 Color file parsing
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.2 颜色文件解析
- en: In [Chapter 3](Chapter_03.xhtml#x1-510003), [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003),
    the `Crayola.GPL` file was presented without showing the details of the parser.
    In [Chapter 8](Chapter_08.xhtml#x1-1700008), [The Itertools Module](Chapter_08.xhtml#x1-1700008),
    a parser was presented that applied a sequence of transformations to the source
    file. This can be rewritten to use `toolz.functoolz.pipe()`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](Chapter_03.xhtml#x1-510003)，[函数、迭代器和生成器](Chapter_03.xhtml#x1-510003)中，`Crayola.GPL`文件被展示出来，但没有显示解析器的详细信息。在[第8章](Chapter_08.xhtml#x1-1700008)，[Itertools模块](Chapter_08.xhtml#x1-1700008)中，展示了一个将一系列转换应用于源文件的解析器。这可以被重写为使用`toolz.functoolz.pipe()`。
- en: First, write and test the new parser.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编写并测试新的解析器。
- en: Compare the two parses. In particular, look for possible extensions and changes
    to the parsing. What if a file had multiple named color sets? Would it be possible
    to skip over the irrelevant ones while looking for the relevant collection of
    colors to parse and extract?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两个解析。特别是，寻找可能的扩展和解析更改。如果一个文件有多个命名的颜色集怎么办？在寻找要解析和提取的相关颜色集合时，是否可以跳过无关的集合？
- en: 11.5.3 Anscombe’s quartet parsing
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.3 安斯康姆四重奏解析
- en: The Git repository for this book includes a file, `Anscombe.txt`, that contains
    four series of (x, y) pairs. Each series has the same well-known mean and standard
    deviation. Four distinct models are required to compute an expected y value for
    a given x value, since each series is surprisingly different.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的Git仓库包含一个文件，`Anscombe.txt`，其中包含四组(x, y)对。每个序列都有相同的知名平均值和标准差。由于每个序列都惊人地不同，需要四个不同的模型来计算给定x值的预期y值。
- en: 'The data is in a table that starts like the following example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在一个表格中，如下例所示：
- en: Anscombe’s quartet
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 安斯康姆四重奏
- en: I
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: I
- en: II
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: II
- en: III
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: III
- en: IV
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: IV
- en: x
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: y
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: x
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: y
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: x
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: y
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: x
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: y
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: '10.0'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '10.0'
- en: '8.04'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '8.04'
- en: '10.0'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '10.0'
- en: '9.14'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '9.14'
- en: '10.0'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '10.0'
- en: '7.46'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '7.46'
- en: '8.0'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '8.0'
- en: '6.58'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '6.58'
- en: '8.0'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '8.0'
- en: '6.95'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '6.95'
- en: '8.0'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '8.0'
- en: '8.14'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '8.14'
- en: '8.0'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '8.0'
- en: '6.77'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '6.77'
- en: '8.0'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '8.0'
- en: '5.76'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '5.76'
- en: etc.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: etc.
- en: The first row is a title. The second row has series names. The third row has
    the two column names for each series. The remaining rows all have x and y values
    for each series.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是标题。第二行有系列名称。第三行有每个系列的两个列名。剩余的行都有每个系列的x和y值。
- en: This needs to be decomposed into four separate sequences. Each sequence should
    have two-element dictionaries with keys of `"x"` and `"y"`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要分解为四个独立的序列。每个序列应包含具有`"x"`和`"y"`键的两个元素字典。
- en: The foundation of the parsing is the `csv` module. This will transform each
    row into a sequence of strings. Each sequence, however, has eight samples from
    four distinct series in it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 解析的基础是`csv`模块。这将把每一行转换为一个字符串序列。然而，每个序列中都有来自四个不同序列的八个样本。
- en: The remaining parsing to decompose the four series can be done either with `toolz.itertoolz`
    or `itertools`. Write this parser to decompose the Anscombe datasets from each
    other. Be sure to convert the values from strings to float values so descriptive
    statistics can be computed for each series.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将四个序列分解的剩余解析可以使用`toolz.itertoolz`或`itertools`来完成。编写这个解析器以分解来自Anscombe数据集的各个序列。确保将值从字符串转换为浮点值，以便为每个序列计算描述性统计。
- en: 11.5.4 Waypoint computations
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.4 航点计算
- en: The Git repository for this book includes a file, `Winter`` 2012-2013.kml`,
    that contains a series of waypoints for a long trip. In [Chapter 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004), the foundational `row_iter_kml()`
    function is described. This emits a series of `list[str]` objects for each waypoint
    along the journey.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的Git仓库包含一个文件，`Winter`` 2012-2013.kml`，其中包含一次长途旅行的多个航点。在[第4章](Chapter_04.xhtml#x1-740004)，[与集合一起工作](Chapter_04.xhtml#x1-740004)中，描述了基础的`row_iter_kml()`函数。这个函数为旅程中的每个航点发出一系列`list[str]`对象。
- en: To be useful, the waypoints must be processed in pairs. The `toolz.itertoolz.sliding`
    `_window()` function is one way to decompose a simple sequence into pairs. The
    `itertools` `.pairwise()` function is another candidate.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有用，途径点必须成对处理。`toolz.itertoolz.sliding` `_window()`函数是将简单序列分解成对的一种方法。`itertools`
    `.pairwise()`函数是另一个候选方案。
- en: In [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007),
    a `distance()` function is presented that computes a close-enough distance between
    two waypoints. Note that the function was designed to work with complex `NamedTuple`
    objects. Redesign and reimplement this distance function to work with points represented
    as dictionaries with keys of ”latitude” and ”longitude.”
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](Chapter_07.xhtml#x1-1530007)，[复杂无状态对象](Chapter_07.xhtml#x1-1530007)中，提供了一个`distance()`函数，该函数计算两个途径点之间足够接近的距离。请注意，该函数被设计为与复杂的`NamedTuple`对象一起工作。重新设计和重新实现这个距离函数，使其能够与表示为具有“latitude”和“longitude”键的字典的点一起工作。
- en: The foundation of the source data parsing is the `row_iter_kml()` function,
    which depends on the underlying `xml.etree` module. This transformed each waypoint
    into a sequence of strings.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 源数据解析的基础是`row_iter_kml()`函数，它依赖于底层的`xml.etree`模块。这个函数将每个途径点转换成一系列字符串。
- en: Redesign the source data parsing to use the `toolz` package. The general processing
    can use `tools.functoolz.pipe` to transform source strings into more useful resulting
    dictionaries. Be sure to convert latitude and longitude values to properly signed
    float values.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重新设计源数据解析以使用`toolz`包。一般处理可以使用`tools.functoolz.pipe`将源字符串转换成更有用的结果字典。确保将纬度和经度值转换为正确符号的浮点值。
- en: After the redesign, compare and contrast the two implementations. Which seems
    more clear and concise? Use the `timeit` module to compare the performance to
    see if either offers specific performance advantages.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新设计后，比较和对比两种实现。哪一个看起来更清晰、简洁？使用`timeit`模块来比较性能，看看是否提供了特定的性能优势。
- en: 11.5.5 Waypoint geofence
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.5 途径点地理围栏
- en: The [Waypoint computations](#x1-2470004) exercise consumed a file with a number
    of waypoints. The waypoints were connected to form a journey from start to finish.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[途径点计算](#x1-2470004)练习消耗了一个包含多个途径点的文件。这些途径点被连接起来，形成从起点到终点的旅程。'
- en: It’s also sensible to examine the waypoints as isolated location samples with
    a latitude and longitude. Given the points, a simple boundary can be computed
    from the greatest and least latitude as well as the greatest and least longitude.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 也有必要将途径点作为具有纬度和经度的独立位置样本来检查。给定这些点，可以从最大和最小的纬度以及最大和最小的经度计算出一个简单的边界。
- en: Superficially, this describes a rectangle. Pragmatically, the closer to the
    North Pole, the closer together the longitude positions become. The area is actually
    a kind of trapezoid, narrower closer to the pole.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，这描述了一个矩形。实际上，越接近北极，经度位置越接近。面积实际上是一种梯形，靠近极点时越窄。
- en: A parsing pipeline similar to the one described in the [Waypoint computations](#x1-2470004)
    exercise is required. The waypoints, however, do not have to be combined into
    pairs. Locate the extrema on each axis to define a box around the overall voyage.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个类似于[途径点计算](#x1-2470004)练习中描述的解析管道。然而，途径点不需要组合成对。在每个轴上定位极值，以定义整个航行的边界框。
- en: 'There are several ways to bracket the voyage, as described below:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所述，有几种方法可以括号化航行：
- en: Given the extreme edges of the voyage, it’s possible to define four points for
    the four corners of the bounding trapezoid. These four points can be used to locate
    a midpoint for the journey.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定航行的极边，可以定义四个点，分别对应于边界梯形的四个角。这四个点可以用来定位旅程的中点。
- en: Given two sequences of latitudes and longitudes, a mean latitude and a mean
    longitude can be computed.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定两个纬度和经度的序列，可以计算出一个平均纬度和一个平均经度。
- en: Given two sequences of latitudes and longitudes, a median latitude and a median
    longitude can be computed.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定两个纬度和经度的序列，可以计算出一个中纬度和一个中经度。
- en: Once the boundaries and center alternatives are known, the equirectangular distance
    computation (from [Chapter 7](Chapter_07.xhtml#x1-1530007), [Complex Stateless
    Objects](Chapter_07.xhtml#x1-1530007)) can be used to locate the point on the
    journey closest to the center.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道了边界和中心选项，就可以使用等距圆距离计算（来自[第7章](Chapter_07.xhtml#x1-1530007)，[复杂无状态对象](Chapter_07.xhtml#x1-1530007)）来定位旅程中离中心最近的点。
- en: 11.5.6 Callable object for the row_counter() function
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.6 row_counter()函数的可调用对象
- en: In the [Some itertoolz functions](#x1-2390001) section of this chapter, a `row_counter()`
    function was defined. It used a global variable to maintain a count of source
    data items that ended an input row.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 [Some itertoolz functions](#x1-2390001) 部分，定义了一个 `row_counter()` 函数。它使用全局变量来维护结束输入行的源数据项的数量。
- en: 'A better design is a callable object with an internal state. Consider the following
    class definition as a base class for your solution:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的设计是一个具有内部状态的调用对象。考虑以下类定义作为您解决方案的基类：
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The idea is to create a callable object, `row_test` `=` `CountEndingItems``(``lambda`
    `item``:` `item` `==` `"")`. This callable object can then be used with `toolz.itertoolz.partition_by()`
    as a way to partition the input based on a count of rows that match some given
    condition.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是创建一个调用对象，`row_test` `=` `CountEndingItems``(``lambda` `item``:` `item` `==`
    `"")`。这个调用对象可以与 `toolz.itertoolz.partition_by()` 一起使用，作为根据匹配某些给定条件行数的输入进行分区的一种方式。
- en: Finish this class definition. Use it with the `toolz.itertoolz.partition_by()`
    solution for partitioning input. Contrast the use of a global variable with a
    stateful, callable object.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个类定义。使用它与 `toolz.itertoolz.partition_by()` 解决方案进行分区。对比使用全局变量与使用具有状态的调用对象的使用方法。
