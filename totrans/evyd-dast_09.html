<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Trees: Non-Linear Structures" id="1FLS41-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Trees: Non-Linear Structures</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre16">Tree </strong></span>
<span class="strong"><strong class="calibre16">structures</strong></span> are essentially collections of nodes, typically including constraints that prevent more than one reference to each node, and stipulate that no references point to the root node. This structure simulates a hierarchical tree-like structure that can be either ordered or unordered based on the value contained in each node. Also, nodes can contain either value types or instances of objects, depending on the purpose of the tree.</p><p class="calibre7">Trees are incredibly useful data structures in programming, although their applications can be somewhat limited. Even when a structure is in use, you may not always recognize their presence since many other data structures are built on top of them. In this chapter we are going to examine the tree data structure in detail, and in later chapters we will examine other structures that typically use the tree structure as a foundation.</p><p class="calibre7">In this chapter we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Definition of the tree data structure</li><li class="listitem">Tree data structure versus the tree data type</li><li class="listitem">Terminology associated with trees</li><li class="listitem">Common operations</li><li class="listitem">Creating trees</li><li class="listitem">Recursion</li><li class="listitem">Traversal</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Trees: Non-Linear Structures" id="1FLS41-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Tree data structure versus tree data type"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec42" class="calibre1"/>Tree data structure versus tree data type</h1></div></div></div><p class="calibre7">In fact, there is both a tree data type as well as a tree data structure, and the two are quite different. So before we go any further, it is important to make a distinction between a tree data structure and a tree data type.</p><p class="calibre7">For starters, a data type is only an arrangement of data without any definition of how a collection of that data is to be implemented. On the other hand, a data structure is precisely concerned with detailing how to take a particular data type and create a usable, concrete implementation of that type.</p><p class="calibre7">In the case of trees, a tree data type must have a value and some concept of children where each of those children is also a tree. A tree data structure is a group of nodes that are linked according to the pattern of a tree data type.</p><p class="calibre7">The two diagrams following show the two types of tree:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Ordered Tree:</li></ul></div><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Tree data structure versus tree data type" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><div class="book"><ul class="itemizedlist"><li class="listitem">Unordered Tree:</li></ul></div><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Tree data structure versus tree data type" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><p class="calibre7">Therefore each node is a tree, with the potential for child nodes that are also trees. In this chapter, we will be focusing on the concrete implementation of a tree data structure.</p></div></div>
<div class="book" title="Tree terminology" id="1GKCM1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec43" class="calibre1"/>Tree terminology</h1></div></div></div><p class="calibre7">Many of the terms and definitions used in trees are unique to these data structures. Therefore, before we can examine tree data structures we need to take the time to learn the language.</p><p class="calibre7">Here are some of the most common and important terms:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">Node</strong></span>: Any object or value stored in the tree represents a node. In the preceding figure, the root and all of its children and descendants are independent nodes.</li><li class="listitem"><span class="strong"><strong class="calibre16">Root</strong></span>: The root is the base node of the tree. Ironically, this node is typically depicted at the top of a graphic representation of the tree. Note that a root node, even if it has zero descendants, represents an entire tree by itself.</li><li class="listitem"><span class="strong"><strong class="calibre16">Parent</strong></span>: A parent node is any node which contains <span class="strong"><em class="calibre20">1...n</em></span> child nodes. The parent is only the parent in respect to one of its children. Also note that any parent node can have <span class="strong"><em class="calibre20">0...n</em></span> children depending on the rules associated with the tree's structure.</li><li class="listitem"><span class="strong"><strong class="calibre16">Child</strong></span>: Any node other than the root node is a child to one (and only one) other node. The root node of any tree that is not a sub-tree of another structure is the only node that is not itself a child.</li><li class="listitem"><span class="strong"><strong class="calibre16">Siblings</strong></span>: Siblings, also referred to as children, represent the collection of all of the child nodes to one particular parent. For example, referring to the preceding figure, the collection of two nodes below the root represents siblings.</li><li class="listitem"><span class="strong"><strong class="calibre16">Leaf</strong></span>: Any node that has no child nodes is called a leaf.</li><li class="listitem"><span class="strong"><strong class="calibre16">Edge</strong></span>: An edge is the route, or reference, between a parent and child node.</li><li class="listitem"><span class="strong"><strong class="calibre16">Descendant</strong></span>: The descendants of a node are any of the nodes that can be reached from that node following edges away from the root node.</li><li class="listitem"><span class="strong"><strong class="calibre16">Ancestor</strong></span>: The ancestors of a node are any of the nodes that can be reached from that node following edges toward the root node.</li><li class="listitem"><span class="strong"><strong class="calibre16">Path</strong></span>: A path is described as a list of edges between a node and one of its descendants.</li><li class="listitem"><span class="strong"><strong class="calibre16">Height of tree</strong></span>: The height of a tree represents the number of edges between the root node and the leaf that is furthest from the root node.</li><li class="listitem"><span class="strong"><strong class="calibre16">Depth</strong></span>: The number of edges between that node and the root node represents the depth of a node. The root node, therefore, has a depth equal to zero.</li></ul></div></div>
<div class="book" title="Common operations" id="1HIT81-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec44" class="calibre1"/>Common operations</h1></div></div></div><p class="calibre7">Tree data structures can consistent of <span class="strong"><em class="calibre20">1...n</em></span> nodes., which means that even a single node without a parent or any children is still considered a tree. Therefore, many of the common operations associated with trees can be defined in terms of a single node, or from the perspective of the same. Here is a list of the most common operations associated with trees</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">Data</strong></span>: The data operation is associated with a single node, and returns the object or value contained in that node.</li><li class="listitem"><span class="strong"><strong class="calibre16">Children</strong></span>: The children operation returns the collection of siblings associated with this parent node.</li><li class="listitem"><span class="strong"><strong class="calibre16">Parent</strong></span>: Some tree structures provide a mechanism to "climb" the tree, or traverse the structure from any particular node back toward the root.</li><li class="listitem"><span class="strong"><strong class="calibre16">Enumerate</strong></span>: An enumeration operation will return a list or some other collection containing every descendant of a particular node, including the root node itself.</li><li class="listitem"><span class="strong"><strong class="calibre16">Insert</strong></span>: An insert operation allows a new node to be added as a child of an existing node in the tree. The insert operation can be somewhat complicated when the tree structure has a limit to the number of children that can be associated with a particular parent. When the maximum number of children permitted is already in place, one of those children must be relocated as a child of the new node being inserted.</li><li class="listitem"><span class="strong"><strong class="calibre16">Graft</strong></span>: Graft is a similar operation to insert, except that the node being inserted has descendants of its own, meaning it is a multi-layer tree. As with the insert operation, graft can be somewhat complicated when the tree structure has a limit to the number of children that can be associated with a particular parent. When the maximum number of children permitted is already in place, one of those children must be logically relocated as a child of a leaf of the new tree being inserted.</li><li class="listitem"><span class="strong"><strong class="calibre16">Delete</strong></span>: The delete operation will remove a specified node from the tree. If the node being deleted has descendants, those nodes must be relocated to the deleted node's parent in some fashion, otherwise the operation is classified as a prune.</li><li class="listitem"><span class="strong"><strong class="calibre16">Prune</strong></span>: Prune operations will remove a node and all of its descendants from a tree.</li></ul></div></div>
<div class="book" title="Instantiating trees" id="1IHDQ1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec45" class="calibre1"/>Instantiating trees</h1></div></div></div><p class="calibre7">Considering how commonly the tree is seen in computer science, it is somewhat surprising that <span class="strong"><em class="calibre20">none</em></span> of the languages we are discussing provides a simple and versatile concrete implementation of the tree structure for general use. Therefore, we are going to create implementations of our own.</p></div>
<div class="book" title="Tree structures"><div class="book" id="1JFUC2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec46" class="calibre1"/>Tree structures</h1></div></div></div><p class="calibre7">Before we begin, we need to detail a few characteristics our tree structure will possess. For starters, we are going to create an ordered tree so we are not going to allow duplicate values to be added, which will simplify our implementation. Also, we are going to restrict each node to two child nodes. Technically this means we are defining a binary tree structure, but for now we are going to ignore the specific advantages and applications of such a structure and examine that definition in more detail later. Next, our structure is going to implement <span class="strong"><em class="calibre20">data</em></span> and <span class="strong"><em class="calibre20">children</em></span> operations by simply exposing the underlying objects contained in each node. We will not be implementing the parent operation because we have no need to traverse the tree backward at this time.</p><p class="calibre7">The <span class="strong"><em class="calibre20">insert</em></span> operation will be implemented as two separate methods supporting raw data and an existing node, while the <span class="strong"><em class="calibre20">graft</em></span> operation will only support existing nodes. Due to our decision not to permit duplicates, the <span class="strong"><em class="calibre20">graft</em></span> operation will act similarly to a union operation within a set data structure in that the resulting tree will only consist of unique values from the two input trees. Each of these three operations will return Boolean values indicating whether the operation succeeded.</p><p class="calibre7">The <span class="strong"><em class="calibre20">delete</em></span> operation will also provide two methods supporting raw data and existing nodes, while the <span class="strong"><em class="calibre20">prune</em></span> operation will only support existing nodes. Each of these three methods will remove the node from the tree and return that node to the caller. In this way, the <span class="strong"><em class="calibre20">delete</em></span> and <span class="strong"><em class="calibre20">prune</em></span> operations will act similarly to a <span class="strong"><em class="calibre20">pop</em></span> function in a queue or stack.</p><p class="calibre7">We will need to implement <span class="strong"><em class="calibre20">search</em></span> operations that will return matching nodes but will not remove the node from the tree. In this way, the search functions will act similarly to a <span class="strong"><em class="calibre20">peek</em></span> function in a queue or stack.</p><p class="calibre7">Our <span class="strong"><em class="calibre20">enumerate</em></span> operation will be implemented as a recursive function. We will examine recursion in more detail later, but for now we'll just implement the method. Finally, we will implement some form of <span class="strong"><em class="calibre20">copy</em></span> operation.
</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">C# provides enough functionality for us to create a versatile tree data structure with surprisingly little code. First we need to build a class to represent the nodes of a tree. Here's what a concrete implementation of a <code class="literal">Node</code> class might look like in C#:</p><pre class="programlisting">    public Int16 Data; 
    public Node Left; 
    public Node Right; 
</pre><p class="calibre7">A <code class="literal">Node</code> represents two basic components including the data contained in the node, and a collection of child nodes that are referenced by our node. In our implementation we have a public field for our node's data, which in this case is an integer. We also have a public field for each of the two child nodes called <code class="literal">Left</code> and <code class="literal">Right</code>.</p><pre class="programlisting">    public List&lt;Node&gt; Children 
    { 
        get 
        { 
            List&lt;Node&gt; children = new List&lt;Node&gt;(); 
            if (this.Left != null)  
            { 
                children.Add(this.Left); 
            } 
            if (this.Right != null)  
            { 
                children.Add(this.Right); 
            } 
            return children; 
        } 
    } 
</pre><p class="calibre7">We have added one additional getter called <code class="literal">Children</code> that returns a <code class="literal">List&lt;Node&gt;</code> containing any child nodes that exist in this node. This property is not so much for convenience as an integral part of our various recursive functions that come later.</p><pre class="programlisting">    public Node(Int16 data) 
    { 
        this.Data = data; 
    } 
</pre><p class="calibre7">Our <code class="literal">Node</code> class defines one custom constructor, which accepts a single parameter of type <code class="literal">Int</code>. This parameter populates our <code class="literal">Data</code> field as it is the only required field in our structure, since child nodes are always optional.</p><pre class="programlisting">    public bool InsertData(Int16 data) 
    { 
        Node node = new Node (data); 
        return this.InsertNode(node); 
    } 
 
    public bool InsertNode(Node node) 
    { 
        if (node == null || node.Data == this.Data) 
        { 
            return false; 
        } 
        else if (node.Data &lt; this.Data)  
        { 
            if (this.Left == null)  
            { 
                this.Left = node; 
                return true; 
            }  
            else  
            { 
                return this.Left.InsertNode(node); 
            } 
       } 
       else 
       { 
           if (this.Right == null)  
           { 
                this.Right = node; 
                return true; 
           }   
           else  
           { 
               return this.Right.InsertNode(node); 
           } 
        } 
    } 
</pre><p class="calibre7">Our first two methods support inserting data and inserting nodes. The <code class="literal">InsertData(Int data)</code> method provides our <span class="strong"><em class="calibre20">insert</em></span> functionality for raw node data. Therefore, this method takes the data point and creates a new <code class="literal">Node</code> object from it before passing that object to the <code class="literal">InsertNode(Node node)</code> method.</p><p class="calibre7">The <code class="literal">InsertNode(Node node)</code> method provides the <span class="strong"><em class="calibre20">Insert</em></span> functionality for an existing <code class="literal">Node</code> object. The method first checks whether <code class="literal">node</code> is <code class="literal">null</code>, or the <code class="literal">Data</code> value of <code class="literal">node</code> matches that of the current node. If so, we return <code class="literal">false</code>, which prevents duplicates from being added to our tree. Next we check if the value is less than our current node's data value. If so, we first check if the <code class="literal">Left</code> node exists and if not we assign the newly inserted node to that open position. Otherwise, this new node must be inserted somewhere below the <code class="literal">Left</code> node so we recursively call <code class="literal">InsertNode(Node node)</code> on the <code class="literal">Left</code> node. That recursive call will start the process over again, confirming that <code class="literal">Left</code> does not contain this value and so on.</p><p class="calibre7">If the value of the inserted <code class="literal">Node</code> is greater than our current node, the entire process repeats but starting with the <code class="literal">Right</code> node. Eventually, we either find the value already exists in our tree, or we find a leaf with an available child position that can accept the inserted <code class="literal">Node</code>. This method has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">log(n)</em></span>).</p><p class="calibre7">Using this method, we could theoretically merge entire trees together with a single call. Unfortunately, <code class="literal">InsertNode(Node node) </code>will not prevent duplicates from being entered into our tree if values existing in our current tree also exist as descendants of the inserted node. The <span class="strong"><em class="calibre20">graft</em></span> operation is required for this functionality.</p><pre class="programlisting">    public bool Graft(Node node) 
    { 
        if (node == null)  
        { 
            return false; 
        } 
 
        List&lt;Node&gt; nodes = node.ListTree(); 
        foreach (Node n in nodes)  
        { 
            this.InsertNode(n); 
        } 
 
        return true; 
    } 
</pre><p class="calibre7">The <code class="literal">Graft(Node node)</code> method leverages the existing <code class="literal">InsertNode(Node node)</code>. The method first confirms that <code class="literal">node</code> is not <code class="literal">null</code>, and returns <code class="literal">false</code> if it is. Next, the method creates a new <code class="literal">List&lt;Node&gt;</code> collection by calling <code class="literal">ListTree()</code> on <code class="literal">node</code>. We will examine <code class="literal">ListTree()</code> in a moment, but for now know that <code class="literal">ListTree()</code> will return a list containing <code class="literal">node</code> and every one of its descendants.</p><pre class="programlisting">    public Node RemoveData(Int16 data) 
    { 
        Node node = new Node (data); 
        return this.RemoveNode(node); 
    } 
 
    public Node RemoveNode(Node node) 
    { 
        if (node == null) 
        { 
            return null; 
        } 
 
        Node retNode; 
        Node modNode; 
        List&lt;Node&gt; treeList = new List&lt;Node&gt;(); 
 
        if (this.Data == node.Data) 
        { 
            //Root match 
            retNode = new Node(this.Data); 
            modNode = this; 
            if (this.Children.Count == 0)  
            { 
                return this; //Root has no childen 
            } 
        } 
        else if (this.Left.Data == node.Data)  
        { 
            retNode = new Node(this.Left.Data); 
            modNode = this.Left; 
        }   
        else if (this.Right.Data == node.Data) 
        { 
            retNode = new Node(this.Right.Data); 
            modNode = this.Right; 
       } 
       else  
       { 
           foreach (Node child in this.Children)  
           { 
               if (child.RemoveNode(node) != null)  
               { 
                   return child; 
               } 
           } 
 
           //No match in tree 
           return null;  
       } 
 
       //Reorder the tree 
       if (modNode.Left != null)  
       { 
            modNode.Data = modNode.Left.Data; 
            treeList.AddRange(modNode.Left.ListTree()); 
            modNode.Left = null; 
        }  
        else if (modNode.Right != null)  
        { 
            modNode.Data = modNode.Right.Data; 
            treeList.AddRange(modNode.Right.ListTree()); 
            modNode.Right = null; 
        }  
        else  
        { 
            modNode = null; 
        } 
  
        foreach (Node n in treeList)  
        { 
            modNode.InsertNode(n); 
        } 
 
        //Finished 
        return retNode; 
    } 
</pre><p class="calibre7">The next two methods support deleting data and deleting nodes. The <code class="literal">RemoveData(Int data)</code> method provides our <span class="strong"><em class="calibre20">delete</em></span> functionality for raw node data. Therefore, this method takes the data point and creates a new <code class="literal">Node</code> object from it, before passing that object to the <code class="literal">RemoveNode(Node node)</code> method.</p><p class="calibre7">The <code class="literal">RemoveNode(Node node)</code> method provides the <span class="strong"><em class="calibre20">delete</em></span> functionality for an existing <code class="literal">Node</code> object. The method first confirms that <code class="literal">node</code> is not <code class="literal">null</code>, and returns <code class="literal">null</code> if it is. Otherwise, the method sets up three objects including <code class="literal">retNode</code> which represents the node that will be returned; <code class="literal">modNode</code> which represents the node that will be modified to accommodate the removed node; and <code class="literal">treelist</code> which will be used to reorder the tree when a node is removed.</p><p class="calibre7">Following this, the method is broken down into two major components. The first searches for a match to the <code class="literal">node</code> parameter. The first <code class="literal">if</code> block checks if the current node data matches the node. If the node matches, <code class="literal">retNode</code> is created using <code class="literal">this.Data</code> and <code class="literal">modNode</code> is set to <code class="literal">this</code>. Before the execution moves on, the method checks if <code class="literal">this</code> has any children. If not, we have a single node tree so our method simply returns <code class="literal">this</code>. This logic prevents us from trying to completely eliminate the tree, which can only be done by another class that instantiates the root <code class="literal">Node</code> object. The next two <code class="literal">if else</code> blocks check if node matches <code class="literal">Left</code> or <code class="literal">Right</code>, respectively. In either case, <code class="literal">retNode</code> is created using the <code class="literal">Data</code> from the matching child, and <code class="literal">modNode</code> is set to the matching child. If we still don't find a match, the method recursively calls <code class="literal">RemoveNode(Node node)</code> on each of the two child nodes. If any of those calls return a <code class="literal">Node</code> object, that object is returned to the caller. When all else fails, our method returns <code class="literal">null</code>, meaning there is no match for <code class="literal">node</code>.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note34" class="calibre1"/>Note</h3><p class="calibre7">Due to how the algorithm is written, the contents of the first <code class="literal">if</code> block can only execute when the root of the tree is being examined. That's because, by the time we begin calling the method recursively on the children, we already know their <code class="literal">Data</code> values don't match that of <code class="literal">node</code>. From this point forward, our method is always looking forward to the children for a match. In terms of recursion, we refer to the first if statement as the <span class="strong"><strong class="calibre16">base case</strong></span> of our algorithm. We will examine recursion in greater detail later in this chapter.</p></div><p class="calibre7">The second component of <code class="literal">RemoveNode(Node node)</code> reorders the remaining nodes so our sorting is not lost in the process of removing node. This component first checks whether <code class="literal">Left</code> is not <code class="literal">null</code>, meaning there is a branch of nodes to the left of this node. If <code class="literal">Left</code> happens to be <code class="literal">null</code>, <code class="literal">Right</code> is checked next. If both <code class="literal">Left</code> and <code class="literal">Right</code> are <code class="literal">null</code>, we've gotten off easy as this is a leaf with no descendants that need to be reordered.</p><p class="calibre7">If either <code class="literal">Left</code> or <code class="literal">Right</code> has an object, there are descendants that need to be addressed. In either case, the block of code moves the <code class="literal">Data</code> value from the child node and assigns it to <code class="literal">modNode.Data</code>, which if you recall is the node we actually want to remove. By moving the data in this fashion we are simultaneously deleting the node and moving its child <code class="literal">Data</code> up to take its place. Following this, our method creates a <code class="literal">List&lt;Node&gt;</code> collection by calling <code class="literal">ListTree()</code> on the child node. This operation returns the child node and every one of its descendants. Then the block completes by setting the child to <code class="literal">null</code>, effectively deleting the entire branch.</p><p class="calibre7">Finally, the method loops through the <code class="literal">treeList</code> collection and calls <code class="literal">InsertNode(Node node)</code> with every <code class="literal">Node</code> in the list. This approach ensures that the data value of our child node will not be duplicated in the final tree, plus our final tree will be properly ordered before the operation has completed.</p><p class="calibre7">Although many algorithms could perform this reorder, and perhaps more than a few of those more efficient than this, for now we just need to make sure that our final tree structure still contains every node but the one that was deleted and it is properly ordered. That being said, the <code class="literal">RemoveNode(Node node)</code> method has a <span class="strong"><em class="calibre20">painfully</em></span> expensive complexity cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>).</p><pre class="programlisting">    public Node Prune(Node root) 
    { 
        Node matchNode; 
        if (this.Data == root.Data) 
        { 
            //Root match 
            Node b = this.CopyTree(); 
            this.Left = null; 
            this.Right = null; 
            return b; 
        } 
        else if (this.Left.Data == root.Data)  
        { 
            matchNode = this.Left; 
        }  
        else if (this.Right.Data == root.Data) 
        { 
            matchNode = this.Right; 
        } 
        else  
        { 
            foreach (Node child in this.Children)  
            { 
                if (child.Prune(root) != null)  
                { 
                    return child; 
                } 
            } 
 
            //No match in tree 
            return null;  
        } 
 
        Node branch = matchNode.CopyTree(); 
        matchNode = null; 
 
        return branch; 
    } 
</pre><p class="calibre7">The <code class="literal">Prune(Node root)</code> method operates in a similar fashion to <code class="literal">RemoveNode(Node node)</code>. We start by confirming that <code class="literal">root</code> is not <code class="literal">null </code>and returning <code class="literal">null </code>if it is. Next we establish our base case and look for a match in <code class="literal">this</code>. If our root node matches, the method creates a copy of the entire tree named <code class="literal">b</code>, then sets <code class="literal">Left</code> and <code class="literal">Right</code> to <code class="literal">null</code> to delete all descendants of the root before returning <code class="literal">b</code>. As in <code class="literal">RemoveNode(Node node)</code>, this logic prevents us from trying to completely eliminate the tree, which can only be done by another class that instantiates the root <code class="literal">Node</code> object.</p><p class="calibre7">If the root node does not match <code class="literal">root</code>, our method checks <code class="literal">Left</code> and <code class="literal">Right</code> and finally it recursively checks <code class="literal">Children</code>. If all else fails, we still return <code class="literal">null</code> denoting that a match could not be found.</p><p class="calibre7">If a match is found in <code class="literal">Left </code>or <code class="literal">Right</code>, <code class="literal">matchNode</code> is set to the matching node and that node is later copied to <code class="literal">Node branch</code>. Finally, <code class="literal">matchNode</code> is set to <code class="literal">null</code>, which deletes the node and its descendants from the tree, and branch is finally returned. This method has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>).</p><pre class="programlisting">    public Node FindData(Int16 data) 
    { 
        Node node = new Node (data); 
        return this.FindNode(node); 
    } 
 
    public Node FindNode(Node node) 
    { 
        if (node.Data == this.Data)  
        { 
            return this; 
        } 
 
        foreach (Node child in this.Children)  
        {  
            Node result = child.FindNode(node); 
            if (result != null)  
            { 
                return result; 
            } 
        } 
 
        return false; 
    } 
</pre><p class="calibre7">Our <code class="literal">Node</code> class implements <span class="strong"><em class="calibre20">search</em></span> functionality using the <code class="literal">FindData(Int data)</code> and <code class="literal">FindNode(Node node)</code> methods. <code class="literal">FindData(Int data)</code> allows us to pass in a raw <code class="literal">Int</code> value, which creates a new <code class="literal">Node</code> object and passes that to <code class="literal">FindNode(Node node)</code>.</p><p class="calibre7">The <code class="literal">FindNode(Node node)</code> method in turn checks if the search node data matches the current node's data. If so, we return <code class="literal">true</code> because we have a match. Otherwise, the method recursively calls <code class="literal">FindNode(Node node)</code> on each node in the <code class="literal">Children</code> collection until a match is found, or we reach the end of the tree. In that case, we return <code class="literal">false</code> denoting that the data does not exist in the tree. This method has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">log(n)</em></span>).</p><pre class="programlisting">    public Node CopyTree() 
    { 
        Node n = new Node (this.Data); 
        if (this.Left != null) 
        { 
            n.Left = this.Left.CopyTree(); 
        } 
 
        if(this.Right != null) 
        { 
            n.Right = this.Right.CopyTree(); 
        } 
        return n; 
    } 
</pre><p class="calibre7">The <code class="literal">CopyTree()</code> method duplicates the current node, then sets <code class="literal">Left</code> and <code class="literal">Right</code> to copies of this using recursive method calls. When the method returns the copied node, the copy represents a complete duplicate of the entire tree, branch, or node.</p><pre class="programlisting">    public List&lt;Node&gt; ListTree() 
    { 
        List&lt;Node&gt; result = new List&lt;Node&gt;(); 
        result.Add(new Node(this.Data()); 
        foreach (Node child in this.Children) 
        { 
            result.AddRange(child.ListTree()); 
        } 
        return result; 
    } 
</pre><p class="calibre7">Finally, we come to the <span class="strong"><em class="calibre20">enumeration</em></span> functionality provided by the <code class="literal">ListTree()</code> method. This method simply creates a new <code class="literal">List&lt;Node&gt;</code> collection, adds a new <code class="literal">Node</code> based on the <code class="literal">Data</code> in <code class="literal">this</code> to the collection, then recursively calls <code class="literal">ListTree()</code> on each node in the <code class="literal">Children</code> collection until we have gathered every node in the tree. Finally, the method returns <code class="literal">result</code> to the caller.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note35" class="calibre1"/>Note</h3><p class="calibre7">This simple class represents each of the nodes in our tree. However, you may be wondering why a node class implements all of the functionality of a tree data structure. If you recall the discussion on terminology, a root node without any descendants represents an entire tree. This means any definition of a node must necessarily provide all of the functionality of the entire tree, in and of itself. Any subsequent implementations of a tree structure will then be built with a single <code class="literal">Node</code> object as its core. This node will have children, which will in turn also have children, and so on, thus providing an entire tree structure encapsulated within a single field.</p></div><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">Java also provides the basic tools necessary to build a robust implementation of our <code class="literal">Node</code> class with little effort. Here's an example of what that implementation might look like:</p><pre class="programlisting">    public int Data; 
    public Node left; 
    public Node right; 
 
    public List&lt;Node&gt; getChildren() 
    { 
        List&lt;Node&gt; children = new LinkedList&lt;Node&gt;(); 
        if (this.Left != null) 
        { 
            children.add(this.Left); 
        } 
        if (this.Right != null) 
        { 
            children.add(this.Right); 
        } 
        return children; 
    } 
</pre><p class="calibre7">As with C#, our Java <code class="literal">Node</code> class includes a public field for our node's data, as well as public fields for each of the two child nodes called <code class="literal">Left</code> and <code class="literal">Right</code>. Our Java <code class="literal">Node</code> likewise includes a public method called <code class="literal">getChildren()</code> that returns a <code class="literal">LinkedList&lt;Node&gt;</code> containing any child nodes that exist in this node.</p><pre class="programlisting">    public Node(int data) 
    { 
        this.Data = data; 
    } 
</pre><p class="calibre7">Our <code class="literal">Node</code> class defines one custom constructor, that accepts a single parameter of type <code class="literal">int</code> which is used to populate the <code class="literal">Data</code> field.</p><pre class="programlisting">    public boolean insertData(int data) 
    { 
        Node node = new Node (data); 
        return this.insertNode(node); 
    } 
 
    public boolean insertNode(Node node) 
    { 
        if (node == null || node.Data == this.Data) 
        { 
            return false; 
        } 
        else if (node.Data &lt; this.Data) 
        { 
            if (this.Left == null) 
            { 
                this.Left = node; 
                return true; 
            } 
            else 
            { 
                return this.Left.insertNode(node); 
            } 
        } 
        else 
        { 
            if (this.Right == null) 
            { 
                this.Right = node; 
                return true; 
            } 
            else 
            { 
                return this.Right.insertNode(node); 
            } 
        } 
    } 
</pre><p class="calibre7">Our first two methods support inserting data and inserting nodes. The <code class="literal">insertData(int data)</code> method provides our <span class="strong"><em class="calibre20">insert</em></span> functionality for raw node data. Therefore, this method takes the data point and creates a new <code class="literal">Node</code> object from it before passing that object to the <code class="literal">insertNode(Node node)</code> method.</p><p class="calibre7">
<code class="literal">insertNode(Node node)</code> provides the <span class="strong"><em class="calibre20">insert</em></span> functionality for an existing <code class="literal">Node</code> object. The method first checks if <code class="literal">node</code> is <code class="literal">null</code>, or the <code class="literal">Data</code> value of <code class="literal">node</code> matches that of the current node. If so, we return <code class="literal">false</code>, which prevents duplicates from being added to our tree. Next we check if the value is less than our current node's data value. If so, we first check if the <code class="literal">Left</code> node exists and if not we assign the newly inserted node to that open position. Otherwise, this new node must be inserted somewhere below the <code class="literal">Left</code> node so we recursively call <code class="literal">insertNode(Node node)</code> on the <code class="literal">Left</code> node. That recursive call will start the process over again, confirming that <code class="literal">Left</code> does not contain this value and so on.</p><p class="calibre7">If the value of the inserted <code class="literal">Node</code> is greater than our current node, the entire process repeats using the <code class="literal">Right</code> node. Eventually, we will determine the value already existed in our tree, or we find a leaf with an available child position that can accept the inserted <code class="literal">Node</code>. This method has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">log(n)</em></span>).</p><pre class="programlisting">    public boolean graft(Node node) 
    { 
        if (node == null) 
        { 
            return false; 
        } 
 
        List&lt;Node&gt; nodes = node.listTree(); 
        for (Node n : nodes) 
        { 
            this.insertNode(n); 
        } 
        return true; 
    } 
</pre><p class="calibre7">The <code class="literal">graft(Node node)</code> method leverages the existing <code class="literal">insertNode(Node node)</code>. The method first confirms that <code class="literal">node</code> is not <code class="literal">null</code>, and returns <code class="literal">false</code> if it is. Next, the method creates a new <code class="literal">List&lt;Node&gt;</code> collection by calling <code class="literal">listTree()</code> on <code class="literal">node</code> which returns a list containing <code class="literal">node</code> and every one of its descendants.</p><pre class="programlisting">    public Node removeData(int data) 
    { 
        Node node = new Node(data); 
        return this.removeNode(node); 
    } 
 
    public Node removeNode(Node node) 
    { 
        if (node == null) 
        {   
            return null; 
        } 
 
        Node retNode; 
        Node modNode; 
        List&lt;Node&gt; treeList = new LinkedList&lt;Node&gt;(); 
 
        if (this.Data == node.Data) 
        { 
            //Root match 
            retNode = new Node(this.Data); 
            modNode = this; 
            if (this.getChildren().size() == 0) 
            { 
                return this; //Root has no childen 
            } 
        } 
        else if (this.Left.Data == node.Data) 
        { 
            //Match found 
            retNode = new Node(this.Left.Data); 
            modNode = this.Left; 
        } 
        else if (this.Right.Data == node.Data) 
        { 
            //Match found 
            retNode = new Node(this.Right.Data); 
            modNode = this.Right; 
        } 
        else 
        { 
            for (Node child : this.getChildren()) 
            { 
                if (child.removeNode(node) != null) 
                { 
                    return child; 
                } 
            } 
 
            //No match in tree 
            return null; 
        } 
 
        //Reorder the tree 
        if (modNode.Left != null) 
        { 
            modNode.Data = modNode.Left.Data; 
            treeList.addAll(modNode.Left.listTree()); 
            modNode.Left = null; 
        } 
        else if (modNode.Right != null) 
        { 
            modNode.Data = modNode.Right.Data; 
            treeList.addAll(modNode.Right.listTree()); 
            modNode.Right = null; 
        } 
        else 
        { 
            modNode = null; 
        } 
 
        for (Node n : treeList) 
        { 
            modNode.insertNode(n); 
        } 
 
        //Finished 
        return retNode; 
    } 
</pre><p class="calibre7">The next two methods support deleting data and deleting nodes. The <code class="literal">removeData(Int data)</code> method provides our <span class="strong"><em class="calibre20">delete</em></span> functionality for raw node data. Therefore, this method takes the data point and creates a new <code class="literal">Node</code> object from it, before passing that object to the <code class="literal">removeNode(Node node)</code> method.</p><p class="calibre7"><code class="literal">removeNode(Node node)</code> provides the <span class="strong"><em class="calibre20">delete</em></span> functionality for an existing <code class="literal">Node</code> object. The method first confirms that <code class="literal">node</code> is not <code class="literal">null</code>, and returns <code class="literal">null</code> if it is. Otherwise, the method sets up three objects including <code class="literal">retNode</code> which represents the node that will be returned; <code class="literal">modNode</code>, which represents the node that will be modified to accommodate the removed node; <code class="literal">treelist</code>, that will be used to reorder the tree when a node is removed.</p><p class="calibre7">The next block begins by searching for a match to the <code class="literal">node</code> parameter. The first <code class="literal">if</code> block checks if the current node matches the node. If the node matches, <code class="literal">retNode</code> is created using <code class="literal">this.Data</code> and <code class="literal">modNode</code> is set to <code class="literal">this</code>. Before the execution moves on, the method checks if <code class="literal">this</code> has any children. If not, we have a single node tree so our method simply returns <code class="literal">this</code>. The next two <code class="literal">if else</code> blocks check if node matches <code class="literal">Left</code> or <code class="literal">Right</code>, respectively. In both cases, <code class="literal">retNode</code> is created using Data from the matching child, and <code class="literal">modNode</code> is set to the matching child. If we still don't find a match, the method recursively calls <code class="literal">removeNode(Node node)</code> on each of the two child nodes. If any of those calls return a <code class="literal">Node</code> object, that object is returned to the caller. When all else fails, our method returns <code class="literal">null</code> meaning there is no match for <code class="literal">node</code> in our tree.</p><p class="calibre7">The second block of <code class="literal">removeNode(Node node)</code> reorders the remaining nodes so our sorting is not lost in the process of removing node. This component first checks if <code class="literal">Left</code> is not <code class="literal">null</code>, meaning there is a branch of nodes to the left of this node. If <code class="literal">Left</code> happens to be <code class="literal">null</code>, <code class="literal">Right</code> is checked next. If both <code class="literal">Left</code> and <code class="literal">Right</code> are <code class="literal">null</code>, we're done.</p><p class="calibre7">If either <code class="literal">Left</code> or <code class="literal">Right</code> is not <code class="literal">null</code>, the method moves the <code class="literal">Data</code> value from the child node and assigns it to <code class="literal">modNode.Data</code>. Following this, our method creates a <code class="literal">List&lt;Node&gt;</code> collection by calling <code class="literal">listTree()</code> on the child node. Then the block wraps up by setting the child to <code class="literal">null</code>, effectively deleting the entire branch.</p><p class="calibre7">Finally, the method loops through the <code class="literal">treeList</code> collection and calls <code class="literal">insertNode(Node node)</code> with every <code class="literal">Node</code> in the list. The <code class="literal">RemoveNode(Node node)</code> method has a cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>).</p><pre class="programlisting">    public Node prune(Node root) 
    { 
        if (root == null) 
        { 
            return null; 
        } 
 
        Node matchNode; 
        if (this.Data == root.Data) 
        { 
            //Root match 
            Node b = this.copyTree(); 
            this.Left = null; 
            this.Right = null; 
            return b; 
        } 
        else if (this.Left.Data == root.Data) 
        { 
            matchNode = this.Left; 
        } 
        else if (this.Right.Data == root.Data) 
        { 
            matchNode = this.Right; 
        } 
        else 
        { 
            for (Node child : this.getChildren()) 
            { 
                if (child.prune(root) != null) 
                { 
                    return child; 
                } 
            } 
 
            //No match in tree 
            return null; 
        }  
 
        Node branch = matchNode.copyTree(); 
        matchNode = null; 
 
        return branch; 
    } 
</pre><p class="calibre7">The <code class="literal">prune(Node root)</code> method operates in a similar fashion to <code class="literal">removeNode(Node node)</code>. We start by confirming that <code class="literal">root</code> is not <code class="literal">null</code> and returning <code class="literal">null </code>if it is. Next we establish our base case and look for a match in <code class="literal">this</code>. If our root node matches, the method creates a copy of the entire tree named <code class="literal">b</code>, then sets <code class="literal">Left </code>and <code class="literal">Right</code> to <code class="literal">null </code>to delete all descendants of the root before returning <code class="literal">b</code>.</p><p class="calibre7">If the root node does not match <code class="literal">root</code>, our method checks <code class="literal">Left</code> and <code class="literal">Right</code>, and finally it recursively checks <code class="literal">Children</code>. If all else fails, we return <code class="literal">null</code> since there is no match for <code class="literal">root</code> in our tree.</p><p class="calibre7">If a match is found in <code class="literal">Left</code> or <code class="literal">Right</code>, <code class="literal">matchNode</code> is set to the matching node and that node is later copied to <code class="literal">Node branch</code>. Finally, <code class="literal">matchNode</code> is set to <code class="literal">null</code>, which deletes the node and its descendants from the tree and branch is finally returned. This method has a cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>).</p><pre class="programlisting">    public Node findData(int data) 
    { 
        Node node = new Node (data); 
        return this.findNode(node); 
    } 
 
    public Node findNode(Node node) 
    { 
        if (node.Data == this.Data) 
        { 
            return this; 
        } 
 
        for (Node child : this.getChildren()) 
        { 
            Node result = child.findNode(node); 
            if (result != null) 
            { 
                return result; 
            } 
        } 
 
        return null; 
    } 
</pre><p class="calibre7">Our <code class="literal">Node</code> class implements <span class="strong"><em class="calibre20">search</em></span> functionality using the <code class="literal">findData(Int data)</code> and <code class="literal">findNode(Node node)</code> methods. <code class="literal">findData(Int data)</code> allows us to pass in a raw <code class="literal">int</code> value, which creates a new <code class="literal">Node</code> object and passes that to <code class="literal">findNode(Node node)</code>.</p><p class="calibre7">The <code class="literal">findNode(Node node)</code> method in turn checks if the search node data matches the current node's data. If so, we return <code class="literal">true</code> because we have a match. Otherwise, the method recursively calls <code class="literal">findNode(Node node)</code> on each node in the <code class="literal">Children</code> collection until a match is found, or we reach the end of the tree. In that case, we return <code class="literal">false</code>, denoting that the data does not exist in the tree. This method has a cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">log(n)</em></span>):</p><pre class="programlisting">    public Node copyTree() 
    { 
        Node n = new Node(this.Data); 
        if (this.Left != null) 
        { 
            n.Left = this.Left.copyTree(); 
        } 
 
        if(this.Right != null) 
        { 
            n.Right = this.Right.copyTree(); 
        } 
        return n; 
    } 
</pre><p class="calibre7">The <code class="literal">copyTree()</code> method duplicates the current node, then sets <code class="literal">Left</code> and <code class="literal">Right</code> to copies of the same using recursive method calls. When the method returns the copied node, the copy represents a complete duplicate of the entire tree, branch or node.</p><pre class="programlisting">    public List&lt;Node&gt; listTree() { 
        List&lt;Node&gt; result = new LinkedList&lt;Node&gt;(); 
        result.add(new Node(this.Data)); 
        for (Node child : this.getChildren()) 
        { 
            result.addAll(child.listTree()); 
        } 
        return result; 
    } 
</pre><p class="calibre7">Finally, we come to the <span class="strong"><em class="calibre20">enumeration</em></span> functionality provided by the <code class="literal">listTree()</code> method. This method simply creates a new <code class="literal">LinkedList&lt;Node&gt;</code> collection, adds a new <code class="literal">Node</code> to the collection based on the <code class="literal">Data</code> in <code class="literal">this</code>, then recursively calls <code class="literal">listTree()</code> on each node in the <code class="literal">Children</code> collection until we have gathered every node in the tree. Finally, the method returns <code class="literal">result</code> to the caller.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">As with other data structure implementations in Objective-C, we have to think a little out-of-the-box to build our Node class. In some ways, Objective-C makes our job simpler but that isn't always the case. Here's what a Node implementation might look like in Objective-C:</p><pre class="programlisting">    -(instancetype)initNodeWithData:(NSInteger)data 
    { 
        if (self = [super init]) 
        { 
            _data = data; 
        } 
        return self; 
    } 
</pre><p class="calibre7">Our <code class="literal">EDSNode</code> class defines one initializer, which accepts a single parameter of type <code class="literal">NSInetger</code>. This parameter populates our <code class="literal">_data</code> field as it is the only required field in our structure since child nodes are always optional.</p><pre class="programlisting">    -(NSInteger)data 
    { 
        return _data; 
    } 
 
    -(EDSNode*)left 
    { 
        return _left; 
    } 
 
    -(EDSNode*)right 
    { 
        return _right; 
    } 
 
    -(NSArray*)children 
    { 
        return [NSArray arrayWithObjects:_left, _right, nil]; 
    } 
</pre><p class="calibre7">The <code class="literal">EDSNode</code> node has three public properties for the data and two child nodes <code class="literal">left</code> and <code class="literal">right</code>, as well as an array property named <code class="literal">children</code> representing the collection of child nodes:</p><pre class="programlisting">    -(BOOL)insertData:(NSInteger)data 
    { 
        EDSNode *node = [[EDSNode alloc] initNodeWithData:data]; 
        return [self insertNode:node]; 
    } 
 
    -(BOOL)insertNode:(EDSNode*)node 
    { 
        if (!node || [self findNode:node]) 
        { 
            return NO; 
        } 
        else if (node.data &lt; _data) 
        { 
            if (!_left) 
            { 
                _left = node; 
                return YES; 
            } 
            else 
            { 
                return [_left insertNode:node]; 
            } 
        } 
        else 
        { 
            if (!_right) 
            { 
                _right = node; 
                return YES; 
            }  
            else  
            { 
                return [_right insertNode:node]; 
            } 
        } 
    } 
</pre><p class="calibre7">Our first two methods support inserting data and inserting nodes. The <code class="literal">insertData:</code> method provides our <span class="strong"><em class="calibre20">insert</em></span> functionality for raw node data. Therefore, this method takes the data point and creates a new <code class="literal">EDSNode</code> object from it before passing that object to the <code class="literal">insertNode:</code> method.</p><p class="calibre7">
<code class="literal">insertNode:</code> provides the <span class="strong"><em class="calibre20">insert</em></span> functionality for an existing <code class="literal">EDSNode</code> object. The method first checks if <code class="literal">node</code> is <code class="literal">nil</code>, or the <code class="literal">data</code> value of <code class="literal">node</code> matches that of the current node. If so, we return <code class="literal">NO</code>. Next we check if the value of <code class="literal">data</code> is less than our current node's <code class="literal">data</code> value. If so, we first check if the <code class="literal">left</code> node exists and if not we assign the newly inserted node to that available position. Otherwise, this new node must be inserted somewhere below the <code class="literal">left</code> node so we recursively call <code class="literal">insertNode:</code> on the <code class="literal">left</code> node. If the value of the inserted <code class="literal">EDSNode</code> is greater than our current node, the entire process repeats with the <code class="literal">right</code> node. Eventually, we either confirm the value already exists in our tree, or we find a leaf with an available child position that can accept the inserted <code class="literal">EDSNode</code>. This method has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">log(n)</em></span>):</p><pre class="programlisting">    -(BOOL)graft:(EDSNode*)node 
    { 
        if (!node) 
        { 
            return NO; 
        } 
     
        NSArray *nodes = [node listTree]; 
        for (EDSNode *n in nodes) 
        { 
            [self insertNode:n]; 
        } 
     
        return true; 
    } 
</pre><p class="calibre7">The <code class="literal">graft:</code> method leverages the existing <code class="literal">insertNode:</code>. The method first confirms that <code class="literal">node</code> is not <code class="literal">nil</code>, and returns <code class="literal">false</code> if it is. Next, the method creates a new <code class="literal">NSArray</code> collection by calling <code class="literal">listTree</code> on <code class="literal">node</code>. We will examine the <code class="literal">listTree</code> method in more detail in a moment, but for now just be aware that this method will return a list containing the node object and every one of its descendants.</p><pre class="programlisting">    -(EDSNode*)removeData:(NSInteger)data 
    { 
        EDSNode *node = [[EDSNode alloc] initNodeWithData:data]; 
        return [self removeNode:node]; 
    } 
 
    -(EDSNode*)removeNode:(EDSNode*)node 
    { 
        if (!node) 
        { 
            return NO; 
        } 
     
        EDSNode *retNode; 
        EDSNode *modNode; 
        NSMutableArray *treeList = [NSMutableArray array]; 
     
        if (self.data == node.data) 
        { 
            //Root match 
            retNode = [[EDSNode alloc] initNodeWithData:self.data]; 
            modNode = self; 
            if ([self.children count] == 0) 
            { 
                return self; //Root has no childen 
            } 
        } 
        else if (_left.data == node.data) 
        { 
            //Match found 
            retNode = [[EDSNode alloc] initNodeWithData:_left.data]; 
            modNode = _left; 
        } 
        else if (_right.data == node.data) 
        { 
            //Match found 
            retNode = [[EDSNode alloc] initNodeWithData:_right.data]; 
            modNode = _right; 
        } 
        else 
        { 
            for (EDSNode *child in self.children) 
            { 
                if ([child removeNode:node]) 
                { 
                    return child; 
                } 
            } 
         
            //No match in tree 
            return nil; 
        } 
     
        //Reorder the tree 
        if (modNode.left) 
        { 
            modNode.data = modNode.left.data; 
            [treeList addObjectsFromArray:[modNode.left listTree]]; 
            modNode.left = nil; 
        } 
        else if (modNode.right) 
        { 
            modNode.data = modNode.right.data; 
            [treeList addObjectsFromArray:[modNode.right listTree]]; 
            modNode.right = nil; 
        }   
        else  
        { 
            modNode = nil; 
        } 
     
        for (EDSNode *n in treeList) 
        { 
            [modNode insertNode:n]; 
        } 
     
        //Finished 
        return retNode; 
    } 
</pre><p class="calibre7">The next two methods support deleting data and deleting nodes. The <code class="literal">removeData:</code> method provides our <span class="strong"><em class="calibre20">delete</em></span> functionality for raw node data. Therefore, this method takes the data point and creates a new <code class="literal">EDSNode</code> object from it, before passing that object to the <code class="literal">removeNode:</code> method.
 The <code class="literal">removeNode:</code> method provides the <span class="strong"><em class="calibre20">delete</em></span> functionality for an existing <code class="literal">Node</code> object. The method first confirms that <code class="literal">node</code> is not <code class="literal">nil</code>, and returns <code class="literal">nil</code> if it is. Otherwise, the method sets up three objects including <code class="literal">retNode</code> which represents the node that will be returned; <code class="literal">modNode</code> that represents the node that will be modified to accommodate the removed node, and <code class="literal">treelist</code> which will be used to reorder the tree when a node is removed.</p><p class="calibre7">Following this, the method is broken down into two major components. The first searches for a match to the <code class="literal">node</code> parameter. The first <code class="literal">if</code> block checks if <code class="literal">self.data</code> matches <code class="literal">node.data</code>. If the node matches, <code class="literal">retNode</code> is created using <code class="literal">this.data</code> and <code class="literal">modNode</code> is set to <code class="literal">this</code>. Before the execution moves on, the method checks if <code class="literal">this</code> has any children. If not, we have a single node tree so our method simply returns <code class="literal">this</code>. This logic prevents us from trying to completely eliminate the tree, which can only be done by another class that instantiates the root <code class="literal">EDSNode</code> object. The next two <code class="literal">if else</code> blocks check if node matches <code class="literal">left</code> or <code class="literal">right</code>, respectively. In either case, <code class="literal">retNode</code> is created using the <code class="literal">data</code> from the matching child, and <code class="literal">modNode</code> is set to the matching child. If we still don't find a match, the method recursively calls <code class="literal">removeNode:</code> on each of the two child nodes. If any of those calls return a <code class="literal">Node</code> object, that object is returned to the caller. When all else fails, our method returns <code class="literal">nil</code> meaning, there is no match for <code class="literal">node</code>.</p><p class="calibre7">The second half of <code class="literal">removeNode:</code> reorders the remaining nodes so our sorting is not lost in the process of removing node. This component first checks if <code class="literal">left</code> is not <code class="literal">nil</code>, meaning there is a branch of nodes to the left of this node. If <code class="literal">left</code> happens to be <code class="literal">nil</code>, <code class="literal">Right</code> is checked next. If both <code class="literal">left</code> and <code class="literal">right</code> are <code class="literal">nil</code>, we are done.</p><p class="calibre7">If either <code class="literal">left</code> or <code class="literal">right</code> has an object, our code moves <code class="literal">data</code> from the child node and assigns it to <code class="literal">modNode.data</code>. Following this, our method creates a <code class="literal">NSArray</code> by calling <code class="literal">listTree</code> on the child node. The method then sets the child to <code class="literal">nil</code>, effectively deleting the entire branch. Finally, the method loops through the <code class="literal">treeList</code> collection and calls <code class="literal">insertNode:</code> with every <code class="literal">EDSNode</code> in the list. The <code class="literal">removeNode:</code> method has a cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>):</p><pre class="programlisting">    -(EDSNode*)prune:(EDSNode*)root 
    { 
        if (!root) 
        { 
            return nil; 
        } 
     
        EDSNode *matchNode; 
        if (self.data == root.data) 
        { 
            //Root match 
            EDSNode *b = [self copyTree]; 
            self.left = nil; 
            self.right = nil; 
            return b; 
        } 
        else if (self.left.data == root.data) 
        { 
            matchNode = self.left; 
        } 
        else if (self.right.data == root.data) 
        { 
            matchNode = self.right; 
        } 
        else 
        { 
            for (EDSNode *child in self.children) 
            { 
                if ([child prune:root]) 
                { 
                    return child; 
                } 
            } 
         
            //No match in tree 
            return nil; 
        } 
     
        EDSNode *branch = [matchNode copyTree]; 
        matchNode = nil; 
     
        return branch; 
    } 
</pre><p class="calibre7">The <code class="literal">prune:</code> method starts by confirming that <code class="literal">root</code> is not <code class="literal">nil </code>and returning <code class="literal">nil </code>if it is. Next we establish our base case and look for a match in <code class="literal">this</code>. If our root node matches, the method creates a copy of the entire tree named <code class="literal">b</code>, then sets <code class="literal">left </code>and <code class="literal">right </code>to <code class="literal">nil </code>to delete all descendants of the root before returning <code class="literal">b</code>. If the root node does not match <code class="literal">root</code>, our method checks <code class="literal">left </code>and <code class="literal">right</code>, and last it recursively checks <code class="literal">children</code>. If all else fails, we still return <code class="literal">nil </code>denoting that a match could not be found.</p><p class="calibre7">If a match is found in <code class="literal">left </code>or <code class="literal">right</code>, <code class="literal">matchNode </code>is set to the matching node and that node is later copied to <code class="literal">EDSNode branch</code>. Finally, <code class="literal">matchNode </code>is set to <code class="literal">nil</code>, which deletes the node and its descendants from the tree, and branch is finally returned. This method has a worst-case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>):</p><pre class="programlisting">    -(EDSNode*)findData:(NSInteger)data 
    { 
        EDSNode *node = [[EDSNode alloc] initNodeWithData:data]; 
        return [self findNode:node]; 
    } 
 
    -(EDSNode*)findNode:(EDSNode*)node 
    { 
        if (node.data == self.data) 
        { 
            return self; 
        } 
     
        for (EDSNode *child in self.children) 
        { 
            EDSNode *result = [child findNode:node]; 
            if (result) 
            { 
                return result; 
            } 
        } 
     
        return nil; 
    } 
</pre><p class="calibre7">Our <code class="literal">EDSNode</code> class implements <span class="strong"><em class="calibre20">search</em></span> functionality using the <code class="literal">findData:</code> and <code class="literal">findNode:</code> methods. <code class="literal">findData:</code> allows us to pass in a raw <code class="literal">NSInteger</code> value, which creates a new <code class="literal">EDSNode</code> object and passes that to <code class="literal">findNode:</code>.</p><p class="calibre7">The <code class="literal">findNode:</code> method in turn checks if the search node data matches the current node's data. If so, we return <code class="literal">YES</code> because we have a match. Otherwise, the method recursively calls <code class="literal">findNode:</code> on each node in the <code class="literal">children</code> collection until a match is found, or we reach the end of the tree. In that case, we return <code class="literal">NO</code> denoting that the data does not exist in the tree. This method has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">log(n)</em></span>):</p><pre class="programlisting">    -(EDSNode*)copyTree 
    { 
        EDSNode *n = [[EDSNode alloc] initNodeWithData:self.data]; 
        if (self.left) 
        { 
            n.left = [self.left copyTree]; 
        } 
     
        if(self.right) 
        { 
            n.right = [self.right copyTree]; 
        } 
        return n; 
    } 
</pre><p class="calibre7">The <code class="literal">copyTree</code> method duplicates the current node, then sets <code class="literal">left</code> and <code class="literal">right</code> to copies of this using recursive method calls. When the method returns the copied node, the copy represents a complete duplicate of the entire tree, branch, or node:</p><pre class="programlisting">    -(NSArray*)listTree 
    { 
        NSMutableArray *result = [NSMutableArray array]; 
        [result addObject:[[EDSNode alloc] initNodeWithData:self.data]]; 
        for (EDSNode *child in self.children) { 
            [result addObjectsFromArray:[child listTree]]; 
        } 
        return [result copy]; 
    } 
</pre><p class="calibre7">Finally, we come to the <span class="strong"><em class="calibre20">enumeration</em></span> functionality, which is provided by the <code class="literal">listTree:</code> method. This method simply creates a new <code class="literal">NSArray</code> collection, adds a new <code class="literal">EDSNode</code> based on the <code class="literal">data</code> in <code class="literal">this</code> to the collection, then recursively calls <code class="literal">listTree</code> on each node in the <code class="literal">children</code> collection until we have gathered every node in the tree. Finally, the method returns <code class="literal">result</code> to the caller.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Our Swift <code class="literal">Node</code> class is similar in structure and functionality to the C# and Java implementations. Here's what an example of the <code class="literal">Node</code> class might look like in Swift:</p><pre class="programlisting">    public var data: Int 
    public var left: Node? 
    public var right: Node? 
 
    public var children: Array&lt;Node&gt; { 
        return [left!, right!] 
    } 
</pre><p class="calibre7">Our Swift <code class="literal">Node</code> has three public properties for the data and two child nodes <code class="literal">left</code> and <code class="literal">right</code>, as well as an array property named <code class="literal">children</code> representing the collection of child nodes:</p><pre class="programlisting">    public init (nodeData: Int) 
    { 
        data = nodeData 
    } 
</pre><p class="calibre7">Our <code class="literal">EDSNode</code> class defines one initializer, which accepts a single parameter of type <code class="literal">NSInetger</code>. This parameter populates our <code class="literal">_data</code> field as it is the only required field in our structure since child nodes are always optional:</p><pre class="programlisting">    public func insertData(data: Int) -&gt; Bool 
    { 
        return insertNode(node: Node(nodeData:data)) 
    } 
 
    public func insertNode(node: Node?) -&gt; Bool 
    { 
        if (node == nil) 
        { 
            return false 
        } 
     
        if ((findNode(node: node!)) != nil) 
        { 
            return false 
        } 
        else if (node!.data &lt; data) 
        { 
            if (left == nil) 
            { 
                left = node 
                return true 
            } 
            else 
            { 
                return left!.insertNode(node: node) 
            } 
        } 
        else 
        { 
            if (right == node) 
            { 
                right = node 
                return true 
            } 
            else 
            { 
                return right!.insertNode(node: node) 
            } 
        } 
    } 
</pre><p class="calibre7">Our first two methods support inserting data and inserting nodes. The <code class="literal">insertData:</code> method provides our <span class="strong"><em class="calibre20">insert</em></span> functionality for raw node data. Therefore, this method takes the data point and creates a new <code class="literal">EDSNode</code> object from it before passing that object to the <code class="literal">insertNode:</code> method.</p><p class="calibre7">The <code class="literal">insertNode:</code> method provides the <span class="strong"><em class="calibre20">insert</em></span> functionality for an existing <code class="literal">EDSNode</code> object. The method first checks if <code class="literal">node</code> is <code class="literal">nil</code>, or the <code class="literal">data</code> value of <code class="literal">node</code> matches that of the current node. If so, we return <code class="literal">NO</code>. Next we check if the value of <code class="literal">data</code> is less than our current node's <code class="literal">data</code> value. If so, we first check if the <code class="literal">left</code> node exists and if not we assign the newly inserted node to that available position. Otherwise, this new node must be inserted somewhere below the <code class="literal">left</code> node so we recursively call <code class="literal">insertNode:</code> on the <code class="literal">left</code> node. If the value of the inserted <code class="literal">EDSNode</code> is greater than our current node, the entire process repeats with the <code class="literal">right</code> node. Eventually, we either confirm the value already exists in our tree, or we find a leaf with an available child position that can accept the inserted <code class="literal">EDSNode</code>. This method has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">log(n)</em></span>):</p><pre class="programlisting">    public func graft(node: Node?) -&gt; Bool 
    { 
        if (node == nil) 
        { 
            return false 
        } 
     
        let nodes: Array = node!.listTree() 
        for n in nodes 
        { 
            self.insertNode(node: n) 
        } 
     
        return true 
    } 
</pre><p class="calibre7">The <code class="literal">graft:</code> method functions leverages the existing <code class="literal">insertNode:</code>. The method first confirms that <code class="literal">node</code> is not <code class="literal">nil</code>, and returns <code class="literal">false</code> if it is. Next, the method creates a new <code class="literal">NSArray</code> collection by calling <code class="literal">listTree</code> on <code class="literal">node</code>. We will examine <code class="literal">listTree</code> in a moment, but for now know that <code class="literal">listTree</code> will return a list containing <code class="literal">node</code> and every one of its descendants:</p><pre class="programlisting">    public func removeData(data: Int) -&gt; Node? 
    { 
        return removeNode(node: Node(nodeData:data)) 
    } 
 
    public func removeNode(node: Node?) -&gt; Node? 
    { 
        if (node == nil) 
        { 
            return nil 
        } 
     
        var retNode: Node 
        var modNode: Node? 
        var treeList = Array&lt;Node&gt;() 
     
        if (self == node!) 
        { 
            //Root match 
            retNode = Node(nodeData: self.data) 
            modNode = self 
            if (children.count == 0) 
            { 
                return self //Root has no childen 
            } 
        } 
        else if (left! == node!) 
        { 
            //Match found 
            retNode = Node(nodeData: left!.data) 
            modNode = left! 
        } 
        else if (right! == node!) 
        { 
            //Match found 
            retNode = Node(nodeData: right!.data) 
            modNode = right! 
        } 
        else 
        { 
            for child in self.children 
            { 
                if (child.removeNode(node: node) != nil) 
                { 
                    return child 
                } 
            } 
         
            //No match in tree 
            return nil 
        } 
     
        //Reorder the tree 
        if ((modNode!.left) != nil) 
        { 
            modNode! = modNode!.left! 
            treeList = modNode!.left!.listTree() 
            modNode!.left = nil 
        } 
        else if ((modNode!.right) != nil) 
        { 
            modNode! = modNode!.right! 
            treeList = modNode!.right!.listTree() 
            modNode!.right = nil 
        }  
        else  
        { 
            modNode = nil 
        } 
     
        for n in treeList 
        { 
            modNode!.insertNode(node: n) 
        } 
     
        //Finished 
        return retNode 
    } 
</pre><p class="calibre7">The next two methods support deleting data and deleting nodes. The <code class="literal">removeData:</code> method provides our <span class="strong"><em class="calibre20">delete</em></span> functionality for raw node data. Therefore, this method takes the data point and creates a new <code class="literal">EDSNode</code> object from it, before passing that object to the <code class="literal">removeNode:</code> method.</p><p class="calibre7">The <code class="literal">removeNode:</code> method provides the <span class="strong"><em class="calibre20">delete</em></span> functionality for an existing <code class="literal">Node</code> object. The method first confirms that <code class="literal">node</code> is not <code class="literal">nil</code>, and returns <code class="literal">nil</code> if it is. Otherwise, the method sets up three objects including <code class="literal">retNode</code> which represents the node that will be returned; <code class="literal">modNode</code>, that represents the node that will be modified to accommodate the removed node; <code class="literal">treelist</code>, that will be used to reorder the tree when a node is removed.</p><p class="calibre7">Following this, the method is broken down into two major components. The first searches for a match to the <code class="literal">node</code> parameter. The first <code class="literal">if</code> block checks if <code class="literal">self.data</code> matches <code class="literal">node.data</code>. If the node matches, <code class="literal">retNode</code> is created using <code class="literal">this.data</code> and <code class="literal">modNode</code> is set to <code class="literal">this</code>. Before the execution moves on, the method checks if <code class="literal">this</code> has any children. If not, we have a single node tree so our method simply returns <code class="literal">this</code>. This logic prevents us from trying to completely eliminate the tree, which can only be done by another class that instantiates the root <code class="literal">EDSNode</code> object. The next two <code class="literal">if else</code> blocks check if node matches <code class="literal">left</code> or <code class="literal">right</code>, respectively. In either case, <code class="literal">retNode</code> is created using the <code class="literal">data</code> from the matching child, and <code class="literal">modNode</code> is set to the matching child. If we still don't find a match, the method recursively calls <code class="literal">removeNode:</code> on each of the two child nodes. If any of those calls return a <code class="literal">Node</code> object, that object is returned to the caller. When all else fails, our method returns <code class="literal">nil</code> meaning there is no match for <code class="literal">node</code>.
 The second half of <code class="literal">removeNode:</code> reorders the remaining nodes so our sorting is not lost in the process of removing node. This component first checks if <code class="literal">left</code> is not <code class="literal">nil</code>, meaning there is a branch of nodes to the left of this node. If <code class="literal">left</code> happens to be <code class="literal">nil</code>, <code class="literal">right</code> is checked next. If both <code class="literal">left</code> and <code class="literal">right</code> are <code class="literal">nil</code> we are done.</p><p class="calibre7">If either <code class="literal">left</code> or <code class="literal">right</code> has an object, our code moves <code class="literal">data</code> from the child node and assigns it to <code class="literal">modNode.data</code>. Following this, our method creates a <code class="literal">NSArray</code> by calling <code class="literal">listTree</code> on the child node. The method then sets the child to <code class="literal">nil</code>, effectively deleting the entire branch. Finally, the method loops through the <code class="literal">treeList</code> collection and calls <code class="literal">insertNode:</code> with every <code class="literal">EDSNode</code> in the list. The <code class="literal">removeNode:</code> method has a cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n<sup class="calibre21">2</sup></em></span>):</p><pre class="programlisting">    public func prune(root: Node?) -&gt; Node? 
    { 
        if (root == nil) 
        { 
            return nil 
        } 
     
        var matchNode: Node? 
        if (self == root!) 
        { 
            //Root match 
            let b = self.copyTree() 
            self.left = nil 
            self.right = nil 
            return b 
        } 
        else if (self.left! == root!) 
        { 
            matchNode = self.left! 
        } 
        else if (self.right! == root!) 
        { 
            matchNode = self.right! 
        } 
        else 
        { 
            for child in self.children 
            { 
                if (child.prune(root: root!) != nil) 
                { 
                    return child 
                } 
            } 
         
            //No match in tree 
            return nil; 
        } 
 
        let branch = matchNode!.copyTree() 
        matchNode = nil 
 
        return branch 
    } 
</pre><p class="calibre7">The <code class="literal">prune:</code> method starts by confirming that <code class="literal">root</code> is not <code class="literal">nil </code>and returning <code class="literal">nil</code> if it is. Next we establish our base case and look for a match in <code class="literal">this</code>. If our root node matches, the method creates a copy of the entire tree named <code class="literal">b</code>, then sets <code class="literal">left</code> and <code class="literal">right</code> to <code class="literal">nil</code> to delete all descendants of the root before returning <code class="literal">b</code>. If the root node does not match <code class="literal">root</code>, our method checks <code class="literal">left</code> and <code class="literal">right</code>, and finally it recursively checks <code class="literal">children</code>. If all else fails, we still return <code class="literal">nil </code>denoting that a match could not be found.</p><p class="calibre7">If a match is found in <code class="literal">left </code>or <code class="literal">right</code>, <code class="literal">matchNode</code> is set to the matching node and that node is later copied to <code class="literal">EDSNode branch</code>. Finally, <code class="literal">matchNode</code> is set to <code class="literal">nil</code>, which deletes the node and its descendants from the tree, and branch is finally returned. This method has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>):</p><pre class="programlisting">    public func findData(data: Int) -&gt; Node? 
    { 
        return findNode(node: Node(nodeData:data)) 
    } 

    public func findNode(node: Node) -&gt; Node? 
    { 
        if (node == self) 
        { 
            return self 
        } 
     
        for child in children 
        { 
            let result = child.findNode(node: node) 
            if (result != nil) 
            { 
                return result 
            } 
        } 
     
        return nil 
    } 
</pre><p class="calibre7">Our <code class="literal">EDSNode</code> class implements <span class="strong"><em class="calibre20">search</em></span> functionality using the <code class="literal">findData:</code> and <code class="literal">findNode:</code> methods. <code class="literal">findData:</code> allows us to pass in a raw <code class="literal">NSInteger</code> value, which creates a new <code class="literal">EDSNode</code> object and passes that to <code class="literal">findNode:</code>.
The <code class="literal">findNode:</code> method in turn checks if the search node data matches the current node's data. If so, we return <code class="literal">YES</code> because we have a match. Otherwise, the method recursively calls <code class="literal">findNode:</code> on each node in the <code class="literal">children</code> collection until a match is found, or we reach the end of the tree. In that case, we return <code class="literal">NO</code> denoting that the data does not exist in the tree. This method has a worst case complexity of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">log(n)</em></span>).</p><pre class="programlisting">    public func copyTree() -&gt; Node 
    { 
        let n = Node(nodeData: self.data) 
     
        if (self.left != nil) 
        { 
            n.left = self.left!.copyTree() 
        } 
     
        if(self.right != nil) 
        { 
            n.right = self.right!.copyTree() 
        } 
     
        return n 
    } 
</pre><p class="calibre7">The <code class="literal">copyTree</code> method duplicates the current node, then sets <code class="literal">left</code> and <code class="literal">right</code> to copies of this using recursive method calls. When the method returns the copied node, the copy represents a complete duplicate of the entire tree, branch, or node:</p><pre class="programlisting">    public func listTree() -&gt; Array&lt;Node&gt; 
    { 
        var result = Array&lt;Node&gt;() 
        result.append(self) 
        for child in children 
        { 
            result.append(contentsOf: child.listTree()) 
        } 
        return result 
    } 
</pre><p class="calibre7">Our Swift <code class="literal">Node</code> class implements the <span class="strong"><em class="calibre20">enumeration</em></span> functionality with the <code class="literal">listTree:</code> method. This method simply creates a new <code class="literal">NSArray</code> collection, adds a new <code class="literal">EDSNode</code> based on the <code class="literal">data</code> in <code class="literal">this</code> to the collection, then recursively calls <code class="literal">listTree</code> on each node in the <code class="literal">children</code> collection until we have gathered every node in the tree. Finally, the method returns <code class="literal">result</code> to the caller:</p><pre class="programlisting">    public func == (lhs: Node, rhs: Node) -&gt; Bool { 
        return (lhs.data == rhs.data) 
    } 
</pre><p class="calibre7">Finally, since our class implements the <code class="literal">Equatable</code> protocol, we need to override the <code class="literal">==</code> operator with respect to <code class="literal">Node</code>. This method allows us to compare data tags for our <code class="literal">Node</code> objects by simply comparing the nodes themselves; this makes our resulting code more concise and readable.</p></div>
<div class="book" title="Recursion" id="1KEEU1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec47" class="calibre1"/>Recursion</h1></div></div></div><p class="calibre7">Although many programmers and even computer science students have a difficult time understanding recursion, the concept is actually quite simple. Plainly stated, recursion is repeatedly performing the same operation by having the method of that operation invoke itself. Therefore, any function that calls an instance of itself is a <span class="strong"><strong class="calibre16">recursive function</strong></span>. As a matter of fact, if a function <code class="literal">f()</code> calls another function <code class="literal">g()</code> which in turn may call function <code class="literal">f()</code> again, this is still a recursive function because <code class="literal">f()</code> eventually calls itself. Recursion is an excellent tool for solving complex problems where the solution to the problem is based on the solution to smaller examples of the same problem.</p><p class="calibre7">The concept of recursion, or recursive functions, is so powerful that almost every modern computer language supports it by providing the ability for a method to call itself. However, before you define a recursive function, you should be aware any function that calls itself could very easily become an <span class="strong"><strong class="calibre16">infinite loop</strong></span> that will crash your application. Any recursive function is useless if there is no way to make it stop. To avoid this your algorithm must define a <span class="strong"><strong class="calibre16">base case,</strong></span> or a value that marks the end of your processing and allows the recursive function to return. Lets examine the quintessential recursion example, the <span class="strong"><strong class="calibre16">Fibonacci sequence</strong></span>.</p><p class="calibre7">The Fibonacci sequence is a series of integers where each integer in the list is the sum of the previous two integers. This definition is easily converted to the algorithm <span class="strong"><em class="calibre20">x<sub class="calibre23">n</sub> = x<sub class="calibre23">n-1</sub> + x<sub class="calibre23">n-2</sub></em></span> where n is the value of any integer in the list. For example, for the list of integers <span class="strong"><em class="calibre20">[1, 1, 2, 3, 5, 8, 13, 21, 34, ..., x<sub class="calibre23">i</sub>]</em></span>, where <span class="strong"><em class="calibre20">x<sub class="calibre23">n</sub> = 8, x<sub class="calibre23">n-1</sub> = 5</em></span> and <span class="strong"><em class="calibre20">x<sub class="calibre23">n-2</sub> = 3</em></span> so <span class="strong"><em class="calibre20">5 + 3 = 8</em></span>. Likewise, where <span class="strong"><em class="calibre20">n = 21</em></span>, <span class="strong"><em class="calibre20">x<sub class="calibre23">n-1</sub> = 13</em></span> and <span class="strong"><em class="calibre20">x<sub class="calibre23">n-2</sub> = 8</em></span> so <span class="strong"><em class="calibre20">13 + 8 = 21</em></span>. This pattern is consistent throughout the list of integers where n &gt; 2.</p><p class="calibre7">So we have a repeatable pattern where <span class="strong"><em class="calibre20">n &gt; 2</em></span>, but what if <span class="strong"><em class="calibre20">n = 2</em></span>? In that case <span class="strong"><em class="calibre20">x<sub class="calibre23">n</sub> = 1, x<sub class="calibre23">n-1</sub> = 1</em></span> and <span class="strong"><em class="calibre20">x<sub class="calibre23">n-2</sub> = undefined</em></span>, which means our algorithm breaks down. At n = 1 we run into a similar problem. Therefore, we need to define the base case for n = 1 and n = 2, or x<sub class="calibre23">1</sub> and x<sub class="calibre23">2</sub>. In the Fibonacci sequence, <span class="strong"><em class="calibre20">x<sub class="calibre23">1</sub> = 1</em></span> and <span class="strong"><em class="calibre20">x<sub class="calibre23">2</sub> = 1</em></span>. If we were to take this algorithm with the base case values, we can create a recursive function to return the list of Fibonacci integers for any value of n. In this method we will define two base case values for n = 0 and n = 1, but when n &gt; 1 our method calls itself and returns the value. Here's one example in C#:</p><pre class="programlisting">    public static int Fibonacci(int n)   
    {   
        if (n == 0) return 0; //Base case   
        if (n == 1) return 1; //Base case   
        return Fibonacci(n - 1) + Fibonacci(n - 2);   
    } 
</pre><p class="calibre7">Recursion is a great tool to have under your belt, but don't abuse it! It has been my experience that many programmers fall into two categories. On one hand, there are programmers who either don't fully understand recursion or simply choose to never use it. On the other hand, some programmers try to use it to solve every problem, which is only forgivable if you're programming in a language LISP.</p><p class="calibre7">The truth is, you should use recursion where it is appropriate, and it's appropriate when it feels natural. When you are trying to solve a problem where recursion fits you will most likely recognize it instinctively. You will either be able to distinguish the recursive nature of the problem, or no matter how hard you try you will not be able to develop an iterative solution that handles all of the base cases.</p><p class="calibre7">One final consideration for recursive functions is readability. While writing your function, keep in mind that other programmers will have to read your work. If you find yourself struggling to understand the function minutes after you wrote it, imagine how someone who is removed from the problem domain will feel while they are reading it. Therefore, review your code carefully to ensure that it is as readable and understandable as possible. Your peers will thank you.
</p></div>
<div class="book" title="Traversal" id="1LCVG1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec48" class="calibre1"/>Traversal</h1></div></div></div><p class="calibre7">There are several ways to traverse the nodes in a tree data structure, but which one you choose will be based largely on how the nodes of your tree are implemented. For example, our Node class includes references from parents to children, but not the reverse. Nor does it provide references to any siblings or cousins of the same order, or level, of the tree. Therefore, our traversal pattern is limited to stepping through the tree by means of following edges, or references, from parents to children. This type of traversal is called <span class="strong"><strong class="calibre16">walking the tree</strong></span>.</p><p class="calibre7">Our node construction would have also allowed us to examine either child prior to examining the parent. If we had structured our search patterns to check the left child node, then the right child node, and finally the node itself, we would have implemented an <span class="strong"><em class="calibre20">in-order traversal</em></span>. If our nodes contained links between objects of the same order, we could examine all parents of a particular order prior to examining any children. This approach is called a <span class="strong"><strong class="calibre16">pre-order walk</strong></span>. If we were to also include links from the child nodes to their respective parents, we could perform the inverse operation, whereby we examine all of the children of a particular order prior to examining any parents. This approach is called a post-order walk. Both of these approaches could be categorized as a <span class="strong"><strong class="calibre16">level-order walk</strong></span>, which performs a breadth-first search over the entire tree, checking nodes level by level.</p></div>
<div class="book" title="Summary" id="1MBG21-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec49" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter we learned about tree data structures, and how they differ from tree data types. We took the time to examine the terminology associated with trees including a visual representation of tree data structures. Next we evaluated the most common operations when working with trees and their complexity cost. Following this we created our own simple binary tree data structure class from scratch, and discussed how the recursive operations are used to traverse the tree. We examined the meaning of recursion and how to write recursive functions of your own using the Fibonacci sequence as an example of this process. Finally, we examined the various ways that tree data structures can be traversed depending on how the nodes in the tree are related to one another.</p></div></body></html>