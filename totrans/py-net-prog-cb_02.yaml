- en: Chapter 2. Multiplexing Socket I/O for Better Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 为提高性能而进行多路复用套接字I/O
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using ForkingMixIn in your socket server applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的套接字服务器应用程序中使用ForkingMixIn
- en: Using ThreadingMixIn in your socket server applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的套接字服务器应用程序中使用ThreadingMixIn
- en: Writing a chat server using select.select
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用select.select编写聊天服务器
- en: Multiplexing a web server using select.epoll
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用select.epoll多路复用Web服务器
- en: Multiplexing an echo server using Diesel concurrent library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Diesel并发库多路复用echo服务器
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter focuses on improving the socket server performance using a few
    useful techniques. Unlike the previous chapter, here we consider multiple clients
    that will be connected to the server and the communication can be asynchronous.
    The server does not need to process the request from clients in a blocking manner,
    this can be done independent of each other. If one client takes more time to receive
    or process data, the server does not need to wait for that. It can talk to other
    clients using separate threads or processes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍使用一些有用的技术来提高套接字服务器的性能。与上一章不同，这里我们考虑多个客户端将连接到服务器，并且通信可以是异步的。服务器不需要以阻塞方式处理来自客户端的请求，这可以独立完成。如果一个客户端接收或处理数据花费了更多时间，服务器不需要等待。它可以使用单独的线程或进程与其他客户端交谈。
- en: In this chapter, we will also explore the `select` module that provides the
    platform-specific I/O monitoring functions. This module is built on top of the
    select system call of the underlying operating system's kernel. For Linux, the
    manual page is located at [http://man7.org/linux/man-pages/man2/select.2.html](http://man7.org/linux/man-pages/man2/select.2.html)
    and can be checked to see the available features of this system call. Since our
    socket server would like to interact with many clients, `select` can be very helpful
    to monitor non-blocking sockets. There are some third-party Python libraries that
    can also help us to deal with multiple clients at the same time. We have included
    one sample recipe of using Diesel concurrent library.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将探讨`select`模块，该模块提供了特定平台的I/O监控功能。此模块建立在底层操作系统的内核的select系统调用之上。对于Linux，手册页位于[http://man7.org/linux/man-pages/man2/select.2.html](http://man7.org/linux/man-pages/man2/select.2.html)，可以检查以查看此系统调用的可用功能。由于我们的套接字服务器希望与许多客户端交互，`select`可以非常有助于监控非阻塞套接字。还有一些第三方Python库也可以帮助我们同时处理多个客户端。我们包含了一个使用Diesel并发库的示例食谱。
- en: Although, for the sake of brevity, we will be using two or few clients, readers
    are free to extend the recipes of this chapter and use them with tens and hundreds
    of clients.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管为了简洁起见，我们将使用两个或少数几个客户端，但读者可以自由扩展本章的食谱，并使用它们与成百上千的客户端一起使用。
- en: Using ForkingMixIn in your socket server applications
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的套接字服务器应用程序中使用ForkingMixIn
- en: You have decided to write an asynchronous Python socket server application.
    The server will not block in processing a client request. So the server needs
    a mechanism to deal with each client independently.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经决定编写一个异步Python套接字服务器应用程序。服务器在处理客户端请求时不会阻塞。因此，服务器需要一个机制来独立处理每个客户端。
- en: 'Python 2.7 version''s `SocketServer` class comes with two utility classes:
    `ForkingMixIn` and `ThreadingMixIn`. The `ForkingMixin` class will spawn a new
    process for each client request. This class is discussed in this section. The
    `ThreadingMixIn` class will be discussed in the next section. For more information,
    you can refer to the Python documentation at [http://docs.python.org/2/library/socketserver.html](http://docs.python.org/2/library/socketserver.html).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.7版本的`SocketServer`类包含两个实用类：`ForkingMixIn`和`ThreadingMixIn`。`ForkingMixin`类将为每个客户端请求生成一个新的进程。本节将讨论此类。`ThreadingMixIn`类将在下一节中讨论。有关更多信息，您可以参考Python文档[http://docs.python.org/2/library/socketserver.html](http://docs.python.org/2/library/socketserver.html)。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let us rewrite our echo server, previously described in [Chapter 1](ch01.html
    "Chapter 1. Sockets, IPv4, and Simple Client/Server Programming"), *Sockets, IPv4,
    and Simple Client/Server Programming*. We can utilize the subclasses of the `SocketServer`
    class family. It has ready-made TCP, UDP, and other protocol servers. We can create
    a `ForkingServer` class inherited from `TCPServer` and `ForkingMixin`. The former
    parent will enable our `ForkingServer` class to do all the necessary server operations
    that we did manually before, such as creating a socket, binding to an address,
    and listening for incoming connections. Our server also needs to inherit from
    `ForkingMixin` to handle clients asynchronously.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写之前在 [第 1 章](ch01.html "第 1 章。套接字、IPv4 和简单的客户端/服务器编程") 中描述的回显服务器，即 *套接字、IPv4
    和简单的客户端/服务器编程*。我们可以利用 `SocketServer` 类家族的子类。它提供了现成的 TCP、UDP 和其他协议服务器。我们可以创建一个从
    `TCPServer` 和 `ForkingMixin` 继承而来的 `ForkingServer` 类。前者父类将使我们的 `ForkingServer`
    类能够执行我们之前手动执行的所有必要服务器操作，例如创建套接字、绑定到地址和监听传入的连接。我们的服务器还需要从 `ForkingMixin` 继承以异步处理客户端。
- en: The `ForkingServer` class also needs to set up a request handler that dictates
    how to handle a client request. Here our server will echo back the text string
    received from the client. Our request handler class `ForkingServerRequestHandler`
    is inherited from the `BaseRequestHandler` provided with the `SocketServer` library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkingServer` 类也需要设置一个请求处理器，以规定如何处理客户端请求。在这里，我们的服务器将回显从客户端接收到的文本字符串。我们的请求处理器类
    `ForkingServerRequestHandler` 是从 `SocketServer` 库提供的 `BaseRequestHandler` 继承而来的。'
- en: We can code the client of our echo server, `ForkingClient`, in an object-oriented
    fashion. In Python, the constructor method of a class is called `__init__()`.
    By convention, it takes a self-argument to attach attributes or properties of
    that particular class. The `ForkingClient` echo server will be initialized at
    `__init__()` and sends the message to the server at the `run()` method respectively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用面向对象的方式编写我们的回显服务器客户端，`ForkingClient`。在 Python 中，类的构造函数方法被称为 `__init__()`。按照惯例，它接受一个
    self 参数来附加该特定类的属性或属性。`ForkingClient` 回显服务器将在 `__init__()` 中初始化，并在 `run()` 方法中分别向服务器发送消息。
- en: If you are not familiar with **object-oriented programming** (**OOP**) at all,
    it might be helpful to review the basic concepts of OOP while attempting to grasp
    this recipe.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本不熟悉**面向对象编程**（**OOP**），在尝试掌握这个食谱的同时，回顾 OOP 的基本概念可能会有所帮助。
- en: In order to test our `ForkingServer` class, we can launch multiple echo clients
    and see how the server responds back to the clients.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的 `ForkingServer` 类，我们可以启动多个回显客户端，并查看服务器如何响应客户端。
- en: 'Listing 2.1 shows a sample code using `ForkingMixin` in a socket server application
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 展示了在套接字服务器应用程序中使用 `ForkingMixin` 的示例代码如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An instance of `ForkingServer` is launched in the main thread, which has been
    daemonized to run in the background. Now, the two clients have started interacting
    with the server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkingServer` 的一个实例在主线程中启动，该线程已被设置为守护线程以在后台运行。现在，两个客户端已经开始与服务器交互。'
- en: 'If you run the script, it will show the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行脚本，它将显示以下输出：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The server port number might be different in your machine since this is dynamically
    chosen by the operating system kernel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端口号可能因操作系统内核动态选择而不同。
- en: Using ThreadingMixIn in your socket server applications
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的套接字服务器应用程序中使用 ThreadingMixIn
- en: Perhaps you prefer writing a multi-threaded application over a process-based
    one due to any particular reason, for example, sharing the states of that application
    across threads, avoiding the complexity of inter-process communication, or something
    else. In such a situation, if you like to write an asynchronous network server
    using `SocketServer` library, you will need `ThreadingMixin`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可能由于某些特定原因，例如，在多个线程之间共享该应用程序的状态，避免进程间通信的复杂性，或者其它原因，你更愿意编写一个基于线程的应用程序而不是基于进程的应用程序。在这种情况下，如果你喜欢使用
    `SocketServer` 库编写异步网络服务器，你需要 `ThreadingMixin`。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: By making a few minor changes to our previous recipe, you can get a working
    version of socket server using `ThreadingMixin`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对我们之前的食谱进行一些小的修改，你可以得到一个使用 `ThreadingMixin` 的工作版本的网络服务器。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)上的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: As seen in the previous socket server based on `ForkingMixIn`, `ThreadingMixIn`
    socket server will follow the same coding pattern of an echo server except a few
    things. First, our `ThreadedTCPServer` will inherit from `TCPServer` and `TheadingMixIn`.
    This multi-threaded version will launch a new thread when a client connects to
    it. Some more details can be found at [http://docs.python.org/2/library/socketserver.html](http://docs.python.org/2/library/socketserver.html).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，基于`ForkingMixIn`的socket服务器，`ThreadingMixIn`套接字服务器将遵循与回声服务器相同的编码模式，除了以下几点。首先，我们的`ThreadedTCPServer`将继承自`TCPServer`和`TheadingMixIn`。这个多线程版本将在客户端连接时启动一个新线程。更多详细信息可以在[http://docs.python.org/2/library/socketserver.html](http://docs.python.org/2/library/socketserver.html)找到。
- en: The request handler class of our socket server, `ForkingServerRequestHandler`,
    sends the echo back to the client from a new thread. You can check the thread
    information here. For the sake of simplicity, we put the client code in a function
    instead of a class. The client code creates the client socket and sends the message
    to the server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们套接字服务器的请求处理器类`ForkingServerRequestHandler`会将回声发送回客户端，从新的线程中。您可以在这里检查线程信息。为了简单起见，我们将客户端代码放在一个函数中而不是一个类中。客户端代码创建客户端套接字并向服务器发送消息。
- en: 'Listing 2.2 shows a sample code on echo socket server using `ThreadingMixIn`
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2展示了使用`ThreadingMixIn`作为以下示例的回声套接字服务器示例代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe first creates a server thread and launches it in the background.
    Then it launches three test clients to send messages to the server. In response,
    the server echoes back the message to the clients. In the `handle()` method of
    the server's request handler, you can see that we retrieve the current thread
    information and print it. This should be different in each client connection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱首先创建一个服务器线程，并在后台启动它。然后它启动三个测试客户端向服务器发送消息。作为回应，服务器将消息回显给客户端。在服务器的请求处理器的`handle()`方法中，您可以看到我们检索当前线程信息并打印它。这应该在每个客户端连接中都是不同的。
- en: 'In this client/server conversation, the `sendall()` method has been used to
    guarantee the sending of all data without any loss:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个客户端/服务器对话中，使用了`sendall()`方法来确保发送所有数据而不丢失：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Writing a chat server using select.select
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 select.select 编写聊天服务器
- en: Launching a separate thread or process per client may not be viable in any larger
    network server application where several hundred or thousand clients are concurrently
    connected to the server. Due to the limited available memory and host CPU power,
    we need a better technique to deal with large number of clients. Fortunately,
    Python provides the `select` module to overcome this problem.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何较大的网络服务器应用程序中，每个客户端都可能是数百或数千个并发连接到服务器，为每个客户端启动一个单独的线程或进程可能不可行。由于可用的内存和主机CPU功率有限，我们需要一种更好的技术来处理大量客户端。幸运的是，Python提供了`select`模块来克服这个问题。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We need to write an efficient chat server that can handle several hundred or
    a large number of client connections. We will use the `select()` method from the
    `select` module that will enable our chat server and client to do any task without
    blocking a send or receive call all the time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个高效的聊天服务器，能够处理数百或大量客户端连接。我们将使用`select()`方法，来自`select`模块，这将使我们的聊天服务器和客户端能够执行任何任务，而无需始终阻塞发送或接收调用。
- en: Let us design this recipe such that a single script can launch both client and
    server with an additional `--name` argument. Only if `--name=server` is passed
    from the command line, the script will launch the chat server. Any other value
    passed to the `--name` argument, for example, `client1`, `client2`, will launch
    a chat client. Let's specify our char server port number from the command line
    using `--port` argument. For a larger application, it may be preferable to write
    separate modules for the server and client.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计这个菜谱，使得一个单独的脚本可以通过额外的`--name`参数启动客户端和服务器。只有当从命令行传递`--name=server`时，脚本才会启动聊天服务器。传递给`--name`参数的任何其他值，例如`client1`、`client2`，将启动一个聊天客户端。我们可以使用`--port`参数从命令行指定我们的聊天服务器端口号。对于更大的应用程序，可能更倾向于为服务器和客户端编写独立的模块。
- en: 'Listing 2.3 shows an example of chat application using `select.select` as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3显示了使用`select.select`作为以下示例的聊天应用程序：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `send()` method takes one named argument channel and positional argument
    `*args`. It serializes the data using the `dumps()` method from the `cPickle`
    module. It determines the size of the data using the `struct` module. Similarly,
    `receive()` takes one named argument `channel`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`方法接受一个名为`channel`的命名参数和一个位置参数`*args`。它使用`cPickle`模块的`dumps()`方法序列化数据。它使用`struct`模块确定数据的大小。同样，`receive()`方法接受一个名为`channel`的命名参数。'
- en: 'Now we can code the `ChatServer` class as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式编写`ChatServer`类：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now the main executable method of the `ChatServer` class should look like the
    following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`ChatServer`类的主要可执行方法应该如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The chat server initializes with a few data attributes. It stores the count
    of clients, map of each client, and output sockets. The usual server socket creation
    also sets the option to reuse an address so that there is no problem restarting
    the server again using the same port. An optional backlog argument to the chat
    server constructor sets the maximum number of queued connections to listen by
    the server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天服务器初始化时带有一些数据属性。它存储客户端的数量、每个客户端的映射和输出套接字。通常的服务器套接字创建也会设置重用地址的选项，这样就不会在相同的端口上再次启动服务器时出现问题。聊天服务器构造函数的可选`backlog`参数设置了服务器可以监听的最大排队连接数。
- en: An interesting aspect of this chat server is to catch the user interrupt, usually
    via keyboard, using the `signal` module. So a signal handler `sighandler` is registered
    for the interrupt signal (`SIGINT`). This signal handler catches the keyboard
    interrupt signal and closes all output sockets where data may be waiting to be
    sent.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个聊天服务器的一个有趣方面是使用`signal`模块捕获用户中断，通常是通过键盘。因此，注册了一个信号处理程序`sighandler`用于中断信号（`SIGINT`）。这个信号处理程序捕获键盘中断信号并关闭所有可能等待发送数据的输出套接字。
- en: 'The main executive method of our chat server `run()` performs its operation
    inside a `while` loop. This method registers with a select interface where the
    input argument is the chat server socket, `stdin`. The output argument is specified
    by the server''s output socket list. In return, `select` provides three lists:
    readable, writable, and exceptional sockets. The chat server is only interested
    in readable sockets where some data is ready to be read. If that socket indicates
    to itself, then that will mean a new client connection has been established. So
    the server retrieves the client''s name and broadcasts this information to other
    clients. In another case, if anything comes from the input arguments, the chat
    server exits. Similarly, the chat server deals with the other client''s socket
    inputs. It relays the data received from any client to others and also shares
    their joining/leaving information.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们聊天服务器的主执行方法`run()`在一个`while`循环中执行其操作。该方法注册了一个选择接口，其中输入参数是聊天服务器套接字`stdin`。输出参数由服务器的输出套接字列表指定。作为回报，`select`提供了三个列表：可读、可写和异常套接字。聊天服务器只对可读套接字感兴趣，其中有一些数据准备好被读取。如果该套接字指向自身，那么这意味着已经建立了一个新的客户端连接。因此，服务器检索客户端的名称并将此信息广播给其他客户端。在另一种情况下，如果输入参数有任何内容，聊天服务器将退出。同样，聊天服务器处理其他客户端的套接字输入。它将接收到的任何客户端数据中继给其他客户端，并共享他们的加入/离开信息。
- en: 'The chat client code class should contain the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天客户端代码类应包含以下代码：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The chat client initializes with a name argument and sends this name to the
    chat server upon connecting. It also sets up a custom prompt `[ name@host ]>`.
    The executive method of this client `run()` continues its operation as long as
    the connection to the server is active. In a manner similar to the chat server,
    the chat client also registers with `select()`. If anything in readable sockets
    is ready, it enables the client to receive data. If the sock value is `0` and
    there''s any data available then the data can be sent. The same information is
    also shown in stdout or, in our case, the command-line console. Our main method
    should now get command-line arguments and call either the server or client as
    follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天客户端使用名称参数初始化，并在连接时将此名称发送到聊天服务器。它还设置了自定义提示`[ name@host ]>`。此客户端的执行方法`run()`只要与服务器保持连接就会继续其操作。类似于聊天服务器，聊天客户端也使用`select()`进行注册。如果任何可读套接字准备好，它将使客户端能够接收数据。如果sock值是`0`并且有可用数据，则可以发送数据。相同的信息也会显示在stdout中，或者在我们的情况下，是命令行控制台。现在，我们的主方法应该获取命令行参数，并按照以下方式调用服务器或客户端：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We would like to run this script thrice: once for the chat server and twice
    for two chat clients. For the server, we pass `–name=server` and `port=8800`.
    For `client1`, we change the name argument `--name=client1` and for `client2`,
    we put `--name=client2`. Then from the `client1` value prompt we send the message
    `"Hello from client 1"`, which is printed in the prompt of the `client2`. Similarly,
    we send `"hello from client 2`" from the prompt of the `client2`, which is shown
    in the prompt of the `client1`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望运行这个脚本三次：一次用于聊天服务器，两次用于两个聊天客户端。对于服务器，我们传递`–name=server`和`port=8800`。对于`client1`，我们更改名称参数`--name=client1`，对于`client2`，我们设置`--name=client2`。然后从`client1`的值提示中发送消息`"Hello
    from client 1"`，该消息将在`client2`的提示中打印出来。同样，我们从`client2`的提示中发送`"hello from client
    2"`，该消息将在`client1`的提示中显示。
- en: 'The output for the server is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器输出如下：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output for `client1` is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`client1`的输出如下：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output for `client2` is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`client2`的输出如下：'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The whole interaction is shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 整个交互过程如下截图所示：
- en: '![How to do it...](img/3463OS_02_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3463OS_02_01.jpg)'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'At the top of our module, we defined two utility functions: `send()` and `receive()`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们模块的顶部，我们定义了两个实用函数：`send()`和`receive()`。
- en: The chat server and client use these utility functions, which were demonstrated
    earlier. The details of the chat server and client methods were also discussed
    earlier.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天服务器和客户端使用这些实用函数，这些函数之前已经演示过。之前也讨论了聊天服务器和客户端方法的细节。
- en: Multiplexing a web server using select.epoll
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用select.epoll多路复用Web服务器
- en: Python's `select` module has a few platform-specific, networking event management
    functions. On a Linux machine, `epoll` is available. This will utilize the operating
    system kernel that will poll network events and let our script know whenever something
    happens. This sounds more efficient than the previously mentioned `select.select`
    approach.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`select`模块有几个平台特定的网络事件管理函数。在Linux机器上，`epoll`可用。这将利用操作系统内核来轮询网络事件，并让我们的脚本知道何时发生某些事情。这听起来比之前提到的`select.select`方法更高效。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's write a simple web server that can return a single line of text to any
    connected web browser.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的Web服务器，它可以向任何连接的Web浏览器返回一行文本。
- en: 'The core idea is during the initialization of this web server, we should make
    a call to `select.epoll()` and register our server''s file descriptor for event
    notifications. In the web server''s executive code, the socket event is monitored
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是在这个Web服务器初始化期间，我们应该调用`select.epoll()`并注册我们服务器的文件描述符以接收事件通知。在Web服务器的执行代码中，监视套接字事件如下：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run this script and access the web server from your browser, such as
    Firefox or IE, by entering `http://localhost:8800/`, the following output will
    be shown in the console:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本并通过浏览器（如Firefox或IE）访问Web服务器，通过输入`http://localhost:8800/`，控制台将显示以下输出：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will also be able to see the following line in your browser:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将在你的浏览器中看到以下行：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot shows the scenario:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了该场景：
- en: '![How to do it...](img/3463OS_02_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3463OS_02_02.jpg)'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In our `EpollServer` web server's constructor, a socket server is created and
    bound to a localhost at a given port. The server's socket is set to the non-blocking
    mode (`setblocking(0)`). The `TCP_NODELAY` option is also set so that our server
    can exchange data without buffering (as in the case of an SSH connection). Next,
    the `select.epoll()` instance is created and the socket's file descriptor is passed
    to that instance to help monitoring.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`EpollServer` Web服务器的构造函数中，创建了一个套接字服务器并将其绑定到给定端口的localhost。服务器的套接字设置为非阻塞模式（`setblocking(0)`）。还设置了`TCP_NODELAY`选项，以便我们的服务器可以不进行缓冲交换数据（如SSH连接的情况）。接下来，创建了`select.epoll()`实例，并将套接字的文件描述符传递给该实例以帮助监控。
- en: 'In the `run()` method of the web server, it starts receiving the socket events.
    These events are denoted as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web服务器的`run()`方法中，它开始接收套接字事件。这些事件如下表示：
- en: '`EPOLLIN`: This socket reads events'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EPOLLIN`：此套接字读取事件'
- en: '`EPOLLOUT`: This socket writes events'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EPOLLOUT`：此套接字写入事件'
- en: In case of a server socket, it sets up the response `SERVER_RESPONSE`. When
    the socket has any connection that wants to write data, it can do that inside
    the `EPOLLOUT` event case. The `EPOLLHUP` event signals an unexpected close to
    a socket that is due to the internal error conditions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器套接字，它设置了响应`SERVER_RESPONSE`。当套接字有任何想要写入数据的连接时，它可以在`EPOLLOUT`事件案例中这样做。`EPOLLHUP`事件表示由于内部错误条件而意外关闭套接字。
- en: Multiplexing an echo server using Diesel concurrent library
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Diesel并发库的多路复用回显服务器
- en: Sometimes you need to write a large custom networking application that wants
    to avoid repeated server initialization code that creates a socket, binds to an
    address, listens, and handles basic errors. There are numerous Python networking
    libraries out there to help you to remove boiler-plate code. Here, we can examine
    such a library called Diesel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要编写一个大型自定义网络应用程序，该应用程序希望避免重复的服务器初始化代码，该代码创建套接字、绑定到地址、监听和处理基本错误。有许多Python网络库可以帮助您删除样板代码。在这里，我们可以检查一个名为Diesel的库。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Diesel uses a non-blocking technique with co-routines to write networking severs
    efficiently. As stated on the website, *Diesel''s core is a tight event loop that
    uses epoll to deliver nearly flat performance out to 10,000 connections and beyond*.
    Here, we introduce Diesel with a simple echo server. You also need diesel library
    3.0 or any later version. You can do that with pip command: `$ pip install diesel
    >= 3.0`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Diesel使用带有协程的非阻塞技术来高效地编写网络服务器。正如网站所述，*Diesel的核心是一个紧密的事件循环，使用epoll提供接近平坦的性能，支持10,000个连接以及更多*。在这里，我们通过一个简单的回显服务器介绍Diesel。您还需要diesel库3.0或更高版本。您可以使用pip命令完成此操作：`$
    pip install diesel >= 3.0`。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the Python Diesel framework, applications are initialized with an instance
    of the `Application()` class and an event handler is registered with this instance.
    Let's see how simple it is to write an echo server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python Diesel框架中，应用程序使用`Application()`类的实例初始化，并使用此实例注册事件处理器。让我们看看编写回显服务器有多简单。
- en: 'Listing 2.5 shows the code on the echo server example using Diesel as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5显示了使用Diesel作为以下回显服务器示例的代码：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run this script, the server will show the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此脚本，服务器将显示以下输出：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On another console window, another Telnet client can be launched and the echoing
    message to our server can be tested as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个控制台窗口中，可以启动另一个Telnet客户端，并按以下方式测试向我们的服务器发送的回显消息：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following screenshot illustrates the interaction of the Diesel chat server:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了Diesel聊天服务器的交互：
- en: '![How to do it...](img/3463OS_02_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3463OS_02_03.jpg)'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our script has taken a command-line argument for `--port` and passed this to
    the `main()` function where our Diesel application has been initialized and run.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本为`--port`参数取了一个命令行参数，并将其传递给初始化并运行我们的Diesel应用程序的`main()`函数。
- en: Diesel has a notion of service where an application can be built with many services.
    `EchoServer` has a `handler()` method. This enables the server to deal with individual
    client connections. The `Service()` method takes the `handler` method and a port
    number to run that service.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Diesel有一个服务概念，其中可以使用许多服务构建应用程序。`EchoServer`有一个`handler()`方法。这使得服务器能够处理单个客户端连接。`Service()`方法接受`handler`方法和端口号来运行该服务。
- en: Inside the `handler()` method, we determine the behavior of the server. In this
    case, the server is simply returning the message text.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handler()`方法内部，我们确定服务器的行为。在这种情况下，服务器只是返回消息文本。
- en: If we compare this code with [Chapter 1](ch01.html "Chapter 1. Sockets, IPv4,
    and Simple Client/Server Programming"), *Sockets, IPv4, and Simple Client/Server
    Programming*, in the *Writing a simple echo client/server application* recipe
    (*listing 1.13a*), it is very clear that we do not need to write any boiler-plate
    code and hence it's very easy to concentrate on high-level application logic.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这段代码与[第1章](ch01.html "第1章. 套接字、IPv4和简单的客户端/服务器编程")中的*套接字、IPv4和简单的客户端/服务器编程*部分，在*编写简单的回声客户端/服务器应用程序*配方（*列表1.13a*）中进行比较，那么我们可以非常清楚地看到，我们不需要编写任何样板代码，因此可以很容易地专注于高级应用程序逻辑。
