- en: Chapter 2. Multiplexing Socket I/O for Better Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using ForkingMixIn in your socket server applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ThreadingMixIn in your socket server applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a chat server using select.select
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplexing a web server using select.epoll
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplexing an echo server using Diesel concurrent library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on improving the socket server performance using a few
    useful techniques. Unlike the previous chapter, here we consider multiple clients
    that will be connected to the server and the communication can be asynchronous.
    The server does not need to process the request from clients in a blocking manner,
    this can be done independent of each other. If one client takes more time to receive
    or process data, the server does not need to wait for that. It can talk to other
    clients using separate threads or processes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will also explore the `select` module that provides the
    platform-specific I/O monitoring functions. This module is built on top of the
    select system call of the underlying operating system's kernel. For Linux, the
    manual page is located at [http://man7.org/linux/man-pages/man2/select.2.html](http://man7.org/linux/man-pages/man2/select.2.html)
    and can be checked to see the available features of this system call. Since our
    socket server would like to interact with many clients, `select` can be very helpful
    to monitor non-blocking sockets. There are some third-party Python libraries that
    can also help us to deal with multiple clients at the same time. We have included
    one sample recipe of using Diesel concurrent library.
  prefs: []
  type: TYPE_NORMAL
- en: Although, for the sake of brevity, we will be using two or few clients, readers
    are free to extend the recipes of this chapter and use them with tens and hundreds
    of clients.
  prefs: []
  type: TYPE_NORMAL
- en: Using ForkingMixIn in your socket server applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have decided to write an asynchronous Python socket server application.
    The server will not block in processing a client request. So the server needs
    a mechanism to deal with each client independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 2.7 version''s `SocketServer` class comes with two utility classes:
    `ForkingMixIn` and `ThreadingMixIn`. The `ForkingMixin` class will spawn a new
    process for each client request. This class is discussed in this section. The
    `ThreadingMixIn` class will be discussed in the next section. For more information,
    you can refer to the Python documentation at [http://docs.python.org/2/library/socketserver.html](http://docs.python.org/2/library/socketserver.html).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us rewrite our echo server, previously described in [Chapter 1](ch01.html
    "Chapter 1. Sockets, IPv4, and Simple Client/Server Programming"), *Sockets, IPv4,
    and Simple Client/Server Programming*. We can utilize the subclasses of the `SocketServer`
    class family. It has ready-made TCP, UDP, and other protocol servers. We can create
    a `ForkingServer` class inherited from `TCPServer` and `ForkingMixin`. The former
    parent will enable our `ForkingServer` class to do all the necessary server operations
    that we did manually before, such as creating a socket, binding to an address,
    and listening for incoming connections. Our server also needs to inherit from
    `ForkingMixin` to handle clients asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The `ForkingServer` class also needs to set up a request handler that dictates
    how to handle a client request. Here our server will echo back the text string
    received from the client. Our request handler class `ForkingServerRequestHandler`
    is inherited from the `BaseRequestHandler` provided with the `SocketServer` library.
  prefs: []
  type: TYPE_NORMAL
- en: We can code the client of our echo server, `ForkingClient`, in an object-oriented
    fashion. In Python, the constructor method of a class is called `__init__()`.
    By convention, it takes a self-argument to attach attributes or properties of
    that particular class. The `ForkingClient` echo server will be initialized at
    `__init__()` and sends the message to the server at the `run()` method respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with **object-oriented programming** (**OOP**) at all,
    it might be helpful to review the basic concepts of OOP while attempting to grasp
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test our `ForkingServer` class, we can launch multiple echo clients
    and see how the server responds back to the clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 2.1 shows a sample code using `ForkingMixin` in a socket server application
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An instance of `ForkingServer` is launched in the main thread, which has been
    daemonized to run in the background. Now, the two clients have started interacting
    with the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the script, it will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The server port number might be different in your machine since this is dynamically
    chosen by the operating system kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Using ThreadingMixIn in your socket server applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps you prefer writing a multi-threaded application over a process-based
    one due to any particular reason, for example, sharing the states of that application
    across threads, avoiding the complexity of inter-process communication, or something
    else. In such a situation, if you like to write an asynchronous network server
    using `SocketServer` library, you will need `ThreadingMixin`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By making a few minor changes to our previous recipe, you can get a working
    version of socket server using `ThreadingMixin`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the previous socket server based on `ForkingMixIn`, `ThreadingMixIn`
    socket server will follow the same coding pattern of an echo server except a few
    things. First, our `ThreadedTCPServer` will inherit from `TCPServer` and `TheadingMixIn`.
    This multi-threaded version will launch a new thread when a client connects to
    it. Some more details can be found at [http://docs.python.org/2/library/socketserver.html](http://docs.python.org/2/library/socketserver.html).
  prefs: []
  type: TYPE_NORMAL
- en: The request handler class of our socket server, `ForkingServerRequestHandler`,
    sends the echo back to the client from a new thread. You can check the thread
    information here. For the sake of simplicity, we put the client code in a function
    instead of a class. The client code creates the client socket and sends the message
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 2.2 shows a sample code on echo socket server using `ThreadingMixIn`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe first creates a server thread and launches it in the background.
    Then it launches three test clients to send messages to the server. In response,
    the server echoes back the message to the clients. In the `handle()` method of
    the server's request handler, you can see that we retrieve the current thread
    information and print it. This should be different in each client connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this client/server conversation, the `sendall()` method has been used to
    guarantee the sending of all data without any loss:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Writing a chat server using select.select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launching a separate thread or process per client may not be viable in any larger
    network server application where several hundred or thousand clients are concurrently
    connected to the server. Due to the limited available memory and host CPU power,
    we need a better technique to deal with large number of clients. Fortunately,
    Python provides the `select` module to overcome this problem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to write an efficient chat server that can handle several hundred or
    a large number of client connections. We will use the `select()` method from the
    `select` module that will enable our chat server and client to do any task without
    blocking a send or receive call all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Let us design this recipe such that a single script can launch both client and
    server with an additional `--name` argument. Only if `--name=server` is passed
    from the command line, the script will launch the chat server. Any other value
    passed to the `--name` argument, for example, `client1`, `client2`, will launch
    a chat client. Let's specify our char server port number from the command line
    using `--port` argument. For a larger application, it may be preferable to write
    separate modules for the server and client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 2.3 shows an example of chat application using `select.select` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `send()` method takes one named argument channel and positional argument
    `*args`. It serializes the data using the `dumps()` method from the `cPickle`
    module. It determines the size of the data using the `struct` module. Similarly,
    `receive()` takes one named argument `channel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can code the `ChatServer` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the main executable method of the `ChatServer` class should look like the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The chat server initializes with a few data attributes. It stores the count
    of clients, map of each client, and output sockets. The usual server socket creation
    also sets the option to reuse an address so that there is no problem restarting
    the server again using the same port. An optional backlog argument to the chat
    server constructor sets the maximum number of queued connections to listen by
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting aspect of this chat server is to catch the user interrupt, usually
    via keyboard, using the `signal` module. So a signal handler `sighandler` is registered
    for the interrupt signal (`SIGINT`). This signal handler catches the keyboard
    interrupt signal and closes all output sockets where data may be waiting to be
    sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main executive method of our chat server `run()` performs its operation
    inside a `while` loop. This method registers with a select interface where the
    input argument is the chat server socket, `stdin`. The output argument is specified
    by the server''s output socket list. In return, `select` provides three lists:
    readable, writable, and exceptional sockets. The chat server is only interested
    in readable sockets where some data is ready to be read. If that socket indicates
    to itself, then that will mean a new client connection has been established. So
    the server retrieves the client''s name and broadcasts this information to other
    clients. In another case, if anything comes from the input arguments, the chat
    server exits. Similarly, the chat server deals with the other client''s socket
    inputs. It relays the data received from any client to others and also shares
    their joining/leaving information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The chat client code class should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The chat client initializes with a name argument and sends this name to the
    chat server upon connecting. It also sets up a custom prompt `[ name@host ]>`.
    The executive method of this client `run()` continues its operation as long as
    the connection to the server is active. In a manner similar to the chat server,
    the chat client also registers with `select()`. If anything in readable sockets
    is ready, it enables the client to receive data. If the sock value is `0` and
    there''s any data available then the data can be sent. The same information is
    also shown in stdout or, in our case, the command-line console. Our main method
    should now get command-line arguments and call either the server or client as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to run this script thrice: once for the chat server and twice
    for two chat clients. For the server, we pass `–name=server` and `port=8800`.
    For `client1`, we change the name argument `--name=client1` and for `client2`,
    we put `--name=client2`. Then from the `client1` value prompt we send the message
    `"Hello from client 1"`, which is printed in the prompt of the `client2`. Similarly,
    we send `"hello from client 2`" from the prompt of the `client2`, which is shown
    in the prompt of the `client1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the server is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for `client1` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for `client2` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole interaction is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3463OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the top of our module, we defined two utility functions: `send()` and `receive()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The chat server and client use these utility functions, which were demonstrated
    earlier. The details of the chat server and client methods were also discussed
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplexing a web server using select.epoll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's `select` module has a few platform-specific, networking event management
    functions. On a Linux machine, `epoll` is available. This will utilize the operating
    system kernel that will poll network events and let our script know whenever something
    happens. This sounds more efficient than the previously mentioned `select.select`
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write a simple web server that can return a single line of text to any
    connected web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core idea is during the initialization of this web server, we should make
    a call to `select.epoll()` and register our server''s file descriptor for event
    notifications. In the web server''s executive code, the socket event is monitored
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script and access the web server from your browser, such as
    Firefox or IE, by entering `http://localhost:8800/`, the following output will
    be shown in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also be able to see the following line in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3463OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our `EpollServer` web server's constructor, a socket server is created and
    bound to a localhost at a given port. The server's socket is set to the non-blocking
    mode (`setblocking(0)`). The `TCP_NODELAY` option is also set so that our server
    can exchange data without buffering (as in the case of an SSH connection). Next,
    the `select.epoll()` instance is created and the socket's file descriptor is passed
    to that instance to help monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `run()` method of the web server, it starts receiving the socket events.
    These events are denoted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EPOLLIN`: This socket reads events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EPOLLOUT`: This socket writes events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of a server socket, it sets up the response `SERVER_RESPONSE`. When
    the socket has any connection that wants to write data, it can do that inside
    the `EPOLLOUT` event case. The `EPOLLHUP` event signals an unexpected close to
    a socket that is due to the internal error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplexing an echo server using Diesel concurrent library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need to write a large custom networking application that wants
    to avoid repeated server initialization code that creates a socket, binds to an
    address, listens, and handles basic errors. There are numerous Python networking
    libraries out there to help you to remove boiler-plate code. Here, we can examine
    such a library called Diesel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Diesel uses a non-blocking technique with co-routines to write networking severs
    efficiently. As stated on the website, *Diesel''s core is a tight event loop that
    uses epoll to deliver nearly flat performance out to 10,000 connections and beyond*.
    Here, we introduce Diesel with a simple echo server. You also need diesel library
    3.0 or any later version. You can do that with pip command: `$ pip install diesel
    >= 3.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Python Diesel framework, applications are initialized with an instance
    of the `Application()` class and an event handler is registered with this instance.
    Let's see how simple it is to write an echo server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 2.5 shows the code on the echo server example using Diesel as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, the server will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'On another console window, another Telnet client can be launched and the echoing
    message to our server can be tested as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates the interaction of the Diesel chat server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3463OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our script has taken a command-line argument for `--port` and passed this to
    the `main()` function where our Diesel application has been initialized and run.
  prefs: []
  type: TYPE_NORMAL
- en: Diesel has a notion of service where an application can be built with many services.
    `EchoServer` has a `handler()` method. This enables the server to deal with individual
    client connections. The `Service()` method takes the `handler` method and a port
    number to run that service.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `handler()` method, we determine the behavior of the server. In this
    case, the server is simply returning the message text.
  prefs: []
  type: TYPE_NORMAL
- en: If we compare this code with [Chapter 1](ch01.html "Chapter 1. Sockets, IPv4,
    and Simple Client/Server Programming"), *Sockets, IPv4, and Simple Client/Server
    Programming*, in the *Writing a simple echo client/server application* recipe
    (*listing 1.13a*), it is very clear that we do not need to write any boiler-plate
    code and hence it's very easy to concentrate on high-level application logic.
  prefs: []
  type: TYPE_NORMAL
