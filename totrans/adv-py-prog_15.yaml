- en: '*Chapter 13*: Starvation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the concept of **starvation** and its potential
    causes in concurrent programming. We will cover a number of variations of the
    **readers-writers problems**, which are prime examples of starvation, and we will
    simulate them in example Python code. This chapter will also cover the relationship
    between *deadlock* and *starvation*, as well as some potential solutions for starvation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding starvation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approaching the readers-writers problem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solutions to starvation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a deep understanding of starvation,
    what causes it, and what practical solutions can be implemented to address the
    problem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter13).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Understanding starvation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Starvation** is a problem in concurrent systems, in which a process (or a
    thread) cannot gain access to the necessary resources in order to proceed with
    its execution and, therefore, cannot make any progress. In this section, we will
    look into the characteristics of a starvation situation, analyze its most common
    causes, and finally, consider a sample program that exemplifies starvation.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: What is starvation?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is quite common for a concurrent program to implement some sort of ordering
    between the different processes in its execution. For example, consider a program
    that has three separate processes, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: One is responsible for handling extremely pressing instructions that need to
    be run as soon as the necessary resources become available.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another process is responsible for other important executions, which are not
    as essential as the tasks in the first process.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last one handles miscellaneous, very infrequent tasks.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, these three processes need to utilize the same resources in order
    to execute their respective instructions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, we have every reason to implement a specification that allows the
    first process to have the highest priority of execution and access to resources,
    then the second process, and then the last process, with the lowest priority.
    However, imagine situations in which the first two processes (with higher priorities)
    run so often that the third process cannot execute its instructions; anytime the
    third process needs to run, it checks to see whether the resources are available
    to be used and finds out that one of the other higher-priority processes is using
    them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: This is a situation of starvation – the third process is given no opportunity
    to execute and, therefore, no progress can be made with that process. In a typical
    concurrent program, it is quite common to have more than three processes at different
    priority levels, yet the situation is fundamentally similar – some processes are
    given more opportunities to run and, therefore, they are constantly executing.
    Others have lower priorities and cannot access the necessary resources to execute.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next few subsections, we will be discussing the potential candidates
    that cause starvation situations. Most of the time, a poorly coordinated set of
    *scheduling instructions* is the main cause of starvation. For example, a considerably
    naive algorithm that deals with three separate tasks might implement constant
    communication and interaction between the first two tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: This setup leads to the fact that the execution flow of the algorithm switches
    solely between the first and second tasks, while the third finds itself idle and
    unable to make any progress with its execution – in this case, because it is starved
    of CPU execution flow. Intuitively, we can identify the root of the problem as
    the fact that the algorithm allows the first two tasks to always dominate the
    CPU and, hence, effectively prevents any other task from also utilizing the CPU.
    A characteristic of a good scheduling algorithm is the ability to distribute the
    execution flow and allocate the resources equally and appropriately.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, many concurrent systems and programs implement a specific
    order of priority, in terms of process and thread execution. This implementation
    of ordered scheduling may very likely lead to the starvation of processes and
    threads of lower priorities and can result in a condition called **priority inversion**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that, in your concurrent program, you have process A of the highest
    priority, process B of a medium priority, and finally, process C of the lowest
    priority; process C would most likely be put in the situation of starvation. Additionally,
    if the execution of process A, the prioritized process, is dependent on the completion
    of process C, which is already in starvation, then process A might never be able
    to complete its execution either, even though it is given the highest priority
    in the concurrent program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram further illustrates the concept of priority inversion
    – a high-priority task running from the time **t2** to **t3** needs to access
    some resources, which are being utilized by a low-priority task:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – A diagram of priority inversion ](img/B17499Figure_13.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – A diagram of priority inversion
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, combining starvation and priority inversion can lead to a situation
    where even the high-priority tasks are unable to execute their instructions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Causes of starvation
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the complexity of designing a scheduling algorithm in mind, let''s discuss
    the specific causes of starvation. The situations that we described in the preceding
    section indicate some potential causes of a starvation situation. However, starvation
    can arise from a number of sources, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Processes (or threads) with high priorities dominate the execution flow in the
    CPU and, hence, low-priority processes (or threads) are not given the opportunity
    to execute their own instructions.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes (or threads) with high priorities dominate the usage of non-shareable
    resources and, hence, low-priority processes (or threads) are not given the opportunity
    to execute their own instructions. This situation is similar to the first one
    but addresses the priority of accessing resources, instead of the priority of
    the execution itself.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes (or threads) with low priorities are waiting for resources to execute
    their instructions, but as soon as the resources become available, other processes
    (or threads) with higher priorities are immediately given access to them, so the
    low-priority processes (or threads) wait indefinitely.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other causes of starvation as well, but the preceding are the most
    common root causes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Starvation's relationship to deadlock
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interestingly, deadlock situations can also lead to starvation, as the definition
    of starvation states that if there is a process (or a thread) that is unable to
    make any progress because it cannot gain access to the necessary process, the
    process (or thread) is experiencing starvation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall our example of deadlock, the Dining Philosophers problem, illustrated
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – An illustration of the Dining Philosophers problem ](img/B17499Figure_13.2.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – An illustration of the Dining Philosophers problem
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: When deadlock occurs in this situation, no philosopher can obtain the necessary
    resources to execute their instructions (each philosopher is required to have
    two forks to start eating). Each philosopher that is in deadlock is therefore
    also in a state of starvation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The readers-writers problem describes in detail the various types of starvation,
    which we will consider next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Approaching the readers-writers problem
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The readers-writers problem is one of the classic use cases in concurrent programming,
    illustrating problems that might occur in a concurrent program. Throughout the
    analysis of the different variations of the readers-writers problem, we will reveal
    more about starvation, as well as its common causes. We will also simulate the
    problem in Python so that a deeper understanding of the problem can be gained.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Problem statement
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a readers-writers problem, first and foremost, we have a shared resource,
    which, in most cases, is a text file. Different threads interact with that text
    file; each is either a reader or a writer. A **reader** is a thread that simply
    accesses the shared resource (the text file) and reads in the data included in
    that file, while a **writer** is a thread that accesses, and possibly mutates,
    the contents of the text file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: We know that writers and readers cannot access the shared resources simultaneously
    since if a thread is writing data to the file, no other thread should be accessing
    the file to read any data from it. The goal of the readers-writers problem is
    therefore to find a correct and efficient way to design and coordinate the scheduling
    of these reader and writer threads. Successful implementation of that goal is
    not only that the program as a whole executes in the most optimized way but also
    that all threads are given sufficient opportunity to execute their instructions
    and no starvation can occur. Additionally, the shared resource (the text file)
    needs to be handled appropriately so that no data will be corrupted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram further illustrates the setup of the readers-writers
    problem:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – A diagram of the readers-writers problem ](img/B17499Figure_13.3.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – A diagram of the readers-writers problem
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will be exploring different variations of the
    problem with increasing levels of complexity. From there, we will also implement
    sample solutions to these problems, thus gaining hands-on experience in preventing
    starvation in concurrent applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The first readers-writers problem
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned, the problem asks us to come up with a scheduling algorithm
    so that readers and writers can access the text file appropriately and efficiently,
    without mishandling or corrupting the data that is included. A naive solution
    to this problem is to impose a lock on the text file so that it becomes a non-shareable
    resource; this means that only one thread (either a reader or a writer) can access
    (and potentially manipulate) the text file at any given time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Yet, this approach simply equates to a sequential program – if the shared resource
    can be utilized by only one thread at a given time, none of the processing time
    between different threads can be overlapped and, effectively, the execution becomes
    sequential. Therefore, this is not an optimal solution, as it is taking advantage
    of concurrent programming.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: One insight regarding the reader threads can lead to a more optimal solution
    to this problem – since readers simply read in the text file and do not alter
    the data in it, multiple readers can be allowed to access the text file simultaneously.
    Indeed, even if more than one reader is fetching data from the text file at the
    same time, the data is not being changed in any way, and the consistency and accuracy
    of the data are therefore maintained.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Following this approach, we will implement a specification in which no reader
    will be kept waiting if the shared resource is being opened for reading by another
    reader. Specifically, in addition to a lock on the shared resource, we will also
    have a counter for the number of readers currently accessing the resource. If
    at any point in the program that counter goes from zero to one (in other words,
    at least one reader is starting to access the resource), we will lock the resource
    from the writers; similarly, whenever the counter decreases to zero (in other
    words, no reader is asking for access to the resource), we will release the lock
    on the resource so that writers can access it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方法，我们将实现一个规范，即当共享资源被另一个读者打开用于读取时，不会让任何读者等待。具体来说，除了对共享资源的锁之外，我们还将有一个当前访问资源的读者数量的计数器。如果在程序的任何时刻，该计数器从零变为一（换句话说，至少有一个读者开始访问资源），我们将锁定资源以防止写者访问；同样，每当计数器减少到零（换句话说，没有读者请求访问资源），我们将释放对资源的锁，以便写者可以访问它。
- en: This specification is efficient for the readers in the sense that once the first
    reader has accessed the resource and placed a lock on it, no writers can access
    it, and the subsequent readers will not have to re-lock it until the last reader
    finishes reading the resource.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范对读者来说效率很高，因为一旦第一个读者访问了资源并对其加锁，就没有写者可以访问它，后续的读者也不必在最后一个读者完成读取资源之前重新锁定它。
- en: 'Let''s try to implement this solution in Python. If you have already downloaded
    the code for this book from the GitHub page, go ahead and navigate to the `Chapter13`
    folder. Let''s take a look at the `Chapter13/example1.py` file – specifically,
    the `writer()` and `reader()` functions, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用 Python 实现这个解决方案。如果你已经从 GitHub 页面下载了这本书的代码，请继续导航到 `Chapter13` 文件夹。让我们看一下
    `Chapter13/example1.py` 文件——特别是 `writer()` 和 `reader()` 函数，如下所示：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding script, the `writer()` function, which is to be called by a
    `threading.Thread` instance (in other words, a separate thread), specifies the
    logic of the writer threads that we discussed previously – accessing the shared
    resource (in this case, the global variable, `text`, which is simply a Python
    string) and writing some data to the resource. Note that we are putting all of
    its instructions inside a `while` loop to simulate the constant nature of the
    application (writers and readers constantly trying to access the shared resource).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，`writer()` 函数（它将由一个 `threading.Thread` 实例调用，换句话说，一个单独的线程）指定了我们之前讨论的写线程的逻辑——访问共享资源（在这种情况下，全局变量
    `text`，它只是一个 Python 字符串）并向资源写入一些数据。请注意，我们将所有指令都放在一个 `while` 循环中，以模拟应用程序的持续性质（写者和读者不断尝试访问共享资源）。
- en: We can also see the reader logic in the `reader()` function. Before asking for
    access to the shared resource, each reader will increment a counter for the number
    of readers that are currently active and trying to access the resource. Similarly,
    after reading data off the file, each reader needs to decrement the number of
    readers. During this process, if a reader is the first reader to access the file
    (in other words, when the counter is one), it will put a lock on the file so that
    no writers can access it; conversely, when a reader is the last reader to read
    the file, it has to release that lock.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `reader()` 函数中看到读者逻辑。在请求访问共享资源之前，每个读者都会增加一个当前活跃并尝试访问资源的读者数量的计数器。同样，在从文件读取数据之后，每个读者需要减少读者数量。在这个过程中，如果读者是第一个访问文件的读者（换句话说，当计数器为一时），它将锁定文件以防止写者访问；相反，当读者是最后一个读取文件的读者时，它必须释放那个锁。
- en: One note about the handling of that counter of readers – you might have noticed
    that we are using a lock object named `rcounter` when incrementing/decrementing
    the counter variable (`rcount`). This is a method that is used to avoid a race
    condition, which is another common concurrency-related problem, for the counter
    variable; specifically, without the lock, multiple threads can be accessing and
    altering the counter variable at the same time, but the only way to ensure the
    integrity of the data is for this counter variable to be handled sequentially.
    We will discuss race conditions (and the practice that is used to avoid them)
    in more detail in the next chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our current script – in the main program, we will set up the
    `text` variable, the counter for readers, and two lock objects (for the reader
    counter and the shared resource respectively). We are also initializing and starting
    three reader threads and two writer threads, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is important to note that, since the instructions of the reader and writer
    threads are both wrapped in `while` loops, the script, when started, will run
    infinitely. You should cancel the Python execution after around 3–4 seconds, when
    enough output has been produced so that the general behavior of the program can
    be observed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the first few lines of output that I obtained after
    running the script:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, there is a specific pattern in the preceding output – all of
    the threads that were accessing the shared resource were readers. In fact, throughout
    my entire output, no writer was able to access the file and, therefore, the `text`
    variable only contains the initial string, `This is some text.`, and was not altered
    in any way. The output that you obtain should also have the same pattern (the
    shared resource not being altered).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the writers are experiencing starvation, as none of them are able
    to access and use the resource. This is a direct result of our scheduling algorithm;
    since multiple readers are allowed to access the text file simultaneously, if
    there are multiple readers accessing the text file frequently enough, it will
    create a continuous stream of readers going through the text file, leaving no
    room for a writer to attempt to access the file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: This scheduling algorithm inadvertently gives priority to the readers over the
    writers and is therefore called **reader preference**. So, this design is undesirable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The second readers-writers problem
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem with the first approach is that when a reader is accessing the text
    file and a writer is waiting for the file to be unlocked, if another reader starts
    its execution and wants to access the file, it will be given priority over the
    writer that has already been waiting. Additionally, if more and more readers keep
    requesting access to the file, the writer will be waiting indefinitely, and that
    was what we observed in our first code example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: To address this problem, we will implement the specification that once a writer
    makes a request to access the file, no reader should be able to jump in line and
    access the file before that writer. To do this, we will have an additional lock
    object in our program to specify whether a writer is waiting for the file and,
    consequently, whether a reader thread can attempt to read the file; we will call
    this lock `read_try`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Similar to how the first of the readers accessing the text file always locks
    it from the writers, we will now have the first of the multiple writers that are
    waiting to access the `read_try` file lock, so that no reader can, again, jump
    in line before those writers that requested access before it. As we discussed
    in reference to the readers, since we are keeping track of the number of writers
    waiting for the text file, we will need to implement a counter for the number
    of writers, and its corresponding lock, in our program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Chapter13/example2.py` file contains the code for this implementation,
    as follows (note that the `reader()` function is being omitted in the text):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compared to our first solution to the problem, the main program remains relatively
    the same (except for the initialization of the `read_try` lock, the `wcount` counter,
    and its lock, `wcounter`), but in our `writer()` function, we are locking `read_try`
    as soon as there is at least one writer waiting to access the file; when the last
    writer finishes its execution, it will release the lock so that any reader waiting
    for the file can now access it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, to see the output produced by the program, we will have it run for 3–4
    seconds and then cancel the execution, as the program would otherwise run forever.
    The following is the output that I obtained via this script:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It can be observed that while some readers were able to access the text file
    (indicated by the first four lines of my output), once a writer gained access
    to the shared resource, no reader was able to access it anymore. The rest of my
    output included messages about writing instructions – `Writing being done by`,
    and so on. As opposed to what we saw in the first solution of the readers-writers
    problem, this solution is giving priority to writers, and, as a consequence, the
    readers are starved. This is therefore called **writer preference**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The priority that writers were given over readers resulted from the fact that
    while only the first and the last writers have to acquire and release the `read_try`
    lock respectively, each reader wanting to access the text file has to interact
    with that lock object individually. Once `read_try` is locked by a writer, no
    reader can even attempt to execute its instructions, let alone try to access the
    text file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: There are cases in which some readers are able to gain access to the text file
    if the readers are initialized and executed before the writers (for example, in
    our program, the readers were the first three elements, and the writers were the
    last two, in our list of threads). However, once a writer is able to access the
    file and acquire the `read_try` lock during its execution, starvation will most
    likely occur for the readers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: This solution is also not desirable, as it gives higher priority to the writer
    threads in our program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The third readers-writers problem
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have seen that both of the solutions that we tried to implement can result
    in starvation by not giving equal priorities to the separate threads; one can
    starve the writers, and the other can starve the readers. A balance between these
    two approaches might give us an implementation with equal priorities among the
    readers and writers, and, hence, solve the problem of starvation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Recall that – in our second approach, we placed a lock on a reader's attempt
    to access the text file, requiring that no writer would be starved once it started
    waiting for the file. In this solution, we will implement a lock that also utilizes
    this logic but is then applied to both readers and writers. All of the threads
    will then be subjected to the constraints of the lock, and equal priority will
    hence be achieved among the separate threads.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, this is a lock that specifies whether a thread will be given access
    to the text file at a given moment; we will call this the **service lock**. Each
    writer or reader has to try to acquire this service lock before executing any
    of its instructions. A writer, having obtained this service lock, will also attempt
    to obtain the resource lock and release the service lock immediately thereafter.
    The writer will then execute its writing logic and finally release the resource
    lock at the end of its execution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `writer()` function in the `Chapter13/example3.py`
    file for our implementation in Python, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On the other hand, a reader will also need to acquire the service lock first.
    Since we are still allowing multiple readers to access the resource at the same
    time, we are implementing the reader counter and its corresponding lock.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The reader will acquire the service lock and the counter lock, increment the
    reader counter (and, potentially, lock the resource), and then release the service
    lock and counter lock sequentially. Now, it will actually read data off the text
    file, and finally, it will decrement the reader counter and potentially release
    the resource lock if it is the last reader to access the file at that time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reader()` function contains the following specification:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, in our main program, we initialize the text string, the reader counter,
    all of the necessary locks, and the reader and writer threads, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that we are commenting the code that prints out the current content of
    the text file in the `reader()` function for readability for our output later
    on. Run the program for 3–4 seconds and then cancel it. The following output is
    what I obtained on my personal computer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The pattern that we have with this current output is that the readers and writers
    are able to access the shared resource cooperatively and efficiently; all of the
    readers and writers are executing their instructions, and no thread is being starved
    by this scheduling algorithm.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Note that as you work with a readers-writers problem in your concurrent program,
    you do not have to reinvent the wheel regarding the approaches that we just discussed.
    PyPI actually has an external library called `readerwriterlock` that contains
    the implementation of the three approaches in Python, as well as support for timeouts.
    Go to [https://pypi.org/project/readerwriterlock/](https://pypi.org/project/readerwriterlock/)
    to find out more about the library and its documentation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to starvation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through an analysis of different approaches to the readers-writers problem,
    you have seen the key to solving starvation – since some threads will be starved
    if they are not given a high priority in accessing the shared resources, implementing
    fairness in the execution of all of the threads will prevent starvation from occurring.
    Fairness, in this case, does not require a program to forgo any order or priority
    that it has imposed on the different threads; but to implement fairness, a program
    needs to ensure that all threads are given sufficient opportunities to execute
    their instructions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping this idea in mind, we can potentially address the problem of starvation
    by implementing one (or a combination) of the following approaches:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**Increasing the priority of low-priority threads**: As we did with the writer
    threads in the second approach and the reader threads in the third approach to
    the readers-writers problem, prioritizing the threads that would otherwise not
    have any opportunity to access the shared resource can successfully eliminate
    starvation.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First-in-first-out thread queue**: To ensure that a thread that started waiting
    for the shared resource before another thread will be able to acquire the resource
    before the other thread, we can keep track of the threads requesting access in
    a first-in-first-out queue.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other methods**: Several methods can also be implemented to balance the selection
    frequency of different threads – for example, a priority queue that also gives
    gradually increasing priority to threads that have been waiting in the queue for
    a long time, or if a thread has been able to access the shared resource many times,
    it will be given less priority.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving starvation in your concurrent program can be a rather complex and involved
    process, and a deep understanding of its scheduling algorithm, combined with an
    understanding of how processes and threads interact with the shared resources,
    is necessary during the process. As you saw in the example of the readers-writers
    problem, it can also take several implementations and revisions of different approaches
    to arrive at a good solution to starvation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered starvation and the specific situations in which
    it could occur by analyzing different instances of the readers-writers problem.
    We have gained insight into how starvation can be solved with different scheduling
    algorithms – by making sure that the priority is distributed appropriately among
    different processes and threads, starvation can be eliminated. These discussions
    will serve as a guide to solutions to real-life instances of starvation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the last of the three common problems of
    concurrent programming – **race conditions**. We will cover the basic foundation
    and causes of race conditions, relevant concepts, and the connection of race conditions
    to other concurrency-related problems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is starvation and why is it undesirable in a concurrent program?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the underlying causes of starvation? What are the common high-level
    causes of starvation that can manifest from the underlying causes?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the connection between deadlock and starvation?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the readers-writers problem?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the first approach to the readers-writers problem? Why does starvation
    arise in that situation?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the second approach to the readers-writers problem? Why does starvation
    arise in that situation?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the third approach to the readers-writers problem? Why does it successfully
    address starvation?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common solutions to starvation?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Parallel Programming with Python*, *Jan Palach*, *Packt Publishing Ltd*, *2014*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python Parallel Programming Cookbook*, *Giancarlo Zaccone*, *Packt Publishing
    Ltd*, *2015*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Starvation and Fairness*, *Jakob Jenkov* ([tutorials.jenkov.com/java-concurrency/starvation-and-fairness](http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness))'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Faster Fair Solution for the Reader-Writer Problem*, *V. Popov and O. Mazonka*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
