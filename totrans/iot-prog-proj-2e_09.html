<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer194">
<h1 class="chapter-number" id="_idParaDest-140"><a id="_idTextAnchor140"/>9</h1>
<h1 id="_idParaDest-141"><a id="_idTextAnchor141"/>Understanding LoRa</h1>
<p>In this chapter, we explore the world of <strong class="bold">LoRa</strong> (short for <strong class="bold">Long Range</strong>), a key technology in <a id="_idIndexMarker678"/>IoT communication. LoRa is known for transmitting data over extensive distances with minimal power. We will explore its practical applications in areas such as agriculture, where it enables efficient management of large-scale sensor networks, and urban settings, where it assists in smart city initiatives such as street <span class="No-Break">lighting control.</span></p>
<p>We will <a id="_idIndexMarker679"/>also investigate the <strong class="bold">radio frequency spectrum</strong> and understand how different frequencies are allocated for various wireless communications, allowing us to better comprehend the operational range of LoRa technology. By studying the frequency spectrum, we can identify which frequency bands are most suitable for <span class="No-Break">LoRa transmissions.</span></p>
<p>Our focus then shifts to the practical aspect: building a LoRa sensory transmitter and LoRa receiver using a Raspberry Pi Pico and Pico W, respectively. We’ll start with assembling the transmitter circuit by integrating an RFM95W LoRa module, a DHT22 temperature sensor, and a Raspberry Pi Pico. We will then house these components in a custom 3D-printed case. We’ll emphasize using the standard Raspberry Pi Pico for its efficiency in tasks that don’t require Wi-Fi, benefiting from its lower power consumption and reduced <span class="No-Break">firmware overhead.</span></p>
<p>For the receiver, we use a Raspberry Pi Pico W, focusing on its Wi-Fi capabilities for future developments. We’ll construct a custom case for the receiver, as with the transmitter, but with an LED for <span class="No-Break">status indication.</span></p>
<p>The development process includes setting up CircuitPython, installing necessary libraries, and writing the code for both the transmitter and receiver. CircuitPython is an open-source derivative of MicroPython, developed by Adafruit, designed to simplify coding for microcontrollers. In our code, we’ll use a delay between transmissions to adhere to European <span class="No-Break">duty-cycle limitations.</span></p>
<p>Finally, we will test our application outdoors, demonstrating LoRa’s impressive range capabilities as compared with the limited range <span class="No-Break">of Wi-Fi.</span></p>
<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li><span class="No-Break">Exploring LoRa</span></li>
<li>Building a LoRa <span class="No-Break">sensory transmitter</span></li>
<li>Building a <span class="No-Break">LoRa receiver</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor142"/>Technical requirements</h1>
<p>The following are the requirements for completing <span class="No-Break">this chapter:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming</span></li>
<li>1 x Raspberry Pi Pico WH (with headers) for development (may add headers to a Raspberry Pi Pico <span class="No-Break">W instead)</span></li>
<li>1 x Pico GPIO expander <span class="No-Break">for development</span></li>
<li>1 x Raspberry Pi Pico (for LoRa <span class="No-Break">sensory transmitter)</span></li>
<li>1 x Raspberry Pi Pico W (for <span class="No-Break">LoRa receiver)</span></li>
<li>2 x RFM95W <span class="No-Break">LoRa modules</span></li>
<li>1 x DHT22 temperature and <span class="No-Break">humidity sensor</span></li>
<li>1 x LED (<span class="No-Break">any color)</span></li>
<li>1 x 220 <span class="No-Break">Ohm resistor</span></li>
<li>4 x M3 10 <span class="No-Break">mm bolts</span></li>
<li>12 x M2 5 <span class="No-Break">mm screws</span></li>
<li>2 x M5 20 <span class="No-Break">mm bolts</span></li>
<li>2 x <span class="No-Break">M5 nuts</span></li>
<li>Hot <span class="No-Break">glue gun</span></li>
<li>Access to a 3D printer or 3D printer service to print <span class="No-Break">custom cases</span></li>
<li>Build files for custom cases may be found in our <span class="No-Break">GitHub repository</span></li>
</ul>
<p>The code and build files for this chapter may be <span class="No-Break">found here:</span></p>
<p><a href="https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter9"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter9</span></a></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor143"/>Exploring LoRa</h1>
<p>LoRa is a wireless communication technology known for its ability to transmit data over long distances <a id="_idIndexMarker680"/>while consuming very little power. It has become increasingly significant in the field of IoT due to its efficiency and reliability in various environments. Originating as a solution for extending the range of wireless communications, LoRa technology has evolved to play a pivotal role in connecting a wide array of <span class="No-Break">IoT devices.</span></p>
<p>In the following sections, we will look at the practical uses of LoRa before we explore the frequency spectrum and how it relates <span class="No-Break">to LoRa.</span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor144"/>Practical uses for LoRa technology</h2>
<p>LoRa technology is instrumental in areas such as agriculture, enabling farmers to deploy sensory <a id="_idIndexMarker681"/>networks for monitoring soil moisture, temperature, and other vital parameters over large areas, enhancing crop management and <span class="No-Break">resource efficiency.</span></p>
<p><strong class="bold">LoRa nodes</strong> offer a <a id="_idIndexMarker682"/>cost-effective solution for modernizing agricultural <a id="_idIndexMarker683"/>practices, contrasting with costlier alternatives such as <strong class="bold">Long Term Evolution</strong> (<strong class="bold">LTE</strong>)-based systems or extensive wired sensor networks. While LTE supports more data-intensive applications, its higher power requirements and operational costs can <span class="No-Break">be prohibitive.</span></p>
<p>In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em>, we see an AI-generated image of LoRa nodes used to measure soil and weather conditions for a <span class="No-Break">modern farm:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer168">
<img alt="Figure 9.1 – Modern farm using LoRa technology" height="790" src="image/B21282_09_01.jpg" width="1407"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Modern farm using LoRa technology</p>
<p>In urban <a id="_idIndexMarker684"/>environments, LoRa may be used to manage smart city applications such as street lighting. In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.2</em>, we see a smart light post used in an urban environment. In this setting, control of the light is determined by a central office with a LoRa message sent to the light post to turn it on or off or control <span class="No-Break">its brightness:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer169">
<img alt="Figure 9.2 – Smart light post using LoRa messages for control" height="389" src="image/B21282_09_02.jpg" width="1248"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Smart light post using LoRa messages for control</p>
<p>This method <a id="_idIndexMarker685"/>of control is beneficial as it allows for remote management of lighting based on real-time data and needs, such as adjusting brightness according to traffic conditions or time <span class="No-Break">of day.</span></p>
<p>To better understand the application of LoRa communication technology, let’s examine the radio frequency spectrum it uses, focusing on how different frequencies cater to various application needs <span class="No-Break">and scenarios.</span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor145"/>Investigating the radio frequency spectrum</h2>
<p>The radio frequency spectrum is used for various wireless communications, including television <a id="_idIndexMarker686"/>broadcasting, mobile data, satellite, and IoT technologies such as LoRa. Frequencies are allocated <a id="_idIndexMarker687"/>for specific uses to avoid interference and optimize communication efficiency. <strong class="bold">Ultra high frequency</strong> (<strong class="bold">UHF</strong>) bands, for example, are commonly used for television broadcasting, mobile phones, and Wi-Fi. Each frequency band has unique characteristics such as propagation range and penetration ability, making them suitable for <span class="No-Break">specific applications.</span></p>
<p>In general, lower frequencies, characterized by their longer wavelengths, can travel greater distances and are more effective at penetrating obstacles compared to higher frequencies. Conversely, higher frequencies, while having shorter wavelengths, possess the ability to carry more data due to their larger bandwidth. These characteristics are crucial in determining the suitable frequency band for different types <span class="No-Break">of communication.</span></p>
<p>A common example of the effectiveness of the penetration of low frequencies is how we often hear the bass, or lower frequencies, from music playing loudly inside a club when we are outside, but not higher frequencies, as lower frequencies are better at penetrating the walls of the club. This ability to penetrate through objects makes lower frequencies especially useful for communications that need to cover larger areas or pass through <a id="_idIndexMarker688"/>obstructions. For instance, lower frequency bands such as those used in AM radio can cover vast geographical areas, while higher frequencies, despite offering more bandwidth, have a shorter range <a id="_idIndexMarker689"/>and are more suited to urban settings with <strong class="bold">Line-Of-Sight</strong> (<strong class="bold">LOS</strong>) communication. Higher frequencies are desirable for technologies such as cell phone communication because they can carry more data, providing greater capacity for voice and data transmission. In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.3</em>, we see an illustration of the frequency spectrum used for wireless communications and associated technologies that operate in <span class="No-Break">specific ranges:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer170">
<img alt="Figure 9.3 – The frequency spectrum for wireless communications" height="350" src="image/B21282_09_03.jpg" width="1210"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The frequency spectrum for wireless communications</p>
<p>LoRa operates in the unlicensed frequency range of 867-869 MHz in Europe, 902-928 MHz in North America, and 915-928 MHz in Australia (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em>). These frequencies are chosen for their balance of range and penetration, ideal for the low-power, long-range communication that <span class="No-Break">LoRa enables.</span></p>
<p>The specific frequency bands can vary within the ranges shown in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em> based on national regulations. We should always check local regulations to ensure compliance with the specific <span class="No-Break">frequencies allowed:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer171">
<img alt="Figure 9.4 – LoRa frequencies based on location" height="720" src="image/B21282_09_04.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – LoRa frequencies based on location</p>
<p>The use <a id="_idIndexMarker690"/>of unlicensed bands comes with regulatory limitations to ensure fair usage and minimize interference. In Europe, the 868 MHz band is subject to a duty-cycle limitation of 1%, restricting transmission time. In North America, the 915 MHz band has dwell-time restrictions, limiting the occupancy time of a signal on <span class="No-Break">a channel.</span></p>
<p>These limitations encourage efficient spectrum use and innovative communication protocol development, as seen in LoRa’s effectiveness within these frameworks. We will consider these limitations when we start writing LoRa code in the upcoming section, <em class="italic">Building a LoRa </em><span class="No-Break"><em class="italic">sensory transmitter</em></span><span class="No-Break">.</span></p>
<p>Now that we have a basic understanding of the frequency spectrum and LoRa’s position within it, let’s <a id="_idIndexMarker691"/>explore the <strong class="bold">Spreading Factor</strong> (<strong class="bold">SF</strong>), a key parameter in LoRa that impacts the network’s range, data rate, and <span class="No-Break">power efficiency.</span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor146"/>Understanding the LoRa SF</h2>
<p>LoRa employs <strong class="bold">Chirp Spread Spectrum</strong> (<strong class="bold">CSS</strong>) technology, where signals vary in frequency <a id="_idIndexMarker692"/>over time to encode data. This technique boosts signal reliability and minimizes power consumption, making it ideal for IoT devices that <a id="_idIndexMarker693"/>operate over extended periods. The use of a broad frequency range in LoRa enables devices to maintain connectivity over long distances while consuming less power. In this process, data transmission involves changing the signal’s frequency across a wide spectrum, significantly enhancing its resistance to interference <span class="No-Break">and noise.</span></p>
<p>Complementing this, LoRa’s SF, a key parameter in LoRa communication, ranges from <strong class="source-inline">SF7</strong> to <strong class="source-inline">SF12</strong>. The SF determines the duration of each symbol (data packet) transmission, essentially balancing transmission range and data rate. Higher SFs, such as <strong class="source-inline">SF12</strong>, extend the range but reduce the data rate, making them suitable for long-distance communication. In contrast, lower SFs such as <strong class="source-inline">SF7</strong> offer faster data rates over shorter distances. This flexibility allows LoRa to cater to a wide array of use cases, from densely populated urban areas in smart cities to remote areas requiring <span class="No-Break">long-range monitoring.</span></p>
<p>In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.5</em>, we see the SF illustrated in an <span class="No-Break">agricultural setting:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer172">
<img alt="Figure 9.5 – SF illustrated in an agricultural setting" height="628" src="image/B21282_09_05.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – SF illustrated in an agricultural setting</p>
<p>The range <a id="_idIndexMarker694"/>increases with the SF number, but higher SFs also require more power due to extended transmission times. For effective communication, it’s essential that both the sender and receiver are configured with the <span class="No-Break">same SF.</span></p>
<p>Now that we’ve explored LoRa communication technology, let’s incorporate what we’ve learned into the Raspberry Pi Pico and <span class="No-Break">Pico W.</span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor147"/>Using LoRa with the Raspberry Pi Pico and Pico W</h2>
<p>In this <a id="_idIndexMarker695"/>chapter, we will develop both a LoRa <a id="_idIndexMarker696"/>sensory transmitter and a LoRa receiver. Our <a id="_idIndexMarker697"/>LoRa sensory transmitter <a id="_idIndexMarker698"/>will utilize the Raspberry Pi Pico, a DHT22 temperature sensor, and an RFM95W LoRa module. Our LoRa receiver will use a Raspberry Pi Pico W, an LED, and an RFM95W LoRa module. We may see our application outlined in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer173">
<img alt="Figure 9.6 – LoRa sensory transmitter and LoRa receiver" height="600" src="image/B21282_09_06.jpg" width="1621"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – LoRa sensory transmitter and LoRa receiver</p>
<p>We will <a id="_idIndexMarker699"/>begin creating our application by building <a id="_idIndexMarker700"/>a LoRa sensory transmitter. We <a id="_idIndexMarker701"/>will start with wiring up <a id="_idIndexMarker702"/>an RFM95W LoRa module to a Raspberry Pi Pico before we move on to installing the temperature sensor in a test circuit. Finally, we will install the components into a custom <span class="No-Break">3D-printed case.</span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor148"/>Building a LoRa sensory transmitter</h1>
<p>In this section, we will build a LoRa sensory transmitter with a temperature sensor using a Raspberry Pi Pico, an RFM95W LoRa module, and a DHT22 temperature sensor. Our goal is to <a id="_idIndexMarker703"/>create a device that reads temperature and humidity data from a DHT22 temperature sensor and transmits this information using the RFM95W LoRa module. We will use the Raspberry Pi Pico and not Pico W for our design, although we could just as easily swap out the Pico for the <span class="No-Break">Pico W.</span></p>
<p>For building and testing our circuit, we will use a Raspberry Pi Pico WH installed on a Pico GPIO expander. Using a Pico WH allows us to build and test circuits for both Pico and Pico W applications. We will use Pico W for the receiver part of our application and not the Pico WH due to <span class="No-Break">size constraints.</span></p>
<p class="callout-heading">Advantages of using a standard Pico over a Pico W</p>
<p class="callout">Besides its cost advantage, the Raspberry Pi Pico offers benefits over the Raspberry Pi Pico W for our LoRa sensory transmitter. The standard Pico, known for its lower power consumption, is well-suited for tasks that don’t require Wi-Fi. Its simpler design leads to reduced firmware overhead, allowing the device to focus its resources on specific tasks rather than managing <span class="No-Break">Wi-Fi connectivity.</span></p>
<p>We’ll also <a id="_idIndexMarker704"/>build a custom case to house our components. This case will not only offer protection but will also ensure organized wiring and enhance the overall durability and portability of our LoRa sensory transmitter. We will start off by adding wires to the RFM95W LoRa module and wiring it up to our Raspberry Pi Pico WH for development. We will later replace the Pico WH with a Pico as we install our components into a <span class="No-Break">custom case.</span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor149"/>Constructing our circuit</h2>
<p>The RFM95W is a compact LoRa module favored for its long-range capabilities and low power <a id="_idIndexMarker705"/>consumption. Designed for sub-GHz frequency operation, it’s well-suited for applications that demand efficient, long-distance <a id="_idIndexMarker706"/>wireless communication. Despite its small size, the RFM95W excels in covering greater distances than conventional wireless technologies, making it particularly effective in <span class="No-Break">open environments.</span></p>
<p>We will start by soldering jumper wires onto <span class="No-Break">the RFM95W.</span></p>
<h3>Adding wires to the RFM95W</h3>
<p>Measuring only 16 mm by 16 mm, the RFM95W module is tiny. Care must be taken when <a id="_idIndexMarker707"/>soldering the jumper wires to the holes of the RFM95W. This is not a soldering job for someone first learning <span class="No-Break">to solder.</span></p>
<p>In <em class="italic">Step 1</em> of <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.7</em>, we see the RFM95W prior to adding our jumper wires. The type of jumper wires we add depends on the breadboarding option we choose. For example, in this case, we are adding female jumper wires (<em class="italic">Step 2</em> of <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.7</em>) as we will be using a GPIO expander for our Raspberry Pi <span class="No-Break">Pico WH:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer174">
<img alt="Figure 9.7 – Adding wires to the RFM95W" height="765" src="image/B21282_09_07.jpg" width="1468"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Adding wires to the RFM95W</p>
<div>
<div class="IMG---Figure" id="_idContainer175">
<img alt="Figure 9.8 – RFM95W pins for wiring" height="887" src="image/B21282_09_08.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – RFM95W pins for wiring</p>
<p>We do <a id="_idIndexMarker708"/>not need to solder wires to every terminal of the RFM95W. In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.8</em>, we outline the terminals that we require jumper wires for and the length of <span class="No-Break">wire needed:</span></p>
<p>Our table illustrates that the length of the wire used for our antenna differs based on the specific frequency model of the RFM95W LoRa module we choose. To account for this variation, we’ve designed different versions of our custom case to accommodate <span class="No-Break">each model.</span></p>
<p>Each case version incorporates a straight antenna wire enclosure, effectively creating a built-in antenna specifically tailored for the respective frequency. This aspect of the design is particularly appealing for those of us who have encountered issues with low-cost antennas that don’t accurately match their <span class="No-Break">labeled frequencies.</span></p>
<p class="callout-heading">Adafruit RFM95W LoRa Radio Transceiver Breakout</p>
<p class="callout">For <a id="_idIndexMarker709"/>those of us who wish to work with a LoRa board that is larger than the standard RFM95W, the Adafruit RFM95W LoRa Radio Transceiver Breakout is a great option. Unlike our RFM95W, this board is breadboard-friendly, using <span class="No-Break">header pins.</span></p>
<p>To reinforce <a id="_idIndexMarker710"/>the soldered connections of the jumpers on our RFM95W, we can apply glue from a hot glue gun, as detailed in <em class="italic">Step 3</em> of <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.7</em>. We use these jumpers to plug the module into the Raspberry Pi Pico WH GPIO expander for initial testing <span class="No-Break">and prototyping.</span></p>
<h3>Assembling our circuit</h3>
<p>With the jumper wires soldered to our RFM95W model, we may now construct our circuit <a id="_idIndexMarker711"/>on a Raspberry Pi Pico GPIO expander. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.9</em> illustrates a wiring diagram for the Raspberry Pi Pico, Raspberry Pi Pico WH, and the RFM95W <span class="No-Break">LoRa module:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer176">
<img alt="Figure 9.9 – Wiring the RFM95W module to the Raspberry Pi Pico" height="379" src="image/B21282_09_09.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Wiring the RFM95W module to the Raspberry Pi Pico</p>
<p>To complete our circuit, we add a DHT22 temperature sensor to our circuit using the wiring diagram in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer177">
<img alt="Figure 9.10 – Wiring up a DHT22 to the Raspberry Pi Pico (WH)" height="572" src="image/B21282_09_10.jpg" width="1049"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Wiring up a DHT22 to the Raspberry Pi Pico (WH)</p>
<p>In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.11</em> (<em class="italic">A</em>), we get a practical view of our circuit layout using a Raspberry Pi Pico with a GPIO <a id="_idIndexMarker712"/>expander (before the DHT22 is added). In our example, we’re utilizing a Raspberry Pi Pico WH and the GPIO expander for circuit construction <span class="No-Break">and testing:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer178">
<img alt="Figure 9.11 – Raspberry Pi Pico WH with GPIO expander and RFM95W LoRa module" height="705" src="image/B21282_09_11.jpg" width="1471"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Raspberry Pi Pico WH with GPIO expander and RFM95W LoRa module</p>
<p>We can see a table with the wire connections in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.11</em> (<em class="italic">B</em>) and what our Raspberry Pi Pico and RFM95W will look like wired together in the case in <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">9</em></span><span class="No-Break"><em class="italic">.11 </em></span><span class="No-Break">(</span><span class="No-Break"><em class="italic">C</em></span><span class="No-Break">).</span></p>
<p>With our <a id="_idIndexMarker713"/>circuit wired up, we are now ready to write our code to send temperature and humidity data through LoRa. We will use Thonny as our development environment and the <span class="No-Break">CircuitPython firmware.</span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor150"/>Developing the code</h2>
<p>For our application, we will use <strong class="bold">CircuitPython</strong> over <strong class="bold">MicroPython</strong> due to several key differences <a id="_idIndexMarker714"/>between these Python implementations. CircuitPython, a derivative <a id="_idIndexMarker715"/>of MicroPython developed by Adafruit, offers a <a id="_idIndexMarker716"/>more streamlined experience for specific use cases, particularly with its comprehensive <span class="No-Break">library support.</span></p>
<p>We will start our development by installing the CircuitPython firmware onto our Raspberry Pi <span class="No-Break">Pico WH.</span></p>
<h3>Setting up CircuitPython and sensor libraries</h3>
<p>We develop our application for the Raspberry Pi Pico (WH) using the Thonny IDE, a tool that’s <a id="_idIndexMarker717"/>compatible with various development <a id="_idIndexMarker718"/>environments such as Raspberry Pi, Windows, Linux, and macOS. For our example, we are using Thonny <span class="No-Break">on Windows.</span></p>
<p>In terms of setting up the Raspberry Pi Pico (WH), the installation of CircuitPython via Thonny is a straightforward process, like how we would <span class="No-Break">install MicroPython.</span></p>
<p>To install CircuitPython on our Raspberry Pi Pico (WH), we do <span class="No-Break">the following:</span></p>
<ol>
<li>If Thonny is not available on our operating system, we visit the Thonny website and download an appropriate <span class="No-Break">version (</span><a href="https://thonny.org"><span class="No-Break">https://thonny.org</span></a><span class="No-Break">).</span></li>
<li>We then launch Thonny using the appropriate method for our <span class="No-Break">operating system.</span></li>
<li>While holding the <em class="italic">BOOTSEL</em> button on the Pico (WH), the small white button near the USB port, we insert it into an available USB port and disregard any pop-up windows that <span class="No-Break">may appear:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer179">
<img alt="Figure 9. 12 – BOOTSEL button as shown on a Pico WH (Pico similar)" height="171" src="image/B21282_09_12.jpg" width="650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9. 12 – BOOTSEL button as shown on a Pico WH (Pico similar)</p>
<ol>
<li value="4">We then <a id="_idIndexMarker719"/>click on the interpreter <a id="_idIndexMarker720"/>information at the bottom right-hand side of the screen and select <span class="No-Break"><strong class="bold">Install CircuitPython…</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer180">
<img alt="Figure 9.13 – Install CircuitPython… option" height="140" src="image/B21282_09_13.jpg" width="794"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Install CircuitPython… option</p>
<ol>
<li value="5">For <strong class="bold">Target volume</strong>, we select our Pico WH (<strong class="source-inline">RPI-RP2 (D:)</strong>). In our example, we select the <strong class="bold">Raspberry Pi • Pico  / Pico H</strong> CircuitPython variant and the <span class="No-Break">latest version:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer181">
<img alt="Figure 9.14 – Installing MicroPython on the Raspberry Pi Pico W" height="537" src="image/B21282_09_14.jpg" width="586"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Installing MicroPython on the Raspberry Pi Pico W</p>
<ol>
<li value="6">Even though <a id="_idIndexMarker721"/>we are developing <a id="_idIndexMarker722"/>on a Pico WH, we treat it as a Pico for development purposes. We click on the <strong class="bold">Install</strong> button and then the <strong class="bold">Close</strong> button once the installation <span class="No-Break">has completed.</span></li>
<li>To have Thonny configured to run the CircuitPython interpreter on our Pico (WH), we select it from the bottom right-hand side of <span class="No-Break">the screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer182">
<img alt="Figure 9.15 – Selecting the CircuitPython interpreter" height="106" src="image/B21282_09_15.jpg" width="729"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Selecting the CircuitPython interpreter</p>
<ol>
<li value="8">We confirm that Thonny is using the CircuitPython interpreter on our Raspberry Pi Pico (WH) by checking <span class="No-Break">the </span><span class="No-Break"><strong class="bold">Shell</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer183">
<img alt="Figure 9.16 – CircuitPython prompt in Thonny" height="232" src="image/B21282_09_16.jpg" width="937"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – CircuitPython prompt in Thonny</p>
<p>With CircuitPython installed, we are now ready to install the libraries we need for our code. This <a id="_idIndexMarker723"/>involves downloading the package <a id="_idIndexMarker724"/>from the Adafruit website and copying over the library files we need to our Raspberry Pi <span class="No-Break">Pico (WH).</span></p>
<p>To do this, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Using a web browser, we navigate to the following <span class="No-Break">URL: </span><a href="https://circuitpython.org/libraries"><span class="No-Break">https://circuitpython.org/libraries</span></a><span class="No-Break">.</span></li>
<li>As we are using CircuitPython 8, we download the <strong class="source-inline">adafruit-circuitpython-bundle-8.x-mpy-20231205.zip</strong> ZIP file and unzip it to a location on <span class="No-Break">our computer.</span></li>
<li>The two files we are interested in are <strong class="source-inline">adafruit_rfm9x.mpy</strong> and <strong class="source-inline">adafruit_dht.mpy</strong>, both of which may be found in the <strong class="source-inline">lib</strong> folder in the unzipped directory. These files are library files for our RFM95W and DHT22 sensors respectively. To install these libraries onto our Raspberry Pi Pico (WH) from Thonny, we locate them in the <strong class="bold">Files</strong> section and right-click to get the <span class="No-Break">following dialog:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer184">
<img alt="Figure 9.17 – Uploading a library file to the Raspberry Pi Pico (WH)" height="680" src="image/B21282_09_17.jpg" width="518"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Uploading a library file to the Raspberry Pi Pico (WH)</p>
<ol>
<li value="4">We must <a id="_idIndexMarker725"/>ensure that we upload <a id="_idIndexMarker726"/>these libraries to the <strong class="source-inline">lib</strong> folder on our Pico (WH) and not the root directory. This would involve double-clicking on the <strong class="source-inline">lib</strong> folder under the <strong class="bold">CircuitPython device</strong> section in Thonny to open it. After uploading the libraries to the Pico (WH), the file structure on our Pico (WH) should look like <span class="No-Break">the following:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer185">
<img alt="Figure 9.18 – Pico file structure after uploading libraries" height="248" src="image/B21282_09_18.jpg" width="776"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Pico file structure after uploading libraries</p>
<p>With our circuit built and CircuitPython and the libraries installed, it is time to write our code. As we will see, we do not require a great amount of code to send temperature and humidity data <span class="No-Break">through LoRa.</span></p>
<h3>Creating LoRa transmission code</h3>
<p>To comply with different regulatory standards, we’ll use a delay for our LoRa transmissions. While Europe’s 1% duty-cycle limit allows for a 99-second delay between messages, we’ll <a id="_idIndexMarker727"/>extend this to 120 seconds, due to the stable nature of temperature and humidity data. This will result in a duty cycle of <span class="No-Break">approximately 0.83%.</span></p>
<p>Although North <a id="_idIndexMarker728"/>America’s regulations focus on dwell time, the period a transmitter occupies a frequency channel rather than a duty cycle, we’re adopting this duty-cycle approach for uniformity. We will use the 915 MHz frequency version of the RFM95W for our application as the author is based in <span class="No-Break">North America.</span></p>
<p>To write our LoRa transmission code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico (WH) to a USB port and launch Thonny. We may use our Raspberry Pi or another operating system for this. In our example, we are using Thonny <span class="No-Break">on Windows.</span></li>
<li>We then activate the CircuitPython environment on our Pico (WH) by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>In a new tab, we enter the <span class="No-Break">following code:</span><pre class="source-code">
import time
import board
import busio
import digitalio
import adafruit_rfm9x
import adafruit_dht
spi = busio.SPI(board.GP18, MOSI=board.GP19, MISO=board.GP16)
cs = digitalio.DigitalInOut(board.GP17)
rst = digitalio.DigitalInOut(board.GP14)
rfm9x = adafruit_rfm9x.RFM9x(spi, cs, rst, 915.0)
dht_sensor = adafruit_dht.DHT22(board.GP4)
print("Sending temperature and humidity data every 120 seconds")
while True:
    try:
        temperature = dht_sensor.temperature
        humidity = dht_sensor.humidity
        data = f"Temp: {temperature}C, Humidity: {humidity}%"
        rfm9x.send(bytes(data, "utf-8"))
        print("Sent:", data)
    except RuntimeError as e:
        print("DHT22 read error:", e)
    time.sleep(120)</pre><p class="list-inset">In our code, we do <span class="No-Break">the following:</span></p><ol><li class="upper-roman"><strong class="bold">We start by importing the necessary libraries</strong>: We import <strong class="source-inline">time</strong>, <strong class="source-inline">board</strong>, <strong class="source-inline">busio</strong>, <strong class="source-inline">digitalio</strong>, <strong class="source-inline">adafruit_rfm9x</strong> (for LoRa communication), and <strong class="source-inline">adafruit_dht</strong> (for the <span class="No-Break">DHT22 sensor).</span></li><li class="upper-roman"><strong class="bold">We then set up SPI communication</strong>: We configure SPI with specific GPIO pins (GP18, GP19, GP16) for the RFM95W <span class="No-Break">LoRa module.</span></li><li class="upper-roman"><strong class="bold">We initialize Chip Select (CS) and Reset (RST) pins</strong>: We set up digital I/O for CS (GP17) and RST (<span class="No-Break">GP14) pins.</span></li><li class="upper-roman"><strong class="bold">We then create an RFM95W LoRa object</strong>: We initialize the RFM9x object for <a id="_idIndexMarker729"/>LoRa communication <a id="_idIndexMarker730"/>at 915.0 MHz. This value should be set based on <span class="No-Break">local regulations.</span></li><li class="upper-roman"><strong class="bold">We initialize the DHT22 sensor</strong>: We set up the DHT22 temperature and humidity sensor on GPIO <span class="No-Break">4 (GP4).</span></li><li class="upper-roman"><strong class="bold">We then print a status message</strong>: We indicate that temperature and humidity data will be sent every <span class="No-Break">120 seconds.</span></li><li class="upper-roman"><strong class="bold">We continuously send data</strong>: In an infinite loop, we read temperature and humidity from the DHT22 sensor, format the data, and send it over LoRa. If a read error occurs, we print an <span class="No-Break">error message.</span></li><li class="upper-roman"><strong class="bold">We then delay between transmissions</strong>: We wait for 120 seconds before sending the next set <span class="No-Break">of data.</span></li></ol></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. This will open the <span class="No-Break">following dialog:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer186">
<img alt="Figure 9.19 – Saving a file to our Raspberry Pi Pico (WH)" height="246" src="image/B21282_09_19.jpg" width="867"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Saving a file to our Raspberry Pi Pico (WH)</p>
<ol>
<li value="5">In this dialog, we are given the option to choose where to store our file. To save it on our Raspberry Pi Pico (WH), we click on the <span class="No-Break">corresponding button.</span></li>
<li>We then <a id="_idIndexMarker731"/>give the file the <a id="_idIndexMarker732"/>name <strong class="source-inline">code.py</strong> and click <strong class="bold">OK</strong>. In the CircuitPython environment, the name <strong class="source-inline">code.py</strong> is special because the system automatically executes this file upon startup or reset, making it the default script that runs when the device <span class="No-Break">powers up.</span></li>
</ol>
<p class="callout-heading">What SF are we using?</p>
<p class="callout">In our code, we don’t explicitly set the SF, so the <strong class="source-inline">adafruit_rfm9x</strong> library’s default is used. Typically, this is an SF of <strong class="source-inline">7</strong>. Since we’re using the default SF for both <strong class="source-inline">transmit</strong> and <strong class="source-inline">receive</strong> nodes, there’s no need to focus on this setting in <span class="No-Break">our application.</span></p>
<ol>
<li value="7">To run our code, we click on the green run button, hit <em class="italic">F5</em> on the keyboard, or click on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>In the <strong class="bold">Shell</strong>, we’ll see a notification confirming the creation of a LoRa message containing temperature and <span class="No-Break">humidity data:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer187">
<img alt="Figure 9.20 – LoRa message notification" height="205" src="image/B21282_09_20.jpg" width="1018"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – LoRa message notification</p>
<p>To recap, we have just created a LoRa sensory transmitter that sends temperature and humidity <a id="_idIndexMarker733"/>sensory data wirelessly. In the absence of errors, it’s reasonable to assume successful transmission of our LoRa <a id="_idIndexMarker734"/>message. However, without a LoRa receiver, we can’t confirm this. We’ll address this by building one in the next section. Before constructing the receiver, we’ll first house our components in a custom <span class="No-Break">3D-printed case.</span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor151"/>Installing the components in a custom case</h2>
<p>Continuing our practice from previous projects, we’ll install our components in a custom case. This <a id="_idIndexMarker735"/>approach allows convenient placement of our LoRa sensory transmitter wherever it’s needed. We can see the custom case for our LoRa sensory transmitter displayed in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.21</em></span><span class="No-Break">.</span></p>
<p>The design of our custom case accommodates the DHT22 sensor, allowing it to extend from the front for accurate temperature and humidity readings. The antenna, a straight wire soldered to the RFM95W module, is housed in a protruding section attached to the base plate of the case. An antenna cover specifically designed for this purpose completes the enclosure, protecting and isolating the antenna. The 915 MHz version of the custom case is displayed in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.21</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<img alt="Figure 9.21 – Custom case used for our LoRa transmitter node" height="631" src="image/B21282_09_21.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – Custom case used for our LoRa transmitter node</p>
<p>Our custom case is designed with a versatile GoPro-style hook at the back, enabling compatibility <a id="_idIndexMarker736"/>with various stands we’ve constructed in earlier chapters of the book. This feature allows for easy and flexible mounting of our LoRa <span class="No-Break">sensory transmitter.</span></p>
<p>The micro-USB port on the Raspberry Pi Pico is exposed, allowing us to provide power to our device. We may also use this port to program our Raspberry <span class="No-Break">Pi Pico.</span></p>
<p class="callout-heading">Using power banks for our Raspberry Pi Pico</p>
<p class="callout">We can power our node remotely using a standard cell phone power bank. However, it’s important to select a power bank that doesn’t automatically shut off due to low power draw, as the Raspberry Pi Pico has minimal <span class="No-Break">power requirements.</span></p>
<p>We will start the construction of our custom case by identifying <span class="No-Break">the parts.</span></p>
<h3>Identifying the parts of our custom LoRa case</h3>
<p>Our custom case features 3D-printed parts that screw together. We may see the parts and major components displayed in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.22</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer189">
<img alt="Figure 9.22 – Parts for custom case" height="666" src="image/B21282_09_22.jpg" width="1134"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – Parts for custom case</p>
<p>Let’s <a id="_idIndexMarker737"/>break down <span class="No-Break">each part:</span></p>
<ul>
<li>Raspberry Pi Pico (<em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>): We use the header-less version of the Raspberry Pi Pico due to <span class="No-Break">space constraints.</span></li>
<li>Backplate (<em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>): The backplate secures both the Raspberry Pi Pico and the RFM95W LoRa module. The length of the extension for the antenna is based on the frequency model used. In this example, we see the 915 <span class="No-Break">MHz model.</span></li>
<li>Antenna cover (<em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>): The antenna cover is used to enclose the wire antenna with the back <span class="No-Break">plate (</span><span class="No-Break"><em class="italic">B</em></span><span class="No-Break">).</span></li>
<li>Front shell (<em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>): The front shell holds the DHT22 sensor and encloses the back plate (<em class="italic">B</em>) to complete <span class="No-Break">the case.</span></li>
<li>DHT22 temperature and humidity sensor (<em class="italic">E</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.22</em></span><span class="No-Break">).</span></li>
<li>RFM95W LoRa module (<em class="italic">F</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>): The version shown is the 915 <span class="No-Break">MHz model.</span></li>
<li>Hook (<em class="italic">G</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.22</em></span><span class="No-Break">).</span></li>
<li>2 x M3 10 mm bolts (<span class="No-Break">not shown).</span></li>
<li>4 x M2 5 mm screws (<span class="No-Break">not shown).</span></li>
</ul>
<p>With the <a id="_idIndexMarker738"/>parts identified, it is now time to assemble our <span class="No-Break">custom case.</span></p>
<h3>Building the custom LoRa case</h3>
<p>To build <a id="_idIndexMarker739"/>the custom case, we follow the steps shown in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.23</em> and <span class="No-Break">outlined next:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer190">
<img alt="Figure 9.23 – Steps to build custom case" height="680" src="image/B21282_09_23.jpg" width="1209"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – Steps to build custom case</p>
<ol>
<li>We start by securing the hook (<em class="italic">G</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>) to the back plate (<em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>) using either epoxy glue or two M2 5 mm screws (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 1</em></span><span class="No-Break">).</span></li>
<li>Using the wiring diagrams from <em class="italic">Figures 9.9</em> and <em class="italic">9.10</em>, we solder the wires from the RFM95W and DHT11 sensors to the Raspberry <span class="No-Break">Pi Pico.</span></li>
<li>Using four M2 5 mm screws, we secure the Raspberry Pi Pico (<em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>) to the back plate (<em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>) such that the USB port is facing down and pointing toward the bottom of the back plate or away from the antenna (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 2</em></span><span class="No-Break">).</span></li>
<li>Using a hot glue gun, we secure the DHT22 (<em class="italic">E</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>) to the front shell (<em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>). Alternatively, two M3 5 mm bolts may be used depending on the holes present on the DHT22 (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 3</em></span><span class="No-Break">).</span></li>
<li>We friction <a id="_idIndexMarker740"/>fit the RFM95W (<em class="italic">F</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>) to the back plate (<em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>) such that the antenna wire sits next to the wire slot on the back plate and extends through (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.23</em>, <em class="italic">Step 3</em>). If the RFM95W does not stay in place, glue from a hot glue gun may be used to secure it <span class="No-Break">in place.</span></li>
<li>Using two M3 10 mm, bolts we secure the back plate to the front shell (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.23</em>, <span class="No-Break"><em class="italic">Step 4</em></span><span class="No-Break">).</span></li>
<li>We secure the antenna cover (<em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.22</em>) to the front of the back plate using two M2 5 <span class="No-Break">mm screws.</span></li>
</ol>
<p>As we used a separate Raspberry Pi Pico WH for writing our coding, we’ll need to install CircuitPython, the necessary libraries, and our code onto the new Pico. Testing the code with Thonny is advisable to check for any issues that might arise during the installation of components into the <span class="No-Break">custom case.</span></p>
<p>Now that our LoRa sensory transmitter is ready, we’ll proceed to construct a LoRa receiver. This device will be responsible for receiving sensory information from the transmitter. We’ll keep the receiver design simple, with its primary function being to acknowledge the receipt of LoRa messages. For this purpose, an LED will suffice to indicate <span class="No-Break">the status.</span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor152"/>Building a LoRa receiver</h1>
<p>In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.6</em>, we see a LoRa receiver processing messages from our LoRa sensory transmitter. Our receiver design is straightforward, requiring only an LED to acknowledge <a id="_idIndexMarker741"/>received messages. We’re utilizing a Raspberry Pi Pico W for the receiver as we plan to leverage its Wi-Fi capabilities in the next chapter and publish sensory data to <span class="No-Break">the internet.</span></p>
<p>We will not cover the steps to install CircuitPython or the required libraries onto the Pico W of the LoRa receiver as we covered these steps already for the LoRa sensory transmitter, and we merely need to do the same for the receiver. We should use the Pico W version of CircuitPython for this part of the project as we will implement Wi-Fi functionality in the <span class="No-Break">next chapter.</span></p>
<p>Also, we won’t detail the construction of the custom case for the LoRa receiver as it mirrors the transmitter’s process. The key variation is fitting an LED with a resistor and LED holder in place of the DHT22 sensor in the front shell. The steps for installing an LED were previously outlined in <em class="italic">Figures 6.22</em> and <em class="italic">6.23</em> of <a href="B21282_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">.</span></p>
<p>In this section, we will focus on the code for the LoRa receiver and highlight the results of an outdoor test of both the LoRa sensory transmitter and the <span class="No-Break">LoRa receiver.</span></p>
<p>We will start with a wiring diagram of the LED with a resistor to our Raspberry Pi <span class="No-Break">Pico W.</span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor153"/>Wiring an LED to the Raspberry Pi Pico W</h2>
<p>For our LoRa receiver, we require an LED to use for acknowledging LoRa messages. Based <a id="_idIndexMarker742"/>on what we have learned so far in this book, we could easily enhance our LoRa receiver with a more robust visualization such as an OLED screen. As we aim to focus only on acknowledging a LoRa signal, we will stick with a simple LED. We may monitor LoRa messages from the Shell in Thonny while running our LoRa receiver in <span class="No-Break">that environment:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer191">
<img alt="Figure 9.24 – Raspberry Pi Pico W, 220 Ohm resistor, and LED" height="739" src="image/B21282_09_24.jpg" width="717"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Raspberry Pi Pico W, 220 Ohm resistor, and LED</p>
<p>To connect an LED to our Raspberry Pi Pico W, we solder a 220 Ohm resistor to the anode <a id="_idIndexMarker743"/>of an LED. We then connect the resistor to the GP5 port on the Pico. For ground, we connect the cathode of the LED to any GND pin on the Pico W (<span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.24</em></span><span class="No-Break">).</span></p>
<p>With the 220 Ohm resistor and LED connected to our Pico W, we then connect an RMM95W LoRa module to our Pico W using the steps from the previous section, <em class="italic">Building a LoRa </em><span class="No-Break"><em class="italic">sensory transmitter</em></span><span class="No-Break">.</span></p>
<p>We are now ready to start <span class="No-Break">writing code.</span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor154"/>Creating code to receive LoRa messages</h2>
<p>Our LoRa <a id="_idIndexMarker744"/>receiver code uses the Adafruit <strong class="source-inline">adafruit_rfm9x</strong> library to listen for LoRa messages. Upon receipt, it prints the message to the Shell in Thonny and flashes the <span class="No-Break">LED twice.</span></p>
<p>To write our LoRa receiver code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico W to a USB port and launch Thonny. We may use our Raspberry Pi or another operating system <span class="No-Break">for this.</span></li>
<li>We then activate the CircuitPython environment on our Pico W by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>In a <a id="_idIndexMarker745"/>new tab, we enter the <span class="No-Break">following code:</span><pre class="source-code">
import time
import board
import busio
import digitalio
import adafruit_rfm9x
spi = busio.SPI(board.GP18, MOSI=board.GP19, MISO=board.GP16)
cs = digitalio.DigitalInOut(board.GP17)
rst = digitalio.DigitalInOut(board.GP14)
rfm9x = adafruit_rfm9x.RFM9x(spi, cs, rst, 915.0)
led = digitalio.DigitalInOut(board.GP5)
led.direction = digitalio.Direction.OUTPUT
print("Listening for LoRa messages...")
def flash_led(times, duration):
    for _ in range(times):
        led.value = True
        time.sleep(duration)
        led.value = False
        time.sleep(duration)
while True:
    packet = rfm9x.receive()
    if packet is not None:
        print("Received message:", packet)
        flash_led(2, 0.5)</pre><p class="list-inset">In our <a id="_idIndexMarker746"/>code, we do <span class="No-Break">the following:</span></p><ol><li class="upper-roman">We start by importing the necessary libraries: <strong class="source-inline">time</strong>, <strong class="source-inline">board</strong>, <strong class="source-inline">busio</strong>, <strong class="source-inline">digitalio</strong>, and <strong class="source-inline">adafruit_rfm9x</strong> for <span class="No-Break">LoRa communication.</span></li><li class="upper-roman">We then set up SPI communication by configuring SPI using GPIO pins GP18 (SCK), GP19 (MOSI), and <span class="No-Break">GP16 (MISO).</span></li><li class="upper-roman">We initialize CS and RST pins by setting up GP17 for CS and GP14 <span class="No-Break">for RST.</span></li><li class="upper-roman">We create an RFM95W LoRa object and initialize the object for 915.0 <span class="No-Break">MHz communication.</span></li><li class="upper-roman">We initialize an LED <span class="No-Break">on GP5.</span></li><li class="upper-roman">We then print a status message indicating that the device is listening for <span class="No-Break">LoRa messages.</span></li><li class="upper-roman">We define a function to flash the LED so that we may flash the LED a specified number of times with a <span class="No-Break">set duration.</span></li><li class="upper-roman">In a continuous loop, we listen for LoRa messages, checking for incoming LoRa packets, printing any received message, and flashing the LED twice for 0.5 seconds each upon receiving <span class="No-Break">a packet.</span></li></ol></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. This will open the <strong class="bold">Where to save </strong><span class="No-Break"><strong class="bold">to?</strong></span><span class="No-Break"> dialog.</span></li>
<li>In this dialog, we are given the option to choose where to store our file. To save it on our Raspberry Pi Pico W, we click on the <span class="No-Break">corresponding button.</span></li>
<li>We then give the file the name <strong class="source-inline">code.py</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
<li>To run <a id="_idIndexMarker747"/>our code, we click on the green run button, hit <em class="italic">F5</em> on the keyboard, or click on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>If it is not already running, we power up and run the LoRa <span class="No-Break">sensory transmitter.</span></li>
<li>In the Shell, we’ll see a notification confirming the receipt of a <span class="No-Break">LoRa message:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer192">
<img alt="Figure 9.25 – Receiving LoRa messages" height="208" src="image/B21282_09_25.jpg" width="969"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – Receiving LoRa messages</p>
<ol>
<li value="10">We should also observe our LED <span class="No-Break">flashes twice.</span></li>
</ol>
<p>With a positive result, we not only confirm that our LoRa receiver is working properly but our LoRa sensory transmitter as well. To take full advantage of our application, we need to use our transmitter and receiver outside. To do this, we should install our LoRa receiver in its own custom case. As mentioned, we follow the same steps outlined for the LoRa sensory transmitter substituting the LED with a resistor and the LED holder with a DHT22 <span class="No-Break">temperature sensor.</span></p>
<p>With both the LoRa sensory transmitter and LoRa, it is time to take our <span class="No-Break">application outdoors.</span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor155"/>Testing our application</h2>
<p>LoRa communication is known for its ability to cover long distances, a feature that sets it apart in the field of wireless communication technologies. While typical LoRa transmissions <a id="_idIndexMarker748"/>range from a few kilometers in urban settings to over 10 kilometers in rural areas, the technology has demonstrated far greater potential under optimal conditions. A world record was established with a LoRa transmission reaching 766 kilometers (476 miles) using just 25 mW of transmission power. This record highlights LoRa’s exceptional long-range capabilities, especially when conditions are favorable and the setup is optimized for <span class="No-Break">maximum reach.</span></p>
<p>In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.26</em>, we observe the results of testing our application over a modest distance of <span class="No-Break">160 meters:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer193">
<img alt="Figure 9.26 – Testing our LoRa sensory transmitter and LoRa receiver at a distance of 160 meters" height="908" src="image/B21282_09_26.jpg" width="1480"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.26 – Testing our LoRa sensory transmitter and LoRa receiver at a distance of 160 meters</p>
<p class="callout-heading">Alternative testing methods</p>
<p class="callout">We may also test our application by applying heat from a source such as a hair dryer, or we may even place our LoRa transmitter in a fridge and observe <span class="No-Break">the results.</span></p>
<p>This distance, while modest for LoRa, is significant when considering applications such as farm <a id="_idIndexMarker749"/>monitoring, where sensors can be spread over large areas, far beyond the reach of traditional Wi-Fi networks, which are typically constrained to about 50 meters indoors and less than 100 meters in <span class="No-Break">open spaces.</span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor156"/>Summary</h1>
<p>In this chapter, we explored LoRa technology, an important component in IoT communication. We started by discussing LoRa’s ability to transmit data over long distances with low power use, emphasizing its importance in wireless technology. We looked at its applications in agriculture, where it improves sensory network management for crop management, and in urban settings for smart city initiatives such as street <span class="No-Break">lighting control.</span></p>
<p>We then examined the technical aspects of LoRa within the radio frequency spectrum. This includes understanding how frequencies are allocated for wireless communications, which is important for identifying the right frequency bands for <span class="No-Break">LoRa transmissions.</span></p>
<p>For our hands-on sections, we built a LoRa sensory transmitter and LoRa receiver using Raspberry Pi Pico and Pico W respectively. This involved constructing a transmitter with a LoRa module and temperature sensor and a LoRa receiver using a simple <span class="No-Break">LED acknowledgment.</span></p>
<p>In the next chapter, we will take things further as we connect our LoRa receiver to the internet and use this to control a new version of the analog-metered weather indicator we created in <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></p>
</div>
</div></body></html>