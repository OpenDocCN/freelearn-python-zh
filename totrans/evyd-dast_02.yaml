- en: 'Chapter 2.  Arrays: Foundational Collections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often, our applications need to store multiple pieces of user data or
    objects in memory at runtime. One solution is to define multiple fields (properties)
    in our various classes to store each of our required data points. Unfortunately,
    even when working with the simplest workflows, this approach quickly becomes ineffective.
    We will either have too many fields to work with, or we simply won't have any
    way of anticipating all of the dynamic requirements for our project at compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this problem is to use an array. Arrays are simple collections
    of data, and they are one of the most common data structures you will encounter
    in your day-to-day programming experience due to the fact that many other data
    structures are built on top of them.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are containers that hold a fixed number of items of a particular type.
    The size of an array in C and its descendant languages are determined when the
    array is created, and the length remains fixed from that point forward. Each item
    in an array is called an **element**, and each element can be accessed by its
    index number. Generally speaking, an array is a collection of data items that
    can be selected by indices that are determined at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable arrays versus immutable arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example applications for arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear searches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multidimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jagged arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that arrays in most languages use what is known as a **zero-based index**,
    meaning that the first item in the array has an index of 0, the second has an
    index of 1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Off-by-one errors** occur when the source code attempts to access an item
    at a given index that is one point away from the actual item you intended to access.
    This type of mistake is common to new and experienced programmers alike and can
    very often be the source of **Index is out of range** or **Index is out of bounds**
    runtime errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arrays: Foundational Collections](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Compile time and runtime**'
  prefs: []
  type: TYPE_NORMAL
- en: In compiled programming languages (as opposed to interpreted languages), the
    difference between compile time and runtime is simply the difference between when
    an application is compiled and when it is run. During compiling, the high-level
    source code that the developer has written is fed into another program (usually
    called a compiler, oddly enough). The compiler checks whether the source code
    has the proper syntax, confirms type constraints are enforced, optimizes the code,
    and then produces an executable in a low-level language that the target architecture
    can utilize. If a program succeeds in compiling, we know that the source code
    is well formed and the resulting executable can be started. Note that developers
    will sometimes use the term *compile time* to include the actual process of writing
    the source code, although this is semantically incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: During runtime, the compiled code runs in the execution environment, but it
    can still experience errors. For example, attempting to divide by zero, dereferencing
    null memory pointers, running out of memory, or attempting to access resources
    that do not exist could all potentially crash your application if your source
    code does not handle these scenarios gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable versus immutable arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, languages that are based on the C language share many of the same
    fundamental characteristics. For example, in C the size of a plain array cannot
    be changed once the array has been created. Since the four languages we are examining
    here are all based on C, the arrays we will be working with also have a fixed
    length in. However, although the size of an array cannot be changed, the contents
    of the structure can change after the array is created.
  prefs: []
  type: TYPE_NORMAL
- en: So, are arrays mutable or immutable? In terms of mutability, we say that *plain
    C arrays are * *immutable* because the structure itself cannot change once it
    has been created. For this reason, it is typically a bad idea to use a plain C
    array for anything other than static datasets. This is because, whenever the dataset
    changes, your program will need to copy the modified data into a new array object
    and dispose of the old one, which are both costly operations.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the array objects you will be working with in higher-level languages
    are not plain C arrays, but rather wrapper classes created for the developer's
    convenience. Array wrapper classes encapsulate the complexities of the underlying
    data structure in favor of methods that handle the heavy lifting behind the scenes
    and properties that expose the characteristics of the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever a language provides a wrapper class for a particular type or data structure,
    you should take advantage of it. These are more convenient than writing your own
    implementation, and typically more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case study: users logged in to a web service'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Business problem**: A developer has created an application that logs mobile
    users in to a particular web service. Due to limitations in the server hardware,
    the web service can only permit 30 connected users at any given time. Therefore,
    the developer needs a way to track and limit the number of mobile device users
    who have connected to the service. In order to avoid duplicate users being permitted
    to log in and overload the service, a simple count of the connections is insufficient,
    as the developer will have no way of differentiating between the owners of each
    connection. Maintaining an array of objects representing a logged-in user is chosen
    as a core component of the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few important pieces of the preceding example we need to make note
    of. First, we are storing our `User` instances in a private class field called
    `_users`. Next, the constructor is instantiating a new array of `User` objects.
    Finally, we are instantiating the array to be 0 items in length and then assigning
    that collection to our private backer field. This is because our array doesn''t
    have any users assigned to it yet, and we don''t want to further complicate this
    code by trying to keep track of null values. In a real-world example, you might
    choose to instantiate and assign the private backer field all in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The former example is more verbose and, therefore, more readable. However,
    using the more succinct example takes up less space. Either approach will work.
    Next we''ll look at a method that allows us to add `User` objects to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we introduced a private method for some form of **validation**. The purpose
    of this method is to determine whether adding a user to the array is a valid operation
    at this time. First, we declared a `bool` variable called `containsUser`. We'll
    use this flag to signal whether or not the array already contains the `User` object
    being passed in. Next, we performed a `for` loop to check every object in the
    array against the passed in `User` object. If we find a match, we set the `containsUser`
    flag to `true` and break out of the `for` loop to save processor time. If `containsUser`
    is `true`, we know that the user object was found, and adding another copy would
    be a violation of our specified business rules. So, the method returns `false`.
    If the user does not exist in the array, execution continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we checked whether the array already contains 30 or more items by evaluating
    its `Length` property. If `true`, we return `false` because the array is full
    according to our business rules and adding more would be a violation. Otherwise,
    we return `true` and program execution can continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is called once the user has been authenticated, which is the only
    time we want to add a user to the user rolls. In this method, we validated the
    add user operation by calling the `CanAddUser()` method. If the `CanAddUser()` method
    returns `true`, method execution continues. First, we used the `Array` wrapper
    class'' `Resize()` method to grow the array by one and make room for our new addition.
    Next, we assigned the new `User` object to the last position in the resized array.
    Finally, we performed some simple housekeeping by logging the user id and new
    length of the `_users` array to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This method is called when a previously authenticated user has been logged out
    of the web service. It uses the array wrapper class' `IndexOf()` method to determine
    whether the passed-in `User` object exists in the array. Since the `IndexOf()` returns
    `-1` if no matching object can be found, this method confirms that the value of
    `i` is equal to `-1`. If the value of `index` is equal to `-1` we perform some
    housekeeping in the form of a console message stating this user ID is not currently
    logged in. Otherwise, we begin the process of deleting an object from an array.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to create a temporary array that is one element shorter than
    the old array. Next, we loop from 0 to the length of the new array, with `i` marking
    the position in the new array and `j` marking the position in the old array. If
    `i` equals the position of the item we want to remove, we increment `j` to skip
    past that element in the old array. Finally, we assign a user we intend to keep
    from the correct position in the old array to the new array. Once we're done iterating
    over the array, we assign the new list to the `_users` property. After this, we
    perform some simple housekeeping by logging the deleted user ID and new length
    of the `_users` array to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few important pieces of the preceding example we need to make note
    of. First, we are storing our `User` instances in a private class field called
    `_users`. Next, the constructor is instantiating a new array of `User` objects.
    Finally, we are instantiating the array as 0 items in length and then assigning
    that collection to our private backer field. This is because our array doesn''t
    have any users assigned to it yet, and we don''t want to further complicate this
    code by trying to keep track of null values. In a real-world example, you might
    choose to instantiate and assign the private backer field all in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The former example is more verbose and, therefore, more readable. However,
    using the more succinct example takes up less space. As with C#, either approach
    will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are introducing a private method for some sort of validation. The purpose
    of this method is to determine whether adding a user to the array is a valid operation
    at this time. First, we declared a `boolean` variable called `containsUser`. We'll
    use this flag to signal whether or not the array already contains the `User` object
    being passed in. Next, we performed a `for` loop to check every object in the
    array against the passed-in `User` object. If we find a match, we set the `containsUser`
    flag to `true` and break out of the `for` loop to save processor time. If `containsUser`
    is true`,` we know the user object was found, and adding another copy would be
    a violation of our specified business rules. So, the method returns `false`. If
    the user does not exist in the array, execution continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check whether the array already contains 30 or more items by evaluating
    its `Length` property. If `true`, we return `false` because the array is full
    according to our business rules, and adding more would be a violation. Otherwise,
    we return `true`, and program execution can continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is called once the user has been authenticated, which is the only
    time we want to add a user to the user rolls. In this method, we validated the
    add user operation by calling the `CanAddUser()` method. If `CanAddUser()` returns
    `true`, the method execution continues. First, we used the `Arrays` wrapper class''
    `copyOf()` method to create a new copy of the array that is one element larger,
    making room for our new addition. Next, we assign the new `User` object to the
    last position in the resized array. Finally, we performed some simple housekeeping
    by logging the user id and the new length of the `_users` array to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method is called when a previously authenticated user has been logged out
    of the web service. First, it loops through the `_users` array to locate a matching
    object to the `User` object that has been passed in. We instantiate the index
    value to `-1` so that, if no matching object can be found, this value does not
    change. This method next confirms that the value of `index` is equal to `-1`.
    If `true`, we perform some housekeeping by logging in to the console this user
    id is not currently logged in. Otherwise, we begin the process of deleting the
    object from the `_users` array.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to create a temporary array that is one element shorter than
    the old array. Next, we loop from 0 to the length of the new array, with `i` marking
    the position in the new array and `j` marking the position in the old array. If
    `i` equals the position of the item we want to remove, we increment `j` to skip
    past that element in the old array. Finally, we assign a user we intend to keep
    from the correct position in the old array to the new array. Once we're done looping,
    we assign the new list to the `_users` property. After this, we perform some simple
    housekeeping by logging the deleted user id and new length of the `_users` array
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with a primitive C array in Objective-C is considerably different than
    in C# or Java, predominantly because Objective-C does not provide methods for
    working *directly* with the primitive type. However, Objective-C does provide
    the `NSArray` wrapper class, which we will use in our code example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'First, our Objective-C class interface defines an **ivar** property for our
    array. Next, our initializer instantiates the `_users` object using the `[NSArrayarray]`
    convenience initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `canAddUser:` method also serves as internal validation in our Objective-C
    example. The purpose of this method is to determine whether adding a user to the
    array is a valid operation at this time. Since we''re working with `NSArray`,
    we have access to the `containsUser:` method, which can immediately determine
    whether the passed-in `User` object exists in the `_users` array. Don''t be fooled
    by the simplicity of this code, however, because, under the `NSArray` hood, the
    `containsUser:` method looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If that code looks familiar, it should because it is nearly identical in function
    to our previous C# and Java examples. The `containsObject:` method exists for
    our convenience, and it performs the heavy lifting for us behind the scenes. Again,
    if the user object is found, adding another copy is a violation of our specified
    business rules, and the method returns `false`. If the user does not exist, execution
    continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check whether the array already contains 30 or more items by evaluating
    its `count` property. If `true`, we return `false` because the array is full according
    to our business rules, and adding more would be a violation. Otherwise, we return
    `true`, and program execution can continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is called once the user has been authenticated, which is the only
    time we want to add a user to the user rolls. In this method, we validated the
    add user operation by calling `canAddUser:`. If `canAddUser:` returns `true`,
    the method execution continues. We use the `NSArray` class'' `arrayByAddingObject:`
    method to create a new copy of the array that includes our new `User` object.
    Last, we performed some simple housekeeping by logging the user id and new length
    of the `_users` array to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method is called when a previously authenticated user has been logged out
    of the web service. First, it uses the `NSArray indexOfObject:` array to get an
    index for any object matching the `User` object that has been passed in. If the
    object is not found, the method returns `NSNotFound`, which is equivalent to `NSIntegerMax`.
  prefs: []
  type: TYPE_NORMAL
- en: This method next confirms that the value of `index` is equal to `NSNotFound`.
    If `true`, we perform some housekeeping by logging in to the console to which
    this user id is not currently logged in. Otherwise, we begin the process of deleting
    the object from the `_users` array.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `NSArray` does not provide a method for deleting an object from
    the underlying immutable array, so we need to get a little creative. First, we
    create a temporary array object called `newUsers` to hold all the `User` objects
    that we want to keep. Next, we loop through the `_users` array, checking each
    object to see whether it matches the `User` we want to delete. If there is no
    match, we add it to the `newUsers` array in the same way we added a new user to
    `_users` when a user is authenticated. If the `User` object matches, we simply
    skip it, effectively deleting it from the final array of objects. As you can imagine,
    this procedure is very costly, and this pattern should be avoided if at all possible.
    Once the loop is complete, we assign the new array to the `_users` property. Finally,
    we perform some simple housekeeping by logging the deleted user id and the new
    count of the `_users` array to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with a primitive C array in Swift is very similar to doing so in C#
    or Java, in that it provides the `Array` class, which we will use in our code
    example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We only need one class property to support our array of users. Swift arrays
    are type-dependent just as in C# and Java, and we must declare the type when declaring
    the array property. Note the difference in how Swift initializes arrays by surrounding
    the type name or object class name with the subscription operator, rather than
    appending the operator to the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `canAddUser:` method also serves as internal validation. The purpose of
    this method is to determine whether adding a user to the array is a valid operation
    at this time. First, we're using the `Array.contains()` method to determine whether
    the user we want to add already exists in the array. If the user object is found,
    adding another copy is a violation of our specified business rules, and the method
    returns `false`. If the user does not exist, execution continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the `count` property of the `_users` array to check that the total
    number of objects within the array is not greater than or equal to 30\. If `true`,
    we return `false` because the array is full according to our business rules, and
    adding more would be a violation. Otherwise, we return `true`, and program execution
    can continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this method is called once the user has been authenticated, which is
    the only time we want to add a user to the user rolls. In this method, we validate
    the add user operation by calling the `canAddUser()` method. If `canAddUser()`
    returns `true`, the method execution continues, and we add the user to the array
    using the `Array.append()` method. Last, we perform some simple housekeeping by
    logging the user id and new length of the `_users` array to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to remove a user during logout, we first need to determine whether
    the object exists in the array and get its index within the array. Swift allows
    us to simultaneously declare the `index` variable, perform this check, and assign
    a value to `index`. If this check returns `true`, we call `Array.removeAtIndex()`
    to take the `user` object out of the array. Finally, we perform some simple housekeeping
    by logging the deleted user ID and the new count of the `_users` array to the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Separation of concerns**'
  prefs: []
  type: TYPE_NORMAL
- en: When you examine the previous examples, you might wonder what happens to all
    those `User` objects we have been adding once we are done with them. If so, great
    catch! If you look closely, you will see we have not instantiated or modified
    a single `User` object in this example-only the array that was contained the objects.
    This is by design.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, the concept of **separation of concerns** dictates
    that computer programs should be broken up into distinct operational features
    that overlap as little as possible. For example, a class named `LoggedInUserArray`,
    which operates as a wrapper to an underlying array structure, should only manipulate
    its array's operations and have little bearing on objects within the array. In
    this case, the inner workings and details of the `User` class objects that are
    passed in are not the `LoggedInUserArray` class's concern.
  prefs: []
  type: TYPE_NORMAL
- en: Once each `User` is removed from the array, the object goes on its merry way.
    If the application retains no other references to the `User` object, some form
    of **garbage collection** will eventually dispose it off from memory. Either way,
    the `LoggedInUserArray` class is not responsible for garbage collection and remains
    agnostic concerning these types of detail.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have seen how arrays are used in common practice, let''s examine
    a few advanced topics relating to arrays: search patterns and variations on the
    basic types of objects that can be stored in an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Linear search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When learning about data structures, it is impossible to avoid discussing the
    subjects of **searching** and **sorting**. Without the ability to search a data
    structure, the data would be fairly useless to us. Without the ability to sort
    the data set for use in a particular application, the data would be extremely
    tedious to manage.
  prefs: []
  type: TYPE_NORMAL
- en: The steps or process we follow to perform a search or a sort of a particular
    data structure are called an **algorithm**. The performance or the complexity
    of an algorithm in computer science is measured using the **big O notation**,
    which is derived from the function *f(n) =* **O** *(g(n))*, read as *f of n equals
    big oh of g of n*. In the simplest terms, **big** **O** is the terminology we
    use to describe the worst case for how long an algorithm takes to run. For example,
    if we know the index of the object we are searching for in an array, it takes
    only one comparison to locate and retrieve that object. Therefore, the worst case
    requires one comparison, and the cost of the search is **O**(*1*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we will examine searching and sorting in much greater detail later,
    for now, we will examine **linear searching**, or sequential searching, which
    is the simplest and least efficient pattern for searching a collection. Iteration
    means repeating a process over and over again. With a linear search, we iterate
    sequentially over the collection of objects until we find a match to our search
    pattern. For collections containing *n* items, the best-case search is when the
    target value is equal to the first item in the collection, which means, only one
    comparison is required. In the worst-case scenario, the target value is not found
    in the collection at all, which means *n* comparisons are required. This means
    the cost of a linear search is **O**(*n*). If you look back at the code examples,
    you will see **O**(*n*) searches in several places:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the linear search algorithm from our C# code but reformatted to use
    a `for` loop, which better demonstrates the concept of **O**(*n*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the linear search algorithm from our Java code but reformatted to use
    a `for` loop, which better demonstrates the concept of **O**(*n*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the linear search algorithm from our Objective-C code but reformatted
    to use a `for` loop which better demonstrates the concept of **O**(*n*) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Swift code does not include an example of a linear search, but one example
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Primitive arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Primitive arrays are simply arrays that only contain primitive types. In C#,
    Java, and Swift, you declare a primitive array by declaring an array on a primitive
    type. As a weakly typed language, Objective-C does not support explicitly typed
    arrays, and therefore does not support explicitly primitive arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Object arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object arrays are simply arrays that contain only instances of a particular
    object. In C#, Java, and Swift, you declare an object array by declaring an array
    on class. As a weakly typed language, Objective-C does not support explicitly
    typed arrays and, therefore, does not support explicitly object arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Mixed arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with arrays, you declare the array using one data type, and all
    of the elements in the array must match that data type. Typically, this constraint
    is suitable, since the elements are normally closely related to one another or
    share similar property values. At other times, the elements in your array are
    not closely related or do not have similar property values. In these circumstances,
    it is desirable to have the ability to mix-and-match types within the same array.
    C# and Java share a similar mechanism for accomplishing this--declaring the array
    as the root class object type. Arrays in Objective-C are already mixed by default
    due to the language being weakly typed. Swift provides the `AnyObject` type for
    declaring mixed arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Working with mixed arrays can seem convenient at the first glance, but be aware
    that you as the developer take the responsibility for type checking away from
    the compiler. This won't be a major adjustment for developers with weakly typed
    languages such as Objective-C, but developers experienced in strongly typed languages
    will need to be very attentive to this concern.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A multidimensional array is an array containing one or more additional arrays.
    The four languages we are working with can each support multidimensional arrays
    of *1...n* dimensions. However, be aware that multidimensional arrays greater
    than three levels deep become extremely difficult to manage.
  prefs: []
  type: TYPE_NORMAL
- en: It sometimes helps to conceptualize multidimensional arrays in terms relative
    to their dimensions. For example, a 2D array might have rows and columns, or *x*
    and *y* values. Similarly, a 3D array might have *x*, *y*, and *z* values. Let's
    look at an example of 2D and 3D arrays in each language.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multidimensional arrays in C# are created with the `[,]` syntax, where each
    `,` represents one additional dimension within the array. The corresponding `new`
    initializer must provide the correct number of size arguments to match the definition
    or the code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for creating multidimensional arrays in Java simply involves stringing
    pairs of `[]` where each pair represents one dimension within the array. The corresponding
    `new` initializer must provide the correct number of bracketed size arguments
    to match the definition or the code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C does not directly support multidimensional arrays with the `NSArray`
    class. If a multidimensional array is required in your code, you will need to
    use `NSMutableArray` or a plain C array, both of which are outside the scope of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multidimensional arrays in Swift can seem somewhat confusing at first glance,
    but what you need to realize is that you are creating arrays of arrays. The definition
    syntax is `[[Int]]` while the initialization syntax is `[[1, 2], [3, 4]]` where
    the values used at initialization can be any value of the specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Jagged Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jagged arrays are created when a multidimensional array contains arrays of different
    sizes. There are rare scenarios when such a design is necessary, but be aware
    that jagged arrays can be very complex and difficult to manage. C#, Java, and
    Swift support jagged arrays. Objective-C does not support multidimensional arrays
    using `NSArray`, and therefore, does not support jagged arrays using it. As with
    multidimensional arrays, Objective-C can support jagged arrays using either `NSMutableArray`
    or plain C arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basic definition of an array structure, how
    arrays look in memory, and how each of the four languages we are discussing implement
    some form of the plain C array structure. Next, we discussed the difference between
    mutable and immutable arrays. Using examples, we looked at how each of the four
    languages we are discussing implements arrays and array functionality. In the
    remainder of the chapter, we examined the linear search algorithm and introduced
    the big **O** notation, including how this notation is applied to arrays with
    examples of simple iteration. We discussed the difference between primitive arrays,
    object arrays, and mixed arrays. Finally, we examined multidimensional arrays
    and their counterpart, jagged arrays.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, it is important to know when to use an array. Arrays are great
    for containing small lists of constant data or data that changes very little to
    not at all. If you find yourself constantly manipulating the data in your array
    or constantly adding and removing objects, then you will want to examine alternative
    data structures such as the List which we will discuss in the following chapter.
  prefs: []
  type: TYPE_NORMAL
