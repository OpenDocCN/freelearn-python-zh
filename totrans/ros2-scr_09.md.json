["```py\n$ cd ros2_ws/src/my_robot_interfaces/\n$ mkdir action\n```", "```py\n$ cd ~/ros2_ws/src/my_robot_interfaces/action/\n$ touch CountUntil.action\n```", "```py\nint64 goal_number\n---\n---\n```", "```py\n# Goal\nint64 target_number\nfloat64 delay\n---\n# Result \nint64 reached_number \n---\n# Feedback \nint64 current_number\n```", "```py\nrosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/HardwareStatus.msg\"\n  \"srv/ResetCounter.srv\"\n  \"srv/ActivateTurtle.srv\"\n  \"action/CountUntil.action\"\n)\n```", "```py\n$ colcon build --packages-select my_robot_interfaces\n```", "```py\n$ ros2 interface show my_robot_interfaces/action/CountUntil\n# Action interface definition here\n```", "```py\nimport rclpy\nimport time\nfrom rclpy.node import Node\nfrom rclpy.action import ActionServer, GoalResponse\nfrom rclpy.action.server import ServerGoalHandle\n```", "```py\nfrom my_robot_interfaces.action import CountUntil\n```", "```py\n<depend>my_robot_interfaces</depend>\n```", "```py\nself.count_until_server_ = ActionServer(\n           self,\n           CountUntil,\n           \"count_until\",\n           goal_callback=self.goal_callback,\n           execute_callback=self.execute_callback)\n```", "```py\ndef goal_callback(self, goal_request: CountUntil.Goal):\n    self.get_logger().info(\"Received a goal\")\n    if goal_request.target_number <= 0:\n        self.get_logger().warn(\"Rejecting the goal, target number must be positive\")\n        return GoalResponse.REJECT\n    self.get_logger().info(\"Accepting the goal\")\n    return GoalResponse.ACCEPT\n```", "```py\ndef execute_callback(self, goal_handle: ServerGoalHandle):\n    target_number = goal_handle.request.target_number\n    delay = goal_handle.request.delay\n    result = CountUntil.Result()\n    counter = 0\n```", "```py\n    self.get_logger().info(\"Executing the goal\")\n    for i in range (target_number):\n        counter += 1\n        self.get_logger().info(str(counter))\n        time.sleep(delay)\n```", "```py\n    goal_handle.succeed()\n    result.reached_number = counter\n    return result\n```", "```py\n#include \"rclcpp/rclcpp.hpp\"\n#include \"rclcpp_action/rclcpp_action.hpp\"\n#include \"my_robot_interfaces/action/count_until.hpp\"\n```", "```py\n<depend>my_robot_interfaces</depend>\n<depend>rclcpp_action</depend>\n```", "```py\nfind_package(my_robot_interfaces REQUIRED)\nfind_package(rclcpp_action REQUIRED)\n```", "```py\nadd_executable(count_until_server src/count_until_server_minimal.cpp)\nament_target_dependencies(count_until_server rclcpp rclcpp_action my_robot_interfaces)\n```", "```py\nrclcpp_action::Server<CountUntil>::SharedPtr count_until_server_;\n```", "```py\ncount_until_server_ = rclcpp_action::create_server<CountUntil>(\n    this,\n    \"count_until\",\n    std::bind(&CountUntilServerNode::goalCallback, this, _1, _2),\n    std::bind(&CountUntilServerNode::cancelCallback, this, _1),\n    std::bind(&CountUntilServerNode::executeCallback, this, _1)\n);\n```", "```py\nrclcpp_action::GoalResponse goalCallback(const rclcpp_action::GoalUUID &uuid, std::shared_ptr<const CountUntil::Goal> goal)\n```", "```py\nreturn rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;\n```", "```py\nint target_number = goal_handle->get_goal()->target_number;\ndouble delay = goal_handle->get_goal()->delay;\nauto result = std::make_shared<CountUntil::Result>();\nint counter = 0;\nrclcpp::Rate loop_rate(1.0/delay);\n```", "```py\nRCLCPP_INFO(this->get_logger(), \"Executing the goal\");\nfor (int i = 0; i < target_number; i++) {\n    counter++;\n    RCLCPP_INFO(this->get_logger(), \"%d\", counter);\n    loop_rate.sleep();\n}\n```", "```py\nresult->reached_number = counter;\ngoal_handle->succeed(result);\n```", "```py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom rclpy.action.client import ClientGoalHandle, GoalStatus\nfrom my_robot_interfaces.action import CountUntil\n```", "```py\nself.count_until_client_ = ActionClient(\nself, CountUntil, \"count_until\")\n```", "```py\ndef send_goal(self, target_number, delay):\n    self.count_until_client_.wait_for_server()\n    goal = CountUntil.Goal()\n    goal.target_number = target_number\n    goal.delay = delay\n    self.count_until_client_.send_goal_async(\n        goal).add_done_callback(self.goal_response_callback)\n```", "```py\ndef goal_response_callback(self, future):\n    self.goal_handle_: ClientGoalHandle = future.result()\n    if self.goal_handle_.accepted:\n        self.get_logger().info(\"Goal got accepted\")\n        self.goal_handle_.get_result_async().add_done_callback(\n            self.goal_result_callback)\n    else:\n        self.get_logger().info(\"Goal got rejected\")\n```", "```py\ndef goal_result_callback(self, future):\n    status = future.result().status\n    result = future.result().result\n    if status == GoalStatus.STATUS_SUCCEEDED:\n        self.get_logger().info(\"Success\")\n    elif status == GoalStatus.STATUS_ABORTED:\n        self.get_logger().error(\"Aborted\")\n    elif status == GoalStatus.STATUS_CANCELED:\n        self.get_logger().warn(\"Canceled\")\n    self.get_logger().info(\"Result: \" + str(result.reached_number))\n```", "```py\nnode = CountUntilClientNode()\nnode.send_goal(5, 0.5)\nrclpy.spin(node)\n```", "```py\n$ ros2 run my_py_pkg count_until_server\n[count_until_server]: Action server has been started.\n[count_until_server]: Received a goal\n[count_until_server]: Accepting the goal\n[count_until_server]: Executing the goal\n[count_until_server]: 1\n...\n[count_until_server]: 5\n```", "```py\n$ ros2 run my_py_pkg count_until_client\n[count_until_client]: Goal got accepted\n[count_until_client]: Success\n[count_until_client]: Result: 5\n```", "```py\nusing CountUntilGoalHandle = rclcpp_action::ClientGoalHandle<CountUntil>;\n```", "```py\nrclcpp_action::Client<CountUntil>::SharedPtr count_until_client_;\n```", "```py\ncount_until_client_ = rclcpp_action::create_client<CountUntil>(this, \"count_until\");\n```", "```py\nauto options = rclcpp_action::Client<CountUntil>::SendGoalOptions();\noptions.goal_response_callback = std::bind(\n    &CountUntilClientNode::goalResponseCallback, this, _1);\noptions.result_callback = std::bind(\n    &CountUntilClientNode::goalResultCallback, this, _1);\ncount_until_client_->async_send_goal(goal, options);\n```", "```py\nif (!goal_handle) {\n```", "```py\nauto node = std::make_shared<CountUntilClientNode>();\nnode->sendGoal(5, 0.5);\nrclcpp::spin(node);\n```", "```py\nfeedback = CountUntil.Feedback()\n```", "```py\nfeedback.current_number = counter\ngoal_handle.publish_feedback(feedback)\n```", "```py\nself.count_until_client_.send_goal_async(\n    goal, feedback_callback=self.goal_feedback_callback). \\\n    add_done_callback(self.goal_response_callback)\n```", "```py\ndef goal_feedback_callback(self, feedback_msg):\n   number = feedback_msg.feedback.current_number\n   self.get_logger().info(\"Got feedback: \" + str(number))\n```", "```py\n$ ros2 run my_py_pkg count_until_client\n[count_until_client]: Goal got accepted\n[count_until_client]: Got feedback: 1\n```", "```py\n[count_until_client]: Got feedback: 5\n[count_until_client]: Success\n[count_until_client]: Result: 5\n```", "```py\nauto result = std::make_shared<CountUntil::Result>();\n```", "```py\nfeedback->current_number = counter;\ngoal_handle->publish_feedback(feedback);\n```", "```py\noptions.feedback_callback = std::bind(\n    &CountUntilClientNode::goalFeedbackCallback, this, _1, _2);\n```", "```py\nvoid goalFeedbackCallback(const CountUntilGoalHandle::SharedPtr &goal_handle, const std::shared_ptr<const CountUntil::Feedback> feedback)\n{\n   (void)goal_handle;\n   int number = feedback->current_number;\n   RCLCPP_INFO(this->get_logger(), \"Got feedback: %d\", number);\n}\n```", "```py\nActionServer(\n    …\n    cancel_callback=self.cancel_callback,\n    …)\n```", "```py\ndef cancel_callback(self, goal_handle: ServerGoalHandle):\n    self.get_logger().info(\"Received a cancel request\")\n    return CancelResponse.ACCEPT\n```", "```py\nif goal_handle.is_cancel_requested:\n    self.get_logger().info(\"Canceling goal\")\n    goal_handle.canceled()\n    result.reached_number = counter\n    return result\n```", "```py\nfrom rclpy.executors import MultiThreadedExecutor\nfrom rclpy.callback_groups import ReentrantCallbackGroup\n```", "```py\nActionServer(\n    …\n    callback_group=ReentrantCallbackGroup())\n```", "```py\nrclpy.spin(node, MultiThreadedExecutor())\n```", "```py\ndef cancel_goal(self):\n   self.get_logger().info(\"Send a cancel goal request\")\n   self.goal_handle_.cancel_goal_async()\n```", "```py\nif number >= 2:\n    self.cancel_goal()\n```", "```py\n[count_until_client]: Goal got accepted\n[count_until_client]: Got feedback: 1\n[count_until_client]: Got feedback: 2\n[count_until_client]: Send a cancel goal request\n[count_until_client]: Canceled\n[count_until_client]: Result: 2\n```", "```py\n[count_until_server]: Executing the goal\n[count_until_server]: 1\n[count_until_server]: 2\n[count_until_server]: Received a cancel request\n[count_until_server]: Canceling goal\n```", "```py\nreturn rclcpp_action::CancelResponse::ACCEPT;\n```", "```py\nif (goal_handle->is_canceling()) {\n    RCLCPP_INFO(this->get_logger(), \"Canceling goal\");\n    result->reached_number = counter;\n    goal_handle->canceled(result);\n    return;\n}\n```", "```py\nrclcpp::executors::MultiThreadedExecutor executor;\nexecutor.add_node(node);\nexecutor.spin();\n```", "```py\nrclcpp::CallbackGroup::SharedPtr cb_group_;\n```", "```py\ncb_group_ = this->create_callback_group(\n    rclcpp::CallbackGroupType::Reentrant);\ncount_until_server_ = rclcpp_action::create_server<CountUntil>(\n    …\n    rcl_action_server_get_default_options(),\n    cb_group_\n);\n```", "```py\nvoid cancelGoal()\n{\n    RCLCPP_INFO(this->get_logger(), \"Send a cancel goal request\");\n    count_until_client_->async_cancel_all_goals();\n}\n```", "```py\nif (number >= 2) {\n    cancelGoal();\n}\n```", "```py\n$ ros2 action list\n/count_until\n```", "```py\n$ ros2 action info /count_until -t\nAction: /count_until\nAction clients: 0\nAction servers: 1\n/count_until_server [my_robot_interfaces/action/CountUntil]\n```", "```py\n$ ros2 interface show my_robot_interfaces/action/CountUntil\n# Here you should see the action definition\n```", "```py\n$ ros2 action send_goal /count_until my_robot_interfaces/action/CountUntil \"{target_number: 3, delay: 0.4}\" --feedback\n```", "```py\nWaiting for an action server to become available...\nSending goal:\n target_number: 3\ndelay: 0.4\nGoal accepted with ID: cad1aa41829d42c5bb1bf73dd4d66600\nFeedback:\ncurrent_number: 1\nFeedback:\ncurrent_number: 2\nFeedback:\ncurrent_number: 3\nResult:\nreached_number: 3\nGoal finished with status: SUCCEEDED\n```", "```py\n$ ros2 topic list --include-hidden-topics\n/count_until/_action/feedback\n/count_until/_action/status\n...\n$ ros2 service list --include-hidden-services\n/count_until/_action/cancel_goal\n/count_until/_action/get_result\n/count_until/_action/send_goal\n...\n```", "```py\n$ ros2 run my_cpp_pkg count_until_server --ros-args \\\n    -r /count_until/_action/feedback:=/count_until1/_action/feedback \\\n    -r /count_until/_action/status:=/count_until1/_action/status \\\n    -r /count_until/_action/cancel_goal:=/count_until1/_action/cancel_goal \\\n    -r /count_until/_action/get_result:=/count_until1/_action/get_result \\\n    -r /count_until/_action/send_goal:=/count_until1/_action/send_goal\n```"]