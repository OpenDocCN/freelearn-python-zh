["```py\n>>> def decorator(function):\n...     return function\n\n>>> def add(a, b):\n...     return a + b\n\n>>> add = decorator(add) \n```", "```py\n>>> @decorator\n... def add(a, b):\n...     return a + b \n```", "```py\n>>> import functools\n\n>>> def decorator(function):\n...    # This decorator makes sure we mimic the wrapped function\n...    @functools.wraps(function)\n...    def _decorator(a, b):\n...        # Pass the modified arguments to the function\n...        result = function(a, b + 5)\n...\n...        # Log the function call\n...        name = function.__name__\n...        print(f'{name}(a={a}, b={b}): {result}')\n...\n...        # Return a modified result\n...        return result + 4\n...\n...    return _decorator\n\n>>> @decorator\n... def func(a, b):\n...     return a + b\n\n>>> func(1, 2)\nfunc(a=1, b=2): 8\n12 \n```", "```py\n>>> import functools\n\n>>> def decorator(function):\n...    @functools.wraps(function)\n...    def _decorator(*args, **kwargs):\n...        a, b = args\n...        return function(a, b + 5)\n...\n...    return _decorator\n\n>>> @decorator\n... def func(a, b):\n...     return a + b\n\n>>> func(1, 2)\n8\n\n>>> func(a=1, b=2)\nTraceback (most recent call last):\n...\nValueError: not enough values to unpack (expected 2, got 0) \n```", "```py\n>>> def add(a, b, /):\n...     return a + b\n\n>>> add(a=1, b=2)\nTraceback (most recent call last):\n...\nTypeError: add() got some positional-only arguments passed ...\n\n>>> def add(*, a, b):\n...     return a + b\n\n>>> add(1, 2)\nTraceback (most recent call last):\n...\nTypeError: add() takes 0 positional arguments but 2 were given \n```", "```py\n>>> import inspect\n>>> import functools\n\n>>> def decorator(function):\n...    # Use the inspect module to get function signature. More\n...    # about this in the logging chapter\n...    signature = inspect.signature(function)\n... \n...    @functools.wraps(function)\n...    def _decorator(*args, **kwargs):\n...        # Bind the arguments to the given *args and **kwargs.\n...        # If you want to make arguments optional, use\n...        # signature.bind_partial instead.\n...        bound = signature.bind(*args, **kwargs)\n...\n...        # Apply the defaults so b is always filled\n...        bound.apply_defaults()\n...\n...        # Extract the filled arguments. If the number of\n...        # arguments is still expected to be fixed, you can use\n...        # tuple unpacking: 'a, b = bound.arguments.values()'\n...        a = bound.arguments['a']\n...        b = bound.arguments['b']\n...        return function(a, b + 5)\n...\n...    return _decorator\n\n>>> @decorator\n... def func(a, b=3):\n...     return a + b\n\n>>> func(1, 2)\n8\n\n>>> func(a=1, b=2)\n8\n\n>>> func(a=1)\n9 \n```", "```py\n>>> def decorator(function):\n...    def _decorator(*args, **kwargs):\n...        return function(*args, **kwargs)\n...\n...    return _decorator\n\n>>> @decorator\n... def add(a, b):\n...     '''Add a and b'''\n...     return a + b\n\n>>> help(add)\nHelp on function _decorator in module ...:\n<BLANKLINE>\n_decorator(*args, **kwargs)\n<BLANKLINE>\n\n>>> add.__name__\n'_decorator' \n```", "```py\n>>> import functools\n\n>>> def decorator(function):\n...     @functools.wraps(function)\n...     def _decorator(*args, **kwargs):\n...         return function(*args, **kwargs)\n...\n...     return _decorator\n\n>>> @decorator\n... def add(a, b):\n...     '''Add a and b'''\n...     return a + b\n\n>>> help(add)\nHelp on function add in module ...:\n<BLANKLINE>\nadd(a, b)\n    Add a and b\n<BLANKLINE>\n\n>>> add.__name__\n'add' \n```", "```py\n>>> import functools\n\n>>> def track(function=None, label=None):\n...     # Trick to add an optional argument to our decorator\n...     if label and not function:\n...         return functools.partial(track, label=label)\n...\n...     print(f'initializing {label}')\n...\n...     @functools.wraps(function)\n...     def _track(*args, **kwargs):\n...         print(f'calling {label}')\n...         function(*args, **kwargs)\n...         print(f'called {label}')\n...\n...     return _track\n\n>>> @track(label='outer')\n... @track(label='inner')\n... def func():\n...     print('func')\ninitializing inner\ninitializing outer\n\n>>> func()\ncalling outer\ncalling inner\nfunc\ncalled inner\ncalled outer \n```", "```py\n>>> import collections\n\n>>> class EventRegistry:\n...     def __init__(self):\n...         self.registry = collections.defaultdict(list)\n... \n...     def on(self, *events):\n...         def _on(function):\n...             for event in events:\n...                 self.registry[event].append(function)\n...             return function\n... \n...         return _on\n... \n...     def fire(self, event, *args, **kwargs):\n...         for function in self.registry[event]:\n...             function(*args, **kwargs)\n\n>>> events = EventRegistry()\n\n>>> @events.on('success', 'error')\n... def teardown(value):\n...     print(f'Tearing down got: {value}')\n\n>>> @events.on('success')\n... def success(value):\n...     print(f'Successfully executed: {value}')\n\n>>> events.fire('non-existing', 'nothing to see here')\n>>> events.fire('error', 'Oops, some error here')\nTearing down got: Oops, some error here\n>>> events.fire('success', 'Everything is fine')\nTearing down got: Everything is fine\nSuccessfully executed: Everything is fine \n```", "```py\n`1 = 0 + 1`\n`2 = 1 + 1`\n`3 = 1 + 2`\n`5 = 2 + 3`\n`8 = 3 + 5` \n```", "```py\n>>> import functools\n\n>>> def memoize(function):\n...     # Store the cache as attribute of the function so we can\n...     # apply the decorator to multiple functions without\n...     # sharing the cache.\n...     function.cache = dict()\n...\n...     @functools.wraps(function)\n...     def _memoize(*args):\n...         # If the cache is not available, call the function\n...         # Note that all args need to be hashable\n...         if args not in function.cache:\n...             function.cache[args] = function(*args)\n...         return function.cache[args]\n...\n...     return _memoize \n```", "```py\n>>> @memoize\n... def fibonacci(n):\n...     if n < 2:\n...         return n\n...     else:\n...         return fibonacci(n - 1) + fibonacci(n - 2)\n\n>>> for i in range(1, 7):\n...     print(f'fibonacci {i}: {fibonacci(i)}')\nfibonacci 1: 1\nfibonacci 2: 1\nfibonacci 3: 2\nfibonacci 4: 3\nfibonacci 5: 5\nfibonacci 6: 8\n\n>>> fibonacci.__wrapped__.cache\n{(1,): 1, (0,): 0, (2,): 1, (3,): 2, (4,): 3, (5,): 5, (6,): 8} \n```", "```py\n# It breaks keyword arguments:\n>>> fibonacci(n=2)\nTraceback (most recent call last):\n...\nTypeError: _memoize() got an unexpected keyword argument 'n' \n```", "```py\n# Unhashable types don't work as dict keys:\n>>> fibonacci([123])\nTraceback (most recent call last):\n...\nTypeError: unhashable type: 'list' \n```", "```py\n>>> import functools\n\n# Create a simple call counting decorator\n>>> def counter(function):\n...     function.calls = 0\n...     @functools.wraps(function)\n...     def _counter(*args, **kwargs):\n...         function.calls += 1\n...         return function(*args, **kwargs)\n...\n...     return _counter\n\n# Create a LRU cache with size 3 \n>>> @functools.lru_cache(maxsize=3)\n... @counter\n... def fibonacci(n):\n...     if n < 2:\n...         return n\n...     else:\n...         return fibonacci(n - 1) + fibonacci(n - 2)\n\n>>> fibonacci(100)\n354224848179261915075\n\n# The LRU cache offers some useful statistics\n>>> fibonacci.cache_info()\nCacheInfo(hits=98, misses=101, maxsize=3, currsize=3)\n\n# The result from our counter function which is now wrapped both by\n# our counter and the cache\n>>> fibonacci.__wrapped__.__wrapped__.calls\n101 \n```", "```py\n>>> import functools\n\n>>> def add(function=None, add_n=0):\n...     # function is not callable so it's probably 'add_n'\n...     if not callable(function):\n...         # Test to make sure we don't pass 'None' as 'add_n'\n...         if function is not None:\n...             add_n = function\n...         return functools.partial(add, add_n=add_n)\n...     \n...     @functools.wraps(function)\n...     def _add(n):\n...         return function(n) + add_n\n...\n...     return _add\n\n>>> @add\n... def add_zero(n):\n...     return n\n\n>>> @add(1)\n... def add_one(n):\n...     return n\n\n>>> @add(add_n=2)\n... def add_two(n):\n...     return n\n\n>>> add_zero(5)\n5\n\n>>> add_one(5)\n6\n\n>>> add_two(5)\n7 \n```", "```py\n>>> import functools\n\n>>> class Debug(object):\n...\n...     def __init__(self, function):\n...         self.function = function\n...         # functools.wraps for classes\n...         functools.update_wrapper(self, function)\n...\n...     def __call__(self, *args, **kwargs):\n...         output = self.function(*args, **kwargs)\n...         name = self.function.__name__\n...         print(f'{name}({args!r}, {kwargs!r}): {output!r}')\n...         return output\n\n>>> @Debug\n... def add(a, b=0):\n...     return a + b\n...\n\n>>> output = add(3)\nadd((3,), {}): 3\n\n>>> output = add(a=4, b=2)\nadd((), {'a': 4, 'b': 2}): 6 \n```", "```py\n>>> import functools\n\n>>> def plus_one(function):\n...     @functools.wraps(function)\n...     def _plus_one(self, n, *args):\n...         return function(self, n + 1, *args)\n...\n...     return _plus_one\n\n>>> class Adder(object):\n...     @plus_one\n...     def add(self, a, b=0):\n...         return a + b\n\n>>> adder = Adder()\n>>> adder.add(0)\n1\n>>> adder.add(3, 4)\n8 \n```", "```py\n>>> import pprint\n\n>>> class Spam(object):\n...     def some_instancemethod(self, *args, **kwargs):\n...         pprint.pprint(locals(), width=60)\n...\n...     @classmethod\n...     def some_classmethod(cls, *args, **kwargs):\n...         pprint.pprint(locals(), width=60)\n...\n...     @staticmethod\n...     def some_staticmethod(*args, **kwargs):\n...         pprint.pprint(locals(), width=60)\n\n# Create an instance so we can compare the difference between\n# executions with and without instances easily\n>>> spam = Spam() \n```", "```py\n# With an instance (note the lowercase spam)\n>>> spam.some_instancemethod(1, 2, a=3, b=4)\n{'args': (1, 2),\n 'kwargs': {'a': 3, 'b': 4},\n 'self': <__main__.Spam object at ...>}\n\n# Without an instance (note the capitalized Spam)\n>>> Spam.some_instancemethod()\nTraceback (most recent call last):\n    ...\nTypeError: some_instancemethod() missing ... argument: 'self'\n\n# But what if we add parameters? Be very careful with these!\n# Our first argument is now used as an argument, this can give\n# very strange and unexpected errors\n>>> Spam.some_instancemethod(1, 2, a=3, b=4)\n{'args': (2,), 'kwargs': {'a': 3, 'b': 4}, 'self': 1} \n```", "```py\n# Classmethods are expectedly identical\n>>> spam.some_classmethod(1, 2, a=3, b=4)\n{'args': (1, 2),\n 'cls': <class '__main__.Spam'>,\n 'kwargs': {'a': 3, 'b': 4}}\n\n>>> Spam.some_classmethod()\n{'args': (), 'cls': <class '__main__.Spam'>, 'kwargs': {}}\n\n>>> Spam.some_classmethod(1, 2, a=3, b=4)\n{'args': (1, 2),\n 'cls': <class '__main__.Spam'>,\n 'kwargs': {'a': 3, 'b': 4}} \n```", "```py\n# Staticmethods are also identical\n>>> spam.some_staticmethod(1, 2, a=3, b=4)\n{'args': (1, 2), 'kwargs': {'a': 3, 'b': 4}}\n\n>>> Spam.some_staticmethod()\n{'args': (), 'kwargs': {}}\n\n>>> Spam.some_staticmethod(1, 2, a=3, b=4)\n{'args': (1, 2), 'kwargs': {'a': 3, 'b': 4}} \n```", "```py\n>>> class Spam:\n...     def __init__(self, spam=1):\n...         self.spam = spam\n...\n...     def __get__(self, instance, cls):\n...         return self.spam + instance.eggs\n...\n...     def __set__(self, instance, value):\n...         instance.eggs = value - self.spam\n\n>>> class Sandwich:\n...     spam = Spam(5)\n...\n...     def __init__(self, eggs):\n...         self.eggs = eggs\n\n>>> sandwich = Sandwich(1)\n>>> sandwich.eggs\n1\n>>> sandwich.spam\n6\n\n>>> sandwich.eggs = 10\n>>> sandwich.spam\n15 \n```", "```py\n>>> import functools\n\n>>> class ClassMethod(object):\n...     def __init__(self, method):\n...         self.method = method\n... \n...     def __get__(self, instance, cls):\n...         @functools.wraps(self.method)\n...         def method(*args, **kwargs):\n...             return self.method(cls, *args, **kwargs)\n...\n...         return method\n\n>>> class StaticMethod(object):\n...     def __init__(self, method):\n...         self.method = method\n... \n...     def __get__(self, instance, cls):\n...         return self.method\n\n>>> class Sandwich:\n...     spam = 'class'\n...\n...     def __init__(self, spam):\n...         self.spam = spam\n...\n...     @ClassMethod\n...     def some_classmethod(cls, arg):\n...         return cls.spam, arg\n...\n...     @StaticMethod\n...     def some_staticmethod(arg):\n...         return Sandwich.spam, arg\n\n>>> sandwich = Sandwich('instance')\n>>> sandwich.spam\n'instance'\n>>> sandwich.some_classmethod('argument')\n('class', 'argument')\n>>> sandwich.some_staticmethod('argument')\n('class', 'argument') \n```", "```py\n>>> import functools\n\n>>> class Sandwich(object):\n...     def get_eggs(self):\n...         print('getting eggs')\n...         return self._eggs\n...\n...     def set_eggs(self, eggs):\n...         print('setting eggs to %s' % eggs)\n...         self._eggs = eggs\n...\n...     def delete_eggs(self):\n...         print('deleting eggs')\n...         del self._eggs\n...\n...     eggs = property(get_eggs, set_eggs, delete_eggs)\n...\n...     @property\n...     def spam(self):\n...         print('getting spam')\n...         return self._spam\n...\n...     @spam.setter\n...     def spam(self, spam):\n...         print('setting spam to %s' % spam)\n...         self._spam = spam\n...\n...     @spam.deleter\n...     def spam(self):\n...         print('deleting spam')\n...         del self._spam\n...\n...     @functools.cached_property\n...     def bacon(self):\n...         print('getting bacon')\n...         return 'bacon!'\n\n>>> sandwich = Sandwich()\n\n>>> sandwich.eggs = 123\nsetting eggs to 123\n\n>>> sandwich.eggs\ngetting eggs\n123\n>>> del sandwich.eggs\ndeleting eggs\n>>> sandwich.bacon\ngetting bacon\n'bacon!' \n>>> sandwich.bacon\n'bacon!' \n```", "```py\n>>> class Property(object):\n...     def __init__(self, fget=None, fset=None, fdel=None):\n...         self.fget = fget\n...         self.fset = fset\n...         self.fdel = fdel\n... \n...     def __get__(self, instance, cls):\n...         if instance is None:\n...             # Redirect class (not instance) properties to self\n...             return self\n...         elif self.fget:\n...             return self.fget(instance)\n... \n...     def __set__(self, instance, value):\n...         self.fset(instance, value)\n... \n...     def __delete__(self, instance):\n...         self.fdel(instance)\n... \n...     def getter(self, fget):\n...         return Property(fget, self.fset, self.fdel)\n... \n...     def setter(self, fset):\n...         return Property(self.fget, fset, self.fdel)\n... \n...     def deleter(self, fdel):\n...         return Property(self.fget, self.fset, fdel) \n```", "```py\n>>> class Sandwich:\n...     @Property\n...     def eggs(self):\n...         return self._eggs\n...\n...     @eggs.setter\n...     def eggs(self, value):\n...         self._eggs = value\n...\n...     @eggs.deleter\n...     def eggs(self):\n...         del self._eggs\n\n>>> sandwich = Sandwich()\n>>> sandwich.eggs = 5\n>>> sandwich.eggs\n5 \n```", "```py\n>>> class Sandwich(object):\n...     def __init__(self):\n...         self.registry = {}\n...\n...     def __getattr__(self, key):\n...         print('Getting %r' % key)\n...         return self.registry.get(key, 'Undefined')\n...\n...     def __setattr__(self, key, value):\n...         if key == 'registry':\n...             object.__setattr__(self, key, value)\n...         else:\n...             print('Setting %r to %r' % (key, value))\n...             self.registry[key] = value\n...\n...     def __delattr__(self, key):\n...         print('Deleting %r' % key)\n...         del self.registry[key]\n\n>>> sandwich = Sandwich()\n\n>>> sandwich.a\nGetting 'a'\n'Undefined'\n\n>>> sandwich.a = 1\nSetting 'a' to 1\n\n>>> sandwich.a\nGetting 'a'\n1\n\n>>> del sandwich.a\nDeleting 'a' \n```", "```py\n>>> import functools\n\n>>> def singleton(cls):\n...     instances = dict()\n...     @functools.wraps(cls)\n...     def _singleton(*args, **kwargs):\n...         if cls not in instances:\n...             instances[cls] = cls(*args, **kwargs)\n...         return instances[cls]\n...     return _singleton\n\n>>> @singleton\n... class SomeSingleton(object):\n...     def __init__(self):\n...         print('Executing init')\n\n>>> a = SomeSingleton()\nExecuting init\n>>> b = SomeSingleton()\n\n>>> a is b\n\nTrue\n>>> a.x = 123\n>>> b.x\n123 \n```", "```py\n>>> import functools\n\n>>> class Value(object):\n...     def __init__(self, value):\n...         self.value = value\n...                                                               \n...     def __repr__(self):\n...         return f'<{self.__class__.__name__} {self.value}>'\n\n>>> class Spam(Value):\n...     def __gt__(self, other):\n...         return self.value > other.value\n...                                                                \n...     def __ge__(self, other):\n...         return self.value >= other.value\n...                                                                \n...     def __lt__(self, other):\n...         return self.value < other.value\n...                                                                \n...     def __le__(self, other):\n...         return self.value <= other.value\n...                                                                \n...     def __eq__(self, other):\n...         return self.value == other.value\n\n>>> @functools.total_ordering\n... class Egg(Value):\n...     def __lt__(self, other):\n...         return self.value < other.value\n...                                                                  \n...     def __eq__(self, other):\n...         return self.value == other.value \n```", "```py\n>>> numbers = [4, 2, 3, 4]\n>>> spams = [Spam(n) for n in numbers]\n>>> eggs = [Egg(n) for n in numbers]\n\n>>> spams\n[<Spam 4>, <Spam 2>, <Spam 3>, <Spam 4>]\n\n>>> eggs\n[<Egg 4>, <Egg 2>, <Egg 3>, <Egg 4>]\n\n>>> sorted(spams)\n[<Spam 2>, <Spam 3>, <Spam 4>, <Spam 4>]\n\n>>> sorted(eggs)\n[<Egg 2>, <Egg 3>, <Egg 4>, <Egg 4>]\n\n# Sorting using key is of course still possible and in this case\n# perhaps just as easy:\n>>> values = [Value(n) for n in numbers]\n>>> values\n[<Value 4>, <Value 2>, <Value 3>, <Value 4>]\n\n>>> sorted(values, key=lambda v: v.value)\n[<Value 2>, <Value 3>, <Value 4>, <Value 4>] \n```", "```py\n>>> def sort_by_attribute(attr, keyfunc=getattr):\n...     def _sort_by_attribute(cls):\n...         def __lt__(self, other):\n...             return getattr(self, attr) < getattr(other, attr)\n...                                           \n...         def __eq__(self, other):\n...             return getattr(self, attr) <= getattr(other, attr)\n...                                           \n...         cls.__lt__ = __lt__               \n...         cls.__eq__ = __eq__               \n...                                 \n...         return functools.total_ordering(cls)\n...\n...     return _sort_by_attribute\n\n>>> class Value(object):\n...     def __init__(self, value):\n...         self.value = value\n...         \n...     def __repr__(self):\n...         return f'<{self.__class__.__name__} {self.value}>'\n\n>>> @sort_by_attribute('value')\n... class Spam(Value):\n...     pass\n\n>>> numbers = [4, 2, 3, 4]\n>>> spams = [Spam(n) for n in numbers]\n>>> sorted(spams)\n[<Spam 2>, <Spam 3>, <Spam 4>, <Spam 4>] \n```", "```py\n`int some_integer = 123;` \n```", "```py\n`some_integer = 123` \n```", "```py\n`some_integer: int = 123` \n```", "```py\n`'spam' + 5` \n```", "```py\n>>> import functools\n\n>>> @functools.singledispatch\n... def show_type(argument):\n...     print(f'argument: {argument}')\n\n>>> @show_type.register(int)\n... def show_int(argument):\n...     print(f'int argument: {argument}')\n\n>>> @show_type.register\n... def show_float(argument: float):\n...     print(f'float argument: {argument}')\n\n>>> show_type('abc')\nargument: abc\n\n>>> show_type(123)\nint argument: 123\n\n>>> show_type(1.23)\nfloat argument: 1.23 \n```", "```py\n>>> import functools\n\n>>> registry = dict()\n\n>>> def register(function):\n...     # Fetch the first type from the type annotation but be\n...     # careful not to overwrite the 'type' function\n...     type_ = next(iter(function.__annotations__.values()))\n...     registry[type_] = function\n...\n...     @functools.wraps(function)\n...     def _register(argument):\n...         # Fetch the function using the type of argument, and\n...         # fall back to the main function\n...         new_function = registry.get(type(argument), function)\n...         return new_function(argument)\n...\n...     return _register\n\n>>> @register\n... def show_type(argument: any):\n...     print(f'argument: {argument}')\n\n>>> @register\n... def show_int(argument: int):\n...     print(f'int argument: {argument}')\n\n>>> show_type('abc')\nargument: abc\n\n>>> show_type(123)\nint argument: 123 \n```", "```py\n>>> import json\n>>> import functools\n\n>>> @functools.singledispatch\n... def write_as_json(file, data):\n...     json.dump(data, file)\n\n>>> @write_as_json.register(str)\n... @write_as_json.register(bytes)\n... def write_as_json_filename(file, data):\n...     with open(file, 'w') as fh:\n...         write_as_json(fh, data)\n\n>>> data = dict(a=1, b=2, c=3)\n>>> write_as_json('test1.json', data)\n>>> write_as_json(b'test2.json', 'w')\n>>> with open('test3.json', 'w') as fh:\n...     write_as_json(fh, data) \n```", "```py\n>>> write_as_json.registry.keys()\ndict_keys([<class 'bytes'>, <class 'object'>, <class 'str'>]) \n```", "```py\nwith open(filename) as fh:\n    pass \n```", "```py\n>>> class Open:\n...     def __init__(self, filename, mode):\n...         self.filename = filename\n...         self.mode = mode\n...\n...     def __enter__(self):\n...         self.handle = open(self.filename, self.mode)\n...         return self.handle\n...\n...     def __exit__(self, exc_type, exc_val, exc_tb):\n...         self.handle.close()\n\n>>> with Open('test.txt', 'w') as fh:\n...     print('Our test is complete!', file=fh) \n```", "```py\n>>> import contextlib\n\n>>> @contextlib.contextmanager\n... def open_context_manager(filename, mode='r'):\n...     fh = open(filename, mode)\n...     yield fh\n...     fh.close()\n\n>>> with open_context_manager('test.txt', 'w') as fh:\n...     print('Our test is complete!', file=fh) \n```", "```py\n>>> import contextlib\n\n>>> with contextlib.closing(open('test.txt', 'a')) as fh:\n...     print('Yet another test', file=fh) \n```", "```py\n>>> @contextlib.contextmanager\n... def debug(name):\n...     print(f'Debugging {name}:')\n...     yield\n...     print(f'Finished debugging {name}')\n\n>>> @debug('spam')\n... def spam():\n...     print('This is the inside of our spam function')\n\n>>> spam()\nDebugging spam:\nThis is the inside of our spam function\nFinished debugging spam \n```", "```py\n>>> def sandwich(bacon: float, eggs: int):\n...     pass \n```", "```py\n>>> import inspect\n>>> import functools\n\n>>> def enforce_type_hints(function):\n...     # Construct the signature from the function which contains\n...     # the type annotations\n...     signature = inspect.signature(function)\n... \n...     @functools.wraps(function)\n...     def _enforce_type_hints(*args, **kwargs):\n...         # Bind the arguments and apply the default values\n...         bound = signature.bind(*args, **kwargs)\n...         bound.apply_defaults()\n... \n...         for key, value in bound.arguments.items():\n...             param = signature.parameters[key]\n...             # The annotation should be a callable\n...             # type/function so we can cast as validation\n...             if param.annotation:\n...                 bound.arguments[key] = param.annotation(value)\n... \n...         return function(*bound.args, **bound.kwargs)\n... \n...     return _enforce_type_hints\n\n>>> @enforce_type_hints\n... def sandwich(bacon: float, eggs: int):\n...     print(f'bacon: {bacon!r}, eggs: {eggs!r}')\n\n>>> sandwich(1, 2)\nbacon: 1.0, eggs: 2\n>>> sandwich(3, 'abc')\nTraceback (most recent call last):\n...\nValueError: invalid literal for int() with base 10: 'abc' \n```", "```py\n>>> import warnings\n>>> import functools\n\n>>> def ignore_warning(warning, count=None):\n...     def _ignore_warning(function):\n...         @functools.wraps(function)\n...         def __ignore_warning(*args, **kwargs):\n...             # Execute the code while catching all warnings\n...             with warnings.catch_warnings(record=True) as ws:\n...                 # Catch all warnings of the given type\n...                 warnings.simplefilter('always', warning)\n...                 # Execute the function\n...                 result = function(*args, **kwargs)\n... \n...             # Re-warn all warnings beyond the expected count\n...             if count is not None:\n...                 for w in ws[count:]:\n...                     warnings.warn(w.message)\n... \n...             return result\n...\n...         return __ignore_warning\n...\n...     return _ignore_warning\n\n>>> @ignore_warning(DeprecationWarning, count=1)\n... def spam():\n...     warnings.warn('deprecation 1', DeprecationWarning)\n...     warnings.warn('deprecation 2', DeprecationWarning)\n\n# Note, we use catch_warnings here because doctests normally\n# capture the warnings quietly\n>>> with warnings.catch_warnings(record=True) as ws:\n...     spam()\n...\n...     for i, w in enumerate(ws):\n...         print(w.message)\ndeprecation 2 \n```"]