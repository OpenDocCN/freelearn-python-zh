<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Scripting with Runners"><div class="book" id="1CQAE2-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Scripting with Runners</h1></div></div></div><p class="calibre8">One of the design principles behind Unix is that programs should be small, doing only one thing, but doing it well. Execution modules follow this pattern, using functions that normally do only one thing, grouped with related functions into modules. When a function is executed, it performs that job, and then returns.</p><p class="calibre8">In Unix, these small programs can be combined together using a shell script, which ties them into a more powerful tool. Salt's runner system brings that element of scripting to Salt, using the same language that Salt itself is written in: Python. In this chapter, we will discuss:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Connecting to Salt's local client</li><li class="listitem">Adding extra logic to execution modules</li><li class="listitem">Troubleshooting runners</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Scripting with Runners">
<div class="book" title="Using Salt's local client"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec40" class="calibre1"/>Using Salt's local client</h1></div></div></div><p class="calibre8">Runners were<a id="id197" class="calibre1"/> originally designed to run on the Master, to combine multiple jobs across Minions into one complete task. In order to communicate with those Minions, a runner needs to use <code class="email">local_client</code>. Unlike other components, this is not built directly into runners; you need to initialize the client yourself. Let's set up a quick example:</p><div class="informalexample"><pre class="programlisting">import salt.client
client = salt.client.get_local_client(__opts__['conf_file'])
minions = client.cmd('*', 'test.ping', timeout=__opts__['timeout'])</pre></div><p class="calibre8">These three lines form the basis of setting up and using the local client. First, we import the <code class="email">salt.client</code> library. Then, we instantiate a client object, which is used to communicate to Salt. When creating that client object, you do need to tell it where to find Salt's configuration file. Luckily, this is something we get for free in the <code class="email">__opts__</code> dictionary, and we're unlikely to need to change it, so that line in your code will probably always look exactly like what we've done here.</p><p class="calibre8">The last line uses the <code class="email">client</code> object to issue a command to a target. What is returned from that is a list of the Minions that responded, within the specified timeout. Let's go ahead and break out that last line into components, and discuss each one:</p><div class="informalexample"><pre class="programlisting">minions = client.cmd(
    '*',  # The target to use
    'test.ping',  # The command to issue
    timeout=__opts__['timeout']  # How long to wait for a response
)</pre></div><p class="calibre8">By now, you <a id="id198" class="calibre1"/>should be used to using <code class="email">'*'</code> as a target, and know that it refers to all of the Minions. And you should know that <code class="email">test.ping</code> is a standard command, often used to check and see which Minions are responding. The timeout is also required, but there's rarely a need to use anything but the configured timeout, so <code class="email">__opts__['timeout']</code> will almost always be sufficient.</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Scripting with Runners">
<div class="book" title="Using Salt's local client">
<div class="book" title="Scripting with the local client"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec60" class="calibre1"/>Scripting with the local client</h2></div></div></div><p class="calibre8">Runners, like <a id="id199" class="calibre1"/>other Salt modules, are based around functions inside of modules. The preceding code is technically correct, but it's not where it needs to be in order to be used as a runner. Let's go ahead and create a runner module called <code class="email">scan</code>, which we'll use to collect various pieces of information about all of our Minions:</p><div class="informalexample"><pre class="programlisting">'''
Scan Minions for various pieces of information

This file should be saved as salt/runners/scan.py
'''
import salt.client


__func_alias__ = {
	'up_': 'up'
}

def up_():
    '''
    Return a list of minions which are responding
    '''
    client = salt.client.get_local_client(__opts__['conf_file'])
    minions = client.cmd('*', 'test.ping', timeout=__opts__['timeout'])
    return sorted(minions.keys())</pre></div><p class="calibre8">At the moment, we don't have much, but it is functional as a runner. Our first function is called <code class="email">up</code>, but since it's considered bad form to use function names shorter than three characters, we've defined it as <code class="email">up_(),</code> and used <code class="email">__func_alias__</code> to make it callable as <code class="email">up</code>.</p><p class="calibre8">This function will <a id="id200" class="calibre1"/>connect to the local client, issue a <code class="email">test.ping</code> to all Minions, and then return a list of which Minions responded. If we were to return <code class="email">minions</code> instead of <code class="email">minions.keys()</code>, then we would get a list of all of the Minions that responded, and what they responded with. Since we know that <code class="email">test.ping</code> will always return <code class="email">True</code> (assuming that it returns in the first place), we can skip returning that data. We also sorted the list of Minions, to make it easier to read.</p><p class="calibre8">To execute this function, use the <code class="email">salt-run</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-run scan.up</strong></span>
<span class="strong"><strong class="calibre2">- achatz</strong></span>
<span class="strong"><strong class="calibre2">- dufresne</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre8">Why not create the client connection at the top of the module, so that every function can have access to it? Due to the way the loader presents modules to Salt, the <code class="email">__opts__</code> dictionary is only available inside functions, so we can't use it at the top of the module. You could hardcode the correct path, but as we all know, hardcoded data is also poor form, and to be avoided.</p><p class="calibre8">If you only want to define the client once, then consider using a private function called <code class="email">_get_conn()</code>, which returns the connection object. However, since it would only contain one line of code, and that line is unlikely to ever change, it's probably not worth it.</p></div><p class="calibre8">The <code class="email">scan.up</code> function that we've created tells us which Minions are responding, but you may be more interested in which ones aren't responding. Those are more likely to tell you when Minions are having connection issues. Let's go ahead and add a function called <code class="email">down()</code>:</p><div class="informalexample"><pre class="programlisting">import salt.key


def down():
    '''
    Return a list of minions which are NOT responding
    '''
    minions = up_()
    key = salt.key.Key(__opts__)
    keys = key.list_keys()
    return sorted(set(keys['minions']) – set(minions))</pre></div><p class="calibre8">First, we need to know which Minions have responded, but we already have a function that reports that to us, so we just use the response from that.</p><p class="calibre8">We also need a list of the Minions that are expected to return. We can get this by creating a <code class="email">salt.key</code> object, and asking it for a list of Minions whose keys have been accepted by the Master.</p><p class="calibre8">Now that we have <a id="id201" class="calibre1"/>a list of which Minions should respond, we remove the Minions that did respond from that list, and if any Minions are left in the list, then they are the ones that we can assume are down. As before, we've sorted the list of Minions as we return them, to make it easy to read:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-run scan.down</strong></span>
<span class="strong"><strong class="calibre2">- adria</strong></span>
<span class="strong"><strong class="calibre2">- trotter</strong></span>
</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Scripting with Runners">
<div class="book" title="Using Salt's local client">
<div class="book" title="Using different targets"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec61" class="calibre1"/>Using different targets</h2></div></div></div><p class="calibre8">One major difference <a id="id202" class="calibre1"/>that separates the <code class="email">salt-run</code> command from the <code class="email">salt</code> command is the inability to specify a target on the command line. This is because runners are designed to be able to determine their targets on their own.</p><p class="calibre8">Let's go ahead and update the <code class="email">up_()</code> and <code class="email">down()</code> functions to allow the user not only to specify their own target but also a target type:</p><div class="informalexample"><pre class="programlisting">def up_(tgt='*', tgt_type='glob'):
    '''
    Return a list of minions which are responding
    '''
    client = salt.client.get_local_client(__opts__['conf_file'])
    minions = client.cmd(
        tgt,
        'test.ping',
        expr_form=tgt_type,
        timeout=__opts__['timeout']
    )
    return sorted(minions.keys())


def down(tgt='*', tgt_type='glob'):
    '''
    Return a list of minions which are NOT responding
    '''
    minions = up_(tgt, tgt_type)

    key = salt.key.Key(__opts__)
    keys = key.list_keys()

    return sorted(set(keys['minions']) - set(minions))</pre></div><p class="calibre8">In our function, the <code class="email">tgt</code> argument <a id="id203" class="calibre1"/>refers to the target. The local client requires a target to be specified anyway, so we just replace <code class="email">'*'</code> in our function with <code class="email">tgt</code>. The <code class="email">tgt_type</code> is the type of target to be used. By default, Salt uses a target type of <code class="email">glob</code> anyway, but users can specify something else (<code class="email">pcre</code>, <code class="email">list</code>, and so on) if they need to. The name of this argument in the local client is <code class="email">expr_form</code>. Check the "Target Selection Options" in the output of <code class="email">salt --help</code> to see which options are supported in your version of Salt.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Scripting with Runners">
<div class="book" title="Using Salt's local client">
<div class="book" title="Combining jobs to add more logic"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec62" class="calibre1"/>Combining jobs to add more logic</h2></div></div></div><p class="calibre8">One of the <a id="id204" class="calibre1"/>most powerful things about runners is the ability to take the output from one job, and use it to start another job. First, let's define a few things about our infrastructure:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We're using Salt Virt to manage some VMs.</li><li class="listitem">Some Minions run hypervisors; others are VMs that run inside those hypervisors. Some do not run a hypervisor, but are also not a VM.</li><li class="listitem">A number of different operating systems are being used, such as Suse, CentOS, and Ubuntu.</li></ul></div><p class="calibre8">With that in mind, we need to run a report of which hypervisors are running on which operating systems.</p><p class="calibre8">We could use this Salt command to discover which Minions are running which operating systems:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt '*' grains.item os</strong></span>
</pre></div><p class="calibre8">And we could run this command to find out which Minions are virtualized:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt '*' grains.item virtual</strong></span>
</pre></div><p class="calibre8">But just because a Minion's <code class="email">virtual</code> grain is set to <code class="email">physical</code> doesn't mean it's a hypervisor. We could run this command to find out which Minions are running hypervisors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt '*' virt.is_hyper</strong></span>
</pre></div><p class="calibre8">However, there's nothing that can aggregate those data together and tell us which hypervisors are running which operating systems; so let's put together a function that can do that:</p><div class="informalexample"><pre class="programlisting">def hyper_os():
    '''
    Return a list of which operating system each hypervisor is running
    '''
    client = salt.client.get_local_client(__opts__['conf_file'])
    minions = client.cmd(
        '*',
        'virt.is_hyper',
        timeout=__opts__['timeout']
    )

    hypers = []
    for minion in minions:
        if minions[minion] is True:
            hypers.append(minion)

    return client.cmd(
        hypers,
        'grains.item',
        arg=('os',),
        expr_form='list',
        timeout=__opts__['timeout']
    )</pre></div><p class="calibre8">After we create <a id="id205" class="calibre1"/>our <code class="email">client</code> object, our first job is to see which Minions actually have a hypervisor running. Then we loop through that list and save the ones that are in another list called <code class="email">hypers</code>. Because we're storing that in list form, we can pass it to the client again with an <code class="email">expr_form</code> of <code class="email">list</code>.</p><p class="calibre8">We've also added something new. The <code class="email">grains.item</code> function expects a single argument that tells it which grain to look up. When you need to pass a list of unnamed arguments to a function, pass it in as <code class="email">arg</code>. When we run this runner, our output will look something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-run scan.hyper_os</strong></span>
<span class="strong"><strong class="calibre2">dufresne:</strong></span>
<span class="strong"><strong class="calibre2">    ----------</strong></span>
<span class="strong"><strong class="calibre2">    os:</strong></span>
<span class="strong"><strong class="calibre2">        Arch</strong></span>
</pre></div><p class="calibre8">Let's say we want to be able to run an arbitrary Salt command on any machine that shows up in that hypervisor list. We're going to do two things in our next bit of code. We're going to break <code class="email">hyper_os()</code> into two functions, called <code class="email">hypers()</code> and <code class="email">hyper_os()</code>, and then add a new function called <code class="email">hyper_cmd()</code>, which will make use of the <code class="email">hypers()</code> function:</p><div class="informalexample"><pre class="programlisting">def hypers(client=None):
    '''
    Return a list of Minions that are running hypervisors
    '''
    if client is None:
        client = salt.client.get_local_client(__opts__['conf_file'])

    minions = client.cmd(
        '*',
        'virt.is_hyper',
        timeout=__opts__['timeout']
    )

    hypers = []
    for minion in minions:
        if minions[minion] is True:
            hypers.append(minion)

    return hypers


def hyper_os():
    '''
    Return a list of which operating system each hypervisor is running
    '''
    client = salt.client.get_local_client(__opts__['conf_file'])

    return client.cmd(
        hypers(client),
        'grains.item',
        arg=('os',),
        expr_form='list',
        timeout=__opts__['timeout']
    )


def hyper_cmd(cmd, arg=None, kwarg=None):
    '''
    Execute an arbitrary command on Minions which run hypervisors
    '''
    client = salt.client.get_local_client(__opts__['conf_file'])

    if arg is None:
        arg = []

    if not isinstance(arg, list):
        arg = [arg]

    if kwarg is None:
        kwarg = {}

    return client.cmd(
        hypers(client),
        cmd,
        arg=arg,
        kwarg=kwarg,
        expr_form='list',
        timeout=__opts__['timeout']
    )</pre></div><p class="calibre8">You may notice that each function is able to create its own <code class="email">client</code> object, including <code class="email">hypers()</code>. This allows us to use <code class="email">scan.hypers</code> on its own. However, it also allows us to pass in a <code class="email">client</code> object from other functions. This can save a lot of time over creating one <code class="email">client</code> object per Salt command.</p><p class="calibre8">The <code class="email">hyper_cmd()</code> function <a id="id206" class="calibre1"/>allows us to pass in arguments in a number of different ways, or none at all if necessary. Using it without any arguments would look like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-run scan.hyper_cmd test.ping</strong></span>
</pre></div><p class="calibre8">Using it with an unnamed argument would look like:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-run scan.hyper_cmd test.ping</strong></span>
</pre></div><p class="calibre8">It starts to get tricky when you pass in a list of arguments. By default, Salt is able to convert YAML that is passed in on the command line into data structures that can be used inside of Salt. This means that you can run this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-run scan.hyper_cmd test.arg [one,two]</strong></span>
</pre></div><p class="calibre8">And Salt will automatically translate <code class="email">[one,two]</code> into a list containing a string of <code class="email">one</code> followed by a string of <code class="email">two</code>. However, that is not what will happen if you run this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-run scan.hyper_cmd test.arg one,two</strong></span>
</pre></div><p class="calibre8">In this case, Salt will think that you have passed in a string whose value is <code class="email">one,two</code>. If you wanted to allow users to enter lists like that, you would need to detect and parse them out manually.</p><p class="calibre8">It gets even trickier if you want to pass in named arguments. The following is valid:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">salt-run scan.hyper_cmd network.interface kwarg="{'iface':'wlp3s0'}"</strong></span>
</pre></div><p class="calibre8">But it's pretty horrible to ask users to type that in. Let's go ahead and shrink our function down by using <a id="id207" class="calibre1"/>Python's own <code class="email">*</code> and <code class="email">**</code> tools, which allow us to accept arbitrary lists and dictionaries from the command line:</p><div class="informalexample"><pre class="programlisting">def hyper_cmd(cmd, *arg, **kwarg):
    '''
    Execute an arbitrary command on Minions which run hypervisors
    '''
    client = salt.client.get_local_client(__opts__['conf_file'])

    return client.cmd(
        hypers(client),
        cmd,
        arg=arg,
        kwarg=kwarg,
        expr_form='list',
        timeout=__opts__['timeout']
    )</pre></div><p class="calibre8">Now we can run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-run scan.hyper_cmd test.kwarg iface='wlp3s0'</strong></span>
</pre></div></div></div></div>
<div class="book" title="The final module" id="1DOR01-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec41" class="calibre1"/>The final module</h1></div></div></div><p class="calibre8">With all of <a id="id208" class="calibre1"/>our code in place, the final module will look like:</p><div class="informalexample"><pre class="programlisting">'''
Scan Minions for various pieces of information

This file should be saved as salt/runners/scan.py
'''
import salt.client
import salt.key


__func_alias__ = {
    'up_': 'up'
}

def up_(tgt='*', tgt_type='glob'):
    '''
    Return a list of minions which are responding
    '''
    client = salt.client.get_local_client(__opts__['conf_file'])
    minions = client.cmd(
        tgt,
        'test.ping',
        expr_form=tgt_type,
        timeout=__opts__['timeout']
    '''
    Return a list of minions which are NOT responding
    '''
    minions = up_(tgt, tgt_type)

    key = salt.key.Key(__opts__)
    keys = key.list_keys()

    return sorted(set(keys['minions']) - set(minions))


def hypers(client=None):
    '''
    Return a list of Minions that are running hypervisors
    '''
    if client is None:
        client = salt.client.get_local_client(__opts__['conf_file'])

    minions = client.cmd(
        '*',
        'virt.is_hyper',
        timeout=__opts__['timeout']
    )

    hypers = []
    for minion in minions:
        if minions[minion] is True:
            hypers.append(minion)

    return hypers


def hyper_os():
    '''
    Return a list of which operating system each hypervisor is running
    '''
    client = salt.client.get_local_client(__opts__['conf_file'])

    return client.cmd(
        hypers(client),
        'grains.item',
        arg=('os',),
        expr_form='list',
        timeout=__opts__['timeout']
    )


def hyper_cmd(cmd, *arg, **kwarg):
    '''
    Execute an arbitrary command on Minions which run hypervisors
    '''
    client = salt.client.get_local_client(__opts__['conf_file'])

    return client.cmd(
        hypers(client),
        cmd,
        arg=arg,
        kwarg=kwarg,
        expr_form='list',
        timeout=__opts__['timeout']
    )</pre></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Troubleshooting runners" id="1ENBI1-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec42" class="calibre1"/>Troubleshooting runners</h1></div></div></div><p class="calibre8">In a <a id="id209" class="calibre1"/>way, runners are a little easier to troubleshoot than other types of modules. For <a id="id210" class="calibre1"/>instance, even though they run on the Master, they don't need the <code class="email">salt-master</code> service to be restarted to pick up new changes. In fact, unless you're using the local client, you don't actually have to have the <code class="email">salt-master </code>service running.</p></div>

<div class="book" title="Troubleshooting runners" id="1ENBI1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Working with the salt-master service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec63" class="calibre1"/>Working with the salt-master service</h2></div></div></div><p class="calibre8">If you are <a id="id211" class="calibre1"/>using the local client, and you try to issue a command without the <code class="email">salt-master</code> service running, you will get an error that looks like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-run scan.hyper_os</strong></span>
<span class="strong"><strong class="calibre2">Exception occurred in runner scan.hyper_os: Traceback (most recent call last):</strong></span>
<span class="strong"><strong class="calibre2">  File "/usr/lib/python2.7/site-packages/salt/client/mixins.py", line 340, in low</strong></span>
<span class="strong"><strong class="calibre2">    data['return'] = self.functions[fun](*args, **kwargs)</strong></span>
<span class="strong"><strong class="calibre2">  File "/usr/lib/python2.7/site-packages/salt/runners/scan.py", line 68, in hyper_os</strong></span>
<span class="strong"><strong class="calibre2">    hypers(client),</strong></span>
<span class="strong"><strong class="calibre2">  File "/usr/lib/python2.7/site-packages/salt/runners/scan.py", line 50, in hypers</strong></span>
<span class="strong"><strong class="calibre2">    timeout=__opts__['timeout']</strong></span>
<span class="strong"><strong class="calibre2">  File "/usr/lib/python2.7/site-packages/salt/client/__init__.py", line 562, in cmd</strong></span>
<span class="strong"><strong class="calibre2">    **kwargs)</strong></span>
<span class="strong"><strong class="calibre2">  File "/usr/lib/python2.7/site-packages/salt/client/__init__.py", line 317, in run_job</strong></span>
<span class="strong"><strong class="calibre2">    raise SaltClientError(general_exception)</strong></span>
<span class="strong"><strong class="calibre2">SaltClientError: Salt request timed out. The master is not responding. If this error persists after verifying the master is up, worker_threads may need to be increased.</strong></span>
</pre></div><p class="calibre8">This is because, <a id="id212" class="calibre1"/>although runners themselves don't rely on the <code class="email">salt-master</code> service, Minions do rely on it to receive commands, and send responses back to the Master.</p></div></div>

<div class="book" title="Troubleshooting runners" id="1ENBI1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Timeout issues"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec64" class="calibre1"/>Timeout issues</h2></div></div></div><p class="calibre8">If the <a id="id213" class="calibre1"/>Master is running properly and you're not receiving the responses that you expect, think about the targets that you're hitting. It is very common for a runner to issue commands to all Minions, but if you're testing in a large infrastructure, or you have keys on your Master that belong to Minions which are inaccessible or no longer exist, then runner commands can take a long time to return.</p><p class="calibre8">While writing your modules, you may want to consider changing the target from <code class="email">'*'</code> to one specific Minion, or perhaps to a specific list of Minions (with the <code class="email">expr_form</code> set to <code class="email">'list'</code>, as we did in our <code class="email">hyper_os()</code> and <code class="email">hyper_cmd()</code> functions). Just make sure you set it back before you push it into production.</p></div></div>
<div class="book" title="Summary" id="1FLS41-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec43" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Runners add a scripting element to Salt, using Python. They are designed to run on the Master, but do not require the <code class="email">salt-master</code> service to be running, unless they are using the local client to issue commands to Minions. Runners are designed to manage targeting on their own, but you can add elements to allow users to specify targets anyway. They are especially useful for using the output from one job as input for another job, which allows you to wrap your own logic around execution modules.</p><p class="calibre8">In the next chapter, we will allow the Master to use external sources to store the files that it serves to its Minions. Next up: adding external file servers.</p></div></body></html>