<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer321" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">18</h1>&#13;
    <h1 id="_idParaDest-535" class="chapterTitle">Packaging – Creating Your Own Libraries or Applications</h1>&#13;
    <p class="normal">The chapters thus far have covered how to write, test, and debug Python code. With all of that, there is only one thing that remains: packaging and distributing your Python libraries and applications. To create installable packages, we will use the <code class="inlineCode">setuptools</code> package, which is bundled with Python these days. If you have created packages before, you might remember <code class="inlineCode">distribute</code> and <code class="inlineCode">distutils2</code>, but it is very important to remember that these have been replaced by <code class="inlineCode">setuptools</code> and <code class="inlineCode">distutils</code> and you shouldn’t use them anymore!</p>&#13;
    <p class="normal">We have several types of packages and packaging methods to cover:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Building new-style packages using the PEP 517/518 <code class="inlineCode">pyproject.toml</code> file</li>&#13;
      <li class="bulletList">Advanced package building using the <code class="inlineCode">setup.py</code> file</li>&#13;
      <li class="bulletList">Package types: wheels, eggs, source packages, and others</li>&#13;
      <li class="bulletList">Installing executables and custom <code class="inlineCode">setuptools</code> commands</li>&#13;
      <li class="bulletList">Packages containing C/C++ extensions</li>&#13;
      <li class="bulletList">Running tests on the package </li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-536" class="heading-1">Introduction to packages</h1>&#13;
    <p class="normal">Python has a very messy history <a id="_idIndexMarker1589"/>when it comes to packaging. Over the decades that Python has existed, we have (had) libraries such as <code class="inlineCode">distutils</code>, <code class="inlineCode">distutils2</code>, <code class="inlineCode">distribute</code>, <code class="inlineCode">buildout</code>, <code class="inlineCode">setuptools</code>, <code class="inlineCode">packaging</code>, <code class="inlineCode">distlib</code>, <code class="inlineCode">poetry</code>, and several others. All of these projects were started with the best intentions to improve upon the status quo, unfortunately with varying degrees of success. And that is not to mention all the different package types such as wheels, source packages, and binary packages such as eggs, Red Hat <code class="inlineCode">.rpm</code> files, and Windows <code class="inlineCode">.exe</code>/<code class="inlineCode">.msi</code> files.</p>&#13;
    <p class="normal">The good news is that <a id="_idIndexMarker1590"/>even though packaging has had a complicated history, things have started to settle over the last few years and the situation has improved greatly. Building packages has become much easier, and maintaining a stable project dependency state is now easily possible.</p>&#13;
    <h2 id="_idParaDest-537" class="heading-2">Types of packages</h2>&#13;
    <p class="normal">Python has (had) a whole bunch of package types, but there are only two that really matter these days:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="keyWord">Wheels</strong>: These are <a id="_idIndexMarker1591"/>small, ready-to-install <code class="inlineCode">.zip</code> files with a <code class="inlineCode">.whl</code> extension that only<a id="_idIndexMarker1592"/> need extraction as opposed to the building a source package would need. Additionally, these can be either source or binary, depending on the package.</li>&#13;
      <li class="bulletList"><strong class="keyWord">Source packages</strong>: These <a id="_idIndexMarker1593"/>can have many extensions <a id="_idIndexMarker1594"/>such as <code class="inlineCode">.zip</code>, <code class="inlineCode">.tar</code>, <code class="inlineCode">.tar.gz</code>, <code class="inlineCode">.tar.bz2</code>, <code class="inlineCode">.tar.xz</code>, and <code class="inlineCode">.tar.Z</code>. They contain the Python/C/etc. source and data files needed to install and build the package.</li>&#13;
    </ul>&#13;
    <p class="normal">Now we’ll go into a bit more detail about the formats.</p>&#13;
    <h3 id="_idParaDest-538" class="heading-3">Wheels – The new eggs</h3>&#13;
    <p class="normal">For pure Python packages, the<a id="_idIndexMarker1595"/> source packages have always been enough. For binary C/C++ packages, however, it is a much less convenient option. The problem with C/C++ source packages is that compilation is needed, which requires not only a compiler but often <a id="_idIndexMarker1596"/>headers and libraries on the system as well. With binary packages, you usually don’t need a compiler or any other libraries installed because the required libraries are bundled with the package; Python itself is enough.</p>&#13;
    <p class="normal">Traditionally, Python used the <code class="inlineCode">.egg</code> format for binary packages. The <code class="inlineCode">.egg</code> format is, in essence, just a renamed <code class="inlineCode">.zip</code> file containing the source code and metadata, and in the case of binary <code class="inlineCode">.egg</code> files also the compiled binaries. While the idea was great, <code class="inlineCode">.egg</code> files never really solved the problem quite right; an <code class="inlineCode">.egg</code> file could match multiple environments, but that was no guarantee of it actually running on those systems. </p>&#13;
    <p class="normal">That is why the <code class="inlineCode">wheel</code> format was introduced (<code class="inlineCode">PEP-427</code>), a package format that can contain both source and binary files and can be installed on Windows, Linux, macOS X, and other systems without requiring a compiler.</p>&#13;
    <p class="normal">As an added bonus, wheels can install both pure Python and binary packages more quickly because there are no build, install, or post-processing steps and because they are smaller. Installing a wheel only requires extracting the <code class="inlineCode">.whl</code> file to the <code class="inlineCode">site-packages</code> directory of your Python environment and you are done.</p>&#13;
    <p class="normal">The biggest issue binary<a id="_idIndexMarker1597"/> wheels solve over eggs is the naming of files. With wheels, this is <a id="_idIndexMarker1598"/>done in a simple and consistent way so that checking for the existence of a compatible wheel can be done by filename alone. The files use the following format:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">{distribution}-{version}[-{build tag}]-{python tag}-{abi tag}-{platform tag}.whl&#13;
</code></pre>&#13;
    <p class="normal">Let’s dive into these fields and look at what their possible values are. But first, the syntax. The names between the <code class="inlineCode">{</code> and <code class="inlineCode">}</code> parentheses are the fields, and the <code class="inlineCode">[</code> and <code class="inlineCode">]</code> parentheses indicate an optional field:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">distribution</code>: The name of the package, e.g. <code class="inlineCode">numpy</code>, <code class="inlineCode">scipy</code>, etc.</li>&#13;
      <li class="bulletList"><code class="inlineCode">version</code>: The version of the package, e.g. <code class="inlineCode">1.2.3</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">build tag</code>: An optional build number as a tie-breaker if multiple wheels match.</li>&#13;
      <li class="bulletList"><code class="inlineCode">python tag</code>: The Python version and platform. In the case of CPython 3.10, this would be <code class="inlineCode">cp310</code>. For PyPy 3.10, this would be <code class="inlineCode">pp310</code>. You can read more about this in <code class="inlineCode">PEP-425</code>. For pure Python packages, this is either <code class="inlineCode">py3</code> for Python 3 support or <code class="inlineCode">py2.py3</code> for universal packages that support both Python 2 and Python 3.</li>&#13;
      <li class="bulletList"><code class="inlineCode">abi tag</code>: The ABI (application binary interface) tag indicates the required Python ABI. <code class="inlineCode">cp310d</code> would be CPython 3.10 with debugging enabled, for example. More details can be found in <code class="inlineCode">PEP-3149</code>. In the case of a pure Python package, this is usually <code class="inlineCode">none</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">platform tag</code>: The platform tag tells you the operating systems it will run on. This can be <code class="inlineCode">win32</code> or <code class="inlineCode">win_amd64</code> for 32-bit or 64-bit Windows respectively. For macOS X, this could be something like <code class="inlineCode">macosx_11_0_arm64</code>. For pure Python packages, this is usually <code class="inlineCode">any</code>.</li>&#13;
    </ul>&#13;
    <p class="normal">With all of these different options, you can probably guess that to support many platforms you will need many wheels. This is actually a good thing, as it solves one of the big issues of egg files, namely that installable files did not always work. If you can find a matching wheel for your system, you can expect it to work without any issues.</p>&#13;
    <p class="normal">The downside is the build time required for all of these wheels. The <code class="inlineCode">numpy</code> package, for example, has 29 different wheels at the time of writing. Each of these wheels takes between 15 and 45 minutes to build, so if we take an average of 30 minutes per wheel, we end up with 15 <a id="_idIndexMarker1599"/>hours of build time for each <code class="inlineCode">numpy</code> release. Naturally, they can be <a id="_idIndexMarker1600"/>built in parallel, but it is something to take into consideration.</p>&#13;
    <p class="normal">Even though we have 29 different wheels available for <code class="inlineCode">numpy</code>, there is still no support for many platforms, such as FreeBSD, so the need for a source package also remains.</p>&#13;
    <h3 id="_idParaDest-539" class="heading-3">Source packages</h3>&#13;
    <p class="normal">Source packages are<a id="_idIndexMarker1601"/> the most versatile out of all the types of Python packages. They contain the source, build scripts, and potentially many other files such as <a id="_idIndexMarker1602"/>documentation and tests. These allow you to build and/or compile the package for your system. Source packages can have many different extensions, such as <code class="inlineCode">.zip</code> and <code class="inlineCode">.tar.bz2</code>, but are basically a slightly stripped-down version of the entire project directory and related files.</p>&#13;
    <p class="normal">Since these packages often contain not only the straight-up source files but also tests and documentation, they take up more space and are slower to install than wheels. Looking at the source package for <code class="inlineCode">numpy</code>, for example, I currently see 1941 files, whereas the wheel only contains 710 files. This difference can actually be useful as well because you might have a use for the test files or the documentation. If you wish to skip the binary files because you wish to have the original sources or if you want an optimized build for your specific system, you can opt for installing the source files by telling <code class="inlineCode">pip</code> to skip the binary files.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">Installing the package from the source instead of the binaries can result in a smaller and/or faster binary because it will only link to the libraries available on your system instead of being universal.</p>&#13;
      <p class="normal">The <code class="inlineCode">psycopg</code> package for connecting to PostgreSQL databases is a good example of this. It offers three possible installation options to install through <code class="inlineCode">pip</code> in descending order of preference:</p>&#13;
    </div>&#13;
    <div class="note">&#13;
      <ul>&#13;
        <li class="bulletList"><code class="inlineCode">psycopg[c]</code>: Both the Python and the C source files for building and compiling locally</li>&#13;
        <li class="bulletList"><code class="inlineCode">psycopg[binary]</code>: The Python source and precompiled binaries</li>&#13;
        <li class="bulletList"><code class="inlineCode">psycopg</code>: The Python source only; in this case, you need to have the <code class="inlineCode">libpq</code> library installed on your system, which is accessed through <code class="inlineCode">ctypes</code></li>&#13;
      </ul>&#13;
    </div>&#13;
    <p class="normal">To install without any pre-compiled binaries: </p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> pip3 install --no-binary ...&#13;
</code></pre>&#13;
    <p class="normal">Since a source<a id="_idIndexMarker1603"/> package comes with a build script, the installation alone<a id="_idIndexMarker1604"/> can already be dangerous. While a wheel will only unpack and not run anything, a source package will execute the build scripts during installation. At one point, there was even a Russian Roulette package on PyPI that would have a 1/6 chance of deleting files on your system during installation to illustrate the dangers of this approach.</p>&#13;
    <p class="normal">I personally think the security risk of executing build scripts during installion is of much less importance than vetting a package before you even plan to install it. Installing potentially malicious packages on your system is a bad idea, whether or not you actually execute the code.</p>&#13;
    <h2 id="_idParaDest-540" class="heading-2">Package tools</h2>&#13;
    <p class="normal">So, what <a id="_idIndexMarker1605"/>tools do we still need and use for installation these days?</p>&#13;
    <p class="normal">The <code class="inlineCode">distribute</code>, <code class="inlineCode">distutils</code>, and <code class="inlineCode">distutils2</code> packages have largely been replaced by <code class="inlineCode">setuptools</code>. To install a <code class="inlineCode">setup.py</code> based source package, you usually need <code class="inlineCode">setuptools</code>, and <code class="inlineCode">setuptools</code> comes bundled with <code class="inlineCode">pip</code>, so that is a requirement you should already have available. When it comes to installing wheels, you need the <code class="inlineCode">wheel</code> package; this is also conveniently bundled with <code class="inlineCode">pip</code>. On most systems, this means that you should have everything you need to install extra packages once Python is installed.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The Ubuntu Linux distribution is unfortunately a notable exception which ships with a mutilated Python installation that lacks both the <code class="inlineCode">pip</code> and <code class="inlineCode">ensurepip</code> commands. This can be fixed by installing <code class="inlineCode">pip</code> separately using:</p>&#13;
      <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> apt install python3-pip&#13;
</code></pre>&#13;
      <p class="normal">If that does not work, you can always install <code class="inlineCode">pip</code> by running the <code class="inlineCode">get-pip.py</code> script: <a href="https://bootstrap.pypa.io/get-pip.py"><span class="url">https://bootstrap.pypa.io/get-pip.py</span></a></p>&#13;
    </div>&#13;
    <p class="normal">Since <code class="inlineCode">setuptools</code> and <code class="inlineCode">pip</code> have seen quite a lot of development over the last few years, it might be a good <a id="_idIndexMarker1606"/>idea to upgrade these packages in any case:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install --upgrade pip setuptools wheel&#13;
</code></pre>&#13;
    <p class="normal">Now that we have all the prerequisites installed, we can continue with building our own packages. </p>&#13;
    <h1 id="_idParaDest-541" class="heading-1">Package versioning</h1>&#13;
    <p class="normal">While there are many versioning <a id="_idIndexMarker1607"/>schemes available, many Python packages, and Python itself, use PEP-440 for the version specifications.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Some people adhere to the <a id="_idIndexMarker1608"/>slightly stricter version called <strong class="keyWord">semantic versioning</strong> (<strong class="keyWord">SemVer</strong>), but the two are largely compatible.</p>&#13;
    </div>&#13;
    <p class="normal">The short and simplified explanation is that version numbers such as <code class="inlineCode">1.2</code> or <code class="inlineCode">1.2.3</code> are used. For instance, looking at version <code class="inlineCode">1.2.3</code>:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">1</code> is the major version and indicates API-breaking incompatible changes</li>&#13;
      <li class="bulletList"><code class="inlineCode">2</code> is the minor version and indicates backward-compatible functionality addition</li>&#13;
      <li class="bulletList"><code class="inlineCode">3</code> is the patch version, which is used for backward-compatible bugfixes</li>&#13;
    </ul>&#13;
    <p class="normal">In the case of major versions, some libraries opt for making the versions non-contiguous and use dates for the versions, such as <code class="inlineCode">2022.5</code>.</p>&#13;
    <p class="normal">Pre-releases such as alphas and betas can be specified through the minor version with letters. The options are <code class="inlineCode">a</code> for alpha, <code class="inlineCode">b</code> for beta, and <code class="inlineCode">rc</code> for release candidate. This results in <code class="inlineCode">1.2a3</code> for <code class="inlineCode">1.2 alpha 3</code>, for instance.</p>&#13;
    <p class="normal">In the case of semantic versioning, this is handled by adding a pre-release identifier to the end, such as <code class="inlineCode">1.2.3-beta</code> or <code class="inlineCode">1.2.3-beta.1</code> for multiple betas.</p>&#13;
    <p class="normal">Lastly, PEP-440 allows the use of post-releases using <code class="inlineCode">1.2.post3</code> instead of <code class="inlineCode">1.2.3</code> for minor bugfixes, and similarly <code class="inlineCode">1.2.dev2</code> for development releases.</p>&#13;
    <p class="normal">Whichever versioning system<a id="_idIndexMarker1609"/> you use, think about it carefully before starting your project. Not taking the future into account can certainly cause problems in the long run. An example of this is Windows. Some applications had trouble supporting Windows 10 because an alphabetical sort of version number puts Windows 10 below Window 8 (after all, 1 is smaller than 8).</p>&#13;
    <h1 id="_idParaDest-542" class="heading-1">Building packages</h1>&#13;
    <p class="normal">Python packages were<a id="_idIndexMarker1610"/> traditionally built using a <code class="inlineCode">setup.py</code> file that contained (part of) the build script. This method usually depends on <code class="inlineCode">setuptools</code> and is still the standard for most packages, but we have easier methods available these days. If your project is not too demanding, you can use a small <code class="inlineCode">pyproject.toml</code> file instead, which can be much easier to maintain.</p>&#13;
    <p class="normal">Let’s give both methods a try and see how easy it is to build a basic Python package. </p>&#13;
    <h2 id="_idParaDest-543" class="heading-2">Packaging using pyproject.toml</h2>&#13;
    <p class="normal">The <code class="inlineCode">pyproject.toml</code> file <a id="_idIndexMarker1611"/>allows for really easy packaging depending on the tooling used. It was introduced in 2015 through <code class="inlineCode">PEP-517</code> and <code class="inlineCode">PEP-518</code>. This method was created to improve upon the <code class="inlineCode">setup.py</code> file by introducing build-time dependencies, automatic configuration, and making it easier to work in a DRY (Don’t Repeat Yourself) manner.</p>&#13;
    <div class="note">&#13;
      <p class="normal">TOML stands for “Tom’s Obvious, Minimal Language” and is somewhat comparable to YAML and INI files, but a bit simpler. Since it is such a simple language, it can easily be included in packages such as <code class="inlineCode">pip</code> with little overhead. This makes it perfect for scenarios where you need a flat structure and have no need for complicated features such as inheritance and includes.</p>&#13;
    </div>&#13;
    <p class="normal">Before we continue, we need to clarify a few things. When we talk about the <code class="inlineCode">setup.py</code> file, we are often actually talking about the <code class="inlineCode">setuptools</code> library instead. The <code class="inlineCode">distutils</code> library, which is bundled with Python, can be used as well, but since <code class="inlineCode">pip</code> depends on <code class="inlineCode">setuptools</code> it is often the better option; it has more features, and updates together with <code class="inlineCode">pip</code> instead of with your Python installation.</p>&#13;
    <p class="normal">Similar to how <code class="inlineCode">setup.py</code> usually means <code class="inlineCode">setuptools</code>, with <code class="inlineCode">pyproject.toml</code> we also have multiple libraries available for building and managing <code class="inlineCode">PEP-517</code> style packages. This approach to creating a standard and relying on community projects for the implementations has worked quite well for Python in the past, which makes it a sound choice. An example of this approach is the Python Web Server Gateway Interface (WSGI), which was introduced as <code class="inlineCode">PEP-333</code> and currently has several great implementations available.</p>&#13;
    <p class="normal">The reference solution for <code class="inlineCode">PEP-517</code> is the <code class="inlineCode">pep517</code> library, which works but is rather limited. Another option is the <code class="inlineCode">build</code> library, which is maintained by the Python Package Authority (PyPA), which also maintains the Python Package Index (PyPI). While that library works, it is also really limited in terms of features and not an option I would recommend either.</p>&#13;
    <p class="normal">The best option by far, in <a id="_idIndexMarker1612"/>my opinion, is the <code class="inlineCode">poetry</code> tool. The <code class="inlineCode">poetry</code> tool not only handles the building of packages for you but also takes care of:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Fast installing of dependencies in parallel</li>&#13;
      <li class="bulletList">Creating virtual environments</li>&#13;
      <li class="bulletList">Creating easy access points for runnable scripts</li>&#13;
      <li class="bulletList">Managing dependencies by specifying smart version constraints (for example, major and minor versions, covered in detail later in this chapter)</li>&#13;
      <li class="bulletList">Building packages</li>&#13;
      <li class="bulletList">Publishing to PyPI</li>&#13;
      <li class="bulletList">Handling multiple Python versions using <code class="inlineCode">pyenv</code></li>&#13;
    </ul>&#13;
    <p class="normal">For most cases, <code class="inlineCode">pyproject.toml</code> can replace the traditional <code class="inlineCode">setup.py</code> files completely, but there are a few cases where you will need some extra tools.</p>&#13;
    <p class="normal">In the case of building C/C++ extensions and others, you either need a <code class="inlineCode">setup.py</code> file or to specify how to build the extensions some other way. One option for this is to use the <code class="inlineCode">poetry</code> tool and add a build script to the <code class="inlineCode">pyproject.toml</code> tool. We will discuss this more later on, in the section about C/C++ extensions.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Editable installs (i.e. <code class="inlineCode">pip install -e ...</code>) were not possible until 2021, but that has been remedied by PEP-660.</p>&#13;
    </div>&#13;
    <h3 id="_idParaDest-544" class="heading-3">Creating a basic package</h3>&#13;
    <p class="normal">Let’s start by <a id="_idIndexMarker1613"/>using <code class="inlineCode">poetry</code> to create a basic <code class="inlineCode">pyproject.toml</code> file in our current directory:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>poetry new .&#13;
Created package t_00_basic_pyproject in .&#13;
</code></pre>&#13;
    <p class="normal">Since our parent directory is called <code class="inlineCode">t_00_basic_pyproject</code>, <code class="inlineCode">poetry</code> automatically makes that the new project name. Alternatively, you can also do <code class="inlineCode">poetry new some_project_name</code> and it will create a directory for you.</p>&#13;
    <p class="normal">The <code class="inlineCode">poetry</code> command created the following files for us:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">README.rst&#13;
pyproject.toml&#13;
t_00_basic_pyproject&#13;
t_00_basic_pyproject/__init__.py&#13;
tests&#13;
tests/__init__.py&#13;
tests/test_t_00_basic_pyproject.py&#13;
</code></pre>&#13;
    <p class="normal">This is very simple boilerplate that contains enough to get your project started. The <code class="inlineCode">t_00_basic_pyproject/__init__.py</code> file contains the version (which defaults to <code class="inlineCode">0.1.0</code>) and the <code class="inlineCode">tests/test_t_00_basic_pyproject.py</code> file tests for this version as an example test. The more interesting part is the <code class="inlineCode">pyproject.toml</code> file, however, so let’s look at that now:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[tool.poetry]</span>&#13;
<span class="hljs-attr">name</span> = <span class="hljs-string">"T_00_basic_pyproject"</span>&#13;
<span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span>&#13;
<span class="hljs-attr">description</span> = <span class="hljs-string">""</span>&#13;
<span class="hljs-attr">authors</span> = [<span class="hljs-string">"Rick van Hattem &lt;Wolph@wol.ph&gt;"</span>]&#13;
&#13;
<span class="hljs-section">[tool.poetry.dependencies]</span>&#13;
<span class="hljs-attr">python</span> = <span class="hljs-string">"^3.10"</span>&#13;
&#13;
<span class="hljs-section">[tool.poetry.dev-dependencies]</span>&#13;
<span class="hljs-attr">pytest</span> = <span class="hljs-string">"^5.2"</span>&#13;
&#13;
<span class="hljs-section">[build-system]</span>&#13;
<span class="hljs-attr">requires</span> = [<span class="hljs-string">"poetry-core&gt;=1.0.0"</span>]&#13;
<span class="hljs-attr">build-backend</span> = <span class="hljs-string">"poetry.core.masonry.api"</span>&#13;
</code></pre>&#13;
    <p class="normal">As you can see, <code class="inlineCode">poetry</code> has automatically configured the name and version. It also added me as an author by looking at the <code class="inlineCode">git</code> config on my system. You can easily configure this yourself by running these commands:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>git config --global user.email 'your@email.tld'&#13;
<span class="hljs-con-meta">$ </span>git config --global user.name 'Your Name'&#13;
</code></pre>&#13;
    <p class="normal">Next up, we can see <a id="_idIndexMarker1614"/>that it automatically set Python 3.10 as a requirement and added <code class="inlineCode">pytest</code> 5.2 as a development dependency. For building the package, it added <code class="inlineCode">poetry-core</code> as a dependency, which is the <code class="inlineCode">poetry</code> equivalent of <code class="inlineCode">setuptools</code>.</p>&#13;
    <h3 id="_idParaDest-545" class="heading-3">Installing packages for development</h3>&#13;
    <p class="normal">For development<a id="_idIndexMarker1615"/> purposes, we usually install a package in <strong class="keyWord">editable mode</strong>. In editable mode, the package is not copied to your <code class="inlineCode">site-packages</code> directory, but a link is made to your source directory so all changes to your source directory apply immediately. Without editable mode, you would have to do a <code class="inlineCode">pip install</code> every time you made a change to your package, which is very inconvenient for development.</p>&#13;
    <p class="normal">With <code class="inlineCode">pip</code>, you can install in editable mode with the command:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install --editable &lt;package-directory&gt;&#13;
</code></pre>&#13;
    <p class="normal">For installing in the current directory, you can use <code class="inlineCode">.</code> as the directory, resulting in:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install --editable .&#13;
</code></pre>&#13;
    <p class="normal">With the <code class="inlineCode">poetry</code> command, installing in editable mode (or something similar for older versions of <code class="inlineCode">poetry</code>) happens automatically. It also handles the creation of a virtual environment for us while making use of <code class="inlineCode">pyenv</code> for the Python version specified in the <code class="inlineCode">pyproject.toml</code> file. To install the package and all of its requirements, you only need to run:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>poetry install&#13;
</code></pre>&#13;
    <p class="normal">If you wish to have direct access to all of the commands in the virtual environment created, you can use:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>poetry shell&#13;
(name-of-your-project) <span class="hljs-con-meta">$</span>&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">poetry shell</code> command <a id="_idIndexMarker1616"/>spawns a new shell with the name of the current project added to your command-line prefix and with the virtual environment scripts directory added to your <code class="inlineCode">PATH</code> environment variable. This results in commands such as <code class="inlineCode">python</code> and <code class="inlineCode">pip</code> executing within your virtual environment.</p>&#13;
    <h3 id="_idParaDest-546" class="heading-3">Adding code and data</h3>&#13;
    <p class="normal">In the basic<a id="_idIndexMarker1617"/> example, we didn’t have anything specifying <a id="_idIndexMarker1618"/>which directory contains the source or that the <code class="inlineCode">t_00_basic_pyproject</code> directory has to be included in the directory. By default, that is handled implicitly, but we can modify the <code class="inlineCode">pyproject.toml</code> file to explicitly include directories or file patterns as the Python source:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[tool.poetry]</span>&#13;
...&#13;
<span class="hljs-attr">packages</span> = [&#13;
    {include=<span class="hljs-string">"T_00_basic_pyproject"</span>},&#13;
    {include=<span class="hljs-string">"some_directory/**/*.py"</span>},&#13;
]&#13;
</code></pre>&#13;
    <p class="normal">Note that adding the <code class="inlineCode">packages</code> argument disables the automatic detection of packages, so you will need to specify all included packages at this point.</p>&#13;
    <p class="normal">To include other data files such as documentation, we can use the <code class="inlineCode">include</code> and <code class="inlineCode">exclude</code> parameters. The <code class="inlineCode">exclude</code> parameter overrides the files included by the <code class="inlineCode">packages</code> argument:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[tool.poetry]</span>&#13;
...&#13;
<span class="hljs-attr">include</span> = [<span class="hljs-string">"CHANGELOG.rst"</span>]&#13;
<span class="hljs-attr">exclude</span> = [<span class="hljs-string">"T_00_basic_pyproject/local.py"</span>]&#13;
</code></pre>&#13;
    <p class="normal">For a basic project, you might not need to look at this. But, as always, explicit is better than implicit, so I recommend that you do take a quick look to prevent unwanted surprises where the wrong files are accidentally included in your package.</p>&#13;
    <h3 id="_idParaDest-547" class="heading-3">Adding executable commands</h3>&#13;
    <p class="normal">Some packages such<a id="_idIndexMarker1619"/> as <code class="inlineCode">numpy</code> are libraries only, meaning they are imported but have no runnable commands. Other packages such as <code class="inlineCode">pip</code> and <code class="inlineCode">poetry</code> contain runnable scripts which are installed as new commands during installion. After all, when the <code class="inlineCode">poetry</code> package is installed, you can use the <code class="inlineCode">poetry</code> command from your shell. </p>&#13;
    <p class="normal">To create our own commands, we need to specify the name of the new command, the module, and the corresponding function, so <code class="inlineCode">poetry</code> will know what to run. For example:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[tool.poetry.scripts]</span>&#13;
<span class="hljs-attr">our_command</span> = <span class="hljs-string">'T_00_basic_pyproject.main:run'</span>&#13;
</code></pre>&#13;
    <p class="normal">This would execute the <code class="inlineCode">run()</code> function in a file called <code class="inlineCode">T_00_basic_pyproject/main.py</code>. After installing the package, you could execute <code class="inlineCode">our_command</code> from your shell to run the script. During development with <code class="inlineCode">poetry</code>, you can use <code class="inlineCode">poetry run our_command</code>, which automatically runs the command in the <code class="inlineCode">poetry</code>-created virtual environment.</p>&#13;
    <h3 id="_idParaDest-548" class="heading-3">Managing dependencies</h3>&#13;
    <p class="normal">The <code class="inlineCode">pyproject.toml</code> file we created<a id="_idIndexMarker1620"/> already had a few requirements for both development and building, but you might also want to add other dependencies to your project. For example, if we wanted to add a progress bar we could run the following:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>poetry add progressbar2&#13;
Using version ^4.0.0 for progressbar2&#13;
...&#13;
</code></pre>&#13;
    <p class="normal">This automatically installs the <code class="inlineCode">progressbar2</code> package for us and adds it to the <code class="inlineCode">pyproject.toml</code> file like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[tool.poetry.dependencies]</span>&#13;
...&#13;
<span class="hljs-attr">progressbar2</span> = <span class="hljs-string">"^4.0.0"</span>&#13;
</code></pre>&#13;
    <p class="normal">Additionally, <code class="inlineCode">poetry</code> will create or update a <code class="inlineCode">poetry.lock</code> file, which contains the exact package versions that are installed, so an installation in a new environment can easily be reproduced. In the case above, we simply told <code class="inlineCode">poetry</code> to install any version of <code class="inlineCode">progressbar2</code> which resulted in <code class="inlineCode">poetry</code> setting the version requirement to <code class="inlineCode">^4.0.0</code>, but we can relax those requirements so <code class="inlineCode">poetry</code> will automatically install the latest patch, minor, or major version of the package.</p>&#13;
    <p class="normal">By default, <code class="inlineCode">poetry</code> will add the dependencies to the <code class="inlineCode">[tool.poetry.dependencies]</code> section, but you can also add them as development dependencies using the <code class="inlineCode">--dev</code> or <code class="inlineCode">-D</code> command-line arguments. If you want to add other types of dependencies such as the <code class="inlineCode">build-system</code> dependencies or test dependencies, you will need to manually edit the <code class="inlineCode">pyproject.toml</code> file, however.</p>&#13;
    <p class="normal">The version specifiers <a id="_idIndexMarker1621"/>expect SemVer-compatible versions and work as follows. For allowing newer non-major versions, you can use the caret (<code class="inlineCode">^</code>). This looks at the first non-zero number, so the behavior of <code class="inlineCode">^1.2.3</code> is different from <code class="inlineCode">^0.1.2</code>, as follows:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">^1.2.3</code> means <code class="inlineCode">&gt;=1.2.3</code> and <code class="inlineCode">&lt;2.0.0</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">^1.2</code> means <code class="inlineCode">&gt;=1.2.0</code> and <code class="inlineCode">&lt;2.0.0</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">^1</code> means <code class="inlineCode">&gt;=1.0.0</code> and <code class="inlineCode">&lt;2.0.0</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">^0.1.2</code> means <code class="inlineCode">&gt;=0.1.2</code> and <code class="inlineCode">&lt;0.2.0</code></li>&#13;
    </ul>&#13;
    <p class="normal">Next up are the tilde (<code class="inlineCode">~</code>) requirements, which specify the minimal version but allow for minor updates. They are a bit simpler than the caret versions and effectively specify what the number should start with:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">~1.2.3</code> means <code class="inlineCode">&gt;=1.2.3</code> and <code class="inlineCode">&lt;1.3.0.</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">~1.2</code> means <code class="inlineCode">&gt;=1.2.0</code> and <code class="inlineCode">&lt;1.3.0.</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">~1</code> means <code class="inlineCode">&gt;=1.0.0</code> and <code class="inlineCode">&lt;2.0.0</code>. Note that the two options above both allow minor version updates, and this is the only one that allows major version updates.</li>&#13;
    </ul>&#13;
    <p class="normal">Wildcard requirements are also possible using an asterisk (<code class="inlineCode">*</code>):</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">1.2.*</code> means <code class="inlineCode">&gt;=1.2.0</code> and <code class="inlineCode">&lt;1.3.0</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">1.*</code> means <code class="inlineCode">&gt;=1.0.0</code> and <code class="inlineCode">&lt;2.0.0</code></li>&#13;
    </ul>&#13;
    <p class="normal">The versioning system is compatible with the format used by <code class="inlineCode">requirements.txt</code> as well, which allows for versions such as:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">&gt;= 1.2.3</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">&gt;= 1.2.3, &lt;1.4.0</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">&gt;= 1.2.3, &lt;1.4.0, != 1.3.0</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">!= 1.5.0</code></li>&#13;
    </ul>&#13;
    <p class="normal">I personally prefer this last syntax since it’s clear and doesn’t require much prior knowledge, but you are free to use whichever you prefer. By default, <code class="inlineCode">poetry</code> will use a <code class="inlineCode">^1.2.3</code> format when adding dependencies.</p>&#13;
    <p class="normal">Now, let’s say we have a requirement like <code class="inlineCode">progressbar2 = "^3.5"</code> and we have version <code class="inlineCode">3.5.0</code> in our <code class="inlineCode">poetry.lock</code> file. If we run <code class="inlineCode">poetry install</code>, it will install exactly version <code class="inlineCode">3.5.0</code> because we know that version to be good.</p>&#13;
    <p class="normal">As a developer, you might<a id="_idIndexMarker1622"/> want to update that dependency to a newer version so you can test if newer versions also work. This is also something we can ask of <code class="inlineCode">poetry</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>poetry update&#13;
Updating dependencies&#13;
...&#13;
Package operations: 0 installs, 1 update, 0 removals&#13;
  • Updating progressbar2 (3.5.0 -&gt; 3.55.0)&#13;
</code></pre>&#13;
    <p class="normal">Now <code class="inlineCode">poetry</code> will automatically upgrade the package and update the <code class="inlineCode">poetry.lock</code> file within the constraints of <code class="inlineCode">pyproject.toml</code>.</p>&#13;
    <h3 id="_idParaDest-549" class="heading-3">Building the package</h3>&#13;
    <p class="normal">Now that we <a id="_idIndexMarker1623"/>have our <code class="inlineCode">pyproject.toml</code> file configured and the dependencies we want, we can build the package. This is trivially easy using <code class="inlineCode">poetry</code>, luckily. Building the package takes a single command:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>poetry build&#13;
Building T_00_basic_pyproject (0.1.0)&#13;
  - Building sdist&#13;
  - Built T_00_basic_pyproject-0.1.0.tar.gz&#13;
  - Building wheel&#13;
  - Built T_00_basic_pyproject-0.1.0-py3-none-any.whl&#13;
</code></pre>&#13;
    <p class="normal">With just that single command, <code class="inlineCode">poetry</code> created a source package and a wheel for us. So, if you have been keeping track, you’ll realize we can essentially create and build a package with just two commands: <code class="inlineCode">poetry new</code> and <code class="inlineCode">poetry build</code>.</p>&#13;
    <h3 id="_idParaDest-550" class="heading-3">Building C/C++ extensions</h3>&#13;
    <p class="normal">Before we start with<a id="_idIndexMarker1624"/> this section, I need to provide a little disclaimer. Building C/C++ extensions is at the time of writing (the end of 2021) not a stable and supported feature by <code class="inlineCode">poetry</code>, which means it could be replaced by a different mechanism in the future. For the time being, however, there is a working solution available for building C/C++ extensions and future versions are likely to work in a similar fashion.</p>&#13;
    <p class="normal">If you are looking for a stable and well-supported solution right now, I would suggest going with a <code class="inlineCode">setup.py</code> based project instead as covered later in this chapter. </p>&#13;
    <p class="normal">We need to start by modifying our <code class="inlineCode">pyproject.toml</code> file and adding the following line to the <code class="inlineCode">[tool.poetry]</code> section:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">build</span> = <span class="hljs-string">"build_extension.py"</span>&#13;
</code></pre>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">Make sure you don’t name the file <code class="inlineCode">build.py</code> if you ever wish to use the PyPA build command.</p>&#13;
    </div>&#13;
    <p class="normal">Once this is done, <code class="inlineCode">poetry</code> will execute the <code class="inlineCode">build_extension.py</code> file when we run <code class="inlineCode">poetry build</code>, so now we need to create the <code class="inlineCode">build_extension.py</code> file so <code class="inlineCode">setuptools</code> can build the extension for us:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pathlib&#13;
<span class="hljs-keyword">import</span> setuptools&#13;
&#13;
<span class="hljs-comment"># Get the current directory</span>&#13;
PROJECT_PATH = pathlib.Path(__file__).parent&#13;
&#13;
<span class="hljs-comment"># Create the extension object with the references to the C source</span>&#13;
sum_of_squares = setuptools.Extension(<span class="hljs-string">'sum_of_squares'</span>, sources=[&#13;
    <span class="hljs-comment"># Get the relative path to sum_of_squares.c</span>&#13;
    <span class="hljs-built_in">str</span>(PROJECT_PATH / <span class="hljs-string">'</span><span class="hljs-string">sum_of_squares.c'</span>),&#13;
])&#13;
&#13;
<span class="hljs-keyword">def</span> <span class="hljs-title">build</span>(<span class="hljs-params">setup_kwargs</span>):&#13;
    setup_kwargs[<span class="hljs-string">'ext_modules'</span>] = [sum_of_squares] &#13;
</code></pre>&#13;
    <p class="normal">This script is largely the same as what you would put in the <code class="inlineCode">setup.py</code> file. The reason for this is that it’s actually injecting into the same function call. If you look carefully at the <code class="inlineCode">build()</code> function, you will see that it updates <code class="inlineCode">setup_kwargs</code> and sets the <code class="inlineCode">ext_modules</code> item within that. That argument is fed to the <code class="inlineCode">setuptools.setup()</code> function verbatim. Essentially, we are just emulating the use of a <code class="inlineCode">setup.py</code> file.</p>&#13;
    <p class="normal">Note that for our C file we used the <code class="inlineCode">sum_of_squares.c</code> file from <em class="chapterRef">Chapter 17, </em><em class="italic">Extensions in C/C++, System Calls, and C/C++ Libaries</em>. You will see that the rest of the code largely resembles the <code class="inlineCode">setup.py</code> file we used in <em class="chapterRef">Chapter 17</em>.</p>&#13;
    <p class="normal">When we execute<a id="_idIndexMarker1625"/> the <code class="inlineCode">poetry build</code> command, <code class="inlineCode">poetry</code> will automatically call <code class="inlineCode">setuptools</code> internally and build the binary wheel:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>poetry build&#13;
Building T_01_pyproject_extensions (0.1.0)&#13;
  - Building sdist&#13;
  - Built T_01_pyproject_extensions-0.1.0.tar.gz&#13;
  - Building wheel&#13;
running build&#13;
running build_py&#13;
creating build&#13;
...&#13;
running build_ext&#13;
building 'sum_of_squares' extension&#13;
...&#13;
</code></pre>&#13;
    <p class="normal">With that, we are done. We now have a wheel file containing the built C extension.</p>&#13;
    <h2 id="_idParaDest-551" class="heading-2">Packaging using setuptools with setup.py or setup.cfg</h2>&#13;
    <p class="normal">The <code class="inlineCode">setup.py</code> file is the <a id="_idIndexMarker1626"/>traditional method of building Python packages, but is still used quite extensively and is a very flexible method of creating packages.</p>&#13;
    <p class="normal"><em class="chapterRef">Chapter 17</em> has already shown us a couple of examples when building extensions, but let’s reiterate and review what the most important parts actually do. The core function you will be using in this entire chapter is <code class="inlineCode">setuptools.setup()</code>.</p>&#13;
    <div class="note">&#13;
      <p class="normal">The <code class="inlineCode">distutils</code> package bundled with Python will be sufficient as well in most cases, but I recommend <code class="inlineCode">setuptools</code> regardless. The <code class="inlineCode">setuptools</code> package has many great features that <code class="inlineCode">distutils</code> lacks and nearly all Python environments will have <code class="inlineCode">setuptools</code> available as it is included with <code class="inlineCode">pip</code>.</p>&#13;
    </div>&#13;
    <p class="normal">Before we continue, it is always a good idea to make sure you have the latest version of <code class="inlineCode">pip</code>, <code class="inlineCode">wheel</code>, and <code class="inlineCode">setuptools</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install -U pip wheel setuptools&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="normal">The <code class="inlineCode">setuptools</code> and <code class="inlineCode">distutils</code> packages have changed significantly over the last few years and the documentation/examples written before 2014 are most likely out of date. Be careful not to implement deprecated examples, and I would recommend skipping any documentation/examples using <code class="inlineCode">distutils</code>.</p>&#13;
    </div>&#13;
    <p class="normal">As an alternative or addition to the <code class="inlineCode">setup.py</code> file, you can also configure all metadata using a <code class="inlineCode">setup.cfg</code> file. This uses the INI format and can be a bit more convenient for simple metadata where you do not need (or want) the overhead of the Python syntax.</p>&#13;
    <p class="normal">You can even <a id="_idIndexMarker1627"/>choose to use <code class="inlineCode">setup.cfg</code> alone and skip <code class="inlineCode">setup.py</code>; however, if you did, you would need a separate building utility. For those cases, I would recommend installing PyPA’s <code class="inlineCode">build</code> library:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install build&#13;
...&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-552" class="heading-3">Creating a basic package</h3>&#13;
    <p class="normal">Now that we have all the <a id="_idIndexMarker1628"/>prerequisites, let’s create a package using a <code class="inlineCode">setup.py</code> file. While the most basic <code class="inlineCode">setuptools.setup()</code> call technically doesn’t require any parameters, you should really include at least the <code class="inlineCode">name</code>, <code class="inlineCode">version</code>, <code class="inlineCode">packages</code>, <code class="inlineCode">url</code>, <code class="inlineCode">author</code>, and <code class="inlineCode">author_email</code> fields if you plan to publish the package to PyPI. Here’s a really basic example containing these fields:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> setuptools&#13;
&#13;
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:&#13;
    setuptools.setup(&#13;
        name=<span class="hljs-string">'T_02_basic_setup_py'</span>,&#13;
        version=<span class="hljs-string">'0.1.0'</span>,&#13;
        packages=setuptools.find_packages(),&#13;
        url=<span class="hljs-string">'</span><span class="hljs-string">https://wol.ph/'</span>,&#13;
        author=<span class="hljs-string">'Rick van Hattem'</span>,&#13;
        author_email=<span class="hljs-string">'wolph@wol.ph'</span>,&#13;
    )&#13;
</code></pre>&#13;
    <p class="normal">As an alternative to configuring these as <code class="inlineCode">setup()</code> parameters, you can also use a <code class="inlineCode">setup.cfg</code> file, which uses the INI format but works in effectively the same way:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">[metadata]&#13;
name = T_03_basic_setup_cfg&#13;
version = <span class="hljs-number">0.1.0</span>&#13;
url=<span class="hljs-string">'https://wol.ph/'</span>,&#13;
author=<span class="hljs-string">'Rick van Hattem'</span>,&#13;
author_email=<span class="hljs-string">'wolph@wol.ph'</span>,&#13;
&#13;
[options]&#13;
packages = find:&#13;
</code></pre>&#13;
    <p class="normal">The main advantage of <code class="inlineCode">setup.cfg</code> is that it is a more concise and simpler file format than the <code class="inlineCode">setup.py</code> file is. Take a look at the <code class="inlineCode">packages</code> section, for example; <code class="inlineCode">setuptools.find_packages()</code> is quite a bit more verbose than <code class="inlineCode">find:</code>.</p>&#13;
    <p class="normal">The downside is <a id="_idIndexMarker1629"/>that you need to pair a <code class="inlineCode">setup.cfg</code> file with either a <code class="inlineCode">setup.py</code> or <code class="inlineCode">pyproject.toml</code> file to be able to build it. <code class="inlineCode">setup.cfg</code> alone is not enough for a package, which makes <code class="inlineCode">setup.cfg</code> a nice and clean way to separate your metadata from your setup code. Additionally, many libraries such as <code class="inlineCode">pytest</code> and <code class="inlineCode">tox</code> have native support for the <code class="inlineCode">setup.cfg</code> file, so these can be configured through the file as well.</p>&#13;
    <p class="normal">To pair <code class="inlineCode">setup.cfg</code> and/or <code class="inlineCode">setup.py</code> with a <code class="inlineCode">pyproject.toml</code> file, we need to add these lines to the <code class="inlineCode">pyproject.toml</code> file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[build-system]</span>&#13;
<span class="hljs-attr">requires</span> = [<span class="hljs-string">"setuptools"</span>, <span class="hljs-string">"wheel"</span>]&#13;
<span class="hljs-attr">build-backend</span> = <span class="hljs-string">"setuptools.build_meta"</span>&#13;
</code></pre>&#13;
    <p class="normal">Note that a <code class="inlineCode">pyproject.toml</code> file by itself won’t give you <code class="inlineCode">poetry</code> support; for <code class="inlineCode">poetry</code> support, you need to add a <code class="inlineCode">[tool.poetry]</code> section.</p>&#13;
    <h3 id="_idParaDest-553" class="heading-3">Installing the package for development</h3>&#13;
    <p class="normal">To install the package<a id="_idIndexMarker1630"/> for local development, we can once again use the <code class="inlineCode">-e</code> or <code class="inlineCode">--editable</code> flag, as explained in the <code class="inlineCode">poetry</code> section of this chapter. This installs a link from your source directory to the <code class="inlineCode">site-packages</code> directory so the actual source is used, instead of having <code class="inlineCode">setuptools</code> copy all of the source files to the <code class="inlineCode">site-packages</code> directory.</p>&#13;
    <p class="normal">In short, from the project directory you can either use the <code class="inlineCode">setup.py</code> file:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 setup.py develop&#13;
</code></pre>&#13;
    <p class="normal">Or <code class="inlineCode">pip</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install -e .&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-554" class="heading-3">Adding packages</h3>&#13;
    <p class="normal">In the basic <a id="_idIndexMarker1631"/>example, you could see that we used <code class="inlineCode">find_packages()</code> as the argument for packages. This automatically detects all source directories and is usually fine as a default, but sometimes you need more control. The <code class="inlineCode">find_packages()</code> function also allows you to add an <code class="inlineCode">include</code> or <code class="inlineCode">exclude</code> parameter if you wish to exclude tests and other files from the package, like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">setuptools.find_packages(&#13;
    include=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c.*'</span>],&#13;
    exclude=[<span class="hljs-string">'a.excluded'</span>],&#13;
)&#13;
</code></pre>&#13;
    <p class="normal">The arguments to <code class="inlineCode">find_packages()</code> can also be translated to a <code class="inlineCode">setup.cfg</code> file with a slightly different syntax:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">[options]&#13;
packages = find:&#13;
&#13;
[options.packages.find]&#13;
include =&#13;
    a&#13;
    b&#13;
    c.*&#13;
exclude = a.excluded&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-555" class="heading-3">Adding package data</h3>&#13;
    <p class="normal">In most scenarios, you<a id="_idIndexMarker1632"/> probably won’t have to include the package data such as test data or documentation files, but there are cases where you need extra files. Web applications, for example, might come bundled with <code class="inlineCode">html</code>, <code class="inlineCode">javascript</code>, and <code class="inlineCode">css</code> files.</p>&#13;
    <p class="normal">There are a few different options for including extra files with your package. First, it is important to know which files are included in your source package by default:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Python source files in the package directories and all their subdirectories</li>&#13;
      <li class="bulletList">The <code class="inlineCode">setup.py</code>, <code class="inlineCode">setup.cfg</code>, and <code class="inlineCode">pyproject.toml</code> files</li>&#13;
      <li class="bulletList">Readme files if available, such as <code class="inlineCode">README.rst</code>, <code class="inlineCode">README.txt</code>, and <code class="inlineCode">README.md</code></li>&#13;
      <li class="bulletList">Metadata files containing the package name, version, entry points, file hashes, and so on</li>&#13;
    </ul>&#13;
    <p class="normal">For Python wheels the list is even shorter, and only the Python source and the metadata files will be packaged by default.</p>&#13;
    <p class="normal">This means that if we want to include other files, we need to specify that those need to be added. We have two different options for adding other types of data to our package.</p>&#13;
    <p class="normal">First of all, we can enable the <code class="inlineCode">include_package_data</code> flag as an argument to <code class="inlineCode">setup()</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    setuptools.setup(&#13;
        ...&#13;
        include_package_data=<span class="hljs-literal">True</span>,&#13;
    )&#13;
</code></pre>&#13;
    <p class="normal">Once that flag is enabled, we can specify what file patterns we want in a <code class="inlineCode">MANIFEST.in</code> file. This file contains patterns to include, exclude, and more. The <code class="inlineCode">include</code> and <code class="inlineCode">exclude</code> commands use patterns to match. These patterns are glob-style patterns (see the <code class="inlineCode">glob</code> module for documentation: <a href="https://docs.python.org/3/library/glob.html"><span class="url">https://docs.python.org/3/library/glob.html</span></a>) and have three variants for both the <code class="inlineCode">include</code> and <code class="inlineCode">exclude</code> commands:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">include</code>/<code class="inlineCode">exclude</code>: These commands only work for the given path and nothing else</li>&#13;
      <li class="bulletList"><code class="inlineCode">recursive-include</code>/<code class="inlineCode">recursive-exclude</code>: These commands are similar to the <code class="inlineCode">include</code>/<code class="inlineCode">exclude</code> commands, but process the given paths recursively</li>&#13;
      <li class="bulletList"><code class="inlineCode">global-include</code>/<code class="inlineCode">global-exclude</code>: Be very careful with these, as they will include or exclude these files anywhere within the source tree</li>&#13;
    </ul>&#13;
    <p class="normal">Besides the <code class="inlineCode">include</code>/<code class="inlineCode">exclude</code> commands, there are also two others: the <code class="inlineCode">graft</code> and <code class="inlineCode">prune</code> commands, which include or exclude directories including all the files under a given <a id="_idIndexMarker1633"/>directory. This can be useful for tests and documentation, since they can include non-standard files. Beyond those examples, it’s almost always better to explicitly include the files you need and ignore all the others. Here’s an example <code class="inlineCode">MANIFEST.in</code> file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Include all documentation files</span>&#13;
include-recursive *.rst&#13;
include LICENSE&#13;
&#13;
<span class="hljs-comment"># Include docs and tests</span>&#13;
graft tests&#13;
graft docs&#13;
&#13;
<span class="hljs-comment"># Skip compiled python files</span>&#13;
global-exclude *.py<span class="hljs-section">[co]</span>&#13;
&#13;
<span class="hljs-comment"># Remove all build directories</span>&#13;
prune docs/_build&#13;
prune build&#13;
prune dist&#13;
</code></pre>&#13;
    <p class="normal">Alternatively, we can use the <code class="inlineCode">package_data</code> and <code class="inlineCode">exclude_package_data</code> arguments and add them to <code class="inlineCode">setup.py</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    setuptools.setup(&#13;
        ...&#13;
        package_data={&#13;
            <span class="hljs-comment"># Include all documentation files</span>&#13;
            <span class="hljs-string">''</span>: [<span class="hljs-string">'*.rst'</span>],&#13;
&#13;
            <span class="hljs-comment"># Include docs and tests</span>&#13;
            <span class="hljs-string">'tests'</span>: [<span class="hljs-string">'*'</span>],&#13;
            <span class="hljs-string">'docs'</span>: [<span class="hljs-string">'*'</span>],&#13;
        },&#13;
        exclude_package_data={&#13;
            <span class="hljs-string">''</span>: [<span class="hljs-string">'*.pyc'</span>, <span class="hljs-string">'*.pyo'</span>],&#13;
            <span class="hljs-string">'dist'</span>: [<span class="hljs-string">'*'</span>],&#13;
            <span class="hljs-string">'build'</span>: [<span class="hljs-string">'*'</span>],&#13;
        },&#13;
    )&#13;
</code></pre>&#13;
    <p class="normal">Naturally, these also <a id="_idIndexMarker1634"/>have an equivalent <code class="inlineCode">setup.cfg</code> format:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">[options]&#13;
...&#13;
include_package_data=<span class="hljs-literal">True</span>,&#13;
&#13;
[options.package_data]&#13;
<span class="hljs-comment"># Include all documentation files</span>&#13;
* = *.rst&#13;
&#13;
<span class="hljs-comment"># Include docs and tests</span>&#13;
tests = *&#13;
docs = *&#13;
&#13;
[options.exclude_package_data]&#13;
* = *.pyc, *.pyo&#13;
dist = *&#13;
build = *&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="normal">Note that these parameters use <code class="inlineCode">package_data</code> instead of <code class="inlineCode">data</code> for a reason. All of these require you to use a package. That means that data will only be included if it’s inside a proper Python package (in other words, if it contains an <code class="inlineCode">__init__.py</code>).</p>&#13;
    </div>&#13;
    <p class="normal">You can choose whichever format and method you prefer.</p>&#13;
    <h3 id="_idParaDest-556" class="heading-3">Managing dependencies</h3>&#13;
    <p class="normal">When you are using a <code class="inlineCode">setup.py</code> or <code class="inlineCode">setup.cfg</code> file, you don’t get the easy dependency management <a id="_idIndexMarker1635"/>that <code class="inlineCode">poetry</code> provides. Adding new dependencies is not much harder, except that you need to add the requirement and install the package yourself instead of doing it all in a single command.</p>&#13;
    <p class="normal">As is the case with <code class="inlineCode">pyproject.toml</code>, there are multiple types of dependencies that you can declare:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">[build-system] requires</code>: These are the requirements to build the project. These are usually <code class="inlineCode">setuptools</code> and <code class="inlineCode">wheel</code> for <code class="inlineCode">setuptools-b</code>ased packages; for <code class="inlineCode">poetry</code> this would be <code class="inlineCode">poetry-core</code>.</li>&#13;
      <li class="bulletList"><code class="inlineCode">[options] install_requires</code>: These are the requirements to be able to run the package. A project such as <code class="inlineCode">pandas</code> will have a requirement for <code class="inlineCode">numpy</code>, for example.</li>&#13;
      <li class="bulletList"><code class="inlineCode">[options.extras_require] NAME_OF_EXTRA</code>: If your project has optional dependencies for specific circumstances, the extras can help. For example, to install <code class="inlineCode">portalocker</code> with <code class="inlineCode">redis</code> support, you can run this command: </li>&#13;
    </ul>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install "portalocker[redis]"&#13;
</code></pre>&#13;
    <p class="normal">If you have experience with creating packages, you might wonder why <code class="inlineCode">tests_require</code> is not shown here. The reason is that there is no real need for it anymore since <code class="inlineCode">extras_require</code> was added. You can simply add an extra requirement for <code class="inlineCode">tests</code> and <code class="inlineCode">docs</code> instead.</p>&#13;
    <p class="normal">Here’s an example <a id="_idIndexMarker1636"/>of adding a few requirements to a <code class="inlineCode">setup.py</code> file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">setuptools.setup(&#13;
    ...&#13;
    setup_requires=[<span class="hljs-string">'pytest-runner'</span>],&#13;
    install_requires=[<span class="hljs-string">'portalocker'</span>],&#13;
    extras_require={&#13;
        <span class="hljs-string">'docs'</span>: [<span class="hljs-string">'sphinx'</span>],&#13;
        <span class="hljs-string">'tests'</span>: [<span class="hljs-string">'pytest'</span>],&#13;
    },&#13;
)&#13;
</code></pre>&#13;
    <p class="normal">Here is the equivalent in a <code class="inlineCode">setup.cfg</code> file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">[build-system]&#13;
requires =&#13;
    setuptools&#13;
    wheel&#13;
&#13;
[options]&#13;
install_requires =&#13;
    portalocker&#13;
&#13;
[options.extras_require]&#13;
docs = sphinx&#13;
tests = pytest&#13;
</code></pre>&#13;
    <h3 id="_idParaDest-557" class="heading-3">Adding executable commands</h3>&#13;
    <p class="normal">As is the case <a id="_idIndexMarker1637"/>with a <code class="inlineCode">pyproject.toml</code>-based project, we can specify executable commands using the <code class="inlineCode">setup.py</code> or <code class="inlineCode">setup.cfg</code> files as well. To add a basic executable command similar to how we can run the <code class="inlineCode">pip</code> or <code class="inlineCode">ipython</code> commands, we can add <code class="inlineCode">entry_points</code> to our <code class="inlineCode">setup.py</code> file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">setuptools.setup(&#13;
...&#13;
    entry_points={&#13;
        <span class="hljs-string">'console_scripts'</span>: [&#13;
            <span class="hljs-string">'our_command = T_02_basic_setup_py.main:run'</span>,&#13;
        ],&#13;
    },&#13;
</code></pre>&#13;
    <p class="normal">Or the <code class="inlineCode">setup.cfg</code> equivalent:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">[options.entry_points]&#13;
console_scripts =&#13;
    our_command = T_03_basic_setup_cfg.main:run&#13;
</code></pre>&#13;
    <p class="normal">Once you have installed this package you can run <code class="inlineCode">our_command</code> from your shell, similar to how you would run a command like <code class="inlineCode">pip</code> or <code class="inlineCode">ipython</code>.</p>&#13;
    <p class="normal">From the examples above, you might wonder if we have other options besides <code class="inlineCode">console_scripts</code>, and the answer is yes. One example is <code class="inlineCode">distutils.commands</code>, which can be used to add extra commands to <code class="inlineCode">setup.py</code>. By adding a command in that namespace, you can do:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 setup.py our_command&#13;
</code></pre>&#13;
    <p class="normal">The most prominent example of this behavior, however, is the <code class="inlineCode">pytest</code> library. The <code class="inlineCode">pytest</code> library uses these entry points to automatically detect plugins that are compatible with <code class="inlineCode">pytest</code>. We could easily create our own equivalent:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">[options.entry_points]&#13;
our.custom.plugins =&#13;
    some_plugin = T_03_basic_setup_cfg.some_plugin:run&#13;
</code></pre>&#13;
    <p class="normal">Once you have packages like these installed, you can query them through <code class="inlineCode">importlib</code> like so:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> importlib <span class="hljs-con-keyword">import</span> metadata&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> metadata.entry_points()[<span class="hljs-con-string">'our.custom.plugins'</span>]&#13;
[EntryPoint(name='some_plugin', value='...some_plugin:run', ...]&#13;
</code></pre>&#13;
    <p class="normal">This is a very <a id="_idIndexMarker1638"/>useful feature for automatically registering plugins across libraries.</p>&#13;
    <h3 id="_idParaDest-558" class="heading-3">Building the package</h3>&#13;
    <p class="normal">To actually build the<a id="_idIndexMarker1639"/> package, we have a few options. I personally use the <code class="inlineCode">setup.py</code> file if it is available:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 setup.py build sdist bdist_wheel&#13;
running build&#13;
...&#13;
creating 'dist/T_02_basic_setup-0.1.0-py3-none-any.whl' and adding ...&#13;
</code></pre>&#13;
    <p class="normal">If you only have a <code class="inlineCode">setup.cfg</code> and <code class="inlineCode">pyproject.toml</code> available, you will need to install a package to invoke the builder. In addition to <code class="inlineCode">poetry</code>, PyPA provides a tool called <code class="inlineCode">build</code> for this, which creates an isolated environment for building the package:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 -m build&#13;
* Creating venv isolated environment...&#13;
...&#13;
Successfully built T_02_basic_setup-0.1.0.tar.gz and T_02_basic_setup-0.1.0-py3-none-any.whl&#13;
</code></pre>&#13;
    <p class="normal">Both the wheel and the source package are written to the <code class="inlineCode">dist</code> directory and they are ready for publishing.</p>&#13;
    <h1 id="_idParaDest-559" class="heading-1">Publishing packages</h1>&#13;
    <p class="normal">Now that we have<a id="_idIndexMarker1640"/> the packages built, we need to actually publish them to PyPI. There are several different options we can use, but let’s discuss some optional package metadata first.</p>&#13;
    <h2 id="_idParaDest-560" class="heading-2">Adding URLs</h2>&#13;
    <p class="normal">Our <code class="inlineCode">setup.py</code> and <code class="inlineCode">setup.cfg</code> files <a id="_idIndexMarker1641"/>already contained a <code class="inlineCode">url</code> parameter that will be used as the package homepage on PyPI. However, we can add more relevant URLs by configuring the <code class="inlineCode">project_urls</code> setting, which is an arbitrary map of name/URL pairs. For <code class="inlineCode">settings.py</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">    setuptools.setup(&#13;
        ...&#13;
        project_urls=<span class="hljs-built_in">dict</span>(&#13;
            docs=<span class="hljs-string">'https://progressbar-2.readthedocs.io/'</span>,&#13;
        ),&#13;
    )&#13;
</code></pre>&#13;
    <p class="normal">Or for <code class="inlineCode">settings.cfg</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">[options]&#13;
project_urls=&#13;
    docs=https://progressbar-<span class="hljs-number">2.</span>readthedocs.io/&#13;
</code></pre>&#13;
    <p class="normal">Similarly, for <code class="inlineCode">pyproject.toml</code> using <code class="inlineCode">poetry</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[tool.poetry.urls]</span>&#13;
<span class="hljs-attr">docs</span>=<span class="hljs-string">'https://progressbar-2.readthedocs.io/'</span>&#13;
</code></pre>&#13;
    <h2 id="_idParaDest-561" class="heading-2">PyPI trove classifiers</h2>&#13;
    <p class="normal">To increase the<a id="_idIndexMarker1642"/> exposure of your package on PyPI, it can be useful to add a few classifiers. Some classifiers such as the Python version and the license are automatically added for you, but it can be useful to specify what kind of library or application you are writing.</p>&#13;
    <p class="normal">There are many examples of useful classifiers for people interested in your packages:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><strong class="keyWord">Development status</strong>: This can vary from “planning” to “mature” and tells your users whether an application is ready for production. People’s definitions of what is stable or beta differs, of course, so this is usually considered a hint at most.</li>&#13;
      <li class="bulletList"><strong class="keyWord">Framework</strong>: The framework(s) you are using or extending. This could be Jupyter, IPython, Django, Flask, and so on.</li>&#13;
      <li class="bulletList"><strong class="keyWord">Topic</strong>: Whether this is a software development package, scientific, a game, and so on.</li>&#13;
    </ul>&#13;
    <p class="normal">A full list of<a id="_idIndexMarker1643"/> classifiers can be found on the PyPI website: <a href="https://pypi.org/classifiers/"><span class="url">https://pypi.org/classifiers/</span></a></p>&#13;
    <h2 id="_idParaDest-562" class="heading-2">Uploading to PyPI</h2>&#13;
    <p class="normal">Uploading and publishing your <a id="_idIndexMarker1644"/>package to PyPI is really easy. Perhaps too easy, as we will see in the case of <code class="inlineCode">twine</code>.</p>&#13;
    <p class="normal">Before we get started, to prevent you from accidentally publishing your package to PyPI, you should be aware of the PyPI test server: <a href="https://packaging.python.org/en/latest/guides/using-testpypi/"><span class="url">https://packaging.python.org/en/latest/guides/using-testpypi/</span></a></p>&#13;
    <p class="normal">In the case of <code class="inlineCode">poetry</code>, we can configure the test repository like this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>poetry config repositories.testpypi https://test.pypi.org/simple/&#13;
<span class="hljs-con-meta">$ </span>poetry config pypi-token.testpypi &lt;token&gt;&#13;
</code></pre>&#13;
    <p class="normal">First of all, if you are using <code class="inlineCode">poetry</code> it is as simple as:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>poetry publish --repository=testpypi&#13;
</code></pre>&#13;
    <p class="normal">If you’re not using <code class="inlineCode">poetry</code> and don’t want to use a <code class="inlineCode">poetry-c</code>ompatible <code class="inlineCode">pyproject.toml</code>, you’ll need a different solution. The official solution from PyPA is to use the <code class="inlineCode">twine</code> tool, maintained by the PyPA. After you have used <code class="inlineCode">python3 -m build</code> to build the package, you can use <code class="inlineCode">twine</code> for uploading:</p>&#13;
    <div class="note">&#13;
      <p class="normal">Warning! This command will immediately register and upload the package to <code class="inlineCode">pypi.org</code> if you are already authenticated. That’s why <code class="inlineCode">--repository testpypi</code> was added to upload to the test PyPI server instead. If you drop that argument, you will immediately publish your package to PyPI.</p>&#13;
    </div>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>twine upload --repository testpypi dist/*&#13;
</code></pre>&#13;
    <p class="normal">Before you start publishing your packages to PyPI, you should ask yourself a couple of questions:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Is the package in a working state?</li>&#13;
      <li class="bulletList">Do you plan to support the package?</li>&#13;
    </ul>&#13;
    <p class="normal">The PyPI repository is unfortunately full of empty packages from people that are claiming usable package names for no apparent reason.</p>&#13;
    <h1 id="_idParaDest-563" class="heading-1">C/C++ extensions</h1>&#13;
    <p class="normal">The previous chapter and <a id="_idIndexMarker1645"/>earlier sections in this chapter have already covered the compilation of C/C++ components lightly, but this topic is complicated enough to warrant its own section with more in-depth explanations.</p>&#13;
    <p class="normal">For convenience, we will start with a basic <code class="inlineCode">setup.py</code> file that compiles a C extension:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> setuptools&#13;
&#13;
sum_of_squares = setuptools.Extension(<span class="hljs-string">'sum_of_squares'</span>, sources=[&#13;
    <span class="hljs-comment"># Get the relative path to sum_of_squares.c</span>&#13;
    <span class="hljs-built_in">str</span>(PROJECT_PATH / <span class="hljs-string">'sum_of_squares.c'</span>),&#13;
])&#13;
&#13;
setuptools.setup(&#13;
    name=<span class="hljs-string">'T_04_C_extensions'</span>,&#13;
    version=<span class="hljs-string">'0.1.0'</span>,&#13;
    ext_modules=[sum_of_squares],&#13;
)&#13;
</code></pre>&#13;
    <p class="normal">Before you start with these extensions, you should learn the following <code class="inlineCode">setup.py</code> commands:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">build_ext</code>: This command builds the C/C++ extension so it can be used when the package is installed in development/editable mode.</li>&#13;
      <li class="bulletList"><code class="inlineCode">clean</code>: This cleans the results from the <code class="inlineCode">build</code> command. This is generally not needed, but sometimes the detection of files that need to be recompiled to work is incorrect. If you encounter strange or unexpected issues, try cleaning the project first.</li>&#13;
    </ul>&#13;
    <p class="normal">Instead of using <code class="inlineCode">python3 setup.py build_ext</code>, you can also choose to use the PyPA <code class="inlineCode">build</code> command, but that is not a convenient option for development. If you use <code class="inlineCode">python3 setup.py build</code> you can re-use your <code class="inlineCode">build</code> directory and selectively build your C/C++ extensions, which saves you a lot of time for larger C/C++ modules. The PyPA <code class="inlineCode">build</code> command is meant to produce clean, production-ready packages, which is strongly recommended for deploying and publishing, but not for development.</p>&#13;
    <h2 id="_idParaDest-564" class="heading-2">Regular C/C++ extensions</h2>&#13;
    <p class="normal">The <code class="inlineCode">setuptools.Extension</code> class tells <code class="inlineCode">setuptools</code> that a module named <code class="inlineCode">sum_of_squares</code> uses <a id="_idIndexMarker1646"/>the source file <code class="inlineCode">sum_of_squares.c</code>. This is just the simplest version of an extension – a name and a list of sources – but often you are going to need not just the C file but also some headers from other libraries.</p>&#13;
    <p class="normal">A prime example is the <code class="inlineCode">pillow</code> library for image manipulation. When the library is building, it automatically detects the libraries available on the system and adds extensions based on that. For <code class="inlineCode">.jpeg</code> support you need to have <code class="inlineCode">libjpeg</code> installed; for <code class="inlineCode">.tiff</code> images you need <code class="inlineCode">libtiff</code>; and so on. As these extensions include binary libraries, some extra compilation flags and C header files are required. The basic PIL module itself doesn’t appear too involved, but the <code class="inlineCode">setup.py</code> file is filled with auto-detection code to detect which <code class="inlineCode">libs</code> (libraries) are available, with the matching C macro definitions to enable these libraries.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Macros in C are preprocessor directives. These directives are executed before the actual compilation step occurs, which makes them ideal for conditional code. You could have a conditional block of debug code dependent on a <code class="inlineCode">DEBUG</code> flag, for example:</p>&#13;
      <pre class="programlisting code"><code class="hljs-code">#ifdef DEBUG&#13;
/* your debug code here */&#13;
#endif&#13;
</code></pre>&#13;
      <p class="normal">If <code class="inlineCode">DEBUG</code> is set, the code will be part of the compiled binary. If the flag is not set, the block of code will never end up in the resulting binary. This results in smaller and faster binaries because these conditionals happen at compile time as opposed to runtime.</p>&#13;
    </div>&#13;
    <p class="normal">Here’s a partial example <code class="inlineCode">Extension</code> from an older version of the <code class="inlineCode">pillow</code> <code class="inlineCode">setup.py</code> file:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">exts = [(Extension(<span class="hljs-string">"</span><span class="hljs-string">PIL._imaging"</span>, files, libraries=libs,&#13;
    define_macros=defs))]&#13;
</code></pre>&#13;
    <p class="normal">The newer versions are quite different and the <code class="inlineCode">setup.py</code> file for the <code class="inlineCode">pillow</code> project is currently over 1,000 lines. The <code class="inlineCode">freetype</code> extension has something similar:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> feature.freetype:&#13;
    exts.append(Extension(&#13;
        <span class="hljs-string">"PIL._imagingft"</span>, [<span class="hljs-string">"_imagingft.c"</span>], libraries=[<span class="hljs-string">"freetype"</span>]))&#13;
</code></pre>&#13;
    <p class="normal">Adding and <a id="_idIndexMarker1647"/>compiling C/C++ extensions can certainly be challenging, so I would recommend taking inspiration from projects such as <code class="inlineCode">pillow</code> and <code class="inlineCode">numpy</code> if you need to take care of this. They are perhaps a bit too complicated, but should provide you with a nice starting point that covers nearly all scenarios.</p>&#13;
    <h2 id="_idParaDest-565" class="heading-2">Cython extensions</h2>&#13;
    <p class="normal">The <code class="inlineCode">setuptools</code> library is a bit <a id="_idIndexMarker1648"/>smarter than the regular <code class="inlineCode">distutils</code> library when it comes to extensions: it actually adds a little trick to the <code class="inlineCode">Extension</code> class. Remember the brief introduction to <code class="inlineCode">cython</code> in <em class="chapterRef">Chapter 12</em>, about performance? The <code class="inlineCode">setuptools</code> library makes it a bit more convenient to compile Cython extensions. The Cython manual recommends that you use something similar to the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup&#13;
<span class="hljs-keyword">from</span> Cython.Build <span class="hljs-keyword">import</span> cythonize&#13;
&#13;
setup(&#13;
    ext_modules = cythonize(<span class="hljs-string">"src/*.pyx"</span>)&#13;
)&#13;
</code></pre>&#13;
    <p class="normal">The problem with this approach is that <code class="inlineCode">setup.py</code> will break with an <code class="inlineCode">ImportError</code> unless you have Cython installed:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python3 setup.py build&#13;
Traceback (most recent call last):&#13;
  File "setup.py", line 2, in &lt;module&gt;&#13;
    import Cython&#13;
ImportError: No module named 'Cython'&#13;
</code></pre>&#13;
    <p class="normal">To prevent that issue, we are just going to let <code class="inlineCode">setuptools</code> handle the Cython compilation:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> setuptools&#13;
&#13;
setuptools.setup(&#13;
    name=<span class="hljs-string">'T_05_cython'</span>,&#13;
    version=<span class="hljs-string">'0.1.0'</span>,&#13;
    ext_modules=[&#13;
        setuptools.Extension(&#13;
            <span class="hljs-string">'sum_of_squares'</span>,&#13;
            sources=[<span class="hljs-string">'T_05_cython/sum_of_squares.pyx'</span>],&#13;
        ),&#13;
    ],&#13;
    setup_requires=[<span class="hljs-string">'cython'</span>],&#13;
)&#13;
</code></pre>&#13;
    <p class="normal">Now Cython will automatically be installed if needed and the code will work just fine:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 setup.py build&#13;
running build&#13;
running build_ext&#13;
cythoning T_05_cython/sum_of_squares.pyx to T_05_cython/sum_of_squares.c&#13;
building 'sum_of_squares' extension&#13;
...&#13;
</code></pre>&#13;
    <p class="normal">For <a id="_idIndexMarker1649"/>development purposes, however, Cython also offers a simpler method that doesn’t require manual building, <code class="inlineCode">pyximport</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> pyximport&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> pyximport.install()&#13;
(None, &lt;pyximport.pyximport.PyxImporter object at ...&gt;)&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> T_05_cython <span class="hljs-con-keyword">import</span> sum_of_squares&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sum_of_squares.sum_of_squares(<span class="hljs-con-number">10</span>)&#13;
14&#13;
</code></pre>&#13;
    <p class="normal">That’s how easy it is to run the <code class="inlineCode">pyx</code> files without explicit compiling.</p>&#13;
    <h1 id="_idParaDest-566" class="heading-1">Testing</h1>&#13;
    <p class="normal">In <em class="chapterRef">Chapter 10</em>, <em class="italic">Testing and Logging – Preparing for Bugs</em>, we saw a few of the many testing systems for Python. As you might suspect, at least some of these have <code class="inlineCode">setup.py</code> integration. It should be noted <a id="_idIndexMarker1650"/>that <code class="inlineCode">setuptools</code> even has a dedicated <code class="inlineCode">test</code> command (at the time of writing), but this command has been deprecated and the <code class="inlineCode">setuptools</code> documentation now recommends using <code class="inlineCode">tox</code>. While I am a huge fan of <code class="inlineCode">tox</code>, for immediate local development it often incurs quite a bit of overhead. I find that executing <code class="inlineCode">py.test</code> directly is faster, because you can really quickly test only the bits of the code that you changed.</p>&#13;
    <h2 id="_idParaDest-567" class="heading-2">unittest</h2>&#13;
    <p class="normal">Before we start, we should <a id="_idIndexMarker1651"/>create a test script for our package. For actual tests please look at <em class="chapterRef">Chapter 10</em>; in this case, we will just use a no-op test, <code class="inlineCode">test.py</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> unittest&#13;
&#13;
<span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(unittest.TestCase):&#13;
    <span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):&#13;
        <span class="hljs-keyword">pass</span>&#13;
</code></pre>&#13;
    <p class="normal">The standard <code class="inlineCode">python setup.py test</code> command has been deprecated, so we will run <code class="inlineCode">unittest</code> directly:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 -m unittest -v <span class="hljs-con-built_in">test</span>&#13;
running test&#13;
...&#13;
</code></pre>&#13;
    <p class="normal">The <code class="inlineCode">unittest</code> library is still rather limited, however, so I recommend skipping straight to <code class="inlineCode">py.test</code> instead.</p>&#13;
    <h2 id="_idParaDest-568" class="heading-2">py.test</h2>&#13;
    <p class="normal">The <code class="inlineCode">py.test</code> package<a id="_idIndexMarker1652"/> currently automatically registers as an extra command in <code class="inlineCode">setuptools</code>, so after installing you can run <code class="inlineCode">python3 setup.py pytest</code>. However, since <code class="inlineCode">setuptools</code> is actively trying to reduce all interaction with <code class="inlineCode">setup.py</code>, I would recommend using a <code class="inlineCode">py.test</code> or <code class="inlineCode">tox</code> call directly instead.</p>&#13;
    <p class="normal">As mentioned earlier, it is recommended to use <code class="inlineCode">tox</code> for bootstrapping your environment and fully testing the project. For fast local development, however, I would suggest installing the <code class="inlineCode">pytest</code> module and running the tests directly.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Note that there might still be old documentation floating around suggesting the use of <code class="inlineCode">pytest-runner</code>, <code class="inlineCode">python setup.py test</code> with an alias or custom command, or the generation of a <code class="inlineCode">runtests.py</code> file, but all of these solutions have been deprecated and should not be used anymore.</p>&#13;
    </div>&#13;
    <p class="normal">To configure <code class="inlineCode">py.test</code> we have several options depending on your preferences. All of the following files will work:</p>&#13;
    <ul>&#13;
      <li class="bulletList"><code class="inlineCode">pytest.ini</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">pyproject.toml</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">tox.ini</code></li>&#13;
      <li class="bulletList"><code class="inlineCode">setup.cfg</code></li>&#13;
    </ul>&#13;
    <p class="normal">For the projects I <a id="_idIndexMarker1653"/>maintain, I have the test requirements defined as an extra so these can be installed using (for example) <code class="inlineCode">pip3 install -e "./progressbar2[tests]"</code>. After that, you can easily run <code class="inlineCode">py.test</code> to run the tests identically to how <code class="inlineCode">tox</code> would run them. Naturally, <code class="inlineCode">tox</code> can also install the requirements using the same extras, which ensures you are using the same test environment.</p>&#13;
    <p class="normal">To enable this in your <code class="inlineCode">setup.cfg</code> (or the equivalent for <code class="inlineCode">setup.py</code> / <code class="inlineCode">pyproject.toml</code>):</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">[options.extras_require]&#13;
tests = pytest&#13;
</code></pre>&#13;
    <p class="normal">For local development, we can now install the package and the extras in editable mode for quick testing:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>pip3 install -e <span class="hljs-con-string">'.[tests]'</span>&#13;
</code></pre>&#13;
    <p class="normal">That should be enough to be able to test using <code class="inlineCode">py.test</code> directly:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>py.test&#13;
</code></pre>&#13;
    <p class="normal">To test using <code class="inlineCode">tox</code>, you will need to create a <code class="inlineCode">tox.ini</code> file, but for that, I suggest you take a look at <em class="chapterRef">Chapter 10</em>.</p>&#13;
    <h1 id="_idParaDest-569" class="heading-1">Exercises</h1>&#13;
    <p class="normal">Now that you have reached the end of the book, there are many things to try, of course. You can build and publish your own applications and libraries, or extend existing libraries and applications.</p>&#13;
    <p class="normal">While trying out the examples in this chapter, be careful not to accidentally publish packages to PyPI if that was not your intention. It just takes a single <code class="inlineCode">twine</code> command to accidentally register and upload a package, and PyPI is already too crowded with packages that do nothing useful.</p>&#13;
    <p class="normal">For some practical exercises:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Create a <code class="inlineCode">setuptools</code> command to bump the version in your package</li>&#13;
      <li class="bulletList">Extend the version bumping command by interactively asking for a major, minor, or patch upgrade</li>&#13;
      <li class="bulletList">Try and convert existing projects from <code class="inlineCode">setup.py</code> to a <code class="inlineCode">pyproject.toml</code> structure</li>&#13;
      </ul>&#13;
        <div class="note">&#13;
          <p class="normal">Example answers for these exercises can be found on GitHub: <a href="Chapter_18.xhtml"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
        </div>&#13;
      &#13;
    &#13;
    <h1 id="_idParaDest-570" class="heading-1">Summary</h1>&#13;
    <p class="normal">After reading this chapter, you should be able to create Python packages containing not only pure-Python files but also extra data, compiled C/C++ extensions, documentation, and tests. With all these tools at your disposal, you are now able to make high-quality Python packages that can easily be reused in other projects and packages.</p>&#13;
    <p class="normal">The Python infrastructure makes it really quite easy to create new packages and split your project into multiple subprojects. This allows you to create simple and reusable packages with fewer bugs because everything is easily testable. While you shouldn’t go overboard with splitting up the packages, if a script or module has a purpose of its own then it’s a candidate for packaging separately.</p>&#13;
    <p class="center">*</p>&#13;
    <p class="normal">With this chapter, we have come to the end of the book. I sincerely hope you enjoyed reading it and have learned about some new and interesting topics. Any and all feedback is greatly appreciated, so feel free to contact me through my website at <a href="https://wol.ph/"><span class="url">https://wol.ph/</span></a>.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>