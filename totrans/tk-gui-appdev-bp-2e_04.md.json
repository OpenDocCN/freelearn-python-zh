["```py\n>> import tkinter, copy, sys, configparser\n```", "```py\nclass Model(): #in model.py\n  def __init__(self):\n    pass\n\nclass View(): #in view.py\n  def __init__(self):\n    pass\n\nclass Controller(): # in controller.py\n  def __init__(self):\n    self.init_model()\n\n  def init_model(self):\n    self.model = model.Model()\n```", "```py\nclass ChessError(Exception): pass\n```", "```py\nNUMBER_OF_ROWS = 8\nNUMBER_OF_COLUMNS = 8\nDIMENSION_OF_EACH_SQUARE = 64 # denoting 64 pixels\nBOARD_COLOR_1 = \"#DDB88C\"\nBOARD_COLOR_2 = \"#A66D4F\"\n```", "```py\nfrom configurations import *\n```", "```py\nimport controller # in view.py\nimport model # in controller.py\n```", "```py\ndef create_chess_base(self):\n  self.create_top_menu()\n  self.create_canvas()\n  self.draw_board()\n  self.create_bottom_frame()\n```", "```py\ndef create_canvas(self):\n  canvas_width = NUMBER_OF_COLUMNS * DIMENSION_OF_EACH_SQUARE\n  canvas_height = NUMBER_OF_ROWS * DIMENSION_OF_EACH_SQUARE\n  self.canvas = Canvas(self.parent, width=canvas_width, height=canvas_height)\n  self.canvas.pack(padx=8, pady=8)\n```", "```py\ndef draw_board(self):\n  current_color = BOARD_COLOR_2\n  for row in range(NUMBER_OF_ROWS):\n    current_color = self.get_alternate_color(current_color)\n    for col in range(NUMBER_OF_COLUMNS):\n       x1, y1 = self.get_x_y_coordinate(row, col)\n       x2, y2 = x1 + DIMENSION_OF_EACH_SQUARE, y1 +DIMENSION_OF_EACH_SQUARE\n       self.canvas.create_rectangle(x1, y1, x2, y2, fill=current_color)\n       current_color = self.get_alternate_color(current_color)\n\ndef get_x_y_coordinate(self, row, col):\n        x = (col * DIMENSION_OF_EACH_SQUARE)\n        y = ((7 - row) * DIMENSION_OF_EACH_SQUARE)\n       return (x, y)\n\ndef get_alternate_color(self, current_color):\n     if current_color == self.board_color_2:\n        next_color = self.board_color_1\n     else:\n        next_color = self.board_color_2\n     return next_color\n```", "```py\nself.canvas.bind(\"<Button-1>\", self.on_square_clicked)\n```", "```py\ndef on_square_clicked(self, event):\n  clicked_row, clicked_column =  self.get_clicked_row_column(event)\n  print(\"Hey you clicked on\", clicked_row, clicked_column)\n```", "```py\ndef get_clicked_row_column(self, event):\n  col_size = row_size = DIMENSION_OF_EACH_SQUARE\n  clicked_column = event.x // col_size\n  clicked_row = 7 - (event.y // row_size)\n  return (clicked_row, clicked_column)\n```", "```py\nHey you clicked on 0 7\nHey you clicked on 3 3\n```", "```py\nX_AXIS_LABELS = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')\nY_AXIS_LABELS = (1, 2, 3, 4, 5, 6, 7, 8)\n```", "```py\nSTART_PIECES_POSITION = {\n\"A8\": \"r\", \"B8\": \"n\", \"C8\": \"b\", \"b\", \"G8\": \"n\", \"H8\": \"r\",\n\"A7\": \"p\", \"B7\": \"p\", \"C7\": \"p\", \"p\", \"G7\": \"p\", \"H7\": \"p\",\n\"A2\": \"P\", \"B2\": \"P\", \"C2\": \"P\", \"P\", \"G2\": \"P\", \"H2\": \"P\",\n\"A1\": \"R\", \"B1\": \"N\", \"C1\": \"B\", \"D8\": \"q\", \"E8\": \"k\", \"F8\":\n\"D7\": \"p\", \"E7\": \"p\", \"F7\": \"D2\": \"P\", \"E2\": \"P\", \"F2\":\n\"D1\": \"Q\", \"E1\": \"K\", \"F1\":\"B\", \"G1\": \"N\", \"H1\": \"R\"\n}\n```", "```py\nclass Model(dict): \n```", "```py\ndef get_piece_at(self, position):\n   return self.get(position) \n```", "```py\ncaptured_pieces = { 'white': [], 'black': [] }\nplayer_turn = None\nhalfmove_clock = 0\nfullmove_number = 1\nhistory = []\n```", "```py\ndef get_alphanumeric_position(self, rowcol):\n  if self.is_on_board(rowcol):\n     row, col = rowcol\n     return \"{}{}\".format(X_AXIS_LABELS[col], Y_AXIS_LABELS[row])\n```", "```py\ndef is_on_board(self, rowcol):\n     row, col = rowcol\n    return 0 <= row <= 7 and 0 <= col <= 7 \n```", "```py\nfrom configurations import *\n\nclass Piece():\n  def __init__(self, color):\n    self.name = self.__class__.__name__.lower()\n    if color == 'black':\n      self.name = self.name.lower()\n    elif color == 'white':\n      self.name = self.name.upper()\n      self.color = color\n\ndef keep_reference(self, model):\n   self.model = model\n\nclass King(Piece):\n  pass\n\nclass Queen(Piece):\n  pass\n\nclass Rook(Piece):\n  pass\n\nclass Bishop(Piece):\n  pass\n\nclass Knight(Piece):\n  pass\n\nclass Pawn(Piece):\n  pass\n```", "```py\nimport piece\n```", "```py\ndef create_piece (piece, color='white'):\n  if isinstance(piece, str):\n    if piece.upper() in SHORT_NAME.keys():\n      color = \"white\" if piece.isupper() else \"black\"\n      piece = SHORT_NAME[piece.upper()]\n    piece = piece.capitalize()\n    if piece in SHORT_NAME.values():\n      return eval(\"{classname} (color)\".format(classname=piece))\n raise exceptions.ChessError(\"invalid piece name: '{}'\".format(piece))\n```", "```py\nSHORT_NAME = {\n 'R':'Rook', 'N':'Knight', 'B':'Bishop', 'Q':'Queen', 'K':'King', 'P':'Pawn'\n }\n```", "```py\ndef draw_single_piece(self, position, piece):\n  x, y = self.controller.get_numeric_notation(position)\n  if piece:\n    filename = \"../pieces_image/{}_{}.png\".format(piece.name.lower(), piece.color)\n    if filename not in self.images:\n      self.images[filename] = PhotoImage(file=filename)\n    x0, y0 = self.calculate_piece_coordinate(x, y)\n    self.canvas.create_image(x0, y0, image=self.images[filename], \n                          tags=(\"occupied\"),  anchor=\"c\")\n```", "```py\ndef calculate_piece_coordinate(self, row, col):\n  x0 = (col * DIMENSION_OF_EACH_SQUARE) + int(DIMENSION_OF_EACH_SQUARE / 2)\n  y0 = ((7 - row) * DIMENSION_OF_EACH_SQUARE) + \n    int(DIMENSION_OF_EACH_SQUARE / 2)\n  return (x0, y0)\n```", "```py\ndef get_numeric_notation(self, position):\n  return piece.get_numeric_notation(position)\n```", "```py\ndef get_numeric_notation(rowcol):\n  row, col = rowcol\n  return int(col)-1, X_AXIS_LABELS.index(row) \n```", "```py\ndef draw_all_pieces(self):\n self.canvas.delete(\"occupied\")\n for position, piece in  self.controller.get_all_pieces_on_chess_board():\n   self.draw_single_piece(position, piece)\n```", "```py\ndef get_all_pieces_on_chess_board(self):\n  return self.model.items()\n```", "```py\n def start_new_game(self):\n   self.controller.reset_game_data()\n   self.controller.reset_to_initial_locations()\n   self.draw_all_pieces()\n```", "```py\ndef reset_game_data(self):\n  self.model.reset_game_data()\n\ndef reset_to_initial_locations(self):\n  self.model.reset_to_initial_locations()\n```", "```py\ndef reset_game_data(self):\n  captured_pieces = {'white': [], 'black': []}\n  player_turn = None\n  halfmove_clock = 0\n  fullmove_number = 1\n  history = []\n\ndef reset_to_initial_locations(self):\n  self.clear()\n  for position, value in START_PIECES_POSITION.items():\n    self[position] = piece.create_piece(value)\n    self[position].keep_reference(self)\n    self.player_turn = 'white'\n```", "```py\nORTHOGONAL_POSITIONS = ((-1,0),(0,1),(1,0),(0, -1))\nDIAGONAL_POSITIONS = ((-1,-1),(-1,1),(1,-1),(1,1)) \n```", "```py\ndef moves_available(self, current_position, directions,distance):\n  model = self.model\n  allowed_moves = []\n  piece = self\n  start_row, start_column = get_numeric_notation(current_position)\n  for x, y in directions:\n    collision = False\n    for step in range(1, distance + 1):\n      if collision: break\n      destination = start_row + step * x, start_column + step * y\n      if self.possible_position(destination) not in \n        model.all_occupied_positions():\n         allowed_moves.append(destination)\n      elif self.possible_position(destination) in\n                         model.all_positions_occupied_by_color \n                           (piece.color):\n         collision = True\n      else:\n         allowed_moves.append(destination)\n         collision = True\n  allowed_moves = filter(model.is_on_board, allowed_moves)\n  return map(model.get_alphanumeric_position, allowed_moves)\n\n```", "```py\ndef possible_position(self, destination): #4.04 piece.py\n  return self.model.get_alphanumeric_position(destination)\n\ndef all_positions_occupied_by_color(self, color): #4.04 model.py\n  result = []\n  for position in self.keys():\n    piece = self.get_piece_at(position)\n    if piece.color == color:\n      result.append(position)\n  return result\n\ndef all_occupied_positions(self): #4.04 model.py\n  return self.all_positions_occupied_by_color('white') +\\\n         self.all_positions_occupied_by_color('black')\n```", "```py\nclass King(Piece):\n  directions = ORTHOGONAL_POSITIONS + DIAGONAL_POSITIONS\n  max_distance = 1\n\n  def moves_available(self,current_position):\n     return super().moves_available(current_position, self.directions, self.max_distance)\n\nclass Queen(Piece):\n  directions = ORTHOGONAL_POSITIONS + DIAGONAL_POSITIONS\n  max_distance = 8\n\n  def moves_available(self,current_position):\n    return super(Queen, self).moves_available\n               (current_position, self.directions, self.max_distance)\n\nclass Rook(Piece):\n  directions = ORTHOGONAL_POSITIONS\n  max_distance = 8\n\n  def moves_available(self,current_position):\n      return super(Rook, self).moves_available(current_position,\n                                    self.directions, self.max_distance)\n\nclass Bishop(Piece):\n  directions = DIAGONAL_POSITIONS\n  max_distance = 8\n\n  def moves_available(self,current_position):\n     return super(Bishop, self).moves_available\n              (current_position, self.directions, self.max_distance)\n```", "```py\nKNIGHT_POSITIONS = ((-2,-1),(-2,1),(-1,-2),(-1,2),(1,-2),(1,2),(2,-1),(2,1))\n```", "```py\nclass Knight(Piece):\n\n def moves_available(self, current_position):\n   model = self.model\n   allowed_moves = []\n   start_position = get_numeric_notation(current_position.upper())\n   piece = model.get(pos.upper())\n   for x, y in KNIGHT_POSITIONS:\n     destination = start_position[0] + x, start_position[1] + y\n     if(model.get_alphanumeric_position(destination) not \n             in model.all_positions_occupied_by_color(piece.color)):\n       allowed_moves.append(destination)\n   allowed_moves = filter(model.is_on_board, allowed_moves)\n   return map(model.get_alphanumeric_position, allowed_moves)\n```", "```py\nclass Pawn(Piece):\n\n  def moves_available(self, current_position):\n    model = self.model\n    piece = self\n    if self.color == 'white':\n      initial_position, direction, enemy = 1, 1, 'black'\n    else:\n      initial_position, direction, enemy = 6, -1, 'white'\n    allowed_moves = []\n    # Moving\n    prohibited = model.all_occupied_positions()\n    start_position = get_numeric_notation(current_position.upper())\n    forward = start_position[0] + direction, start_position[1]\n    if model.get_alphanumeric_position(forward) not in prohibited:\n      allowed_moves.append(forward)\n      if start_position[0] == initial_position:\n        # If pawn is in starting position allow double  moves\n        double_forward = (forward[0] + direction, forward[1])\n        if model.get_alphanumeric_position(double_forward) not in \n          prohibited:\n            allowed_moves.append(double_forward)\n    # Attacking\n    for a in range(-1, 2, 2):\n      attack = start_position[0] + direction,\n      start_position[1] + a\n      if model.get_alphanumeric_position(attack) in\n                 model.all_positions_occupied_by_color(enemy):\n         allowed_moves.append(attack)\n    allowed_moves = filter(model.is_on_board, allowed_moves)\n    return map(model.get_alphanumeric_position, allowed_moves)\n```", "```py\ndef get_all_available_moves(self, color):\n  result = []\n  for position in self.keys():\n    piece = self.get_piece_at(position)\n    if piece and piece.color == color:\n       moves = piece.moves_available(position)\n       if moves:\n         result.extend(moves)\n  return result\n```", "```py\n def get_alphanumeric_position_of_king(self, color):\n   for position in self.keys():\n     this_piece = self.get_piece_at(position)\n     if isinstance(this_piece, piece.King) and this_piece.color == color:\n        return position\n```", "```py\ndef is_king_under_check(self, color):\n  position_of_king = self.get_alphanumeric_position_of_king(color)\n  opponent = 'black' if color =='white' else 'white'\n  return position_of_king in self.get_all_available_moves(opponent) \n```", "```py\ndef on_square_clicked(self, event):\n  clicked_row, clicked_column = self.get_clicked_row_column(event)\n  position_of_click =  self.controller.get_alphanumeric_position \n                                   ((clicked_row, clicked_column))\n  if self.selected_piece_position: # on second click\n     self.shift(self.selected_piece_position, position_of_click)\n     self.selected_piece_position = None\n  self.update_highlight_list(position_of_click)\n  self.draw_board()\n  self.draw_all_pieces()\n```", "```py\ndef shift(self, start_pos, end_pos):\n  selected_piece = self.controller.get_piece_at(start_pos)\n  piece_at_destination =  self.controller.get_piece_at(end_pos)\n  if not piece_at_destination or piece_at_destination.color\n                      != selected_piece.color:\n     try:\n        self.controller.pre_move_validation(start_pos, end_pos)\n     except exceptions.ChessError as error:\n        self.info_label[\"text\"] = error.__class__.__name__\n  else:\n     self.update_label(selected_piece, start_pos, end_pos)\n```", "```py\ndef update_highlight_list(self, position):\n  self.all_squares_to_be_highlighted = None\n  try:\n    piece = self.controller.get_piece_at(position)\n  except:\n    piece = None\n  if piece and (piece.color == self.controller.player_turn()):\n    self.selected_piece_position = position\n  self.all_squares_to_be_highlighted = list(map(self.controller.get_numeric_notation,\n                   self.controller.get_piece_at(position).moves_available(position)))\n```", "```py\nHIGHLIGHT_COLOR = \"#2EF70D\"\n```", "```py\ndef draw_board(self):\n  current_color = BOARD_COLOR_2\n  for row in range(NUMBER_OF_ROWS):\n     current_color = self.get_alternate_color(current_color)\n     for col in range(NUMBER_OF_COLUMNS):\n        x1, y1 = self.get_x_y_coordinate(row, col)\n        x2, y2 = x1 + DIMENSION_OF_EACH_SQUARE, y1 + \n          DIMENSION_OF_EACH_SQUARE\n        if(self.all_squares_to_be_highlighted and (row, col) in \n                       self.all_squares_to_be_highlighted):\n           self.canvas.create_rectangle(x1, y1, x2, y2, \n             fill=HIGHLIGHT_COLOR)\n        else:\n           self.canvas.create_rectangle(x1, y1, x2, y2, fill=current_color)\n        current_color = self.get_alternate_color(current_color)\n```", "```py\n    def pre_move_validation(self, initial_pos, final_pos):\n        initial_pos, final_pos = initial_pos.upper(), final_pos.upper()\n        piece = self.get_piece_at(initial_pos)\n        try:\n            piece_at_destination = self.get_piece_at(final_pos)\n        except:\n            piece_at_destination = None\n        if self.player_turn != piece.color:\n            raise exceptions.NotYourTurn(\"Not \" + piece.color + \"'s turn!\")\n        enemy = ('white' if piece.color == 'black' else 'black')\n        moves_available = piece.moves_available(initial_pos)\n        if final_pos not in moves_available:\n            raise exceptions.InvalidMove\n        if self.get_all_available_moves(enemy):\n            if self.will_move_cause_check(initial_pos, final_pos):\n                raise exceptions.Check\n        if not moves_available and self.is_king_under_check(piece.color):\n            raise exceptions.CheckMate\n        elif not moves_available:\n            raise exceptions.Draw\n        else:\n            self.move(initial_pos, final_pos)\n            self.update_game_statistics(\n                piece, piece_at_destination, initial_pos, final_pos)\n            self.change_player_turn(piece.color)\n```", "```py\n class Check(ChessError): pass\n class InvalidMove(ChessError): pass\n class CheckMate(ChessError): pass\n class Draw(ChessError): pass\n class NotYourTurn(ChessError): pass\n```", "```py\nself.info_label[\"text\"] = error.__class__.__name__\n```", "```py\ndef will_move_cause_check(self, start_position, end_position):\n  tmp = deepcopy(self)\n  tmp.move(start_position, end_position)\n  return tmp.is_king_under_check(self[start_position].color)\n```", "```py\ndef move(self, start_pos, final_pos):\n self[final_pos] = self.pop(start_pos, None)\n```", "```py\n    def update_game_statistics(self, piece, dest, start_pos, end_pos):\n        if piece.color == 'black':\n            self.fullmove_number += 1\n        self.halfmove_clock += 1\n        abbr = piece.name\n        if abbr == 'pawn':\n            abbr = ''\n            self.halfmove_clock = 0\n        if dest is None:\n            move_text = abbr + end_pos.lower()\n        else:\n            move_text = abbr + 'x' + end_pos.lower()\n            self.halfmove_clock = 0\n        self.history.append(move_text)\n\n```", "```py\ndef on_new_game_menu_clicked(self):\n  self.start_new_game()\n```", "```py\nfrom configparser import ConfigParser\n```", "```py\n[chess_colors]\n board_color_1 = #DDB88C\n board_color_2 = #A66D4F\n highlight_color = #2EF70D\n```", "```py\nconfig = ConfigParser()\nconfig.read('chess_options.ini')\nBOARD_COLOR_1 = config.get('chess_colors', 'board_color_1', \n  fallback=\"#DDB88C\")\nBOARD_COLOR_2 = config.get('chess_colors', 'board_color_2', fallback = \n  \"#A66D4F\")\nHIGHLIGHT_COLOR =config.get('chess_colors', 'highlight_color', fallback \n  = \"#2EF70D\")\n```", "```py\nself.pref_window.transient(self.parent)\n```", "```py\nimport preferenceswindow\n```", "```py\ndef on_preference_menu_clicked(self):\n  self.show_prefereces_window()\n\ndef show_prefereces_window(self):\n  preferenceswindow.PreferencesWindow(self)\n```", "```py\ndef on_cancel_button_clicked(self):\n  self.pref_window.destroy()\n```", "```py\ndef set_new_values(self):\n  color_1 = self.board_color_1.get()\n  color_2 = self.board_color_2.get()\n  highlight_color = self.highlight_color.get()\n  config = ConfigParser()\n  config.read('chess_options.ini')\n  config.set('chess_colors', 'board_color_1',color_1)\n  config.set('chess_colors', 'board_color_2',color_2)\n  config.set('chess_colors', 'highlight_color', highlight_color)\n  configurations.BOARD_COLOR_1 = self.board_color_1.get()\n  configurations.BOARD_COLOR_2 = self.board_color_2.get()\n  configurations.HIGHLIGHT_COLOR = self.highlight_color.get()\n  with open('chess_options.ini', 'w') as config_file:\n     config.write(config_file)\n```", "```py\ndef reload_colors(self, color_1, color_2, highlight_color):\n self.board_color_1 = color_1\n self.board_color_2 = color_2\n self.highlight_color = highlight_color\n self.draw_board()\n self.draw_all_pieces()\n```"]