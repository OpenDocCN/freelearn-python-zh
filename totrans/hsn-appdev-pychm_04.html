<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-78"><a id="_idTextAnchor077"/>4</h1>
<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Editing and Formatting with Ease in PyCharm</h1>
<p>Leonardo Da Vinci, the great painter and sculptor, mused that his sculptures were fully formed in the blocks of stone from the quarry before he even saw the marble. Da Vinci explained that all he did was remove the pieces of marble that were not required for the form. In other words, his masterpieces were completed in his mind before a chisel touched the crude stone. In many ways, you are Da Vinci. You have a project in your head, fully formed, and you are eager to show the world your masterpiece. Instead of using a hammer and chisel to write your code, you are using PyCharm. In the previous chapters, we worked through the installation process and configuration of PyCharm. We also set up an interpreter for your project. Next up: the exploration of the main tools that you will use to craft your masterpiece, which mainly reside in the editor.</p>
<p>By now, you have discovered many of the obvious features of the editor. We know it handles a lot of the PEP-8 syntax rules automatically. We know we get the color-coded syntax. We also have observed that the <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) will make suggestions on several different areas of coding, ranging from linting style rules to auto-completion.</p>
<p>This chapter will focus on the features of the editor that are less obvious. The product’s documentation provides keyboard shortcuts and editor basics that will not be discussed in this chapter. Instead, the following topics will be covered:</p>
<ul>
<li>Real-time code inspection with automated fixes, which allows you to focus on development goals rather than on the rules of Python coding.</li>
<li>Various code-completion support features in PyCharm and how to leverage them. By using these, you’ll be able to code more quickly and more accurately. We will only focus on those tools that ship with PyCharm versus third-party <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>) enhancements that require plugins such as Kite or GitHub Copilot. These will be covered in <a href="B19644_15.xhtml#_idTextAnchor379"><em class="italic">Chapter 15</em></a>.</li>
<li>Refactoring tools that allow you to polish and refine your code into the masterpiece that it can become through patience, discipline, and good tooling.</li>
<li>Documentation tools that will take you from the level of “good developer” to the level of “master developer.” It’s one thing to invent an amazing work of code. Documenting it so others can benefit from it takes your work to another level.</li>
</ul>
<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Technical requirements</h1>
<p>In order to proceed through this chapter and the rest of the book, you will need the following:</p>
<ul>
<li>An installed and working Python interpreter. I’ll be using the latest from <a href="https://python.org">https://python.org</a>.</li>
<li>Installed copies of <code>pip</code> and <code>virtualenv</code>. You get these automatically when you install Python on Windows, and MacOS has them included on every system. If you are using Linux, you need to install the package managers, such as <code>pip</code>, and virtual environment tools, such as <code>virtualenv</code>, separately. Our examples will use <code>pip</code> and <code>virtualenv</code>.</li>
<li>An installed and working copy of PyCharm. Installation was covered in <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>.</li>
<li>This book’s sample source code from GitHub can be found at <a href="https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04">https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04</a>. We covered cloning the code in <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation </em><em class="italic">and Configuration</em>.</li>
</ul>
<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Code analysis, inspection, and suggestion</h1>
<p>Intelligent <a id="_idIndexMarker278"/>code completion is essential to any programming tool’s adoption. The definition of a good code completion engine is one that is aware of high-level aspects of programming, including specifics of language syntax. The engine also must be aware of the lower-level specifics of the program you write. Many enhanced text editors support code completion but lack this level of sophistication. PyCharm stands out as an exceptionally sophisticated code editor, encompassing both the historical and modern aspects of code editors and offering a level of sophistication that surpasses many other enhanced text editors in terms of intelligent code completion.</p>
<p>The most common form of code completion is a large picklist of words that are matched as you type. The list of possibilities narrows as more letters are typed. Notepad++ is an enhanced text editor widely used by developers. I consider it a must-have tool for quick and easy edits when I am too impatient to wait on an IDE to fully load. <em class="italic">Figure 4</em><em class="italic">.1</em> shows a session where I began typing some Python code:</p>
<div><div><img alt="Figure 4.1: Notepad++ uses a very simple mechanism for code highlighting and completion" src="img/B19644_04_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Notepad++ uses a very simple mechanism for code highlighting and completion</p>
<p>The tool does not intuitively know what is being typed; therefore, I must tell it that I am coding in Python. After the language is set, it will attempt to autocomplete everything, even though such an exercise is clearly futile. In <em class="italic">Figure 4</em><em class="italic">.1</em>, I was going to type the following:</p>
<pre class="source-code">
import time
def test_code():
  pass</pre> <p>This clearly<a id="_idIndexMarker279"/> isn’t going to win me any Jolt awards. You see in the screenshot that the list is filtering a known list of words. Its only contextual point of reference is knowing that the file is a Python file. This isn’t very effective, but it is better than nothing.</p>
<p>Systems like these are little more than spell checkers. While a seasoned pro might scoff at the usefulness of such a simple system, the earliest IDEs that displayed this level of wizardry pioneered a feature we are now unwilling to live without: code completion.</p>
<p>PyCharm lies at the opposite end of the spectrum with respect to sophistication. Like Notepad++, PyCharm is aware of the keywords that comprise PyCharm. PyCharm, though, is able to glean insight into the structure of the objects that make up the standard library. <em class="italic">Figure 4</em><em class="italic">.2</em> shows me typing some code into PyCharm, having created a simple file for this example:</p>
<div><div><img alt="Figure 4.2: PyCharm auto-completes based on its understanding of the time library" src="img/B19644_04_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: PyCharm auto-completes based on its understanding of the time library</p>
<p>In this<a id="_idIndexMarker280"/> case, I have imported the <code>time</code> library just as I did in the Notepad++ example from <em class="italic">Figure 4</em><em class="italic">.1</em>. I’m a little further along here. I have my function defined, and I’m going to simply print the current local time using the <code>time</code> library I had already imported. As you can see in <em class="italic">Figure 4</em><em class="italic">.2</em>, PyCharm is offering completion against the contents of the time library.</p>
<p class="callout-heading">Completing the auto-completion</p>
<p class="callout">Once the auto-completion list appears, you can press <em class="italic">Tab</em> or <em class="italic">Enter</em> to select the highlighted option. You can use the up and down arrow keys to move through the list, or you can click any of the list items with your mouse. You’ll work fastest, though, if you keep your fingers on the keyboard.</p>
<p>By now, you are starting to appreciate the code completion system offered by PyCharm. Let us further explore the capabilities of this important tool.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>It duzunt assewm yew cna spel</h2>
<p>Our simplistic word-list example from Notepad++ earlier already stands in sharp contrast to the more sophisticated<a id="_idIndexMarker281"/> features of PyCharm’s <a id="_idIndexMarker282"/>auto-completion engine. Let’s dig a little deeper. If your tool relies on a word list, then the second your spelling steps out of line, your suggestion list dries up. In effect, the word-list method requires you to know what it is you are looking for while requiring it to be spelled correctly.</p>
<p>In <em class="italic">Figure 4</em><em class="italic">.3</em>, you will see something a little different:</p>
<div><div><img alt="Figure 4.3: PyCharm finds all possibilities containing the text you’ve typed" src="img/B19644_04_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: PyCharm finds all possibilities containing the text you’ve typed</p>
<p>PyCharm is designed to offer suggestions based on the letters that are typed. In other words, as you type <code>cl</code>, the word <em class="italic">clock</em> might appear. The word <em class="italic">clock</em> will also appear if you type <code>lo</code>, <code>ck</code>, or any consecutive letters contained in the list of keywords matched. Perfectly spelled words are not necessary. Just get in the ballpark, and the word you are searching for will likely pop up.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>It understands your code</h2>
<p>Good code completion<a id="_idIndexMarker283"/> is able to understand and autocomplete based on the language and the libraries in use. In our case, that’s Python, which has an enormous standard library compared to other languages. Python is designed around a “batteries included” philosophy. Contrast that with JavaScript as implemented in Node.js, where the only libraries you get are file and HTTP libraries. The .NET languages give you a small core. You can say the same about Golang. Most languages require you to use the package manager. The fact that PyCharm can do this is spectacular by itself.</p>
<p>PyCharm, being a great IDE, can also understand the code you’ve written. <em class="italic">Figure 4</em><em class="italic">.4</em> shows the <code>autocomplete_demo.py</code> file, where I have added an import to the <code>no_problemo.py</code> file. The <code>no_problemo.py</code> file has one function in it called <code>perfection()</code>. As you can see, PyCharm is able to see inside the file and provide autocompletion on the code I have written versus simply doing auto-complete from a language-based word list:</p>
<div><div><img alt="Figure 4.4: PyCharm provides autocompletion suggestions on the code you’ve written, as well as standard Python language and the standard library" src="img/B19644_04_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: PyCharm provides autocompletion suggestions on the code you’ve written, as well as standard Python language and the standard library</p>
<p>I am offered auto-completion on the function name, as well as hints<a id="_idIndexMarker284"/> on the <strong class="bold">method signature</strong>. If you’re unfamiliar with the term <em class="italic">method signature</em>, it simply refers to the name, argument list, and <a id="_idIndexMarker285"/>return values for a function or method. If you’ve included type hints, PyCharm will remind you of the argument names and types the function or method requires. This works with modules as well as classes if you’re <a id="_idIndexMarker286"/>using <strong class="bold">object-oriented </strong><strong class="bold">programming</strong> (<strong class="bold">OOP</strong>).</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Postfix code completion</h2>
<p>Traditional<a id="_idIndexMarker287"/> code completion has been taken to the next level in PyCharm, but we are far from finished. Usually, hitting the period (<em class="italic">.</em>) key on your keyboard triggers a list to appear. We are now used to that list containing what might come after the dot. However, what if PyCharm could give you suggestions on what might come <em class="italic">before</em> the dot? In <em class="italic">Figure 4</em><em class="italic">.5</em>, we see an example of postfix code completion, which you will find in the <code>postfix_example.py</code> file in the <a href="B19644_04.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a> sample code:</p>
<div><div><img alt="Figure 4.5: Postfix completion in PyCharm can suggest what might come before the dot rather than simply what might come after" src="img/B19644_04_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Postfix completion in PyCharm can suggest what might come before the dot rather than simply what might come after</p>
<p>I can’t blame you if you are confused by seeing <code>.if</code> (if expr) as a possibility following what is clearly a string-typed variable. The <code>.if</code> suggestion is not part of Python. It is a <strong class="bold">postfix suggestion</strong>. If you<a id="_idIndexMarker288"/> complete this suggestion your code is transformed. The following code isn’t viable Python syntax:</p>
<pre class="source-code">
b.if</pre> <p>Therefore, it is converted to the following:</p>
<pre class="source-code">
if b:</pre> <p>Just imagine <a id="_idIndexMarker289"/>the possibilities! However, if you’re not the imaginative type, check out <em class="italic">Figure 4</em><em class="italic">.6</em>, which shows PyCharm’s <strong class="bold">Postfix Completion</strong> configuration options:</p>
<div><div><img alt="Figure 4.6: PyCharm’s Postfix Completion configuration options" src="img/B19644_04_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: PyCharm’s Postfix Completion configuration options</p>
<p>Naturally, these options are fully configurable. You can even add your own! The templates are not limited to Python. You<a id="_idIndexMarker290"/> can see in the list that there are configurations for TypeScript, JavaScript, and <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>). This is important because application development is rarely limited to the scope of just the Python language.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Hippie completion</h2>
<p>Hey, man! You wanna see something <a id="_idIndexMarker291"/>that is like totally far out? It’s called <strong class="bold">cyclic word expansion</strong>. Only total squares call it that, though. If you wanna be <em class="italic">hip</em>, you’ll<a id="_idIndexMarker292"/> call it <strong class="bold">hippie completion</strong>!</p>
<p>Hippie completion <a id="_idIndexMarker293"/>is invoked by pressing <em class="italic">Alt</em> + <em class="italic">/</em> (Windows and Linux) or <em class="italic">⌥</em> + <em class="italic">/</em> on macOS. Once triggered, PyCharm will index all the files you currently have open and provide auto-completion suggestions based on words within that context. In effect, you are using the simplest form of auto-complete; a word list. The word list is generated on the fly from the words in the files you have open. They don’t have to be code. Plain text files, markup, markdown, or really any text will show up in the suggestions list based on a simple forward match. As you type, the list narrows. You can see an example in <em class="italic">Figure 4</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 4.7: Hippie completion is totally far-out!" src="img/B19644_04_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: Hippie completion is totally far-out!</p>
<p>The text file on the right contains a list of words<a id="_idIndexMarker294"/> I generated at <a href="https://fungenerators.com/lorem-ipsum/hippie/">https://fungenerators.com/lorem-ipsum/hippie/</a>. Unfortunately, it turns out, a lot of the iconic words from the hippie generation in the United States cannot be printed in a book of this caliber. We have the highest standards! So, I edited the list, and this was all that was left. These words are random, so please don’t try to construe any meaning from them, despite all the allegations about there being secret backward messages on albums by The Beatles. The code on the right can expand from that list using hippie completion. To <a id="_idIndexMarker295"/>make this work, I typed <code>print("pat</code> then pressed <em class="italic">Alt</em> + <em class="italic">/</em>. The word <em class="italic">patchouli</em> magically<a id="_idIndexMarker296"/> appeared! I hope this example was worth it for you. I may never get that smell out of my keyboard!</p>
<p>You can use <em class="italic">Alt</em> + <em class="italic">Shift</em> + <em class="italic">/</em> or <em class="italic">⌥</em> + <em class="italic">Shift</em> + <em class="italic">/</em> to enable backward cyclic word expansion, which matches from the end of the words backward to the beginning. If the powers that be had asked me (and they didn’t, because they never do) I’d have called this <code>#GingerRogersCompletion</code> and reference this book, it might catch on!</p>
<p class="callout-heading">Pro hippie tip</p>
<p class="callout">Repeatedly pressing <em class="italic">Alt</em> + <em class="italic">/</em> (Windows and Linux) or <em class="italic">⌥</em> + <em class="italic">/</em> on macOS cycles through the list. You can just keep hitting the key combination until the word you are looking for appears.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Indexing</h2>
<p>There are <a id="_idIndexMarker298"/>various engines at work in powering PyCharm’s various code completion techniques. You might be wondering how it works. It isn’t dark sorcery, I assure you. The key to understanding it is to pay attention when PyCharm loads a project. <em class="italic">Figure 4</em><em class="italic">.8</em> calls your attention to the bottom of the PyCharm application window. PyCharm kicks off several background processes that comb through your code and index every character. The index is then converted into an in-memory database that is used by the various engines at play:</p>
<div><div><img alt="Figure 4.8: Keep an eye on the bottom of the PyCharm window to know when background processes such as indexing are running" src="img/B19644_04_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: Keep an eye on the bottom of the PyCharm window to know when background processes such as indexing are running</p>
<p>Normally, I <a id="_idIndexMarker299"/>don’t really care how the magic works, but it is worth bringing up because there will be times when PyCharm seems slow or unresponsive. When PyCharm seems slow or if auto-completion isn’t working, check the area of the screen indicated in <em class="italic">Figure 4</em><em class="italic">.8</em> and see whether there are indexing processes running. You’ll probably notice your CPU spike as well if you monitor such things. This is temporary. Once the indexing process completes, PyCharm will become responsive again.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Power Save Mode</h2>
<p>One of the<a id="_idIndexMarker300"/> more cryptic entries in the PyCharm menu, shown in <em class="italic">Figure 4</em><em class="italic">.9</em>, is <strong class="bold">Power </strong><strong class="bold">Save Mode</strong>:</p>
<div><div><img alt="Figure 4.9: The Power Save Mode menu option can be found under the File menu" src="img/B19644_04_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: The Power Save Mode menu option can be found under the File menu</p>
<p>I remember<a id="_idIndexMarker301"/> the first time I clicked it. The streetlights throughout the city block where I live instantly got brighter. My electric meter that was spinning like a buzzsaw mere minutes ago was now lazily spinning slower than an abandoned top. Once, a guy at the power company even called and thanked me for doing my part in saving the planet.</p>
<p>OK, I’m making all that up, except for the part about the guy from the power company. That totally happened. The <code>b.if</code> from the earlier example:</p>
<div><div><img alt="Figure 4.10: A message reminds you that power save mode is on and that you will not be receiving the usual level of assistance from PyCharm" src="img/B19644_04_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: A message reminds you that power save mode is on and that you will not be receiving the usual level of assistance from PyCharm</p>
<p>Personally, I consider<a id="_idIndexMarker302"/> this utterly barbaric! How are we supposed to work like this? Next, you’ll be telling me I don’t have access to the internet, Kite, GitHub Copilot, ChatGPT, or Stack Overflow! You’ll strip me of my very reasonably priced subscription to <a href="http://packtpub.com">packtpub.com</a>, where I can get all the e-books I can read for one low price. Then you’ll take away my Herman Miller Aeron Chair and limit me to only one $14 mezzo-Grande half-fat triple foam double shot latte with rainbow jasmine-infused sprinkles per day! Why don’t you enact a dress code while you’re at it? Strike! Strike! Strike!</p>
<p>Sorry. I got a little carried away. Needless to say, this is probably the least favorite feature of the IDE. Maybe it is useful if you chewed up your laptop’s battery playing <em class="italic">Ghost Recon: Breakpoint</em> on an overseas flight, and upon landing, you suddenly get a call from the boss who needs something fixed right away. Suddenly, you need to squeeze every second out of that 5% battery level you have left. I hate it when that happens.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Customizing code completion</h1>
<p>Customization <a id="_idIndexMarker303"/>within PyCharm is an ongoing theme. It might have been easier to show you what you can’t customize, except that I haven’t actually found anything yet. Code completion is no different. Whether you prefer a very lightweight experience with little to no help or you want your handheld on every line of code, there is a way to make PyCharm into the editor you want to use every day.</p>
<p>To open the settings for code completion, venture back to the settings dialog we explored in <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation and Configuration</em>. You can reach it easily by clicking the <strong class="bold">File</strong> menu item and selecting <strong class="bold">Settings</strong>. That brings up the settings dialog. If you recall from <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation and Configuration</em>, this dialog is massive! We’re looking for <strong class="bold">Editor</strong> | <strong class="bold">General</strong> | <strong class="bold">Code Completion</strong>, as shown in <em class="italic">Figure 4</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 4.11: The Code Completion settings allow you to customize the behavior of PyCharm’s Code Completion engine" src="img/B19644_04_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: The Code Completion settings allow you to customize the behavior of PyCharm’s Code Completion engine</p>
<p>You should spend a moment going through everything you can do on this screen. PyCharm gives you a great deal of control! I promised this wouldn’t be a tedious accounting of<a id="_idIndexMarker304"/> every option. Instead, draw your attention to the most popular and potentially most useful sett<a id="_idTextAnchor088"/>ings available.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/>Match case</h2>
<p>Located at the<a id="_idIndexMarker305"/> top of the window, this option specifies whether items in the suggestion list should match the case of whatever you are typing. For example, if I wanted to type in an exception expression for the <code>KeyboardInterrupt</code> exception in Python and the <code>K</code> for the correct class name to be included in the suggestion list. Next to the <strong class="bold">Match case</strong> checkbox, you can also choose only the first letter’s case should be matched or whether this should apply to all the letters.</p>
<p>I personally always disable this checkbox so that I only have to type in, for example, a lowercase <code>k</code> to take advantage of code completion. When I am learning a new language or API, this setting can help me with a practice I call <em class="italic">property shopping</em>. I don’t know what properties and methods are available, so an alphabetized list can be helpful. For example, every programming language has some sort of string-handling class or library. It is a very safe bet that the said library will have functions for trimming, which is to remove extra spaces from the front, end, or both ends of a string. There is always some sort of <code>toUpper</code> and <code>toLower</code> methods. These are all vital parts of defensive programming. A password input where a user accidentally includes a space at the beginning or end of the password makes for a frustrating user experience. Any conditional logic you use involving user input is easier to handle if you make everything upper or lowercase. Given these are so fundamental to our work, we know they will be on the list, but every language calls them something different. I work on projects that require switching between two or three languages, and it is very easy to type in the wrong function name. Take the method that converts a string to uppercase. In JavaScript, such a function looks like this:</p>
<pre class="source-code">
let foo = "some user option";
if(foo.toUpperCase() === "SOME USER OPTION"){
 console.log("It matched!");
}</pre> <p>The same code in PyCharm, which I might be creating only minutes later, would look like this:</p>
<pre class="source-code">
foo = "some user option"
if foo.upper() == "SOME USER OPTION":
  print("It matched")</pre> <p>In order to<a id="_idIndexMarker306"/> be effective, I need the word upper to be a match regardless of whether it is uppercase or lowercase.</p>
<p>Like everything we have seen in code completion, and for that matter, like everything in programming, there is a trade-off to this practice. Specifically, if <strong class="bold">Match case</strong> is disabled, sometimes the suggestion list might be populated by many more irrelevant options, which makes finding the correct API more difficult. At the same time, though, you will see a full list of what is possible, which can help you learn your way around and sometimes discover features in an API you had not imagined<a id="_idTextAnchor090"/> were available.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/>Sorting suggestions alphabetically</h2>
<p>As its<a id="_idIndexMarker307"/> name suggests, this option allows you to sort the items in the suggestion list in alphabetical order. This feature is useful for long suggestion lists that require the developer to scroll through them carefully to find what they are looking for if they were not ordered alphabetically.</p>
<p>On multiple occasions, we have seen the dynamic nature of PyCharm, and it is once again demonstrated in this feature. Specifically, while interacting with a suggestion list in the editor, you can change the order of the items in the list at any time by clicking on the icon located in the bottom-right corner of the suggestion window, as shown in <em class="italic">Figure 4</em><em class="italic">.12</em>:</p>
<div><div><img alt="Figure 4.12: You can change the way suggestions are sorted within the list itself" src="img/B19644_04_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12: You can change the way suggestions are sorted within the list itself</p>
<p>Clicking <a id="_idIndexMarker308"/>the <strong class="bold">…</strong> (ellipsis) element allows you to change how the suggestions are sorted: by relevance or alphabetically by name.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/>Machine learning assisted completions</h2>
<p>This<a id="_idIndexMarker309"/> newer option is simultaneously magical and scary. Enabled by default, PyCharm will train a machine learning model based on your code. This allows PyCharm to make suggestions based not only on your code but also that of thousands of other developers. Traditional code completion usually gives you suggestions for the next keyword, property, method name, or parameter you are about to type. Do not be surprised if PyCharm offers complete entire functions or blocks of code for you with machine learning assisted completions. You will see this for common tasks such as connecting to databases, working with pandas data frames, or validating user input.</p>
<p>The settings merely allow you to turn on various languages supported by PyCharm. Python, JavaScript, and TypeScript are enabled by default. Only SQL, a special-purpose language used for working with relational databases, is not enabled by default. I suspect this is because there are additional settings around your preferred SQL dialect both at the global and project level that contribute to suggestions. It would be awkward to expect a <a id="_idIndexMarker310"/>tight list of suggestions given the number of databases PyCharm supports and the differences in their implementation of language elements not defined by standardized SQL. We’ll look at SQL and relational databases later in <em class="italic">Chapter 11</em>, <em class="italic">Understanding Database Management with PyCharm</em>. I promise the experience will not<a id="_idTextAnchor093"/> leave you bankrupt.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor094"/>Showing the documentation popup in [...] ms</h2>
<p>When you <a id="_idIndexMarker311"/>enable this feature, you will see the documentation in addition to the suggestion code. You will be able to understand what the code you are typing does rather than blindly accepting the suggestions. This is great for new developers, whether they are totally new to coding or just new to Python. The advantage of this feature is that you can go through the documentation of all the suggested items dynamically as you simply move the cursor down the items.</p>
<p>This is especially beneficial when working with classes and methods that have similar APIs. We will discuss this feature, along with other documentation-related functionalities, in the last section of this chapter.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor095"/>Parameter info</h2>
<p>Scroll down <a id="_idIndexMarker312"/>past the JavaScript section, as seen in <em class="italic">Figure 4</em><em class="italic">.13</em>, and you’ll find an option for suggesting parameter information:</p>
<div><div><img alt="Figure 4.13: Scroll down past JavaScript to find options for showing parameter information" src="img/B19644_04_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13: Scroll down past JavaScript to find options for showing parameter information</p>
<p>The<a id="_idIndexMarker313"/> first option is straightforward. It controls the amount of time that must elapse before a suggestion appears. In general, suggestions are great unless you are teaching, doing a code review, or doing some sort of demo, in which case they can clutter up your screen. Sometimes it’s a good idea to raise the time limit so the suggestions or documentation are shown only if you linger for a few seconds.</p>
<p>The second option allows you to toggle, showing the full method signature. I love this feature. The code hint will show you the whole method signature so you can see all the arguments at once.</p>
<p>A method signature uniquely defines a function or method within the scope where it is declared. It consists of a name for the function. Along with the names, and preferably hints, for the type of the function’s arguments with some hints about the return type. These are not unique to Python. In fact, they are a little bit fuzzy in Python. Now compare it with a static language such as C#, which uses more strict programming structures. In Python, you can use type hints, which help developers to remember the expected types of the arguments being passed. Let’s look at an example of a method signature without hints:</p>
<pre class="source-code">
a = 5
b = 6
def add_two_ints(first, second):
  return a + b</pre> <p>This is OK. This<a id="_idIndexMarker314"/> code will work as intended, and the intention of the developer is clear. Let’s look at the same function with hints:</p>
<pre class="source-code">
a = 5
b = 6
def add_two_ints(first: int, second: int) -&gt; int:
  return a + b</pre> <p>This is much better! Now we know for certain the types that are expected as input parameters, and we know the type that is going to be returned. I said earlier that method signatures are “fuzzy” in Python. I said this because both code samples will work. Python ignores the hints entirely during compilation. The hints are just used by the tooling and make your Python code easier to read and understand. Adding hints to your code whenever possible will enhance the way you, and your teammates, see your method signatures if you turn on the <strong class="bold">Show full method </strong><strong class="bold">signatures</strong> option.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor096"/>Code analysis and automated fixes</h1>
<p>Code completion is a standard feature of most code editors and IDEs. As we’ve seen, not all completion <a id="_idIndexMarker315"/>engines are created equally. The same can be true for analysis engines. A code analysis engine is an extension of code completion in concept, if not in implementation. Code completion tries to predict the code you are writing and helps you finish more quickly. Code analysis examines the code you’ve written<a id="_idIndexMarker316"/> and attempts to determine whether or not the code will work when you run it. Just as with code completion, there are differing levels of complexity at play here and different processes examining different things.</p>
<p>The simplest form of analysis is<a id="_idIndexMarker317"/> called <em class="italic">linting</em>. Pretty much every programming language has a linting tool, and Python is no exception. While there are many to choose from, PyCharm uses the popular <code>pylint</code> library by default.</p>
<p>A linter runs a tacit analysis of your code through a process of pattern matching. There are two<a id="_idIndexMarker318"/> linting operations: <strong class="bold">logical lint</strong> and <strong class="bold">stylistic lint</strong>. A<a id="_idIndexMarker319"/> logical lint <a id="_idIndexMarker320"/>looks for code errors, code with potentially unintentional results or side effects, and dangerous code patterns. A stylistic lint<a id="_idIndexMarker321"/> looks for code that doesn’t conform to common conventions. This is less of a problem with Python since the language already has a strict set of code formatting rules called <strong class="bold">Python Enhancement Proposal #8</strong>. Nobody calls it that. Those in the <a id="_idIndexMarker322"/>know simply call it <strong class="bold">PEP-8</strong>.</p>
<p>Combined, you can think of <code>pylint</code> and, by extension, all linters, much like a spelling and grammar checker for regular text. The linter looks for misspelled keywords, malformed code, and obvious syntax errors. A linter can also enforce style guidelines, though really Python is already designed to enforce rules to make your code as human-readable as possible.</p>
<p>While it’s one thing to point out problems in your code, it is entirely more useful if the tool also suggests and even implements fixes to those problems. The same is true of humans. It is easy to point out flaws. Anybody can do that. Good advice on how to fix your flaws is more useful than criticism. So, in addition to linting, PyCharm offers a system that will offer to help you fix the problems exposed by the linter.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor097"/>Problem detection</h2>
<p>Problem detection<a id="_idIndexMarker323"/> is performed by PyCharm in real time as you type your code. The indexing process we’ve mentioned before plays a role here, but we’ll come back to that. First, let’s focus on the visible interface in the editor that shows you where your problems lie. There are four places to look, as shown in <em class="italic">Figure 4</em><em class="italic">.14</em>:</p>
<div><div><img alt="Figure 4.14: Four places in the user interface tell you that you have problems" src="img/B19644_04_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14: Four places in the user interface tell you that you have problems</p>
<p>The <a id="_idIndexMarker324"/>right gutter of the editor (1) will show you where all the problematic lines lie in the currently open file. This gutter is a compressed, miniature representation of your file. It is pretty common for a file to have hundreds or maybe even thousands of lines. You can click on the area in the gutter where you see the colored marks, and the editor will scroll to that location.</p>
<p>PyCharm will classify the problems into three basic categories: errors (red), warnings (yellow), and weak warnings (gray). This is reported for the whole file at the top of the gutter column with counts of each problem type (2). In addition to colors, this area gives you different shapes. The error icon is a round red circle with an exclamation point within it. Warnings are a triangle with an exclamation point. Weak warnings are also depicted using a triangle with an exclamation, but they appear considerably dimmer. If no problems are detected, you are rewarded with a green check mark. <em class="italic">Figure 4</em><em class="italic">.15</em> shows two files. One has no problems (1), while the other has a number of issues in different categories (2):</p>
<div><div><img alt="Figure 4.15: The file on the bottom is devoid of any problems, while the one on top isn’t quite as lucky" src="img/B19644_04_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15: The file on the bottom is devoid of any problems, while the one on top isn’t quite as lucky</p>
<p>Anything <a id="_idIndexMarker325"/>marked in red is an error that will probably prevent your program from running correctly or at all. A warning means your code will probably run, but there are some obvious cases where it won’t perform as expected. A weak warning is usually a minor flaw, such as a variable name that doesn’t conform to an English dictionary word. If your locale is set to a language other than English, PyCharm will flag words from your local language.</p>
<p>The second place to look for problems is within the editor window itself. Look back at <em class="italic">Figure 4</em><em class="italic">.15</em> at line 13. You’ll see a squiggly red (trust me) underline beneath the word <code>math</code>. The colors of the lines correspond with the severity of the problem. The right-hand gutter shows you where the problem is located, while the underlines show you the problem directly on the offending line. If you hover your mouse over whatever is underlined, you’ll get a description of the problem. I’ll go into more depth on this later in this chapter when we talk<a id="_idIndexMarker326"/> about <strong class="bold">intentions</strong>, which are suggestions about how to fix problems in your code.</p>
<p>The third place you’ll find indicators of problems is the project explorer. Refer back to <em class="italic">Figure 4</em><em class="italic">.15</em>, area 3. There is a Python package called <code>bad_actor</code>. That file isn’t open in <em class="italic">Figure 4</em><em class="italic">.15</em>, but I opened it when I created it, typed in some incomplete code, then closed the file. You can see the file open in <em class="italic">Figure 4</em><em class="italic">.16</em>:</p>
<div><div><img alt="Figure 4.16: Silly me! I started typing in the file but never finished" src="img/B19644_04_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16: Silly me! I started typing in the file but never finished</p>
<p>If there is <a id="_idIndexMarker327"/>an error in the file you aren’t currently working on, you’ll find it flagged in the file list. The warning will bubble up through the directory system. There’s a red squiggly line at the top project folder, another in the folder for the package, and still another underline beneath the file where the problem lies. PyCharm doesn’t examine closed files. It only examines files you open, but once it finds the problem, it will remember where it is and continue to warn you until you fix the problem.</p>
<p class="callout-heading">Bad actor</p>
<p class="callout">I needed an exemplary bad actor for the previous visual pun. Kevin Costner is a bad American actor. He certainly isn’t the worst, but he’s easily in the top 10. If you don’t believe me, watch the movie <em class="italic">Dances with Wolves</em>. If you still don’t believe me, watch <em class="italic">The Bodyguard</em>. If you still think he’s great, watch <em class="italic">Waterworld</em> and realize he financed that movie out of his own pocket because he was convinced it would be a mega-hit.</p>
<p>The fourth place is the problems window. In <em class="italic">Figure 4</em><em class="italic">.17</em>, you can see a red dot over an icon in area 4 in <a id="_idIndexMarker328"/>the screenshot. Click the icon, and the problems window will open and show you a list of faults, as seen in <em class="italic">Figure 4</em><em class="italic">.17</em>:</p>
<div><div><img alt="Figure 4.17: Open the problem window to see a list of all your problems. Only your code problems are displayed. Life problems are not shown" src="img/B19644_04_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17: Open the problem window to see a list of all your problems. Only your code problems are displayed. Life problems are not shown</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Syntax errors</h2>
<p>Syntax errors<a id="_idIndexMarker329"/> are usually the shallowest errors exposed by an IDE. We’ve seen a few already. <em class="italic">Figure 4</em><em class="italic">.17</em> shows an incomplete function definition, so it is flagged in red as a syntax error. In <em class="italic">Figure 4</em><em class="italic">.14</em>, line 13 has a red underline beneath the word <code>math</code>. PyCharm recognizes this as a reference to the Python <code>math</code> library, which I have neglected to import. This throws an unresolved reference error. These kinds of errors are always marked in red as severe errors because they will prevent the program from running.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor099"/>Duplicated code</h2>
<p>If you <a id="_idIndexMarker330"/>make a habit of copying and pasting code within your project or even between different projects, you can expect a warning from PyCharm. Duplicated code is a sign your project is in trouble.</p>
<p>The best practice is to follow the <a id="_idIndexMarker331"/>concept called <strong class="bold">Don’t Repeat Yourself</strong> (<strong class="bold">DRY</strong>). I’ll say it again. You want your code to always be DRY. Never repeat your code by copying and pasting. Make sure it’s DRY. OK, I’ll stop if you promise to heed PyCharm’s warnings about code not being DRY.</p>
<p>When you find this problem within a single project, you can usually fix it by hoisting the duplicated code into a function and calling the function from the parts of your code where the duplicates lie.</p>
<p>If you get flagged for copying and pasting between projects, you should turn the duplicated code into a Python package that can be shared between projects.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor100"/>PEP-8 problems</h2>
<p>PyCharm’s<a id="_idIndexMarker332"/> linter alerts you to styling problems in your code that violate PEP-8. The biggest problem for developers new to Python is dealing with the rules around white space. Indentions and empty lines between functions are all part of the PEP-8 rules designed to keep your code very readable. Most PEP-8 problems are flagged as warnings.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor101"/>Dead code</h2>
<p>This is<a id="_idIndexMarker333"/> my personal pet peeve. Someone writes some code, which ultimately gets replaced with a different function. Both the old and the unused function are sitting in the code file, along with the new one. They might have similar names. They might even be in different files. When I was a kid, I had a poster on my wall titled Murphy’s Laws of Technology. The poster espoused a pessimistic but, in my experience (and probably yours if you’ve been doing this for a while), totally accurate worldview. Here’s a sampling of Murphy’s Laws with respect to technology:</p>
<ul>
<li>You can never tell which direction the train traveled by looking at the track</li>
<li>Logic is a systematic method of coming to the wrong conclusion with confidence</li>
<li>Whenever a system becomes completely defined, some fool discovers something which either abolishes the system or expands it beyond recognition</li>
<li>Technology is dominated by those who manage what they don’t understand: if builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization</li>
<li>The attention span of a computer is only as long as its electrical cord</li>
<li>An expert is one who knows more and more about less and less until he knows absolutely everything about nothing</li>
</ul>
<p>This<a id="_idIndexMarker334"/> is relevant because, at least for me, the likelihood that I will find and attempt to modify dead code (thinking it to be very much alive and the obvious source of all my problems) in a software system asymptotically approaches 100%. The tiny degree of variance somewhere between 99% and 100% seems to be affected by my present level of caffeination and whether I skipped breakfast. These effects appear to be inversely proportional.</p>
<p>I thank goodness for a system that warns me that I’m looking at dead code. My usual rant is that you should take dead code out. You won’t need it, and if you do, that’s what revision control systems are for.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>Method signature mismatches</h2>
<p>A <a id="_idIndexMarker335"/>method signature mismatch happens when a function requires more or fewer arguments than the number you supplied. PyCharm will warn you when this happens.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/>The road to good code is paved with PyCharm’s intentions</h2>
<p>Now that<a id="_idIndexMarker336"/> we’ve spent time learning about our flaws, let’s <a id="_idIndexMarker337"/>look at some tools that help us fix them. PyCharm features a mechanism called intentions designed to<a id="_idIndexMarker338"/> automate fixing and improving your code. Take a look at <em class="italic">Figure 4</em><em class="italic">.18</em>:</p>
<div><div><img alt="Figure 4.18: Hover your mouse over any underlined code to see why it is underlined, along with possible fixes" src="img/B19644_04_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18: Hover your mouse over any underlined code to see why it is underlined, along with possible fixes</p>
<p>In the<a id="_idIndexMarker339"/> case <a id="_idIndexMarker340"/>of the<a id="_idIndexMarker341"/> code shown, the problem is I invoked the <code>sqrt()</code> method, which finds the square root. The method is a static method in the <code>math</code> class. The problem is I failed to import that class. The description of the problem appears just below the underline when I hover. Below the problem description is the most likely fix. Pressing <em class="italic">Alt</em> + <em class="italic">Shift</em> + <em class="italic">Enter</em> will automatically fix the problem by adding <code>import math</code> to the top of the file.</p>
<p>If you’d like to try this out, you can use the <code>inspection</code> project in the <code>chapter-04</code> folder of the sample code we cloned in <a href="B19644_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Installation </em><em class="italic">and Configuration</em>.</p>
<p>Note this might not be the only possible fix. In <em class="italic">Figure 4</em><em class="italic">.18</em>, we can also see <strong class="bold">More actions…</strong> prompting us to either click the link or press <em class="italic">Alt</em> + <em class="italic">Enter</em> to see more possibilities.</p>
<p>Truly astute readers might have noticed the lightbulb. This is an alternate vector to the same feature. Check out <em class="italic">Figure 4</em><em class="italic">.19</em> to see the lightbulb in action:</p>
<div><div><img alt="Figure 4.19: The lightbulb is another way to get the intentions" src="img/B19644_04_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19: The lightbulb is another way to get the intentions</p>
<p>Clicking the lightbulb shows a list of possible intentions. This time, we see a preview. The intention is going to add <code>import math</code> at line 1 of the file.</p>
<p>The<a id="_idIndexMarker342"/> lightbulbs <a id="_idIndexMarker343"/>can be tricky <a id="_idIndexMarker344"/>sometimes because they have a tendency to disappear if you move off the line <a id="_idIndexMarker345"/>where they originally appeared. If you’d like to use the lightbulb, just click anywhere within the underline and wait for a tick. It will appear at the beginning of the line where the problem lies.</p>
<p>In the case we’re exploring, the problem is a legitimate error. The program won’t run until we fix the problem. You can’t see it in the previous two figures, but the lightbulb is red. You’ll also see yellow lightbulbs for less egregious problems.</p>
<p>Now if you’re like me, you want to see a clean file with a green check and no underlines. Let me tell you, that will probably never happen. PyCharm will almost always find something to change. Sometimes the suggested changes are not very useful. You might heed a suggestion that changes your code in some minor way. Right after you do this, the lightbulb comes back, and PyCharm offers to change the code back to the way it was. Yellow light bulbs are not your enemy unless they have an exclamation point in them.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor104"/>Refactoring</h1>
<p>Most <a id="_idIndexMarker346"/>good IDEs, and development-focused text editors, for that matter, feature some level of tooling for refactoring. Refactoring is a very important practice that is often neglected. In my book, which is available on Amazon (or wherever the finest technical books are sold), <em class="italic">Real-World Implementation of C# Design Patterns</em>, I cover some of the entropic forces that lead a well-intended coding project to ruin. Your code starts off pristine, and the whole team commits to maintaining zero technical debt. But it never lasts. Factors such as time pressure, developer skill level, inevitable change, visibility, and complexity cause a process of devolution. Your code goes from a well-constructed, perfectly architected masterpiece to a big ball of mud on a plate of spaghetti!</p>
<p>I realize that I am pointing to a C# book here, but if you have a Packt subscription, I urge you to read the first two chapters of the book. The chapters discuss the common problems and preventions of work degradation. One thing you can do is to be vigilant and never dismiss the value of refactoring your code as a regular part of the development practice.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor105"/>What is refactoring?</h2>
<p>Simply put, refactoring is improving code without changing its functionality. If you have unit tests (you do, RIGHT!?!??!), they should pass before and after refactoring without any changes to the tests themselves. You are looking for ways to optimize your code in terms of readability and performance. Maybe you skipped some code niceties, such as adding <strong class="bold">docstrings</strong>, which <a id="_idIndexMarker347"/>we’ll cover later in this chapter. Maybe you didn’t add type hints to your method signatures. Perhaps there are opportunities to leverage design patterns or SOLID principles to make your code more flexible.</p>
<p>The idea behind refactoring is that you are taking a second look at your code, preferably after a little time has passed. Have you ever looked at code you wrote a month or even a year ago and wondered what possessed you to type that horrible function body? Why in the world did you _________? (Fill in the blank with something silly you did.) You can’t believe that was you. You are smarter than that. Consider having regular peer reviews of your code. This can happen at any time during the writing process. Also, having someone less invested in your work will be able to spot unrealized opportunities for improvement. Almost always, this will involve refactoring. Flip things around. How many times have you been handed some code written by another developer? Maybe the person that <a id="_idIndexMarker348"/>has left the company? You look it over and conclude that whoever wrote the code was clearly a recent escapee from the local asylum. It must be totally rewritten. This is you refactoring someone else’s code.</p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor106"/>Refactoring tools in PyCharm</h2>
<p>PyCharm <a id="_idIndexMarker349"/>has a set of menu options dedicated to refactoring. There are a few that are not explicitly called out as refactoring tools.</p>
<h3>Cleaning up your code</h3>
<p>PyCharm <a id="_idIndexMarker350"/>has a very thorough <strong class="bold">Code Cleanup</strong> tool. This<a id="_idIndexMarker351"/> tool, in effect, runs the same inspections you have seen so far, but it does them in bulk. You can have PyCharm try to fix all the problems as well. This feature is useful when you import a project created outside of PyCharm, say with a tool that doesn’t offer the kind of assistance you have seen in PyCharm.</p>
<p>You can clean up an open file or all files in your project. To be honest, I don’t recommend you do this at the project level since you can’t really predict what the engine will do to a large set of files you haven’t even opened. <em class="italic">Figure 4</em><em class="italic">.20</em> shows the menu location for <strong class="bold">Code Cleanup</strong><strong class="bold">…</strong>:</p>
<div><div><img alt="Figure 4.20: The Code Cleanup tools can be found in the Code menu" src="img/B19644_04_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20: The Code Cleanup tools can be found in the Code menu</p>
<p>Once<a id="_idIndexMarker352"/> you click the menu option, you’ll see a dialog asking <a id="_idIndexMarker353"/>about the scope of the clean-up, as seen in <em class="italic">Figure 4</em><em class="italic">.21</em>:</p>
<div><div><img alt="Figure 4.21: Specify the scope of the code cleanup" src="img/B19644_04_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21: Specify the scope of the code cleanup</p>
<p>You can clean up the whole project, uncommitted files, the current file (which for me is <code>main.py</code> from the <code>inspection</code> project in the <code>chapter-04</code> folder of the sample source code), or a <a id="_idIndexMarker354"/>custom scope. My recommendation is not to try to boil the ocean. Do not do a <a id="_idIndexMarker355"/>whole project cleanup on a massive project. It is usually smarter to let PyCharm work its magic on small batches of files. The <strong class="bold">Uncommitted files</strong> option is a nice step you can take before you commit changes to your version control system.</p>
<h3>Renaming</h3>
<p>Donald Knuth, one <a id="_idIndexMarker356"/>of the most respected software developers of all time, wrote in his book <em class="italic">The Art of Computer Programming</em>, that there are two things in programming that are hard: naming things (e.g., variables, functions, classes, files, and so on) well, and invalidating your caches. How true this is! It is an art form to write meaningful variable definitions that are self-documenting while making your intentions clear. It usually takes several tries to get it right. PyCharm has a tool that easily allows a name change. You can right-click on anything you’ve named and select <strong class="bold">Rename</strong>. Type the new name of the thing that is to be renamed. PyCharm will affect the change everywhere the named thing is referenced. It will even find and change references in comments and docstrings.</p>
<p>If the scope of the change is small, for example, you are renaming something scoped to a local function, the rename operation happens immediately. If you are attempting a rename with a broader scope, such as one that entails multiple files, PyCharm will preview the change for you by showing you all the files that will be affected. You can inspect all the changes before they are made to make sure the changes are appropriate. After you are satisfied, you can apply those changes.</p>
<p class="callout-heading">There is no rename menu option for files!</p>
<p class="callout">This is confusing if you come from another tool such as Visual Studio Code, where renaming files is a simple matter of picking the file from the explorer view and clicking twice or pressing <em class="italic">F2</em>. You’ll hunt for the rename option for files, and you will not find one. That’s because it is in the <strong class="bold">Refactor</strong> menu. PyCharm considers renaming a file a refactor. Unlike other tools, PyCharm will make sure renaming the file doesn’t affect your code.</p>
<h3>Inlining variables</h3>
<p>PyCharm <a id="_idIndexMarker357"/>gives you the ability to automatically inline your variables. In fact, this is among the more common suggestions PyCharm provides. Consider this code:</p>
<pre class="source-code">
a = 5
b = 6
def add_two(num1: int, num2: int) -&gt; int:
  sum = num1 + num2
  return sum
add_two(a, b)</pre> <p>The sum variable isn’t really needed. If you inline the variable, the code becomes the following:</p>
<pre class="source-code">
a = 5
b = 6
def add_two(num1: int, num2: int) -&gt; int:
  return num1 + num2
add_two(a, b)</pre> <p>We’ve removed the line that declared the <code>sum</code> variable and assigned it the value of <code>num1 + </code><code>num2</code>.</p>
<h3>Extracting methods</h3>
<p>Earlier, I mentioned <a id="_idIndexMarker358"/>a concept called DRY, or Don’t Repeat Yourself. Yes, I realize that by mentioning it again, I am breaking the rule. I am doing so with a purpose. Remember, the IDE points out errors and then provides advice and tools to fix the problem. I’d like to present a very useful feature. PyCharm gives you a tool to easily extract code into a separate function. You will want to do this under a couple of circumstances. First, if you find yourself copying and pasting code within your project. You probably need to make that code a function and then call it from the places where you are pasting the copied code. Secondly, when you find a function that breaks the single responsibility principle. If you’ve never heard of this, you can guess what it means. A well-written program should contain functions that do only one thing. Written code that contains functions or methods that perform multiple responsibilities could be broken into separate functions.</p>
<p>Take a look at an easy example of such an opportunity. Open the <code>chapter-04/not_dry.py</code> file in the sample code. The code within is truly egregious! Sensitive viewers might want to sit down before opening the file. Behold! Something everybody has done at least once before they learned it was a bad idea:</p>
<pre class="source-code">
computer_science_grades = {
  "Guido van Rossum": 100,
  "Ewa Jodlwska": 99,
  "Fabrizio Romano": 88,
  "Henrich Kruger": 87,
  "Rick van Hattem": 83,
  "Steven Lott": 72,
  "Dusty Phillips": 72,
  "Quan Nguyen": 92
}</pre> <p>OK, so far, it is fine. We’ve got a dictionary of people who took a computer science class along with their grades. By the way, those aren’t random names. After you finish this chapter, see whether you can figure out who these illustrious individuals might be. I apologize to some of the illustrious individuals for the numbers themselves. They are meant to be more or less random keys except for Mr. van Rossum, who would obviously have gotten a perfect grade. I’m sure they all did very well in real life. Following that, we have another set of class grades:</p>
<pre class="source-code">
advanced_theoretical_and_applied_recess_grades = {
  "Bruce Van Horn": 100,
  "Prajakta Naik": 92,
  "Kinnari Chohan": 88,
  "Pooja Yadiv": 86
}</pre> <p>While it <a id="_idIndexMarker359"/>is a different subject and a different group of people, it’s the same idea. Now suppose we need to figure out the class average for each class. I can make a function for computing the average in the computer science class:</p>
<pre class="source-code">
def computer_science_average(grades: dict) -&gt; float:
  raw_total = 0
  for grade in grades.values():
    raw_total += grade
  average = (raw_total / len(grades))
  return average</pre> <p>Our method signature gives lots of good hints. We have a descriptive function name. The function takes one parameter, and our hint tells us we’re expecting a dictionary. The function is expected to return a float.</p>
<p>The function body creates a variable called <code>raw_total</code> and sets it to <code>0</code>. Next, we loop through the values of <code>dict</code> and, on each iteration, add <code>value</code> to <code>raw_total</code>. Once we have the total, we divide it by the number of keys (<code>len</code>) in <code>dict</code>, and voila! We have the class average. Towards the bottom of the file, we can see where this function is called:</p>
<pre class="source-code">
boring_class_average = computer_science_average(computer_science_grades)
print(f"Boring average is {boring_class_average}")</pre> <p>Wonderful! We have a call to our <code>computer_science_average</code> function along with a highly judgmental (and probably inaccurate since it might have been your favorite class) variable assignment. So, what’s wrong with any of this? Nothing. It’s what comes next that presents a problem and an opportunity to extract a method. The next function<a id="_idIndexMarker360"/> computes a different class: advanced theoretical and applied recess. This is a field that I personally pioneered, and within this field, I have no rival. Unfortunately, since I spent more time on the playground perfecting my art and less time in computer science class, I have all but duplicated the function we wrote earlier:</p>
<pre class="source-code">
def advanced_recess_average(grades: dict) -&gt; float:
  raw_total = 0
  for grade in grades.values():
    raw_total += grade
  average = (raw_total / len(grades))
  return average</pre> <p>It’s the same function with a different name! We need to consolidate! To do this, you need to highlight everything between the colon that ends the method signature and the <code>return</code> statement. Refer to <em class="italic">Figure 4</em><em class="italic">.22</em>. Don’t include the <code>return</code> statement, or PyCharm won’t generate a <code>return</code> statement in your extracted function:</p>
<div><div><img alt="Figure 4.22: Select the code to extract into a new function or method" src="img/B19644_04_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22: Select the code to extract into a new function or method</p>
<p>Next, right-click<a id="_idIndexMarker361"/> the selected code and click <strong class="bold">Refactor</strong> | <strong class="bold">Extract Method</strong>, as shown in <em class="italic">Figure 4</em><em class="italic">.23</em>:</p>
<div><div><img alt="Figure 4.23: Right-click the selected code, then click Refactor, then Extract Method" src="img/B19644_04_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23: Right-click the selected code, then click Refactor, then Extract Method</p>
<p>This brings up a user interface that allows you to define the new method, as seen in <em class="italic">Figure 4</em><em class="italic">.24</em>:</p>
<div><div><img alt="Figure 4.24: The ﻿Extract ﻿Method dialog in PyCharm" src="img/B19644_04_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24: The Extract Method dialog in PyCharm</p>
<p>Set the <a id="_idIndexMarker362"/>name of the extract method. I set mine to <code>compute_average</code>. PyCharm has filled in the rest automatically. Click <strong class="bold">OK</strong>, and your code will change. <em class="italic">Figure 4</em><em class="italic">.25</em> shows the result of my refactoring:</p>
<div><div><img alt="Figure 4.25: The result of the refactoring. Note the compute_average function was generated automatically from the selected code" src="img/B19644_04_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25: The result of the refactoring. Note the compute_average function was generated automatically from the selected code</p>
<p>Let’s look at<a id="_idIndexMarker363"/> the resulting code PyCharm generated from the refactor. First, <code>computer_science_average</code> has changed to this:</p>
<pre class="source-code">
def computer_science_average(grades: dict) -&gt; float:
  average = compute_average(grades)
  return average</pre> <p>This function is now calling the extracted function. The extracted function looks like this:</p>
<pre class="source-code">
def compute_average(grades):
  raw_total = 0
  for grade in grades.values():
    raw_total += grade
  total_number_grades = len(grades)
  average = (raw_total / total_number_grades)
  return average</pre> <p>This is the code we selected for extraction. PyCharm generated the function for me. I must tell you, at this point, that I’m usually wary of generated code. It is rarely perfect. Here, I would have preferred a type hint on the <code>grades</code> parameter and a hint on the return type. Those are minor issues, though, and the result saved me some typing.</p>
<p>One lingering<a id="_idIndexMarker364"/> question might remain. Why didn’t PyCharm detect and flag the duplicated code? The quick answer: our sample code is too short. If I were to add a few more lines to the duplicated functions, it would appear as a duplicate. Let’s try it out. Modify the code in both functions so it looks like this:</p>
<pre class="source-code">
def computer_science_average(grades: dict) -&gt; float:
  raw_total = 0
  fake_var_1 = 1
  fake_var_2 = 2
  fake_var_3 = 3
  fake_var_4 = 4
  fake_var_5 = 5
  fake_var_6 = 6
  fake_var_7 = 7
  print(f"{fake_var_1}{fake_var_2}{fake_var_3}{fake_var_4}")
  print(f"{fake_var_5}{fake_var_6}{fake_var_7}")
  for grade in grades.values():
    raw_total += grade
  average = (raw_total / len(grades))
  return average</pre> <p>All I did was add a bunch of fake variable declarations. They don’t do anything important except make the duplicate code fragment longer. By default, PyCharm only looks for duplicated fragments that are 10 lines or longer. Short duplications don’t make the cut. I bring this up because the magic of method extraction handles duplicates automatically. Let’s do <a id="_idIndexMarker365"/>the same exercise. First, look at PyCharm with the changes in place. You should see some indicators that we have problems, as shown in <em class="italic">Figure 4</em><em class="italic">.26</em>:</p>
<div><div><img alt="Figure 4.26: Now that our duplicated code is longer, it gets detected and flagged" src="img/B19644_04_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.26: Now that our duplicated code is longer, it gets detected and flagged</p>
<p>We can see that PyCharm has noticed our duplicated code. Highlight the code for extraction, as shown in <em class="italic">Figure 4</em><em class="italic">.27</em>:</p>
<div><div><img alt="Figure 4.27: Mark the code for extraction" src="img/B19644_04_27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.27: Mark the code for extraction</p>
<p>Right-click the<a id="_idIndexMarker366"/> highlighted code and click <strong class="bold">Refactor</strong> | <strong class="bold">Extract Method</strong>, as shown in <em class="italic">Figure 4</em><em class="italic">.28</em>:</p>
<div><div><img alt="Figure 4.28: Extract the method by right-clicking, clicking Refactor, then Extract Method" src="img/B19644_04_28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.28: Extract the method by right-clicking, clicking Refactor, then Extract Method</p>
<p>Name the <a id="_idIndexMarker367"/>extracted function <code>compute_average</code>, as shown in <em class="italic">Figure 4</em><em class="italic">.29</em>:</p>
<div><div><img alt="Figure 4.29: Name the extracted function compute_average" src="img/B19644_04_29.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.29: Name the extracted function compute_average</p>
<p>Click <strong class="bold">OK</strong>. This<a id="_idIndexMarker368"/> time things are a little different. You’ll find that PyCharm creates the function extraction as before, but this time you are prompted to replace the duplicate code as well, as shown in <em class="italic">Figure 4</em><em class="italic">.30</em>:</p>
<div><div><img alt="Figure 4.30: PyCharm asks whether you’d like to replace the duplicated fragment with a reference to the extracted function" src="img/B19644_04_30.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.30: PyCharm asks whether you’d like to replace the duplicated fragment with a reference to the extracted function</p>
<h3>Exporting a function to another file</h3>
<p>How <a id="_idIndexMarker369"/>often have you written a nifty utility function in the wrong place? Maybe you put it in a module or class that is designed to do something specific, but your utility function turns out to be generally used in lots of places. The single responsibility principle that applies to functions also applies to modules and classes. Having a function that connects to a database is a great example. Let’s say you just got a job working for Billy Blanca’s Candy Factory. They need you to write some scripts that will import lists of candies they make from several different text formats and store them in a database. The first requirement comes in, and you need to read from a plain text file and write to an SQLite database.</p>
<p>Open the project in <code>chapter-04/move_function/read_input_file_a.py</code>. Let’s review the contents:</p>
<pre class="source-code">
import sqlite3
CANDY_DB = "candy.db"</pre> <p>These first two lines import the <code>sqlite3</code> library from the standard library. If you haven’t worked with <code>sqlite3</code> before, here’s all you need to know for now: it is a file-based relational database. By this, we mean you don’t need to install a server as you would with databases such as Postgres or MariaDB. This makes it a good database to use for teaching and prototype work. We’ll cover databases in detail in <a href="B19644_11.xhtml#_idTextAnchor266"><em class="italic">Chapter 11</em></a>, <em class="italic">Understanding Database Management in PyCharm</em>. Let’s continue with the definition for the function that will open the file, read the contents, and insert them into the database:</p>
<pre class="source-code">
def read_input_file_type_a(file_path: str) -&gt; None:
  with open(file_path, "r") as data:
    for line in data:
      cleaned = line.strip("\n")
      write_to_database(cleaned)
  print("Processing Complete!")</pre> <p>We’ve <a id="_idIndexMarker370"/>opened the file. For each line in the file, we are reading it in as text and removing the newline character. This is necessary for the database insert to work properly. Once the string is cleaned, we are calling a function that writes to the database:</p>
<pre class="source-code">
def write_to_database(datum: str) -&gt; None:
  connection = sqlite3.connect(CANDY_DB)
  cursor = connection.cursor()
  sql = f"INSERT INTO candy(name) VALUES ('{datum}')"
  print(sql)
  cursor.execute(sql)
  cursor.close()
  connection.close()</pre> <p>I’ve included the database file in the code repository, so there is no code needed to create the database. This function just opens the database, then creates a cursor. A cursor is used to execute commands against the database using SQL. Even if you don’t know SQL, I’m sure you can figure out what is happening. There is a table in the database called <code>candy</code>. The table has only one field: <code>name</code>. We’re keeping it very simple here. I have neglected to create a primary key because, for now, the database doesn’t really matter. We should be focused on the function more than how it works.</p>
<p>Having generated a SQL statement to insert the <code>candy</code> name from the <code>candy</code> name in the current line of the text file, I execute the SQL statement, which will insert one row into the <code>candy</code> table.</p>
<p>As a <a id="_idIndexMarker371"/>general rule in programming, whatever you create, you should destroy, and whatever you open, you should always close. So, I close my cursor and my database connection to avoid any resource locks later down the road. Finally, I use the common dunder-name convention to run the file for testing:</p>
<pre class="source-code">
if __name__ == "__main__":
  read_input_file_type_a("../input_file_a.txt")</pre> <p>In PyCharm, I can execute this by setting my run configuration to <strong class="bold">Current File</strong> and clicking the <strong class="bold">Run</strong> button. It works! The file is read, and we get no errors.</p>
<p class="callout-heading">Dunderscores</p>
<p class="callout">A <code>__init__</code>? You could say, “<em class="italic">underscore underscore init underscore underscore.</em>” But that is cumbersome. If you just say, “init” you’re not being specific enough since there could be another function or method called <code>init</code> without the underscores. So, you say “<em class="italic">dunderscore init</em>” or even just “<em class="italic">dunder init</em>”, and everybody knows what you’re talking about.</p>
<p>The next day we come to work and learn of a new requirement. We need another script that reads <a id="_idIndexMarker373"/>data from a <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) file. The JSON file just contains an array like this:</p>
<pre class="source-code">
{
 "data": [
  "truffles",
  "turtles",
  "dark chocolate bark"
 ]
}</pre> <p>It’s still just a list of candy, but we need to process it differently. Open up <code>chapter-04/move_function/input/read_input_file_b.py</code>. You’ll find its code is similar to the other code:</p>
<pre class="source-code">
import json
from read_input_file_a import write_to_database</pre> <p>We<a id="_idIndexMarker374"/> know we need to work with JSON, so I’ve imported the <code>json</code> package. I also know I’ll need to write to the same database as before. I know code reuse is a good thing, so I import the function from the other script. Then I set to creating a version of the code that reads JSON files:</p>
<pre class="source-code">
def read_input_file_type_b(file_path: str) -&gt; None:
  with open(file_path, "r") as json_data:
    data = json.load(json_data)
    candies = data["data"]
    for candy in candies:
      write_to_database(candy)
  print("Processing Complete!")
if __name__ == "__main__":
  read_input_file_type_b("../input_file_b.json")</pre> <p>The <code>json.load</code> method takes the raw text and converts it into a regular Python 3 <code>dict</code>. As you can see from the preceding file listing, <code>dict</code> will have one thing in it: an array of candy with the key of data. So, I grab that and put it in the <code>candies</code> variable, then I loop over that array and call the <code>write_to_database</code> function for each <code>candy</code> in the array. Wow! It’s not even lunchtime! Maybe I can walk around the factory? I hear they’ve got some little girl testing some gum that turns people into a raspberry.</p>
<p>Not so fast! This <a id="_idIndexMarker375"/>code could be improved. Our input scripts are really designed to read data from text. It doesn’t make sense to have one of the scripts contain the database function because it simply doesn’t belong inside the script that reads text input files. It really should be in its own package. Let’s extract it to its own file.</p>
<p>Open <code>chapter-04/move_function/input/read_input_file_a.py</code>. Right-click on the name of the function we’re going to move, as shown in <em class="italic">Figure 4</em><em class="italic">.31</em>:</p>
<div><div><img alt="Figure 4.31: Right-click the function you want to move, then click Refactor, then Move" src="img/B19644_04_31.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.31: Right-click the function you want to move, then click Refactor, then Move</p>
<p>In the <a id="_idIndexMarker376"/>context menu, click <code>database_helper.py</code> filename. Click <strong class="bold">OK</strong>. Watch carefully because a lot is about to happen.</p>
<p>I get a new file called <code>database_helper.py</code>:</p>
<pre class="source-code">
import sqlite3
from input.read_input_file_a import CANDY_DB
def write_to_database(datum: str) -&gt; None:
  connection = sqlite3.connect(CANDY_DB)
  cursor = connection.cursor()
  sql = f"INSERT INTO candy(name) VALUES ('{datum}')"
  print(sql)
  cursor.execute(sql)
  cursor.close()
  connection.close()</pre> <p>This is<a id="_idIndexMarker377"/> the extracted function moved to its own file. PyCharm discovered the relevant import statement and moved that here as well. I had a constant for the file name called <code>CANDY_DB</code>. It didn’t move that, which would be my preference. Unfortunately, the current release of PyCharm is not psychic. I’ll just have to move that myself. Other than that, this file looks perfect.</p>
<p>If you check the contents of <code>input_file_a.py</code>, you’ll see it has changed. The first line in the file now reads as follows:</p>
<pre class="source-code">
from input.database_helper import write_to_database</pre> <p>Likewise, if I open <code>input_file_b.py</code>, I’ll find the input there as well. PyCharm extracted the function to its own file, then changed every reference in every file to point to the new location.</p>
<p>Now, I realize I probably should have put this in its own module, and I realize you probably would have done this totally differently. Before you go bashing me on Twitter, remember this book is about PyCharm, not software architecture. I’m trying to keep it simple on purpose.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Documentation</h1>
<p>No programmer<a id="_idIndexMarker378"/> can doubt the importance of documentation in software engineering and development. That said, the process of creating documentation for a program can be quite tedious. Furthermore, the end result might not even be effective if the person doing the documentation was not following standard practices.</p>
<p>Keeping that in mind, PyCharm looks to streamline this process of documentation and make it as straightforward and seamless as possible. Regarding documentation, there are two components we will consider for this process: viewing and creating documentation. We will learn that PyCharm offers great support for both processes.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor108"/>Working with docstrings</h2>
<p>Documentation<a id="_idIndexMarker379"/> in Python is known as docstrings, defined <a id="_idIndexMarker380"/>as a string literal that is placed before any of the statements in a module, function, class, or method in Python. You can look at examples of Python docstrings by going into the source code of the various built-in Python functions. It is also recommended that any custom API you write also has the appropriate docstrings for readability and maintainability.</p>
<p>The most noteworthy subtlety in creating docstrings is the practice of using triple-double quotes to surround a docstring (which we will see examples of in the next subsection). For more <a id="_idIndexMarker381"/>details about docstring conventions, take a look at this PEP article: <a href="http://www.python.org/dev/peps/pep-0257/">www.python.org/dev/peps/pep-0257/</a>.</p>
<h3>Creating documentation</h3>
<p>In this <a id="_idIndexMarker382"/>subsection, we will look into the process of writing a docstring for functions with the help of PyCharm. Let’s get started.</p>
<p>Open the project in the sample source code in <code>chapter-04/documentation</code>. Open the <code>prime_test.py</code> file, which looks like this:</p>
<pre class="source-code">
import sys
from math import sqrt
def prime_check(n: int) -&gt; bool:
  # TODO: docstring goes here
  if n &lt; 2:
    return False
  limit = int(sqrt(n)) + 1
  for i in range(2, limit):
    if n % i == 0:
      return False # return False if a divisor is found
  return True # return True if no divisor is found</pre> <p>The file goes<a id="_idIndexMarker383"/> on after that, but the part I need you to focus on is the line right below the method signature for the <code>prime_check</code> function. There is a <code>TODO</code> there. If you’re from a Spanish-speaking country, realize this doesn’t mean <em class="italic">all</em>. It refers to a “to-do” item in the code. In this case, the original developer, who happens to be Quan Nguyen, the author of the first edition of this book, is stating he didn’t write the docstring for this function. He is signaling here that he knows that, and he intends to come back and fix this later. Let’s help him out with a little PyCharm magic. Before you get too excited, I’m sad to report that there isn’t a tool in PyCharm that can read your code and generate the docstring. Given how much developers hate writing documentation, I’ll wager there is a fast-and-furious effort underway somewhere to have AI do this. But we’re sticking with what PyCharm lets us do out of the box.</p>
<p>Delete the <code># TODO</code> line and, in its place, type three double quotation marks (<code>"""</code>) and press <em class="italic">Enter</em>. You’ll find a generated docstring template appears:</p>
<pre class="source-code">
"""
:param n:
:return:
"""</pre> <p>This template needs some filling-in in order to become a proper docstring. Note the gap beneath the first set of triple quotes. Here, you are expected to write about what the function does. Maybe something like this:</p>
<pre class="source-code">
"""
Check whether an integer is a prime number of not.
Generally, the function goes through all odd numbers
less than the square root of the input integer, and
checks to see if the input is divisible by that number.
:param n:
:return:
"""</pre> <p>Below<a id="_idIndexMarker384"/> that is a section for the parameters expected by the function. Here, the function takes one argument called <code>n</code>. We should write a little bit about that parameter, including its type:</p>
<pre class="source-code">
"""
Check whether an integer is a prime number of not.
Generally, the function goes through all odd numbers
less than the square root of the input integer, and
checks to see if the input is divisible by that number.
:param n: the integer to prime check
:return:
"""</pre> <p>The last part is the documentation for the return value:</p>
<pre class="source-code">
"""
Check whether an integer is a prime number of not.
Generally, the function goes through all odd numbers
less than the square root of the input integer, and
checks to see if the input is divisible by that number.
:param n: the integer to prime check
:return: boolean
"""</pre> <p>Consider the<a id="_idIndexMarker385"/> generated template of the docstring after we hit <em class="italic">Return/Enter</em> to expand the pair of triple-double quotes. <code>:param</code> and <code>:return:</code> are part of the template and will be included every time we expand a docstring in the same way. PyCharm allows us to change this format of docstring templates, making it highly customizable and accommodating.</p>
<h3>Customizing the docstring templates</h3>
<p>As usual, the<a id="_idIndexMarker386"/> docstring templates are highly customizable. You’ll find the customization settings by going into the <strong class="bold">Settings</strong> window, covered extensively in <a href="B19644_03.xhtml#_idTextAnchor052"><em class="italic">Chapter 3</em></a>,<em class="italic"> Customizing Interpreters and Virtual Environments</em>. Just search on docstring, and you’ll find the areas that should capture your attention. The first is shown in <em class="italic">Figure 4</em><em class="italic">.32</em>:</p>
<div><div><img alt="Figure 4.32: You can change the general format used to render your docstrings to one of several industry-standard formats" src="img/B19644_04_32.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.32: You can change the general format used to render your docstrings to one of several industry-standard formats</p>
<p>The other group of settings is part of the color scheme settings, which allow you to customize the <a id="_idIndexMarker387"/>color used to render the docstring in the PyCharm editor.</p>
<h3>Viewing documentation</h3>
<p>Imagine a <a id="_idIndexMarker388"/>situation where you are using a specific method from one package, but you are not entirely sure which parameters the method takes in and/or what its return type is. Therefore, you need to go online and look into the documentation of the package for that specific method.</p>
<p>As a PyCharm user, you can achieve the same thing with two simple actions: <code>prime_check.py</code> script from the previous section, move your cursor to the line where we use the <code>math.sqrt()</code> function in the <code>prime_check()</code> function; it should be around line 19.</p>
<h3>Quick Documentation</h3>
<p>Let’s say we’d like <a id="_idIndexMarker389"/>to see the documentation of this function. You can simply hover your mouse over the function call and wait a moment. Alternatively, you can choose <strong class="bold">View</strong> | <strong class="bold">Quick Documentation</strong> for this or its corresponding keyboard shortcut. You will see a pop-up window showing documentation similar to <em class="italic">Figure 4</em><em class="italic">.33</em>:</p>
<div><div><img alt="Figure 4.33: Quick Documentation shows the documentation for the selected function" src="img/B19644_04_33.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.33: Quick Documentation shows the documentation for the selected function</p>
<p>What’s <a id="_idIndexMarker390"/>more, you can also view the documentation for your own functions, methods, classes, and so on using the same action. PyCharm’s indexing process finds and generates this information when you open the project.</p>
<p>If you move your cursor to the call to <code>prime_check()</code> in the main scope in the following line (which should be around line 38):</p>
<p><code>if prime_check(num):</code></p>
<p>After waiting a moment, you will be able to see the same docstring that we entered earlier, as shown in <em class="italic">Figure 4</em><em class="italic">.34</em>:</p>
<div><div><img alt="Figure 4.34: Quick Documentation shows the documentation for the selected function on line 38" src="img/B19644_04_34.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.34: Quick Documentation shows the documentation for the selected function on line 38</p>
<p>Note the format <a id="_idIndexMarker391"/>of the docstring in the documentation matches the documentation shown in the window.</p>
<h3>Quick definition</h3>
<p><strong class="bold">Quick Definition</strong> operates in the same manner as <strong class="bold">Quick Documentation</strong>. This is useful<a id="_idIndexMarker392"/> when the documentation does not provide enough information, and you would like to see how a specific function is defined within the source code. To do this, place your cursor at a specific API call, and go to <strong class="bold">View</strong> | <strong class="bold">Quick Definition</strong> to evoke the action.</p>
<p>For example, <em class="italic">Figure 4</em><em class="italic">.35</em> shows the quick definition evoked on the call to <code>prime_check()</code> in our example:</p>
<div><div><img alt="Figure 4.35: Quick Definition shows the actual code definition for the function, which naturally includes the docstring if one is present" src="img/B19644_04_35.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.35: Quick Definition shows the actual code definition for the function, which naturally includes the docstring if one is present</p>
<p>Overall <a id="_idIndexMarker393"/>PyCharm provides powerful options when it comes to dynamically viewing documentation and definitions within the IDE. Significant time and energy can be saved when programmers do not have to switch from their development environment to look for documentation.</p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>Summary</h1>
<p>Throughout this chapter, we examined PyCharm’s features regarding various aspects of programming, including code analysis, code completion, refactoring, and documenting. In all of these processes, PyCharm’s intelligent code analyzer provides smart and convenient options for editing and fixing problems in your code in real time and in a dynamic way.</p>
<p>Aside from a wide number of options the intelligent code analyzer can support, PyCharm also allows users to customize the behavior of the analyzer to their liking. This can be achieved in various sections of the general settings. Overall, these support features look to improve your productivity as a developer in a way that is customized and beneficial to you.</p>
<p>In the next chapter, we will focus on a particular aspect of programming: version control. We will learn about the specifics of the version control process with Git and how PyCharm supports and streamlines this process.</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor110"/>Questions</h1>
<ol>
<li>What levels of severity in terms of problems in a Python program are determined by PyCharm’s code analyzer?</li>
<li>What are some common problems that PyCharm can detect and help fix via its intelligent code analyzer?</li>
<li>How is PyCharm’s code completion support different from others?</li>
<li>What are some common code completion options that PyCharm offers?</li>
<li>What are the common causes for PyCharm’s code completion support not working?</li>
<li>What are some common refactoring options that PyCharm offers?</li>
</ol>
<h1 id="_idParaDest-109"><a id="_idTextAnchor111"/>Further reading</h1>
<ul>
<li>Jolt Awards: <em class="italic">The Best Books For </em><em class="italic">Developers </em>(<a href="http://informationweek.com">informationweek.com</a>)</li>
<li>Pylint home page: <a href="https://www.pylint.org/">https://www.pylint.org/</a></li>
<li>Murphy’s laws on technology: <a href="https://www.netlingo.com/word/murphys-laws-on-technology.php">https://www.netlingo.com/word/murphys-laws-on-technology.php</a></li>
<li>Be sure to check out the companion website for the book at <a href="https://www.pycharm-book.com">https://www.pycharm-book.com</a>.</li>
</ul>
</div>
</body></html>