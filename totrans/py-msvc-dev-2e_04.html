<html><head></head><body>
  <div><h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-74" class="chapterTitle">Designing Jeeves</h1>
    <p class="normal">In <em class="chapterRef">Chapter 1</em>, <em class="italic">Understanding Microservices</em>, we said that the natural way to build a microservices-based app is to start with a monolithic version that implements all the features, and then to split it into microservices that make the most sense. When you are designing software, you have enough to worry about with the flow of information through the system, meeting requirements, and working out how it all fits together. Having a design that encounters reality is when you start getting a good idea of what types of components you should have, and as you gain experience, it will become easier to spot potential microservices earlier on.</p>
    <p class="normal">In this chapter, we will go through this process by building a monolithic application and implementing the required features. We will cover how each component works and why it's there, as well as how information flows through the system.</p>
    <p class="normal">The chapter is organized into two main sections:</p>
    <ul>
      <li class="bullet">Presentation of our application and its user stories</li>
      <li class="bullet">How Jeeves can be built as a monolithic application</li>
    </ul>
    <p class="normal">Of course, in reality, the splitting process happens over time once the monolithic app design has some time to mature. But for the purpose of this book, we'll assume that the first version of the application has been used for a while and offered us some insights as to how it can be split in the right way, thanks to our time machine.</p>
    <h1 id="_idParaDest-75" class="title">The Jeeves bot</h1>
    <p class="normal"><strong class="keyword">Jeeves</strong> is an example <a id="_idIndexMarker229"/>application that was created for this book. Don't look for it in the Apple or Play Store, as it's not released or deployed for real users.</p>
    <p class="normal">However, the application does work, and you can study its different components on GitHub in the PythonMicroservices organization: <a href="https://github.com/PythonMicroservices/">https://github.com/PythonMicroservices/</a>.</p>
    <p class="normal">We will be connecting to Slack, a popular communication platform, primarily used to send text messages in channels, similar to the older IRC service. Jeeves will be our personal assistant—a name taken from the stories of <em class="italic">P. G. Wodehouse</em>—and used for other software bots and at least one search engine. We will be using the name for its familiarity and not because of any connection with other people's work. The Jeeves presented here offers an interactive service to users of a Slack workspace and can be easily adapted to other chat environments. It also offers a web view to configure essential settings.</p>
    <p class="normal">Once Jeeves is <a id="_idIndexMarker230"/>connected to a Slack workspace, a user can send the bot messages and receive replies. Users can also visit the web page and register for any third-party services they might need to connect to thanks to the standard OAuth2 mechanism. See <a id="_idIndexMarker231"/>more at <a href="https://oauth.net/2/">https://oauth.net/2/</a>.</p>
    <p class="normal">We will be <a id="_idIndexMarker232"/>using <strong class="keyword">Strava</strong> (<a href="https://www.strava.com">https://www.strava.com</a>) as an example of a third-party site, although this could easily be GitHub, Google services, Atlassian's JIRA, or some other useful service.</p>
    <p class="normal">The OAuth2 standard is based on the idea of authorizing a third-party application to call a service with an access token that is unique to the user of the service. The token is generated by the service and usually has a limited scope in what calls can be performed.</p>
    <p class="normal">Let's dive into the features through their user stories.</p>
    <h1 id="_idParaDest-76" class="title">User stories</h1>
    <p class="normal">Firstly, what should <a id="_idIndexMarker233"/>our application do? A good way to describe our goals is by covering the desired behavior in different scenarios. If you've been involved in Agile development before, this will be familiar in the guise of "user stories." User stories are <a id="_idIndexMarker234"/>very simple descriptions of all the interactions a user can have with an application, and is often the first high-level document that is written when a project starts, as some of the stories appear in the justification or proposal for the work to begin.</p>
    <p class="normal">Attempting to fill lots of detail early on can also make life harder; start with high-level stories and add detail as they are revisited. Sometimes a user story might be discarded if it's not feasible—it depends very much on how the work progresses and on the feasibility of each idea. User stories are also helpful to detect when it's worth splitting a feature into its microservice: a story that stands on its own could be a good candidate.</p>
    <p class="normal">For Jeeves, we can start with this small set:</p>
    <ul>
      <li class="bullet">As a Slack workspace user, I can send messages to a bot and get updates about the weather without leaving Slack</li>
      <li class="bullet">As a Slack workspace user, I expect the bot to remember facts that I have told it about myself, such as my location</li>
      <li class="bullet">As a Slack workspace user, I can visit the bot's control panel and authenticate third-party services, such as GitHub and Strava</li>
      <li class="bullet">As an admin of the bot, I can get statistics regarding the bot's usage</li>
      <li class="bullet">As an <a id="_idIndexMarker235"/>admin of the bot, I can disable or change the configuration of various features</li>
      <li class="bullet">As a user, I can <a id="_idIndexMarker236"/>create an account on a third-party site that the bot knows about, and then use the bot to perform tasks there</li>
    </ul>
    <p class="normal">There are already a few components emerging from this set of user stories. In no particular order, these are as follows:</p>
    <ul>
      <li class="bullet">The app needs to store the contents of some types of messages it receives. These may be stored against a specific Slack identity.</li>
      <li class="bullet">A user should be able to navigate to a web interface for third-party site authentication.</li>
      <li class="bullet">The app will authenticate web users with a password or a URL with a provided token.</li>
      <li class="bullet">The app should be able to perform periodic scheduled tasks to alert the user if a condition is true, such as for bad weather.</li>
    </ul>
    <p class="normal">These descriptions are enough to get us started. The next section describes how the application can be designed and coded.</p>
    <h1 id="_idParaDest-77" class="title">Monolithic design</h1>
    <p class="normal">This section presents extracts <a id="_idIndexMarker237"/>from the source code of the monolithic version of Jeeves. If you want to study it in detail, then the whole application can be found at <a href="https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/monolith">https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/monolith</a>.</p>
    <p class="normal">The first thing to consider is the retrieval of data from Slack into our application. There will be a single endpoint for this, as Slack sends all its events to the URL that the application developer configures. Later on, we can also add other endpoints to work with other environments, such as IRC, Microsoft Teams, or Discord.</p>
    <p class="normal">We will also need a small interface to allow people to adjust the settings outside Slack, as controlling third-party authentication tokens and updating permissions for those tools is much easier using a web page. We will also need a small database to store all this information, along with other settings that we want our microservice to have.</p>
    <p class="normal">Lastly, we will need <a id="_idIndexMarker238"/>some code to actually perform the actions our bot should do on behalf of the person who has sent it messages.</p>
    <p class="normal">A design pattern that is often referred to when building applications is the <strong class="keyword">Model-View-Controller</strong> (<strong class="keyword">MVC</strong>) pattern, which <a id="_idIndexMarker239"/>separates the code into three parts:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Model</strong>: This manages the data</li>
      <li class="bullet"><strong class="keyword">View</strong>: This displays the model for a particular context (web view, PDF view, and so on)</li>
      <li class="bullet"><strong class="keyword">Controller</strong>: This manipulates the model to change its state</li>
    </ul>
    <p class="normal"><code class="Code-In-Text--PACKT-">SQLAlchemy</code> is a library that can aid with the model part, allowing us to specify tables, relationships, and wrappers around reading and writing data in our Python source code. In a microservice, the view and controller distinction can be a bit vague, because what is called a view is a function that receives a request and sends back a response—and that function can both display and manipulate the data, allowing it to act as both a View and as a Controller.</p>
    <p class="normal">The Django project uses <strong class="keyword">Model-View-Template</strong> (<strong class="keyword">MVT</strong>) to <a id="_idIndexMarker240"/>describe that pattern, where View is the Python callable, and Template is the template engine, or whatever is in charge of producing a response in a particular format, given some data. <code class="Code-In-Text--PACKT-">Quart</code> uses Jinja2 for all sorts of useful template rendering—most commonly generating HTML and filling in the contents with values that it obtains from variables using the <code class="Code-In-Text--PACKT-">render_template()</code> function. We will use this approach for views that present data to a human; for API views that return JSON, we will use <code class="Code-In-Text--PACKT-">json.dumps()</code> to generate the response. In any case, the first step of designing our application is to define the model.</p>
    <h2 id="_idParaDest-78" class="title">Model</h2>
    <p class="normal">In a <code class="Code-In-Text--PACKT-">Quart</code> application <a id="_idIndexMarker241"/>based on SQLAlchemy, the model is described through classes, which represent the database schema. For Jeeves, the database tables are:</p>
    <ul>
      <li class="bullet"><strong class="keyword">User</strong>: This contains information about each user, including their credentials</li>
      <li class="bullet"><strong class="keyword">Service</strong>: This is a list of the available services the bot can provide, and whether or not they are active</li>
      <li class="bullet"><strong class="keyword">Log</strong>: A log of bot activity</li>
    </ul>
    <p class="normal">Using <a id="_idIndexMarker242"/>the <strong class="keyword">SQLAlchemy</strong> (<a href="https://www.sqlalchemy.org/">https://www.sqlalchemy.org/</a>) library, each table is created as a subclass of the base class provided by the module, allowing us to avoid duplicating effort and leaving the classes in our own code clean and focused on the data that we want to work with. SQLAlchemy has asynchronous interfaces that can be used to keep the performance benefits of our async application while accessing the database. To use these features, we <a id="_idIndexMarker243"/>must install both <code class="Code-In-Text--PACKT-">sqlalchemy</code> and <code class="Code-In-Text--PACKT-">aiosqlite</code>. The full example can be found in the code samples' GitHub repository as the <code class="Code-In-Text--PACKT-">sqlachemy-async.py</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code">     # sqlalchemy-async.py
     
    from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
    from sqlalchemy.orm import declarative_base, sessionmaker
    from sqlalchemy import Column, Integer, String, Boolean, JSON
    from sqlalchemy.orm import Session
    from sqlalchemy.future import select
    from sqlalchemy import update
 
    # Initialize SQLAlchemy with a test database
    DATABASE_URL = "sqlite+aiosqlite:///./test.db"
    engine = create_async_engine(DATABASE_URL, future=True, echo=True)
    async_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)
    Base = declarative_base()
  
    # Data Model
    class User(Base):
        __tablename__ = "user"
        id = Column(Integer, primary_key=True, autoincrement=True)
        name = Column(String)
        email = Column(String)
        slack_id = Column(String)
        password = Column(String)
        config = Column(JSON)
        is_active = Column(Boolean, default=True)
        is_admin = Column(Boolean, default=False)
        def json(self):
            return {"id": self.id, "email": self.email, "config": self.config}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">User</code> table mostly stores some Unicode strings, but it's also worth noting the two <code class="Code-In-Text--PACKT-">Boolean</code> values that guarantee that we do not need to interpret another system's way of storing <code class="Code-In-Text--PACKT-">True</code> and <code class="Code-In-Text--PACKT-">False</code>. There is also a JSON column for storing entire data structures—a feature available in an increasing number of backend databases, including PostgreSQL and SQLite.</p>
    <p class="normal">When <a id="_idIndexMarker244"/>used in a <code class="Code-In-Text--PACKT-">Quart</code> app, SQLAlchemy allows us to write an interface to avoid writing SQL directly; instead, we can call functions that query and filter the data. We can go one <a id="_idIndexMarker245"/>step further and create a <strong class="keyword">data access layer</strong> (<strong class="keyword">DAL</strong>) that handles all of the database session management for us. In the following code, we have written an access layer that can be used as a context manager, while providing methods to create and find users. The <code class="Code-In-Text--PACKT-">create_user</code> method is simply using the model we defined previously to create a new Python object—without all the fields, to make the example clearer—and then adding it to the database session, ensuring the data has been written out before returning the value written to the database.</p>
    <p class="normal">Building on that, we can then use the <code class="Code-In-Text--PACKT-">get_all_users</code> method to return all the records stored using the <code class="Code-In-Text--PACKT-">User</code> model, using <code class="Code-In-Text--PACKT-">select()</code> to retrieve them, and <code class="Code-In-Text--PACKT-">get_user</code> to return just one record, while using the <code class="Code-In-Text--PACKT-">where</code> method to filter the results to only display the ones that match the argument provided:</p>
    <pre class="programlisting code"><code class="hljs-code">   class UserDAL:
      def __init__(self, db_session):
         self.db_session = db_session
      async def create_user(self, name, email, slack_id):
         new_user = User(name=name, email=email, slack_id=slack_id)
         self.db_session.add(new_user)
         await self.db_session.flush()
         return new_user.json()
      async def get_all_users(self):
         query_result = await self.db_session.execute(select(User).order_by(User.id))
         return {"users": [user.json() for user in query_result.scalars().all()]}
      async def get_user(self, user_id):
         query = select(User).where(User.id == user_id)
         query_result = await self.db_session.execute(query)
         user = query_result.one()
         return user[0].json()
</code></pre>
    <p class="normal">With the DAL set up, we <a id="_idIndexMarker246"/>can use a feature provided by Python's own <code class="Code-In-Text--PACKT-">contextlib</code> to create an asynchronous context manager:</p>
    <pre class="programlisting code"><code class="hljs-code">    @asynccontextmanager
    async def user_dal():
        async with async_session() as session:
            async with session.begin():
                yield UserDAL(session)
</code></pre>
    <p class="normal">All of this is a lot to set up, but once done, it allows us to access any of the data stored behind the <code class="Code-In-Text--PACKT-">User</code> model with only a context manager to control the database session. We will use all this code in our views.</p>
    <h2 id="_idParaDest-79" class="title">View and template</h2>
    <p class="normal">When a request is received, a view is <a id="_idIndexMarker247"/>invoked through the URL mapping, and we can <a id="_idIndexMarker248"/>use the context manager we created above to query and update the database. The following <code class="Code-In-Text--PACKT-">Quart</code> view will allow us to view all the users in the database when the <code class="Code-In-Text--PACKT-">/users</code> endpoint is queried:</p>
    <pre class="programlisting code"><code class="hljs-code">    @app.get("/users")
    async def get_all_users():
        async with user_dal() as ud:
            return await ud.get_all_users()
</code></pre>
    <p class="normal">When the <code class="Code-In-Text--PACKT-">user_dal</code> context is created, we gain access to all the methods within it, and so we can easily call the <code class="Code-In-Text--PACKT-">get_all_users</code> method and return the values to the client. Let's put all of the above together into one example application, adding in some of our missing fields:</p>
    <pre class="programlisting code"><code class="hljs-code">    # sqlalchemy-async.py
    from contextlib import asynccontextmanager
    from quart import Quart
    from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
    from sqlalchemy.orm import declarative_base, sessionmaker
    from sqlalchemy import Column, Integer, String, Boolean, JSON
    from sqlalchemy.orm import Session
    from sqlalchemy.future import select
    from sqlalchemy import update
    # Initialize SQLAlchemy with a test database
    DATABASE_URL = "sqlite+aiosqlite:///./test.db"
    engine = create_async_engine(DATABASE_URL, future=True, echo=True)
    async_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)
    Base = declarative_base()
    # Data Model
    class User(Base):
        __tablename__ = "user"
        id = Column(Integer, primary_key=True, autoincrement=True)
        name = Column(String)
        email = Column(String)
        slack_id = Column(String)
        password = Column(String)
        config = Column(JSON)
        is_active = Column(Boolean, default=True)
        is_admin = Column(Boolean, default=False)
        def json(self):
            return {
                "id": self.id,
                "email": self.email,
                "slack_id": self.slack_id,
                "config": self.config,
                "is_active": self.is_active,
                "is_admin": self.is_admin,
            }
    # Data Access Layer
    class UserDAL:
        def __init__(self, db_session):
            self.db_session = db_session
        async def create_user(
            self,
            name,
            email,
            slack_id,
            password=None,
            config=None,
            is_active=True,
            is_admin=False,
        ):
            new_user = User(
                name=name,
                email=email,
                slack_id=slack_id,
                password=password,
                config=config,
                is_active=is_active,
                is_admin=is_admin,
            )
            self.db_session.add(new_user)
            await self.db_session.flush()
            return new_user.json()
        async def get_all_users(self):
            query_result = await self.db_session.execute(select(User).order_by(User.id))
            return [user.json() for user in query_result.scalars().all()]
        async def get_user(self, user_id):
            query = select(User).where(User.id == user_id)
            query_result = await self.db_session.execute(query)
            user = query_result.one()
            return user[0].json()
    app = Quart(__name__)
    @app.before_serving
    async def startup():
        # create db tables
        async with engine.begin() as conn:
            # This resets the database – remove for a real project!
            await conn.run_sync(Base.metadata.drop_all)
            await conn.run_sync(Base.metadata.create_all)
            async with user_dal() as bd:
                await bd.create_user("name", "email", "slack_id")
    @asynccontextmanager
    async def user_dal():
        async with async_session() as session:
            async with session.begin():
                yield UserDAL(session)
    @app.get("/users/&lt;int:user_id&gt;")
    async def get_user(user_id):
        async with user_dal() as ud:
            return await ud.get_user(user_id)
    @app.get("/users")
    async def get_all_users():
        async with user_dal() as ud:
            return await ud.get_all_users()
    if __name__ == "__main__":
        app.run()
</code></pre>
    <h2 id="_idParaDest-80" class="title">A human-readable view</h2>
    <p class="normal">If we were to want this <a id="_idIndexMarker249"/>information presented in an easily readable format, we could use a Jinja2 template and pass the results of the query to fill in the details:</p>
    <pre class="programlisting code"><code class="hljs-code">    @app.get("/users/page")
    async def get_all_users_templated():
        async with user_dal() as ud:
            users = await ud.get_all_users()
            return await render_template("users.html", users=users)
</code></pre>
    <p class="normal">Without any configuration to tell it otherwise, Jinja looks for its templates in a subdirectory of the Python application called <code class="Code-In-Text--PACKT-">templates/</code>, which is often enough for small applications.</p>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">users.html</code> template has <a id="_idIndexMarker250"/>some HTML in it, but also some directives that are bounded by curly braces. There is a <code class="Code-In-Text--PACKT-">for</code> loop that allows us to iterate over the data that is passed to the template, and we can see that instructions sent to Jinja are surrounded by <code class="Code-In-Text--PACKT-">{% and %}</code>. Another common instruction in a template would be <code class="Code-In-Text--PACKT-">{% if … %}</code> to only include a piece of text if the condition is true. Inside the <code class="Code-In-Text--PACKT-">for</code> loop, we see some variable expansions inside <code class="Code-In-Text--PACKT-">{{</code> and <code class="Code-In-Text--PACKT-">}}</code>, signaling to Jinja that it should look for a variable with that name. It's possible to apply filters to variables, which is especially useful when formatting dates. Here is a simple template that loops over all of the users it is given and displays both their email address and Slack ID:</p>
    <pre class="programlisting code"><code class="hljs-code">    &lt;html&gt;
      &lt;body&gt;
        &lt;h1&gt;User List&lt;/h1&gt;
        &lt;ul&gt;
          {% for user in users %}
          &lt;li&gt;
          {{ user.email }} {{ user.slack_id }} 
          &lt;/li&gt;
          {% endfor %}
        &lt;/ul&gt;
      &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
    <p class="normal">For editing data through the web, WTForms can be used to generate forms for each model. WTForms is a library that generates HTML forms with Python definitions, takes care of extracting data from incoming requests, and validating them before you update your model. Find out more at <a href="http://wtforms.readthedocs.io">http://wtforms.readthedocs.io</a>.</p>
    <p class="normal">The Flask-WTF project wraps WTForms for <code class="Code-In-Text--PACKT-">Quart</code> and adds some useful integration, such as securing <a id="_idIndexMarker251"/>forms with <strong class="keyword">Cross-Site Request Forgery</strong> (<strong class="keyword">CSRF</strong>) tokens. Find out more at <a href="https://flask-wtf.readthedocs.io/">https://flask-wtf.readthedocs.io/</a>.</p>
    <p class="normal">CSRF tokens will ensure that no malicious third-party website can send valid forms to your app when you are logged in. <em class="chapterRef">Chapter 7</em>, <em class="italic">Securing Your Services</em>, will explain in detail how CSRF works and why it is important for your app security. </p>
    <p class="normal">The following module implements a form for the <code class="Code-In-Text--PACKT-">User</code> table, using <code class="Code-In-Text--PACKT-">FlaskForm</code> as its basis:</p>
    <pre class="programlisting code"><code class="hljs-code">    import quart.flask_patch
    from flask_wtf import FlaskForm 
    import wtforms as f 
    from wtforms.validators import DataRequired 
 
    class UserForm(FlaskForm):
        email = f.StringField("email", validators=[DataRequired()])
        slack_id = f.StringField("Slack ID")
        password = f.PasswordField("password")
 
        display = ["email", slack_id, "password"] 
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">display</code> attribute is <a id="_idIndexMarker252"/>just a helper to assist the template in iterating into a particular ordered list of fields when rendering the form. Everything else is using WTForms basic fields classes to create a form for the user table. The WTForm's Fields documentation provides the full list at <a href="https://wtforms.readthedocs.io/en/2.3.x/fields/">https://wtforms.readthedocs.io/en/2.3.x/fields/</a>.</p>
    <p class="normal">Once created, <code class="Code-In-Text--PACKT-">UserForm</code> can be used in a view that has two goals. The first one is to display the form on <code class="Code-In-Text--PACKT-">GET</code> calls, and the second one is to update the database on <code class="Code-In-Text--PACKT-">POST</code> calls when the user submits the form:</p>
    <pre class="programlisting code"><code class="hljs-code"> @app.route("/create_user", methods=["GET", "POST"])
    async def create_user():
        form = UserForm()
        if request.method == "POST" and form.validate():
            async with user_dal() as ud:
                await ud.create_user(form.name.data, form.email.data, form.slack_id.data)
            return redirect("/users")
        return await render_template("create_user.html", form=form) 
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">UserForm</code> class has a method to validate the incoming <code class="Code-In-Text--PACKT-">POST</code> data, using the validators we provide. When some data is invalid, the form instance will keep the list of errors in <code class="Code-In-Text--PACKT-">field.errors</code> in case the template wants to display them for the user.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">create_user.html</code> template iterates through the form field list, and WTForm takes care of rendering the proper HTML tags:</p>
    <pre class="programlisting code"><code class="hljs-code">    &lt;html&gt; 
     &lt;body&gt; 
      &lt;form action="" method="POST"&gt; 
        {{ form.hidden_tag() }} 
        &lt;dl&gt; 
         {% for field in form.display %} 
         &lt;dt&gt;{{ form[field].label }}&lt;/dt&gt; 
         &lt;dd&gt;{{ form[field]() }} 
           {% if form[field].errors %} 
             {% for e in form[field].errors %}{{ e }} {% endfor %} 
           {% endif %} 
           &lt;/dd&gt;
         {% endfor %} 
        &lt;/dl&gt; 
        &lt;p&gt; 
        &lt;input type=submit value="Publish"&gt; 
      &lt;/form&gt; 
     &lt;/body&gt; 
    &lt;/html&gt; 
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">form.hidden_tag()</code> method <a id="_idIndexMarker253"/>will render all hidden fields, such as the CSRF token. Once this form is working, it's easy to reuse the same pattern for every form needed in the app.</p>
    <p class="normal">Forms are often adjusted regularly during development and, by necessity, they are tightly coupled to the structure of the database. Because of this, when we look at splitting Jeeves up into microservices, we will consider whether these forms need to be provided by the database microservice to avoid schema dependencies appearing in other services.</p>
    <h2 id="_idParaDest-81" class="title">Slack workspaces</h2>
    <p class="normal">Slack allows people to <a id="_idIndexMarker254"/>connect apps to a workspace. If you are an administrator of the FunCorp Slack instance, you could visit the following link and create a new bot user: <a href="https://api.slack.com/apps?new_app=1">https://api.slack.com/apps?new_app=1</a>.</p>
    <p class="normal">The exact process and web page layout may change—as web services frequently do—but there will be an opportunity to enable Event Subscriptions and provide a URL to which Slack messages should be sent. </p>
    <p class="normal">A token will be generated, which you should copy and place in your application's settings so that it can authenticate to Slack when sending messages:</p>
    <figure class="mediaobject"><img src="img/B17108_04_01.png" alt="image3.png"/></figure>
    <p class="packt_figref">Figure 4.1: Subscribing to Slack bot events</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Request</code> URL that you <a id="_idIndexMarker255"/>give to Slack will need to be reachable from Slack's own servers, and so running this on your laptop may not be enough. If you run into trouble, then using a virtual server in a cloud provider is a quick and easy way to get going. We will cover this in more detail in <em class="chapterRef">Chapter 10</em>, <em class="italic">Deploying on AWS</em>, where we discuss deploying our application in the cloud.</p>
    <p class="normal">Once the bot's endpoint is verified, it will start receiving the messages it has subscribed to. This means that if you have selected <code class="Code-In-Text--PACKT-">app_mention</code> events, then messages that don't mention the bot by name will not be sent, but any others will. Your bot will need some permissions—known as scopes—to read and send messages:</p>
    <figure class="mediaobject"><img src="img/B17108_04_02.png" alt="image2.png"/></figure>
    <p class="packt_figref">Figure 4.2: Example Slack bot permissions to receive messages</p>
    <p class="normal">The JSON data that is <a id="_idIndexMarker256"/>sent for an event arrives with all the data categorized. Using the example below, when the person types <em class="italic">@jeeves hello</em>, the API endpoint will receive a JSON object that identifies the workspace, the timestamp, what sort of event it was, what user typed it, and the component parts of the message itself—such as a mention (<code class="Code-In-Text--PACKT-">@jeeves</code>) and the text, <em class="italic">hello</em>. Any user ID that is sent will not be recognizable to a human as they are the internal text strings used to represent users and workspaces. This does mean that when we connect a user to our application, we never really learn the username they chose in Slack unless we ask Slack for it.</p>
    <p class="normal">Here is a trimmed copy of the JSON data our service gets when we ask for the weather in our Slack workspace. It is easy to see that the values for the user and team are not human-friendly, but the JSON is also helpful in that it has already broken up a potentially complicated message into sections for us so that we don't need to worry about safely removing mentions of other users, links, or other special elements that can be in the post:</p>
    <pre class="programlisting code"><code class="hljs-code">{
    "event": {
        "client_msg_id": "79cd47ec-4586-4677-a50d-4db58bdfcd4b",
        "type": "app_mention",
        "text": "&lt;@U01HYK05BLM&gt;\u00a0weather in London, UK",
        "user": "U136F44A0",
        "ts": "1611254457.003600",
        "team": "T136F4492",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pqx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U01HYK05BLM"
                            },
                            {
                                "type": "text",
                                "text": " weather in London, UK"
                            }
                        ]
                    }
                ]
            }
        ],
    … 
}
</code></pre>
    <h2 id="_idParaDest-82" class="title">Taking actions</h2>
    <p class="normal">Our bot should be <a id="_idIndexMarker257"/>able to do useful things for the people who send it messages, and we should keep these actions as self-contained as possible. Even without using a microservice-based design, it is far safer to create well-defined boundaries between different components.</p>
    <p class="normal">How do we know which action to take? After receiving a message from Slack, we need to understand the data we have been given and look for the appropriate keywords. When we find something that matches, we can then check to see what function we should call.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Quart</code> view we use <a id="_idIndexMarker258"/>to handle Slack messages should be as simple as possible, and so we do just enough processing to extract information from the data we are given and pass it on to a message processor. This processor is responsible for examining the text the bot has been sent, and deciding on a course of action. Arranging the code this way also means that if we add support from other chat services, we can use the same message processor, and so consult the same list of actions.</p>
    <p class="normal">We may require a more complex or dynamic action configuration later, but for now, let's start with a simple mapping in the configuration file. The dictionary keys will be some text to look for at the start of the message, and the value is the name of a function to be called when it matches. Each of those functions will take the same arguments, to make our life simpler:</p>
    <pre class="programlisting code"><code class="hljs-code">    ACTION_MAP = {
        "help": show_help_text,
        "weather": fetch_weather,
        "config": user_config,
    }
    def process_message(message, metadata):
        """Decide on an action for a chat message.
        Arguments:
            message (str): The body of the chat message
            metadata (dict): Data about who sent the message,
                  the time and channel.
        """
        reply = None
        for test, action in ACTION_MAP.items():
            if message.startswith(test):
                reply = action(message.lstrip(test), metadata)
                break
        if reply:
            post_to_slack(reply, metadata)
</code></pre>
    <p class="normal">By using this approach, adding new actions to our bot does not involve any changes to the <code class="Code-In-Text--PACKT-">process_message</code> function, and so no changes are made to the tests for that function; instead, we just change a dictionary near the top of the file. It will also be easier to move the <code class="Code-In-Text--PACKT-">ACTION_MAP</code> into a database or configuration file later if we discover that this would be useful.</p>
    <p class="normal">The actions might make <a id="_idIndexMarker259"/>good use of the metadata, and so we pass that information along. Looking up the weather, for example, can make use of any stored location that the person has told us about.</p>
    <h2 id="_idParaDest-83" class="title">OAuth tokens</h2>
    <p class="normal"><strong class="keyword">OAuth2</strong> (<a href="https://oauth.net/2/">https://oauth.net/2/</a>) allows us <a id="_idIndexMarker260"/>to make an authenticated request to someone else's site. We could request read-only access to <a id="_idIndexMarker261"/>someone's Google calendar, permission to post issues to GitHub, or the ability to read information about our recorded exercises in a fitness application. We can do all of this without ever asking for someone's password to a different site—something no one should ever do!</p>
    <p class="normal">For our example, we will connect to Slack to allow the people using our bot to log in and update information about themselves. We can also use this to fetch information about them, such as the details of their Slack profile—if they allow us to.</p>
    <p class="normal">We will present people visiting a web page with a button they can use to log in to the site using Slack, which will send the web browser off to Slack's page to authorize our application. If they agree, then our application is given a code, which we can then use to request an access token. That access token will let us contact Slack and verify that the token is still valid, and let us ask for the information the person has allowed us to view—or change! For this example, we will need HTTPS enabled and a valid site certificate. The easiest way to do this will be to use a proxy and a "Let's Encrypt" certificate. We will cover setting up this proxy and certificate in <em class="chapterRef">Chapter 7</em>, <em class="italic">Securing Your Services</em>. For now, let's look at how we log users in:</p>
    <pre class="programlisting code"><code class="hljs-code">    # slack_oauth2.py
    import os
    from quart import Quart, request, render_template
    import aiohttp
    app = Quart(__name__)
    @app.route("/")
    async def welcome_page():
        client_id = os.environ["SLACK_CLIENT_ID"]
        return await render_template("welcome.html", client_id=client_id)
    @app.route("/slack/callback")
    async def oauth2_slack_callback():
        code = request.args["code"]
        client_id = os.environ["SLACK_CLIENT_ID"]
        client_secret = os.environ["SLACK_CLIENT_SECRET"]
        access_url = f"https://slack.com/api/oauth.v2.access?client_id={client_id}&amp;client_secret={client_secret}&amp;code={code}"
        async with aiohttp.ClientSession() as session:
            async with session.get(access_url) as resp:
                access_data = await resp.json()
                print(access_data)
        return await render_template("logged_in.html")
    if __name__ == "__main__":
        app.run() 
</code></pre>
    <p class="normal">We have <a id="_idIndexMarker262"/>introduced <strong class="keyword">aiohttp</strong> (<a href="https://docs.aiohttp.org/">https://docs.aiohttp.org/</a>) here, which is a useful asynchronous <a id="_idIndexMarker263"/>library for making outgoing <a id="_idIndexMarker264"/>web requests. We are also not handling the error responses that our callback view receives, or storing this useful data in a database to use later on. In that view, <code class="Code-In-Text--PACKT-">@login_required</code> and <code class="Code-In-Text--PACKT-">current_user</code> are part of the authentication and authorization processes presented in the next section.</p>
    <h2 id="_idParaDest-84" class="title">Authentication and authorization</h2>
    <p class="normal">Our monolithic application is <a id="_idIndexMarker265"/>almost ready but it also requires a way to <a id="_idIndexMarker266"/>handle authentication and authorization. Simply put:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Authentication</strong> is proving that you are who you claim to be</li>
      <li class="bullet"><strong class="keyword">Authorization</strong> is determining what actions you are permitted to perform</li>
    </ul>
    <p class="normal">This is a careful—but critically important—distinction to make. In most services, there is an administrator, who must provide authentication—prove who they are—to be granted permission to perform configuration updates. A regular user of the service still must prove who they are, but the things they can do will not include the same access rights as used by administrators.</p>
    <p class="normal">For Jeeves, we need to connect our Slack users to our web service user interface so that people can authenticate with external services. We are setting up the third-party authentication this way so that we don't need to perform any complicated changes to a standard OAuth process.</p>
    <p class="normal">Since Slack uses an <a id="_idIndexMarker267"/>internal identifier for most users, we won't see—nor do <a id="_idIndexMarker268"/>we need to—the friendly name they have chosen to display to other people. Instead, we will know them by a short nine-character string: You can view your own by checking your Slack profile, and it will be visible under the <strong class="keyword">More</strong> menu. How do we connect that with the web interface? The quickest way would be to get a sign-in link from the bot. If a user sends Jeeves a message asking to log in, Jeeves can reply with a URL. Once visited, that URL will let the user set a password and use all the web features.</p>
    <p class="normal">For our monolithic solution, we have just seen how we can let people log in using Slack without us ever having to handle a password. Using the <code class="Code-In-Text--PACKT-">quart-auth</code> library makes managing session information for a user straightforward as it provides useful helper functions to create and store session cookies so that we will be remembered between visits.</p>
    <p class="normal">Looking at the changes, our welcome page no longer presents the login button in its template, but instead now has a new decorator, <code class="Code-In-Text--PACKT-">@login_required</code>, which will only allow the view to be loaded if we have declared that the current visitor has successfully authenticated:</p>
    <pre class="programlisting code"><code class="hljs-code">    @app.route("/")
    @login_required
    async def welcome_page():
        return await render_template("welcome.html")
</code></pre>
    <p class="normal">If a visitor to the site is not authenticated, then their visit will be handled by the <code class="Code-In-Text--PACKT-">errorhandler</code> we set, which here redirects them to the login page. The login page does the same job as our previous welcome page and shows the user the login button to press:</p>
    <pre class="programlisting code"><code class="hljs-code">    @app.route("/slack_login")
    async def slack_login():
        client_id = os.environ["SLACK_CLIENT_ID"]
        return await render_template("login.html", client_id=client_id)
    @app.errorhandler(Unauthorized)
    async def redirect_to_login(_):
        return redirect(url_for("slack_login"))
</code></pre>
    <p class="normal">The Slack OAuth2 process <a id="_idIndexMarker269"/>continues as it did before, and we receive a <a id="_idIndexMarker270"/>message in our callback. If the message indicates that things went well, then we can use the <code class="Code-In-Text--PACKT-">AuthUser</code> calls of <code class="Code-In-Text--PACKT-">quart-auth</code> and the <code class="Code-In-Text--PACKT-">login_user</code> calls to set a session for this user. Let's put the whole thing together in a working example, making use of the <code class="Code-In-Text--PACKT-">secrets</code> library to generate a secure, but temporary, secret key for development:</p>
    <pre class="programlisting code"><code class="hljs-code">     # logging_in.py
    import os
    from quart import Quart, request, render_template, redirect, url_for
    from quart_auth import (
        AuthManager,
        login_required,
        logout_user,
        login_user,
        AuthUser,
        Unauthorized,
    )
    import aiohttp
    import secrets
    app = Quart(__name__)
    AuthManager(app)
    app.secret_key = secrets.token_urlsafe(16)
    @app.route("/")
    @login_required
    async def welcome_page():
        return await render_template("welcome.html")
    @app.route("/slack_login")
    async def slack_login():
        client_id = os.environ["SLACK_CLIENT_ID"]
        return await render_template("login.html", client_id=client_id)
    @app.errorhandler(Unauthorized)
    async def redirect_to_login(_):
        return redirect(url_for("slack_login"))
    @app.route("/slack/callback")
    async def oauth2_slack_callback():
        code = request.args["code"]
        client_id = os.environ["SLACK_CLIENT_ID"]
        client_secret = os.environ["SLACK_CLIENT_SECRET"]
        access_url = f"https://slack.com/api/oauth.v2.access?client_id={client_id}&amp;client_secret={client_secret}&amp;code={code}"
        async with aiohttp.ClientSession() as session:
            async with session.get(access_url) as resp:
            access_data = await resp.json()
            if access_data["ok"] is True:
                authed_user = access_data["authed_user"]["id"]
                login_user(AuthUser(authed_user))
                return redirect(url_for("welcome_page")
        return redirect(url_for("slack_login"))
</code></pre>
    <p class="normal">If you do need to <a id="_idIndexMarker271"/>store passwords, the simplest form of protection is to <a id="_idIndexMarker272"/>make sure that they are not stored in the clear in a database; instead, store them in a hashed form that cannot be converted back to the original password. That will minimize the risk of leaking passwords if your server is compromised. For the authentication process, it just means that when the user logs in, you need to hash the incoming password to compare it to the stored hash. Always check to see what the latest recommendations are for hashing algorithms, as inventing your own or using one that is obsolete can be very risky.</p>
    <p class="normal">The transport layer is not usually the weak spot in application security. Thanks to the hard work of security professionals <a id="_idIndexMarker273"/>working on <strong class="keyword">Transport Layer Security</strong> (<strong class="keyword">TLS</strong>), we only need to concern ourselves with what happens inside the service once the request is received.</p>
    <p class="normal">In the same vein, more granular permission verifications can be done by looking at the <code class="Code-In-Text--PACKT-">current_user</code> variable <a id="_idIndexMarker274"/>that <code class="Code-In-Text--PACKT-">quart_auth</code> sets in the <a id="_idIndexMarker275"/>application context. For example, you could use this to allow a user to change their data, but prevent them from changing any other users' data.</p>
    <h2 id="_idParaDest-85" class="title">Background tasks</h2>
    <p class="normal">So far, our application has <a id="_idIndexMarker276"/>several features that would be useful to run as scheduled tasks, without user interaction: our weather action could check for weather alerts in a user's area and send a message to them; a calendar action could report on your scheduled meetings at the start of the working day; a monthly report of the actions that have been undertaken could be produced and emailed to the person looking after the bot.</p>
    <p class="normal">These are background tasks, and they need to run on their own outside the HTTP request/response cycle. Most operating systems have some form of scheduled task feature, such as cron on Unix or Scheduled Tasks in Windows. These features may not be ideal for our application, as it means we are connected to a specific platform when we should ideally be platform-agnostic, and able to run inside containers, or migrate to a serverless platform if our needs change.</p>
    <p class="normal">A popular way to run repetitive background tasks in Python web apps is to use <strong class="keyword">Celery</strong>, a distributed task queue that can execute some work in a standalone process: <a href="http://docs.celeryproject.org">http://docs.celeryproject.org</a>.</p>
    <p class="normal">To run these pieces of work, an intermediate called a message broker is in charge of passing messages back and forth between the application and Celery. For instance, if the app wants Celery to run something, it will add a message in the broker; Celery will poll it and do the job.</p>
    <p class="normal">A message broker can be any service that can store messages and provide a way to retrieve them. The Celery <a id="_idIndexMarker277"/>project works out of the box with <strong class="keyword">Advanced Message Queuing Protocol</strong> (<strong class="keyword">AMQP</strong>) services <a id="_idIndexMarker278"/>such as <strong class="keyword"><a id="_idIndexMarker279"/></strong><strong class="keyword">RabbitMQ</strong> (<a href="http://www.rabbitmq.com">http://www.rabbitmq.com</a>), <strong class="keyword">Redis</strong> (<a href="http://redis.io">http://redis.io</a>), and <strong class="keyword">Amazon SQS</strong> (<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>). AMQP provides a standard <a id="_idIndexMarker280"/>set of techniques for routing and delivering messages in a reliable way. We will be using RabbitMQ in our examples when we investigate the microservices design in more detail in the next chapter, where RabbitMQ will be responsible for making sure that messages reach their destination, and Celery is responsible for acting on those messages.</p>
    <p class="normal">The component that executes the job is called a worker, and Celery provides a class to start one. To use Celery from a <code class="Code-In-Text--PACKT-">Quart</code> application, you can create a <code class="Code-In-Text--PACKT-">background.py</code> module that instantiates a Celery object and marks your background tasks with an <code class="Code-In-Text--PACKT-">@celery.</code><code class="Code-In-Text--PACKT-">task</code> decorator.</p>
    <p class="normal">In the following example, we <a id="_idIndexMarker281"/>are using Celery to set up a task that will fetch weather reports for every user who has a location and a Slack username set in our database. While, in practice, we would want people to opt-in to this feature, it allows us to show how a task is constructed.</p>
    <p class="normal">We will use the database we created earlier in this chapter and assume we have added a location field to it. We should also add a function to let us search for user accounts with a location set:</p>
    <pre class="programlisting code"><code class="hljs-code">    class UserDAL:
        ...
        async def get_users_with_locations(self):
            query = select(User).where(User.location is not None)
            return await self.db_session.execute(query)
</code></pre>
    <p class="normal">Now we can set up a worker to do the task. The only difficulty is needing to wrap the function we call to do the work. To use the asynchronous database engine, it must be an <code class="Code-In-Text--PACKT-">async</code> function, but Celery can only call synchronous functions, so we use a helper found in the <code class="Code-In-Text--PACKT-">asgiref</code> library to convert it:</p>
    <pre class="programlisting code"><code class="hljs-code">    # weather_worker.py
    import asyncio
    from asgiref.sync import async_to_sync
    from celery import Celery
    from database import user_dal
    celery_app = Celery("tasks", broker="amqp://localhost")
    async def fetch_weather(location):
        return "This is where we would call the weather service"
    async def post_to_slack(message, options):
        print(f"This is where we would post {message}")
    async def weather_alerts_async():
        async with user_dal() as ud:
            query_results = await ud.get_users_with_locations()
            for user in query_results:
                user = user[0] # the database returns a tuple
                weather_message = await fetch_weather(user.location)
                username = user.slack_id
                if not username.startswith("@"):
                    username = "@" + username
                await post_to_slack(weather_message, {"channel": username})
    @celery_app.task
    def do_weather_alerts():
        async_to_sync(weather_alerts_async)()
    @celery_app.on_after_configure.connect
    def setup_periodic_tasks(sender, **kwargs):
        sender.add_periodic_task(10.0, do_weather_alerts, name="fetch the weather", expires=30)  
</code></pre>
    <p class="normal">Celery will need <a id="_idIndexMarker282"/>RabbitMQ running in order to work—there are tutorials on RabbitMQ's website, but below we assume you have Docker installed and can run containers. If you don't, then don't worry; we will discuss containers in more detail in <em class="chapterRef">Chapter 10</em>, <em class="italic">Deploying on AWS</em>. We run the Celery background worker, which will wait for messages to arrive asking it to do work, and in another terminal, we start the scheduler, or beat, which will use the periodic task we set up:</p>
    <pre class="programlisting code"><code class="hljs-code">    
    docker run -d -p 5672:5672 rabbitmq 
    celery -A background worker  --loglevel=INFO
    celery -A background beat --loglevel=INFO
</code></pre>
    <p class="normal">This Celery worker also connects to RabbitMQ using AMQP, so that tasks can be triggered by sending a message through the broker. This will be especially useful if we don't need to send an immediate response to the caller, but instead expect a longer-running process to perform some tasks.</p>
    <p class="normal">Continuing our setup, we <a id="_idIndexMarker283"/>can look at the scheduler. Every 10 seconds is probably a bit too frequent for a report like this. We should instead use the crontab feature from Celery, which lets us specify a schedule while using the more familiar Unix crontab settings:</p>
    <pre class="programlisting code"><code class="hljs-code">    from celery.schedules import crontab
    @celery_app.on_after_configure.connect
    def setup_periodic_tasks(sender, **kwargs):
        sender.add_periodic_task(       
            crontab(hour=7, minute=30, day_of_week='monday'),
            do_weather_alerts, name="fetch the weather", expires=30
        )
</code></pre>
    <p class="normal">When the Celery service is invoked by the <code class="Code-In-Text--PACKT-">Quart</code> application by passing messages, it could be considered as a microservice in and of itself. That is also interesting in terms of deployment since both the RabbitMQ server and the Celery app can be deployed on another server. Our asynchronous function can then use the current app context to access the database, run queries, and then use the features of our application to run tasks.</p>
    <h1 id="_idParaDest-86" class="title">Putting together the monolithic design</h1>
    <p class="normal">This monolithic design is a <a id="_idIndexMarker284"/>solid foundation and should be the kind of result you would aim for in your first development iteration. Everything should be created with tests and documentation, as explained in <em class="chapterRef">Chapter 3</em>, <em class="italic">Coding, Testing, and Documentation: the Virtuous Cycle</em>.</p>
    <p class="normal">It is a short and clean implementation on top of a relational database that can be deployed with a PostgreSQL, MySQL, or a cloud provider's own SQL database. Thanks to the SQLAlchemy abstractions, a local version can run with SQLite 3 and facilitate your day-to-day development and local testing. To build this app, we've used the following extensions and libraries:</p>
    <ul>
      <li class="bullet"><strong class="keyword">aiohttp</strong>: This <a id="_idIndexMarker285"/>handles all the outgoing HTTP requests</li>
      <li class="bullet"> <strong class="keyword">SQLAlchemy</strong>: This is <a id="_idIndexMarker286"/>used for the model</li>
      <li class="bullet"><strong class="keyword">Flask-WTF</strong> and <strong class="keyword">WTForms</strong>: These <a id="_idIndexMarker287"/>are used <a id="_idIndexMarker288"/>for all the forms</li>
      <li class="bullet"><strong class="keyword">Celery and RabbitMQ</strong>: These <a id="_idIndexMarker289"/>are used for <a id="_idIndexMarker290"/>background processes and periodic tasks</li>
      <li class="bullet"><strong class="keyword">quart-auth</strong>: This is used for <a id="_idIndexMarker291"/>managing authentication and authorization</li>
    </ul>
    <p class="normal">The overall design can be represented in a diagram, as shown in <em class="italic">Figure 4.3</em>:</p>
    <figure class="mediaobject"><img src="img/B17108_04_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.3: The components of our first design</p>
    <p class="normal">A typical early <a id="_idIndexMarker292"/>deployment will put all of these services on the same server. It's certainly simpler that way, and it often feels straightforward to give an application a more powerful computer—this is known as scaling vertically. A single computer, whether it's a virtual machine in a cloud provider or a physical server in your building, has a limited number of resources available, and so there is a practical upper limit to vertical scaling.</p>
    <p class="normal">Whether your application is running out of memory, network throughput, CPU processing availability, or some other bottleneck, the best solution is to update the architecture so that the service can be run across many different computers. This is scaling horizontally, and is one of the benefits of using microservices. If a microservice needs more I/O throughput to serve all its requests than a single computer can provide, that's not a problem if it <a id="_idIndexMarker293"/>can run across dozens or hundreds of computers.</p>
    <h1 id="_idParaDest-87" class="title">Summary</h1>
    <p class="normal">The Jeeves bot is a typical web app that interacts with a database and a few backend services. The only unusual feature is that it receives most of its workload from one endpoint. Building this application with a monolithic architecture has allowed us to quickly iterate over several choices and get a prototype that works well during development and low-volume usage.</p>
    <p class="normal">From our discussions about the actions, it should be clear that there are good candidates for migration to a microservice. If we run this bot for dozens or hundreds of Slack workspaces, then we may find that one component is used much more than others, or has reliability issues that are difficult to address in the current architecture. How should the application scale up? What happens when an external service it relies upon is encountering errors? What happens if one of our own components—our database or message broker—goes down?</p>
    <p class="normal">In the next chapter, we will look at these issues: how to change the architecture of Jeeves so that it is more resilient, and how to make careful, measured changes to the service.</p>
  </div>
</body></html>