<html><head></head><body>
		<div><h1 id="_idParaDest-68"><em class="italic"><a id="_idTextAnchor077"/>Chapter 3</em>: Models, Relations, and Inheritance</h1>
			<p><strong class="bold">Models</strong> represent tables, also known<a id="_idIndexMarker338"/> as objects, within a database. Django<a id="_idIndexMarker339"/> provides a simple way to map objects to a project's underlying database(s). We will use this mapping system to work with other components of Django in later chapters of this book, such as a template, view, or form, to name a few. Anything that relies on accessing data from within a database will rely on the models that we create. If a project connects to an external database system or the project uses an API to interact with data, then there is no need to create any models in that situation.</p>
			<p>In this chapter, we will cover the following:</p>
			<ul>
				<li>Writing model classes to create database tables</li>
				<li>Using standard field types and third-party field types</li>
				<li>Configuring field validators</li>
				<li>Linking tables through field relationships</li>
				<li>Working with model meta classes and options</li>
				<li>Using model methods and method decorators</li>
				<li>Practicing extending models</li>
				<li>Introducing using the Django shell as a tool to perform queries and add data</li>
				<li>Creating a model manager to format and control data</li>
			</ul>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p>To work with the code in this chapter, the following tools will need to be installed on your local machine: </p>
			<ul>
				<li>Python version 3.9 – used as the underlying programming language for the project</li>
				<li>Django version 4.0 – used as the backend framework of the project</li>
				<li>pip package manager – used to manage third-party Python/Django packages</li>
			</ul>
			<p>We will continue to work with the solution created in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. However, it is not necessary to use the Visual Studio IDE. The main project itself can be run using another IDE or independently using a terminal or command-line window from within the project root folder. This is where the <code>manage.py</code> file resides. Whatever editor or IDE you are using, a virtual environment will also be needed to work with the Django project. Instructions for how to create a project and virtual environment can be found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. You will need a database to store the data contained in your project. PostgreSQL was chosen for the examples in the previous chapter; however, any database type that you choose for your project can be used to work with the examples in this chapter.</p>
			<p>All of the code created in this chapter can be found in the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer">https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer</a>. The bulk of the code depicted in this chapter can be found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/</code> directory.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3zZ68RS">https://bit.ly/3zZ68RS</a></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor079"/>Preparing for this chapter</h1>
			<p>Start by creating a new app in your project called <code>chapter_3</code> by following the steps discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, under the subsection titled <em class="italic">Creating a Django app</em>. As discussed in that section, don't forget to change the value of the <code>name =</code> variable for your app class found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/apps.py</code> file to now point to the path where you installed your app. Be sure to also include this app in your <code>INSTALLED_APPS</code> variable found in the <code>settings.py</code> file as well.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor080"/>Writing model classes</h1>
			<p>Each model in your project represents<a id="_idIndexMarker340"/> a table within your database. The fields that are created in those models all relate<a id="_idIndexMarker341"/> to columns within that table. Django provides a technique called <code>settings.py</code> file of a project. The ORM technique is a process used to convert data between two systems of incompatible data types. This means that Django<a id="_idIndexMarker342"/> takes the headache out of working directly with <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) to perform queries. The Django ORM irons out odd differences between the various database types when interpreting SQL, making it a universal tool for working with all data structures. Now, you and your developers can focus more on developing and less on the headaches involved. Django does not require the use of SQL as a standard writing practice. However, if you want or need to, Django does provide a way to use basic SQL when performing query operations.</p>
			<p>Next, imagine we are building a site that allows a user to view a page providing details about a specific car, commonly<a id="_idIndexMarker343"/> referred to as a detail page/view. Let's say we are building a basic site just to store and look up details about cars that are listed for sale. A user could do this for a number of reasons; perhaps they are renting, buying, leasing, or selling a car. In any scenario, we would need a table that represents a vehicle object, another table for the model of the vehicle (not to be confused with a Django model), and another table for the engine type. In a real-world scenario, your project may consist of many other tables and the structure of these tables may also differ in many ways. In this particular exercise, we won't create a model for the manufacturer, also known as the make of a vehicle. The manufacturer will be created as a set in order to demonstrate certain concepts for educational purposes:</p>
			<ol>
				<li>Inside the <code>models.py</code> file of the <code>chapter_3</code> directory that was just created, write three empty classes, one for each of the tables related to our vehicle exercise, following this example:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong>
from django.db import <strong class="bold">models</strong>
<strong class="bold">class Vehicle(models.Model):</strong>
    <strong class="bold">pass</strong></pre></li>
				<li>Create one class each for <code>Vehicle</code>, <code>VehicleModel</code>, and <code>Engine</code>. We will name the class<a id="_idIndexMarker344"/> pertaining to a model of a vehicle as <code>VehicleModel</code> instead of <code>Model</code> in order to prevent confusion as we work through each exercise.<p class="callout-heading">Tip</p><p class="callout">In the preceding example, three classes were created that do absolutely nothing at this time by writing the <code>pass</code> statement directly in them. This is a tool to add to your toolbox for writing skeleton code and allowing other components to continue to function while you write. Python will give you errors if nothing is placed in a class and when you are ready to write code for that class, remove the <code>pass</code> statement and replace it with your actual code.</p></li>
			</ol>
			<p>The names given to model classes can be almost anything you would like, but they cannot be any of the reserved Python keywords, such as <code>True</code>, <code>False</code>, <code>class</code>, <code>pass</code>, and <code>import</code>. Name your classes anything that makes sense when you are using them elsewhere in your code. You can use uppercase or lowercase letters, but when Django creates your tables, the names will always be lowercase. This is why it is unacceptable to name two different classes the same name with different letter casings. For example, if we named two classes <code>class Vehicle</code> and <code>class vehicle</code>, Django would then tell us we have the following <code>RuntimeError</code> when attempting to make migrations:</p>
			<pre>RuntimeError: Conflicting 'vehicle' models in application 'chapter_3':</pre>
			<p>This is why it is better to adopt a writing style that uses one or the other letter casing and stick with that pattern throughout your project.</p>
			<p>Let's discuss the various field types that exist and see which ones we can use for our vehicle exercises.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor081"/>Standard field types</h2>
			<p>Right out of the<a id="_idIndexMarker345"/> box, Django offers numerous <strong class="bold">Standard Field Types</strong> to choose from. The following tables<a id="_idIndexMarker346"/> can be used as cheat sheets when writing your models:</p>
			<div><div><img src="img/B17243_03_Table1.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption"><img src="img/B17243_03_Table2.png" alt=""/></p>
			<p>For a complete breakdown<a id="_idIndexMarker347"/> of all of the field types<a id="_idIndexMarker348"/> to choose from, you can<a id="_idIndexMarker349"/> visit the official Django documentation on field types here: <a href="https://docs.djangoproject.com/en/4.0/ref/models/fields/">https://docs.djangoproject.com/en/4.0/ref/models/fields/</a>.</p>
			<h3>Field arguments</h3>
			<p>Every field class will accept <code>verbose_name</code>, <code>blank</code>, and <code>null</code> arguments on our fields quite often. <code>verbose_name</code> will specify the human-readable name for a field. We should specify a <code>max_length</code> argument for any <code>CharField</code> instances that we use, to limit the character length of that field. Without setting a <code>max_length</code> argument, the character length limit is theoretically unlimited. However, you are limited by the physical restrictions of the database that you are using; the limit would then be several thousand or hundreds of thousands of characters instead of the literal infinite limit. The <code>null</code> and <code>blank</code> arguments are almost considered the same thing, except that the <code>null</code> argument says that the database can store a null value for any empty records. The <code>blank</code> argument is related to validation performed on that field, at the database level, to check whether a user attempted to enter a null value when saving or creating that record in the database. </p>
			<p>A <code>default</code> argument will be used to assign a value to a field by default, should a value not be provided at the time an object is created or updated. Default values are used in circumstances where, say, data is being migrated into your database from an outside source, with data that isn't in synchronization with the constraints set on your tables. For example, if you had a field argument set to <code>null=False</code> and you imported data that contained a null value, errors would likely result. Say you had a <code>BooleanField</code> with the <code>default=True</code>/<code>False</code> argument, and then performed the same data import; then, all those null values would be converted to <code>True</code>/<code>False</code> automatically during your import. A <code>default</code> argument can be applied to virtually every field type. </p>
			<p>The <code>choices</code> argument allows us to pass in a predefined set of choices that contain a value and a human-readable interpretation<a id="_idIndexMarker355"/> of that value. Choices<a id="_idIndexMarker356"/> can be used on <code>CharField</code> and <code>BooleanField</code> instances, as well as a handful of other field types. They can be made into a drop-down select box or be used in a collection of checkboxes or radio buttons. The <code>choices</code> argument accepts a list of tuples, where each tuple consists of the first element being the value of the field and the second element being the human-readable string representation of that value. For this exercise, we will be converting the human-interpreted <em class="italic">yes/no</em> choices into a computer-interpreted <em class="italic">true/false</em> value on a <code>BooleanField</code>. We will also apply this technique to the manufacturer/make field later in this chapter, in order to store an integer value.</p>
			<p>Another argument that can be useful is the <code>editable=False</code> attribute. This attribute would render a field hidden in any form object within a template. This field would not be visible or editable by the user in any way. The <code>unique=True</code> argument can also be useful. This argument states that two rows/records in your table cannot have the same value for that particular field. This would be useful if, say, an email field is used as a unique identifier for a model, preventing duplicates from existing. We would get conflicting results with errors telling us that the email address already exists when saving or creating a new record.</p>
			<p>Model field arguments differ from form field arguments in that the model arguments will apply rules to your columns on the database level. Your form field arguments, which we will cover in <a href="B17243_05_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 5</em></a>, <em class="italic">Django Forms</em>, are rules that only apply to a field as it is used within a particular form. This means you can set <code>blank=True</code> on a model field, making it not required on the database level but in a <code>required=True</code> form field set, making it required for that particular form. Alternatively, we could make that field required in all forms by setting the constraint at the database level using <code>blank=False</code>. Keep that in mind when writing your model classes.</p>
			<p>Next, let's begin writing the different fields that are needed for our vehicle scenario.</p>
			<h3>Adding a standard field type</h3>
			<p>From the Django fields list provided<a id="_idIndexMarker357"/> earlier, we will use <code>CharField</code> for each of the models. <code>CharField</code> will be used to provide a name for each item as we add them to the database, except for the <code>Vehicle</code> model class. For the <code>Vehicle</code> model, we<a id="_idIndexMarker358"/> will use <code>CharField</code> as the <code>BooleanField</code> on the <code>Vehicle</code> model, to store a value indicating whether or not this vehicle has been sold. This is the field where we will create a list of <em class="italic">yes/no</em> choices to use instead of the <em class="italic">true/false</em> values.</p>
			<p>Follow these steps to create the fields<a id="_idIndexMarker359"/> for each of your model classes. Remember to remove the <code>pass</code> statement:</p>
			<ol>
				<li value="1">In your <code>/chapter_3/models.py</code> file, create the set of <em class="italic">yes/no</em> choices above your model classes and below your <code>import</code> statements, as depicted:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
from django.db import models
<strong class="bold">YESNO_CHOICES</strong> = (
    (True, 'Yes'),
    (False, 'No')
)
...</pre></li>
				<li>Add the following field to your <code>VehicleModel</code> class:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">VehicleModel</strong>(models.Model):
    name = models.CharField(
        verbose_name = 'Model',
        max_length = 75,
        unique = True,
        blank = True,
        null = True,
    )</pre></li>
				<li>Add the following field to your <code>Engine</code> class:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">Engine</strong>(models.Model):
    name = models.CharField(
        verbose_name = 'Engine',
        max_length = 75,
        blank = True,
        null = True,
    )</pre></li>
				<li>Add the following<a id="_idIndexMarker360"/> fields to your <code>Vehicle</code> class:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">Vehicle</strong>(models.Model):
    vin = <strong class="bold">models.CharField</strong>(
        <strong class="bold">verbose_name = 'VIN'</strong>,
        <strong class="bold">max_length = 17</strong>,
        <strong class="bold">unique = True,</strong>
        <strong class="bold">blank = True</strong>,
        <strong class="bold">null = True</strong>,
    )
    sold = <strong class="bold">models.BooleanField</strong>(
        verbose_name = 'Sold?',
        <strong class="bold">choices = YESNO_CHOICES</strong>,
        <strong class="bold">default = False</strong>,
        blank = True,
        null = True,
    )</pre></li>
			</ol>
			<p>The <code>name</code> field on the <code>VehicleModel</code> class shown previously will use the <code>unique</code> argument, allowing only names<a id="_idIndexMarker361"/> that do not already exist in that table. The <code>name</code> field on the <code>Engine</code> class will not use the <code>unique</code> argument, so we can allow engines of the same name but assign them to different vehicle models. The <code>YESNO_CHOICES</code> variable is used as a global variable placed outside of any model class so that it can be used in many fields if needed. If a variable or set of choices is extremely unique, then it is best practice to place it above your field declarations, within the model class that is it being used in. You could also store these variables in an entirely separate file as well, as long as the code remains clean and simple.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The preceding code is a relaxed style of the PEP-8 style guide where we are placing each argument on its own line, separated by a comma while also following basic Python indentation rules. Most of the code throughout this book will be written in this way.</p>
			<ol>
				<li value="5">Run the Django <code>makemigration</code> and <code>migrate</code> commands, as shown:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py makemigrations</strong>
<strong class="bold">Migrations for 'chapter_3':</strong>
<strong class="bold">  becoming_a_django_entdev\chapter_3\migrations\0001_initial.py</strong>
<strong class="bold">    - Create model Engine </strong>
<strong class="bold">    - Create model Vehicle</strong>
<strong class="bold">    - Create model VehicleModel</strong>
<strong class="bold">(virtual_env) PS &gt; python3 manage.py migrate</strong>
<strong class="bold">Operations to perform:</strong>
<strong class="bold">  Apply all migrations: admin, auth, chapter_1, chapter_3, contenttypes, sessions</strong>
<strong class="bold">Running migrations:</strong>
<strong class="bold">  Applying chapter_3.0001_initial... OK</strong></pre></li>
			</ol>
			<p>Every time a model is changed, created, or deleted, these Django migration commands will need<a id="_idIndexMarker362"/> to be executed in order to prevent runtime errors. They can be executed from either your IDE or within a command line or terminal window, executed from within your project's root directory, where your <code>manage.py</code> file lives. Refer to <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, in the subsection titled <em class="italic">Building initial table structures</em> to learn more about the different ways to execute these commands.</p>
			<p>If those two Django migration commands were successful, three more tables will have been created in your database. When viewed from within your PgAdmin tool or any other database management tool that you decided to use, those tables will look similar to as in the following screenshot:</p>
			<div><div><img src="img/Figure_3.1_B17243.jpg" alt="Figure 3.1 – PgAdmin – created vehicle, model, and engine tables&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – PgAdmin – created vehicle, model, and engine tables</p>
			<p>If we needed to use fields that don't come standard in Django, such as <code>AddressField</code>, <code>MoneyField</code>, or <code>PhoneField</code>, we would have<a id="_idIndexMarker363"/> to install packages and also configure settings before we can use them. Let's prepare our project next to let us do just that, by integrating <code>MoneyField</code> into these examples.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor082"/>Third-party field types</h2>
			<p>A <code>django-address</code> package uses the Google Maps API to suggest addresses related to what the user has typed as the user is typing into a single text field. This means that the package provides the model class as well as the form field class it creates and any other related tools. Related tools such as, all of the JavaScript and CSS libraries that help a form work. The <code>django-image-cropping</code> tool is also very powerful: it allows a user to upload an image and let the user crop the image however they desire. </p>
			<p>There is a package specifically made to handle currency called <code>django-money</code>. This package takes <code>DecimalField</code> from the list of standard field types and provides many different actions that involve working with money in a financial industry-accepted way. The <code>django-money</code> package provides definitions for all currencies that exist today and includes their corresponding currency sign. In addition to performing arithmetic operations, such as addition and subtraction, currencies can also be converted from one sign to another using current exchange rates. This means that this package will communicate with an API to retrieve that information. </p>
			<p>The <code>django-phone-field</code> package will accept a phone number that is rather versatile. The phone field allows for country codes and accepts special characters so that it can be masked to any format you need. The <code>django-ckeditor</code> package is a tool used for adding rich text editors to your pages, allowing users to enter HTML into one of your form fields. If you're using django CMS, they also make a version of the django-ckeditor package specifically for use with the django CMS package. </p>
			<p>Here is<a id="_idIndexMarker366"/> a short list<a id="_idIndexMarker367"/> of third-party<a id="_idIndexMarker368"/> field types<a id="_idIndexMarker369"/> to add to your<a id="_idIndexMarker370"/> field type<a id="_idIndexMarker371"/> cheat sheet from before:</p>
			<ul>
				<li><code>AddressField</code> – <a href="https://pypi.org/project/django-address/">https://pypi.org/project/django-address/</a> </li>
				<li><code>ImageCropField</code> – <a href="https://pypi.org/project/django-image-cropping/">https://pypi.org/project/django-image-cropping/</a> </li>
				<li><code>MoneyField</code> – <a href="https://pypi.org/project/django-money/">https://pypi.org/project/django-money/</a> </li>
				<li><code>PhoneField</code> – <a href="https://pypi.org/project/django-phone-field/">https://pypi.org/project/django-phone-field/</a> </li>
				<li><code>RichTextField</code> – <a href="https://pypi.org/project/django-ckeditor/">https://pypi.org/project/django-ckeditor/</a> </li>
				<li>(<em class="italic">django CMS</em>) <code>RichTextField</code> – <a href="https://pypi.org/project/djangocms-text-ckeditor/">https://pypi.org/project/djangocms-text-ckeditor/</a> </li>
			</ul>
			<p>Next, we will<a id="_idIndexMarker372"/> add <code>MoneyField</code> to our <code>Vehicle</code> model <a id="_idIndexMarker373"/>class.</p>
			<h3>Adding a third-party field type</h3>
			<p>Since some of the fields, such as <code>AddressField</code>, require obtaining<a id="_idIndexMarker374"/> a personal Google API key directly from Google, we will not be using that field type. We will only demonstrate using one of these third-party field types and then move on to the next topic. </p>
			<p>To include <code>MoneyField</code> in a project, follow these steps:</p>
			<ol>
				<li value="1">Add <code>django-money</code> to your <code>requirements.txt</code> file and install it in your virtual environment or run the following command to manually install this package. Make sure your virtual environment is already activated:<pre><strong class="bold">(virtual_env) PS &gt; pip install django-money</strong></pre></li>
				<li>In your <code>settings.py</code> file, add the following app to your <code>INSTALLED_APPS</code> list:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
...
INSTALLED_APPS = [
    ...,
    <strong class="bold">'djmoney',</strong>
    'becoming_a_django_entdev.chapter_3',
]</pre></li>
			</ol>
			<p>Make sure it is located above your local apps<a id="_idIndexMarker375"/> and below all of your <code>django.contrib</code> apps, as shown previously, where it is placed before the <code>chapter_3</code> app.</p>
			<ol>
				<li value="3">Using <code>MoneyField</code>, you can specify the different currencies available in your project within the <code>settings.py</code> file. In the following example, we specify the US dollar and European euro as the two currencies available in this project:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
...
<strong class="bold">CURRENCIES</strong> = ('USD', 'EUR')
<strong class="bold">CURRENCY_CHOICES</strong> = [
    (<strong class="bold">'USD'</strong>, 'USD $'), 
    (<strong class="bold">'EUR'</strong>, 'EUR €')
]</pre></li>
				<li>Add the following highlighted <code>import</code> statement to the top of your <code>/chapter_3/models.py</code> file: <pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
from django.db import models
<strong class="bold">from djmoney.models.fields import MoneyField</strong></pre></li>
				<li>In your <code>Vehicle</code> class, add the price field shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">Vehicle</strong>(models.Model):
    ...
    price = <strong class="bold">MoneyField</strong>(
        max_digits = 19,
        decimal_places = 2,
        default_currency = 'USD',
        null = True,
    )</pre></li>
			</ol>
			<p>You will also need to use the field arguments<a id="_idIndexMarker376"/> depicted in the preceding example (adjust the values as needed).</p>
			<p>Let's explore what validation we can apply to the field types that we are using.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor083"/>Model field validators</h2>
			<p>Field validators<a id="_idIndexMarker377"/> are database-level rules that can be set on model fields. They are useful in situations<a id="_idIndexMarker378"/> where instead of <code>DecimalField</code>, using a <code>max_length</code> argument to control the character length, we are defining a minimum or maximum numeric value. A Django <code>ValidationError</code> if that criterion is not met. Since this is a callable, you can write your own function to suit your needs or use one of the many different callable functions that come included with Django. For instance, we could use the <code>MinValueValidator</code> and <code>MaxValueValidator</code> functions when specifying a constraint for a minimum or maximum numeric value. You can view a complete<a id="_idIndexMarker379"/> list of validator functions provided by Django here: <a href="https://docs.djangoproject.com/en/4.0/ref/validators/">https://docs.djangoproject.com/en/4.0/ref/validators/</a>. </p>
			<h3>Setting a field validator</h3>
			<p><code>MoneyField</code> offers a few of its own field<a id="_idIndexMarker380"/> validators that add constraints on currency values of whatever type is defined in your project. The money validators take the leg work out of using a Django <code>DecimalValidator</code> or writing your own callable method. </p>
			<p>Follow these steps to set your validator on the existing <code>Vehicle</code> model:</p>
			<ol>
				<li value="1">At the top of your <code>/chapter_3/models.py</code> file, and just below your existing <code>import</code> statements, add the following <code>import</code> statement:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
<strong class="bold">from djmoney.models.validators import MaxMoneyValidator, MinMoneyValidator</strong></pre></li>
				<li>Whether it is a standard Django field validator or another one provided by a third-party package, it will go in the validator argument of a field, as shown on the <code>price</code> field of the <code>Vehicle</code> model here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">Vehicle</strong>(models.Model):
    ...
    <strong class="bold">price</strong> = MoneyField(
        max_digits = 19,
        decimal_places = 2,
        default_currency = 'USD',
        null = True,
        <strong class="bold">validators</strong> = [
            <strong class="bold">MinMoneyValidator(</strong>
                <strong class="bold">{'EUR': 500, 'USD': 400}</strong>
            <strong class="bold">)</strong>,
            <strong class="bold">MaxMoneyValidator(</strong>
                <strong class="bold">{'EUR': 500000, 'USD': 400000}</strong>
            <strong class="bold">)</strong>,
        ])</pre></li>
			</ol>
			<p>These functions usually take in one or more arguments<a id="_idIndexMarker381"/> themselves. In this example, we are specifying the parameters for the minimum and maximum currency values. The preceding example states that all Euro (<code>EUR</code>) values should be between 500 and 500,000 Euros and the American dollar values (<code>USD)</code> should be between 400 and 400,000 dollars. These are rough estimates used for demonstration only and are not exact conversion rates.</p>
			<p>Currently, our three model classes exist independently from one another. This means they are not linked to each other in any way just yet. We will need them to be related to one another before we are done. Next, we will be linking those tables by working with model field relationships.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor084"/>Working with model field relationships</h1>
			<p>Django provides three relationship<a id="_idIndexMarker382"/> types for linking tables: </p>
			<ul>
				<li><strong class="bold">Many</strong><strong class="bold">–</strong><strong class="bold">to</strong><strong class="bold">–</strong><strong class="bold">one</strong></li>
				<li><strong class="bold">Many</strong><strong class="bold">–</strong><strong class="bold">to</strong><strong class="bold">–</strong><strong class="bold">many </strong></li>
				<li><strong class="bold">One</strong><strong class="bold">–</strong><strong class="bold">to</strong><strong class="bold">–</strong><strong class="bold">one</strong></li>
			</ul>
			<p>A <em class="italic">many-to-one</em> relationship is<a id="_idIndexMarker383"/> defined by using a <code>ForeignKey</code> field, and the other two relationship types are defined using the self-explanatory <code>ManyToManyField</code> and <code>OneToOneField</code>. These fields are named appropriately after the relationship type that they represent. </p>
			<p>Next, we will discuss the key components of working with model field relationships.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor085"/>Field arguments</h2>
			<p>The three field types, <code>ForeignKey</code>, <code>ManyToManyField</code>, and <code>OneToOneField</code>, all accept<a id="_idIndexMarker384"/> the standard <code>default</code>, <code>blank</code>, and <code>verbose_name</code> field arguments that other field types accept. The <code>null</code> argument will have no effect on a <code>ManyToManyField</code> and will only apply to the <code>ForeignKey</code> and <code>OneToOneField</code> types. Two of these field types—<code>ForeignKey</code> and <code>OneToOneField</code>—require at least two positional arguments, the first being the model class that the field relates to and the second being the <code>on_delete</code> argument. Positional means they need to be in that order and required means they must be specified. The <code>on_delete</code> argument specifies what the database will do with records from related tables if a parent or child object is deleted. </p>
			<p>The <code>on_delete</code> choices include the following:</p>
			<ul>
				<li><code>models.CASCADE</code> – used to automatically delete any related objects when an object is deleted from that table.</li>
				<li><code>models.PROTECT</code> – used to prevent deletion of any of the objects.</li>
				<li><code>models.RESTRICT</code> – used to prevent deletion in certain scenarios.</li>
				<li><code>models.SET_DEFAULT</code> – used to set the field of related objects to a default value.</li>
				<li><code>models.SET_NULL</code> – used to set the field of related objects to a null value.</li>
				<li><code>models.SET()</code> – accepts a callable to write your own function for setting a value.</li>
				<li><code>models.DO_NOTHING</code> – will take no action; using this option could cause <strong class="bold">IntegrityError</strong> and should be used with caution.</li>
			</ul>
			<p>We will set the value for the <code>on_delete</code> argument to <code>models.CASCADE</code>, ensuring that if a <code>Vehicle</code> is deleted from the database, nothing will happen to the related <code>VehicleModel</code> and <code>Engine</code> objects. But if we deleted a <code>VehicleModel</code> or <code>Engine</code> object from<a id="_idIndexMarker385"/> the database, the related <code>Vehicle</code> that depends on that soon-to-be-deleted object will also be deleted. If we want to preserve <code>Vehicle</code> in the scenario of when either of those two is deleted, we should use the <code>models.SET_DEFAULT</code> value instead.</p>
			<p>The three field types—<code>ForeignKey</code>, <code>ManyToManyField</code>, and <code>OneToOneField</code>—all allow for us to follow relationships forward and backward when performing queries, which means if you query a parent object, you can follow that lookup forward to get all of its child objects. A reverse lookup would mean you query a child object and follow its lookup backward to get its parent object. These forward and reverse relationships are defined on fields by using the <code>related_name</code> and <code>related_query_name</code> arguments, which will soon be demonstrated.</p>
			<p>A <code>ForeignKey</code> field and <code>ManyToManyField</code> can accept a <code>limit_choices_to</code> argument, which applies a filter to the related queries. The <code>limit_choices_to</code> argument will accept a dictionary or Q object. It will also accept a callable function that returns either a dictionary or Q object. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">A <code>filter()</code>, <code>all()</code>, or <code>order_by()</code> statement cannot provide. To learn more about complex lookups with Q objects, visit the official Django documentation here: <a href="https://docs.djangoproject.com/en/4.0/topics/db/queries/#complex-lookups-with-q-objects">https://docs.djangoproject.com/en/4.0/topics/db/queries/#complex-lookups-with-q-objects</a>. To learn more about performing<a id="_idIndexMarker387"/> queries in general, jump ahead to the section titled <em class="italic">Performing queries</em> later in this chapter.</p>
			<p>Continuing on with our vehicle<a id="_idIndexMarker388"/> classes, we can apply some of these model relations and arguments to the classes we already wrote. They will help us link a hypothetical <code>Seller</code> to a <code>Vehicle</code>, a <code>Vehicle</code> to a <code>VehicleModel</code>, and that <code>VehicleModel</code> to an <code>Engine</code>.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor086"/>Field type – ForeignKey</h2>
			<p>We will be using a <code>ForeignKey</code> field to<a id="_idIndexMarker389"/> represent a <em class="italic">many-to-one</em> relationship<a id="_idIndexMarker390"/> between the <code>Vehicle</code> class and the <code>VehicleModel</code> and <code>Engine</code> classes. </p>
			<p>Follow these steps to create your <code>ForeignKey</code> field:</p>
			<ol>
				<li value="1">In your <code>/chapter_3/models.py</code> file, add the following two fields to your existing <code>Vehicle</code> model class, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">Vehicle</strong>(models.Model):
    ...
    <strong class="bold">vehicle_model = models.ForeignKey(</strong>
        <strong class="bold">VehicleModel</strong>,
        <strong class="bold">on_delete = models.CASCADE,</strong>
        verbose_name = 'Model',
        <strong class="bold">related_name = 'model_vehicle',</strong>
        blank = True,
        null = True,
    )
    <strong class="bold">engine = models.ForeignKey(</strong>
        <strong class="bold">Engine</strong>,
        <strong class="bold">on_delete = models.CASCADE,</strong>
        verbose_name = 'Engine',
        <strong class="bold">related_name = 'engine_vehicle',</strong>
        blank = True,
        null = True,
    )</pre></li>
				<li>In your <code>/chapter_3/models.py</code> file, add<a id="_idIndexMarker391"/> the following field<a id="_idIndexMarker392"/> to your existing <code>Engine</code> model class, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">Engine</strong>(models.Model):
    ...
    <strong class="bold">vehicle_model = models.ForeignKey(</strong>
        <strong class="bold">VehicleModel,</strong>
        <strong class="bold">on_delete = models.CASCADE,</strong>
        verbose_name = 'Model',
        <strong class="bold">related_name = 'model_engine',</strong>
        blank = True,
        null = True,
    )</pre></li>
				<li>Now, run your Django migration commands one more time, as discussed in the subsection titled <em class="italic">Building initial table structures</em> in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. You can see the two fields that we created, <code>vehicle_model</code> and <code>engine</code>, are now in the list of columns shown in our database management tool:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_3.2_B17243.jpg" alt="Figure 3.2 – PgAdmin – ForeignKey field&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – PgAdmin – ForeignKey field</p>
			<p>In the preceding<a id="_idIndexMarker393"/> screenshot, these fields <a id="_idIndexMarker394"/>are shown as <code>vehicle_model_id</code> and <code>engine_id</code>. The <code>_id</code> suffix automatically gets added to the column name in your database.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor087"/>Field type – ManyToManyField</h2>
			<p>Here, we will<a id="_idIndexMarker395"/> represent a <em class="italic">many-to-many</em> field relationship<a id="_idIndexMarker396"/> between a seller and the vehicles they are selling with a <code>ManyToManyField</code> type. <code>ManyToManyField</code> will not accept the <code>on_delete</code> argument. Instead, when a child or parent is deleted, the other will always remain in your database since many other objects could relate to it as well. </p>
			<p>Follow these steps to create <code>ManyToManyField</code>:</p>
			<ol>
				<li value="1">In your <code>/chapter_3/models.py</code> file, create a new <code>Seller</code> model class with a <code>name</code> field and a <code>vehicle</code> field to use as your <em class="italic">many-to-many</em> relationship. Your code should now resemble the following example:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">Seller</strong>(models.Model):
    <strong class="bold">name = models.CharField(</strong>
        verbose_name = 'Seller Name',
        max_length = 150,
        blank = True,
        null = True,
    )
    <strong class="bold">vehicle = models.ManyToManyField(</strong>
        <strong class="bold">Vehicle,</strong>
        verbose_name = 'Vehicles',
        <strong class="bold">related_name = 'vehicle_sellers',</strong>
        <strong class="bold">related_query_name = 'vehicle_seller',</strong>
        blank = True,
    )</pre></li>
			</ol>
			<p>We will link <code>ManyToManyField</code> to the <code>Vehicle</code> model class in the first positional argument. It's given a <code>related_name</code> argument<a id="_idIndexMarker397"/> with a value of <code>vehicle_sellers</code> and a <code>related_query_name</code> argument with a value of <code>vehicle_seller</code>. These two arguments<a id="_idIndexMarker398"/> are used for linking and mapping to this field later on in <a href="B17243_10_ePub.xhtml#_idTextAnchor293"><em class="italic">Chapter 10</em></a>, <em class="italic">Database Management</em>.</p>
			<ol>
				<li value="2">Go ahead and run your Django migration commands one more time. You should see the columns that were created for this table in your database management tool, similar to the following screenshot: </li>
			</ol>
			<div><div><img src="img/Figure_3.3_B17243.jpg" alt="Figure 3.3 – pgAdmin – ManyToManyField&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – pgAdmin – ManyToManyField</p>
			<p>We should also see any additional<a id="_idIndexMarker399"/> tables that automatically get created, which<a id="_idIndexMarker400"/> are used to manage the relationships between <code>Seller</code> and <code>Vehicle</code>. That table is shown in the preceding screenshot as <strong class="bold">chapter_3_seller_vehicle</strong>. </p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor088"/>Mutable versus immutable objects</h2>
			<p><strong class="bold">Mutability</strong> is a fundamental concept of the Python<a id="_idIndexMarker401"/> language and is broken down<a id="_idIndexMarker402"/> into mutable and immutable<a id="_idIndexMarker403"/> objects. An object is said to be <strong class="bold">mutable</strong> if its values can change over time. If an object's value will not change, then that object is said to be <strong class="bold">immutable</strong>. In Python, an object's mutability is also defined by the data type that it is. For example, mutable objects are represented using a <em class="italic">list</em>, <em class="italic">dictionary</em>, <em class="italic">set</em>, or <em class="italic">QuerySet</em>. Immutable objects are defined by using the <em class="italic">bool</em>, <em class="italic">decimal</em>, <em class="italic">float</em>, <em class="italic">int</em>, <em class="italic">range</em>, <em class="italic">string</em>, and <em class="italic">tuple</em> data types. Queries will perform better if the object being searched is immutable rather than mutable. Most of the time, the difference is miniscule, literally in nano-or milliseconds. When your project goes live and your database starts to collect thousands, if not millions, of records, the time it takes to query something will then be noticed when it takes seconds, if not minutes or tens of minutes, to complete a single query.</p>
			<p>For example, we could represent<a id="_idIndexMarker404"/> a set of choices as a <code>PositiveIntegerField</code> using a tuple object to associate<a id="_idIndexMarker405"/> a human-readable string representation<a id="_idIndexMarker406"/> to a numeric integer value. Take the make/manufacturer of a vehicle that was mentioned earlier in this chapter. We don't really need a table to store this information unless we have other related information that needs to be stored or have a project requirement stating that the user should have the ability to add/edit these choices.</p>
			<p>Hardcoding these values as an immutable data type can be done by following these steps: </p>
			<ol>
				<li value="1">In the <code>/chapter_3/models.py</code> file, add the following set above your model classes and below your <code>import</code> statements:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
<strong class="bold">MAKE_CHOICES</strong> = (
    (1, 'Buick'),
    (2, 'Cadillac'),
    (3, 'Chevrolet'),
    ...
)</pre></li>
				<li>Use that set as the value of the <code>choices</code> argument of your <code>make</code> field within your <code>Vehicle</code> class, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">Vehicle</strong>(models.Model):
    ...
    <strong class="bold">make = models.PositiveIntegerField(</strong>
        <strong class="bold">choices = MAKE_CHOICES,</strong>
        verbose_name = 'Vehicle Make/Brand',
        blank = True,
        null = True,
    )</pre></li>
			</ol>
			<p>Next, let's discuss what the <code>Meta</code> subclass<a id="_idIndexMarker407"/> is and how it is used<a id="_idIndexMarker408"/> to control the behavior of models<a id="_idIndexMarker409"/> even more than what we have already done.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor089"/>Using the Meta subclass</h1>
			<p><code>Meta</code>. It is not required and <a id="_idIndexMarker411"/>completely optional but it does make using Django much more useful when it is included in your models. Metadata provides all of the "other" information that is not defined in model field arguments. The settings<a id="_idIndexMarker412"/> that are defined inside this class are called <strong class="bold">meta options,</strong> and there are quite a lot to choose from. We will go over only some of the most commonly used options in the following sections and how they can be helpful. A complete breakdown of all of the options<a id="_idIndexMarker413"/> is available here: <a href="https://docs.djangoproject.com/en/4.0/ref/models/options/">https://docs.djangoproject.com/en/4.0/ref/models/options/</a>. </p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor090"/>Meta options – verbose_name and verbose_name_plural</h2>
			<p>We can use the <code>verbose_name</code> and <code>verbose_name_plural</code> options to specify what human-readable<a id="_idIndexMarker414"/> text is used in areas<a id="_idIndexMarker415"/> of the Django admin site or if we look it up later in the code that we write. We will introduce<a id="_idIndexMarker416"/> the Django admin<a id="_idIndexMarker417"/> site in <a href="B17243_06_ePub.xhtml#_idTextAnchor190"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring the Django Admin Site</em>. </p>
			<p>To add these options to your model classes, using the class named <code>VehicleModel</code>, set these two verbose options to read as <code>Vehicle Model</code> and <code>Vehicle Models</code>, as depicted:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> </pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">VehicleModel</strong>(models.Model):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    class <strong class="bold">Meta</strong>:</pre>
			<pre class="source-code">        <strong class="bold">verbose_name</strong> = 'Vehicle Model'</pre>
			<pre class="source-code">        <strong class="bold">verbose_name_plural</strong> = 'Vehicle Models'</pre>
			<p>Now, throughout your code and the Django admin site, these values will be used as the singular and plural representations of your object(s).</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor091"/>Meta option – ordering</h2>
			<p>The <code>ordering</code> option is used when obtaining<a id="_idIndexMarker418"/> a list of objects. This setting will accept<a id="_idIndexMarker419"/> one or many fields as a parameter to order by default if no other ordering rules have been specified when the query is performed. It will order in ascending order unless a dash (<code>–</code>) character has been placed before the value; if a dash is used, then the results will appear in descending order instead. </p>
			<p>To add this option to your model classes, we can order the <code>VehicleModel</code> class by <code>name</code> in ascending order, and then again in descending order, as shown in the following code:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> </pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">VehicleModel</strong>(models.Model):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    class <strong class="bold">Meta</strong>:</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        #<strong class="bold">ordering</strong> = ['<strong class="bold">name</strong>', '<strong class="bold">secondary_field</strong>',]</pre>
			<pre class="source-code">        <strong class="bold">ordering</strong> = ['<strong class="bold">-</strong>name']</pre>
			<p>The first example, commented<a id="_idIndexMarker420"/> out in the previous code block, shows us that we can order by additional<a id="_idIndexMarker421"/> fields, separated by a comma as well as in ascending order. The last example in the preceding code block depicts ordering the results in descending order alphabetically, from Z to A.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor092"/>Meta option – indexes</h2>
			<p>The <code>indexes</code> option relates<a id="_idIndexMarker422"/> to a standard data<a id="_idIndexMarker423"/> architecture concept called <code>indexes</code> meta option. </p>
			<p>Follow these steps to add this option to your model classes:</p>
			<ol>
				<li value="1">To index the name field on the <code>VehicleModel</code> class, it would be written as shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
<strong class="bold">from django.db.models.functions import Lower</strong>
...
class <strong class="bold">VehicleModel</strong>(models.Model):
    ...
    class <strong class="bold">Meta</strong>:
        ...
        <strong class="bold">indexes</strong> = [
            <strong class="bold">models.Index(fields=['name']),</strong>
            models.Index(
                fields = ['<strong class="bold">-name</strong>'], 
                name = 'desc_name_idx'
            ),
            models.Index(
                Lower('name').desc(), 
                <strong class="bold">name = 'lower_name_idx'</strong>
            )
        ]</pre></li>
			</ol>
			<p>The preceding example creates<a id="_idIndexMarker425"/> three separate indexes, one for the name<a id="_idIndexMarker426"/> in ascending order, one in descending order, and another for lowercase-only names in ascending order. </p>
			<ol>
				<li value="2">Next, run your Django migration commands one more time. In your command-line or terminal window, the following messages should appear:<pre><strong class="bold">    - Create index chapter_3_v_name_055414_idx on field(s) name of model vehiclemodel</strong>
<strong class="bold">    - Create index desc_name_idx on field(s) -name of model vehiclemodel</strong>
<strong class="bold">    - Create index lower_name_idx on OrderBy(Lower(F(name)), descending=True) on model vehiclemodel</strong></pre></li>
			</ol>
			<p>If we don't specify a <code>name=</code> attribute, as was not done in the first index of the preceding example, Django will name it using its default naming convention instead. This is what resulted in the name <code>chapter_3_v_name_055414_idx</code> for the first index message in the preceding example. The preceding example imports a class from the <code>django.db.models.functions</code> library, called <code>Lower</code>. The <code>Lower</code> class allows us to create an index on all of the lowercase character representations for the <code>name</code> field in the last index in the previous code block. There are<a id="_idIndexMarker427"/> numerous database functions that Django provides, and a complete breakdown<a id="_idIndexMarker428"/> of these functions can be found in the official Django documentation here: <a href="https://docs.djangoproject.com/en/4.0/ref/models/database-functions/">https://docs.djangoproject.com/en/4.0/ref/models/database-functions/</a>.</p>
			<p>The indexes for each table<a id="_idIndexMarker429"/> are usually shown within a database management tool. For example, in PgAdmin, navigate the data tree from within the <strong class="bold">Browser</strong> tab to find the <strong class="bold">chapter_3_vehiclemodel</strong> indexes. It is a very deep navigation: go to <strong class="bold">PostgreSQL 13</strong> | <strong class="bold">Databases</strong> | <strong class="bold">local_postgresql</strong> | <strong class="bold">Schemas</strong> | <strong class="bold">public</strong> | <strong class="bold">Tables</strong> | <strong class="bold">chapter_3_vehiclemodel</strong> | <strong class="bold">Indexes</strong> and you should see your indexes, as shown in the following screenshot:</p>
			<p class="figure-caption">  </p>
			<div><div><img src="img/Figure_3.4_B17243.jpg" alt="Figure 3.4 – PgAdmin – model indexes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – PgAdmin – model indexes</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor093"/>Meta option – db_table</h2>
			<p>Sometimes, a project might<a id="_idIndexMarker430"/> have so many models that they start to conflict with each other or it just becomes<a id="_idIndexMarker431"/> too confusing to manage. The <code>db_table</code> option is used to specify the name of the table in a database. If this option is not set, by default Django will name your tables using the <code>{{ app_name }}_{{ model_name }}</code> naming convention. We can use this option to specify a unique table name on a case-by-case basis that differs from the default naming convention.</p>
			<p>For example, let's create a new class named <code>engine2</code>, in lowercase this time. This way, we know that the lowercase classes are meant for side practice, separate from the main classes, which will be named with the first letter capitalized. Here, we will add the number <code>RuntimeError</code>, which was mentioned earlier in this chapter, in the <em class="italic">Writing model classes</em> section.</p>
			<p>Follow these steps<a id="_idIndexMarker432"/> to add this option to your model classes:</p>
			<ol>
				<li value="1">In the <code>/chapter_3/models.py</code> file, create the <code>engine2</code> class and copy the name field from the <code>Engine</code> class into it, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">engine2</strong>(models.Model):
    <strong class="bold">name</strong> = models.CharField(
        verbose_name = 'Engine',
        max_length = 75,
        blank = True,
        null = True,
    )</pre></li>
				<li>Create the <code>Meta</code> subclass and set the <code>db_table</code> option as depicted here. Do not use this option on the <code>Engine</code> class:<pre><strong class="bold"># /becoming_a_django_entdev/chap<a id="_idTextAnchor094"/>ter_3/models.py</strong> 
...
class <strong class="bold">engine2</strong>(models.Model):
    ...
    class <strong class="bold">Meta</strong>:
        db_table = '<strong class="bold">chapter_3_practice_engine</strong>'</pre></li>
			</ol>
			<p>Set the value of <code>db_table</code> to <code>'chapter_3_practice_engine'</code>, as shown.</p>
			<ol>
				<li value="3">Next, run your Django migration<a id="_idIndexMarker433"/> commands one more time. In your database management tool, such as PgAdmin, the <code>chapter_3</code> tables should look similar to the following: </li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_3.5_B17243.jpg" alt="Figure 3.5 – PgAdmin – db_table option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – PgAdmin – db_table option</p>
			<p>We can see the <code>engine2</code> model class. Another valuable meta <a id="_idIndexMarker434"/>option that you may find yourself using a lot is the abstract option. This is primarily used for extending model classes and is best explained later in the section titled <em class="italic">Extending models</em> of this chapter.</p>
			<p>Before we extend model classes, let's explore using model methods and method decorators.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor095"/>Customizing models</h1>
			<p>Model methods are custom functions<a id="_idIndexMarker435"/> written within a model class that provide added<a id="_idIndexMarker436"/> functionality related to a single record within a table. They let us create<a id="_idIndexMarker437"/> our own business logic and format field data<a id="_idIndexMarker438"/> as we need to. Django provides us with several default methods and we can also write our own custom methods. Custom methods can combine fields and return data derived from those two or more fields. Decorators are sometimes used in combination with model methods to provide even more functionality.</p>
			<p>Some methods can let us perform special operations when an object is saved and/or deleted at the database level. Other methods are used when queries are performed or when rendering an object within a template. We will discuss some of the methods that Django provides and then demonstrate<a id="_idIndexMarker439"/> their uses. For a complete breakdown of the full capabilities<a id="_idIndexMarker440"/> of using Django's model methods, visit their<a id="_idIndexMarker441"/> documentation, found here: <a href="https://docs.djangoproject.com/en/4.0/topics/db/models/#model-methods">https://docs.djangoproject.com/en/4.0/topics/db/models/#model-methods</a>. </p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor096"/>Writing methods</h2>
			<p>Writing a model method<a id="_idIndexMarker442"/> is similar to writing a <code>Meta</code> subclass, except instead of writing a class, we are now writing a function inside that class using the <code>def</code> keyword.</p>
			<p>The four most helpful and most used methods are defined here:</p>
			<ul>
				<li><code>def save(self, *args, **kwargs)</code> – used to override the save action of this model at the database level. You can inject your own logic either before or after the save has occurred by tapping into this method.</li>
				<li><code>def delete(self, *args, **kwargs)</code> – this is similar to the <code>save</code> method, except that you can add your own logic before or after an object has been deleted at the database level.</li>
				<li><code>def get_absolute_url(self)</code> – used by Django to formulate a canonical URL for that object. This is used to redefine the default behavior of how Django creates a URL structure for these objects. This is also the URL used within the Django admin site to access this object.</li>
				<li><code>def __str__(self)</code> – used to redefine the default manner that Django will use to create a string representation of a single record within that table.</li>
			</ul>
			<p>We will use the <code>__str__()</code> method to demonstrate how to override a Django-provided method and access methods throughout the code of your project.</p>
			<h3>Model method – __str__</h3>
			<p>Using the same <code>MAKE_CHOICES</code> tuple that was created<a id="_idIndexMarker443"/> earlier, we will override the <code>__str__()</code> method to formulate a custom name for all <code>Vehicle</code> objects. The default string representation of a <code>Vehicle</code> object that we will define will use the following naming convention, <code>{{ vehicle make }} {{ vehicle model }}</code>, with a space in between. </p>
			<p>To configure this method in your <code>Vehicle</code> class, in your <code>/chapter_3/models.py</code> file, write the <code>__str__()</code> method, as depicted<a id="_idIndexMarker444"/> in the following code block, in your existing <code>Vehicle</code> model class:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> </pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">Vehicle</strong>(models.Model):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">def __str__(self):</strong></pre>
			<pre class="source-code">        MAKE_CHOICES_DICT = dict(MAKE_CHOICES)</pre>
			<pre class="source-code">        return MAKE_CHOICES_DICT[self.make] + ' ' + self.model.name</pre>
			<p>It's easy to see that model methods are just functions that take in an instance of itself, perform an operation of some kind on itself, and then return the transformed value. The value in the preceding example is a string, and for the <code>__str__()</code> method, it should always return a string, whereas other methods, including custom methods that you create, can return any other data type, such as an <em class="italic">integer</em>, <em class="italic">dictionary</em>, <em class="italic">QuerySet</em>, or <em class="italic">date/time</em> object, to name a few.</p>
			<p>Next, <a id="_idTextAnchor097"/>let's discuss writing our own custom model methods, one that Django does not provide for us.</p>
			<h3>Custom model method</h3>
			<p>A custom method would come<a id="_idIndexMarker445"/> in handy if say we want to display a more in-depth name than what the <code>__str__()</code> method already does for a model class. For example, let's include the engine type in addition to the information returned from the <code>__str__()</code> method. The naming convention will be <code>{{ vehicle make }} {{ vehicle model }} – {{ vehicle engine }}</code>, with the space and dash in between.</p>
			<p>To create your own model method on the <code>Vehicle</code> class, in your <code>/chapter_3/models.py</code> file, create a new method within your <code>Vehicle</code> model and call it <code>full_vehicle_name()</code>, as shown:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> </pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">Vehicle</strong>(models.Model):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">def full_vehicle_name(self):</strong></pre>
			<pre class="source-code">        <strong class="bold">return self.__str__() + ' - ' + self.engine.name</strong></pre>
			<p>The preceding example uses the same logic found in the <code>__str__()</code> method. We are just calling that method<a id="_idIndexMarker446"/> from within the custom method using the <code>self.__str__()</code> expression, instead of writing the same code in two different places. </p>
			<p>Next, we will apply a decorator around the newly created custom method, changing how we interact with this data.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor098"/>Decorators</h2>
			<p>A decorator is a standard Python<a id="_idIndexMarker447"/> design pattern that allows developers to extend the functionality of an object without permanently changing the behavior of that object. The concept of decorators can be applied to virtually any class or method that exists in a project. We will be applying this concept to the <code>full_vehicle_name()</code> method that we just created, to change it from a callable to now a meta property of that model.</p>
			<h3>Decorator – @property</h3>
			<p>A <code>@property</code> decorator <a id="_idIndexMarker448"/>allows us to write a method<a id="_idIndexMarker449"/> to act as a regular property of a model instance, rather than act as a function. Using this decorator, we can access <code>full_vehicle_name</code> just like we would any other field found in that table. The only thing we cannot do is save data as we would for any other field, because that property is not technically its own column in that table to store data in.</p>
			<p>With no <code>@property</code> decorator present, data would be accessed similar to the following demonstration:</p>
			<pre>&gt;&gt;&gt; print(my_object.my_custom_method())</pre>
			<p>With the <code>@property</code> decorator present, the <code>print</code> statement would be written similar to the following<a id="_idIndexMarker450"/> demonstration:</p>
			<pre>&gt;&gt;&gt; print(my_object.my_custom_method)</pre>
			<p>To wrap your method in a <code>@property</code> decorator, in your <code>/chapter_3/models.py</code> file, within the <code>Vehicle</code> model class, create a new method called <code>fullname()</code>, as depicted here:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> </pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">Vehicle</strong>(models.Model):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">@property</strong></pre>
			<pre class="source-code">    <strong class="bold">def fullname(self):</strong></pre>
			<pre class="source-code">        return self.__str__() + ' - ' + self.engine.name</pre>
			<p>The preceding example will perform the same task as the <code>full_vehicle_name()</code> method except with the <code>@property</code> decorator applied. When we perform query operations later, in the section titled <em class="italic">Performing queries</em>, we will compare the difference between the two methods to see how that data is returned and used. </p>
			<p>Now that we have discussed most of the core concepts of what makes up a Django model, let's practice extending<a id="_idIndexMarker451"/> these models in an effort to keep to a <strong class="bold">Don't Repeat Yourself</strong> (<strong class="bold">DRY</strong>) style of writing.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor099"/>Extending models</h1>
			<p><code>User</code> model, which is a very common model to extend. </p>
			<p>Next, we will practice extending our practice model called <code>engine2</code> and then extend the Django <code>User</code> model, turning it into the <code>Seller</code> model. This would make the <code>Seller</code> object related to a <code>Vehicle</code> and also act as a <code>User</code>, provided with permission-based roles<a id="_idIndexMarker454"/> and permission group capabilities.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor100"/>Extending basic model classes</h2>
			<p>Extending regular model classes<a id="_idIndexMarker455"/> is pretty easy to do. Follow these steps to extend the <code>engine2</code> practice class:</p>
			<ol>
				<li value="1">In your <code>/chapter_3/models.py</code> file, in the class named <code>engine2</code>, keep the name field as is and then add a new field called <code>vehicle_model</code>, with the <code>related_name</code> attribute value that is depicted in the following code block: <pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">engine2</strong>(models.Model):
    name = models.CharField(...)
    <strong class="bold">vehicle_model = models.ForeignKey(</strong>
        VehicleModel,
        on_delete = models.CASCADE,
        verbose_name = 'Model',
        <strong class="bold">related_name = 'model_engine2',</strong>
        blank = True,
        null = True,
    )</pre></li>
				<li>Make sure your <code>engine2</code> class has the following <code>Meta</code> class options:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">engine2</strong>(models.Model):
    class <strong class="bold">Meta</strong>:
        <strong class="bold">abstract = True</strong>
        db_table = '<strong class="bold">chapter_3_practice_engine</strong>'
        ordering = ['name',]
        verbose_name = 'Practice Engine'
        verbose_name_plural = 'Practice Engines'</pre></li>
			</ol>
			<p>We basically want <code>engine2</code> to resemble the <code>Engine</code> class exactly, except that we want to keep the original class<a id="_idIndexMarker456"/> untouched and write a new class called <code>engine3</code> constructed from <code>engine2</code>. We also have to give the <code>vehicle_model</code> field in the <code>engine2</code> class a new and unique value for the <code>related_name</code> argument. Otherwise, when we run the Django migration commands, we will experience conflicting errors with the <code>Engine</code> class. In the <code>engine2</code> class, specify the <code>abstract = True</code> option as we did in the preceding example. That option allows us to use that class as a parent class.</p>
			<ol>
				<li value="3">Now, create a new class called <code>engine3</code> below your <code>engine2</code> class, as depicted in the following code block:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">engine3</strong>(<strong class="bold">engine2</strong>):
    <strong class="bold">other_name = models.CharField(</strong>
        verbose_name = 'Other Engine Name',
        max_length = 75,
        blank = True,
        null = True,
    )</pre></li>
			</ol>
			<p>In the <code>engine3</code> class shown here, we are not creating a <code>Meta</code> subclass and we will only give it one field. We also replaced <code>models.Model</code> with <code>engine2</code>. That is where we pass in the name of the class that we want to construct the new class from, otherwise known as extending or inheriting from that parent class.</p>
			<p>Running your Django migration<a id="_idIndexMarker457"/> commands now will result in an error, telling us that the <code>chapter_3_practice_engine</code> table already exists. To prevent this, we can do one of two things. We could rename the <code>Meta</code> class option <code>db_table</code> of the <code>engine2</code> class or we can drop all of the tables in the database and start fresh. </p>
			<h3>Dropping database tables</h3>
			<p>Since, currently, we do not have any real data<a id="_idIndexMarker458"/> to worry about and because we are so early in the development life cycle, it's okay to drop our tables. It is acceptable because we are still getting started with building the skeleton code of our project. We are also working with a local database, meaning we won't disrupt other developers' workflows by performing this task. Dropping your tables can be done using any database management tool. </p>
			<p>Follow these steps to drop your tables using PgAdmin:</p>
			<ol>
				<li value="1">In PgAdmin, navigate to <strong class="bold">Tools</strong> | <strong class="bold">Query Tool</strong>. </li>
				<li>In the tab that opens, enter the following two commands:<pre><strong class="bold"># In the Query Tool of the PgAdmin App</strong>
DROP SCHEMA public CASCADE;
CREATE SCHEMA public;</pre></li>
				<li>Execute these commands by hitting the <strong class="bold">Execute/Refresh</strong> button or pressing <em class="italic">F5</em> on your keyboard.</li>
				<li>You will also need to delete all migration files found in any migrations folder, such as the <code>/chapter_3/migrations/</code> and <code>/chapter_3/migrations/__pycache__/</code> folders. <p class="callout-heading">Note</p><p class="callout">Every time tables are dropped, data is lost. The next time the Django migration commands are executed, the <code>createsuperuser</code> command should be executed and/or data fixtures loaded.</p></li>
				<li>Execute your Django<a id="_idIndexMarker459"/> migration commands one more time. The following screenshot shows that all of the fields and <code>Meta</code> class options that existed before in the <code>engine2</code> class now exist in the <code>engine3</code> class even though we did not write them for the <code>engine3</code> class:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_3.6_B17243.jpg" alt="Figure 3.6 – PgAdmin – extended engine&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – PgAdmin – extended engine</p>
			<p>We can see this because the <code>Meta</code> class <code>db_table = 'chapter_3_practice_engine'</code> option is placed in the <code>engine2</code> class and is what the <code>engine3</code> table is named. No table was created for the <code>engine2</code> class because it is configured as an abstract class. We also see that the two fields, <code>name</code> and <code>vehicle_model</code>, from the <code>engine2</code> class also get applied to the <code>engine3</code> class.</p>
			<p>Let's extend the built-in Django <code>User</code> class next.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor101"/>Extending the Django User model</h2>
			<p>Extending the Django <code>User</code> model <a id="_idIndexMarker460"/>will transform the <code>Seller</code> model, making it act as a <code>User</code> in the system. This means you can create a user profile that will have fields that do not come standard with Django; it will have fields that we create. This is done by constructing the <code>Seller</code> class using the <code>AbstractUser</code> or <code>AbstractBaseUser</code> class as the parent class. </p>
			<p>Follow these steps to extend your <code>User</code> class:</p>
			<ol>
				<li value="1">In your <code>/chapter_3/models.py</code> file, in the <code>Seller</code> class, replace <code>models.Model</code> with the <code>AbstractUser</code> parent class and include the <code>import</code> statement shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
<strong class="bold">from django.contrib.auth.models import AbstractUser</strong>
...
class <strong class="bold">Seller</strong>(<strong class="bold">AbstractUser</strong>):
    ...</pre></li>
			</ol>
			<p>An <code>AbstractUser</code> class will allow us to keep all of the original fields that exist in the <code>User</code> model. If we want to create a brand-new <code>User</code> model from scratch, use the <code>AbstractBaseUser</code> parent class instead. </p>
			<ol>
				<li value="2">We also need to adjust the value of the <code>AUTH_USER_MODEL</code> variable in the <code>settings.py</code> file, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
...
AUTH_USER_MODEL = '<strong class="bold">chapter_3.Seller</strong>'</pre></li>
			</ol>
			<p>Use the <code>app_name.model_name</code> naming convention, paying attention to model class letter casing. Without adjusting this value, we will get a <code>User</code> model for this project; instead, the <code>Seller</code> model will be used.</p>
			<ol>
				<li value="3">If we try to run the Django migration commands now, Django will ask us to assign a default value to the username and password fields. Since a username field needs to be unique, we can't just set a default value for this object easily because that will result in duplicate usernames. The reason this will happen is that we destroyed the previous <code>auth_user</code> tables in the database and created an entirely new set of relations for a <code>User</code>. Go ahead and drop your tables just like you did<a id="_idIndexMarker461"/> in the previous subsection, titled <em class="italic">Dropping database tables</em>. Now run the Django migrations commands. The following screenshot shows the <code>chapter_3_seller</code> table now has many other fields that we did not write: </li>
			</ol>
			<div><div><img src="img/Figure_3.7_B17243.jpg" alt="Figure 3.7 – PgAdmin – user model extension&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – PgAdmin – user model extension</p>
			<p>Now that we have covered the basics of writing and extending models, let's use the Django shell to perform queries. We can use the Django shell to see the results of queries without having to learn about rendering templates first, which<a id="_idIndexMarker462"/> is what all of <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, will cover.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor102"/>Using the Django shell</h1>
			<p>The <strong class="bold">Django shell</strong> is a powerful tool to add to any toolbox. It will activate<a id="_idIndexMarker463"/> the Python interactive interpreter and uses the Django database abstraction API to let us connect directly to the database(s) configured in a project. With this, we can write Python and perform queries directly from a terminal or command-line window.</p>
			<p>To activate the Django shell, follow these steps:</p>
			<ol>
				<li value="1">Open your terminal or command-line window and navigate to the root of your project. Make sure your virtual environment has been activated and then execute the following command:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py shell</strong></pre></li>
				<li>You should see it print out the following information about the <code>InteractiveConsole</code> that was launched:<pre><strong class="bold">Python 3.7.8 (tags/v3.7.8:4b47a5b6ba, Jun 28 2020, 08:53:46) [MSC v.1916 64 bit (AMD64)] on win32</strong>
<strong class="bold">Type "help", "copyright", "credits" or "license" for more information.</strong>
<strong class="bold">(InteractiveConsole)</strong>
<strong class="bold">&gt;&gt;&gt;</strong></pre></li>
				<li>Your console will now display three right-angle brackets, where you can begin writing and executing Python code one line at a time. Theoretically, you could input an entire script this way, but it will not be saved anywhere, and your code will be lost when the window is closed or the <code>InteractiveConsole</code> is terminated. </li>
			</ol>
			<p>Now that this shell is activated, let's add sample data and perform a few queries to observe how it behaves.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor103"/>Running basic Python scripts</h2>
			<p>Earlier in this chapter, in the subsection<a id="_idIndexMarker464"/> titled <em class="italic">Mutable versus immutable objects</em>, it was mentioned<a id="_idIndexMarker465"/> that a Python string is one of the immutable data types that exist. An immutable string is one that cannot be reassigned a character at a particular index of that string after it has been created. This means that what is allowed is reassigning the value to that string altogether, and what is not allowed is changing the value of a character at a particular index. This is a basic fundamental of Python, and those who are new to Python can find this to be confusing. In this next example, we will demonstrate how to use the Django shell and at the same time demonstrate what makes a string immutable:</p>
			<ol>
				<li value="1">Launch the Python interactive interpreter by running the following Django shell command:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py shell </strong></pre></li>
				<li>Assign a new variable called <code>myvar</code> and give it an initial value of <code>my_string</code>, as shown:<pre><strong class="bold">&gt;&gt;&gt; myvar = 'my_string'</strong>
<strong class="bold">&gt;&gt;&gt; myvar[2] = ''</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "&lt;console&gt;", line 1, in &lt;module&gt;</strong>
<strong class="bold">TypeError: 'str' object does not support item assignment</strong>
<strong class="bold">&gt;&gt;&gt;</strong></pre></li>
			</ol>
			<p>By executing the second statement shown in the previous code block, where we try to remove the underscore from the string at index <code>2</code>, we are receiving an error stating <code>TypeError: 'str' object does not support item assignment</code>. </p>
			<ol>
				<li value="3">If we just reassign the value of the <code>myvar</code> variable, as is done in the following code block, we will be able to remove the underscore this way:<pre><strong class="bold">&gt;&gt;&gt; myvar = 'my_string'</strong>
<strong class="bold">&gt;&gt;&gt; print(myvar)</strong>
<strong class="bold">my_string</strong>
<strong class="bold">&gt;&gt;&gt; myvar = 'mystring'</strong>
<strong class="bold">&gt;&gt;&gt; print(myvar)</strong>
<strong class="bold">mystring</strong>
<strong class="bold">&gt;&gt;&gt; </strong></pre></li>
			</ol>
			<p>In the preceding example, the first <code>print</code> statement returns <code>my_string</code> and then, after we change the value of <code>myvar</code>, the next <code>print</code> statement returns <code>mystring</code>. </p>
			<ol>
				<li value="4">We could use string<a id="_idIndexMarker466"/> indexes to look up characters<a id="_idIndexMarker467"/> and combine them but we cannot reassign a character at an index. The following example would remove the underscore by looking up characters at specified index ranges:<pre><strong class="bold">&gt;&gt;&gt; myvar = 'my_string'</strong>
<strong class="bold">&gt;&gt;&gt; print(myvar[0:2] + myvar[3:9])</strong>
<strong class="bold">mystring</strong>
<strong class="bold">&gt;&gt;&gt; </strong></pre></li>
				<li>Type <code>exit()</code> to quit using the interactive interpreter and return to using your <code>manage.py</code> commands:<pre><strong class="bold">&gt;&gt;&gt; exit()</strong></pre></li>
			</ol>
			<p>Now that we know how to execute basic Python scripts in the interactive interpreter, let's use this tool to generate a custom <code>SECRET_KEY</code> and set a project's <code>.env</code> file.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor104"/>Generating a SECRET_KEY variable</h2>
			<p>A <code>SECRET_KEY</code> variable<a id="_idIndexMarker468"/> in Django is used as a hash<a id="_idIndexMarker469"/> to secure things, such as your sessions, cookie storage, password tokenization, and all other methods of cryptographic signing that act to secure your site. Instead of using an online tool to generate this key, where the transmission either to or from that source could be compromised, you could generate your own using the Django shell. All we are doing is generating a random string. There is nothing special about this operation; you could technically use any combination of letters and numbers that you enter on a keyboard too. While this is not necessary since Django already generates a unique key for us when we create a new Django project, it is a useful step to allow us<a id="_idIndexMarker470"/> to create different keys to use on each of our Heroku<a id="_idIndexMarker471"/> environments. This way, we don't share the same <code>SECRET_KEY</code>.</p>
			<p>To generate your own <code>SECRET_KEY</code>, follow these steps:</p>
			<ol>
				<li value="1">Activate the Django shell in your terminal or command-line window and then import the method shown in the following code block:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py shell</strong>
<strong class="bold">&gt;&gt;&gt; from secret_key_generator import secret_key_generator</strong></pre></li>
			</ol>
			<p>The method shown here comes from the package called <code>secret_key_generator</code>, which we installed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>.</p>
			<ol>
				<li value="2">Next, execute the following <code>print</code> statement:<pre><strong class="bold">&gt;&gt;&gt; print(secret_key_generator.generate())</strong>
<strong class="bold">your_randomly_generated_key_printed_here</strong></pre></li>
				<li>Take the key that gets printed onscreen and use it to set or reset your environment variables. To reset your variables, just follow the same steps as were discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, under the subsection titled <em class="italic">Remote variables</em> and it will update your value with the new value.</li>
			</ol>
			<p>The preceding shell command also created for us a text file called <code>.secret.txt</code>, found in the root of your project, where your <code>manage.py</code> file is located. You can delete the <code>.sectret.txt</code> file as it is not needed.</p>
			<p>Now, let's use the Django <a id="_idIndexMarker472"/>shell to add data to our tables next, allowing us to use the Django<a id="_idIndexMarker473"/> shell to perform queries after that.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor105"/>Saving data</h2>
			<p>Creating and saving objects<a id="_idIndexMarker474"/> to your database using the Django shell is easy. After we have activated the Django shell, we need to import the models that we want to work with into memory just like when we import something at the top of any <code>.py</code> file. </p>
			<p>Follow these steps to create<a id="_idIndexMarker475"/> and save data using the Django shell:</p>
			<ol>
				<li value="1">Import your vehicle class objects using the <code>InteractiveConsole</code> window by executing the following commands:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py shell</strong>
<strong class="bold">&gt;&gt;&gt; from becoming_a_django_entdev.chapter_3.models import Engine, Seller, Vehicle, VehicleModel </strong></pre></li>
			</ol>
			<p>These objects will be available for you to use until that window is closed or the <code>exit()</code> command is executed. </p>
			<ol>
				<li value="2">While these objects are loaded, it only takes the two lines of code shown in the following code block to create a new object and then save it:<pre><strong class="bold">&gt;&gt;&gt; vehicle_model = VehicleModel(name = 'Enclave Avenir', make = 1)</strong>
<strong class="bold">&gt;&gt;&gt; vehicle_model.save()</strong></pre></li>
			</ol>
			<p>The preceding lines will create and then save a <code>VehicleModel</code> object with the name of <code>Enclave Avenir</code> into the <code>chapter_3_vehiclemodel</code> table. In the creation of the <code>vehicle_model</code> object previously, we provided values to all of the fields that exist for that class. The value of the <code>make</code> field uses the numeric value of the tuple that we created earlier, called <code>MAKE_CHOICES</code>. </p>
			<ol>
				<li value="3">However, if we try to create an <code>Engine</code> object using a numeric value for the <code>vehicle_model</code> field, then we will be given a <code>ValueError</code>, as shown:<pre><strong class="bold">&gt;&gt;&gt; engine = Engine(name = '3.6L DI DOHC 6cyl', vehicle_model = 1)</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  ...</strong>
<strong class="bold">ValueError: Cannot assign "1": "Engine.model" must be a "VehicleModel" instance.</strong></pre></li>
				<li>In order to successfully<a id="_idIndexMarker476"/> create an <code>Engine</code> object, we first have<a id="_idIndexMarker477"/> to create a <code>VehicleModel</code> object as we did for the <code>vehicle_model</code> temporary object in <em class="italic">step 2</em>. Then, use that variable to set as the value of the <code>model</code> field instead of using a numeric integer, as shown: <pre><strong class="bold">&gt;&gt;&gt; vehicle_model = VehicleModel(name = 'Enclave Avenir', make = 1)</strong>
<strong class="bold">&gt;&gt;&gt; vehicle_model.save()</strong>
<strong class="bold">&gt;&gt;&gt; engine = Engine(name = '3.6L DI DOHC 6cyl', vehicle_model = vehicle_model)</strong>
<strong class="bold">&gt;&gt;&gt; engine.save()</strong></pre></li>
			</ol>
			<p><em class="italic">Step 4</em> of the preceding example will likely result in an error due to us adding the <code>unique = True</code> argument to the <code>name</code> field of the <code>VehicleModel</code> class. This is also because we just created an object using the same name in <em class="italic">step 2</em>. You can get around that by providing a unique name or disregarding it and moving forward. This error was made intentionally for learning purposes. The error you receive should look like the one shown in the following code block, indicating that you have duplicate entries:</p>
			<pre>Traceback (most recent call last):
  File "C:\Projects\Packt_Publishing\Repo\becoming_a_django_entdev\virtual_env\lib\site-packages\django\db\backends\utils.py", line 84, in _execute
    return self.cursor.execute(sql, params)
psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "chapter_3_vehiclemodel_name_a94a4619_uniq"
DETAIL:  Key (name)=(Enclave Avenir) already exists.
...
The above exception was the direct cause of the following exception:
django.db.utils.IntegrityError: duplicate key value violates unique constraint "chapter_3_vehiclemodel_name_a94a4619_uniq"
DETAIL:  Key (name)=(Enclave Avenir) already exists.</pre>
			<p>To get around this, we need to use the <code>update_or_create()</code> method instead of the <code>save()</code> method.</p>
			<p>If we try to create and then save<a id="_idIndexMarker478"/> an engine with a <code>vehicle_model</code> field<a id="_idIndexMarker479"/> that has not been already saved to the database, we will get a <code>ValueError</code> informing us that there is an unsaved related object present. If you wish to see this, create the <code>vehicle_model</code> object using the following values. Then, use that object to assign as the value of the <code>vehicle_model</code> field on the <code>engine</code> object and try to save:</p>
			<pre>&gt;&gt;&gt; vehicle_model = VehicleModel(name = 'Blazer LT', make = 3)
&gt;&gt;&gt; engine = Engine(name = '4 Cylinders 4 2.0L DI Turbo DOHC 122 CID', vehicle_model = vehicle_model)
&gt;&gt;&gt; engine.save()
Traceback (most recent call last):
  ...
ValueError: save() prohibited to prevent data loss due to unsaved related object 'model'.</pre>
			<p>Once you try to save that <code>engine</code>, the error shown in the preceding code block would print to your screen, which is the reason why we need<a id="_idIndexMarker480"/> to save each related object before creating<a id="_idIndexMarker481"/> an object that they rely on.</p>
			<p>Let's discuss using the <code>update_or_create()</code> method next.</p>
			<h3>Model method – update_or_create()</h3>
			<p>We use the <code>update_or_create()</code> method instead<a id="_idIndexMarker482"/> of the <code>save()</code> method to create or modify an existing object. </p>
			<p>Follow these steps to use this method:</p>
			<ol>
				<li value="1">Make sure the Django shell is activated and then execute the following command:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py shell</strong>
<strong class="bold">&gt;&gt;&gt; vehicle_model, created = VehicleModel.objects.update_or_create(name = 'Enclave Avenir', make = 1, defaults={'name': 'Enclave Avenir', 'make': 1},)</strong></pre></li>
			</ol>
			<p>The preceding example should have been successful. If it was, then you received no errors, and you'll see the three right-angle brackets waiting for your next input command. </p>
			<ol>
				<li value="2">Using a database management tool such as PgAdmin, check to see that you have a <code>VehicleModel</code> record in your table with the name <code>Enclave Avenir</code>. The <code>defaults</code> argument in the preceding example is an optional argument that defines the values that you want to set if this operation creates a new record. Without it, the system will default to values set on your model fields instead.</li>
				<li>In this step, we will add a <code>Vehicle</code> to the database. It requires the use of a <code>Money</code> class to create a <code>Money</code> object. To use<a id="_idIndexMarker483"/> the <code>Money</code> class, execute the following <code>import</code> statement:<pre><strong class="bold">&gt;&gt;&gt; from djmoney.money import Money</strong></pre></li>
				<li>Now, execute the following three <code>update_or_create()</code> commands:<pre><strong class="bold">&gt;&gt;&gt; vehicle_model, model_created = VehicleModel.objects.update_or_create(name = 'Blazer LT', make = 3,)</strong>
<strong class="bold">&gt;&gt;&gt; engine, engine_created = Engine.objects.update_or_create(name = '3.9L DI DOHC 6cyl', vehicle_model = vehicle_model,)</strong>
<strong class="bold">&gt;&gt;&gt; vehicle, vehicle_created = Vehicle.objects.update_or_create(vin = 'aa123456789012345', sold = True, price = Money(10000, 'USD'), make = 3, vehicle_model = vehicle_model, engine = engine,)</strong></pre></li>
			</ol>
			<p>The commands in this subsection should have all resulted in success without errors.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If a vehicle with the same VIN as the one shown previously is already created for you by importing the data found in the <code>chapter_3</code> data fixture, then you can just change the <code>vin</code> value in the preceding example to a new and unique <code>vin</code> value. This allows you to witness a new record being added to your table when viewed in a database management tool such as PgAdmin.</p>
			<p>Let's discuss loading the <code>chapter_3</code> data fixture next.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor106"/>Loading the chapter_3 data fixture</h2>
			<p>Instead of providing<a id="_idIndexMarker484"/> steps on how to create all of the data<a id="_idIndexMarker485"/> that will be needed to demonstrate the exercises throughout the rest of this chapter and this book, we will be adding data from a data fixture. Adding data can be done in a much simpler way than how it was done from within the Django shell. We will discuss this concept in more depth and create our own fixtures later in <a href="B17243_10_ePub.xhtml#_idTextAnchor293"><em class="italic">Chapter 10</em></a>, <em class="italic">Database Management</em>. For now, make sure the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_3/fixtures/</code> folder and all of the files found in this folder from the code of this book are copied into your <code>/chapter_3/</code> app folder. The <code>chapter_3</code> fixture will provide enough data for us to work with the remaining examples of this chapter. </p>
			<p>To load your data fixture make sure you have exited your Django shell and that your virtual environment is active and then execute the following command:</p>
			<pre>(virtual_env) PS &gt; python3 manage.py loaddata chapter_3</pre>
			<p>If you have issues with importing this fixture, double-check that your table structures match the structures of the models provided with the code of this book in the <code>chapter_3</code> app.</p>
			<p>The alternative would be to follow the steps in the <em class="italic">Saving data</em> subsection of this chapter to add your own sample data one painstaking item at a time. Create and save as many objects<a id="_idIndexMarker486"/> as you would like using those examples. If you were<a id="_idIndexMarker487"/> to create a <code>Vehicle</code> object, it would be done in the same way as creating an <code>Engine</code> object, except now you are defining the values of two related objects instead of one in order to save successfully. We just need to have a few objects to play around with in the next exercises of this chapter. </p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor107"/>Performing queries</h1>
			<p>Performing queries<a id="_idIndexMarker488"/> using the Django shell will give us some insight into how queries work. In the following subsections, we will discuss some common methods that a<a id="_idTextAnchor108"/>re used.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor109"/>Model method – all()</h2>
			<p>The <code>all()</code> method returns<a id="_idIndexMarker489"/> all records found in the table for that model <a id="_idIndexMarker490"/>object. This method will return a QuerySet in the following format, representing all entries that it finds:</p>
			<pre>(virtual_env) PS &gt; python3 manage.py shell
&gt;&gt;&gt; from becoming_a_django_entdev.chapter_3.models import Engine, Seller, Vehicle, VehicleModel 
&gt;&gt;&gt; VehicleModel.objects.all()
&lt;QuerySet [&lt;VehicleModel: Blazer LT&gt;, &lt;VehicleModel: Enclave Avenir&gt;, &lt;VehicleModel: Envision Avenir&gt;]&gt; </pre>
			<p>The <code>chapter_3</code> data fixture only provides three VehicleModel and that is why a collection of only three objects is returned to us. Your results may vary. One of the reasons why we created a <code>__str__()</code> method, as was done earlier in this chapter, in the subsection titled <em class="italic">Model method – __str__</em>, is so that it could be represented in a logical way in code usage such as this, where the object name that gets printed out is a name that makes sense to us and not something that won't make sense. Without the <code>__str__()</code> method defined in the <code>VehicleModel</code> class, the QuerySet would have been returned to us in a manner that looks like the following example:</p>
			<pre>&lt;QuerySet [&lt;VehicleModel: VehicleModel object (3)&gt;, &lt;VehicleModel: VehicleModel object (2)&gt;, &lt;VehicleModel: VehicleModel object (1)&gt;]&gt;</pre>
			<p>We would have no way to distinguish<a id="_idIndexMarker491"/> which object is which and what order they are in just<a id="_idIndexMarker492"/> by looking at the collection printed in this code block.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor110"/>Model method – get()</h2>
			<p>The <code>get()</code> method is used<a id="_idIndexMarker493"/> to target a specific<a id="_idIndexMarker494"/> database record. </p>
			<p>Follow these steps to see this method in action:</p>
			<ol>
				<li value="1">Use <code>get()</code> to target the <code>vin</code> value of a vehicle when performing a query, as is done here:<pre><strong class="bold">&gt;&gt;&gt; vehicle = Vehicle.objects.get(vin = 'aa123456789012345')</strong>
<strong class="bold">&gt;&gt;&gt; print(vehicle)</strong>
<strong class="bold">Chevrolet Blazer LT</strong></pre></li>
				<li>Using the single object that was returned to us, run the <code>print</code> statement again using the <code>full_vehicle_name()</code> method that we created earlier, to see the difference in the results that are generated:<pre><strong class="bold">&gt;&gt;&gt; print(vehicle.full_vehicle_name())</strong>
<strong class="bold">Chevrolet Blazer LT - 3.6L DI DOHC 6cyl</strong></pre></li>
				<li>Next, use the other <code>fullname</code> method with the <code>@property</code> decorator to return the exact same results:<pre><strong class="bold">&gt;&gt;&gt; print(vehicle.fullname)</strong>
<strong class="bold">Chevrolet Blazer LT - 3.6L DI DOHC 6cyl</strong></pre></li>
			</ol>
			<p>Django is using the format that we defined earlier in the <code>__str__</code> method to generate a string that gets printed to the screen in <em class="italic">step 1</em>. We already know that the <code>vin</code> field is set to <code>unique = True</code>, meaning there will never be two objects with the same <code>vin</code> value in the database, so we know that it is safe to use the <code>get()</code> method in all the preceding steps. If there<a id="_idIndexMarker495"/> are numerous items with the same value and a <code>get()</code> method<a id="_idIndexMarker496"/> is used, then you will need to use a <code>filter()</code> method instead.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor111"/>Model method – filter()</h2>
			<p>The <code>filter()</code> method is used to look up records<a id="_idIndexMarker497"/> in a database<a id="_idIndexMarker498"/> that may have the same field values. This method will return a collection of results instead of a single result. The collection will be returned to us as a <code>QuerySet</code>. For example, we can filter the <code>VehicleModel</code> table, which we already know contains three rows. </p>
			<p>The following example will filter the <code>make</code> field by the value of <code>Buick</code>, to return a collection of only two objects instead of three:</p>
			<pre> &gt;&gt;&gt; print(VehicleModel.objects.filter(make = 1))
&lt;QuerySet [&lt;VehicleModel: Enclave Avenir&gt;, &lt;VehicleModel: Envision Avenir&gt;]&gt;</pre>
			<p>Queries can get much more complex than using a simple <code>all()</code>, <code>get()</code>, or <code>filter()</code> method. Q objects provide more complicated queries as well. For a complete breakdown of how to use Q objects<a id="_idIndexMarker499"/> in Django, visit the documentation here: https://docs.djangoproject.com/en/4.0/ref/models/querysets/#q-objects. </p>
			<p>We can even obtain a summary of objects using arithmetic functions, which brings us to our nex<a id="_idIndexMarker500"/>t subsection, discussing<a id="_idIndexMarker501"/> aggregates.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor112"/>Aggregates</h2>
			<p>Django provides an easy way to generate<a id="_idIndexMarker502"/> a summary of a collection of objects, known as <strong class="bold">aggregates</strong>. What this means is that<a id="_idIndexMarker503"/> we can perform a query and use any one of the many <strong class="bold">aggregation functions</strong> that Django provides. This can be used to generate<a id="_idIndexMarker504"/> an average price for all the vehicles, generate an average price of just the sold vehicles, or generate a total count of vehicles for a particular seller. While there is a lot of information regarding the topic of aggregates and annotates, we will discuss some basic usages. A complete guide<a id="_idIndexMarker505"/> to generating aggregates in Django can be found here: <a href="https://docs.djangoproject.com/en/4.0/ref/models/querysets/#aggregation-functions">https://docs.djangoproject.com/en/4.0/ref/models/querysets/#aggregation-functions</a>.</p>
			<h3>Model method – aggregate()</h3>
			<p>Aggregates are used to generate a summary<a id="_idIndexMarker506"/> of every object in a QuerySet. To get an average<a id="_idIndexMarker507"/> price of every vehicle that exists in that table, we can use the <code>Avg</code> aggregate function. The argument that we pass into the <code>Avg</code> function is the field that we want to perform this operation on. </p>
			<p>Follow these steps to practice using aggregates:</p>
			<ol>
				<li value="1">Import your <code>Vehicle</code> model and the <code>Avg</code> class objects, as shown:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py shell</strong>
<strong class="bold">&gt;&gt;&gt; from becoming_a_django_entdev.chapter_3.models import Vehicle</strong>
<strong class="bold">&gt;&gt;&gt; from django.db.models import Avg</strong></pre></li>
				<li>Perform a query lookup using the <code>all()</code> method combined with the <code>aggregate()</code> method, as shown:<pre><strong class="bold">&gt;&gt;&gt; vehicles = Vehicle.objects.all().aggregate(Avg('price'))</strong></pre></li>
				<li>Print your <code>vehicles</code> object:<pre><strong class="bold">&gt;&gt;&gt; print(vehicles)</strong>
<strong class="bold">{'price__avg': Decimal('16335.428571428571')}</strong></pre></li>
			</ol>
			<p>The summary is returned as a dictionary object. </p>
			<ol>
				<li value="4">You can get the value of the <code>price__avg</code> key by executing the following <code>print</code> statement:<pre><strong class="bold">&gt;&gt;&gt; print(vehicles['price__avg'])</strong>
<strong class="bold">16335.428571428571</strong></pre></li>
			</ol>
			<p>The result of the average is, of course, not actually formatted in any particular currency type yet. </p>
			<ol>
				<li value="5">We can format<a id="_idIndexMarker508"/> it in US dollars by applying the same <code>Money()</code> conversion<a id="_idIndexMarker509"/> that we did before when we created and then saved our first vehicle in the database, by executing the following commands: <pre><strong class="bold">&gt;&gt;&gt; from djmoney.money import Money</strong>
<strong class="bold">&gt;&gt;&gt; print(Money(vehicles['price__avg'], 'USD'))</strong>
<strong class="bold">$16,335.43</strong></pre></li>
			</ol>
			<p>Where we wrote <code>Vehicle.objects.all().aggregate()</code> in <em class="italic">step 2</em> previously, the <code>all()</code> method is redundant. The <code>aggregate()</code> method basically does the same thing as the <code>all()</code> method, meaning we could write our statement as follows and produce the same results:</p>
			<pre> &gt;&gt;&gt; vehicles = Vehicle.objects.aggregate(Avg('price'))</pre>
			<p>We can also replace the <code>all()</code> method with any of the standard query methods, such as <code>get()</code> or <code>filter()</code>, as depicted in the following example:</p>
			<pre>&gt;&gt;&gt; vehicles = Vehicle.objects.filter(sold=False).aggregate(Avg('price'))
&gt;&gt;&gt; print(Money(vehicles['price__avg'], 'USD'))
$18,419.60</pre>
			<p>Let's discuss<a id="_idIndexMarker510"/> annotations<a id="_idIndexMarker511"/> next.</p>
			<h3>Model method – annotate()</h3>
			<p>Annotations<a id="_idIndexMarker512"/> are used when we have<a id="_idIndexMarker513"/> objects that relate to other objects in a QuerySet and we want to generate a summary of every related object in that QuerySet. </p>
			<p>Follow these steps to practice using annotations:</p>
			<ol>
				<li value="1">Execute the following commands to provide a query of all sellers that exist in a table and then generate a count of only the sold vehicles that it finds:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py shell</strong>
<strong class="bold">&gt;&gt;&gt; from becoming_a_django_entdev.chapter_3.models import Seller, Vehicle</strong>
<strong class="bold">&gt;&gt;&gt; from django.db.models import Avg, Count</strong>
<strong class="bold">&gt;&gt;&gt; sellers = Seller.objects.filter(vehicles__sold=True).annotate(Count('vehicles'))</strong>
<strong class="bold">&gt;&gt;&gt; print(sellers[0].vehicles__count)</strong>
<strong class="bold">2</strong></pre></li>
				<li>Alter the preceding <code>filter</code> statement to count only the unsold vehicles, as shown:<pre><strong class="bold">&gt;&gt;&gt; sellers = Seller.objects.filter(vehicles__sold=False).annotate(Count('vehicles'))</strong>
<strong class="bold">&gt;&gt;&gt; print(sellers[0].vehicles__count)</strong>
<strong class="bold">5</strong></pre></li>
			</ol>
			<p>We need to specify the index at <code>sellers[0]</code> because a <code>filter()</code> method will always return a collection of objects, even if the query only results in one object. </p>
			<ol>
				<li value="3">Print the <code>sellers</code> collection to the screen, as shown:<pre><strong class="bold">&gt;&gt;&gt; print(sellers)</strong>
<strong class="bold">&lt;QuerySet [&lt;Seller: admin&gt;]&gt;</strong></pre></li>
			</ol>
			<p>We can see that there is only one <code>Seller</code> in the database at this time. We got the numbers <code>2</code> and then <code>5</code> as the results, for a total of seven vehicles that relate to that seller.</p>
			<p>Next, we will discuss<a id="_idIndexMarker514"/> model managers<a id="_idIndexMarker515"/> and how they can be used to perform advanced queries.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor113"/>Writing model managers</h1>
			<p>We now know that when we want<a id="_idIndexMarker516"/> to apply logic that pertains to a single object within a table, we will look into writing a model method. An advanced Django concept can allow us to add logic that would relate to the entire table of objects instead. That would be written using a <code>objects</code> manager, as in when we write a query statement such as <code>MyModel.objects.all()</code>. Since the <code>objects</code> manager is already created for us, there is technically no need for us to create a model manager at all. However, custom model managers can be used in a project to provide additional methods that the entire table uses. We will discuss a simple use of this concept that adds filters to a table. To learn more about how model managers can be used in more depth, visit<a id="_idIndexMarker517"/> the official Django documentation, found here: <a href="https://docs.djangoproject.com/en/4.0/topics/db/managers/">https://docs.djangoproject.com/en/4.0/topics/db/managers/</a>. </p>
			<p>Take the following steps to apply a filter, separating the vehicle objects by make/manufacturer. Here, we will write a manager for the <code>Buick</code> vehicles and another manager for the <code>Chevy</code> vehicles. In a large project, it would also be wise to place your managers in a separate <code>managers.py</code> file and import them into <code>models.py</code> before using them. Let's just add them all to the <code>models.py</code> file for now:</p>
			<ol>
				<li value="1">In the <code>/chapter_3/models.py</code> file, add the following two model manager classes above your model classes and below any existing <code>import</code> statements, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">BuickVehicleManager</strong>(models.Manager):
    def get_queryset(self):
        return super().get_queryset()<strong class="bold">.filter(make=1)</strong>
class <strong class="bold">ChevyVehicleManager</strong>(models.Manager):
    def get_queryset(self):
        return super().get_queryset()<strong class="bold">.filter(make=3)</strong>
...</pre></li>
				<li>In the <code>/chapter_3/models.py</code> file, add the following three model manager statements<a id="_idIndexMarker518"/> to your existing <code>Vehicle</code> class, below the model fields found in that class and above the <code>Meta</code> subclass, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_3/models.py</strong> 
...
class <strong class="bold">Vehicle</strong>(models.Model):
    # Place Model Fields Here
    # The Default Model Manager
    <strong class="bold">objects</strong> = <strong class="bold">models.Manager()</strong>
    # The Buick Specific Manager
    <strong class="bold">buick_objects</strong> = <strong class="bold">BuickVehicleManager()</strong>
    # The Chevy Specific Manager
    <strong class="bold">chevy_objects</strong> = <strong class="bold">ChevyVehicleManager()</strong>
    # Place Meta Class and Model Methods Here</pre></li>
				<li>Next, open your terminal or command-line window and activate your virtual environment and the Django shell. Then, import the <code>Vehicle</code> model into <code>InteractiveConsole</code>, as is done here: <pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py shell</strong>
<strong class="bold">&gt;&gt;&gt; from becoming_a_django_entdev.chapter_3.models import Vehicle </strong></pre></li>
				<li>Execute the following <code>objects</code> manager <code>count()</code> method:<pre><strong class="bold">&gt;&gt;&gt; Vehicle.objects.all().count()</strong>
<strong class="bold">7</strong></pre></li>
				<li>Execute the following <code>buick_objects</code> manager <code>count()</code> method:<pre><strong class="bold">&gt;&gt;&gt; Vehicle.buick_objects.all().count()</strong>
<strong class="bold">2</strong></pre></li>
				<li>Execute the following <code>chevy_objects</code> manager <code>count()</code> method:<pre><strong class="bold">&gt;&gt;&gt; Vehicle.chevy_objects.all().count()</strong>
<strong class="bold">5</strong></pre></li>
			</ol>
			<p>What we get in return<a id="_idIndexMarker519"/> are the vehicles that relate to each manager that we created, starting with the <code>objects</code> manager, then <code>buick_objects</code> and <code>chevy_objects</code>. This counts the filtered objects instead of providing us with a total count of all objects in that table. Even though we are still using the <code>all()</code> method, we only get all of the objects related to that filter. We also apply the <code>count()</code> method to print a numeric count of what gets returned in a QuerySet versus printing the names of each object, as was depicted in previous query examples.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor114"/>Summary</h1>
			<p>In this chapter, we learned that models are building blocks of everything else we build that accesses data in a database. They provide the containers where all of a project's data will exist as a data storage device for this application. We now have a toolbox with tools related to the structure of the tables, such as the columns that exist or rules/constraints that we apply to them. Other tools help us to link these tables together that build the relationships between those tables. We also know how to transform the data that we have to provide other data not kept in those tables, but rather derived from it. Some of the concepts add performance power by doing work in the background, indexing data, and reducing the time that it takes to look up information. Querying objects is also a complex subject and there is a lot of material regarding it; use the concepts in this chapter to help guide you through researching more advanced ways of querying data, to help with complex real-world scenarios. Later, in <a href="B17243_10_ePub.xhtml#_idTextAnchor293"><em class="italic">Chapter 10</em></a>, <em class="italic">Database Management</em>, we will discuss other tricks that help to enhance database performance when performing database queries. </p>
			<p>Next, let's take the models that we created in this chapter and render that data onto an actual web page, finally viewing something within a browser. These will be the URLs, views, and templates that we create in the next chapter.</p>
		</div>
	</body></html>