["```py\nimport unittest\n\nclass CheckNumbers(unittest.TestCase):\n    def test_int_float(self):\n        self.assertEqual(1, 1.0)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```", "```py\n.\n--------------------------------------------------------------\nRan 1 test in 0.000s\n\nOK  \n```", "```py\n    def test_str_float(self): \n        self.assertEqual(1, \"1\") \n```", "```py\n.F\n============================================================\nFAIL: test_str_float (__main__.CheckNumbers)\n--------------------------------------------------------------\nTraceback (most recent call last):\n File \"first_unittest.py\", line 9, in test_str_float\n self.assertEqual(1, \"1\")\nAssertionError: 1 != '1'\n\n--------------------------------------------------------------\nRan 2 tests in 0.001s\n\nFAILED (failures=1)  \n```", "```py\nimport unittest\n\ndef average(seq):\n    return sum(seq) / len(seq)\n\nclass TestAverage(unittest.TestCase):\n    def test_zero(self):\n        self.assertRaises(ZeroDivisionError, average, [])\n\n    def test_with_zero(self):\n        with self.assertRaises(ZeroDivisionError):\n            average([])\n\nif __name__ == \"__main__\":\n    unittest.main()\n```", "```py\nfrom collections import defaultdict \n\nclass StatsList(list): \n    def mean(self): \n        return sum(self) / len(self) \n\n    def median(self): \n        if len(self) % 2: \n            return self[int(len(self) / 2)] \n        else: \n            idx = int(len(self) / 2) \n            return (self[idx] + self[idx-1]) / 2 \n\n    def mode(self): \n        freqs = defaultdict(int) \n        for item in self: \n            freqs[item] += 1 \n        mode_freq = max(freqs.values()) \n        modes = [] \n        for item, value in freqs.items(): \n            if value == mode_freq: \n                modes.append(item) \n        return modes \n```", "```py\nfrom stats import StatsList\nimport unittest\n\nclass TestValidInputs(unittest.TestCase):\n    def setUp(self):\n        self.stats = StatsList([1, 2, 2, 3, 3, 4])\n\n    def test_mean(self):\n        self.assertEqual(self.stats.mean(), 2.5)\n\n    def test_median(self):\n        self.assertEqual(self.stats.median(), 2.5)\n        self.stats.append(4)\n        self.assertEqual(self.stats.median(), 3)\n\n    def test_mode(self):\n        self.assertEqual(self.stats.mode(), [2, 3])\n        self.stats.remove(2)\n        self.assertEqual(self.stats.mode(), [3])\n\nif __name__ == \"__main__\":\n    unittest.main()\n```", "```py\nimport unittest\nimport sys\n\nclass SkipTests(unittest.TestCase):\n    @unittest.expectedFailure\n    def test_fails(self):\n        self.assertEqual(False, True)\n\n    @unittest.skip(\"Test is useless\")\n    def test_skip(self):\n        self.assertEqual(False, True)\n\n    @unittest.skipIf(sys.version_info.minor == 4, \"broken on 3.4\")\n    def test_skipif(self):\n        self.assertEqual(False, True)\n\n    @unittest.skipUnless(\n        sys.platform.startswith(\"linux\"), \"broken unless on linux\"\n    )\n    def test_skipunless(self):\n        self.assertEqual(False, True)\n\nif __name__ == \"__main__\":\n    unittest.main()\n```", "```py\nxssF\n======================================================================\nFAIL: test_skipunless (__main__.SkipTests)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n File \"test_skipping.py\", line 22, in test_skipunless\n self.assertEqual(False, True)\nAssertionError: False != True\n\n----------------------------------------------------------------------\nRan 4 tests in 0.001s\n\nFAILED (failures=1, skipped=2, expected failures=1)\n```", "```py\ndef test_int_float(): \n    assert 1 == 1.0 \n```", "```py\nclass TestNumbers: \n    def test_int_float(self): \n        assert 1 == 1.0 \n\n    def test_int_str(self): \n        assert 1 == \"1\" \n```", "```py\n============================== test session starts ==============================\nplatform linux -- Python 3.7.0, pytest-3.8.0, py-1.6.0, pluggy-0.7.1\nrootdir: /home/dusty/Py3OOP/Chapter 12: Testing Object-oriented Programs, inifile:\ncollected 3 items\n\ntest_with_pytest.py ..F [100%]\n\n=================================== FAILURES ====================================\n___________________________ TestNumbers.test_int_str ____________________________\n\nself = <test_with_pytest.TestNumbers object at 0x7fdb95e31390>\n\n def test_int_str(self):\n> assert 1 == \"1\"\nE AssertionError: assert 1 == '1'\n\ntest_with_pytest.py:10: AssertionError\n====================== 1 failed, 2 passed in 0.03 seconds =======================\n```", "```py\ndef setup_module(module):\n    print(\"setting up MODULE {0}\".format(module.__name__))\n\ndef teardown_module(module):\n    print(\"tearing down MODULE {0}\".format(module.__name__))\n\ndef test_a_function():\n    print(\"RUNNING TEST FUNCTION\")\n\nclass BaseTest:\n    def setup_class(cls):\n        print(\"setting up CLASS {0}\".format(cls.__name__))\n\n    def teardown_class(cls):\n        print(\"tearing down CLASS {0}\\n\".format(cls.__name__))\n\n    def setup_method(self, method):\n        print(\"setting up METHOD {0}\".format(method.__name__))\n\n    def teardown_method(self, method):\n        print(\"tearing down METHOD {0}\".format(method.__name__))\n\nclass TestClass1(BaseTest):\n    def test_method_1(self):\n        print(\"RUNNING METHOD 1-1\")\n\n    def test_method_2(self):\n        print(\"RUNNING METHOD 1-2\")\n\nclass TestClass2(BaseTest):\n    def test_method_1(self):\n        print(\"RUNNING METHOD 2-1\")\n\n    def test_method_2(self):\n        print(\"RUNNING METHOD 2-2\")\n```", "```py\nsetup_teardown.py\nsetting up MODULE setup_teardown\nRUNNING TEST FUNCTION\n.setting up CLASS TestClass1\nsetting up METHOD test_method_1\nRUNNING METHOD 1-1\n.tearing down  METHOD test_method_1\nsetting up METHOD test_method_2\nRUNNING METHOD 1-2\n.tearing down  METHOD test_method_2\ntearing down CLASS TestClass1\nsetting up CLASS TestClass2\nsetting up METHOD test_method_1\nRUNNING METHOD 2-1\n.tearing down  METHOD test_method_1\nsetting up METHOD test_method_2\nRUNNING METHOD 2-2\n.tearing down  METHOD test_method_2\ntearing down CLASS TestClass2\n\ntearing down MODULE setup_teardown  \n```", "```py\nimport pytest\nfrom stats import StatsList\n\n@pytest.fixture\ndef valid_stats():\n    return StatsList([1, 2, 2, 3, 3, 4])\n\ndef test_mean(valid_stats):\n    assert valid_stats.mean() == 2.5\n\ndef test_median(valid_stats):\n    assert valid_stats.median() == 2.5\n    valid_stats.append(4)\n    assert valid_stats.median() == 3\n\ndef test_mode(valid_stats):\n    assert valid_stats.mode() == [2, 3]\n    valid_stats.remove(2)\n    assert valid_stats.mode() == [3]\n```", "```py\nimport pytest\nimport tempfile\nimport shutil\nimport os.path\n\n@pytest.fixture\ndef temp_dir(request):\n    dir = tempfile.mkdtemp()\n    print(dir)\n    yield dir\n    shutil.rmtree(dir)\n\ndef test_osfiles(temp_dir):\n    os.mkdir(os.path.join(temp_dir, \"a\"))\n    os.mkdir(os.path.join(temp_dir, \"b\"))\n    dir_contents = os.listdir(temp_dir)\n    assert len(dir_contents) == 2\n    assert \"a\" in dir_contents\n    assert \"b\" in dir_contents\n```", "```py\nimport socket \n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM) \ns.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) \ns.bind(('localhost',1028)) \ns.listen(1) \n\n    while True: \n        client, address = s.accept() \n        data = client.recv(1024) \n        client.send(data) \n        client.close() \n```", "```py\nimport subprocess\nimport socket\nimport time\nimport pytest\n\n@pytest.fixture(scope=\"session\")\ndef echoserver():\n    print(\"loading server\")\n    p = subprocess.Popen([\"python3\", \"echo_server.py\"])\n    time.sleep(1)\n    yield p\n    p.terminate()\n\n@pytest.fixture\ndef clientsocket(request):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((\"localhost\", 1028))\n    yield s\n    s.close()\n\ndef test_echo(echoserver, clientsocket):\n    clientsocket.send(b\"abc\")\n    assert clientsocket.recv(3) == b\"abc\"\n\ndef test_echo2(echoserver, clientsocket):\n    clientsocket.send(b\"def\")\n    assert clientsocket.recv(3) == b\"def\"\n```", "```py\nimport sys \nimport pytest \n\ndef test_simple_skip(): \n    if sys.platform != \"fakeos\": \n        pytest.skip(\"Test works only on fakeOS\") \n\n    fakeos.do_something_fake() \n    assert fakeos.did_not_happen \n```", "```py\n@pytest.mark.skipif(\"sys.version_info <= (3,0)\") \ndef test_python3(): \n    assert b\"hello\".decode() == \"hello\" \n```", "```py\nimport datetime\nimport redis\n\nclass FlightStatusTracker:\n    ALLOWED_STATUSES = {\"CANCELLED\", \"DELAYED\", \"ON TIME\"}\n\n    def __init__(self):\n        self.redis = redis.StrictRedis()\n\n    def change_status(self, flight, status):\n        status = status.upper()\n        if status not in self.ALLOWED_STATUSES:\n            raise ValueError(\"{} is not a valid status\".format(status))\n\n        key = \"flightno:{}\".format(flight)\n        value = \"{}|{}\".format(\n            datetime.datetime.now().isoformat(), status\n        )\n        self.redis.set(key, value)\n```", "```py\nfrom flight_status_redis import FlightStatusTracker\nfrom unittest.mock import Mock\nimport pytest\n\n@pytest.fixture\ndef tracker():\n    return FlightStatusTracker()\n\ndef test_mock_method(tracker):\n tracker.redis.set = Mock()\n    with pytest.raises(ValueError) as ex:\n        tracker.change_status(\"AC101\", \"lost\")\n    assert ex.value.args[0] == \"LOST is not a valid status\"\n assert tracker.redis.set.call_count == 0\n\n```", "```py\nimport datetime\nfrom unittest.mock import patch\n\ndef test_patch(tracker):\n    tracker.redis.set = Mock()\n    fake_now = datetime.datetime(2015, 4, 1)\n with patch(\"datetime.datetime\") as dt:\n        dt.now.return_value = fake_now\n        tracker.change_status(\"AC102\", \"on time\")\n    dt.now.assert_called_once_with()\n    tracker.redis.set.assert_called_once_with(\n        \"flightno:AC102\", \"2015-04-01T00:00:00|ON TIME\"\n    )\n```", "```py\n    def __init__(self, redis_instance=None): \n        self.redis = redis_instance if redis_instance else redis.StrictRedis() \n```", "```py\n$coverage run coverage_unittest.py  \n```", "```py\n$coverage report  \n```", "```py\nName                           Stmts   Exec  Cover\n--------------------------------------------------\ncoverage_unittest                  7      7   100%\nstats                             19      6    31%\n--------------------------------------------------\nTOTAL                             26     13    50%  \n```", "```py\nMissing\n-----------\n8-12, 15-23  \n```", "```py\nfrom stats import StatsList \nimport unittest \n\nclass TestMean(unittest.TestCase): \n    def test_mean(self): \n        self.assertEqual(StatsList([1,2,2,3,3,4]).mean(), 2.5) \n\nif __name__ == \"__main__\": \n\n    unittest.main() \n```", "```py\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z \nB C D E F G H I J K L M N O P Q R S T U V W X Y Z A \nC D E F G H I J K L M N O P Q R S T U V W X Y Z A B \nD E F G H I J K L M N O P Q R S T U V W X Y Z A B C \nE F G H I J K L M N O P Q R S T U V W X Y Z A B C D \nF G H I J K L M N O P Q R S T U V W X Y Z A B C D E \nG H I J K L M N O P Q R S T U V W X Y Z A B C D E F \nH I J K L M N O P Q R S T U V W X Y Z A B C D E F G \nI J K L M N O P Q R S T U V W X Y Z A B C D E F G H \nJ K L M N O P Q R S T U V W X Y Z A B C D E F G H I \nK L M N O P Q R S T U V W X Y Z A B C D E F G H I J \nL M N O P Q R S T U V W X Y Z A B C D E F G H I J K \nM N O P Q R S T U V W X Y Z A B C D E F G H I J K L \nN O P Q R S T U V W X Y Z A B C D E F G H I J K L M \nO P Q R S T U V W X Y Z A B C D E F G H I J K L M N \nP Q R S T U V W X Y Z A B C D E F G H I J K L M N O \nQ R S T U V W X Y Z A B C D E F G H I J K L M N O P \nR S T U V W X Y Z A B C D E F G H I J K L M N O P Q \nS T U V W X Y Z A B C D E F G H I J K L M N O P Q R \nT U V W X Y Z A B C D E F G H I J K L M N O P Q R S \nU V W X Y Z A B C D E F G H I J K L M N O P Q R S T \nV W X Y Z A B C D E F G H I J K L M N O P Q R S T U \nW X Y Z A B C D E F G H I J K L M N O P Q R S T U V \nX Y Z A B C D E F G H I J K L M N O P Q R S T U V W \nY Z A B C D E F G H I J K L M N O P Q R S T U V W X \nZ A B C D E F G H I J K L M N O P Q R S T U V W X Y \n```", "```py\nE N C O D E D I N P Y T H O N\nT R A I N T R A I N T R A I N \n```", "```py\ndef test_encode():\n    cipher = VigenereCipher(\"TRAIN\")\n    encoded = cipher.encode(\"ENCODEDINPYTHON\")\n    assert encoded == \"XECWQXUIVCRKHWA\"\n```", "```py\nclass VigenereCipher:\n    def __init__(self, keyword):\n        self.keyword = keyword\n\n    def encode(self, plaintext):\n        return \"XECWQXUIVCRKHWA\"\n\n```", "```py\ndef test_encode_character(): \n    cipher = VigenereCipher(\"TRAIN\") \n    encoded = cipher.encode(\"E\") \n    assert encoded == \"X\" \n```", "```py\ndef test_encode_spaces(): \n    cipher = VigenereCipher(\"TRAIN\") \n    encoded = cipher.encode(\"ENCODED IN PYTHON\") \n    assert encoded == \"XECWQXUIVCRKHWA\" \n\ndef test_encode_lowercase(): \n    cipher = VigenereCipher(\"TRain\") \n    encoded = cipher.encode(\"encoded in Python\") \n    assert encoded == \"XECWQXUIVCRKHWA\" \n```", "```py\nfrom vigenere_cipher import combine_character \ndef test_combine_character(): \n    assert combine_character(\"E\", \"T\") == \"X\" \n    assert combine_character(\"N\", \"R\") == \"E\" \n```", "```py\ndef combine_character(plain, keyword): \n    plain = plain.upper() \n    keyword = keyword.upper() \n    plain_num = ord(plain) - ord('A') \n    keyword_num = ord(keyword) - ord('A') \n    return chr(ord('A') + (plain_num + keyword_num) % 26) \n```", "```py\ndef test_extend_keyword(): cipher = VigenereCipher(\"TRAIN\") extended = cipher.extend_keyword(16) assert extended == \"TRAINTRAINTRAINT\" \n```", "```py\n    def extend_keyword(self, number):\n        repeats = number // len(self.keyword) + 1\n        return (self.keyword * repeats)[:number]\n```", "```py\n    def encode(self, plaintext): \n        cipher = [] \n        keyword = self.extend_keyword(len(plaintext)) \n        for p,k in zip(plaintext, keyword): \n            cipher.append(combine_character(p,k)) \n        return \"\".join(cipher) \n```", "```py\n        plaintext = plaintext.replace(\" \", \"\").upper() \n```", "```py\ndef test_separate_character(): \n    assert separate_character(\"X\", \"T\") == \"E\" \n    assert separate_character(\"E\", \"R\") == \"N\" \n\ndef test_decode(): \n    cipher = VigenereCipher(\"TRAIN\") \n    decoded = cipher.decode(\"XECWQXUIVCRKHWA\") \n    assert decoded == \"ENCODEDINPYTHON\" \n```", "```py\ndef separate_character(cypher, keyword): \n    cypher = cypher.upper() \n    keyword = keyword.upper() \n    cypher_num = ord(cypher) - ord('A') \n    keyword_num = ord(keyword) - ord('A') \n    return chr(ord('A') + (cypher_num - keyword_num) % 26) \n```", "```py\n    def decode(self, ciphertext): \n        plain = [] \n        keyword = self.extend_keyword(len(ciphertext)) \n        for p,k in zip(ciphertext, keyword): \n            plain.append(separate_character(p,k)) \n        return \"\".join(plain) \n```", "```py\n    def _code(self, text, combine_func): \n        text = text.replace(\" \", \"\").upper() \n        combined = [] \n        keyword = self.extend_keyword(len(text)) \n        for p,k in zip(text, keyword): \n            combined.append(combine_func(p,k)) \n        return \"\".join(combined) \n\n    def encode(self, plaintext): \n        return self._code(plaintext, combine_character) \n\n    def decode(self, ciphertext): \n        return self._code(ciphertext, separate_character) \n```"]