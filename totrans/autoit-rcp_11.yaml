- en: Chapter 11. Time in the Zone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time calculations are fun, interesting, and tedious at the same time. Fun, when
    you first learn to read time, interesting, when you learn about daylight saving
    and tedious, when a customer complains about not able to schedule meetings across
    time zones through your web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with time, date, and calendar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing and combining dates, and date arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting and parsing dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with time zone calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating invoicing based on time zone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"If you love life, don''t waste time, for time is what life is made up of."
                                                                                 
                   --Bruce Lee.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Time is the measure of all things. We have so many things to do in life, and
    yet the irony is we have so much less time on our hands. These days, we plan for
    time intuitively: what time should I travel at to avoid traffic, what''s my deadline
    for this task among many other things, and so on. Businesses plan their activities
    for the complete year even before the calendar begins.'
  prefs: []
  type: TYPE_NORMAL
- en: Time calculations are almost everywhere. Want to schedule a meeting with your
    colleague in Australia? Get the time zone right, work on a good time for you and
    your colleague, and then schedule it. Want to write code to perform a task for
    your customer when the time is right? Manage time objects in the database and
    keep track of all the tasks for your users. Even in the Hollywood movie, *National
    Treasure*, Nicholas Cage had to depend on time zone calculations to get to the
    next clue that took him closer to the treasure.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, you can't run away from time calculations wherever you are and
    whatever you do. In this chapter, we will work with `date` and `time` objects
    in Python. We will also learn how to perform arithmetic operations on dates and
    work with time zone calculations. We will also learn how to automate a business
    process based on users' time zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, we will majorly use built-in Python modules.
    The following built-in modules will be used in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`datetime` ([https://docs.python.org/2/library/datetime.html](https://docs.python.org/2/library/datetime.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calendar` ([https://docs.python.org/2/library/calendar.html](https://docs.python.org/2/library/calendar.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also use this external module to work with time zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pytz` ([http://pytz.sourceforge.net/](http://pytz.sourceforge.net/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pytz` library brings the Olson timezone database into Python. It allows
    accurate and cross-platform timezone calculations in Python 2\. It also helps
    in performing calculations with respect to daylight savings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the recipes, let''s check if we have the relevant modules
    in our Python installation and also install the ones we need in this chapter.
    We start by creating a virtual environment for this chapter and activating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s install the `pytz` module in our virtual environment using Python
    `pip`. Once we install the module, we will move ahead to the first recipe and
    start working with `time` and `date` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Working with time, date, and calendar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use built in Python modules and we don't need to install
    anything explicitly. So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go to your favorite editor, create a file named `time_ex.py`, and write the
    following code in the Python file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the preceding Python code, we will see the following output. Observe
    how we created a given time object using Python and retrieved the *hour, minute,
    second,* and *microsecond* details for the given time object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_001.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Python''s `Time` class has some more attributes that can be effectively used
    for time calculations. For instance, in the following code snippet, I can get
    the valid time range for a given day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code snippet can be seen in the following screenshot.
    Observe how we get the first and the last available time for the day:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_002.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Neat! Now, let''s look at the `date` object. The following Python code gets
    today''s date for you. We also retrieve the `year`, `month`, and `day` attributes
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Ok, cool! We can also create a new `date` object or modify an existing one
    with Python''s `date()` and `replace()` methods. The following code demonstrates
    how to use these methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding snippet is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_004.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Fantastic! Let''s move ahead and see if we can work with months or even years.
    With Python, it''s very easy to work with the whole calendar. The following code
    prints out the calendar for the complete year on the console. In this case, it
    returns the calendar for the year 2017\. Let me check my birthday... oh it''s
    on Tuesday this year and I have to go to the office:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is shown in the following screenshot. The
    first screenshot returns the complete calendar for the year 2017:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The following screenshot only returns the calendar for the eleventh month of
    2017, that is, November 2017:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_006.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we started working with `time` objects. We created a `time`
    object with the `datetime.time()` method that takes hour, minute, and second as
    input parameters. We also read the time object with `hour`, `minute`, and `second` attributes,
    and got the earliest and latest times of the day with `datetime.time.min` and
    `datetime.time.max` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we moved onto working with dates using the `datetime.date()` method. We
    got today's date with the `datetime.date()` method and printed the year, month,
    and day for today with the `today.year`, `today.month`, and `today.day` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a new date with the `datetime.date()` method by passing the
    `year`, `month`, and `day` as parameters. Once the `date` object was available,
    we used it to get the new date with the `replace()` method. We passed `year` and
    `month` as parameters to the `replace()` method to create the new `date` object.
  prefs: []
  type: TYPE_NORMAL
- en: We also worked with the `calendar` object in this section. We used the `calendar`
    module available in Python installation for this purpose. First, we instantiated
    the `TextCalendar` class to create a text calendar object. Later, we used this
    object to print the calendar for the year 2017 on the console with `pryear()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We could also show the calendar for just the month of November for the year,
    2017, using the `prmonth()` method. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: Comparing and combining the date and time objects, and date arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating `date` objects and using them is great, but the tasks we need to perform
    for business use cases are often related to comparing or calculating differences
    in the date and time objects. In this recipe, we will learn how to perform these
    operations in Python. It is, however, important to note a major change that we
    will see in this recipe. In the last recipe, we worked with the time and date
    objects independently. But Python's `datetime` module provides a great benefit,
    in the sense that we get to work on objects that include both date and time attributes.
    You will see this difference in the How to do it section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will work with the `datetime` Python module that we used
    for the last couple of examples. We don't have any new installations to be done
    for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by getting the difference between two datetime objects. The following
    code does this operation and calculates the difference between two `datetime`
    objects. Though this operation only tells you the difference in seconds, you can
    also use these to get the difference in months or years. In the following screenshot,
    notice how `datetime.now()` returns a string with both today''s date and the current
    time. It is important to understand that we are working on an object that comprises
    the date and time attributes. If you think about it, in the actual world also,
    when we have to calculate the time difference between two events, working on the
    date and time objects together will be the most useful to us. Even if we independently
    work on the date object or the time object, we will end up performing the same
    calculation that we will perform with the datetime object, so imagine the benefits
    we get with this approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is shown in the following screenshot.
    See how we get the difference between the datetime objects in seconds:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This is fine, but you may ask what happens if the difference in the `datetime`
    objects is negative. In this example, if we calculate `now_1 - now_2`, we get
    a high number and not the actual difference. For this, we have a nice trick to
    get the difference between two `datetime` objects. We can use `(now_1 - now_2).total_seconds()`
    to get the negative value, that is, `-5` seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OK, now let''s move forward to perform more calculations on the `datetime`
    objects. For instance, how about getting the time from the past or into the future?
    The following code helps us perform these operations; see how we got the date
    and time at this moment and also could return the date and time for the next day,
    that is, tomorrow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'If we want to get the time in the past, we could do it in the same way as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output of the preceding code is shown in the following screenshot. Note
    that we asked for a past date, which is 365 days back. However, it shows November
    28, 2015\. Why? Shouldn't it show the same day? Oh, of course, 2016 was a leap
    year!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_009.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'OK, now we''re comfortable working with getting the difference or adding time
    to `date` and `time` objects. But we also often need to compare between times,
    right? Let''s learn this with the help of a code snippet. The following Python
    code compares `time` and `date` objects separately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding piece of code can be seen in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_010.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'As we saw in the previous recipe, you also feel the need to combine your `time`
    objects with the `date` objects. For instance, you have developed your program
    for a use case where you want to compare `time` objects and take some action.
    But you may end up doing the date comparison also since the `time` objects you
    are comparing fall on different dates. Since you''re already aware how easy it
    is to work with `datetime` objects, you may want to combine your `time` and `date`
    objects into a single `datetime` object and easily work on them. We can easily
    achieve this in Python; the following code demonstrates combining independent
    times and dates to `datetime` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding piece of code is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_011.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, we worked on `time`, `date`, and `calendar` objects independently.
    In this recipe, we started working on the complete `datetime` object.
  prefs: []
  type: TYPE_NORMAL
- en: In the first code example of this recipe, we calculated the difference between
    the `datetime` objects. We could easily do that with the same subtraction (`-`)
    operator we're used to. That means the `__sub__()` method has been overridden
    for the `datetime` class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the second and third code snippets, we used the `timedelta()` method
    to get to the future `datetime` objects or move in the past. The `timedelta()`
    method supports conveniently named attributes such as `days` or `hours` to shift
    the current `datetime` objects to the past or future. We get to the past with
    `- timedelta()` and move ahead with `+ timedelta()` operations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we understood how to compare the `datetime` objects. This was again simply
    done like any other Python object. In Python, we check if an integer is less than
    or greater than another integer with the `<` and `>` operators, respectively.
    Same is the case with the `datetime` objects. We simply use these operators to
    compare even the `datetime` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the use case where we needed to work on `date` and `time`
    objects to get the difference or compare them. For this, we wrote a Python code
    to combine the `date` and `time` objects and used the `datetime.combine()` method.
    This made sure that the comparison or the difference operation can be easily done
    on the `datetime` objects instead of doing them individually on `date` or `time`
    objects and then merging the results.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting and parsing dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all the recipes so far, we performed multiple operations on the `date` or
    `time` objects. But the objects themselves are represented in certain formats.
    For instance, by default, the `date()` object is represented in a YYYY-MM-DD format
    and the `time()` object is represented in a HH:MM:SS format. While these representations
    are good, we can't always use these formats for representing data to the users
    on a website or while scheduling meetings from a web page.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we quickly look at the different formats in which the `date`
    and `time` objects can be manifested to the users.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we end up using the same `datetime` module that gets packaged
    with the default Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started with something we know. The following Python code will print
    the date and time in ISO format. This format is the most used format around the
    world and is universally acceptable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, as you would have already imagined, this format is not quite readable.
    For instance, it reads the month in digits (11 for November) and returns the time
    even till microseconds (which I don''t think is very useful). How about formats
    where we solve these issues and make the date more readable? Yes, we can easily
    do that with the following code snippet. In this code, with the help of certain
    format specifiers such as `''%b''`, we manage to make the month readable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You must have seen some web applications using Unix timestamp or epochs to store
    time. Even though this is a nice way to store objects, you still need to represent
    the actual time or date to the user in the format she understands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unix time, also known as POSIX time or epoch time, is a system for describing
    times defined as seconds that have elapsed since Thursday, January 01, 1970, 00:00:00
    UTC. Unix timestamps are useful as they represent time independent of time zones.
    For example, a Unix time can represent 1:00 pm in London and 8:00 am in New York.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippets show how to convert timestamps to `datetime` objects
    and vice versa:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another fun representation of the `datetime` objects can be to show the date
    from the *n*^(th) day from when the world began. For instance, can you print the
    date for the 1000^(th) day after Jan 1, 0001? It is the date corresponding to
    the propletic Gregorian calendar where 01/01/01 has an ordinal 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the preceding Python code snippet, you will be able to see the desired
    objects as in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_012.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we looked at the various ways of representing `datetime` objects.
    In the first example, we printed the date and time in ISO format. This is the
    most used format and you can read more about the ISO format at [https://en.wikipedia.org/wiki/ISO_8601](https://en.wikipedia.org/wiki/ISO_8601).
    As you can see, we need not use a new method for this representation; we simply
    used `datetime.today()` to get the date in ISO format.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we looked at defining our own format for representing
    the date in the string format. We took the help of format specifiers, such as
    `%a`, `%b`, and `%d` to work with date and `%H`, `%M`, and `%S` to work with time.
    We specified the format in the `format` variable and used it to pass it to `strftime()`
    method that formatted the ISO `datetime` object to our custom String format.
  prefs: []
  type: TYPE_NORMAL
- en: The next two examples helped us convert a Unix timestamp or an epoch to a `datetime`
    object and vice versa. For the first use case, we use the `datetime.fromtimestamp(<unixtimestamp>)`
    method to convert a Unix time stamp to a `datetime` object, and in the successive
    example, we converted a `datetime` object to a Unix timestamp with the `strftime()`
    method. The Unix time (1284101485) used in this example is the number of seconds
    that have elapsed since January 01, 1970.
  prefs: []
  type: TYPE_NORMAL
- en: In the last and interesting example, we get the date and time in a Gregorian
    calendar ordinal format with `fromordinal()` method. You will not use this method,
    in all likelihood, but I have included it in this chapter as an interesting date
    format for you to know.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with time zone calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the trickiest calculations that you will have to perform on `date` or
    `time` objects is the one that involves time zones. Your colleague works in San
    Francisco and you are in Sydney, how do you plan to do a conference call? When
    you set up a meeting, you should be aware of your colleague's time zone, else
    you may set up a meeting for 8 pm Sydney time while for your colleague in San
    Francisco, it is already past midnight. Time zone calculations are often tedious
    and need to be handled cautiously while developing business applications. Let's
    see how Python can help us in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the `pytz` module that we installed at the beginning
    of this chapter. In fact, the Python standard library doesn't have a time zone
    library, but we can completely rely on the modules contributed by the Python community
    for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with a trivial operation of getting the local time in UTC.
    **UTC** stands for **Universal Time Converter**, a worldwide standard for regulating
    clocks and time measurements. UTC is also popularly known as Greenwich Mean Time
    (GMT).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is shown in the following screenshot.
    Look at how my local time is +5:30 hours ahead of UTC:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_013.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'OK, this is nice. So, you can convert your local time to UTC, but this is not
    always enough. Your customers (for whom you develop the application) can be from
    anywhere in the world. Their accounts also need to be managed with respect to
    their time zones and local times. Let''s see how we can figure out the local time
    for a user in a given time zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding piece of code is shown in the following screenshot.
    Observe how we converted a local UTC time to **Eastern Standard Time** (**EST**)
    by getting the eastern time zone. In fact, UTC works out to be the best way to
    convert time across time zones:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_014.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Performing arithmetic calculations on `datetime` objects with time zone information
    is also trivial in Python. Look at the following code and see how we perform arithmetic
    operations on `date` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we run this piece of code on our Python interpreter, we get the following
    output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_015.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We can''t finish any topic on time zones without really talking about this,
    can we? Yes, how do we deal with daylight savings in time zone calculations? Thanks
    to Benjamin Franklin for the gift he gave to the world on daylight savings. Let''s
    understand this with the help of a code example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the code snippet, you''d see two `datetime` objects represented
    in the String format. The first one takes care of the daylight savings and the
    second one disregards it. November 6, 2016 is when the daylight savings ended
    this year in the eastern time zone and the clock moved backwards:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_016.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Lastly, there are a few helper methods that are available in the `pytz` module
    that are often useful, for instance, getting the time zones for a given country
    based on the ISO country code, or simply getting the country name from the ISO
    country code. Let''s look at the following examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code snippet can be viewed in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_017.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we looked at the various ways of working with time zones, which
    are integral to date-time calculations. In the first code example of this recipe,
    we calculate the current local time with `datetime.now()` and then got the same
    local time in UTC with `datetime.utcnow()`. The `utcnow()` method becomes very
    handy when we have to store date/time objects in the database for further processing,
    such as scheduling events.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at how to switch to a different time zone and retrieve the local
    time in that time zone. The `pytz` class has a simple attribute, `utc`, to set
    the time zone to UTC; we used it to set our current time zone to UTC. Later we
    used the `timezone()` method of the `pytz` module to switch to the eastern time
    zone with `timezone('US/Eastern')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all the recipes before this one, we created a `datetime` object with the
    `datetime()` method; in this recipe also, we used the `datetime` method but with
    the `tzinfo` parameter in this way: `datetime(YYYY, MM, DD, HH, MM, SS, tzinfo=<timezone>)`.
    The `tzinfo` parameter makes sure to add the time zone information to the `datetime`
    object, which is important while performing calculations across time zones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `datetime` class has another convenient method that will represent the
    `datetime` object to a time zone of our choice: the `astimezone()` method. Using
    this method, we converted the UTC `datetime` object to eastern time with this
    code, `loc_dt.astimezone(eastern)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created a custom string format to represent the eastern time with
    the `strftime(format)` method.
  prefs: []
  type: TYPE_NORMAL
- en: We can also add or remove time/days during the time zone calculations like we
    did with `datetime` objects. In the third code sample of this recipe, we switched
    to the Australia/Sydney time zone and created a `datetime` object for this time
    zone; this operation returned us the local time in Sydney. With the help of the `timedelta()`
    method, we then removed ten minutes from the local time with `local - timedelta(mins=10)`
    and also added 18 hours to the time with `local + timedelta(hours=18)`. This way,
    we could access the time from the past or in the future. Think of it as time travel.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth code snippet, we understood how to work with daylight savings.
    To understand this, we created a `datetime` object without any time zone information
    and assigned it to the `dt` variable. We also created a time zone object for eastern
    time with the code, `eastern = timezone('US/Eastern')`. We then used the `localize()`
    method on the time zone object to convert the `dt` object to eastern time. Here
    is where we add another parameter, `is_dst`, to the `localize(is_dst=<True/False>)`
    method to return the local time in eastern time zone, with or without considering
    daylight savings.
  prefs: []
  type: TYPE_NORMAL
- en: In 2016, November 6 was the day when the clock moved backwards at 2 am. So,
    in our example, when we queried for 1:30 am eastern time with `is_dst=True`, it
    returned time in **Eastern Daylight Time** (**EDT**), which is four hours behind
    **Coordinated Universal Time** (UTC-0400 hours). When we queried for the same
    time with `is_dst=False`, it returns the time in EST, which is UTC-0500 hours.
  prefs: []
  type: TYPE_NORMAL
- en: In the last example of this recipe, we looked at a few useful helper methods
    provided by the `pytz` module. For instance, `pytz.country_timezones['au']` returned
    all the time zones available in Au (Australia) and `pytz.country_names['gb']`
    returned the name of the country, that is, Britain (UK), based on the ISO country
    code `gb`. You will realize the utility of these libraries when you actually solve
    some of the time zone problems.
  prefs: []
  type: TYPE_NORMAL
- en: Automating invoicing based on user time zone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jacob is a Finance Manager at Anzee Corporation in North America and is responsible
    for customer invoicing. Anzee Corporation provides a **Software as a Service**
    (**SaaS**) platform to its customers and charges customers based on the platform
    usage. Anzee's customers have raised complaints regarding incorrect monthly invoices.
    In their words, "*Invoices for the previous month are available on the 1^(st)
    day of the next month, which is fine, but a part of our usage is not accounted
    for. This messes up our accounting.*"
  prefs: []
  type: TYPE_NORMAL
- en: Currently, Jacob generates invoices in a manual way by getting the data for
    customer's payments and platform usage from the platform's database records. With
    an increasing number of customers each month, Jacob realizes that the manual process
    is going to be laborious and time consuming. He also wants someone to look at
    the issue the customers are complaining about. Can we help Jacob?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll use all the built-in Python modules that we''ve used
    in the previous recipes as well as install the `fpdf` module for generating the
    PDF invoice to solve Jacob''s need for an automated way to prepare invoices for
    his customers. We install the module using Python `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started by looking at the database records. Anzee Corporation uses
    MongoDB to store the records of customer payments and charges for the month. For
    this example, lets assume, the payment records of Anzee Corporation are stored
    in JSON format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use a `users` document that contains the list of all the users with fields
    such as `id`, `name`, `city`, and `timezone`, like any other user table would.
    It also maintains the records of all the payments done by the users in `payments`,
    which contains the `id` of the user who paid for the platform services, the amount
    paid, and the date on which the amount is paid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The timestamp for all the payments done is in the UTC format. Like payments,
    it also maintains the `usage` records that again contain the user ID of the person
    who used the platform, the amount she was charged for the usage, and the time
    at which she was charged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'OK cool, now that we have all the data, let''s work on writing the code to
    generate our invoice. We start by writing methods to get the payments and usages
    for the users for a given month. The following code snippet does this task for
    us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s write the code to generate a PDF invoice in an automated manner,
    as Jacob wanted for his platform. We use the `fpdf` module for this purpose. The
    following code generates the invoice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we run the preceding code snippet in entirety, we get the generated invoice,
    which looks like the following screenshot:![How to do it...](img/image_12_018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OK, this is cool! We could generate the invoice like Jacob expected. We are
    now able to save a lot of time for him by automating the complete process. But
    then he also wanted us to look at the customer complaints regarding the invoice
    not containing accurate information. Let's see what could have happened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, Anzee Corporation stores all the transactions and usage timestamps in UTC
    so that it becomes very easy for them to retrieve the time and show it to the
    user based on the user's time zone. So when we look up all records to get the
    transactions in that month for the invoice, we're looking at the UTC timestamps
    and not the time in the user's time zones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For instance, if you look deeper into the JSON data, there is a mention of another
    payment made by `John`, user ID `12`, which has a `created_at` timestamp as `2016-12-01T01:00:00.141Z`.
    This time may not fall under the month of November from a UTC perspective, but
    the user who made the payment belongs to the US/Eastern time zone. So, 1 am on
    December 1, 2016 in UTC is actually 8 pm on November 30 in the Eastern time zone.
    Obviously, the user doesn't find his payment featuring in the invoice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet solves the problem by generating invoices based
    on the user time zones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the preceding code snippet is shown in the following screenshot.
    See how the payments column now reflects the correct data and includes the $5
    payment done at 8 pm on November 30, 2016, taking the total to *$12 + $5 = $17*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_12_019.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first looked at automating the invoice generation for Jacob. We parsed the
    JSON data for all the users and calculated the payments and usage for all the
    users for the month of November.
  prefs: []
  type: TYPE_NORMAL
- en: We developed `get_payments(user_id, month)` and `get_usage(user_id, month)`
    to go through the `payments` and `usage` records and picked the records for the
    month of November. We did this by working on the `created_at` JSON strings and
    converting them to date/time objects, with `dt = datetime.strptime(u["created_at"],
    '%Y-%m-%dT%H:%M:%S.%fZ')`.
  prefs: []
  type: TYPE_NORMAL
- en: But as we understood in the previous section, just converting the string to
    a timestamp didn't help, as we didn't consider the time with respect to the user's
    time zone. For this, we used the date/time object, `dt`, to convert it to the
    UTC time zone with `dt.replace(tzinfo=pytz.UTC)`, and then converted `dt` to reflect
    the time in the user's time zone with the `dt.astimezone(timezone(<>))` method.
    This way, we could get the payment time in the user's time zone and the invoice
    data reflected correct figures for the month of November.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created HTML content for the invoice by adding the appropriate username,
    time of invoice, and stored this in the `html` variable. Later, we created a `MyFPDF`
    class that inherited `FPDF` and `HTMLMixin` classes from the `fpdf` module. The
    `MyFPDP` class was then used to create a `pdf` object, which represented an empty
    PDF file object. We added a page to the `pdf` object with the `add_page()` method
    and updated it with HTML content (our invoice content) with the `write_html(html)`
    method. Eventually, we dumped the `pdf` object with all the data on the disk with
    the `output(<filename>)` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many other interesting use cases with time and time zone operations
    in Python. It can get tricky if not used well, as we saw in our last examples.
    As a general guideline, I recommend you to:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use `datetime` objects that are time zone aware. You will never go wrong
    with this approach. It will always serve you as a reminder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the `datetime` in an ISO format that also returns you the time zone information
    for the given object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hope you liked this chapter and enjoyed the examples! Stay tuned.
  prefs: []
  type: TYPE_NORMAL
