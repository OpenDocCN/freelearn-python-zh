["```py\n    python -m venv myenv\n    source myenv/bin/activate\n    ```", "```py\n    pip install django \n    pip install django-rest-framework\n    ```", "```py\n    admin web app under the grades directory and add a manage.py file to our project. The admin web app includes built-in web server launch scripts, a settings file, and a URL routing file. manage.py is also a command-line utility, like django-admin, and offers similar features but in the context of a Django project. The file structure of the project directory will look as follows when we create a new Django project: ![Figure 11.4 – File structure of a new Django project \n    ](img/B17189_11_04.jpg)Figure 11.4 – File structure of a new Django project As shown in *Figure 11.4*, the `settings.py` file contains a project-level setting including a list of apps to deploy with the web server. The `urls.py` file contains routing information for different deployed applications. Currently, only the `admin` app is included in this file. `asgi.py` and `wsgi.py` are available to launch the ASGI or WSGI web server, and the option of which one to use is set in the `settings.py` file. \n    ```", "```py\n    grades_svc. This will also create a default SQLite3 database instance. The option of using the default SQLite3 database is available in the settings.py file, but it can be changed if we decide to use any other database. \n    ```", "```py\n    from django.db import models\n    class Grade(models.Model):\n        grade_id = models.CharField(max_length=20)\n        building = models.CharField(max_length=200)\n        teacher = models.CharField(max_length=200)\n        def __str__(self):\n            return self.grade_id\n    ```", "```py\n    from django.contrib import admin\n    from .models import Grade\n    admin.site.register(Grade)\n    ```", "```py\n    from rest_framework import viewsets, status\n    from rest_framework.response import Response\n    from .models import Grade\n    from .serializers import GradeSerializer\n    class GradeViewSet(Grade object and for getting a Grade object according to its ID in actual implementation for the completeness of our microservice. We are showing only the list method because this is the only method relevant for our sample application. It is also important to highlight that the view objects should be implemented as classes and we should avoid putting application logic in the view objects.\n    ```", "```py\n    INSTALLED_APPS = [\n        'django.contrib.admin',\n        'django.contrib.auth',\n        'django.contrib.contenttypes',\n        'django.contrib.sessions',\n        'django.contrib.messages',\n        'django.contrib.staticfiles',\n        'grades_svc',\n        'rest_framework',\n    ]\n    ```", "```py\n    urlpatterns = [\n        path('admin/', admin.site.urls),\n        urls.py file of the admin app, we are redirecting every request to our microservice, except the one that comes with the admin/ URL. \n    ```", "```py\n    from django.urls import path\n    from .views import GradeViewSet\n    urlpatterns = [\n        path(grades/', GradeViewSet.as_view({\n            GET and POST methods of HTTP requests with the grades/ URL to the list and create methods of the GradeViewSet class that we implemented in the views.py file earlier. Similarly, we attached the GET request with the grades/<str:id> URL to the retrieve method of the GradeViewSet class. By using this file, we can add additional URL mapping to the Python functions/methods. \n    ```", "```py\npython3 manage.py makemigrations\npython3 manage.py migrate\n```", "```py\npython3 manage.py runserver\n```", "```py\npython3 manage.py createsuperuser\n```", "```py\n    requirements.txt file. This file will be used by Docker Engine to download these libraries inside the container on top of a Python interpreter. The contents of this file in our project are as follows: \n\n    ```", "```py\n\n    ```", "```py\n    FROM python:3.8-slim\n    ENV PYTHONUNBUFFERED 1\n    WORKDIR /app\n    COPY requirements.txt /app/requirements.txt\n    RUN pip install -r requirements.txt\n    COPY . /app\n    CMD python manage.py runserver 0.0.0.0:8000\n    ```", "```py\n    version: '3.7'\n    services:\n      gradesms:\n        build:\n          context: gradesms service. Note that build is pointing to Dockerfile we just created and assuming it is in the same directory as this docker-compose.yml file. The container port 8000 is mapped to the web server port 8000. This is an important step in allowing traffic from the container to your application inside the container.\n    ```", "```py\n    docker-compose up\n    ```", "```py\nSTUDENTS_MS = http://localhost:8080/students\nGRADES_MS   = \"http://localhost:8000/grades\"\n@app.get('/')\ndef list():\n   student_svc_resp = requests.get(STUDENTS_MS)\n   students = json.loads(student_svc_resp.text)\n   grades_svc_resp = requests.get(GRADES_MS)\n   grades_list = json.loads(grades_svc_resp.text)\n   grades_dict = {cls_item['grade']:\n                    cls_item for cls_item in grades_list}\n  for student in students:\n    student['building'] =         grades_dict[student['grade']]['building']\n    student['teacher'] =         grades_dict[student['grade']]['teacher']\n   return render_template('main.html', students=students)\n```", "```py\n    pip freeze -> requirements.txt\n    ```", "```py\n    FROM python:3.8-slim\n    ENV PYTHONUNBUFFERED True\n    WORKDIR /app\n    COPY . ./\n    #Install production dependencies.\n    RUN pip install -r requirements.txt\n    RUN pip install Flask gunicorn\n    # Run the web service on container startup. we will use \n    # gunicorn and bind our api_app as the main application\n    CMD exec gunicorn --bind:$PORT --workers 1 --threads 8 api_app:app\n    ```", "```py\n    gcr stands for Google Container Registry.\n    ```", "```py\n    <hostname>/<Project ID>/<Image name>\n    ```", "```py\n    docker tag gcloud build command can achieve two steps in one command.\n    ```", "```py\n    gcloud run deploy --image gcr.io/students-run/students\n    ```"]