- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to API Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”The one goal of compassionate communication is to help others suffer less.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Thich Nhat Hanh
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about the concept of **Application Programming
    Interface** , or **API** .
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to API design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete API example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to briefly touch on the HTTP protocol, as it is the infrastructure
    upon which we will build the API. Moreover, since the framework we are going to
    use, **FastAPI** , leverages Type Hinting extensively, you may want to make sure
    you have read *Chapter 12, Introduction to Type Hinting* , as a prerequisite.
  prefs: []
  type: TYPE_NORMAL
- en: After a short general introduction to APIs, we are going to show you a railway
    project, which you can find in its complete state in the source code for this
    chapter, along with its requirements and a README file that explains all you need
    to know to run the API and query it.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI has proven to be the optimal choice for this project. Thanks to its
    capabilities, we have been able to create an API with clean, concise, and expressive
    code. We believe it to be a good starting point for you to explore and expand
    on.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, it is quite likely that you will have to work on APIs, at some
    point in your career. Technology and frameworks evolve all the time, so we recommend
    that you also focus on the theoretical concepts we are going to expose, as that
    knowledge will help you be less dependent on any particular framework or library.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start with HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: The Hypertext Transfer Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **World Wide Web** ( **WWW** ), or simply the **Web** , is a way of accessing
    information using the **Internet** . The Internet is a vast network of networks,
    a networking infrastructure. Its purpose is to connect billions of devices together,
    all around the globe, so that they can communicate with one another. Information
    travels through the Internet in a rich variety of languages, called **protocols**
    , that allow different devices to share content.
  prefs: []
  type: TYPE_NORMAL
- en: The Web is an information-sharing model, built on top of the Internet, which
    employs the **Hypertext Transfer Protocol** ( **HTTP** ) as a basis for data communication.
    The Web, therefore, is just one of several ways information can be exchanged over
    the Internet; email, instant messaging, news groups, and so on, all rely on different
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: How does HTTP work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTTP is an asymmetric **request-response** **client-server** protocol. An HTTP
    client – for example, your web browser – sends a request message to an HTTP server.
    The server, in turn, returns a response message. HTTP is primarily a **pull-based
    protocol** , which means the client pulls information from the server, rather
    than the server pushing it to the client. There are techniques, implemented over
    HTTP, that simulate push-based behavior, for example, long polling, WebSockets,
    and HTTP/2 Server Push. Despite these, the foundation of HTTP remains a pull-based
    protocol, where it is the client that initiates the requests. Look at the diagram
    in *Figure 14.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: A simplified depiction of the HTTP protocol'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is transmitted via the **Transmission Control Protocol/Internet Protocol**
    ( **TCP/IP)** , which provides the tools for a reliable communication exchange
    over the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: An important feature of the HTTP protocol is that it is **stateless** . This
    means that the current request has no knowledge about what happened in previous
    requests. This technical limitation exists for good reasons, but it is easy to
    overcome. In practice, most websites offer the ability to “log in” and the illusion
    of carrying a state from page to page. When a user logs in to a website, a token
    of user information is saved (most often on the client side, in special files
    called **cookies** ) so that each request the user makes carries the means for
    the server to recognize the user and provide a custom interface by showing their
    name, keeping their basket populated, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP defines a set of methods—also known as *verbs* —to indicate the desired
    action to be performed on a given resource. Each of them is different, but some
    of them share some common features. In particular, the ones we will use in our
    API are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET** : The `GET` method requests a representation of the specified resource.
    Requests using `GET` should only retrieve data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST** : The `POST` method is used to submit an entity to the specified resource,
    often causing a change in state or side effects on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT** : The `PUT` method requests that the target resource creates or updates
    its state with the state defined by the representation enclosed in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE** : The `DELETE` method requests that the target resource delete its
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other methods are `HEAD` , `CONNECT` , `OPTIONS` , `TRACE` , and `PATCH` . For
    a comprehensive explanation of all of these methods, please refer to [https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The API we are going to write works over HTTP, which means we will write code
    to perform and handle HTTP requests and responses. We will not keep prepending
    “HTTP” to the terms “request” and “response” from now on, as we trust there will
    not be any confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Response status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to know about HTTP responses is that they include a status code, which
    expresses the outcome of the request in a concise way. Status codes consist of
    a number and a brief description, for example, *404 Not Found* . You can check
    the complete list of HTTP status codes at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Status codes are classified in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '1xx informational response: The request was received, continuing process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2xx successful: The request was successfully received, understood, and accepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3xx redirection: Further action needs to be taken to complete the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4xx client error: The request contains bad syntax or cannot be fulfilled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '5xx server error: The server failed to fulfill a valid request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When consuming the API, we will receive status codes in the responses, so it
    is important that you at least have an idea about what they mean.
  prefs: []
  type: TYPE_NORMAL
- en: APIs – An introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve into the details of this chapter’s specific project, let us
    spend a moment talking about APIs in general.
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of the chapter, API stands for **Application
    Programming Interface** . An API is a set of rules, protocols, and tools for building
    software and applications. It acts as a connection layer between computers, or
    computer programs. In contrast, user interfaces provide a bridge between computers
    and people.
  prefs: []
  type: TYPE_NORMAL
- en: An API is normally accompanied by a *specification document* , or *standard*
    , which serves as a blueprint that outlines how software components are meant
    to interact. A system that meets the specification is said to implement, or expose,
    the API. The term API can describe both the implementation and the specification.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, an API defines the methods and data formats that developers can
    use to interact with a program, a web service, or any other software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly speaking, there are two types of APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Web APIs: Accessible over the Internet, they are often used to enable web applications
    to interact with each other or with backend servers. They are the backbone of
    web development, enabling functionalities such as fetching data from a server,
    posting data, or integrating with third-party services like media platforms, payment
    gateways, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Frameworks and software libraries: These provide a set of functions and procedures
    that perform specific tasks, and help speed up application development by providing
    building blocks to the developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will be focusing on Web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: An API is normally made of different parts. These are known by different names,
    the most common of which are *methods* , *subroutines* , or *endpoints* (we will
    call them endpoints in this chapter). When we use these parts, the technical term
    for this is *calling* them.
  prefs: []
  type: TYPE_NORMAL
- en: The API specification instructs you on how to call each endpoint, what type
    of requests to make, which parameters and headers to pass, which addresses to
    reach, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of an API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several reasons to introduce an API into a system. One we have already
    mentioned is to create the means for different applications to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Another important reason is to give access to a system by providing a layer
    through which the external world can communicate with the system itself.
  prefs: []
  type: TYPE_NORMAL
- en: The API layer takes care of security by performing the **authentication** and
    **authorization** of users, as well as **validation** of all the data that is
    exchanged in the communications.
  prefs: []
  type: TYPE_NORMAL
- en: '*Authentication* means the system can validate user credentials to unequivocally
    identify them. *Authorization* means the system can verify what a user has access
    to.'
  prefs: []
  type: TYPE_NORMAL
- en: Users, systems, and data are checked and validated at the border, and if they
    pass the check, they can interact with the rest of the system (through the API).
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism is conceptually like landing at an airport and having to show
    the border control our passports to be able to interact with the system, which
    is the country we landed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the API layer hides the internals of the systems from the outside
    world provides another benefit: if the internal system changes, in terms of technology,
    languages, or even workflows, the API can adapt the way it interfaces to it, but
    still provide a consistent interface to the public side. If we put a letter into
    a letterbox, we do not need to know or control how the postal service will deal
    with it, as long as the letter arrives at the destination. So, the interface (the
    letterbox) is kept consistent, while the other side (the mail carrier, their vehicles,
    technology, workflows, and so on) is free to change and evolve.'
  prefs: []
  type: TYPE_NORMAL
- en: It should not be surprising that virtually any electronic device we own today,
    that is connected to the Web, is talking to a (potentially wide) range of APIs
    to perform its tasks.
  prefs: []
  type: TYPE_NORMAL
- en: API protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several types of API. They can be open to the public, or private.
    They can provide access to data, services, or both. APIs can be written and designed
    using different methods and standards, and they can employ different protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most common protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypertext Transfer Protocol/Secure (HTTP/HTTPS)** : The foundation of data
    communication for the Web.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Representational State Transfer (REST)** : Technically not a protocol, but
    rather a type of architecture built over HTTP, APIs designed in this style are
    called RESTful APIs. They are stateless and capable of leveraging data caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Object Access Protocol (SOAP)** : A well-established protocol for
    building web services, its messages are normally XML-formatted, and its specification
    is quite strict, which is why this protocol is suitable for situations that require
    high security standards and transactional reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL** : A query language for APIs that employs a type system to define
    the data. Unlike REST, GraphQL uses a single endpoint to allow clients to fetch
    only the data they need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebSocket** : Ideal for applications that require bidirectional communication
    between client and server, as well as real-time data updates. They provide full-duplex
    communication over a single TCP connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote Procedural Call (RPC)** : It allows programmers to execute code on
    the server side by remotely calling a procedure (hence the name). These of APIs
    are tightly coupled with the server implementation, so they are usually not made
    for public consumption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API data-exchange formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said that an API is an interface between at least two computer systems. It
    would be quite impractical, when interfacing with other systems, to have to shape
    the data into whatever format they implement. Therefore, the API, which provides
    the communication layer between systems, specifies not only the communication
    protocols but also which formats can be adopted for the data exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: The most common data-exchange formats today are **JSON** , **XML** , and **YAML**
    . We saw JSON in *Chapter 8, Files and Data Persistence* , and we will use it
    as the format for the API of this chapter too. JSON is widely adopted today by
    many APIs, and many frameworks provide the ability to translate data from and
    to JSON, out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: The railway API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a working knowledge of what an API is, let us turn to something
    more concrete.
  prefs: []
  type: TYPE_NORMAL
- en: Before we show you the code, allow us to stress that this code is not production-ready,
    as that would have been too long and needlessly complex for a book’s chapter.
    However, this code is fully functional, and it should provide you with a good
    starting point to learn more, especially if you experiment with it. We will leave
    suggestions on how to do so at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have a database with some entities that model a railway application. We want
    to allow an external system to perform **CRUD** operations on the database, so
    we are going to write an API to serve as the interface to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**CRUD** stands for **Create** , **Read** , **Update** , and **Delete** . These
    are the four basic database operations. Many HTTP services also model CRUD operations
    through REST or REST-like APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start by looking at the project files, so you will have an idea of where
    things are. You can find them in the folder for this chapter, in the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Within the `api_code` folder, you can find all the files belonging to the FastAPI
    project. The main application module is `main.py` . We have left the `dummy_data.py`
    script in the code, which you can use to generate a new `train.db` , the database
    file. Make sure you read the `README.md` in this chapter’s folder for instructions
    on how to use it. We have also collected a list of queries to the API for you
    to copy and try out, in `queries.md` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `api` package, we have the application modules. The database models
    are in `models.py` , and the schemas used to describe them to the API are in `schemas.py`
    . The other modules’ purposes should be evident from their names: `users.py` ,
    `stations.py` , `tickets.py` , `trains.py` , and `admin.py` all contain the definitions
    of the corresponding endpoints of the API. `util.py` contains some utility functions;
    `deps.py` defines the dependency providers; `config.py` holds the configuration
    settings; `crud.py` contains the functions that perform CRUD operations on the
    database and, finally, `.env.example` is a template for you to create a `.env`
    file to provide settings to your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In software engineering, **dependency injection** is a design pattern in which
    an object receives other objects that it depends on, called dependencies. The
    software responsible for constructing and injecting those dependencies is known
    as the *injector* , or *provider* . Hence, a dependency provider is a piece of
    software that creates and provides a dependency, so that other parts of the software
    can use it without having to take care of creating it, setting it up, and disposing
    of it. To learn more about this pattern, please refer to this Wikipedia page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Dependency_injection](https://en.wikipedia.org/wiki/Dependency_injection)'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When preparing the entity-relationship schema for this project, we sought to
    design something interesting and, at the same time, simple and contained. This
    application considers four entities: *Stations* , *Trains* , *Tickets* , and *Users*
    . A Train is a journey from one station to another one. A Ticket is a connection
    between a Train and a User. Users can be passengers or administrators, according
    to what they are supposed to be able to do with the API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 14.2* , you can see the **entity relationship** ( **ER** ) model
    of the database. It describes the four entities and how they relate to one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: ER model of the database'
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the database models using SQLAlchemy, and we have chosen SQLite
    as the DBMS, for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: If you skipped *Chapter 8, Files and Data Persistence* , this would be a good
    moment to read it, as it will provide you with a foundation to understand the
    models in this chapter’s project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the `models` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As usual, at the top of the module, we import all that is necessary. We then
    define a couple of variables to indicate the default length of Unicode fields
    ( `UNICODE_LEN` ) and the length of the salt used to hash passwords ( `SALT_LEN`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: For a refresher on what a salt is, please refer to *Chapter 9, Cryptography
    and Tokens* .
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define two enumerations: `Classes` and `Roles` , which will be used
    in the models’ definitions. We used the `StrEnum` class as a base, which was introduced
    in Python 3.11, and makes it possible to compare its members directly to strings.
    The `auto()` function automatically generates values for `Enum` attributes. For
    `StrEnum` , it will set the value to the lowercase version of the attribute name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the definition of the `Station` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Station` model is quite straightforward. There are a few attributes: `id`
    acts as the primary key, and then we have `code` , `country` , and `city` , which
    (when combined) tell us all we need to know about a station. There are two relationships
    that link station instances to all the trains departing from, and arriving to,
    them. The rest of the code defines the `__repr__()` method, which provides a string
    representation for instances, and whose implementation is also assigned to `__str__()`
    , so the output will be the same whether we call `str(station_instance)` or `repr(station_instance)`
    . This technique is quite commonly adopted to prevent code repetition.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we defined a unique constraint on the `code` field to ensure that
    no two stations with the same code can exist in the database. Big cities like
    Rome, London, and Paris have more than one train station, so the fields `city`
    and `country` can be the same for stations located in the same city, but each
    of them must have its own unique `code` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that, we find the definition of the `Train` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the `Train` model, we find all the attributes we need to describe a train
    instance, plus a handy relationship, `tickets` , that gives us access to all the
    tickets that have been created against a train. The `first_class` and `second_class`
    fields hold how many first- and second-class cars a train has.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added relationships to station instances: `station_from` and `station_to`
    . These allow us to fetch the station instances as objects, instead of only having
    access to their IDs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `Ticket` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Ticket` has some properties too and includes two relationships: `user` and
    `train` , which point to the user who bought the ticket, and to the train the
    ticket is for, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we have used the `Classes` enumeration in the definition of the `car_class`
    attribute. This translates to an enumeration field in the database schema definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `User` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `User` model defines some properties for each user. Note how here we have
    another enumeration used for the user’s role. A user can either be a passenger
    or an admin. This will allow us to present you with a simple example of how to
    write an endpoint that allows access only to authorized users.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of methods on the `User` model that are used to hash and
    validate passwords. You might recall from *Chapter 9, Cryptography and Tokens*
    , that passwords should never be stored in a database in plain text (which means,
    as they are). So, in our API, when saving a password for a user, we create a hash
    and store it alongside the salt that was used for the encryption. In the source
    code for the book, you will find, at the end of this module, the implementation
    of the `_hash()` function, which we have omitted here for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: Main setup and configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we understand the database models, let us inspect the main entry point
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is all the code in the `main.py` module. It imports the various endpoint
    modules and includes their routers in the main app. By including a router in the
    main app, we enable the application to serve all the endpoints declared using
    that specific router. We will explain what routers are later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There is only one endpoint in the main module, which serves as a greeting message.
    An endpoint is a simple function – in this case, `root()` – that contains the
    code to be executed when a request is made against it. When and how this function
    will be invoked depends on the decorator(s) applied to the function. In this case,
    the `app.get()` decorator instructs the API to serve this endpoint when called
    with a GET request. The decorator accepts an argument to specify the URL path
    on which the endpoint will be served. Here, we use `"/"` to specify that this
    endpoint will be found at the root, which is the base URL on which the app is
    running.
  prefs: []
  type: TYPE_NORMAL
- en: If this API were served at the base URL `http://localhost:8000` , this endpoint
    would be called when we requested either `http://localhost:8000` or `http://localhost:8000/`
    (notice the difference is in the trailing slash).
  prefs: []
  type: TYPE_NORMAL
- en: Application settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within the greeting message from the last snippet of code, there is a variable,
    `api_version` , taken from the `settings` object. All frameworks allow for a collection
    of settings to be injected into the application to configure its behavior. We
    did not really need to use settings in this example project—we could have just
    hardcoded those values in the main module—but we thought it was worth showing
    you how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Settings are defined within a Pydantic model ( [https://github.com/pydantic/pydantic](https://github.com/pydantic/pydantic)
    ). **Pydantic** is a library that provides data validation using Python-type annotations.
    Older versions of Pydantic also provided settings management, but that feature
    has been extracted into a separate library called `pydantic-settings` ( [https://github.com/pydantic/pydantic-settings](https://github.com/pydantic/pydantic-settings)
    ), which also adds additional settings management capabilities. In this case,
    we have three pieces of information within the settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`secret_key` : Used to sign and verify JSON Web Tokens (JWTs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug` : When set to `True` , it instructs the SQLAlchemy engine to log verbosely,
    which is helpful to debug queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api_version` : The version of the API. We do not really make use of this information,
    apart from displaying it in the greeting message, but normally the version plays
    an important role because it is tied to a specific API specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FastAPI plucks these settings from a `.env` file, as specified when we create
    the `SettingsConfigDict` instance. Here is how that file looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For this to work, FastAPI needs help from a library called `python-dotenv` .
    It is part of this chapter’s requirements, so if you have installed them in your
    virtual environment, you are all set.
  prefs: []
  type: TYPE_NORMAL
- en: Station endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to explore some FastAPI endpoints. Because this API is CRUD-oriented,
    there is some repetition in the code. We will therefore show you one example for
    each of the CRUD operations, and we will do so by using the `Station` endpoints
    examples. Please refer to the source code to explore the endpoints related to
    the other models. You will find that they all follow the same patterns and conventions.
    The main difference is that they relate to different database models.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us start our exploration with a GET request. In this case, we are going
    to get all the stations in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Within the `stations.py` module, we start by importing the necessary objects
    from the `typing` module, and from `fastapi` . We also import `Session` from `sqlalchemy`
    , and a few other tools from the local codebase.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint `get_stations()` is decorated with a `router` object, instead of
    `app` like in the main file. `APIRouter` can be thought of as a mini `FastAPI`
    class, in that it takes all the same arguments. We declare `router` and assign
    a prefix to it ( `"` `/stations"` , in this case), which means all functions decorated
    with this router become endpoints that can be called at addresses that start with
    `http://localhost:8000/stations` . In this case, the empty string fed to the `router.get()`
    method instructs the app to serve this endpoint on the root URL for this router,
    which will be the concatenation of the base URL and the router prefix, as explained
    above.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI provides a couple of alternative ways to specify the type of data returned
    from an endpoint. One is to pass a `response_model` argument to the decorator.
    In our case, though, it is enough to specify the return value of the function
    using type annotations. For this endpoint, we return a list of `Station` instances.
    We will see their implementation shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The `tags` argument is used for documentation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The function itself takes some arguments, which are a database session, `db`
    , and an optional string, `code` , which, when specified, will instruct the endpoint
    to serve only the stations whose `code` field matches the one provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few things to notice:'
  prefs: []
  type: TYPE_NORMAL
- en: Data coming with the request, such as query parameters, is specified in the
    endpoint declaration. If the endpoint function requires data to be sent in the
    body of the request, this is specified using Pydantic models (in this project,
    they are defined in the `schemas.py` module).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever an endpoint returns becomes the body of the response. FastAPI will
    try to serialize the returned data to JSON. However, when the response model is
    set, serialization goes first through the Pydantic model specified in `response_model`
    , and then from the Pydantic model to JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use a database session in the body of an endpoint, we use a dependency provider,
    which, in this case, is specified using the `Depends` class, to which we pass
    the `get_db()` `function` . This function yields a local database session and
    closes it when the endpoint call terminates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `Optional` class, from the `typing` module, to specify that parameters
    are optional in a request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the `get_stations()` function simply calls the function of the same
    name from the `crud` module and returns the resulting value. All the functions
    that regulate the interaction with the database live in the `crud.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was a design choice that should make this code easier to reuse and test.
    Moreover, it simplifies reading the entry point code. Let us see the body of `get_stations()`
    in the `crud.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice how similar this function’s signature is to the one for the endpoint
    that calls it. `get_stations()` selects and returns all instances of `Station`
    , optionally filtered by `code` (in case it is not `None` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the API, activate your virtual environment and run the following command
    from within the `api_code` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Uvicorn** is a lightning-fast **ASGI server** , built on `uvloop` and `httptools`
    . It works seamlessly with both normal and asynchronous functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the ASGI documentation page ( [https://asgi.readthedocs.io/](https://asgi.readthedocs.io/)
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '**ASGI** ( **Asynchronous Server Gateway Interface** ) is a spiritual successor
    to **WSGI** ( **Web Server Gateway Interface** ), intended to provide a standard
    interface between async-capable Python web servers, frameworks, and applications.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where WSGI provided a standard for synchronous Python apps, ASGI provides one
    for both asynchronous and synchronous apps, with a WSGI backwards-compatibility
    implementation and multiple servers and application frameworks.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For this chapter’s project, we have chosen to write synchronous code as the
    asynchronous equivalent would have only made the code more difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: If you are comfortable writing asynchronous code, please refer to the FastAPI
    documentation ( [https://fastapi.tiangolo.com](https://fastapi.tiangolo.com) )
    to learn how to write asynchronous endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The `--reload` flag in the `uvicorn` command above configures the server to
    automatically reload whenever a file is saved. It is optional, but quite useful
    for saving time when you are working on the API source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we called the `get_stations()` endpoint, this is what we would see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the command we are using to call the API: `http` . This is a command
    that comes with the **Httpie** utility.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find Httpie at [https://httpie.io](https://httpie.io) . Httpie is a
    user-friendly command-line HTTP client for the API era. It comes with JSON support,
    syntax highlighting, persistent sessions, wget-like downloads, plugins, and more.
    There are other tools to perform requests, such as **curl** . The choice is up
    to you, as it makes no difference which tool you use to make requests from the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: The API is served by default at `http://localhost:8000` . You can add arguments
    to the `uvicorn` command to customize this, if you so desire.
  prefs: []
  type: TYPE_NORMAL
- en: The first few lines of the response are information from the API engine. We
    learn the protocol used was HTTP1.1, and that the request succeeded (status code
    *200 OK* ). We have info on the content length, and its type, which is JSON. Finally,
    we get a timestamp and the type of server. We are going to omit the part of this
    information that just repeats, from now on.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the response is a list of `Station` instances, in their JSON representation,
    thanks to `list[Station` ] type annotation, which we indicated in the function
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to search by `code` , for example, the London station, we could
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The above command uses the same URL as before but adds the `code` query parameter
    (separated from the URL path with a `?` ). The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we got one match, which corresponds to the London station, but still,
    it is returned as a list, as indicated by the type annotation for this endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now explore an endpoint dedicated to fetching a single station by ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For this endpoint, we configure the router to accept GET requests, at the URL
    `http://localhost:8000/stations/{station_id}` , where `station_id` will be an
    integer. Hopefully, the way URLs are constructed is starting to make sense for
    you. There is the base part, `http://localhost:8000` , then the prefix for the
    router, `/stations` , and finally, the specific URL information that we feed to
    each endpoint, which in this case is `/{station_id}` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us fetch the Kyiv station, with ID `3` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice how this time we got back an object by itself, instead of it being wrapped
    in a list like it was in the `get_stations()` endpoint. This is in accordance
    with the type annotation for this endpoint, which is set to `Station` , and it
    makes sense, as we are fetching a single object by ID.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_station()` function takes the `station_id` , type-annotated as an integer,
    and the usual `db` session object. Using type annotations to specify parameters
    allows FastAPI to do data validation on the type of the arguments we use when
    calling an endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to pass a non-integer value for `station_id` , this would happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we had to abridge the error message due to its length. FastAPI responds
    with useful information: `station_id` , from the path, is not a valid integer.
    Notice also that the status code is *422 Unprocessable Entity* , as opposed to
    *200 OK* , this time. In general, errors in the four hundreds ( *4xx* ) express
    client errors, while errors in the five hundreds ( *5xx* ) express server errors.
    In this case, we are making a call using an incorrect URL (we are not using an
    integer). Therefore, it is an error on the client side. Other API frameworks would
    return a simple *400 Bad Request* status code in the same scenario, but FastAPI
    returns *422 Unprocessable Entity* , which is oddly specific. It is easy though,
    in FastAPI, to customize which status would be returned upon a bad request; there
    are examples in the official documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what happens when we try to fetch a station with an ID that does
    not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This time the URL is correct, in that `station_id` is an integer; however, there
    is no station with ID 100. The API returns the *404 Not Found* status, as the
    response body tells us.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go back to the code of this endpoint, you will notice how straightforward
    its logic is: provided that the arguments passed are correct—in other words, they
    respect the type—it tries to fetch the corresponding station from the database
    by using another simple function from the `crud` module. If the station is not
    found, it raises an `HTTPException` with the desired status code (404) and a detail
    that will hopefully help the consumer understand what went wrong. If the station
    is found, then it is returned. The process of returning a JSON serialized version
    of objects is done automatically by FastAPI. The object retrieved from the database
    is a SQLAlchemy instance of the `Station` class ( `models.Station` ). That instance
    is fed to the Pydantic `Station` class ( `schemas.Station` ), which is used to
    produce a JSON representation that is then returned by the endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem complicated, but it is an excellent example of decoupling.
    FastAPI takes care of the workflow, and all we need to do is take care of the
    wiring: request parameters, response models, dependencies, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us now see something a bit more interesting: how to create a station. First,
    the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we instruct the router that we want to accept a POST request to
    the root URL (remember: base part, plus router prefix). We type-annotate the return
    to be `Station` , as the endpoint will be returning the newly created object,
    and we also specify the default status code for the response, which is `201 Created`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The `create_station()` function takes the usual `db` session and a `station`
    object. The `station` object is created for us, behind the scenes. FastAPI takes
    the data from the body of the request and feeds it to the Pydantic schema `StationCreate`
    . That schema defines all the data we need to receive, and the result is the `station`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic in the body follows this flow: it tries to get a station using the
    code provided; if a station is found, we cannot create one with that data. The
    code field is defined to be unique. Therefore, creating a station with the same
    code would result in a database error. Hence, we return status code *400 Bad Request*
    , informing the caller that the station already exists. If the station is not
    found, we can instead proceed to create it and return it. Let us see the declaration
    of the Pydantic schemas involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note how we used inheritance to define the schemas. It is normal practice to
    have a base schema that provides functionalities common to all children. Then,
    each child specifies its needs separately. In this case, in the base schema, we
    have `code` , `country` , and `city` . When fetching stations, we also want to
    return the `id` , so we specify that in the `Station` class. Moreover, since this
    class is used to translate SQLAlchemy objects, we need to tell the model about
    it, and we do so by specifying the `model_config` attribute. Remember that SQLAlchemy
    is an **object-relational mapping** ( **ORM** ), so we need to tell the model
    to read the attributes of an object by setting `from_attributes=True` .
  prefs: []
  type: TYPE_NORMAL
- en: The `StationCreate` model does not need anything extra, so we simply use the
    `pass` instruction as a body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see the CRUD functions for this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `get_station_by_code()` function is fairly simple. It selects a `Station`
    object with a case-insensitive match on `code` (the “i” prefix in `ilike()` means
    case-insensitive).
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to perform a case-insensitive comparison, which do not
    involve using `ilike` . Those might be the right way to go when performance is
    important, but for this chapter’s purpose, we found the simplicity of `ilike`
    to be exactly what we needed.
  prefs: []
  type: TYPE_NORMAL
- en: The `create_station()` function takes a `db` session and a `StationCreate` instance.
    First, we get the station data in the form of a Python dictionary (by calling
    `model_dump()` ). We know all data must be there; otherwise, the endpoint would
    have already failed during the initial Pydantic validation stage.
  prefs: []
  type: TYPE_NORMAL
- en: Using the data from `station.model_dump()` , we create an instance of the SQLAlchemy
    `Station` model. We add it to the database, commit the transaction, and return
    it. Note that when we initially create the `db_station` object, it does not have
    an `id` attribute. The `id` is automatically assigned by the database engine when
    the row is inserted into the `stations` table (which happens when we call `db.commit()`
    ). SQLAlchemy will automatically set the `id` attribute when we call `commit()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see this endpoint in action. Notice how we need to specify `POST` to
    the `http` command, which allows us to send data, in JSON format, within the body
    of the request. Previous requests were of the GET type, which is the default type
    for the `http` command. Notice also that we have split the command over two lines
    due to the book’s line length constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We successfully created a station. Let us now try again, but this time omitting
    the code, which is mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we get a *422 Unprocessable Entity* status code again, because
    the Pydantic `StationCreate` model validation failed, and the response body tells
    us why: `code` is missing in the body of the request. It also provides a useful
    link to look up the error.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logic to update a station is a bit more complex. Let us go through it together.
    First, the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The router is instructed to listen for a PUT request, which is the type you
    should use to modify a web resource. The URL terminates with the `station_id`
    , which identifies the station we want to update. The function takes the `station_id`
    , a Pydantic `StationUpdate` instance, and the usual `db` session.
  prefs: []
  type: TYPE_NORMAL
- en: We start by fetching the desired station from the database. If the station is
    not found in the database, we simply return a *404 Not Found* status code, as
    there is nothing to update. Otherwise, we update the station and return a *204
    No Content* status code, which is the common way to respond to a PUT request.
    We could also have returned *200 OK* , but in that case, we should have returned
    the updated resource within the body of the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pydantic model for a station update is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All properties are declared as `Optional` because we want to allow the caller
    to pass only what they wish to update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the code for the CRUD function responsible for updating a station:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `update_station()` function takes the necessary arguments to identify the
    station to update, and the station data that will be used to update the record
    in the database, plus the usual `db` session.
  prefs: []
  type: TYPE_NORMAL
- en: We build a statement using the `update()` helper from `sqlalchemy` . We use
    `where()` to filter the station by `id` , and we specify the new values by asking
    the Pydantic station object to give us a Python dictionary excluding anything
    that has not been passed to the call. This serves the purpose of allowing partial
    updates to be executed. If we omitted `exclude_unset=True` from the code, any
    argument that was not passed would end up in the dictionary, set to its default
    value ( `None` ).
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, we should use a PATCH request to do a partial update, but
    it is fairly common to use PUT for both complete and partial updates.
  prefs: []
  type: TYPE_NORMAL
- en: We execute the statement and return the number of rows affected by this operation.
    We do not use this information in the endpoint body, but it would be a nice exercise
    for you to do it. We will see how to make use of that information in the endpoint
    that deletes a station.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us use this endpoint on the station we created in the previous section,
    with ID `12` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We got what we expected. Let us verify that the update was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'All three properties of the object with ID `12` have been changed. Let us now
    try a partial update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we only updated the station code. Let us verify again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As expected, only `code` was changed.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let us explore how to delete a station. As usual, let us start with
    the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To delete stations, we instruct the router to listen for a DELETE request. The
    URL is the same one we used to get a single station, as well as to update one.
    It is the HTTP verb we choose that triggers the right endpoint. The `delete_station()`
    function takes `station_id` and the `db` session.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the body of the endpoint, we get the number of rows affected by the operation.
    In this case, if there is one, we return a *204 No Content* status code, which
    tells the caller that the deletion was successful. If no rows were affected, we
    return a *404 Not Found* status code. Notice that we could have written the update
    method exactly like this, making use of the number of affected rows, but we chose
    another approach there so that you had a different example to learn from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the `CRUD` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function makes use of the `delete()` helper from `sqlalchemy` . Similar
    to what we did for the update scenario, we create a statement that identifies
    a station by ID and instructs for its deletion. We execute the statement and return
    the number of affected rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see this endpoint in action, on a successful scenario first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We got a *204 No Content* status code, which tells us the deletion was successful.
    Let us verify it indirectly by trying to delete the station with ID `12` again.
    This time we expect the station to be gone, and a *404 Not Found* status code
    in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we received a *404 Not Found* status code, which means a station
    with ID 12 was not found, proving that the first attempt to delete it was successful.
    There are a few more endpoints in the `stations.py` module, which you should check
    out.
  prefs: []
  type: TYPE_NORMAL
- en: The other endpoints we have written are there to create, read, update, and delete
    users, trains, and tickets. Apart from the fact that they act on different database
    and Pydantic models, they would not really bring any more insight to this exposition.
    Therefore, let us instead look at an example of how to authenticate a user.
  prefs: []
  type: TYPE_NORMAL
- en: User authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authentication, in this project, is done via a JWT. Once again, please refer
    to *Chapter 9, Cryptography and Tokens* , for a refresher on JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start from the authentication endpoint, in the `users.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This router has the prefix `"` `/users"` . To authenticate a user, we need to
    make a POST request to this endpoint. It takes a Pydantic `Auth` schema, the usual
    `db` session, and the `settings` object, which is needed to provide the secret
    key that is used to create the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user is not found, we return a *404 Not Found* status code. If the user
    is found, but the password provided does not correspond to the one in the database
    record, we return status code *401 Unauthorized* . Finally, if the user is found
    and the password is correct, we create a token with two claims: `email` and `role`
    . We will use the role to perform authorization functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_token()` function is a wrapper around `jwt.encode()` that also
    adds a couple of timestamps to the payload of the token. It is not worth showing
    that code here. Let us instead see the `Auth` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We authenticate users with their email (which serves as the username) and password.
    That is why, in the SQLAlchemy `User` model, we have set up a uniqueness constraint
    on the `email` field. We need each user to have a unique username, and email is
    a commonly used field for this need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us exercise this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We got a token back (abridged, in the snippet), so we can use it. The user
    we have authenticated is an admin, so we are going to show you how we could have
    written the endpoint to delete a station if we wanted to allow only admins to
    do so. Let us see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, you can see that the endpoint declaration and body are nearly
    the same as their naïve counterpart, with one important difference: before attempting
    to delete anything, we call `ensure_admin()` . In the endpoint, we need to grab
    the authorization header from the request, which is responsible for bearing the
    token information, so that we can pass it to the `ensure_admin()` function. We
    do this by declaring it in the function signature, as an optional string that
    comes from the `Header` object.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ensure_admin()` function delegates to the `util.is_admin()` function, which
    unpacks the token, verifies its validity, and inspects the `role` field within
    the payload to see if it is that of an admin. If all the checks are successful,
    it returns `True` , or `False` otherwise. The `ensure_admin()` function does nothing
    when the check is successful but raises an `HTTPException` with a *403 Forbidden*
    status code when the check is unsuccessful. This means that if, for any reason,
    the user is not authorized to make this call, the execution of the endpoint’s
    body will immediately stop and return after its first line.
  prefs: []
  type: TYPE_NORMAL
- en: There are more sophisticated ways to do authentication and authorization, but
    it would have been impractical to fit them within the chapter. This simple example
    is good enough as a start to understand how to implement this feature in an API.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Documenting APIs is a tedious activity. One advantage of using FastAPI is that
    you do not need to document your project: the documentation is automatically generated
    by the framework. This is possible thanks to the use of type annotations and Pydantic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure your API is running, then open a browser and navigate to `http://localhost:8000/docs`
    . A page will open that should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_14_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: A partial screenshot of FastAPI self-generated documentation'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 14.3* , you can see a list of endpoints. They are categorized using
    the `tags` argument, which we have specified in each endpoint declaration. This
    documentation not only allows you to inspect each endpoint in detail but is also
    interactive, which means you can test the endpoints by making requests directly
    from the page.
  prefs: []
  type: TYPE_NORMAL
- en: Where do we go from here?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should now have a basic understanding of API design and main concepts.
    Of course, studying this chapter’s code will deepen your understanding and likely
    provoke questions. Here are some suggestions if you wish to learn more on the
    subject:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn FastAPI well. The website offers tutorials both for beginners and advanced
    programmers. They are quite thorough and cover much more than we could ever include
    in a single chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the source code from this chapter, enhance the API by adding advanced
    searching and filtering capabilities. Try implementing a more sophisticated authentication
    system and exploring the use of background tasks, sorting, and pagination. You
    could also expand the admin section by adding other endpoints only for admin users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amend the endpoint that books a ticket so that it checks that there are free
    seats on the train. Each train specifies how many first- and second-class cars
    there are, as well as the number of seats per car. We designed the train model
    this way specifically to allow you to practice with this exercise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add tests for the existing endpoints, and for anything else you add to the source
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about WSGI ( [https://wsgi.readthedocs.io/](https://wsgi.readthedocs.io/)
    ) and, if you are familiar with asynchronous programming, ASGI, its asynchronous
    equivalent ( [https://asgi.readthedocs.io/](https://asgi.readthedocs.io/) ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about middleware in FastAPI, and concepts like **Cross-Origin Resource
    Sharing (CORS** ), which are important when we run an API in the real world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn other API frameworks, like Falcon ( [https://falcon.readthedocs.io/](https://falcon.readthedocs.io/)
    ), or Django Rest Framework ( [https://www.django-rest-framework.org](https://www.django-rest-framework.org)
    ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about Representational State Transfer (REST). It is used everywhere,
    but there are different ways to write APIs with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about more advanced API concepts, such as versioning, data formats, protocols,
    and so on. Learn what headers can do more in-depth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if you are familiar with asynchronous programming, we recommend rewriting
    the code for this chapter so that it is asynchronous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to set `DEBUG=true` in the `.env` file, when working with the API,
    so that you get all the database queries logged automatically in your terminal,
    and you can check if the SQL code they produce reflects your intentions. This
    is quite a handy tool to have when SQLAlchemy operations become a bit more complex.
  prefs: []
  type: TYPE_NORMAL
- en: API design is such an important skill. We cannot emphasize enough how essential
    it is for you to master this subject.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of APIs. We started with a brief overview
    of the Web and moved on to FastAPI, which leverages type annotations. Those were
    introduced in *Chapter 12, Introduction to Type Hinting* .
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed APIs in generic terms. We saw different ways to classify them,
    and the purposes and benefits of their use. We also explored protocols and data-exchange
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we delved into the source code, analyzing a small part of the FastAPI
    project that we wrote for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded the chapter with a series of suggestions for the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter discusses developing CLI applications with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_14.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
