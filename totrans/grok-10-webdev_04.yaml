- en: Chapter 4. Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Chapter 3, we learned how to display information on a web page by using
    views. In fact, as we saw, the view machinery is powerful enough to create complete
    applications, like our to-do list manager. We''ll now turn our attention to where
    the data for these views comes from: the content objects, or models that define
    Grok applications. Here''s a list of what we''ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What a model is and what relationship it has with views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to persist model data on the ZODB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to structure our code to maintain the separation of display logic from application
    logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a container is and how to use one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use multiple models and associate specific views to each
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Grok introspector to navigate models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models and applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the views do the actual work of showing our data and handling user
    interaction, they are just one possible way of displaying the data. In the previous
    chapter, we started with a very simple view with no styles or client-side scripting,
    and by the end of the chapter, we had a completely different looking application.
    What remained constant throughout was the thing we were working with: to-do lists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we added lists or list items and checked off items, we were interacting
    with the model for our application, which in this case was defined with just two
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A Grok application is composed of one or more models. The models can be simple
    Python objects, but generally use `grok.Model` as a base class. The main model
    of an application should inherit from `grok.Application` as well, which is what
    happens in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: The model contains the application data and all of the logic that's not directly
    related to how this data is shown. In the case of our to-do list manager, the
    model consists of only a `todolists` class attribute that holds all the lists
    and their items.
  prefs: []
  type: TYPE_NORMAL
- en: Even though this model is so simple, the views work for the model and not the
    other way around. If we look at the code in both the `index` and `check` views,
    we'll see that every time something important happens the value of `self.context.todolists`
    is modified. As we mentioned before, all views have a `context` attribute that
    refers to their associated model. Through it, views can access all of the attributes
    of this model.
  prefs: []
  type: TYPE_NORMAL
- en: Storing model data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we can create and manage lists successfully, but once we restart the
    application we lose all the data. We need a way to persist the information.
  prefs: []
  type: TYPE_NORMAL
- en: For web applications, this usually means creating some tables in a relational
    database and storing the information by using direct SQL queries or an **Object
    Relational Mapper** (**ORM**). An ORM is a good solution as it takes our objects
    and transparently stores their attributes in the corresponding tables. Each time
    we need to work with our objects, the ORM reassembles them from the database once
    again, without the need for us to worry about SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grok can store data in relational databases using plain SQL as well as a diverse
    range of ORMs for Python, such as SQLAlchemy ([http://www.sqlalchemy.org](http://www.sqlalchemy.org))
    or Storm ([https://storm.canonical.com](https://storm.canonical.com)). However,
    Grok gives us another interesting option that is a more natural fit for our Python
    objects, and can work even more transparently than ORMs: the **Zope Object Database**
    (**ZODB**).'
  prefs: []
  type: TYPE_NORMAL
- en: The ZODB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed the ZODB in the first chapter, where we mentioned that it is very
    well integrated with Grok. We'll show a simple example of storing data now, and
    come back to the details, later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, the to-do list manager application has its title defined inside
    the`<h1>` tag on the `index` template. Let''s give each application instance a
    `title` attribute, so that the user can set the title himself. First, we''ll replace
    the simplistic model definition that we have been using so far with more realistic
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have added an `__init__` method that is called when the application is created.
    Inside this method, we make sure that we call the superclass' `__init__` method
    as well, so that our method extends, rather than replaces the original code. We
    then define two instance attributes, `title` and `todolists`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, there are two kinds of objects: **mutable objects**, which can have
    their values changed, and **immutable objects**, that cannot. For immutable objects,
    such as strings or numbers, we gain automatic persistence in the ZODB merely by
    inheriting from `grok.Model`. In the case of the title, now we can transparently
    store it in the ZODB. The `todolists`, as they are stored inside a list (a mutable
    object), need a little more work, but we''ll get to them later.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the title dynamically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a `title` attribute, we can modify the `index.pt` template
    to show that, instead of the old text. Both the`<title>` and`<h1>` tags need a
    `tal:content` statement, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the template will use whatever title is stored in the application instance.
    Now we need a way for the user to set the title. Let''s create a simple Ajax view
    that can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All this does is checks for the key `new_title` in the request, and sets the
    `title` attribute to its value. As we did with the `Check` view back in Chapter
    3, the response does not use a template, but a simple Python code that returns
    plain text. We just return the `title` attribute that was changed in the `update`
    method, so that the JavaScript callback function can change it immediately after
    it's set.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, we use a couple of JavaScript functions to produce an *edit-in-place*
    effect, so that the user can click on the title and change it right there. We
    won''t go into the code here, but you can find it in the Chapter 4 directory in
    the book''s code package. You can look at the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the title dynamically](img/7481_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we run the application now, it will be possible to edit the title, restart
    the application, and see that its value is saved across server restarts. One word
    of warning though: because we added an attribute to the application instance inside
    the `__init__` method, it''s necessary to delete any existing application instances
    before trying this code. That''s because the `title` attribute is added at the
    time of application creation, when the `__init__` method is run, which didn''t
    happen when we created applications in the previous chapter. If we try to use
    an older application instance, we''ll get an attribute error when we try to access
    the `title` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The rules of persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, the `todolists` attribute will not get persisted to
    the ZODB that easily. The reason is that whenever changes are made to mutable
    attributes, the application needs to inform the ZODB that there has been a change.
    This is done by setting the special `_p_changed` attribute of the instance to
    `True.`
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the `todolists` attribute, all we have to do is set `_p_changed`
    to `True` after any modification to the attribute. We''ll just need to add this
    code at the end of the `update` methods in the index and check views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Thankfully, this is the only rule that we have to keep in mind when working
    with the ZODB in Grok. Well, there are a few more rules, but Grok already follows
    them, so this is the only one that will require us to modify the code. Let''s
    look at the rules of persistence for the ZODB:'
  prefs: []
  type: TYPE_NORMAL
- en: Inherit from `persistent.Persistent` (a class defined in the ZODB code) or one
    of its subclasses. The Grok classes, `grok.Model` and `grok.Container` already
    do this for us, so by extending them we will automatically persist our classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class instances have to be related to each other in a hierarchical structure.
    The ZODB has a root object and this object contains other objects, which can in
    turn contain some other objects, forming a tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When modifying mutable attributes of persistent objects that are not persistent
    themselves, the persistence machinery has to be notified, by setting the special
    `_p_changed` attribute of the instance to `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like we said, Grok follows these rules, so that by using Grok's models and containers
    we automatically have persistent data storage for our applications. In this way,
    we can think only in terms of classes and attributes instead of translating them
    back and forth in our minds (and code) into tables and columns.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we have to do to store the to-do lists inside the ZODB. We almost
    have a complete application, so now let's focus on how to better structure our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Display logic and application logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We keep talking about the separation of display and application logic, but our
    code so far is clearly not enforcing this rule. The model only holds the lists
    and everything else happens inside the views.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that our views need to know too much about
    how the model is implemented, and it becomes very hard to change it without needing
    to modify some or all of the views.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we add a list item in the `update` method of our index view,
    we have to know that list items are stored as dictionaries with `description`
    and `check` keys . We also have to know that the list of items is stored under
    the key items in a dictionary representing the list itself. These are too many
    internal details, and writing view code, which relies on this knowledge may require
    heavy modifications to it, if the model implementation changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Worse, relying on this knowledge makes our code more repetitive than it should
    be, and forces us to make the same change in multiple places when there are modifications.
    Look at this line of code from the to-do list manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We only have two views, and this line shows up in both of them. If we add more
    views and need to look at the items from some list in them, we'll have to repeat
    this code again. Now suppose we add projects to our application and wish to store
    the lists inside a project. In this case, we would have to change every occurrence
    of this line in every view, to reflect the new structure.
  prefs: []
  type: TYPE_NORMAL
- en: This is why separation of display and application logic is so important. It
    helps to structure our applications and allows us to change the way the data is
    displayed without modifying its internal representation, or the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Separating display and application logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's think about how we could restructure the application so that this principle
    is taken into account. Remember, the model shouldn't know anything about how it
    is displayed and the views should not depend on any implementation details from
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could start by adding some method to the model to add lists and get all
    the items from a list, so that we can call these new methods from the view and
    stop depending on how list data are stored in the main list of the to-do lists.
    We might be tempted to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, we must resist the temptation. If we go down this path, our code will
    be filled with `self._p_changed` lines, and we'll be passing list indexes around
    like crazy. Having the to-do lists represented as a simple list is really not
    the way to go. We should instead use a more carefully designed model, and take
    full advantage of Grok's model classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using containers and multiple models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we are using `grok.Model` as a base class for our application,
    which mostly buys us nearly transparent ZODB storage, as we have seen. Most non-trivial
    applications, however, will require more than one type of object to be useful.
    Also, it's fairly common to organize application data using parent and child relationships,
    so that one main object is the parent and contains a number of child objects.
    In our to-do list manager application, the main application is a container of
    to-do lists and each list in turn can contain a number of items.
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a very common pattern, Grok offers a `grok.Container` class
    which allows us to store other models and also handles ZODB persistence. Using
    it, we can structure our code better, simplify it, and also eliminate the need
    to signal to the framework every time a change is made to a list or one of its
    items (no more `self._p_changed` lines). Instead of dealing with an ad hoc list
    structure and keeping track of indexes, we can think about list objects and item
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding containers to our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conceptually, then, our application will consist of a container of lists. A
    list object will also be a container, where the items will be stored. Let''s start
    by defining the main model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not very different from what we had before. The important change is
    that we now inherit from `grok.Container` instead of `grok.Model`. This will allow
    the application to store list objects. We also define a `next_id` attribute to
    create identifiers for the lists. OK, let''s define the list model now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A list has `title` and `description` attributes, both mandatory parameters at
    instance creation. As with the list model, we also define a `next_id` attribute
    to keep track of individual items. Notice that `grok.Application` is not a base
    class here, because this is a model that will be used by the application defined
    earlier. In some cases, we could have a need for more than one application in
    a project, and technically we could define both in the same file, but generally
    it's suggested that we use a separate file for different applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TodoList` class is also a `grok.Container` because it will contain to-do
    items. These items will not contain other types of models, so the list item class
    definition will simply be a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `TodoItem` class just inherits from `grok.Model`. It only has a `description`
    attribute, which is a mandatory parameter at instance creation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding behavior to the models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our application model structured, we should think about which
    model will perform which actions. We are talking about the different actions,
    such as list and item creation, that our application performs. However, in the
    previous version they were crowded inside the `update` method of the `index` view.
    With a clean model structure we can now separate these actions and put each one
    where it better belongs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main application is the list manager, so the methods for list creation
    and deletion should be added to the `Todo` class. Let''s get going with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `addList` method takes a `title` and `description` and simply creates an
    instance of `TodoList`. The new list is stored in the container using a key, just
    like a Python dictionary works (in fact, it supports the same methods, such as
    keys, values, and items). The key is generated using the `next_id` attribute that
    we discussed earlier, which is then incremented for the next list creation.
  prefs: []
  type: TYPE_NORMAL
- en: The `deleteList` method is even simpler, as we just need to delete the desired
    key from the dictionary using the `del` statement. As promised, notice the absence
    of any code dealing directly with persistence. The lists will be correctly stored
    in the ZODB without the need for explicit notification.
  prefs: []
  type: TYPE_NORMAL
- en: The TodoList model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s turn our attention to the `TodoList` model. We need a way to add
    and delete items, similar to what we did with the main application. Also, if we
    want to keep our non-JavaScript-enabled version of the application working, we
    need a way to change the `checked` status of multiple items at the same time.
    Here''s the code that we have to add to the `TodoList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `addItem` method is almost a verbatim copy of the `addList` method that
    we saw earlier. We use the `next_id` pattern to create the ID, and create a new
    instance of `TodoItem`. The `deleteItem` method is identical to the `deleteList`
    method discussed earlier. The `updateItems` method is different because it expects
    a list of item IDs to mark as checked. We iterate through all of the items in
    the list and set their `checked` attribute to `True` if they are on the received
    list, or set it to `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TodoItem` model is the simplest of the three. We can directly set the
    `checked` attribute to `True` or `False`, so we probably don''t need separate
    methods to do that. We will only add a convenience method to toggle the `checked`
    state of an item, without requiring us to know the current state. This will be
    useful for the Ajax-enabled check view that we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `toggleCheck` method simply sets the value of the `checked` attribute of
    the `TodoItem` to the opposite of the current value, thus acting as a toggle.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a complete model that uses Grok's features and includes all of the
    application logic. The views will now be able to perform the display work without
    messing with the application's internals.
  prefs: []
  type: TYPE_NORMAL
- en: Reorganizing the views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Speaking of views, we need to refactor those, too. So far, we have been doing
    everything with only one view, but this needs to change. We'd like to keep the
    application as having one single main view and showing all modifications to the
    different models on the same page, but method calls to each model's actions should
    come from the views associated with that model. This is because in this way Grok
    will take care of setting the context for the view correctly, and we will not
    have to worry about making sure that we act on the correct model in our code.
    Remember that earlier we used a hidden`<input>` tag with a list index to tell
    our `update` method on which list we wanted to operate. We don't need to do this
    anymore if we associate our views with the right models.
  prefs: []
  type: TYPE_NORMAL
- en: For the main application, then, we will keep the `index` view and the `setTitle`
    views. We'll also add views for calling the `addList` and `deleteList` methods.
    The new `TodoList` model will have a view for each of its three actions, which
    are `addItem, deleteItem`, and `updateItem`. For the `TodoItem` model, we'll reuse
    the existing `check` view, but the one associated with this model instead of the
    main application.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. So, previously we had a single model with three views, but now we
    have three models, and each will require a couple of views. How will Grok know
    which views are associated with which model?
  prefs: []
  type: TYPE_NORMAL
- en: Introducing class annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of Grok's conventions is that all views defined in a module where there's
    only one model definition will be associated with this model. Grok knows that
    this is the only possibility, and so automatically sets the `context` attribute
    on all views to be this model. Now that we have three models, each view that we
    create has to explicitly tell Grok to which model it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism Grok uses to do this is called a **class annotation**. Grok has
    many conventions that help it decide what to do when no information is available,
    but we can certainly tell Grok what to do when we need to. A class annotation
    is just a declarative way of telling Grok something about a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explicitly associate a view with a model, we use the `grok.context` class
    annotation. This class takes as a parameter the model to which we want to associate
    a view. Let''s redefine our `index` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use the `grok.context` class annotation to tell Grok that this view will
    work with the `Todo` model as context. This is in fact all of the code that we
    need for this view, as we have separated the model responsibilities into three
    different views. No more gigantic `update` methods full of `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Before going on with the other views, let's think a bit about how `index` views
    work. As we saw in the previous chapter, if a view has the name `index` it will
    be treated as the default view for a model. We also learned that the name of a
    view is automatically given by the lowercase version of its own class name. Now,
    for the case where we have more than one model and for each of them we want to
    have a default view, how do we name the view classes? There can't be two `Index`
    classes defined in the same module.
  prefs: []
  type: TYPE_NORMAL
- en: Setting view names explicitly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you guessed that class annotations would come into play again, you were
    absolutely right. For cases like these, we have the `grok.name` class annotation,
    which can be used to explicitly set the name of a view. Right now, we need only
    one `index` view in our code, but we may need to add default views for the other
    models later, so we might as well change the code at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We change the view class name to `TodoIndex`, which would result in URLs with
    the name `todoindex`. We then use the `grok.name` annotation to set the view name
    to `index`, thus allowing us to call the default view without using its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the action views for this model. First, the `addlist`
    view, which will be used to add new lists to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `TodoAddList` view is also associated with the `Todo` model, but uses a
    different name. This view will be called when the user fills the create list form
    and clicks on the submit button.
  prefs: []
  type: TYPE_NORMAL
- en: Notice in this code how the `update` method is just one line long. We just call
    the `addList` method of the `context` and pass the two required parameters to
    it. No need to grapple with form parameters or make `if` checks to see what action
    is desired.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this application we want the index page to show all changes immediately.
    Therefore, in the `render` method, instead of using a template to produce HTML,
    or sending a plain text string as we have done before, we perform a redirection
    to the index view, using the `redirect` method available to the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `deletelist` view is very similar to the `addlist` view. We hadn''t implemented
    this functionality in the initial version of our application, but you''ll see
    it''s really cheap to do that now that we have the proper structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We just use a different name and call the `deleteList` method of the model,
    but otherwise the code is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last view for the `Todo` model is the `setTitle` view that we added at
    the beginning of this chapter. Here''s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we keep the old behavior of returning the new title when rendering.
    The only change here is that the association with the model is explicit, and we
    give it a different name than its class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three views associated to the `TodoList` model are almost carbon copies
    of the `addlist` and `deletelist` views of the `Todo` model. Let''s take a look
    and talk about what''s different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the three of them use the `grok.context` annotation to associate
    themselves with the `TodoList` model. The `update` methods of all three are very
    similar to the other ones, and just call the correct `update` method from the
    `context`, which in this case we know is a `TodoList` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `redirect` call on the `render` method is a little different, though. As
    the context is a `TodoList` and we want to show the index view for the `Todo`
    model, we need to get at the container of this list to pass it to the `url` function
    of the view, so that it can generate the correct URL. To do this, we use another
    characteristic of a Grok model object, a `__parent__` attribute, which points
    to its container. As we know that the list is contained by the `Todo` model, we
    can get at it in this way. Model objects also have a `__name__` attribute, which
    stores the key that is used to access the object inside its container. We'll use
    that in a minute when we see how the index template has to change to accommodate
    the new model structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the `TodoItem` model, we just need the `check` view that was already
    used in the previous version of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are a few differences. The view is now explicitly associated with the
    `TodoItem` model using `grok.context`, obviously. Also, we now call the new `toggleCheck`
    method of the `TodoItem` instead of making the change in the view. Finally, we
    construct the ID for the`<div>` tag that the view will be returning, by using
    the `__parent__` and `__name__` attributes of the model. In this way, we avoid
    the need to have list and item indexes passed as view parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a much better separation of application and display logic in our
    to-do list manager application. Let''s see how this impacts the code for the `index`
    view, which now has to display data from three models instead of one. Look at
    the code for the loop that shows the lists and their items. First, note that we
    now iterate over the lists using `context/values` instead of the list elements
    that we had in the old model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After that, we define the `todo` list form. Notice how we use `view.url()` to
    generate the correct URL for posting the form. Remember that this function works
    by passing the object for which we want to generate a URL and an optional view
    name to append to it. In the following code, the action for the first form is
    defined by calling the `view url` method, passing the current `todolist` object
    and the `updateitems` view name to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the code to delete a list. Take a look at how we use the `__name__`
    attribute to create URLs that include the name of the object that we are interested
    in. In this way, methods that expect a key to work will receive it directly from
    this view. We don''t need to do any list and item index calculations, or add hidden
    fields with list data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the form has very similar changes, which are mostly the use of `__name__`
    and `view.url:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the form for adding list items now also uses `view.url` to generate
    the form action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: One would think that having to use three models could complicate things in the
    view, but we actually have to use less code this time around. It's also a lot
    cleaner. Instead of a big form with multiple submit buttons that all go to the
    same `update` method in the same view, we now use several forms, and direct the
    form submissions to the respective view by using `view.url()` to generate the
    correct URL in each case.
  prefs: []
  type: TYPE_NORMAL
- en: Other than these changes, the code for the template is mostly the same as we
    already had, so no big changes are required to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: The Grok introspector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we now have a fully working application. Play with it a little and create
    some lists and tasks. Everything will be safely stored inside the ZODB.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now take a quick look at one tool that Grok offers that can be very helpful
    to understand object relationships and responsibilities when we are dealing with
    applications developed by someone else (or revisiting applications we wrote years
    ago).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Grok introspector is a tool that is accessible from the application list
    at `http://localhost:8080/applications`. Go there and, under **Installed Applications**,
    you''ll see your instance of the `Todo` application. The application name is a
    link to run it, but to the right of that name there is a link that says **object
    browser**. Click on this link and you''ll see something similar to the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Grok introspector](img/7481_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we can see the data from the current instance of the `Todo` model.
    Notice how the parent information used for the `__parent__` attribute is there
    at the top. Below we can see the base classes of the object, which we know are
    `grok.Application` and `grok.Container`. Under the **Base classes** section there
    is an **Interfaces provided** section. We'll have more to say about interfaces
    later, so for now let's skip that.
  prefs: []
  type: TYPE_NORMAL
- en: Below that you can see a section called **Attributes and Properties**. Under
    **Attributes**, you'll find the `title` and `next_id` attributes of the `Todo`
    model, with their current values. Then comes the **Mappings** section, where the
    values for all of the objects stored in this container are shown. If you click
    on any of these values, you'll get a page with the data for the corresponding
    model instance, so you can easily navigate the whole data structure produced by
    the application and look at the information within.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the names and documentation strings for all of the methods of the object
    are shown. Try adding a documentation string to a method of our application, and
    you will see it reflected in that section (after a server restart, of course).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we extended our demonstration application using models. The
    amount of code did not increase greatly from the previous chapter, but we have
    a much more elegant and better-structured application. The code is also more maintainable
    and pretty extensible, as we'll learn next when we deal with forms in Grok.
  prefs: []
  type: TYPE_NORMAL
