- en: Using Constraints, Filtering, Searching, Ordering, and Pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take advantage of many features included in the Django
    REST framework to add constraints, pagination, filtering, searching, and ordering
    features to our RESTful Web Service. We will add a huge amount of features with
    a few lines of code. We will gain an understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Browsing the API with resources and relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining unique constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with unique constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring pagination classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making requests that paginate results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with customized pagination classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making requests that use customized paginated results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring filter backend classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding filtering, searching, and ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with different types of Django filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making requests that filter results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing requests that filter and order results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making requests that perform starts with searches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the browsable API to test pagination, filtering, searching, and ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browsing the API with resources and relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take advantage of the browsable API feature that we introduced in [Chapter
    5](dj-rst-websvc_ch15.html),* Understanding and Customizing the Browsable API
    Feature*, with our new web service. Let's start browsing our new RESTful Web Service.
    Open a web browser and enter `http://localhost:8000`. The browser will compose
    and send a `GET` request to `/` with `text/html` as the desired content type,
    and the returned HTML web page will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request will end up executing the `GET` method defined in the `ApiRoot`
    class within the `views.py` file. The following screenshot shows the rendered
    web page with the resource description Api Root:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e6c4e6e-fc28-42b8-a414-84671a6e6c58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Api Root renders the following hyperlinks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8000/drone-categories/`: The collection of drone categories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/drones/`: The collection of drones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/pilots/`: The collection of pilots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/competitions/`: The collection of competitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily access each resource collection by clicking or tapping on the
    appropriate hyperlink. Once we access each resource collection, we can perform
    operations on the different resources throughout the browsable API. Whenever we
    visit any of the resource collections, we can use the breadcrumb to go back to
    the Api Root that lists all the hyperlinks.
  prefs: []
  type: TYPE_NORMAL
- en: Our new RESTful Web Service takes advantage of many generic views. These views
    provide many features for the browsable API that weren't included when we worked
    with function-based views, and we will be able to use forms to easily compose
    and send HTTP `POST` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click or tap on the URL at the right-hand side of drone-categories and the
    web browser will go to `http://localhost:8000/drone-categories/`. As a result,
    Django will render the web page for the Drone Category List. At the bottom of
    the web page, there are two tabs to make an HTTP POST request: Raw data and HTML
    form. By default, the HTML form tab is activated and displays an automatically
    generated form with a textbox to enter the value for the Name field to create
    a new drone category. We can use this form to easily compose and send an HTTP
    POST request without having to deal with the raw JSON data as we did when working
    with the browsable API and our previous web service. The following screenshot
    shows the HTML form to create a new drone category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99ba53ff-72e1-4c21-94a1-6a40cfe4d7a2.png)'
  prefs: []
  type: TYPE_IMG
- en: HTML forms make it really easy to generate requests to test our RESTful web
    service with the browsable API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following value in the Name textbox: `Octocopter`. Then, click or
    tap POST to create a new drone category. The browsable API will compose and send
    an HTTP `POST` request to `/drone-categories/` with the specified data. Then,
    we will see the results of this request in the web browser. The following screenshot
    shows the rendered web page with the results of the previous operation, with an
    HTTP status code of `201 Created` in the response and the previously explained
    HTML form with the POST button that allows us to continue composing and sending
    HTTP `POST` requests to `/drone-categories/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/562ff41e-6c31-45d9-83e6-947634b56c10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can go back to the Api Root by clicking on the link on the breadcrumb
    and use the HTML forms to create drones, pilots, and finally, competitions. For
    example, go to the Api Root and click or tap on the URL at the right-hand side
    of drones and the web browser will go to `http://localhost:8000/drones/`. As a
    result, Django will render the web page for the Drone List. At the bottom of the
    web page, there are two tabs to make an HTTP POST request: Raw data and HTML form.
    By default, the HTML form tab is activated and displays an automatically generated
    form with the appropriate controls for the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drone category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manufacturing date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has it competed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Drone category field provides a drop-down with all the existing drone categories
    so that we can select one of them for our new drone. The Has it competed field
    provides a checkbox because the underlying field is Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this form to easily compose and send an HTTP `POST` request without
    having to deal with the raw JSON data as we did when working with the browsable
    API and our previous web service. The following screenshot shows the HTML form
    to create a new drone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b11fe842-b418-4f1b-b823-f3bad85094d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Defining unique constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RESTful Web Service doesn''t use any constraints, and therefore, it is
    possible to create many drone categories with the same name. We don''t want to
    have many drone categories with the same name. Each drone category name must be
    unique in the database table that persists drone categories (the `drones_dronecategory`
    table). We also want drones and pilots to have unique names. Hence, we will make
    the necessary changes to add unique constraints to each of the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: The name field of the `DroneCategory` model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name field of the `Drone` model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name field of the `Pilot` model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn the necessary steps to edit existing models and add constraints
    to fields that are already persisted in tables and to propagate the changes in
    the underlying database by running the already analyzed migrations process.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or Command Prompt window in which it is
    running. We have to edit the models and then execute migrations before starting
    Django's development server again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will edit the existing code that declares the models to add unique
    constraints to the `name` field for the models that we use to represent and persist
    the drone categories, drones, and pilots. Open the `drones/models.py` file and
    replace the code that declares the `DroneCategory`, `Drone`, and `Pilot` classes
    with the following code. The lines that were edited are highlighted in the code
    listing. The code for the `Competition` class remains without changes. The code
    file for the sample is included in the `hillar_django_restful_07_01` folder, in
    the `restful01/drones/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We added `unique=True` as one of the named arguments for each call to the `models.CharField`
    initializer. This way, we specify that the fields must be unique, and Django's
    ORM will translate this into a requirement for the creation of the necessary unique
    constraints for the fields in the underlying database tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is necessary to execute the migrations that will generate the unique
    constraints we added for the fields in the models in the database. This time,
    the migrations process will synchronize the database with the changes we made
    in the models, and therefore, the process will apply a delta. Run the following
    Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The lines in the output indicate that the `drones/migrations/0002_auto_20171104_0246.py`
    file includes the code to alter the fields called `name` on `drone`, `dronecategory`,
    and `pilot`. It is important to take into account that the Python filename generated
    by the migrations process encodes the date and time, and therefore, the name will
    be different when you run the code in your development computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the code for the file that was automatically generated
    by Django. The code file for the sample is included in the `hillar_django_restful_07_01`
    folder, in the `restful01/drones/migrations/0002_auto_20171104_0246.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code defines a subclass of the `django.db.migrations.Migration` class called
    `Migration`, which defines an `operations` list with many `migrations.AlterField`
    instances. Each `migrations.AlterField` instance will alter the field in the table
    for each of the related models: `drone`, `dronecategory`, and `pilot`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following Python script to execute all the generated migrations
    and apply the changes in the underlying database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command.
    Notice that the order in which the migrations are executed can differ in your
    development computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run the previous command, we will have unique indexes on the `name`
    fields for the following tables in the PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`drones_drone`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drones_dronecategory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drones_pilot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the PostgreSQL command-line tools or any other application that allows
    us to easily check the contents of the PostgreSQL database to check the tables
    that Django updated. If you are working with an SQLite or any other database with
    this example, make sure you use the commands or tools related to the database
    you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a list of the indexes for each of the previously
    enumerated tables in the SQLPro for Postgres GUI tool. Each table has a new unique
    index for the name field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fbca5f4-4c17-428c-a170-febbbc9162b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the names generated for the new unique indexes in the sample
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: The `drones_drone_name_85faecee_uniq` index for the `drones_drone` table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `drones_drone_dronecategory_name_dedead86_uniq` index for the `drones_dronecategory`
    table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `drones_pilot_name_3b56f2a1_uniq` index for the `drones_pilot` table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with unique constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can launch Django''s development server to compose and send HTTP requests
    to understand how unique constraints work when applied to our models. Execute
    any of the following two commands, based on your needs, to access the API in other
    devices or computers connected to your LAN. Remember that we analyzed the difference
    between them in [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*, in
    the *Launching Django''s development server* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to create a drone category with
    a name that already exists: `''Quadcopter''`, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Django won''t be able to persist a `DroneCategory` instance whose `name` is
    equal to the specified value because it violates the unique constraint we just
    added to the `name` field for the `DroneCategory` model. As a result of the request,
    we will receive a `400 Bad Request` status code in the response header and a message
    related to the value specified for the `name` field in the JSON body: `"drone
    category with this name already exists."` The following lines show the detailed
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We made the necessary changes to avoid duplicate values for the `name` field
    in drone categories, drones, or pilots. Whenever we specify the name for any of
    these resources, we will be referencing the same unique resource, because duplicates
    aren't possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to create a pilot with a name
    that already exists: `''Penelope Pitstop''`, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send an HTTP `POST` request with the
    specified JSON key-value pairs. The request specifies `/pilots/`, and therefore,
    it will match the `''^pilots/$''` regular expression and will run the `post` method
    for the `views.PilotList` class-based view. Django won''t be able to persist a
    `Pilot` instance whose `name` is equal to the specified value because it violates
    the unique constraint we just added to the `name` field for the `Pilot` model.
    As a result of the request, we will receive a `400 Bad Request` status code in
    the response header and a message related to the value specified for the `name`
    field in the JSON body: `"pilot with this name already exists."` The following
    lines show the detailed response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we generate the HTTP `POST` request with the help of the HTML form in the
    browsable API, we will see the error message displayed below the Name field in
    the form, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3a58bab-9384-4f36-8196-7e2dfeb4daf9.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been working with a database that has just a few rows, and therefore,
    the HTTP `GET` requests to the different resource collections for our RESTful
    Web Service don't have problems with the amount of data in the JSON body of the
    responses. However, this situation changes as the number of rows in the database
    tables increases.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine we have 300 rows in the `drones_pilots` table that persists pilots.
    We don't want to retrieve the data for 300 pilots whenever we make an HTTP `GET`
    request to `localhost:8000/pilots/`. Instead, we just take advantage of the pagination
    features available in the Django REST framework to make it easy to specify how
    we want the large result sets to be split into individual pages of data. This
    way, each request will retrieve only one page of data, instead of the entire result
    set. For example, we can make the necessary configurations to retrieve only the
    data for a page of a maximum of four pilots.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we enable a pagination scheme, the HTTP `GET` requests must specify
    the pieces of data that they want to retrieve, that is, the details for the specific
    pages, based on predefined pagination schemes. In addition, it is extremely useful
    to have data about the total number of resources, the next page, and the previous
    one, in the response body. This way, the user or the application that is consuming
    the RESTful Web Service knows the additional requests that need to be made to
    retrieve the required pages.
  prefs: []
  type: TYPE_NORMAL
- en: We can work with page numbers and the client can request a specific page number
    in the HTTP `GET` request. Each page will include a maximum amount of resources.
    For example, if we request the first page for the 300 pilots, the web service
    will return the first four pilots in the response body. The second page will return
    the pilots from the fifth to the eighth position in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to specify an offset combined with a limit. For example, if
    we request a page with an offset equal to 0 and a limit of 4, the web service
    will return the first four pilots in the response body. A second request with
    an offset equal to 4 and a limit of 4 will return the pilots from the fifth to
    the eighth position in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, each of the database tables that persist the models we have defined
    has a few rows. However, after we start working with our web service in a real-life
    production environment, we will have hundreds of competitions, pilots, drones,
    and drone categories. Hence, we will definitely have to deal with large result
    sets. We will usually have the same situation in most RESTful Web Services, and
    therefore, it is very important to work with pagination mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring pagination classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Django REST framework provides many options to enable pagination. First,
    we will set up one of the customizable pagination styles included in the Django
    REST framework to include a maximum of four resources in each individual page
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Our RESTful Web Service uses the generic views that work with **mixin** classes.
    These classes are prepared to build paginated responses based on specific settings
    in the Django REST framework configuration. Hence, our RESTful Web Service will
    automatically take into account the pagination settings we configured, without
    requiring additional changes in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/restful01/settings.py` file that declares module-level
    variables that define the configuration of Django for the `restful01` project.
    We will make some changes to this Django settings file. The code file for the
    sample is included in the `hillar_django_restful_07_01` folder, in the `restful01/restful01/settings.py`
    file. Add the following lines that declare a dictionary named `REST_FRAMEWORK` with
    key-value pairs that configure the global pagination settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the changes and Django''s development server will recognize the edits
    and start again with the new pagination settings enabled. The new dictionary has
    two string keys: `''DEFAULT_PAGINATION_CLASS''` and `''PAGE_SIZE''`. The value
    for the `''DEFAULT_PAGINATION_CLASS''` key specifies a global setting with the
    default pagination class that the generic views will use to provide paginated
    responses. In this case, we will use the `rest_framework.pagination.LimitOffsetPagination`
    class that provides a limit/offset-based style.'
  prefs: []
  type: TYPE_NORMAL
- en: This pagination style works with a `limit` parameter that indicates the maximum
    number of items to return and an `offset` that specifies the starting position
    of the query. The value for the `PAGE_SIZE` settings key specifies a global setting
    with the default value for the `limit`, also known as the page size. In this case,
    the value is set to `4`, and therefore, the maximum number of resources returned
    in a single request will be four. We can specify a different limit when we perform
    the HTTP request by specifying the desired value in the `limit` query parameter.
    We can configure the class to have a maximum `limit` value in order to avoid undesired
    huge result sets. This way, we can make sure that the user won't be able to specify
    a large number for the `limit` value. However, we will make this specific configuration
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send many HTTP `POST` requests to create nine additional
    drones related to the two drone categories we created: `Quadcopter` and `Octocopter`.
    This way, we will have a total of 11 drones (two existing drones, plus nine additional
    drones) to test the limit/offset pagination mechanism we have enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent `curl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands will compose and send nine HTTP `POST` requests with the
    specified JSON key-value pairs. The requests specify `/drones/`, and therefore,
    they will match the `'^drones/$'` regular expression and run the `post` method
    for the `views.DroneList` class-based view.
  prefs: []
  type: TYPE_NORMAL
- en: Making requests that paginate results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve all the drones.
    The new pagination settings will take effect and we will only retrieve the first
    page for the drones resource collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send an HTTP `GET` request. The request
    specifies `/drones/`, and therefore, it will match the `''^drones/$''` regular
    expression and run the `get` method for the `views.DroneList` class-based view.
    The method executed in the generic view will use the new settings we added to
    enable the offset/limit pagination, and the result will provide us with the first
    four drone resources. However, the response body looks different than in the previous
    HTTP `GET` requests we made to any resource collection. The following lines show
    the sample response that we will analyze in detail. Don''t forget that the drones
    are being sorted by the name field, in ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The response has a `200 OK` status code in the header and the following keys
    in the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`: The value indicates the total number of drones for the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: The value provides a link to the next page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previous`: The value provides a link to the previous page. In this case, the
    response includes the first page of the result set, and therefore, the link to
    the previous page is `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`results`: The value provides an array of JSON representations of `Drone` instances
    that compose the requested page. In this case, the four drones belong to the first
    page of the result set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous HTTP `GET` request, we didn't specify any values for either
    the `limit` or `offset` parameters. We specified `4` as the default value for
    the `limit` parameter in the global settings and the generic views use this configuration
    value and provide us with the first page. Whenever we don't specify any `offset`
    value, the default `offset` is equal to `0` and the `get` method will return the
    first page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous request is equivalent to the following HTTP `GET` request that
    specifies `0` for the `offset` value. The result of the next command will be the
    same as the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous requests are equivalent to the following HTTP `GET` request that
    specifies `0` for the offset value and `4` for the limit value. The result of
    the next command will be the same as the previous two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send an HTTP request to retrieve the next page, that
    is, the second page for the drones. We will use the value for the `next` key provided
    in the JSON body of the response from the previous requests. This value gives
    us the URL for the next page: `http://localhost:8000/drones/?limit=4&offset=4`.
    Thus, we will compose and send an HTTP `GET` method to `/drones/` with the limit
    value set to `4` and the `offset` value set to `4` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will provide us the second page of four drone resources as the value
    for the `results` key in the response body. In addition, we will see the values
    for the `count`, `previous`, and `next` keys that we analyzed in the previous
    requests. The following lines show the sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the result set is the second page, and therefore, we have a value
    for the `previous` key: `http://localhost:8000/drones/?limit=4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous HTTP request, we specified values for both the `limit` and
    `offset` parameters. However, as we set the default value of `limit` to `4` in
    the global settings, the following request will produce the same results as the
    previous request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send an HTTP request to retrieve the next page, that
    is, the third and last page for the drones. We will use the value for the `next`
    key provided in the JSON body of the response from the previous requests. This
    value gives us the URL for the next page as `http://localhost:8000/drones/?limit=4&offset=8`.
    Thus, we will compose and send an HTTP `GET` method to `/drones/` with the limit
    value set to `4` and the `offset` value set to `8` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will provide us with the third and last page of three drone resources
    as the value for the `results` key in the response body. In addition, we will
    see the values for the `count`, `previous`, and `next` keys that we analyzed in
    the previous requests. The following lines show the sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the result set is the last page, and therefore, we have `null`
    as the value for the `next` key.
  prefs: []
  type: TYPE_NORMAL
- en: Working with customized pagination classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We enabled pagination to limit the size for the result sets. However, any client
    or user is able to specify a large number for the `limit` value, such as `10000`,
    and generate a huge result set. In order to specify the maximum number that is
    accepted for the limit query parameter, it is necessary to create a customized
    version of the limit/offset pagination scheme that the Django REST framework provides
    us.
  prefs: []
  type: TYPE_NORMAL
- en: We made changes to the global configuration to use the `rest_framework.pagination.LimitOffsetPagination`
    class to handle paginated responses. This class declares a `max_limit` class attribute
    whose default value is equal to `None`, which means there is no upper bound for
    the `limit` value. We will indicate the upper bound value for the limit query
    parameter in the `max_limit` class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or Command Prompt in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `restful01/drones` folder and create a new file named `custompagination.py`.
    Write the following code in this new file. The following lines show the code for
    this file that declares the new `LimitOffsetPaginationWithUpperBound` class. The
    code file for the sample is included in the `hillar_django_restful_07_02` folder
    in the `restful01/drones/custompagination.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The previous lines declare the `LimitOffsetPaginationWithUpperBound` class as
    a subclass of  `rest_framework.pagination.LimitOffsetPagination`. This new class
    overrides the value assigned to the `max_limit` class attribute with `8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/restful01/settings.py` file and replace the line that specifies
    the value for the `DEFAULT_PAGINATION_CLASS` key in the `REST_FRAMEWORK` dictionary
    with the highlighted line. The following lines show the new declaration of the
    `REST_FRAMEWORK` dictionary. The code file for the sample is included in the `hillar_django_restful_07_02`
    folder in the `restful01/restful01/settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This way, all the generic views will use the recently declared `drones.custompagination.LimitOffsetPaginationWithUpperBound`
    class that provides the limit/offset pagination scheme we have analyzed with an
    upper bound for the `limit` value equal to `8`.
  prefs: []
  type: TYPE_NORMAL
- en: If any request specifies a value higher than 8 for the limit, the class will
    use the maximum limit value, that is, `8`, and the RESTful Web Service will never
    return more than eight resources in a paginated response.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to configure a maximum limit to avoid generating responses
    with huge amounts of data that might generate important loads to the server running
    the RESTful Web Service. Note that we will learn to limit the usage of the resources
    of our RESTful Web Service in the forthcoming chapters. Pagination is just the
    beginning of a long story.
  prefs: []
  type: TYPE_NORMAL
- en: Making requests that use customized paginated results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launch Django's development server. If you don't remember how to start Django's
    development server, check the instructions in [Chapter 3](dj-rst-websvc_ch13.html),* Creating
    API Views*, in the *Launching Django's development server* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve the first page
    for the drones with the value for the `limit` query parameter set to `500`. This
    value is higher than the maximum limit we established:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The code in the `get` method for the `views.DroneList` class-based view will
    use the new settings we added to enable the customized offset/limit pagination,
    and the result will provide us with the first eight drone resources because the
    maximum value for the limit query is set to `8`. The value specified for the `limit`
    query parameter is greater than `8`, and therefore, the maximum value of `8` is
    used, instead of the value indicated in the request.
  prefs: []
  type: TYPE_NORMAL
- en: The key advantage of working with generic views is that we can easily customize
    the behavior for the methods defined in the mixins that compose these views with
    just a few lines of code. In this case, we took advantage of the pagination features
    available in the Django REST framework to specify how we wanted large results
    sets to be split into individual pages of data. Then, we customized paginated
    results with just a few lines of code to make the limit/offset pagination scheme
    match our specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring filter backend classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been working with the entire queryset as the result set. For
    example, whenever we requested the drones resource collection, the RESTful Web
    Service worked with the entire resource collection and used the default sorting
    we had configured in the model. Now, we want our RESTful Web Service to be able
    to provide filtering, searching, and sorting features.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to understand that we have to be careful with the fields
    we configure to be available in the filtering, searching, and ordering features.
    The configuration will have an impact on the queries executed on the database,
    and therefore, we must make sure that we have the appropriate database optimizations,
    considering the queries that will be executed. Specific database optimizations
    are outside of the scope of this book, but you definitely must take them into
    account when you configure these features.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or Command Prompt window in which it is
    running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the `django-filter` package in our virtual
    environment. This package will enable us to use many field filtering features
    that we can easily customize in the Django REST framework. Make sure the virtual
    environment is activated, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines of the output will indicate that the `django-filter` package
    has been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will work with the following three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rest_framework.filters.OrderingFilter`: This class allows the client to control
    how the results are ordered with a single query parameter. We can specify which
    fields may be ordered against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django_filters.rest_framework.DjangoFilterBackend`: This class provides field
    filtering capabilities. We can specify the set of fields we want to be able to
    filter against, and the filter backend defined in the `django-filter` package
    will create a new `django_filters.rest_framework.FilterSet` class and associate
    it to the class-based view. It is also possible to create our own `rest_framework.filters.FilterSet`
    class, with more customized settings, and write our own code to associate it with
    the class-based view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rest_framework.filters.SearchFilter`: This class provides single query parameter-based
    searching capabilities, and its behavior is based on the Django admin''s search
    function. We can specify the set of fields we want to include for the search feature
    and the client will be able to filter items by making queries that search on these
    fields with a single query. It is useful when we want to make it possible for
    a request to search on multiple fields with a single query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to configure the filter backends by including any of the previously
    enumerated classes in a tuple and assigning it to the `filter_backends` class
    attribute for the generic view classes. In our RESTful Web Service, we want all
    our class-based views to use the same filter backends, and therefore, we will
    make changes in the global configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/restful01/settings.py` file that declares module-level
    variables that define the configuration of Django for the `restful01` project.
    We will make some changes to this Django settings file. Add the highlighted lines
    that declare the `''DEFAULT_FILTER_BACKENDS''` key and assign a tuple of strings
    as its value with the three classes we have analyzed. The following lines show
    the new declaration of the `REST_FRAMEWORK` dictionary. The code file for the
    sample is included in the `hillar_django_restful_07_03` folder in the `restful01/restful01/settings.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Locate the lines that assign a string list to `INSTALLED_APPS` to declare the
    installed apps. Add the following string to the `INSTALLED_APPS` string list and
    save the changes to the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the new code that declares the `INSTALLED_APPS` string
    list with the added line highlighted and with comments to understand what each
    added string means. The code file for the sample is included in the `hillar_django_restful_07_03`
    folder in the `restful01/restful01/settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This way, we have added the `django_filters` application to our Django project
    named `restful01`.
  prefs: []
  type: TYPE_NORMAL
- en: The default query parameter names are `search` for the search feature and `ordering`
    for the ordering feature. We can specify other names by setting the desired strings
    in the `SEARCH_PARAM` and the `ORDERING_PARAM` settings. In this case, we will
    work with the default values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding filtering, searching, and ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will add the necessary code to configure the fields that we want to
    be included in the filtering, searching, and ordering features for each of the
    class-based views that retrieve the contents of each resource collection. Hence,
    we will make changes to all the classes with the `List` suffix in the `views.py`
    file: `DroneCategoryList`, `DroneList`, `PilotList`, and `CompetitionList`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will declare the following three class attributes in each of those classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter_fields`: This attribute specifies a tuple of strings whose values indicate
    the field names that we want to be able to filter against. Under the hood, the
    Django REST framework will automatically create a `rest_framework.filters.FilterSet`
    class and associate it to the class-based view in which we are declaring the attribute.
    We will be able to filter against the field names included in the tuple of strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search_fields`: This attribute specifies a tuple of strings whose values indicate
    the text type field names that we want to include in the search feature. In all
    the usages, we will want to perform a starts-with match. In order to do this,
    we will include `''^''` as a prefix of the field name to indicate that we want
    to restrict the search behavior to a starts-with match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordering_fields`: This attribute specifies a tuple of strings whose values
    indicate the field names that the HTTP request can specify to sort the results.
    If the request doesn''t specify a field for ordering, the response will use the
    default ordering fields specified in the model that is related to the class-based
    view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open the `restful01/drones/views.py` file. Add the following code after the
    last line that declares the imports, before the declaration of the `DroneCategoryList`
    class. The code file for the sample is included in the `hillar_django_restful_07_03`
    folder in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following highlighted lines to the `DroneList` class declared in the
    `views.py` file. The next lines show the new code that defines the class. The
    code file for the sample is included in the `hillar_django_restful_07_03` folder
    in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The changes in the `DroneList` class are easy to understand. We will be able
    to filter, search, and order by the `name` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted lines to the `DroneList` class declared in the
    `views.py` file. The next lines show the new code that defines the class. The
    code file for the sample is included in the `hillar_django_restful_07_03` folder
    in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the `DroneList` class, we specified many field names in the `filter_fields`
    attribute. We included `'drone_category'` in the string tuple, and therefore,
    we will be able to include the ID values for this field in the filter.
  prefs: []
  type: TYPE_NORMAL
- en: We will take advantage of other options for related models that will allow us
    to filter by fields of the related model later. This way, we will understand the
    different customizations available.
  prefs: []
  type: TYPE_NORMAL
- en: The `ordering_fields` attribute specifies two field names for the tuple of strings,
    and therefore, we will be able to order the results by either `name` or `manufacturing_date`.
    Don't forget that we must take into account database optimizations when enabling
    fields to order by.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted lines to the `PilotList` class declared in the
    `views.py` file. The next lines show the new code that defines the class. The
    code file for the sample is included in the `hillar_django_restful_07_03` folder
    in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `ordering_fields` attribute specifies two field names for the tuple of strings,
    and therefore, we will be able to order the results by either `name` or `races_count`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with different types of Django filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create a customized filter that we will apply to the `Competition`
    model. We will code the new `CompetitionFilter` class, specifically, a subclass
    of the `rest_framework.filters.FilterSet` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/drones/views.py` file. Add the following code before the
    declaration of the `CompetitionList` class. The code file for the sample is included
    in the `hillar_django_restful_07_03` folder in the `restful01/drones/views.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CompetitionFilter` class declares the following class attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from_achievement_date`: This attribute is a `django_filters.DateTimeFilter`
    instance that allows the request to filter the competitions whose `achievement_date`
    DateTime value is greater than or equal to the specified DateTime value. The value
    specified in the `name` argument indicates the field to which the DateTime filter
    is applied, `''distance_achievement_date''`, and the value for the `lookup_expr`
    argument indicates the lookup expression, `''gte''`, which means greater than
    or equal to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to_achievement_date`: This attribute is a `django_filters.DateTimeFilter`
    instance that allows the request to filter the competitions whose `achievement_date`
    DateTime value is less than or equal to the specified DateTime value. The value
    specified in the `name` argument indicates the field to which the DateTime filter
    is applied, `''distance_achivement_date''`, and the value for the `lookup_expr`
    argument indicates the lookup expression, `''lte''`, which means less than or
    equal to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_distance_in_feet`: This attribute is a `django_filters.NumberFilter` instance
    that allows the request to filter the competitions whose `distance_in_feet` numeric
    value is greater than or equal to the specified number. The value for the `name`
    argument indicates the field to which the numeric filter is applied, `''distance_in_feet''`,
    and the value for the `lookup_expr` argument indicates the lookup expression,
    `''gte''`, which means greater than or equal to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_distance_in_feet`: This attribute is a `django_filters.NumberFilter` instance
    that allows the request to filter the competitions whose `distance_in_feet` numeric
    value is less than or equal to the specified number. The value for the `name`
    argument indicates the field to which the numeric filter is applied, `''distance_in_feet''`,
    and the value for the `lookup_expr` argument indicates the lookup expression,
    `''lte''`, which means less than or equal to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drone_name`: This attribute is a `django_filters.AllValuesFilter` instance
    that allows the request to filter the competitions whose drones'' names match
    the specified string value. The value for the `name` argument indicates the field
    to which the filter is applied, `''drone__name''`. Notice that there is a double
    underscore (`__`) between `drone` and `name`, and you can read it as the `name`
    field for the `drone` model or simply replace the double underscore with a dot
    and read `drone.name`. The name uses Django''s double underscore syntax. However,
    we don''t want the request to use `drone__name` to specify the filter for the
    drone''s name. Hence, the instance is stored in the class attribute named `drone_name`,
    with just a single underscore between `player` and `name`, to make it more user-friendly.
    We will make configurations to make the browsable API display a drop-down with
    all the possible values for the drone''s name to use as a filter. The drop-down
    will only include the drones'' names that have registered competitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pilot_name`: This attribute is a `django_filters.AllValuesFilter` instance
    that allows the request to filter the competitions whose pilots'' names match
    the specified string value. The value for the `name` argument indicates the field
    to which the filter is applied, `''pilot__name''`. The name uses Django''s double
    underscore syntax. As happened with `drone_name`, we don''t want the request to
    use `pilot__name` to specify the filter for the pilot''s name, and therefore,
    we stored the instance in the class attribute named `pilot_name`, with just a
    single underscore between `pilot` and `name`. The browsable API will display a
    drop-down with all the possible values for the pilot''s name to use as a filter.
    The drop-down will only include the pilots'' names that have registered competitions
    because we used the `AllValuesFilter` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CompetitionFilter` class defines a `Meta` inner class that declares the
    following two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`model`: This attribute specifies the model related to the filter set, that
    is, the `Competition` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields`: This attribute specifies a tuple of strings whose values indicate
    the field names and filter names that we want to include in the filters for the
    related model. We included `''distance_in_feet''` and the names for all the previously
    explained filters. The string `''distance_in_feet''` refers to the field with
    this name. We want to apply the default numeric filter that will be built under
    the hood to allow the request to filter by an exact match on the `distance_in_feet`
    field. This way, the request will have plenty of options to filter competitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, add the following highlighted lines to the `CompetitionList` class declared
    in the `views.py` file. The next lines show the new code that defines the class.
    The code file for the sample is included in the `hillar_django_restful_07_03`
    folder in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `filter_class` attribute specifies `CompetitionFilter` as its value, that
    is, the `FilterSet` subclass that declares the customized filters that we want
    to use for this class-based view. In this case, the code didn't specify a tuple
    of strings for the `filter_class` attribute because we have defined our own `FilterSet`
    subclass.
  prefs: []
  type: TYPE_NORMAL
- en: The `ordering_fields` tuple of strings specifies the two field names that the
    request will be able to use for ordering the competitions.
  prefs: []
  type: TYPE_NORMAL
- en: Making requests that filter results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can launch Django''s development server to compose and send HTTP requests
    to understand how to use the previously coded filters. Execute any of the following
    two commands, based on your needs, to access the API in other devices or computers
    connected to your LAN. Remember that we analyzed the difference between them in
    [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*, in the *Launching
    Django''s development server* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to retrieve all the drone categories
    whose `name` is equal to `Quadcopter`, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show a sample response with the single drone category whose
    `name` matches the specified `name` string in the filter and the list of hyperlinks
    for the drones that belong to the category. The following lines show the JSON
    response body without the headers. Notice that the results are paginated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Composing requests that filter and order results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will compose and send an HTTP request to retrieve all the drones whose related
    drone category ID is equal to `1` and whose value for the `has_it_competed` field
    is equal to `False`. The results must be sorted by `name` in descending order,
    and therefore, we specify `-name` as the value for the `ordering` query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The hyphen (`-`) before the field name indicates that the ordering feature must
    use descending order instead of the default ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you replace `1` with the `pk` value of the previously retrieved drone
    category named `Quadcopter`. The `has_it_competed` field is a `bool` field, and
    therefore, we have to use Python valid bool values (`True` and `False`) when specifying
    the desired values for the bool field in the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show a sample response with the first four out of seven
    drones that match the specified criteria in the filter, sorted by name in descending
    order. Notice that the filters and the ordering have been combined with the previously
    configured pagination. The following lines show only the JSON response body, without
    the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the response provides the value for the `next` key, `http://localhost:8000/drones/?drone_category=1&has_it_competed=False&limit=4&offset=4&ordering=-name`.
    This URL includes the combination of pagination, filtering, and ordering query
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the `DroneList` class, we included `'drone_category'` as one of the strings
    in the `filter_fields` tuple of strings. Hence, we had to use the drone category
    ID in the filter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use a filter on the drone's name related to a competition. As previously
    explained, our `CompetitionFilter` class provides us a filter to the name of the
    related drone in the `drone_name` query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will combine the filter with another filter on the pilot''s name related
    to a competition. Remember that the class also provides us a filter to the name
    of the related pilot in the `pilot_name` query parameter. We will specify two
    conditions in the criteria, and the filters are combined with the `AND` operator.
    Hence, both conditions must be met. The pilot''s name must be equal to `''Penelope
    Pitstop''` and the drone''s name must be equal to `''WonderDrone''`. The following
    command generates a request with the explained filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show a sample response with the competition that matches
    the specified criteria in the filters. The following lines show only the JSON
    response body, without the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send an HTTP request to retrieve all the competitions
    that match the following criteria. In addition, we want the results ordered by
    `distance_achievement_date`, in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: The `distance_achievement_date` is between `2017-10-18` and `2017-10-21`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `distance_in_feet` value is between `700` and `900`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following command will do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously analyzed `CompetitionFilter` class allowed us to create a request
    like the previous one, in which we take advantage of the customized filters. The
    following lines show a sample response with the two competitions that match the
    specified criteria in the filters. We overrode the default ordering specified
    in the model with the `ordering` field indicated in the request. The following
    lines show only the JSON body response, without the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Making requests that perform starts with searches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will take advantage of searches that are configured to check whether
    a value starts with the specified characters. We will compose and send an HTTP
    request to retrieve all the pilots whose `name` starts with `'G'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next request uses the search feature that we configured to restrict the
    search behavior to a starts-with match on the `name` field for the `Drone` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show a sample response with the two drones that match the
    specified search criteria, that is, those drones whose `name` starts with `''G''`.
    The following lines show only the JSON response body, without the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Using the browsable API to test pagination, filtering, searching, and ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We enabled pagination and we added filtering, searching, and ordering features
    to our RESTful Web Service. All of these new features have an impact on how each
    web page is rendered when working with the browsable API.
  prefs: []
  type: TYPE_NORMAL
- en: We can work with a web browser to easily test pagination, filtering, searching,
    and ordering with a few clicks or taps.
  prefs: []
  type: TYPE_NORMAL
- en: Open a web browser and go to `http://localhost:8000/drones/`. Replace `localhost` with
    the IP of the computer that is running Django's development server if you use
    another computer or device to run the browser. The browsable API will compose
    and send a `GET` request to `/drones/` and will display the results of its execution,
    that is, the headers and the JSON drones list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have configured pagination, and therefore, the rendered web page will include
    the default pagination template associated with the base pagination class we are
    using and will display the available page numbers in the upper-right corner of
    the web page. The following screenshot shows the rendered web page after entering
    the URL in a web browser with the resource description, Drone List, and the three
    pages generated with the limit/offset pagination scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/474df671-756c-4855-8965-9a0e19565809.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, go to `http://localhost:8000/competitions/`. The browsable API will compose
    and send a `GET` request to `/competitions/` and will display the results of its
    execution, that is, the headers and the JSON competitions list. The web page will
    include a Filters button at the right-hand side of the resource description, Competition
    List, and at the left-hand side of the OPTIONS button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click or tap on Filters, and the browsable API will render the Filter model
    with the appropriate controls for each filter that you can apply below Field Filters.
    In addition, the model will render the different ordering options below Ordering.
    The following screenshot shows the Filters model for the competitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b0c8dc5-1cb1-4db3-8ba1-34c40a5b0065.png)'
  prefs: []
  type: TYPE_IMG
- en: The Drone name and Pilot name drop-downs only provide the related drones' names
    and pilots' names that have participated in competitions because we used the `AllValuesFilter`
    class for both filters. We can easily enter all the values for each desired filter
    that we want to apply and click or tap Submit. Then, click on Filters again, select
    the ordering option, and click Submit. The browsable API will compose and send
    the necessary HTTP request to apply the filters and ordering we have specified
    and it will render a web page with the first page of the results of the execution
    of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot shows the results of executing a request whose filters
    were composed with the previously explained model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8114b3f2-cb23-447b-bbf7-119af60badc9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the parameters for the HTTP `GET` request. Notice that the
    browsable API generates the query parameters but doesn''t specify values for the
    filters that were left without values in the previous modal. When the query parameters
    don''t specify values, they are ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As happens whenever we have to test the different features included in our RESTful
    Web Service, the browsable API is also extremely helpful whenever we need to check
    filters and ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `django_filters.rest_framework.DjangoFilterBackend` class provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Control on how the results are ordered with a single query parameter
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Single query parameter-based searching capabilities, based on the Django admin's
    search function
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Field filtering capabilities
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `rest_framework.filters.SearchFilter` class provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Control on how the results are ordered with a single query parameter
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Single query parameter-based searching capabilities, based on the Django admin's
    search function
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Field filtering capabilities
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If we want to create a unique constraint, what must be added to a `models.CharField`
    initializer as one of the named arguments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unique=True`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`unique_constraint=True`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`force_unique=True`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following class attributes specifies a tuple of strings whose
    values indicate the field names that we want to be able to filter against in a
    class-based view that inherits from `generics.ListCreateAPIView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filters`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filtering_fields`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filter_fields`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following class attributes specifies a tuple of strings whose
    values indicate the field names that the HTTP request can specify to sort the
    results in a class-based view that inherits from `generics.ListCreateAPIView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`order_by`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ordering_fields`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`order_fields`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used the browsable API feature to navigate through the API
    with resources and relationships. We added unique constraints to improve consistency
    for the models in our RESTful Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: We understood the importance of paginating results and we configured and tested
    a global limit/offset pagination scheme with the Django REST framework. Then,
    we created our own customized pagination class to make sure that requests weren't
    able to acquire a huge amount of elements in a single page.
  prefs: []
  type: TYPE_NORMAL
- en: We configured filter backend classes and we added code to the models to add
    filtering, searching, and ordering capabilities to the class-based views. We created
    a customized filter and we made requests to filter, search, and order results,
    and we understood how everything worked under the hood. Finally, we used the browsable
    API to test pagination, filtering, and ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we improved our RESTful Web Service with unique constraints, paginated
    results, fitering, searching, and ordering features, we will secure the API with
    authentication and permissions. We will cover these topics in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the API with Authentication and Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will understand the difference between authentication and
    permissions in the Django REST framework. We will start securing our RESTful Web
    Service by adding requirements for authentication schemes and specifying permission
    policies. We will gain an understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding authentication and permissions in Django, the Django REST framework,
    and RESTful Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and permissions-related data to models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with object-level permissions via customized permission classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving information about users that make requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting permissions policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the superuser for Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user for Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making authenticated requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browsing the secured API with the required authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with token-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating and using tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding authentication and permissions in Django, the Django REST framework,
    and RESTful Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, our sample RESTful Web Service processes all the incoming requests
    without requiring any kind of authentication, that is, any user can perform requests.
    The Django REST framework allows us to easily use diverse authentication schemes
    to identify a user that originated the request or a token that signed the request.
    Then, we can use these credentials to apply permission and throttling policies
    that will determine whether the request must be permitted or not.
  prefs: []
  type: TYPE_NORMAL
- en: We already know how configurations work with the Django REST framework. We can
    apply a global setting and override it if necessary in the appropriate class-based
    views. Hence, we can set the default authentication schemes in the global settings
    and override them whenever required for specific scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The settings allow us to declare a list of classes that specify the authentication
    schemes to be used for all the incoming HTTP requests. The Django REST framework
    will use all the specified classes in the list to authenticate a request, before
    running the appropriate method for the class-based view based on the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify just one class. However, it is very important to understand
    the behavior in case we have to use more than one class. The first class in the
    list that generates a successful authentication will be responsible for setting
    the values for the following two attributes for the `request` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: This attribute represents the user model instance. In our examples,
    we will work with an instance of the Django User class, specifically, the `django.contrib.auth.User`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth`: This attribute provides additional authentication data required by
    the authentication scheme, such as an authentication token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a successful authentication, we will be able to use the `request.user`
    attribute within the different methods in our class-based views that receive the
    `request` parameter. This way, we will be able to retrieve additional information
    about the `user` that generated the request.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the authentication classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Django REST framework provides the following three authentication classes
    in the `rest_framework.authentication` module. All of them are subclasses of the
    `BaseAuthentication` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BasicAuthentication`: This class provides an HTTP basic authentication against
    a username and a password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SessionAuthentication`: This class works with Django''s session framework
    for authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TokenAuthentication`: This class provides a simple token-based authentication.
    The request must include the token generated for a user as the value for the `Authorization`
    HTTP header key with the `''Token ''` string as a prefix for the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, in a production environment, we must make sure that the RESTful Web
    Service is only available over HTTPS, with the usage of the latest TLS versions.
    We shouldn't use an HTTP basic authentication or a simple token-based authentication
    over plain HTTP in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The previous classes are included in the Django REST framework out of the box.
    There are many additional authentication classes provided by many third-party
    libraries. We will work with some of these libraries later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or go to the Command Prompt window in which
    it is running. We have to edit the models and then execute migrations before starting
    Django's development server again.
  prefs: []
  type: TYPE_NORMAL
- en: We will make the necessary changes to combine HTTP basic authentication against
    a username and a password with Django's session framework for authentication.
    Hence, we will add the `BasicAuthentication` and `SessionAuthentication` classes
    in the global authentication classes list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/restful01/settings.py` file that declares the module-level
    variables that define the configuration of Django for the `restful01` project.
    We will make some changes to this Django settings file. Add the highlighted lines
    to the `REST_FRAMEWORK` dictionary. The following lines show the new declaration
    of the `REST_FRAMEWORK` dictionary. The code file for the sample is included in
    the `hillar_django_restful_08_01` folder in the `restful01/restful01/settings.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the `DEFAULT_AUTHENTICATION_CLASSES` settings key to the `REST_FRAMEWORK`
    dictionary. This new key specifies a global setting with a tuple of string whose
    values indicate the classes that we want to use for authentication: `BasicAuthentication`
    and `SessionAuthentication`.'
  prefs: []
  type: TYPE_NORMAL
- en: Including security and permissions-related data to models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want each drone to have an owner. Only an authenticated user will be able
    to create a drone and it will automatically become the owner of this new drone.
    We want only the owner of a drone to be able to update or delete the drone. Hence,
    an authenticated user that is also the owner of the drone will be able to execute
    `PATCH`, `PUT`, and `DELETE` methods on the drone resource that he owns.
  prefs: []
  type: TYPE_NORMAL
- en: Any authenticated user that isn't the owner of a specific drone resource will
    have read-only access to this drone. In addition, unauthenticated requests will
    also have read-only access to drones.
  prefs: []
  type: TYPE_NORMAL
- en: We will combine authentication with specific permissions. Permissions use the
    authentication information included in the `request.user` and `request.auth` attributes
    to determine whether the request should be granted or denied access. Permissions
    allow us to control which types of users will be granted or denied access to the
    different features, methods, resources, or resource collections of our RESTful
    Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the permissions features in the Django REST framework to allow only
    authenticated users to create new drones and automatically become their owners.
    We will make the necessary changes in the models to make a drone have a user as
    its owner. We will take advantage of the out-of-the-box permission classes included
    in the framework combined with a customized permission class, to define the previously
    explained permission policies for the drones and their related HTTP verbs supported
    in our web service.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will stay focused on security and permissions and we will leave
    throttling rules for the next chapters. Bear in mind that throttling rules also
    determine whether a specific request must be authorized or not. However, we will
    work on throttling rules later and we will combine them with authentication and
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/drones/models.py` file and replace the code that declares
    the `Drone` class with the following code. The new lines are highlighted in the
    code listing. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines declare a new `owner` field for the `Drone` model. The
    new field uses the `django.db.models.ForeignKey` class to provide a many-to-one
    relationship to the `django.contrib.auth.User` model.
  prefs: []
  type: TYPE_NORMAL
- en: This `User` model persists the users for the Django authentication system. Now,
    we are using this authentication system for our RESTful Web Service. The `'drones'`
    value specified for the `related_name` argument creates a backward relation from
    the `User` to the `Drone` model. Remember that this value indicates the name to
    use for the relation from the related `User` object back to a `Drone` object.
    This way, we will be able to access all the drones owned by a specific user.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we delete a `User`, we want all drones owned by this user to be deleted
    too, and therefore, we specified the `models.CASCADE` value for the `on_delete`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/drones/serializers.py` file and add the following code
    after the last line that declares the imports, before the declaration of the `DroneCategorySerializer`
    class. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/serializers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t want to use the `DroneSerializer` serializer class for the drones
    related to a user because we want to serialize fewer fields, and therefore, we
    created the `UserDroneSerializer` class. This class is a subclass of the `HyperlinkedModelSerializer`
    class. This new serializer allows us to serialize the drones related to a `User`.
    The `UserDroneSerializer` class defines a `Meta` inner class that declares the
    following two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `Drone` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields`: This attribute specifies a tuple of string whose values indicate
    the field names that we want to include in the serialization from the related
    model. We just want to include the URL and the drone''s name, and therefore, the
    code includes `''url''` and `''name''` as members of the tuple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UserSerializer` is a subclass of the `HyperlinkedModelSerializer` class.
    This new serializer class declares a `drones` attribute as an instance of the
    previously explained `UserDroneSerializer` class, with the `many` and `read_only`
    arguments equal to `True` because it is a one-to-many relationship and it is read-only.
    The code specifies the `drones` name that we specified as the string value for
    the `related_name` argument when we added the `owner` field as a `models.ForeignKey`
    instance in the `Drone` model. This way, the `drones` field will provide us with
    an array of URLs and names for each drone that belongs to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will add an `owner` field to the existing `DroneSerializer` class. Open
    the `restful01/drones/serializers.py` file and replace the code that declares
    the `DroneSerializer` class with the following code. The new lines are highlighted
    in the code listing. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/serializers.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The new version of the `DroneSerializer` class declares an `owner` attribute
    as an instance of `serializers.ReadOnlyField` with the `source` argument equal
    to `'owner.username'`. This way, the serializer will serialize the value for the
    `username` field of the related `django.contrib.auth.User` instance stored in
    the `owner` field.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the `ReadOnlyField` class because the owner is automatically populated
    when an authenticated user creates a new drone. It will be impossible to change
    the owner after a drone has been created with an HTTP `POST` method call. This
    way, the `owner` field will render the username that created the related drone.
    In addition, we added `'owner'` to the `fields` string tuple within the `Meta`
    inner class.
  prefs: []
  type: TYPE_NORMAL
- en: We made the necessary changes to the `Drone` model and its serializer (the `DroneSerializer`
    class) to make drones have owners.
  prefs: []
  type: TYPE_NORMAL
- en: Working with object-level permissions via customized permission classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `rest_framework.permissions.BasePermission` class is the base class from
    which all customized permission classes should inherit to work with the Django
    REST framework. We want to make sure that only a drone owner can update or delete
    an existing drone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `restful01/drones` folder and create a new file named `custompermission.py`.
    Write the following code in this new file. The following lines show the code for
    this file that declares the new `IsCurrentUserOwnerOrReadOnly` class declared
    as a subclass of the `BasePermission` class. The code file for the sample is included
    in the `hillar_django_restful_08_01` folder in the `restful01/drones/custompermission.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The previous lines declare the `IsCurrentUserOwnerOrReadOnly` class and override
    the `has_object_permission` method defined in the `BasePermission` superclass
    that returns a `bool` value indicating whether the permission should be granted
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `permissions.SAFE_METHODS` tuple of string includes the three HTTP methods
    or verbs that are considered safe because they are read-only and they don''t produce
    changes to the related resource or resource collection: `''GET''`, `''HEAD''`,
    and `''OPTIONS''`. The code in the `has_object_permission` method checks whether
    the HTTP verb specified in the `request.method` attribute is any of the three
    safe methods specified in `permission.SAFE_METHODS`. If this expression evaluates
    to `True`, the `has_object_permission` method returns `True` and grants permission
    to the request.'
  prefs: []
  type: TYPE_NORMAL
- en: If the HTTP verb specified in the `request.method` attribute is not any of the
    three safe methods, the code returns `True` and grants permission only when the
    `owner` attribute of the received `obj` object (`obj.owner`) matches the user
    that originated the request (`request.user`). The user that originated the request
    will always be the authenticated user. This way, only the owner of the related
    resource will be granted permission for those requests that include HTTP verbs
    that aren't safe.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the new `IsCurrentUserOwnerOrReadOnly` customized permission class
    to make sure that only the drone owners can make changes to an existing drone.
    We will combine this permission class with the `rest_framework.permissions.IsAuthenticatedOrReadOnly`
    one that only allows read-only access to resources when the request doesn't belong
    to an authenticated user. This way, whenever an anonymous user performs a request,
    he will only have read-only access to the resources.
  prefs: []
  type: TYPE_NORMAL
- en: Saving information about users that make requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a user performs an HTTP `POST` request to the drone resource collection
    to create a new drone resource, we want to make the authenticated user that makes
    the request the owner of the new drone. In order to make this happen, we will
    override the `perform_create` method in the `DroneList` class declared in the
    `views.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/drones/views.py` file and replace the code that declares
    the `DroneList` class with the following code. The new lines are highlighted in
    the code listing. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `generics.ListCreateAPIView` class inherits from the `CreateModelMixin`
    class and other classes. The `DroneList` class inherits the `perform_create` method
    from the `rest_framework.mixins.CreateModelMixin` class.
  prefs: []
  type: TYPE_NORMAL
- en: The code that overrides the `perform_create` method provides an additional `owner`
    field to the `create` method by setting a value for the `owner` argument in the
    call to the `serializer.save` method. The code sets the `owner` argument to the
    value of `self.request.user`, that is, to the authenticated user that is making
    the request. This way, whenever a new `Drone` is created and persisted, it will
    save the `User` associated to the request as its owner.
  prefs: []
  type: TYPE_NORMAL
- en: Setting permission policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will configure permission policies for the class-based views that work with
    the `Drone` model. We will override the value for the `permission_classes` class
    attribute for the `DroneDetail` and `DroneList` classes.
  prefs: []
  type: TYPE_NORMAL
- en: We will add the same lines of code in the two classes. We will include the `IsAuthenticatedOrReadOnly`
    class and our recently declared `IsCurrentUserOwnerOrReadOnly` permission class
    in the `permission_classes` tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/drones/views.py` file and add the following lines after
    the last line that declares the imports, before the declaration of the `DroneCategorySerializer`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code that declares the `DroneDetail` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code that declares the `DroneList` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Creating the superuser for Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will run the necessary command to create the `superuser` for Django
    that will allow us to authenticate our requests. We will create other users later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you are in the `restful01` folder that includes the `manage.py` file
    in the activated virtual environment. Execute the following command that executes
    the `createsuperuser` subcommand for the `manage.py` script to allow us to create
    the `superuser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will ask you for the username you want to use for the `superuser`.
    Enter the desired username and press *Enter*. We will use `djangosuper` as the
    username for this example. You will see a line similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the command will ask you for the email address. Enter an email address
    and press *Enter.* You can enter `djangosuper@example.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the command will ask you for the password for the new superuser. Enter
    your desired password and press *Enter*. We will use `passwordforsuper` as an
    example in our tests. Of course, this password is not the best example of a strong
    password. However, the password is easy to type and read in our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will ask you to enter the password again. Enter it and press *Enter*.
    If both entered passwords match, the superuser will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Our database has many rows in the `drones_drone` table. We added a new `owner`
    field for the `Drone` model and this required field will be added to the `drones_drone`
    table after we execute migrations. We have to assign a default owner for all the
    existing drones to make it possible to add this new required field without having
    to delete all these drones. We will use one of the features included in Django
    to solve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to know the `id` value for the superuser we have created to use
    it as the default owner for the existing drones. Then, we will use this value
    to let Django know which is the default owner for the existing drones.
  prefs: []
  type: TYPE_NORMAL
- en: We created the first user, and therefore, the `id` will be equal to `1`. However,
    we will check the procedure to determine the `id` value in case you create other
    users and you want to assign any other user as the default owner.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the row in the `auth_user` table whose `username` field matches
    `'djangosuper'` in any tool that works with PostgreSQL. Another option is to run
    the following commands to retrieve the ID from the auth_user table for the row
    whose username is equal to `'djangosuper'`. In case you specified a different
    name, make sure you use the appropriate one. In addition, replace the username
    in the command with the username you used to create the PostgreSQL database and
    password with your chosen password for this database user. You specified this
    information when you executed the steps explained in [Chapter 6](dj-rst-websvc_ch16.html),
    *Working with Advanced Relationships and Serialization*, in the *Running migrations
    that generate relationships* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command assumes that you are running PostgreSQL on the same computer in
    which you are executing the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output with the value for the `id` field: `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following Python script to generate the migrations that will allow
    us to synchronize the database with the new field we added to the `Drone` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Django will explain to us that we cannot add a non-nullable field without a
    default and will ask us to select an option with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Enter `1` and press *Enter*. This way, we will select the first option to provide
    the one-off default that will be set on all the existing `drones_drone` rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django will ask us to provide the default value we want to set for the `owner`
    field of the `drones_drone` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the value for the previously retrieved `id`: `1`. Then, press *Enter*.
    The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that the `restful01/drones/migrations/0003_drone_owner.py`
    file includes the code to add the field named `owner` to the `drone` table. The
    following lines show the code for this file that was automatically generated by
    Django. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/migrations/0003_drone_owner.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The code declares the `Migration` class as a subclass of the `django.db.migrations.Migration`
    class. The `Migration` class defines an `operations` list with a `migrations.AddField`
    instance that will add the `owner` field to the table related to the `drone` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following Python script to apply all the generated migrations
    and execute the changes in the database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run the previous command, we will have a new `owner_id` field in the
    `drones_drone` table in the PostgreSQL database. The existing rows in the `drones_drone`
    table will use the default value we instructed Django to use for the new `owner_id`
    field: `1`. This way, the superuser named `''djangosuper''` will be the owner
    for all the existing drones.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the PostgreSQL command line or any other application that allows
    us to easily check the contents of the PostreSQL database to browse the `drones_drone`
    table that Django updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the new structure for the `drones_drone` table
    at the left-hand side and all its rows at the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9099daf-bfb1-41a2-aec6-80de7af1a110.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a user for Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will use Django''s interactive shell to create a new user for Django.
    Run the following command to launch Django''s interactive shell. Make sure you
    are within the `restful01` folder in the terminal, Command Prompt, or Windows
    Powershell window in which you have the virtual environment activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that a line that says **(**InteractiveConsole**)** is displayed
    after the usual lines that introduce your default Python interactive shell. Enter
    the following code in the shell to create another user that is not a superuser.
    We will use this user and the superuser to test our changes in the permissions
    policies. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `scripts/create_user.py` file. You can replace `user01` with your
    desired username, `user01@example.com` with the email and `user01password` with
    the password you want to use for this user. Notice that we will be using these
    credentials in the following sections. Make sure you always replace the credentials
    with your own credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, enter the following command to quit the interactive console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: You can achieve the same goal by pressing *Ctrl + D*. Now, we have a new user
    for Django named `user01`.
  prefs: []
  type: TYPE_NORMAL
- en: Making authenticated requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can launch Django''s development server to compose and send authenticated
    HTTP requests to understand how the configured authentication classes, combined
    with the permission policies, work. Execute any of the following two commands
    based on your needs to access the API in other devices or computers connected
    to your LAN. Remember that we analyzed the difference between them in [Chapter
    3](dj-rst-websvc_ch13.html),*Creating API Views*, in the *Launching Django''s
    development server* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will compose and send an HTTP `POST` request without authentication credentials
    to try to create a new drone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive an `HTTP 401 Unauthorized` status code in the response header
    and a `detail` message indicating that we didn''t provide authentication credentials
    in the JSON body. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'After the changes we made, if we want to create a new drone, that is, to make
    an HTTP `POST` request to `/drones/`, we need to provide authentication credentials
    by using HTTP authentication. Now, we will compose and send an HTTP request to
    create a new drone with authentication credentials, that is, with the superuser
    name and his password. Remember to replace `djangosuper` with the name you used
    for the superuser and `passwordforsuper` with the password you configured for
    this user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `Drone` with the superuser named `djangosuper` as its owner has been
    successfully created and persisted in the database because the request was authenticated.
    As a result of the request, we will receive an `HTTP 201 Created` status code
    in the response header and the recently persisted `Drone` serialized to JSON in
    the response body. The following lines show an example response for the HTTP request,
    with the new `Drone` object in the JSON response body. Notice that the JSON response
    body includes the `owner` key and the username that created the drone as its value:
    `djangosuper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will try to update the `has_it_competed` field value for the previously
    created drone with an HTTP `PATCH` request. However, we will use the other user
    we created in Django to authenticate this HTTP `PATCH` request. This user isn't
    the owner of the drone, and therefore, the request shouldn't succeed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace `user01` and `user01password` in the next command with the name and
    password you configured for this user. In addition, replace `12` with the ID generated
    for the previously created drone in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive an `HTTP 403 Forbidden` status code in the response header
    and a detail message indicating that we do not have permission to perform the
    action in the JSON body. The owner for the drone we want to update is `djangosuper`
    and the authentication credentials for this request use a different user: `user01`.
    Hence, the operation is rejected by the `has_object_permission` method in the
    `IsCurrentUserOwnerOrReadOnly` customized permission class we created. The following
    lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The user that isn''t the drone''s owner cannot make changes to the drone. However,
    he must be able to have read-only access to the drone. Hence, we must be able
    to compose and retrieve the previous drone details with an HTTP `GET` request
    with the same authentication credentials. It will work because `GET` is one of
    the safe methods and a user that is not the owner is allowed to read the resource.
    Replace `user01` and `user01password` in the next command with the name and password
    you configured for this user. In addition, replace `12` with the ID generated
    for the previously created drone in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The response will return an `HTTP 200 OK` status code in the header and the
    requested `Drone` serialized to JSON in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: Making authenticated HTTP PATCH requests with Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will use one of the GUI tools we installed in *Chapter 1,* *Installing
    the Required Software and Tools*, specifically, Postman. We will use this GUI
    tool to compose and send an HTTP `PATCH` request with the appropriate authentication
    credentials to the web service. In the previous chapters, whenever we worked with
    Postman, we didn't specify authentication credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Builder tab in Postman to compose and send an HTTP `PATCH`
    request to update the `has_it_competed` field for the previously created drone.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In case you made previous requests with Postman, click on the plus (**+**) button
    at the right-hand side of the tab that displayed the previous request. This way,
    you will create a new tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select PATCH in the drop-down menu at the left-hand side of the Enter request
    URL textbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `http://localhost:8000/drones/12` in that textbox at the right-hand side
    of the drop-down. Replace `12` with the ID generated for the previously created
    drone in your configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Authorization tab below the textbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Basic Auth in the TYPE drop-down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name you used to create `djangosuper` in the Username textbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the password you used instead of `passwordforsuper` for this user in
    the Password textbox. The following screenshot shows the basic authentication
    configured in Postman for the HTTP `PATCH` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0883be60-59a2-4a55-84b0-e89d32eb7be9.png)'
  prefs: []
  type: TYPE_IMG
- en: Click Body at the right-hand side of the Authorization and Headers tabs, within
    the panel that composes the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the raw radio button and select JSON (application/json) in the drop-down
    at the right-hand side of the binary radio button. Postman will automatically
    add a Content-type = application/json header, and therefore, you will notice the
    Headers tab will be renamed to Headers (1), indicating to us that there is one
    key/value pair specified for the request headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following lines in the textbox below the radio buttons, within the
    Body tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the request body in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/043a3075-b78c-4ab1-839a-d2f2c47f6f94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We followed the necessary steps to create an HTTP `PATCH` request with a JSON
    body that specifies the necessary key/value pairs to update the value for the
    `was_included_in_home` field of an existing drone, with the necessary HTTP authentication
    credentials. Click Send and Postman will display the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Status: `200 OK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time: The time it took for the request to be processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Size: The approximate response size (sum of body size plus headers size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body: The response body with the recently updated drone formatted as JSON with
    syntax highlighting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the JSON response body in Postman for the HTTP
    `PATCH` request. In this case, the request updated the existing drone because
    we authenticated the request with the user that is the drone''s owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d2fa033-b76a-418a-9082-c3ebaffef574.png)'
  prefs: []
  type: TYPE_IMG
- en: Browsing the secured API with the required authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want the browsable API to display the log in and log out views. In order
    to make this possible, we have to add a line in the `urls.py` file in the `restful01/restful01`
    folder, specifically, in the `restful01/restful01/urls.py` file. The file defines
    the root URL configurations and we want to include the URL patterns provided by
    the Django REST framework that provide the log in and log out views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the new code for the `restful01/restful01/urls.py`
    file. The new line is highlighted. The code file for the sample is included in
    the `hillar_django_restful_08_01` folder, in the `restful01/restful01/urls.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Open a web browser and go to `http://localhost:8000/`. Replace localhost by
    the IP of the computer that is running Django's development server in case you
    use another computer or device to run the browser. The browsable API will compose
    and send a `GET` request to `/` and will display the results of its execution,
    that is, the Api Root. You will notice there is a Log in hyperlink at the upper-right
    corner.
  prefs: []
  type: TYPE_NORMAL
- en: Click or tap Log in and the browser will display the Django REST framework login
    page. Enter the name you used to create `djangosuper` in the Username textbox
    and the password you used instead of `passwordforsuper` for this user in the Password
    textbox. Then, click Log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you will be logged in as `djangosuper` and all the requests you compose
    and send through the browsable API will use this user. You will be redirected
    again to the Api Root and you will notice the Log in hyperlink is replaced with
    the username (djangosuper) and a drop-down menu that allows you to log out. The
    following screenshot shows the Api Root after we are logged in as `djangosuper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b59a2e88-187a-492d-872b-64a39cc7b4fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Click or tap on the username that is logged in (djangosuper) and select Log
    Out from the drop-down menu. We will log in as a different user.
  prefs: []
  type: TYPE_NORMAL
- en: Click or tap Log in and the browser will display the Django REST framework login
    page. Enter the name you used to create `user01` in the Username textbox and the
    password you used instead of `user01password` for this user in the Password textbox.
    Then, click Log in.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will be logged in as `user01` and all the requests you compose and
    send through the browsable API will use this user. You will be redirected again
    to the Api Root and you will notice the Log in hyperlink is replaced with the
    username (user01).
  prefs: []
  type: TYPE_NORMAL
- en: Go to `http://localhost:8000/drones/12`. Replace `12` with the ID generated
    for the previously created drone in your configuration. The browsable API will
    render the web page with the results for the `GET` request to `localhost:8000/drones/12`.
  prefs: []
  type: TYPE_NORMAL
- en: Click or tap the OPTIONS button and the browsable API will render the results
    of the HTTP `OPTIONS` request to `http://localhost:8000/drones/12` and will include
    the DELETE button at the right-hand side of the Drone Detail title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click or tap DELETE. The web browser will display a confirmation modal. Click
    or tap the DELETE button in the modal. As a result of the HTTP `DELETE` request,
    the web browser will display an `HTTP 403 Forbidden` status code in the response
    header and a detail message indicating that we do not have permission to perform
    the action in the JSON body. The owner for the drone we want to delete is `djangosuper`
    and the authentication credentials for this request use a different user, specifically,
    `user01`. Hence, the operation is rejected by the `has_object_permission` method
    in the `IsCurrentUserOwnerOrReadOnly` class. The following screenshot shows a
    sample response for the HTTP `DELETE` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd15f21d-27fe-49fc-a215-b63bfb46d6e6.png)'
  prefs: []
  type: TYPE_IMG
- en: The browsable API makes it easy to compose and send authenticated requests to
    our RESTful Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: Working with token-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will make changes to use token-based authentication to retrieve, update,
    or delete pilots. Only those users that have a token will be able to make these
    operations with pilots. Hence, we will setup a specific authentication for pilots.
    It will still be possible to see the pilot's name rendered in unauthenticated
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: The token-based authentication requires a new model named `Token`. Make sure
    you quit the Django's development server. Remember that you just need to press
    *Ctrl* + *C* in the terminal or command prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in a production environment, we must make sure that the RESTful Web
    Service is only available over HTTPS, with the usage of the latest TLS versions.
    We shouldn't use a token-based authentication over plain HTTP in a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/restful01/settings.py` file that declares module-level
    variables that define the configuration of Django for the `restful01` project.
    Locate the lines that assign a strings list to `INSTALLED_APPS` to declare the
    installed apps. Add the following string to the `INSTALLED_APPS` strings list
    and save the changes to the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the new code that declares the `INSTALLED_APPS` strings
    list with the added line highlighted and with comments to understand what each
    added string means. The code file for the sample is included in the `hillar_django_restful_08_02`
    folder in the `restful01/restful01/settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This way, we have added the `rest_framework.authtoken` application to our Django
    project named `restful01`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following Python script to execute all migrations required for
    the recently added `authtoken` application and apply the changes in the underlying
    database tables. This way, we will install the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command.
    Notice that the order in which the migrations are executed can differ in your
    development computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: After we run the previous command, we will have a new `authtoken_token` table
    in the PostgreSQL database. This table will persist the generated tokens and has
    a foreign key to the `auth_user` table.
  prefs: []
  type: TYPE_NORMAL
- en: We will configure authentication and permission policies for the class-based
    views that work with the `Pilot` model. We will override the values for the `authentication_classes`
    and `permission_classes` class attributes for the `PilotDetail` and `PilotList`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: We will add the same lines of code in the two classes. We will include the `TokenAuthentication`
    authentication class in the `authentication_classes` tuple, and the `IsAuthenticated`
    permission class in the `permission_classes` tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/drones/views.py` file and add the following lines after
    the last line that declares the imports, before the declaration of the `DroneCategorySerializer`
    class. The code file for the sample is included in the `hillar_django_restful_08_02`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code that declares the `PilotDetail` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_08_02`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code that declares the `PilotList` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_08_02`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Generating and using tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will launch our default Python interactive shell in our virtual environment
    and make all the Django project modules available to write code that will generate
    a token for an existing user. We will do this to understand how the token generation
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to launch the interactive shell. Make sure you are
    within the `restful01` folder in the terminal, Command Prompt, or Windows Powershell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that a line that says (InteractiveConsole) is displayed after
    the usual lines that introduce your default Python interactive shell. Enter the
    following code in the Python interactive shell to import all the things we will
    need to retrieve a `User` instance and generate a new token. The code file for
    the sample is included in the `hillar_django_restful_08_02` folder, in the `restful01/tokens_test_01.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code to retrieve an instance of the `User` model whose
    username matches "user01" and create a new `Token` instance related to this user.
    The last line prints the value for the `key` attribute for the generated `Token`
    instance saved in the `token` variable. Replace `user01` in the next lines with
    the name you configured for this user. The code file for the sample is included
    in the `hillar_django_restful_08_02` folder, in the `restful01/tokens_test_01.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line shows a sample output from the previous code with the string
    value for `token.key`. Copy the output generated when running the code because
    we will use this token to authenticate requests. Notice that the token generated
    in your system will be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, enter the following command to quit the interactive console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a token for the Django user named `user01`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can launch Django''s development server to compose and send HTTP requests
    to retrieve pilots to understand how the configured token authentication class
    combined with the permission policies work. Execute any of the following two commands
    based on your needs to access the API in other devices or computers connected
    to your LAN. Remember that we analyzed the difference between them in [Chapter
    3](dj-rst-websvc_ch13.html),*Creating API Views*, in the *Launching Django''s
    development server* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will compose and send an HTTP `GET` request without authentication credentials
    to try to retrieve the first page of the `pilots` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive an `HTTP 401 Unauthorized` status code in the response header
    and a detail message indicating that we didn''t provide authentication credentials
    in the JSON body. In addition, the value for the `WWW-Authenticate` header specifies
    the authentication method that must be applied to access the resource collection:
    `Token`. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'After the changes we made, if we want to retrieve the collection of pilots,
    that is, to make an HTTP `GET` request to `/pilots/`, we need to provide authentication
    credentials by using the token-based authentication. Now, we will compose and
    send an HTTP request to retrieve the collection of pilots with authentication
    credentials, that is, with the token. Remember to replace `PASTE-TOKEN-HERE` with
    the previously generated token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of the request, we will receive an `HTTP 200 OK` status code in
    the response header and the first page of the pilots collection serialized to
    JSON in the response body. The following screenshot shows the first lines of a
    sample response for the request with the appropriate token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b83974c-e9cd-4f8d-bddd-8f2dc13faea0.png)'
  prefs: []
  type: TYPE_IMG
- en: The token-based authentication provided with the Django REST framework is very
    simple and it requires customization to make it production ready. Tokens never
    expire and there is no setting to specify the default expiration time for a token.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see whether you can answer the following questions correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `permissions.SAFE_METHODS` tuple of string includes the following HTTP
    methods or verbs that are considered safe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''GET''`, `''HEAD''`, and `''OPTIONS''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''POST''`, `''PATCH''`, and `''OPTIONS''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''GET''`, `''PUT''`, and `''OPTIONS''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following settings key in the `REST_FRAMEWORK` dictionary specifies
    the global setting with a tuple of string whose values indicate the classes that
    we want to use for authentication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''GLOBAL_AUTHENTICATION_CLASSES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''DEFAULT_AUTHENTICATION_CLASSES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''REST_FRAMEWORK_AUTHENTICATION_CLASSES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is the model that persists a Django user?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Django.contrib.auth.DjangoUser`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Django.contrib.auth.User`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Django.rest-framework.User`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following classes is the base class from which all customized permission
    classes should inherit to work with the Django REST framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Django.contrib.auth.MainPermission`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.permissions.MainPermission`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework.permissions.BasePermission`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to configure permission policies for a class-based view, which of the
    following class attributes do we have to override?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`permission_classes`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`permission_policies_classes`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rest_framework_permission_classes`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the differences between authentication and permissions
    in Django, the Django REST framework, and RESTful Web Services. We analyzed the
    authentication classes included in the Django REST framework out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: We followed the necessary steps to include security and permissions-related
    data to models. We worked with object-level permissions via customized permission
    classes and we saved information about users that make requests. We understood
    that there are three HTTP methods or verbs that are considered safe.
  prefs: []
  type: TYPE_NORMAL
- en: We configured permission policies for the class-based views that worked with
    the `Drone` model. Then, we created a superuser and another user for Django to
    compose and send authenticated requests and to understand how the permission policies
    we configured were working.
  prefs: []
  type: TYPE_NORMAL
- en: We used command-line tools and GUI tools to compose and send authenticated requests.
    Then, we browsed the secured RESTful Web Service with the browsable API feature.
    Finally, we worked with a simple token-based authentication provided by the Django
    REST framework to understand another way of authenticating requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have improved our RESTful Web Service with authentication and permission
    policies, it is time to combine these policies with throttling rules and versioning.
    We will cover these topics in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Throttling Rules and Versioning Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with throttling rules to limit the usage of our
    RESTful Web Service. We don''t want to process requests until our RESTful Web
    Service runs out of resources, and therefore, we will analyze the importance of
    throttling rules. We will take advantage of the features included in the Django
    REST framework to manage different versions of our web service. We will gain an
    understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of throttling rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the purpose of the different throttling classes in the Django REST
    framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring throttling policies in the Django REST framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests to check that throttling policies work as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding versioning classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the versioning scheme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests to check that versioning works as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the importance of throttling rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](dj-rst-websvc_ch17.html), *Securing the API with Authentication
    and Permissions*, we made sure that some requests were authenticated before processing
    them. We took advantage of many authentication schemes to identify the user that
    originated the request. Throttling rules also determine whether the request must
    be authorized or not. We will work with them in combination with authentication.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we haven't established any limits on the usage of our RESTful Web Service.
    As a result of this configuration, both unauthenticated and authenticated users
    can compose and send as many requests as they want to. The only thing we have
    limited is the resultset size throughout the configuration of the pagination features
    available in the Django REST framework. Hence, large results sets are split into
    individual pages of data. However, a user might compose and send thousands of
    requests to be processed with any kind of limitation. Of course, the servers or
    virtual machines that run our RESTful Web Services or the underlying database
    can be overloaded by the huge amount of requests because we don't have limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throttles control the rate of requests that users can make to our RESTful Web
    Service. The Django REST framework makes it easy to configure throttling rules.
    We will use throttling rules to configure the following limitations to the usage
    of our RESTful Web Service:'
  prefs: []
  type: TYPE_NORMAL
- en: A maximum of 3 requests per hour for unauthenticated users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A maximum of 10 requests per hour for authenticated users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A maximum of 20 requests per hour for the drones related views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A maximum of 15 requests per hour for the pilots related views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the purpose of the different throttling classes in the Django REST
    framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Django REST framework provides three throttling classes in the `rest_framework.throttling`
    module. All of them are subclasses of the `SimpleRateThrottle` class which inherits
    from the `BaseThrottle` class.
  prefs: []
  type: TYPE_NORMAL
- en: The three classes allow us to specify throttling rules that indicate the maximum
    number of requests in a specific period of time and within a determined scope.
    Each class is responsible for computing and validating the maximum number of requests
    per period. The classes provide different mechanisms to determine the previous
    request information to specify the scope by comparing it with the new request.
    The Django REST framework stores the required data to analyze each throttling
    rule in the cache. Thus, the classes override the inherited `get_cache_key` method
    that determines the scope that will be used for computing and validating.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the three throttling classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnonRateThrottle`: This class limits the rate of requests that an anonymous
    user can make, and therefore, its rules apply to unauthenticated users. The unique
    cache key is the IP address of the incoming request. Hence, all the requests originated
    in the same IP address will accumulate the total number of requests for this IP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserRateThrottle`: This class limits the rate of requests that a specific
    user can make and applies to both authenticated and non-authenticated users. Obviously,
    when the requests are authenticated, the authenticated user ID is the unique cache
    key. When the requests are unauthenticated and come from anonymous users, the
    unique cache key is the IP address of the incoming request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScopedRateThrottle`: This class is useful whenever we have to restrict access
    to specific features of our RESTful Web Service with different rates. The class
    uses the value assigned to the `throttle_scope` attribute to limit requests to
    the parts that are identified with the same value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous classes are included in the Django REST framework out of the box.
    There are many additional throttling classes provided by many third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit the Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or Command Prompt window in which it is
    running. We will make the necessary changes to combine the different authentication
    mechanisms we set up in the previous chapter with the application of throttling
    rules. Hence, we will add the `AnonRateThrottle` and `UserRateThrottle` classes
    in the global throttling classes list.
  prefs: []
  type: TYPE_NORMAL
- en: The value for the `DEFAULT_THROTTLE_CLASSES` settings key specifies a global
    setting with a tuple of string whose values indicate the default classes that
    we want to use for throttling rules. We will specify the `AnonRateThrottle` and
    `UserRateThrottle` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DEFAULT_THROTTLE_RATES` settings key specifies a dictionary with the default
    throttle rates. The next list specifies the keys, the values that we will assign
    and their meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''anon''`: We will specify `''3/hour''` as the value for this key, which means
    we want a maximum of 3 requests per hour for anonymous users. The `AnonRateThrottle`
    class will apply this throttling rule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''user''`: We will specify `''10/hour''` as the value for this key, which
    means we want a maximum of 10 requests per hour for authenticated users. The `UserRateThrottle`
    class will apply this throttling rule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''drones''`: We will specify `''20/hour''` as the value for this key, which
    means we want a maximum of 20 requests per hour for the drones-related views.
    The `ScopedRateThrottle` class will apply this throttling rule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''pilots''`: We will specify `''15/hour''` as the value for this key, which
    means we want a maximum of 15 requests per hour for the drones-related views.
    The `ScopedRateThrottle` class will apply this throttling rule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The maximum rate value for each key is a string that specifies the number of
    requests per period with the following format: `''number_of_requests/period''`,
    where `period` can be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d`: day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`day`: day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h`: hour'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hour`: hour'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: minute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`: minute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sec`: second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we will always work with a maximum number of requests per hour,
    and therefore, the values will use `/hour` after the maximum number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/restful01/settings.py` file that declares module-level
    variables that define the configuration of Django for the `restful01` project.
    We will make some changes to this Django settings file. Add the highlighted lines
    to the `REST_FRAMEWORK` dictionary. The following lines show the new declaration
    of the `REST_FRAMEWORK` dictionary. The code file for the sample is included in
    the `hillar_django_restful_09_01` folder in the `restful01/restful01/settings.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: We added values for the `DEFAULT_THROTTLE_CLASSES` and the `DEFAULT_THROTTLE_RATES`
    settings keys to configure the default throttling classes and the desired rates.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring throttling policies in the Django REST framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will configure throttling policies for the class-based views related
    to drones: `DroneList` and `DroneDetail`. We will override the values for the
    following class attributes for the class-based views:'
  prefs: []
  type: TYPE_NORMAL
- en: '`throttle_classes`: This class attribute specifies a tuple with the names of
    the classes that will manage throttling rules for the class. In this case, we
    will specify the `ScopedRateThrottle` class as the only member of the tuple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throttle_scope`: This class attribute specifies the throttle scope name that
    the `ScopedRateThrottle` class will use to accumulate the number of requests and
    limit the rate of requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This way, we will make these class-based views work with the `ScopedRateThrottle`
    class and we will configure the throttle scope that this class will consider for
    each of the class based views related to drones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `restful01/drones/views.py` file and add the following lines after
    the last line that declares the imports, before the declaration of the `DroneCategoryList`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code that declares the `DroneDetail` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_09_01`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code that declares the `DroneList` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_09_01`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: We added the same lines in the two classes. We assigned `'drones'` to the `throttle_scope`
    class attribute and we included `ScopedRateThrottle` in the tuple that defines
    the value for `throttle_classes`. This way, the two class-based views will use
    the settings specified for the `'drones'` scope and the `ScopeRateThrottle` class
    for throttling. We added the `'drones'` key to the `DEFAULT_THROTTLE_RATES` key
    in the `REST_FRAMEWORK` dictionary, and therefore, the `'drones'` scope is configured
    to serve a maximum of 20 requests per hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will configure throttling policies for the class-based views related
    to pilots: `PilotList` and `PilotDetail`. We will also override the values for
    the `throttle_scope` and `throttle_classes` class attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the code that declares the `PilotDetail` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_09_01`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the code that declares the `PilotList` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_09_01`
    folder, in the `restful01/drones/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: We added the same lines in the two classes. We assigned `'pilots'` to the `throttle_scope`
    class attribute and we included `ScopedRateThrottle` in the tuple that defines
    the value for `throttle_classes`. This way, the two class-based views will use
    the settings specified for the `'pilots'` scope and the `ScopeRateThrottle` class
    for throttling. We added the `'pilots'` key to the `DEFAULT_THROTTLE_RATES` key
    in the `REST_FRAMEWORK` dictionary, and therefore, the `'drones'` scope is configured
    to serve a maximum of 15 requests per hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the class-based views we have edited won''t take into account the global
    settings that applied the default classes that we use for throttling: `AnonRateThrottle`
    and `UserRateThrottle`. These class-based views will use the configuration we
    have specified for them.'
  prefs: []
  type: TYPE_NORMAL
- en: Running tests to check that throttling policies work as expected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Django runs the main body of a class-based view, it performs the checks
    for each throttle class specified in the throttle classes settings. In the drones
    and pilots-related views, we wrote code that overrides the default settings.
  prefs: []
  type: TYPE_NORMAL
- en: If a single throttle check fails, the code will raise a `Throttled` exception
    and Django won't execute the main body of the view. The cache is responsible for
    storing previous request information for throttling checking.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can launch Django's development server to compose and send HTTP requests
    to understand how the configured throttling rules, combined with all the previous
    configurations, work. Execute any of the following two commands based on your
    needs to access the API in other devices or computers connected to your LAN. Remember
    that we analyzed the difference between them in [Chapter 3](dj-rst-websvc_ch13.html),*Creating
    API Views*, in the *Launching Django's development server* section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send the following HTTP `GET` request without authentication
    credentials to retrieve the first page of the competitions four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the features of the shell in macOS or Linux to run the previous
    command four times with just a single line with a bash shell. The command is compatible
    with a Cygwin terminal in Windows. We must take into account that we will see
    all the results one after the other and we will have to scroll to understand what
    happened with each execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line allows you to run the command four times with a single line
    in Windows PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that we must execute four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that is executed four times with
    a single line in a bash shell in a macOS or Linux, or a Cygwin terminal in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that is executed four times with
    a single line in Windows PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The Django REST framework won''t process the request number 4\. The `AnonRateThrottle`
    class is configured as one of the default throttle classes and its throttle settings
    specify a maximum of 3 requests per hour. Hence, we will receive an HTTP `429
    Too many requests` status code in the response header and a message indicating
    that the request was throttled and the time in which the server will be able to
    process an additional request. The value for the `Retry-After` key in the response
    header provides the number of seconds that we must wait until the next request:
    `2347`. The following lines show a sample response. Notice that the number of
    seconds might be different in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send the following HTTP `GET` request with authentication
    credentials to retrieve the first page of the competitions four times. We will
    use the superuser we created in the previous chapter. Remember to replace `djangosuper`
    with the name you used for the superuser and `passwordforsuper` with the password
    you configured for this user as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'In a Linux, macOS or a Cygwin terminal, we can run the previous command four
    times with the following single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The following line allows you to run the command four times with a single line
    in Windows PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that we must execute four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that we can execute four times
    in a Linux, macOS or a Cygwin terminal with a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that is executed four times with
    a single line in Windows PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Django will process the request number 4 because we have composed
    and sent 4 authenticated requests with the same user. The `UserRateThrottle` class
    is configured as one of the default throttle classes and its throttle settings
    specify 10 requests per hour. We still have 6 requests before we accumulate the
    maximum number of requests per hour.
  prefs: []
  type: TYPE_NORMAL
- en: If we compose and send the same request 7 times more, we will accumulate 11
    requests and we will will receive an HTTP `429 Too many requests` status code
    in the response header, a message indicating that the request was throttled and
    the time in which the server will be able to process an additional request after
    the last execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send the following HTTP `GET` request without authentication
    credentials to retrieve the first page of the drones collection 20 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the features of the shell in macOS or Linux to run the previous
    command 20 times with just a single line with a bash shell. The command is compatible
    with a Cygwin terminal in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line allows you to run the command 20 times with a single line
    in Windows PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that we must execute 20 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that is executed 20 times with
    a single line in a bash shell in macOS or Linux, or a Cygwin terminal in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that is executed 20 times with
    a single line in Windows PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: The Django REST framework will process the 20 requests. The `DroneList` class
    has its `throttle_scope` class attribute set to `'drones'` and uses the `ScopedRateThrottle`
    class to accumulate the requests in the specified scope. The `'drones'` scope
    is configured to accept a maximum of 20 requests per hour, and therefore, if we
    make another request with the same non-authenticated user and this request accumulates
    in the same scope, the request will be throttled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve the details
    for a drone. Make sure you replace `1` for any existing drone ID value that was
    listed in the results for the previous requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The Django REST framework won''t process this request. The request ends up
    routed to the `DroneDetail` class. The `DroneDetail` class has its `throttle_scope`
    class attribute set to `''drones''` and uses the `ScopedRateThrottle` class to
    accumulate the requests in the specified scope. Thus, both the `DroneList` and
    the `DroneDetail` class accumulate in the same scope. The new request from the
    same non-authenticated user becomes the request number 21 for the `''drones''`
    scope that is configured to accept a maximum of 20 requests per hour, and therefore,
    we will receive an HTTP `429 Too many requests` status code in the response header
    and a message indicating that the request was throttled and the time in which
    the server will be able to process an additional request. The value for the `Retry-After`
    key in the response header provides the number of seconds that we must wait until
    the next request: `3138`. The following lines show a sample response. Notice that
    the number of seconds might be different in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Throttling rules are extremely important to make sure that users don't abuse
    our RESTful Web Service and that we keep control of the resources that are being
    used to process incoming requests. We should never put a RESTful Web Service in
    production without a clear configuration for throttling rules.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding versioning classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we have to keep many different versions of a RESTful Web Service
    alive at the same time. For example, we might need to have version 1 and version
    2 of our RESTful Web Service accepting and processing requests. There are many
    versioning schemes that make it possible to serve many versions of a web service.
  prefs: []
  type: TYPE_NORMAL
- en: The Django REST framework provides five classes in the `rest_framework.versioning`
    module. All of them are subclasses of the `BaseVersioning` class. The five classes
    allow us to work with a specific versioning scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use one of these classes in combination with changes in the URL configurations
    and other pieces of code to support the selected versioning scheme. Each class
    is responsible for determining the version based on the implemented schema and
    to make sure that the specified version number is a valid one based on the allowed
    version settings. The classes provide different mechanisms to determine the version
    number. The following are the five versioning classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AcceptHeaderVersioning`: This class configures a versioning scheme that requires
    each request to specify the desired version as an additional value of the media
    type specified as a value for the `Accept` key in the header. For example, if
    a request specifies `''application/json; version=1.2''` as the value for the `Accept`
    key in the header, the `AcceptHeaderVersioning` class will set the `request.version`
    attribute to `''1.2''`. This scheme is known as media type versioning, content
    negotiation versioning or accept header versioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostNameVersioning`: This class configures a versioning scheme that requires
    each request to specify the desired version as a value included in the hostname
    in the URL. For example, if a request specifies `v2.myrestfulservice.com/drones/`
    as the URL, it means that the request wants to work with version number 2 of the
    RESTful Web Service. This scheme is known as hostname versioning or domain versioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URLPathVersioning`: This class configures a versioning scheme that requires
    each request to specify the desired version as a value included in the URL path.
    For example, if a request specifies `v2/myrestfulservice.com/drones/` as the URL,
    it means that the request wants to work with version number 2 of the RESTful Web
    Service. The class requires us to work with a `version` URL keyword argument.
    This scheme is known as URI versioning or URL path versioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NamespaceVersioning`: This class configures the versioning scheme explained
    for the `URLPathVersioning` class. The only difference compared with this other
    class is that the configuration in the Django REST framework application is different.
    In this case, it is necessary to use URL namespacing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueryParameterVersioning`: This class configures a versioning scheme that
    requires each request to specify the desired version as a query parameter. For
    example, if a request specifies `myrestfulservice.com/?version=1.2`, the `QueryParameterVersioning`
    class will set the `request.version` attribute to `''1.2''`. This scheme is known
    as query parameter versioning or request parameter versioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous classes are included in the Django REST framework out of the box.
    It is also possible to code our own customized versioning scheme. Each versioning
    scheme has its advantages and trade-offs. In this case, we will work with the
    `NamespaceVersioning` class to provide a new version of the RESTful Web Service
    with a minor change compared to the first version. However, it is necessary to
    analyze carefully whether you really need to use any versioning scheme. Then,
    you need to figure out which is the most appropriate one based on your specific
    needs. Of course, if possible, we should always avoid any versioning scheme because
    they add complexity to our RESTful Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a versioning scheme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine we have to serve the following two versions of our RESTful Web
    Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version 1**: The version we have developed so far. However, we want to make
    sure that the clients understand that they are working with version 1, and therefore,
    we want to include a reference to the version number in the URL for each HTTP
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version 2**: This version has to allow clients to reference the drones resource
    collection with the `vehicles` name instead of `drones`. In addition, the drone
    categories resource collection must be accessed with the `vehicle-categories`
    name instead of `drone-categories`. We also want to make sure that the clients
    understand that they are working with version 2, and therefore, we want to include
    a reference to the version number in the URL for each HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between the second and the first version will be minimal because
    we want to keep the example simple. In this case, we will take advantage of the
    previously explained `NamespaceVersioning` class to configure a `URL path versioning
    scheme.`
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit the Django's development server. Remember that you just need
    to press *Ctrl + C* in the terminal or command prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make the necessary changes to configure the usage of the `NameSpaceVersioning`
    class as the default versioning class for our RESTful Web Service. Open the `restful01/restful01/settings.py`
    file that declares module-level variables that define the configuration of Django
    for the `restful01` project. We will make some changes to this Django settings
    file. Add the highlighted lines to the `REST_FRAMEWORK` dictionary. The following
    lines show the new declaration of the `REST_FRAMEWORK` dictionary. The code file
    for the sample is included in the `hillar_django_restful_09_02` folder in the
    `restful01/restful01/settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: We added a value for the `DEFAULT_VERSIONING_CLASS` settings key to configure
    the default versioning class that we want to use. As happened whenever we added
    values for settings keys, the new configuration will be applied to all the views
    as a global setting that we are able to override if necessary in specific classes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new sub-folder named `v2` within the `restful01/drones` folder (`restful01\drones`
    in Windows). This new folder will be the baseline for the specific code required
    for version 2 of our RESTful Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the recently created `restful01/drones/v2` folder and create a new file
    named `views.py`. Write the following code in this new file. The following lines
    show the code for this file that creates the new `ApiRootVersion2` class declared
    as a subclass of the `generics.GenericAPIView` class. The code file for the sample
    is included in the `hillar_django_restful_09_02` folder in the `restful01/drones/v2/views.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The `ApiRootVersion2` class is a subclass of the `rest_framework.generics.GenericAPIView`
    class and declares the `get` method. As we learned in *[Chapter 6](dj-rst-websvc_ch16.html),
    Working with Advanced Relationships and Serialization*, the `GenericAPIView` class
    is the base class for all the generic views we have been working with. We will
    make the Django REST framework use this class instead of the `ApiRoot` class when
    the requests work with version 2.
  prefs: []
  type: TYPE_NORMAL
- en: The `ApiRootVersion2` class defines the `get` method that returns a `Response`
    object with key/value pairs of strings that provide a descriptive name for the
    view and its URL, generated with the `rest_framework.reverse.reverse` function.
    This URL resolver function returns a fully qualified URL for the view. Whenever
    we call the `reverse` function, we include the `request` value for the `request`
    argument. It is very important to do this in order to make sure that the `NameSpaceVersioning`
    class can work as expected to configure the versioning scheme.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the response defines keys named `'vehicle-categories'` and `'vehicles'`
    instead of the `'drone-cagories'` and `'drones'` keys that are included in the
    `views.py` file, in the `ApiRoot` class that will be used for version 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go to the recently created `restful01/drones/v2` folder and create a new
    file named `urls.py`. Write the following code in this new file. The following
    lines show the code for this file that declares the `urlpatterns` array. The lines
    that are different compared to the first version are highlighted. The code file
    for the sample is included in the `hillar_django_restful_09_02` folder in the
    `restful01/drones/v2/urls.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The previous code defines the URL patterns that specify the regular expressions
    that have to be matched in the request to run a specific method for a class-based
    view defined in the original version of the `views.py` file. We want version 2
    to use `vehicle-categories` and `vehicles` instead of `drone-categories` and `drones`.
    However, we won't make changes in the serializer, and therefore, we will only
    change the URL that the clients must use to make requests related to drone categories
    and drones.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have to replace the code in the `urls.py` file in the `restful01/restful01`
    folder, specifically, the `restful01/restful01/urls.py` file. The file defines
    the root URL configurations, and therefore, we must include the URL patterns for
    the two versions declared in the `restful01/drones/urls.py` and in the `restful01/drones/v2/urls.py`.
    The following lines show the new code for the `restful01/restful01/urls.py` file.
    The code file for the sample is included in the `hillar_django_restful_09_02`
    folder, in the `restful01/restful01/urls.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a URL starts with `v1/`, the url patterns defined for the previous
    version will be used and the `namespace` will be set to `'v1'`. Whenever a URL
    starts with `v2/`, the url patterns defined for version 2 will be used and the
    namespace will be set to `'v2'`. We want the browsable API to display the log
    in and log out views for the two versions, and therefore, we included the necessary
    code to include the definitions included in `rest_framework.urls` for each of
    the versions, with different namespaces. This way, we will be able to easily test
    the two versions with the browsable API and the configured authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests to check that versioning works as expected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can launch Django's development server to compose and send HTTP requests
    to understand how the configured versioning scheme works. Execute any of the following
    two commands based on your needs to access the API in other devices or computers
    connected to your LAN. Remember that we analyzed the difference between them in
    [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*, in the *Launching
    Django's development server* section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve the first page
    of the drone categories by working with the first version of our RESTful Web Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/v1/drone-categories/`. The request URL starts with `v1/`
    after the domain and the port number (`http://localhost:8000/`), and therefore,
    it will match the `''^v1/''` regular expression and will test the regular expressions
    defined in the `restful01/drones/urls.py` file and will work with a namespace
    equal to `''v1''`. Then, the URL without the version prefix (`''v1/''`) will match
    the `''drone-categories/$''`regular expression and run the `get` method for the
    `views.DroneCategoryList` class-based view.'
  prefs: []
  type: TYPE_NORMAL
- en: The `NamespaceVersioning` class makes sure that the rendered URLs include the
    appropriate version prefix in the response. The following lines show a sample
    response for the HTTP request, with the first and only page of drone categories.
    Notice that the URLs for the drones list for each category include the version
    prefix. In addition, the value of the `url` key for each drone category includes
    the version prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve the first page
    of the vehicle categories by working with the second version of our RESTful Web
    Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/v2/vehicle-categories/`. The request URL starts with `v2/`
    after the domain and the port number (`http://localhost:8000/`), and therefore,
    it will match the `''^v2/''` regular expression and will test the regular expressions
    defined in the `restful01/drones/v2/urls.py` file and will work with a namespace
    equal to `''v2''`. Then, the URL without the version prefix (`''v2/''`) will match
    the `''vehicle-categories/$''`regular expression and run the `get` method for
    the `views.DroneCategoryList` class-based view.'
  prefs: []
  type: TYPE_NORMAL
- en: As happened with the previous request, the `NamespaceVersioning` class makes
    sure that the rendered URLs include the appropriate version prefix in the response.
    The following lines show a sample response for the HTTP request, with the first
    and only page of vehicle categories. We haven't made changes to the serializer
    in the new version, and therefore, each category will render a list named `drones`.
    However, the URLs for the drones list for each category include the version prefix
    and they use the appropriate URL with a `vehicle` in the URL instead of a drone.
    In addition, the value of the `url` key for each vehicle category includes the
    version prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a web browser and enter `http://localhost:8000/v1`. The browser will compose
    and send a `GET` request to `/v1` with `text/html` as the desired content type
    and the returned HTML web page will be rendered. The request will end up executing
    the `get` method defined in the `ApiRoot` class within the `restful01/drones/views.py`
    file. The following screenshot shows the rendered web page with the resource description:
    Api Root. The Api Root for the first version uses the appropriate URLs for version
    1, and therefore, all the URLs start with `http://localhost:8000/v1/`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b03ca25a-db69-4fe5-a709-08da995e95a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go to `http://localhost:8000/v2`. The browser will compose and send a
    `GET` request to `/v2` with `text/html` as the desired content type and the returned
    HTML web page will be rendered. The request will end up executing the `get` method
    defined in the `ApiRootVersion2` class within the `restful01/drones/v2/views.py`
    file. The following screenshot shows the rendered web page with the resource description:
    Api Root Version2\. The Api Root for the first version uses the appropriate URLs
    for version 2, and therefore, all the URLs start with `http://localhost:8000/v2/`.
    You can check the differences with the Api Root rendered for version 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d9c65a1-f6a5-41ea-904e-847a463e6510.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This new version of the Api Root renders the following hyperlinks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8000/v2/vehicle-categories/`: The collection of vehicle categories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/v2/vehicles/`: The collection of vehicles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/v2/pilots/`: The collection of pilots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/v2/competitions/`: The collection of competitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use all the features provided by the browsable API with the two versions
    we have configured.
  prefs: []
  type: TYPE_NORMAL
- en: Developing and maintaining multiple versions of a RESTful Web Service is an
    extremely complex task that requires a lot of planning. We must take into account
    the different versioning schemes that the Django REST framework provides out of
    the box to make our job simpler. However, it is always very important to avoid
    making things more complex than necessary. We should keep any versioning scheme
    as simple as possible and we must make sure that we continue to provide RESTful
    Web Services with easily identifiable resources and resource collections in the
    URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rest_framework.throttling.UserRateThrottle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests that a specific user can make and applies to *both
    authenticated and non-authenticated users*
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests that a specific user can make and applies *only
    to authenticated users*
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests that a specific user can make and applies *only
    to non-authenticated users*
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following settings key in the `REST_FRAMEWORK` dictionary specifies
    the global setting with a tuple of string whose values indicate the classes that
    we want to use for throttling rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''DEFAULT_THROTTLE_CLASSES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''GLOBAL_THROTTLE_CLASSES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''REST_FRAMEWORK_THROTTLE_CLASSES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following settings key in the `REST_FRAMEWORK` dictionary specifies
    a dictionary with the default throttle rates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''GLOBAL_THROTTLE_RATES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''DEFAULT_THROTTLE_RATES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''REST_FRAMEWORK_THROTTLE_RATES''`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `rest_framework.throttling.ScopedRateThrottle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests that an anonymous user can make
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests that a specific user can make
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests for specific parts of the RESTful Web Service identified
    with the value assigned to the `throttle_scope` property
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `rest_framework.versioning.NamespaceVersioning` class configures a versioning
    scheme known as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Query parameter versioning or request parameter versioning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Media type versioning, content negotiation versioning or accept header versioning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: URI versioning or URL path versioning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the importance of throttling rules and how we
    can combine them with authentication and permissions in Django, the Django REST
    framework and RESTful Web Services. We analyzed the throttling classes included
    in the Django REST framework out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: We followed the necessary steps to configure many throttling policies in the
    Django REST framework. We worked with global and scope-related settings. Then,
    we used command-line tools to compose and send many requests to test how the throttling
    rules worked.
  prefs: []
  type: TYPE_NORMAL
- en: We understood versioning classes and we configured a URL path versioning scheme
    to allow us to work with two versions of our RESTful Web Service. We used command-line
    tools and the browsable API to understand the differences between the two versions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can combine throttling rules, authentication and permission policies
    with versioning schemes, it is time to explore other features offered by the Django
    REST framework and third-party packages to improve our RESTful Web Service and
    automate tests. We will cover these topics in the next chapter.
  prefs: []
  type: TYPE_NORMAL
