- en: Using Constraints, Filtering, Searching, Ordering, and Pagination
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用约束、过滤、搜索、排序和分页
- en: 'In this chapter, we will take advantage of many features included in the Django
    REST framework to add constraints, pagination, filtering, searching, and ordering
    features to our RESTful Web Service. We will add a huge amount of features with
    a few lines of code. We will gain an understanding of:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用 Django REST 框架中包含的许多功能，为我们的 RESTful Web 服务添加约束、分页、过滤、搜索和排序功能。我们只需几行代码就能添加大量功能。我们将了解：
- en: Browsing the API with resources and relationships
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用资源和关系浏览 API
- en: Defining unique constraints
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义唯一约束
- en: Working with unique constraints
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用唯一约束进行工作
- en: Understanding pagination
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解分页
- en: Configuring pagination classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置分页类
- en: Making requests that paginate results
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分页结果的请求
- en: Working with customized pagination classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义分页类进行工作
- en: Making requests that use customized paginated results
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义分页结果的请求
- en: Configuring filter backend classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置过滤后端类
- en: Adding filtering, searching, and ordering
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加过滤、搜索和排序
- en: Working with different types of Django filters
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同类型的 Django 过滤器进行工作
- en: Making requests that filter results
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行过滤结果的请求
- en: Composing requests that filter and order results
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合过滤和排序结果的请求
- en: Making requests that perform starts with searches
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行以搜索开头的请求
- en: Using the browsable API to test pagination, filtering, searching, and ordering
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可浏览的 API 测试分页、过滤、搜索和排序
- en: Browsing the API with resources and relationships
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资源和关系浏览 API
- en: We will take advantage of the browsable API feature that we introduced in [Chapter
    5](dj-rst-websvc_ch15.html),* Understanding and Customizing the Browsable API
    Feature*, with our new web service. Let's start browsing our new RESTful Web Service.
    Open a web browser and enter `http://localhost:8000`. The browser will compose
    and send a `GET` request to `/` with `text/html` as the desired content type,
    and the returned HTML web page will be rendered.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们在第 5 章[理解并自定义可浏览 API 功能](dj-rst-websvc_ch15.html)中引入的可浏览 API 功能，结合我们的新
    Web 服务。让我们开始浏览我们的新 RESTful Web 服务。打开一个网页浏览器，输入 `http://localhost:8000`。浏览器将组合并发送一个带有
    `text/html` 作为期望内容类型的 `GET` 请求到 `/`，返回的 HTML 网页将被渲染。
- en: 'The request will end up executing the `GET` method defined in the `ApiRoot`
    class within the `views.py` file. The following screenshot shows the rendered
    web page with the resource description Api Root:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请求最终将执行 `views.py` 文件中 `ApiRoot` 类定义的 `GET` 方法。以下截图显示了带有资源描述 Api Root 的渲染网页：
- en: '![](img/4e6c4e6e-fc28-42b8-a414-84671a6e6c58.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e6c4e6e-fc28-42b8-a414-84671a6e6c58.png)'
- en: 'The Api Root renders the following hyperlinks:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Api Root 渲染以下超链接：
- en: '`http://localhost:8000/drone-categories/`: The collection of drone categories'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/drone-categories/`: 无人机类别的集合'
- en: '`http://localhost:8000/drones/`: The collection of drones'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/drones/`: 无人机的集合'
- en: '`http://localhost:8000/pilots/`: The collection of pilots'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/pilots/`: 飞行员的集合'
- en: '`http://localhost:8000/competitions/`: The collection of competitions'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/competitions/`: 竞赛的集合'
- en: We can easily access each resource collection by clicking or tapping on the
    appropriate hyperlink. Once we access each resource collection, we can perform
    operations on the different resources throughout the browsable API. Whenever we
    visit any of the resource collections, we can use the breadcrumb to go back to
    the Api Root that lists all the hyperlinks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松通过点击或轻触适当的超链接来访问每个资源集合。一旦我们访问了每个资源集合，我们就可以在可浏览的 API 中对不同的资源执行操作。每次我们访问任何资源集合时，我们都可以使用面包屑导航回到列出所有超链接的
    API 根。
- en: Our new RESTful Web Service takes advantage of many generic views. These views
    provide many features for the browsable API that weren't included when we worked
    with function-based views, and we will be able to use forms to easily compose
    and send HTTP `POST` requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新 RESTful Web 服务利用了许多通用视图。这些视图为可浏览的 API 提供了许多功能，这些功能在我们使用基于函数的视图时并未包含，我们将能够使用表单轻松地组合并发送
    HTTP `POST` 请求。
- en: 'Click or tap on the URL at the right-hand side of drone-categories and the
    web browser will go to `http://localhost:8000/drone-categories/`. As a result,
    Django will render the web page for the Drone Category List. At the bottom of
    the web page, there are two tabs to make an HTTP POST request: Raw data and HTML
    form. By default, the HTML form tab is activated and displays an automatically
    generated form with a textbox to enter the value for the Name field to create
    a new drone category. We can use this form to easily compose and send an HTTP
    POST request without having to deal with the raw JSON data as we did when working
    with the browsable API and our previous web service. The following screenshot
    shows the HTML form to create a new drone category:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触无人机类别右侧的URL，网页浏览器将跳转到 `http://localhost:8000/drone-categories/`。结果，Django将渲染无人机类别列表的网页。在网页底部，有两个选项卡可以发起HTTP
    POST请求：原始数据和HTML表单。默认情况下，HTML表单选项卡被激活，并显示一个自动生成的表单，其中包含用于输入名称字段值的文本框。我们可以使用这个表单轻松地组合并发送HTTP
    POST请求，而无需像处理可浏览的API和我们的前一个Web服务时那样处理原始JSON数据。以下截图显示了创建新无人机类别的HTML表单：
- en: '![](img/99ba53ff-72e1-4c21-94a1-6a40cfe4d7a2.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99ba53ff-72e1-4c21-94a1-6a40cfe4d7a2.png)'
- en: HTML forms make it really easy to generate requests to test our RESTful web
    service with the browsable API.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单使得通过可浏览的API轻松生成请求来测试我们的RESTful Web服务变得非常简单。
- en: 'Enter the following value in the Name textbox: `Octocopter`. Then, click or
    tap POST to create a new drone category. The browsable API will compose and send
    an HTTP `POST` request to `/drone-categories/` with the specified data. Then,
    we will see the results of this request in the web browser. The following screenshot
    shows the rendered web page with the results of the previous operation, with an
    HTTP status code of `201 Created` in the response and the previously explained
    HTML form with the POST button that allows us to continue composing and sending
    HTTP `POST` requests to `/drone-categories/`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称文本框中输入以下值：`Octocopter`。然后，点击或轻触POST以创建一个新的无人机类别。可浏览的API将组合并发送一个HTTP `POST`
    请求到 `/drone-categories/`，带有指定数据。然后，我们将在网页浏览器中看到这个请求的结果。以下截图显示了上一个操作渲染的网页结果，响应中有一个HTTP状态码为`201
    Created`，以及之前解释的带有POST按钮的HTML表单，该按钮允许我们继续组合并发送HTTP `POST` 请求到 `/drone-categories/`：
- en: '![](img/562ff41e-6c31-45d9-83e6-947634b56c10.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/562ff41e-6c31-45d9-83e6-947634b56c10.png)'
- en: 'Now, you can go back to the Api Root by clicking on the link on the breadcrumb
    and use the HTML forms to create drones, pilots, and finally, competitions. For
    example, go to the Api Root and click or tap on the URL at the right-hand side
    of drones and the web browser will go to `http://localhost:8000/drones/`. As a
    result, Django will render the web page for the Drone List. At the bottom of the
    web page, there are two tabs to make an HTTP POST request: Raw data and HTML form.
    By default, the HTML form tab is activated and displays an automatically generated
    form with the appropriate controls for the following fields:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过点击面包屑中的链接返回Api根目录，并使用HTML表单创建无人机、飞行员，最后是比赛。例如，转到Api根目录，点击或轻触无人机右侧的URL，网页浏览器将跳转到
    `http://localhost:8000/drones/`。结果，Django将渲染无人机列表的网页。在网页底部，有两个选项卡可以发起HTTP POST请求：原始数据和HTML表单。默认情况下，HTML表单选项卡被激活，并显示一个自动生成的表单，其中包含以下字段的适当控件：
- en: Name
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Drone category
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无人机类别
- en: Manufacturing date
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制造日期
- en: Has it competed
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否已参赛
- en: The Drone category field provides a drop-down with all the existing drone categories
    so that we can select one of them for our new drone. The Has it competed field
    provides a checkbox because the underlying field is Boolean.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无人机类别字段提供了一个下拉菜单，包含所有现有的无人机类别，以便我们可以为我们的新无人机选择其中一个。是否已参赛字段提供了一个复选框，因为底层字段是布尔类型。
- en: 'We can use this form to easily compose and send an HTTP `POST` request without
    having to deal with the raw JSON data as we did when working with the browsable
    API and our previous web service. The following screenshot shows the HTML form
    to create a new drone:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个表单轻松地组合并发送一个HTTP `POST` 请求，而无需像处理可浏览的API和我们的前一个Web服务时那样处理原始JSON数据。以下截图显示了创建新无人机的HTML表单：
- en: '![](img/b11fe842-b418-4f1b-b823-f3bad85094d4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b11fe842-b418-4f1b-b823-f3bad85094d4.png)'
- en: Defining unique constraints
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义唯一约束
- en: 'The RESTful Web Service doesn''t use any constraints, and therefore, it is
    possible to create many drone categories with the same name. We don''t want to
    have many drone categories with the same name. Each drone category name must be
    unique in the database table that persists drone categories (the `drones_dronecategory`
    table). We also want drones and pilots to have unique names. Hence, we will make
    the necessary changes to add unique constraints to each of the following fields:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web服务不使用任何约束，因此可以创建许多具有相同名称的无人机类别。我们不想有太多具有相同名称的无人机类别。每个无人机类别名称必须在持久化无人机类别的数据库表（`drones_dronecategory`表）中是唯一的。我们还想让无人机和飞行员具有唯一的名称。因此，我们将对以下每个字段添加唯一约束的必要更改进行必要的更改：
- en: The name field of the `DroneCategory` model
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DroneCategory`模型的名称字段'
- en: The name field of the `Drone` model
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Drone`模型的名称字段'
- en: The name field of the `Pilot` model
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pilot`模型的名称字段'
- en: We will learn the necessary steps to edit existing models and add constraints
    to fields that are already persisted in tables and to propagate the changes in
    the underlying database by running the already analyzed migrations process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过运行已分析的迁移过程来学习编辑现有模型和向已持久化到表中的字段添加约束的必要步骤，并通过运行迁移过程在底层数据库中传播更改。
- en: Make sure you quit Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or Command Prompt window in which it is
    running. We have to edit the models and then execute migrations before starting
    Django's development server again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您退出Django的开发服务器。请记住，您只需在终端或命令提示符窗口中按*Ctrl* + *C*即可。我们必须编辑模型并执行迁移，然后再启动Django的开发服务器。
- en: 'Now, we will edit the existing code that declares the models to add unique
    constraints to the `name` field for the models that we use to represent and persist
    the drone categories, drones, and pilots. Open the `drones/models.py` file and
    replace the code that declares the `DroneCategory`, `Drone`, and `Pilot` classes
    with the following code. The lines that were edited are highlighted in the code
    listing. The code for the `Competition` class remains without changes. The code
    file for the sample is included in the `hillar_django_restful_07_01` folder, in
    the `restful01/drones/models.py` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑现有的声明模型的代码，为用于表示和持久化无人机类别、无人机和飞行员的模型添加对`name`字段的唯一约束。打开`drones/models.py`文件，并用以下代码替换声明`DroneCategory`、`Drone`和`Pilot`类的代码。代码列表中已编辑的行被突出显示。`Competition`类的代码保持不变。示例代码文件包含在`hillar_django_restful_07_01`文件夹中的`restful01/drones/models.py`文件中：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We added `unique=True` as one of the named arguments for each call to the `models.CharField`
    initializer. This way, we specify that the fields must be unique, and Django's
    ORM will translate this into a requirement for the creation of the necessary unique
    constraints for the fields in the underlying database tables.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`unique=True`作为每个调用`models.CharField`初始化器的命名参数之一添加。这样，我们指定字段必须是唯一的，Django的ORM会将此转换为在底层数据库表中创建必要唯一约束的要求。
- en: 'Now, it is necessary to execute the migrations that will generate the unique
    constraints we added for the fields in the models in the database. This time,
    the migrations process will synchronize the database with the changes we made
    in the models, and therefore, the process will apply a delta. Run the following
    Python script:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行将为我们添加到模型中字段生成的唯一约束的迁移是必要的。这次，迁移过程将同步数据库与我们在模型中做出的更改，因此，该过程将应用一个增量。运行以下Python脚本：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following lines show the output generated after running the previous command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一个命令后生成的输出：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The lines in the output indicate that the `drones/migrations/0002_auto_20171104_0246.py`
    file includes the code to alter the fields called `name` on `drone`, `dronecategory`,
    and `pilot`. It is important to take into account that the Python filename generated
    by the migrations process encodes the date and time, and therefore, the name will
    be different when you run the code in your development computer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的行表明`drones/migrations/0002_auto_20171104_0246.py`文件包含了更改`drone`、`dronecategory`和`pilot`上名为`name`的字段的代码。重要的是要注意，迁移过程生成的Python文件名包含了日期和时间，因此，当您在开发计算机上运行代码时，名称将不同。
- en: 'The following lines show the code for the file that was automatically generated
    by Django. The code file for the sample is included in the `hillar_django_restful_07_01`
    folder, in the `restful01/drones/migrations/0002_auto_20171104_0246.py` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了由 Django 自动生成的文件的代码。示例的代码文件包含在 `hillar_django_restful_07_01` 文件夹中的 `restful01/drones/migrations/0002_auto_20171104_0246.py`
    文件中：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code defines a subclass of the `django.db.migrations.Migration` class called
    `Migration`, which defines an `operations` list with many `migrations.AlterField`
    instances. Each `migrations.AlterField` instance will alter the field in the table
    for each of the related models: `drone`, `dronecategory`, and `pilot`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个名为 `Migration` 的 `django.db.migrations.Migration` 类的子类，该类定义了一个包含许多 `migrations.AlterField`
    实例的 `operations` 列表。每个 `migrations.AlterField` 实例将更改与每个相关模型（`drone`、`dronecategory`
    和 `pilot`）相关的表中的字段。
- en: 'Now, run the following Python script to execute all the generated migrations
    and apply the changes in the underlying database tables:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下 Python 脚本来执行所有生成的迁移并在底层数据库表中应用更改：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following lines show the output generated after running the previous command.
    Notice that the order in which the migrations are executed can differ in your
    development computer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一个命令后生成的输出。请注意，迁移执行的顺序可能在您的开发计算机中有所不同：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After we run the previous command, we will have unique indexes on the `name`
    fields for the following tables in the PostgreSQL database:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行上一个命令后，PostgreSQL 数据库中以下表的 `name` 字段将具有唯一索引：
- en: '`drones_drone`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drones_drone`'
- en: '`drones_dronecategory`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drones_dronecategory`'
- en: '`drones_pilot`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drones_pilot`'
- en: We can use the PostgreSQL command-line tools or any other application that allows
    us to easily check the contents of the PostgreSQL database to check the tables
    that Django updated. If you are working with an SQLite or any other database with
    this example, make sure you use the commands or tools related to the database
    you are using.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 PostgreSQL 命令行工具或任何允许我们轻松检查 PostgreSQL 数据库内容的其他应用程序来检查 Django 更新了哪些表。如果您使用的是
    SQLite 或其他数据库，请确保您使用与您使用的数据库相关的命令或工具。
- en: 'The following screenshot shows a list of the indexes for each of the previously
    enumerated tables in the SQLPro for Postgres GUI tool. Each table has a new unique
    index for the name field:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 SQLPro for Postgres GUI 工具中之前列举的每个表的索引列表。每个表都有一个针对名称字段的新的唯一索引：
- en: '![](img/1fbca5f4-4c17-428c-a170-febbbc9162b3.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fbca5f4-4c17-428c-a170-febbbc9162b3.png)'
- en: 'The following are the names generated for the new unique indexes in the sample
    database:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在示例数据库中为新唯一索引生成的名称：
- en: The `drones_drone_name_85faecee_uniq` index for the `drones_drone` table
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drones_drone` 表的 `drones_drone_name_85faecee_uniq` 唯一索引'
- en: The `drones_drone_dronecategory_name_dedead86_uniq` index for the `drones_dronecategory`
    table
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drones_dronecategory` 表的 `drones_drone_dronecategory_name_dedead86_uniq` 唯一索引'
- en: The `drones_pilot_name_3b56f2a1_uniq` index for the `drones_pilot` table
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drones_pilot` 表的 `drones_pilot_name_3b56f2a1_uniq` 唯一索引'
- en: Working with unique constraints
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理唯一约束
- en: 'Now, we can launch Django''s development server to compose and send HTTP requests
    to understand how unique constraints work when applied to our models. Execute
    any of the following two commands, based on your needs, to access the API in other
    devices or computers connected to your LAN. Remember that we analyzed the difference
    between them in [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*, in
    the *Launching Django''s development server* section:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动 Django 的开发服务器来编写并发送 HTTP 请求，以了解当唯一约束应用于我们的模型时的工作方式。根据您的需求，执行以下两个命令之一，以在其他设备或连接到您的局域网的计算机上访问
    API。请记住，我们在 *启动 Django 的开发服务器* 部分的 [第 3 章](dj-rst-websvc_ch13.html) 中分析了它们之间的区别：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行任何之前的命令后，开发服务器将监听端口 `8000`。
- en: 'Now, we will compose and send an HTTP request to create a drone category with
    a name that already exists: `''Quadcopter''`, as shown below:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个 HTTP 请求来创建一个名为 `'Quadcopter'` 的无人机类别，如下所示：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Django won''t be able to persist a `DroneCategory` instance whose `name` is
    equal to the specified value because it violates the unique constraint we just
    added to the `name` field for the `DroneCategory` model. As a result of the request,
    we will receive a `400 Bad Request` status code in the response header and a message
    related to the value specified for the `name` field in the JSON body: `"drone
    category with this name already exists."` The following lines show the detailed
    response:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Django无法持久化名称等于指定值的`DroneCategory`实例，因为它违反了我们刚刚添加到`DroneCategory`模型`name`字段的唯一约束。由于请求的结果，我们将在响应头中收到`400
    Bad Request`状态码，并在JSON体中收到与`name`字段指定的值相关的消息：“具有此名称的无人机类别已存在。”以下行显示了详细的响应：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We made the necessary changes to avoid duplicate values for the `name` field
    in drone categories, drones, or pilots. Whenever we specify the name for any of
    these resources, we will be referencing the same unique resource, because duplicates
    aren't possible.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对无人机类别、无人机或飞行员中的`name`字段进行了必要的更改，以避免重复值。每当指定这些资源中的任何一个的名称时，我们都会引用相同的唯一资源，因为不可能存在重复。
- en: 'Now, we will compose and send an HTTP request to create a pilot with a name
    that already exists: `''Penelope Pitstop''`, as shown below:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求来创建一个具有已存在名称的飞行员：`'Penelope Pitstop'`，如下所示：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The previous command will compose and send an HTTP `POST` request with the
    specified JSON key-value pairs. The request specifies `/pilots/`, and therefore,
    it will match the `''^pilots/$''` regular expression and will run the `post` method
    for the `views.PilotList` class-based view. Django won''t be able to persist a
    `Pilot` instance whose `name` is equal to the specified value because it violates
    the unique constraint we just added to the `name` field for the `Pilot` model.
    As a result of the request, we will receive a `400 Bad Request` status code in
    the response header and a message related to the value specified for the `name`
    field in the JSON body: `"pilot with this name already exists."` The following
    lines show the detailed response:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将使用指定的JSON键值对编写并发送一个HTTP `POST`请求。请求指定`/pilots/`，因此它将匹配`'^pilots/$'`正则表达式，并运行`views.PilotList`类视图的`post`方法。由于请求，我们将在响应头中收到`400
    Bad Request`状态码，并在JSON体中收到与`name`字段指定的值相关的消息：“具有此名称的飞行员已存在。”以下行显示了详细的响应：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we generate the HTTP `POST` request with the help of the HTML form in the
    browsable API, we will see the error message displayed below the Name field in
    the form, as shown in the next screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们借助可浏览API中的HTML表单生成HTTP `POST`请求，我们将在表单中名称字段下方看到显示的错误消息，如下一个屏幕截图所示：
- en: '![](img/e3a58bab-9384-4f36-8196-7e2dfeb4daf9.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3a58bab-9384-4f36-8196-7e2dfeb4daf9.png)'
- en: Understanding pagination
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解分页
- en: So far, we have been working with a database that has just a few rows, and therefore,
    the HTTP `GET` requests to the different resource collections for our RESTful
    Web Service don't have problems with the amount of data in the JSON body of the
    responses. However, this situation changes as the number of rows in the database
    tables increases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用只有几行的数据库，因此，我们对RESTful Web服务的不同资源集合发出的HTTP `GET`请求在响应JSON体中的数据量方面没有问题。然而，随着数据库表中行数的增加，这种情况发生了变化。
- en: Let's imagine we have 300 rows in the `drones_pilots` table that persists pilots.
    We don't want to retrieve the data for 300 pilots whenever we make an HTTP `GET`
    request to `localhost:8000/pilots/`. Instead, we just take advantage of the pagination
    features available in the Django REST framework to make it easy to specify how
    we want the large result sets to be split into individual pages of data. This
    way, each request will retrieve only one page of data, instead of the entire result
    set. For example, we can make the necessary configurations to retrieve only the
    data for a page of a maximum of four pilots.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们在`drones_pilots`表中持久化飞行员有300行。我们不希望在向`localhost:8000/pilots/`发出HTTP `GET`请求时检索300名飞行员的全部数据。相反，我们只需利用Django
    REST框架中可用的分页功能，使其易于指定我们希望将大量结果集拆分为单个数据页的方式。这样，每个请求将只检索一页数据，而不是整个结果集。例如，我们可以进行必要的配置，以仅检索最多四名飞行员的页面数据。
- en: Whenever we enable a pagination scheme, the HTTP `GET` requests must specify
    the pieces of data that they want to retrieve, that is, the details for the specific
    pages, based on predefined pagination schemes. In addition, it is extremely useful
    to have data about the total number of resources, the next page, and the previous
    one, in the response body. This way, the user or the application that is consuming
    the RESTful Web Service knows the additional requests that need to be made to
    retrieve the required pages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们启用分页方案时，HTTP `GET`请求必须指定它们想要检索的数据片段，即基于预定义的分页方案的具体页面的详细信息。此外，在响应体中包含有关资源总数、下一页和上一页的数据极为有用。这样，使用RESTful
    Web服务的用户或应用程序就知道需要发出哪些额外请求以检索所需的页面。
- en: We can work with page numbers and the client can request a specific page number
    in the HTTP `GET` request. Each page will include a maximum amount of resources.
    For example, if we request the first page for the 300 pilots, the web service
    will return the first four pilots in the response body. The second page will return
    the pilots from the fifth to the eighth position in the response body.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用页码，客户端可以在HTTP `GET`请求中请求特定的页码。每一页将包含最大数量的资源。例如，如果我们请求300名飞行员的第一页，Web服务将在响应体中返回前四个飞行员。第二页将返回响应体中第五到第八位的飞行员。
- en: Another option is to specify an offset combined with a limit. For example, if
    we request a page with an offset equal to 0 and a limit of 4, the web service
    will return the first four pilots in the response body. A second request with
    an offset equal to 4 and a limit of 4 will return the pilots from the fifth to
    the eighth position in the response body.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选项是指定偏移量与限制。例如，如果我们请求一个偏移量为0且限制为4的页面，Web服务将在响应体中返回前四个飞行员。第二次请求偏移量为4且限制为4的请求将返回响应体中第五到第八位的飞行员。
- en: Right now, each of the database tables that persist the models we have defined
    has a few rows. However, after we start working with our web service in a real-life
    production environment, we will have hundreds of competitions, pilots, drones,
    and drone categories. Hence, we will definitely have to deal with large result
    sets. We will usually have the same situation in most RESTful Web Services, and
    therefore, it is very important to work with pagination mechanisms.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们定义的模型持久化的每个数据库表都有几行。然而，在我们开始在现实生活中的生产环境中使用我们的Web服务后，我们将有数百场比赛、飞行员、无人机和无人机类别。因此，我们肯定必须处理大量结果集。在大多数RESTful
    Web服务中，我们通常会有相同的情况，因此，与分页机制一起工作非常重要。
- en: Configuring pagination classes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置分页类
- en: The Django REST framework provides many options to enable pagination. First,
    we will set up one of the customizable pagination styles included in the Django
    REST framework to include a maximum of four resources in each individual page
    of data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架提供了许多选项来启用分页。首先，我们将设置Django REST框架中包含的可定制的分页样式之一，以便在数据每一页中包含最多四个资源。
- en: Our RESTful Web Service uses the generic views that work with **mixin** classes.
    These classes are prepared to build paginated responses based on specific settings
    in the Django REST framework configuration. Hence, our RESTful Web Service will
    automatically take into account the pagination settings we configured, without
    requiring additional changes in the code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的RESTful Web服务使用与**mixin**类一起工作的通用视图。这些类已经准备好根据Django REST框架配置中的特定设置构建分页响应。因此，我们的RESTful
    Web服务将自动考虑我们配置的分页设置，而无需在代码中进行额外更改。
- en: 'Open the `restful01/restful01/settings.py` file that declares module-level
    variables that define the configuration of Django for the `restful01` project.
    We will make some changes to this Django settings file. The code file for the
    sample is included in the `hillar_django_restful_07_01` folder, in the `restful01/restful01/settings.py`
    file. Add the following lines that declare a dictionary named `REST_FRAMEWORK` with
    key-value pairs that configure the global pagination settings:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`restful01/restful01/settings.py`文件，该文件声明了定义`restful01`项目Django配置的模块级变量。我们将对此Django设置文件进行一些更改。示例代码文件包含在`hillar_django_restful_07_01`文件夹中，位于`restful01/restful01/settings.py`文件中。添加以下行，声明一个名为`REST_FRAMEWORK`的字典，其中包含配置全局分页设置的键值对：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save the changes and Django''s development server will recognize the edits
    and start again with the new pagination settings enabled. The new dictionary has
    two string keys: `''DEFAULT_PAGINATION_CLASS''` and `''PAGE_SIZE''`. The value
    for the `''DEFAULT_PAGINATION_CLASS''` key specifies a global setting with the
    default pagination class that the generic views will use to provide paginated
    responses. In this case, we will use the `rest_framework.pagination.LimitOffsetPagination`
    class that provides a limit/offset-based style.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改后，Django的开发服务器将识别编辑并重新启动，启用新的分页设置。新的字典有两个字符串键：`'DEFAULT_PAGINATION_CLASS'`
    和 `'PAGE_SIZE'`。`'DEFAULT_PAGINATION_CLASS'` 键的值指定了一个全局设置，即通用视图将使用的默认分页类，用于提供分页响应。在这种情况下，我们将使用
    `rest_framework.pagination.LimitOffsetPagination` 类，它提供基于限制/偏移的样式。
- en: This pagination style works with a `limit` parameter that indicates the maximum
    number of items to return and an `offset` that specifies the starting position
    of the query. The value for the `PAGE_SIZE` settings key specifies a global setting
    with the default value for the `limit`, also known as the page size. In this case,
    the value is set to `4`, and therefore, the maximum number of resources returned
    in a single request will be four. We can specify a different limit when we perform
    the HTTP request by specifying the desired value in the `limit` query parameter.
    We can configure the class to have a maximum `limit` value in order to avoid undesired
    huge result sets. This way, we can make sure that the user won't be able to specify
    a large number for the `limit` value. However, we will make this specific configuration
    later.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分页样式使用一个 `limit` 参数，表示要返回的最大项目数，以及一个指定查询起始位置的 `offset`。`PAGE_SIZE` 设置键的值指定了一个全局设置，即
    `limit` 的默认值，也称为页面大小。在这种情况下，该值设置为 `4`，因此，单个请求中返回的资源最大数量将是四个。我们可以在执行HTTP请求时通过指定
    `limit` 查询参数中的所需值来指定不同的限制。我们可以配置类以具有最大的 `limit` 值，以避免不希望的大结果集。这样，我们可以确保用户无法指定一个大的
    `limit` 值。然而，我们将在稍后进行此特定配置。
- en: 'Now, we will compose and send many HTTP `POST` requests to create nine additional
    drones related to the two drone categories we created: `Quadcopter` and `Octocopter`.
    This way, we will have a total of 11 drones (two existing drones, plus nine additional
    drones) to test the limit/offset pagination mechanism we have enabled:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送多个HTTP `POST` 请求来创建与我们所创建的两个无人机类别（`Quadcopter` 和 `Octocopter`）相关的九个额外无人机：这样，我们将总共拥有11架无人机（两个现有无人机加上九个额外无人机）来测试我们已启用的限制/偏移分页机制：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following are the equivalent `curl` commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous commands will compose and send nine HTTP `POST` requests with the
    specified JSON key-value pairs. The requests specify `/drones/`, and therefore,
    they will match the `'^drones/$'` regular expression and run the `post` method
    for the `views.DroneList` class-based view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送九个HTTP `POST` 请求，指定了指定的JSON键值对。请求指定 `/drones/`，因此，它们将匹配 `'^drones/$'`
    正则表达式，并运行 `views.DroneList` 类视图的 `post` 方法。
- en: Making requests that paginate results
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送分页结果请求
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve all the drones.
    The new pagination settings will take effect and we will only retrieve the first
    page for the drones resource collection:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP `GET` 请求来检索所有无人机。新的分页设置将生效，我们只会检索无人机资源集合的第一页：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous commands will compose and send an HTTP `GET` request. The request
    specifies `/drones/`, and therefore, it will match the `''^drones/$''` regular
    expression and run the `get` method for the `views.DroneList` class-based view.
    The method executed in the generic view will use the new settings we added to
    enable the offset/limit pagination, and the result will provide us with the first
    four drone resources. However, the response body looks different than in the previous
    HTTP `GET` requests we made to any resource collection. The following lines show
    the sample response that we will analyze in detail. Don''t forget that the drones
    are being sorted by the name field, in ascending order:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送一个HTTP `GET` 请求。请求指定`/drones/`，因此，它将匹配`'^drones/$'`正则表达式，并运行`views.DroneList`类视图的`get`方法。在通用视图中执行的方法将使用我们添加的新设置来启用偏移/限制分页，并提供给我们前四个无人机资源。然而，响应体看起来与我们在之前对任何资源集合发出的HTTP
    `GET` 请求不同。以下行显示了我们将详细分析的示例响应。别忘了无人机是按名称字段升序排序的：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The response has a `200 OK` status code in the header and the following keys
    in the response body:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 响应头中有一个`200 OK`状态码，响应体中有以下键：
- en: '`count`: The value indicates the total number of drones for the query.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：该值表示查询的无人机总数。'
- en: '`next`: The value provides a link to the next page.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`：该值提供了一个到下一页的链接。'
- en: '`previous`: The value provides a link to the previous page. In this case, the
    response includes the first page of the result set, and therefore, the link to
    the previous page is `null`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previous`：该值提供了一个到上一页的链接。在这种情况下，响应包括结果集的第一页，因此，上一页的链接是`null`。'
- en: '`results`: The value provides an array of JSON representations of `Drone` instances
    that compose the requested page. In this case, the four drones belong to the first
    page of the result set.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`results`：该值提供了一个由请求页面的`Drone`实例组成的JSON表示数组的值。在这种情况下，四个无人机属于结果集的第一页。'
- en: In the previous HTTP `GET` request, we didn't specify any values for either
    the `limit` or `offset` parameters. We specified `4` as the default value for
    the `limit` parameter in the global settings and the generic views use this configuration
    value and provide us with the first page. Whenever we don't specify any `offset`
    value, the default `offset` is equal to `0` and the `get` method will return the
    first page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的HTTP `GET` 请求中，我们没有指定`limit`或`offset`参数的任何值。我们在全局设置中将`limit`参数的默认值指定为`4`，通用视图使用此配置值并提供给我们第一页。每次我们没有指定任何`offset`值时，默认的`offset`等于`0`，`get`方法将返回第一页。
- en: 'The previous request is equivalent to the following HTTP `GET` request that
    specifies `0` for the `offset` value. The result of the next command will be the
    same as the previous one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的请求等同于以下指定`offset`值为`0`的HTTP `GET` 请求。下一个命令的结果将与之前的相同：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The previous requests are equivalent to the following HTTP `GET` request that
    specifies `0` for the offset value and `4` for the limit value. The result of
    the next command will be the same as the previous two commands:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的请求等同于以下指定`offset`值为`0`和`limit`值为`4`的HTTP `GET` 请求。下一个命令的结果将与之前的两个命令相同：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will compose and send an HTTP request to retrieve the next page, that
    is, the second page for the drones. We will use the value for the `next` key provided
    in the JSON body of the response from the previous requests. This value gives
    us the URL for the next page: `http://localhost:8000/drones/?limit=4&offset=4`.
    Thus, we will compose and send an HTTP `GET` method to `/drones/` with the limit
    value set to `4` and the `offset` value set to `4` :'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求以检索下一页，即无人机的第二页。我们将使用前一个请求的JSON响应体中提供的`next`键的值。这个值为我们提供了下一页的URL：`http://localhost:8000/drones/?limit=4&offset=4`。因此，我们将编写并发送一个HTTP
    `GET` 方法到`/drones/`，将限制值设置为`4`，将`offset`值设置为`4`：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result will provide us the second page of four drone resources as the value
    for the `results` key in the response body. In addition, we will see the values
    for the `count`, `previous`, and `next` keys that we analyzed in the previous
    requests. The following lines show the sample response:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将为我们提供四个无人机资源中的第二页，作为响应体中`results`键的值。此外，我们还将看到之前请求中分析的`count`、`previous`和`next`键的值。以下行显示了示例响应：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this case, the result set is the second page, and therefore, we have a value
    for the `previous` key: `http://localhost:8000/drones/?limit=4`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果集是第二页，因此，我们有一个`previous`键的值：`http://localhost:8000/drones/?limit=4`。
- en: 'In the previous HTTP request, we specified values for both the `limit` and
    `offset` parameters. However, as we set the default value of `limit` to `4` in
    the global settings, the following request will produce the same results as the
    previous request:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的HTTP请求中，我们指定了`limit`和`offset`参数的值。然而，由于我们在全局设置中将`limit`的默认值设置为`4`，接下来的请求将产生与之前请求相同的结果：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we will compose and send an HTTP request to retrieve the next page, that
    is, the third and last page for the drones. We will use the value for the `next`
    key provided in the JSON body of the response from the previous requests. This
    value gives us the URL for the next page as `http://localhost:8000/drones/?limit=4&offset=8`.
    Thus, we will compose and send an HTTP `GET` method to `/drones/` with the limit
    value set to `4` and the `offset` value set to `8` :'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求以检索下一页，即无人机的第三页和最后一页。我们将使用之前请求的JSON响应体中提供的`next`键的值。此值为我们提供了下一页的URL，即`http://localhost:8000/drones/?limit=4&offset=8`。因此，我们将编写并发送一个HTTP
    `GET`方法到`/drones/`，将限制值设置为`4`，将`offset`值设置为`8`：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result will provide us with the third and last page of three drone resources
    as the value for the `results` key in the response body. In addition, we will
    see the values for the `count`, `previous`, and `next` keys that we analyzed in
    the previous requests. The following lines show the sample response:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将为我们提供三个无人机资源中的第三页和最后一页，作为响应体中`results`键的值。此外，我们还将看到之前请求中分析的`count`、`previous`和`next`键的值。以下行显示了示例响应：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this case, the result set is the last page, and therefore, we have `null`
    as the value for the `next` key.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果集是最后一页，因此，`next`键的值为`null`。
- en: Working with customized pagination classes
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义分页类进行工作
- en: We enabled pagination to limit the size for the result sets. However, any client
    or user is able to specify a large number for the `limit` value, such as `10000`,
    and generate a huge result set. In order to specify the maximum number that is
    accepted for the limit query parameter, it is necessary to create a customized
    version of the limit/offset pagination scheme that the Django REST framework provides
    us.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用了分页来限制结果集的大小。然而，任何客户端或用户都可以指定一个大的`limit`值，例如`10000`，并生成一个巨大的结果集。为了指定接受`limit`查询参数的最大数值，有必要创建一个自定义的Django
    REST框架提供的limit/offset分页方案的版本。
- en: We made changes to the global configuration to use the `rest_framework.pagination.LimitOffsetPagination`
    class to handle paginated responses. This class declares a `max_limit` class attribute
    whose default value is equal to `None`, which means there is no upper bound for
    the `limit` value. We will indicate the upper bound value for the limit query
    parameter in the `max_limit` class attribute.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对全局配置进行了更改，使用`rest_framework.pagination.LimitOffsetPagination`类来处理分页响应。这个类声明了一个`max_limit`类属性，其默认值等于`None`，这意味着`limit`值没有上限。我们将在`max_limit`类属性中指定`limit`查询参数的上限值。
- en: Make sure you quit Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or Command Prompt in which it is running.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您退出Django的开发服务器。请记住，您只需在终端或运行它的命令提示符中按*Ctrl* + *C*即可。
- en: 'Go to the `restful01/drones` folder and create a new file named `custompagination.py`.
    Write the following code in this new file. The following lines show the code for
    this file that declares the new `LimitOffsetPaginationWithUpperBound` class. The
    code file for the sample is included in the `hillar_django_restful_07_02` folder
    in the `restful01/drones/custompagination.py` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`restful01/drones`文件夹，并创建一个名为`custompagination.py`的新文件。在这个新文件中编写以下代码。以下行显示了此文件的代码，该代码声明了新的`LimitOffsetPaginationWithUpperBound`类。示例的代码文件包含在`hillar_django_restful_07_02`文件夹中的`restful01/drones/custompagination.py`文件中：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous lines declare the `LimitOffsetPaginationWithUpperBound` class as
    a subclass of  `rest_framework.pagination.LimitOffsetPagination`. This new class
    overrides the value assigned to the `max_limit` class attribute with `8`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行声明了`LimitOffsetPaginationWithUpperBound`类为`rest_framework.pagination.LimitOffsetPagination`类的子类。这个新类覆盖了分配给`max_limit`类属性的值，将其设置为`8`。
- en: 'Open the `restful01/restful01/settings.py` file and replace the line that specifies
    the value for the `DEFAULT_PAGINATION_CLASS` key in the `REST_FRAMEWORK` dictionary
    with the highlighted line. The following lines show the new declaration of the
    `REST_FRAMEWORK` dictionary. The code file for the sample is included in the `hillar_django_restful_07_02`
    folder in the `restful01/restful01/settings.py` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`restful01/restful01/settings.py`文件，并将指定`REST_FRAMEWORK`字典中`DEFAULT_PAGINATION_CLASS`键值的行替换为高亮行。以下行显示了新的`REST_FRAMEWORK`字典声明。示例的代码文件包含在`hillar_django_restful_07_02`文件夹中的`restful01/restful01/settings.py`文件中：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This way, all the generic views will use the recently declared `drones.custompagination.LimitOffsetPaginationWithUpperBound`
    class that provides the limit/offset pagination scheme we have analyzed with an
    upper bound for the `limit` value equal to `8`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，所有通用视图都将使用最近声明的`drones.custompagination.LimitOffsetPaginationWithUpperBound`类，该类提供了我们已分析的带有`limit`值上限为`8`的限制/偏移分页方案。
- en: If any request specifies a value higher than 8 for the limit, the class will
    use the maximum limit value, that is, `8`, and the RESTful Web Service will never
    return more than eight resources in a paginated response.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何请求指定的限制值高于8，则该类将使用最大限制值，即`8`，并且RESTful Web服务永远不会在分页响应中返回超过八个资源。
- en: It is a good practice to configure a maximum limit to avoid generating responses
    with huge amounts of data that might generate important loads to the server running
    the RESTful Web Service. Note that we will learn to limit the usage of the resources
    of our RESTful Web Service in the forthcoming chapters. Pagination is just the
    beginning of a long story.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 配置最大限制是一个好习惯，可以避免生成可能对运行RESTful Web服务的服务器产生重要负载的大量数据响应。请注意，我们将在接下来的章节中学习如何限制我们RESTful
    Web服务资源的使用。分页只是漫长故事的开端。
- en: Making requests that use customized paginated results
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送使用自定义分页结果的请求
- en: Launch Django's development server. If you don't remember how to start Django's
    development server, check the instructions in [Chapter 3](dj-rst-websvc_ch13.html),* Creating
    API Views*, in the *Launching Django's development server* section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Django的开发服务器。如果你不记得如何启动Django的开发服务器，请查看*启动Django开发服务器*部分中的[第3章](dj-rst-websvc_ch13.html)，*创建API视图*中的说明。
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve the first page
    for the drones with the value for the `limit` query parameter set to `500`. This
    value is higher than the maximum limit we established:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP `GET`请求，以检索具有`limit`查询参数值为`500`的无人机的第一页。这个值高于我们设定的最大限制：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The code in the `get` method for the `views.DroneList` class-based view will
    use the new settings we added to enable the customized offset/limit pagination,
    and the result will provide us with the first eight drone resources because the
    maximum value for the limit query is set to `8`. The value specified for the `limit`
    query parameter is greater than `8`, and therefore, the maximum value of `8` is
    used, instead of the value indicated in the request.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`views.DroneList`类视图的`get`方法中的代码将使用我们添加的新设置来启用自定义的偏移/限制分页，并且结果将提供给我们前八个无人机资源，因为限制查询的最大值被设置为`8`。指定的`limit`查询参数值大于`8`，因此，将使用最大值`8`，而不是请求中指示的值。'
- en: The key advantage of working with generic views is that we can easily customize
    the behavior for the methods defined in the mixins that compose these views with
    just a few lines of code. In this case, we took advantage of the pagination features
    available in the Django REST framework to specify how we wanted large results
    sets to be split into individual pages of data. Then, we customized paginated
    results with just a few lines of code to make the limit/offset pagination scheme
    match our specific requirements.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用视图一起工作的关键优势是，我们可以通过几行代码轻松自定义由这些视图组成的混入中定义的方法的行为。在这种情况下，我们利用了Django REST框架中可用的分页功能来指定我们希望如何将大型结果集拆分为单独的数据页。然后，我们仅用几行代码自定义了分页结果，以使限制/偏移分页方案符合我们的特定要求。
- en: Configuring filter backend classes
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置过滤器后端类
- en: So far, we have been working with the entire queryset as the result set. For
    example, whenever we requested the drones resource collection, the RESTful Web
    Service worked with the entire resource collection and used the default sorting
    we had configured in the model. Now, we want our RESTful Web Service to be able
    to provide filtering, searching, and sorting features.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用整个查询集作为结果集。例如，每次我们请求无人机资源集合时，RESTful Web服务都会处理整个资源集合并使用我们在模型中配置的默认排序。现在，我们希望我们的RESTful
    Web服务能够提供过滤、搜索和排序功能。
- en: It is very important to understand that we have to be careful with the fields
    we configure to be available in the filtering, searching, and ordering features.
    The configuration will have an impact on the queries executed on the database,
    and therefore, we must make sure that we have the appropriate database optimizations,
    considering the queries that will be executed. Specific database optimizations
    are outside of the scope of this book, but you definitely must take them into
    account when you configure these features.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要理解，我们必须小心配置可用于过滤、搜索和排序的字段。配置将对数据库执行的查询产生影响，因此，我们必须确保我们有适当的数据库优化，考虑到将要执行的查询。具体的数据库优化超出了本书的范围，但您在配置这些功能时绝对必须考虑它们。
- en: Make sure you quit Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or Command Prompt window in which it is
    running.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已退出Django的开发服务器。请记住，您只需在终端或命令提示符窗口中按*Ctrl* + *C*即可。
- en: 'Run the following command to install the `django-filter` package in our virtual
    environment. This package will enable us to use many field filtering features
    that we can easily customize in the Django REST framework. Make sure the virtual
    environment is activated, and run the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令在我们的虚拟环境中安装`django-filter`包。此包将使我们能够使用许多字段过滤功能，我们可以在Django REST框架中轻松自定义这些功能。确保虚拟环境已激活，并运行以下命令：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last lines of the output will indicate that the `django-filter` package
    has been successfully installed:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`django-filter`包已成功安装：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will work with the following three classes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下三个类：
- en: '`rest_framework.filters.OrderingFilter`: This class allows the client to control
    how the results are ordered with a single query parameter. We can specify which
    fields may be ordered against.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rest_framework.filters.OrderingFilter`：此类允许客户端通过单个查询参数控制结果的排序方式。我们可以指定哪些字段可以进行排序。'
- en: '`django_filters.rest_framework.DjangoFilterBackend`: This class provides field
    filtering capabilities. We can specify the set of fields we want to be able to
    filter against, and the filter backend defined in the `django-filter` package
    will create a new `django_filters.rest_framework.FilterSet` class and associate
    it to the class-based view. It is also possible to create our own `rest_framework.filters.FilterSet`
    class, with more customized settings, and write our own code to associate it with
    the class-based view.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_filters.rest_framework.DjangoFilterBackend`：此类提供字段过滤功能。我们可以指定我们想要能够过滤的字段集，并且`django-filter`包中定义的过滤后端将创建一个新的`django_filters.rest_framework.FilterSet`类并将其关联到基于类的视图。我们还可以创建自己的`rest_framework.filters.FilterSet`类，具有更多自定义设置，并编写自己的代码将其与基于类的视图关联。'
- en: '`rest_framework.filters.SearchFilter`: This class provides single query parameter-based
    searching capabilities, and its behavior is based on the Django admin''s search
    function. We can specify the set of fields we want to include for the search feature
    and the client will be able to filter items by making queries that search on these
    fields with a single query. It is useful when we want to make it possible for
    a request to search on multiple fields with a single query.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rest_framework.filters.SearchFilter`：此类提供基于单个查询参数的搜索功能，其行为基于 Django 管理员的搜索功能。我们可以指定我们想要包含在搜索功能中的字段集，客户端可以通过对这些字段进行搜索的查询来过滤项目。当我们要使请求能够通过单个查询在多个字段上进行搜索时，这很有用。'
- en: It is possible to configure the filter backends by including any of the previously
    enumerated classes in a tuple and assigning it to the `filter_backends` class
    attribute for the generic view classes. In our RESTful Web Service, we want all
    our class-based views to use the same filter backends, and therefore, we will
    make changes in the global configuration.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在元组中包含之前枚举的任何类来配置过滤器后端，并将其分配给通用视图类的 `filter_backends` 类属性。在我们的 RESTful Web
    服务中，我们希望所有基于类的视图都使用相同的过滤器后端，因此我们将对全局配置进行修改。
- en: 'Open the `restful01/restful01/settings.py` file that declares module-level
    variables that define the configuration of Django for the `restful01` project.
    We will make some changes to this Django settings file. Add the highlighted lines
    that declare the `''DEFAULT_FILTER_BACKENDS''` key and assign a tuple of strings
    as its value with the three classes we have analyzed. The following lines show
    the new declaration of the `REST_FRAMEWORK` dictionary. The code file for the
    sample is included in the `hillar_django_restful_07_03` folder in the `restful01/restful01/settings.py`
    file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 打开声明 `restful01/restful01/settings.py` 文件中 Django `restful01` 项目的配置的模块级变量文件。我们将对此
    Django 设置文件进行一些修改。添加高亮显示的行，声明 `'DEFAULT_FILTER_BACKENDS'` 键并将其值设置为包含我们已分析的三种类的字符串元组。以下行显示了新的
    `REST_FRAMEWORK` 字典声明。示例代码文件包含在 `hillar_django_restful_07_03` 文件夹中的 `restful01/restful01/settings.py`
    文件中：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Locate the lines that assign a string list to `INSTALLED_APPS` to declare the
    installed apps. Add the following string to the `INSTALLED_APPS` string list and
    save the changes to the `settings.py` file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到将字符串列表赋值给 `INSTALLED_APPS` 的行，以声明已安装的应用程序。将以下字符串添加到 `INSTALLED_APPS` 字符串列表中，并将更改保存到
    `settings.py` 文件中：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following lines show the new code that declares the `INSTALLED_APPS` string
    list with the added line highlighted and with comments to understand what each
    added string means. The code file for the sample is included in the `hillar_django_restful_07_03`
    folder in the `restful01/restful01/settings.py` file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了新的代码，声明了带有高亮显示的添加行和注释的 `INSTALLED_APPS` 字符串列表。示例代码文件包含在 `hillar_django_restful_07_03`
    文件夹中的 `restful01/restful01/settings.py` 文件中：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This way, we have added the `django_filters` application to our Django project
    named `restful01`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就将 `django_filters` 应用程序添加到了名为 `restful01` 的 Django 项目中。
- en: The default query parameter names are `search` for the search feature and `ordering`
    for the ordering feature. We can specify other names by setting the desired strings
    in the `SEARCH_PARAM` and the `ORDERING_PARAM` settings. In this case, we will
    work with the default values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认查询参数名称是 `search` 用于搜索功能，`ordering` 用于排序功能。我们可以通过在 `SEARCH_PARAM` 和 `ORDERING_PARAM`
    设置中设置所需的字符串来指定其他名称。在这种情况下，我们将使用默认值。
- en: Adding filtering, searching, and ordering
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加过滤、搜索和排序
- en: 'Now, we will add the necessary code to configure the fields that we want to
    be included in the filtering, searching, and ordering features for each of the
    class-based views that retrieve the contents of each resource collection. Hence,
    we will make changes to all the classes with the `List` suffix in the `views.py`
    file: `DroneCategoryList`, `DroneList`, `PilotList`, and `CompetitionList`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加必要的代码来配置我们想要包含在每个基于类的视图中的过滤、搜索和排序功能，这些视图检索每个资源集合的内容。因此，我们将修改 `views.py`
    文件中所有带有 `List` 后缀的类：`DroneCategoryList`、`DroneList`、`PilotList` 和 `CompetitionList`。
- en: 'We will declare the following three class attributes in each of those classes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这些类中声明以下三个类属性：
- en: '`filter_fields`: This attribute specifies a tuple of strings whose values indicate
    the field names that we want to be able to filter against. Under the hood, the
    Django REST framework will automatically create a `rest_framework.filters.FilterSet`
    class and associate it to the class-based view in which we are declaring the attribute.
    We will be able to filter against the field names included in the tuple of strings.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter_fields`: 此属性指定了一个字符串元组，其值表示我们想要能够进行过滤的字段名称。在底层，Django REST框架将自动创建一个`rest_framework.filters.FilterSet`类，并将其关联到我们声明此属性的基于类的视图中。我们将能够对字符串元组中包含的字段名称进行过滤。'
- en: '`search_fields`: This attribute specifies a tuple of strings whose values indicate
    the text type field names that we want to include in the search feature. In all
    the usages, we will want to perform a starts-with match. In order to do this,
    we will include `''^''` as a prefix of the field name to indicate that we want
    to restrict the search behavior to a starts-with match.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search_fields`: 此属性指定了一个字符串元组，其值表示我们想要包含在搜索功能中的文本类型字段名称。在所有用法中，我们都会想要执行以起始字符匹配。为了做到这一点，我们将包括`''^''`作为字段名称的前缀，以表示我们想要将搜索行为限制为以起始字符匹配。'
- en: '`ordering_fields`: This attribute specifies a tuple of strings whose values
    indicate the field names that the HTTP request can specify to sort the results.
    If the request doesn''t specify a field for ordering, the response will use the
    default ordering fields specified in the model that is related to the class-based
    view.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ordering_fields`: 此属性指定了一个字符串元组，其值表示HTTP请求可以指定的字段名称，以对结果进行排序。如果请求没有指定排序字段，则响应将使用与基于类的视图相关联的模型中指定的默认排序字段。'
- en: 'Open the `restful01/drones/views.py` file. Add the following code after the
    last line that declares the imports, before the declaration of the `DroneCategoryList`
    class. The code file for the sample is included in the `hillar_django_restful_07_03`
    folder in the `restful01/drones/views.py` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`restful01/drones/views.py`文件。在声明导入的最后一行之后，在`DroneCategoryList`类声明之前添加以下代码。示例的代码文件包含在`hillar_django_restful_07_03`文件夹中的`restful01/drones/views.py`文件中：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the following highlighted lines to the `DroneList` class declared in the
    `views.py` file. The next lines show the new code that defines the class. The
    code file for the sample is included in the `hillar_django_restful_07_03` folder
    in the `restful01/drones/views.py` file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下突出显示的行添加到`views.py`文件中声明的`DroneList`类。下面的行显示了定义类的新的代码。示例的代码文件包含在`restful01/drones/views.py`文件中的`hillar_django_restful_07_03`文件夹中：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The changes in the `DroneList` class are easy to understand. We will be able
    to filter, search, and order by the `name` field.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`DroneList`类的更改易于理解。我们将能够通过`name`字段进行过滤、搜索和排序。'
- en: 'Add the following highlighted lines to the `DroneList` class declared in the
    `views.py` file. The next lines show the new code that defines the class. The
    code file for the sample is included in the `hillar_django_restful_07_03` folder
    in the `restful01/drones/views.py` file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下突出显示的行添加到`views.py`文件中声明的`DroneList`类。下面的行显示了定义类的新的代码。示例的代码文件包含在`restful01/drones/views.py`文件中的`hillar_django_restful_07_03`文件夹中：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the `DroneList` class, we specified many field names in the `filter_fields`
    attribute. We included `'drone_category'` in the string tuple, and therefore,
    we will be able to include the ID values for this field in the filter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DroneList`类中，我们在`filter_fields`属性中指定了许多字段名称。我们在字符串元组中包含了`'drone_category'`，因此，我们将能够将此字段的ID值包含在过滤器中。
- en: We will take advantage of other options for related models that will allow us
    to filter by fields of the related model later. This way, we will understand the
    different customizations available.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用其他相关模型选项，这将允许我们稍后通过相关模型的字段进行过滤。这样，我们将了解可用的不同自定义选项。
- en: The `ordering_fields` attribute specifies two field names for the tuple of strings,
    and therefore, we will be able to order the results by either `name` or `manufacturing_date`.
    Don't forget that we must take into account database optimizations when enabling
    fields to order by.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`ordering_fields`属性指定了字符串元组中的两个字段名称，因此，我们将能够通过`name`或`manufacturing_date`对结果进行排序。不要忘记，在启用按字段排序时，我们必须考虑数据库优化。'
- en: 'Add the following highlighted lines to the `PilotList` class declared in the
    `views.py` file. The next lines show the new code that defines the class. The
    code file for the sample is included in the `hillar_django_restful_07_03` folder
    in the `restful01/drones/views.py` file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下突出显示的行添加到 `views.py` 文件中声明的 `PilotList` 类。下面的行显示了定义类的新的代码。示例代码文件包含在 `hillar_django_restful_07_03`
    文件夹中的 `restful01/drones/views.py` 文件中：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `ordering_fields` attribute specifies two field names for the tuple of strings,
    and therefore, we will be able to order the results by either `name` or `races_count`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ordering_fields` 属性指定了字符串元组的两个字段名称，因此我们可以通过 `name` 或 `races_count` 对结果进行排序。'
- en: Working with different types of Django filters
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与不同类型的 Django 过滤器一起工作
- en: Now, we will create a customized filter that we will apply to the `Competition`
    model. We will code the new `CompetitionFilter` class, specifically, a subclass
    of the `rest_framework.filters.FilterSet` class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个自定义过滤器，并将其应用于 `Competition` 模型。我们将编写新的 `CompetitionFilter` 类，具体来说，是
    `rest_framework.filters.FilterSet` 类的子类。
- en: 'Open the `restful01/drones/views.py` file. Add the following code before the
    declaration of the `CompetitionList` class. The code file for the sample is included
    in the `hillar_django_restful_07_03` folder in the `restful01/drones/views.py`
    file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `restful01/drones/views.py` 文件。在 `CompetitionList` 类声明之前添加以下代码。示例代码文件包含在
    `hillar_django_restful_07_03` 文件夹中的 `restful01/drones/views.py` 文件中：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `CompetitionFilter` class declares the following class attributes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompetitionFilter` 类声明了以下类属性：'
- en: '`from_achievement_date`: This attribute is a `django_filters.DateTimeFilter`
    instance that allows the request to filter the competitions whose `achievement_date`
    DateTime value is greater than or equal to the specified DateTime value. The value
    specified in the `name` argument indicates the field to which the DateTime filter
    is applied, `''distance_achievement_date''`, and the value for the `lookup_expr`
    argument indicates the lookup expression, `''gte''`, which means greater than
    or equal to.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from_achievement_date`: 此属性是一个 `django_filters.DateTimeFilter` 实例，允许请求过滤那些
    `achievement_date` 日期时间值大于或等于指定日期时间的比赛。`name` 参数指定的值表示应用日期时间过滤的字段，即 `''distance_achievement_date''`，而
    `lookup_expr` 参数的值表示查找表达式，即 `''gte''`，表示大于或等于。'
- en: '`to_achievement_date`: This attribute is a `django_filters.DateTimeFilter`
    instance that allows the request to filter the competitions whose `achievement_date`
    DateTime value is less than or equal to the specified DateTime value. The value
    specified in the `name` argument indicates the field to which the DateTime filter
    is applied, `''distance_achivement_date''`, and the value for the `lookup_expr`
    argument indicates the lookup expression, `''lte''`, which means less than or
    equal to.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to_achievement_date`: 此属性是一个 `django_filters.DateTimeFilter` 实例，允许请求过滤那些 `achievement_date`
    日期时间值小于或等于指定日期时间的比赛。`name` 参数指定的值表示应用日期时间过滤的字段，即 `''distance_achivement_date''`，而
    `lookup_expr` 参数的值表示查找表达式，即 `''lte''`，表示小于或等于。'
- en: '`min_distance_in_feet`: This attribute is a `django_filters.NumberFilter` instance
    that allows the request to filter the competitions whose `distance_in_feet` numeric
    value is greater than or equal to the specified number. The value for the `name`
    argument indicates the field to which the numeric filter is applied, `''distance_in_feet''`,
    and the value for the `lookup_expr` argument indicates the lookup expression,
    `''gte''`, which means greater than or equal to.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_distance_in_feet`: 此属性是一个 `django_filters.NumberFilter` 实例，允许请求过滤那些 `distance_in_feet`
    数值大于或等于指定数值的比赛。`name` 参数的值表示应用数值过滤的字段，即 `''distance_in_feet''`，而 `lookup_expr`
    参数的值表示查找表达式，即 `''gte''`，表示大于或等于。'
- en: '`max_distance_in_feet`: This attribute is a `django_filters.NumberFilter` instance
    that allows the request to filter the competitions whose `distance_in_feet` numeric
    value is less than or equal to the specified number. The value for the `name`
    argument indicates the field to which the numeric filter is applied, `''distance_in_feet''`,
    and the value for the `lookup_expr` argument indicates the lookup expression,
    `''lte''`, which means less than or equal to.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_distance_in_feet`: 此属性是一个 `django_filters.NumberFilter` 实例，允许请求过滤那些 `distance_in_feet`
    数值小于或等于指定数值的比赛。`name` 参数的值表示应用数值过滤的字段，即 `''distance_in_feet''`，而 `lookup_expr`
    参数的值表示查找表达式，即 `''lte''`，表示小于或等于。'
- en: '`drone_name`: This attribute is a `django_filters.AllValuesFilter` instance
    that allows the request to filter the competitions whose drones'' names match
    the specified string value. The value for the `name` argument indicates the field
    to which the filter is applied, `''drone__name''`. Notice that there is a double
    underscore (`__`) between `drone` and `name`, and you can read it as the `name`
    field for the `drone` model or simply replace the double underscore with a dot
    and read `drone.name`. The name uses Django''s double underscore syntax. However,
    we don''t want the request to use `drone__name` to specify the filter for the
    drone''s name. Hence, the instance is stored in the class attribute named `drone_name`,
    with just a single underscore between `player` and `name`, to make it more user-friendly.
    We will make configurations to make the browsable API display a drop-down with
    all the possible values for the drone''s name to use as a filter. The drop-down
    will only include the drones'' names that have registered competitions.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drone_name`: 这个属性是一个 `django_filters.AllValuesFilter` 实例，允许请求通过匹配指定的字符串值来过滤无人机名字的竞赛。`name`
    参数的值表示应用过滤器的字段，即 `''drone__name''`。注意 `drone` 和 `name` 之间有一个双下划线（`__`），你可以将其读作
    `drone` 模型的 `name` 字段，或者简单地用点替换双下划线并读作 `drone.name`。该名称使用 Django 的双下划线语法。然而，我们不希望请求使用
    `drone__name` 来指定无人机名字的过滤器。因此，该实例存储在名为 `drone_name` 的类属性中，`player` 和 `name` 之间只有一个下划线，使其更易于用户使用。我们将进行配置，使可浏览的
    API 显示一个下拉菜单，显示所有可能的无人机名字值，以便用作过滤器。下拉菜单将只包括已注册竞赛的无人机名字。'
- en: '`pilot_name`: This attribute is a `django_filters.AllValuesFilter` instance
    that allows the request to filter the competitions whose pilots'' names match
    the specified string value. The value for the `name` argument indicates the field
    to which the filter is applied, `''pilot__name''`. The name uses Django''s double
    underscore syntax. As happened with `drone_name`, we don''t want the request to
    use `pilot__name` to specify the filter for the pilot''s name, and therefore,
    we stored the instance in the class attribute named `pilot_name`, with just a
    single underscore between `pilot` and `name`. The browsable API will display a
    drop-down with all the possible values for the pilot''s name to use as a filter.
    The drop-down will only include the pilots'' names that have registered competitions
    because we used the `AllValuesFilter` class.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pilot_name`: 这个属性是一个 `django_filters.AllValuesFilter` 实例，允许请求通过匹配指定的字符串值来过滤飞行员名字的竞赛。`name`
    参数的值表示应用过滤器的字段，即 `''pilot__name''`。该名称使用 Django 的双下划线语法。正如 `drone_name` 的情况一样，我们不希望请求使用
    `pilot__name` 来指定飞行员名字的过滤器，因此，我们将实例存储在名为 `pilot_name` 的类属性中，`pilot` 和 `name` 之间只有一个下划线。可浏览的
    API 将显示一个下拉菜单，显示所有可能的飞行员名字值，以便用作过滤器。下拉菜单将只包括已注册竞赛的飞行员名字，因为我们使用了 `AllValuesFilter`
    类。'
- en: 'The `CompetitionFilter` class defines a `Meta` inner class that declares the
    following two attributes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompetitionFilter` 类定义了一个 `Meta` 内部类，声明了以下两个属性：'
- en: '`model`: This attribute specifies the model related to the filter set, that
    is, the `Competition` class.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`: 这个属性指定了与过滤器集相关的模型，即 `Competition` 类。'
- en: '`fields`: This attribute specifies a tuple of strings whose values indicate
    the field names and filter names that we want to include in the filters for the
    related model. We included `''distance_in_feet''` and the names for all the previously
    explained filters. The string `''distance_in_feet''` refers to the field with
    this name. We want to apply the default numeric filter that will be built under
    the hood to allow the request to filter by an exact match on the `distance_in_feet`
    field. This way, the request will have plenty of options to filter competitions.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields`: 这个属性指定了一个字符串元组，其值表示我们想要包含在相关模型过滤器中的字段名和过滤器名。我们包括了 `''distance_in_feet''`
    和所有之前解释过的过滤器名称。字符串 `''distance_in_feet''` 指的是具有此名称的字段。我们希望应用默认的数值过滤器，它将在底层构建，以便请求可以通过
    `distance_in_feet` 字段的精确匹配来过滤。这样，请求将有大量的选项来过滤竞赛。'
- en: 'Now, add the following highlighted lines to the `CompetitionList` class declared
    in the `views.py` file. The next lines show the new code that defines the class.
    The code file for the sample is included in the `hillar_django_restful_07_03`
    folder in the `restful01/drones/views.py` file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下突出显示的行添加到 `views.py` 文件中声明的 `CompetitionList` 类。下面的行显示了定义类的新的代码。示例代码文件位于
    `restful01/drones/views.py` 文件中的 `hillar_django_restful_07_03` 文件夹中：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `filter_class` attribute specifies `CompetitionFilter` as its value, that
    is, the `FilterSet` subclass that declares the customized filters that we want
    to use for this class-based view. In this case, the code didn't specify a tuple
    of strings for the `filter_class` attribute because we have defined our own `FilterSet`
    subclass.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_class`属性指定了`CompetitionFilter`作为其值，即声明了我们想要用于此类视图的定制过滤器的`FilterSet`子类。在这种情况下，代码没有为`filter_class`属性指定字符串元组，因为我们已经定义了自己的`FilterSet`子类。'
- en: The `ordering_fields` tuple of strings specifies the two field names that the
    request will be able to use for ordering the competitions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串元组`ordering_fields`指定了请求将能够用于排序比赛的两个字段名称。
- en: Making requests that filter results
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送过滤结果请求
- en: 'Now we can launch Django''s development server to compose and send HTTP requests
    to understand how to use the previously coded filters. Execute any of the following
    two commands, based on your needs, to access the API in other devices or computers
    connected to your LAN. Remember that we analyzed the difference between them in
    [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*, in the *Launching
    Django''s development server* section:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动Django的开发服务器，以编写并发送HTTP请求来了解如何使用之前编写的筛选器。根据您的需求，执行以下两个命令之一，以在其他连接到您的局域网（LAN）的设备或计算机上访问API。请记住，我们在[第3章](dj-rst-websvc_ch13.html)的*启动Django开发服务器*部分分析了它们之间的区别：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行任何之前的命令后，开发服务器将开始监听端口`8000`。
- en: 'Now, we will compose and send an HTTP request to retrieve all the drone categories
    whose `name` is equal to `Quadcopter`, as shown below:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求，以检索所有名称等于`Quadcopter`的无人机类别，如下所示：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following lines show a sample response with the single drone category whose
    `name` matches the specified `name` string in the filter and the list of hyperlinks
    for the drones that belong to the category. The following lines show the JSON
    response body without the headers. Notice that the results are paginated:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了包含单个匹配指定`name`字符串的`name`的无人机类别和属于该类别的无人机链接列表的示例响应。以下行显示了没有头部的JSON响应体。请注意，结果已分页：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Composing requests that filter and order results
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写筛选和排序结果的请求
- en: We will compose and send an HTTP request to retrieve all the drones whose related
    drone category ID is equal to `1` and whose value for the `has_it_competed` field
    is equal to `False`. The results must be sorted by `name` in descending order,
    and therefore, we specify `-name` as the value for the `ordering` query parameter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写并发送一个HTTP请求，以检索所有相关无人机类别ID等于`1`且`has_it_competed`字段值为`False`的无人机。结果必须按`name`降序排序，因此，我们将`-name`作为`ordering`查询参数的值。
- en: The hyphen (`-`) before the field name indicates that the ordering feature must
    use descending order instead of the default ascending order.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名称前的连字符（`-`）表示排序功能必须使用降序而不是默认的升序。
- en: 'Make sure you replace `1` with the `pk` value of the previously retrieved drone
    category named `Quadcopter`. The `has_it_competed` field is a `bool` field, and
    therefore, we have to use Python valid bool values (`True` and `False`) when specifying
    the desired values for the bool field in the filter:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`1`替换为之前检索到的名为`Quadcopter`的无人机类别的`pk`值。`has_it_competed`字段是一个布尔字段，因此，在指定布尔字段在筛选器中的期望值时，我们必须使用Python有效的布尔值（`True`和`False`）。
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following lines show a sample response with the first four out of seven
    drones that match the specified criteria in the filter, sorted by name in descending
    order. Notice that the filters and the ordering have been combined with the previously
    configured pagination. The following lines show only the JSON response body, without
    the headers:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了包含按名称降序排序的七个匹配指定筛选器条件的无人机中的前四个的示例响应。请注意，筛选器和排序已与之前配置的分页结合使用。以下行仅显示JSON响应体，没有头部：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that the response provides the value for the `next` key, `http://localhost:8000/drones/?drone_category=1&has_it_competed=False&limit=4&offset=4&ordering=-name`.
    This URL includes the combination of pagination, filtering, and ordering query
    parameters.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应提供了`next`键的值，`http://localhost:8000/drones/?drone_category=1&has_it_competed=False&limit=4&offset=4&ordering=-name`。此URL包含了分页、过滤和排序查询参数的组合。
- en: In the `DroneList` class, we included `'drone_category'` as one of the strings
    in the `filter_fields` tuple of strings. Hence, we had to use the drone category
    ID in the filter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DroneList`类中，我们将`'drone_category'`作为字符串元组`filter_fields`中的一个字符串包含在内。因此，我们必须在过滤器中使用无人机类别ID。
- en: Now, we will use a filter on the drone's name related to a competition. As previously
    explained, our `CompetitionFilter` class provides us a filter to the name of the
    related drone in the `drone_name` query parameter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用与比赛相关的无人机名称的过滤器。如前所述，我们的`CompetitionFilter`类为我们提供了一个过滤器，用于在`drone_name`查询参数中过滤相关无人机的名称。
- en: 'We will combine the filter with another filter on the pilot''s name related
    to a competition. Remember that the class also provides us a filter to the name
    of the related pilot in the `pilot_name` query parameter. We will specify two
    conditions in the criteria, and the filters are combined with the `AND` operator.
    Hence, both conditions must be met. The pilot''s name must be equal to `''Penelope
    Pitstop''` and the drone''s name must be equal to `''WonderDrone''`. The following
    command generates a request with the explained filter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将过滤器与另一个与比赛相关的飞行员名称的过滤器结合起来。请记住，该类还为我们提供了一个过滤器，用于在`pilot_name`查询参数中过滤相关飞行员的名称。我们将在标准中指定两个条件，并且过滤器通过`AND`运算符组合。因此，必须满足这两个条件。飞行员的名称必须等于`'Penelope
    Pitstop'`，无人机的名称必须等于`'WonderDrone'`。以下命令生成了一个具有解释过滤器的请求：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following lines show a sample response with the competition that matches
    the specified criteria in the filters. The following lines show only the JSON
    response body, without the headers:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了与过滤器中指定的标准匹配的比赛的示例响应。以下几行仅显示JSON响应体，不包含头部信息：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we will compose and send an HTTP request to retrieve all the competitions
    that match the following criteria. In addition, we want the results ordered by
    `distance_achievement_date`, in descending order:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求来检索所有符合以下标准的比赛。此外，我们希望结果按`distance_achievement_date`降序排列：
- en: The `distance_achievement_date` is between `2017-10-18` and `2017-10-21`
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`distance_achievement_date`在`2017-10-18`和`2017-10-21`之间'
- en: The `distance_in_feet` value is between `700` and `900`
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`distance_in_feet`的值在`700`和`900`之间'
- en: 'The following command will do the job:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将完成工作：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The previously analyzed `CompetitionFilter` class allowed us to create a request
    like the previous one, in which we take advantage of the customized filters. The
    following lines show a sample response with the two competitions that match the
    specified criteria in the filters. We overrode the default ordering specified
    in the model with the `ordering` field indicated in the request. The following
    lines show only the JSON body response, without the headers:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 之前分析的`CompetitionFilter`类允许我们创建一个像之前的请求一样，利用自定义过滤器的请求。以下几行显示了与过滤器中指定的标准匹配的两个比赛的示例响应。我们通过请求中指定的`ordering`字段覆盖了模型中指定的默认排序。以下几行仅显示JSON响应体，不包含头部信息：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Making requests that perform starts with searches
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行以...开头的搜索请求
- en: Now, we will take advantage of searches that are configured to check whether
    a value starts with the specified characters. We will compose and send an HTTP
    request to retrieve all the pilots whose `name` starts with `'G'`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将利用配置为检查值是否以指定字符开头的搜索。我们将编写并发送一个HTTP请求来检索所有`name`以`'G'`开头的飞行员。
- en: 'The next request uses the search feature that we configured to restrict the
    search behavior to a starts-with match on the `name` field for the `Drone` model:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个请求使用我们配置的搜索功能，将搜索行为限制为对`Drone`模型的`name`字段进行以...开头的匹配：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following lines show a sample response with the two drones that match the
    specified search criteria, that is, those drones whose `name` starts with `''G''`.
    The following lines show only the JSON response body, without the headers:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了与指定搜索条件匹配的两个无人机的示例响应，即那些`name`以`'G'`开头的无人机。以下行仅显示JSON响应体，不包括头部信息：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Using the browsable API to test pagination, filtering, searching, and ordering
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可浏览API测试分页、过滤、搜索和排序
- en: We enabled pagination and we added filtering, searching, and ordering features
    to our RESTful Web Service. All of these new features have an impact on how each
    web page is rendered when working with the browsable API.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用了分页功能，并添加了过滤、搜索和排序功能到我们的RESTful Web服务中。所有这些新功能都会影响在使用可浏览API时每个网页的渲染方式。
- en: We can work with a web browser to easily test pagination, filtering, searching,
    and ordering with a few clicks or taps.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用网络浏览器通过几点击或轻触轻松测试分页、过滤、搜索和排序功能。
- en: Open a web browser and go to `http://localhost:8000/drones/`. Replace `localhost` with
    the IP of the computer that is running Django's development server if you use
    another computer or device to run the browser. The browsable API will compose
    and send a `GET` request to `/drones/` and will display the results of its execution,
    that is, the headers and the JSON drones list.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 打开网络浏览器并访问`http://localhost:8000/drones/`。如果您使用另一台计算机或设备运行浏览器，请将`localhost`替换为运行Django开发服务器的计算机的IP地址。可浏览API将组合并发送一个`GET`请求到`/drones/`，并显示其执行结果，即头部信息和JSON无人机列表。
- en: 'We have configured pagination, and therefore, the rendered web page will include
    the default pagination template associated with the base pagination class we are
    using and will display the available page numbers in the upper-right corner of
    the web page. The following screenshot shows the rendered web page after entering
    the URL in a web browser with the resource description, Drone List, and the three
    pages generated with the limit/offset pagination scheme:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了分页，因此渲染的网页将包括与我们使用的基分页类相关联的默认分页模板，并在网页右上角显示可用的页码。以下截图显示了在网页浏览器中输入URL后渲染的网页，其中包含资源描述、无人机列表和用limit/offset分页方案生成的三个页面：
- en: '![](img/474df671-756c-4855-8965-9a0e19565809.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/474df671-756c-4855-8965-9a0e19565809.png)'
- en: Now, go to `http://localhost:8000/competitions/`. The browsable API will compose
    and send a `GET` request to `/competitions/` and will display the results of its
    execution, that is, the headers and the JSON competitions list. The web page will
    include a Filters button at the right-hand side of the resource description, Competition
    List, and at the left-hand side of the OPTIONS button.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，访问`http://localhost:8000/competitions/`。可浏览API将组合并发送一个`GET`请求到`/competitions/`，并显示其执行结果，即头部信息和JSON竞赛列表。网页将在资源描述“竞赛列表”的右侧和“OPTIONS”按钮的左侧包含一个“过滤”按钮。
- en: 'Click or tap on Filters, and the browsable API will render the Filter model
    with the appropriate controls for each filter that you can apply below Field Filters.
    In addition, the model will render the different ordering options below Ordering.
    The following screenshot shows the Filters model for the competitions:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触“过滤”，可浏览API将渲染带有每个可应用过滤器的适当控制器的Filter模型。此外，模型将在“排序”下方渲染不同的排序选项。以下截图显示了竞赛的Filters模型：
- en: '![](img/3b0c8dc5-1cb1-4db3-8ba1-34c40a5b0065.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b0c8dc5-1cb1-4db3-8ba1-34c40a5b0065.png)'
- en: The Drone name and Pilot name drop-downs only provide the related drones' names
    and pilots' names that have participated in competitions because we used the `AllValuesFilter`
    class for both filters. We can easily enter all the values for each desired filter
    that we want to apply and click or tap Submit. Then, click on Filters again, select
    the ordering option, and click Submit. The browsable API will compose and send
    the necessary HTTP request to apply the filters and ordering we have specified
    and it will render a web page with the first page of the results of the execution
    of the request.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 无人机名称和飞行员名称的下拉菜单仅提供参与竞赛的相关无人机名称和飞行员名称，因为我们为两个过滤器都使用了`AllValuesFilter`类。我们可以轻松输入每个所需过滤器想要应用的所有值，然后点击或轻触提交。然后，再次点击“过滤”，选择排序选项，并点击提交。可浏览API将组合并发送必要的HTTP请求来应用我们指定的过滤和排序，并将渲染一个包含请求执行结果的第一个页面的网页。
- en: 'The next screenshot shows the results of executing a request whose filters
    were composed with the previously explained model:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了执行一个请求的结果，其过滤器是由之前解释的模型组成的：
- en: '![](img/8114b3f2-cb23-447b-bbf7-119af60badc9.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8114b3f2-cb23-447b-bbf7-119af60badc9.png)'
- en: 'The following are the parameters for the HTTP `GET` request. Notice that the
    browsable API generates the query parameters but doesn''t specify values for the
    filters that were left without values in the previous modal. When the query parameters
    don''t specify values, they are ignored:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对HTTP `GET`请求的参数。请注意，可浏览的API生成了查询参数，但未指定在先前模式中未指定值的过滤器值。当查询参数未指定值时，它们将被忽略：
- en: '[PRE62]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As happens whenever we have to test the different features included in our RESTful
    Web Service, the browsable API is also extremely helpful whenever we need to check
    filters and ordering.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们每次必须测试我们RESTful Web Service中包含的不同功能一样，可浏览的API在需要检查过滤器和排序时也非常有用。
- en: Test your knowledge
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'The `django_filters.rest_framework.DjangoFilterBackend` class provides:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`django_filters.rest_framework.DjangoFilterBackend`类提供：'
- en: Control on how the results are ordered with a single query parameter
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单个查询参数控制结果的排序
- en: Single query parameter-based searching capabilities, based on the Django admin's
    search function
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于Django管理员的搜索功能的单查询参数搜索能力
- en: Field filtering capabilities
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段过滤功能
- en: 'The `rest_framework.filters.SearchFilter` class provides:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.filters.SearchFilter`类提供：'
- en: Control on how the results are ordered with a single query parameter
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单个查询参数控制结果的排序
- en: Single query parameter-based searching capabilities, based on the Django admin's
    search function
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于Django管理员的搜索功能的单查询参数搜索能力
- en: Field filtering capabilities
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段过滤功能
- en: If we want to create a unique constraint, what must be added to a `models.CharField`
    initializer as one of the named arguments?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们要创建一个唯一约束，需要在`models.CharField`初始化器中将哪个命名参数添加进去？
- en: '`unique=True`'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unique=True`'
- en: '`unique_constraint=True`'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unique_constraint=True`'
- en: '`force_unique=True`'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`force_unique=True`'
- en: 'Which of the following class attributes specifies a tuple of strings whose
    values indicate the field names that we want to be able to filter against in a
    class-based view that inherits from `generics.ListCreateAPIView`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个类属性指定了一个字符串元组，其值表示我们想要在继承自`generics.ListCreateAPIView`的类视图中能够过滤的字段名称：
- en: '`filters`'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`filters`'
- en: '`filtering_fields`'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`filtering_fields`'
- en: '`filter_fields`'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`filter_fields`'
- en: 'Which of the following class attributes specifies a tuple of strings whose
    values indicate the field names that the HTTP request can specify to sort the
    results in a class-based view that inherits from `generics.ListCreateAPIView`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个类属性指定了一个字符串元组，其值表示HTTP请求可以指定以对类视图进行排序的字段名称，该视图继承自`generics.ListCreateAPIView`：
- en: '`order_by`'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`order_by`'
- en: '`ordering_fields`'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ordering_fields`'
- en: '`order_fields`'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`order_fields`'
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案包含在[附录](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454)，*解决方案*中。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used the browsable API feature to navigate through the API
    with resources and relationships. We added unique constraints to improve consistency
    for the models in our RESTful Web Service.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了可浏览的API功能，通过资源和关系在API中进行导航。我们添加了唯一约束，以改善我们RESTful Web Service中模型的一致性。
- en: We understood the importance of paginating results and we configured and tested
    a global limit/offset pagination scheme with the Django REST framework. Then,
    we created our own customized pagination class to make sure that requests weren't
    able to acquire a huge amount of elements in a single page.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解了分页结果的重要性，并使用Django REST框架配置和测试了一个全局限制/偏移分页方案。然后，我们创建了自己的自定义分页类，以确保请求不能在单页中获取大量元素。
- en: We configured filter backend classes and we added code to the models to add
    filtering, searching, and ordering capabilities to the class-based views. We created
    a customized filter and we made requests to filter, search, and order results,
    and we understood how everything worked under the hood. Finally, we used the browsable
    API to test pagination, filtering, and ordering.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了过滤器后端类，并在模型中添加了代码以向基于类的视图添加过滤、搜索和排序功能。我们创建了一个自定义过滤器，并进行了过滤、搜索和排序结果的请求，我们理解了底层是如何工作的。最后，我们使用可浏览的
    API 测试了分页、过滤和排序。
- en: Now that we improved our RESTful Web Service with unique constraints, paginated
    results, fitering, searching, and ordering features, we will secure the API with
    authentication and permissions. We will cover these topics in the next chapter.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过唯一约束、分页结果、过滤、搜索和排序功能改进了我们的 RESTful Web 服务，我们将通过认证和权限来保护 API。我们将在下一章中介绍这些主题。
- en: Securing the API with Authentication and Permissions
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用认证和权限保护 API
- en: 'In this chapter, we will understand the difference between authentication and
    permissions in the Django REST framework. We will start securing our RESTful Web
    Service by adding requirements for authentication schemes and specifying permission
    policies. We will gain an understanding of:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 Django REST 框架中认证和权限之间的区别。我们将通过添加认证方案要求和指定权限策略来开始保护我们的 RESTful Web
    服务。我们将了解以下内容：
- en: Understanding authentication and permissions in Django, the Django REST framework,
    and RESTful Web Services
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Django、Django REST 框架和 RESTful Web 服务中的认证和权限
- en: Authentication classes
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证类
- en: Security and permissions-related data to models
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与模型相关的安全性和权限数据
- en: Working with object-level permissions via customized permission classes
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自定义权限类处理对象级权限
- en: Saving information about users that make requests
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存有关发起请求的用户的信息
- en: Setting permissions policies
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置权限策略
- en: Creating the superuser for Django
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Django 创建超级用户
- en: Creating a user for Django
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Django 创建用户
- en: Making authenticated requests
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送认证请求
- en: Browsing the secured API with the required authentication
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用所需的认证浏览受保护的 API
- en: Working with token-based authentication
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于令牌的认证
- en: Generating and using tokens
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成和使用令牌
- en: Understanding authentication and permissions in Django, the Django REST framework,
    and RESTful Web Services
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Django、Django REST 框架和 RESTful Web 服务中的认证和权限
- en: Right now, our sample RESTful Web Service processes all the incoming requests
    without requiring any kind of authentication, that is, any user can perform requests.
    The Django REST framework allows us to easily use diverse authentication schemes
    to identify a user that originated the request or a token that signed the request.
    Then, we can use these credentials to apply permission and throttling policies
    that will determine whether the request must be permitted or not.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的示例 RESTful Web 服务处理所有传入的请求，而不需要任何类型的认证，也就是说，任何用户都可以执行请求。Django REST 框架允许我们轻松使用各种认证方案来识别发起请求的用户或签名请求的令牌。然后，我们可以使用这些凭据来应用权限和节流策略，这将决定请求是否必须被允许。
- en: We already know how configurations work with the Django REST framework. We can
    apply a global setting and override it if necessary in the appropriate class-based
    views. Hence, we can set the default authentication schemes in the global settings
    and override them whenever required for specific scenarios.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道配置是如何与 Django REST 框架一起工作的。我们可以应用全局设置，并在必要时在适当的基于类的视图中覆盖它。因此，我们可以在全局设置中设置默认的认证方案，并在需要时为特定场景覆盖它们。
- en: The settings allow us to declare a list of classes that specify the authentication
    schemes to be used for all the incoming HTTP requests. The Django REST framework
    will use all the specified classes in the list to authenticate a request, before
    running the appropriate method for the class-based view based on the request.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置允许我们声明一个类列表，指定用于所有传入 HTTP 请求的认证方案。Django REST 框架将使用列表中指定的所有类来认证请求，然后在基于类的视图运行相应的方法之前。
- en: 'We can specify just one class. However, it is very important to understand
    the behavior in case we have to use more than one class. The first class in the
    list that generates a successful authentication will be responsible for setting
    the values for the following two attributes for the `request` object:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一个类。然而，在必须使用多个类的情况下，了解其行为非常重要。列表中第一个成功生成认证的类将负责为`request`对象设置以下两个属性的值：
- en: '`user`: This attribute represents the user model instance. In our examples,
    we will work with an instance of the Django User class, specifically, the `django.contrib.auth.User`
    class.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：此属性代表用户模型实例。在我们的示例中，我们将使用Django User类的一个实例，具体是`django.contrib.auth.User`类。'
- en: '`auth`: This attribute provides additional authentication data required by
    the authentication scheme, such as an authentication token.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth`：此属性提供了认证方案所需的额外认证数据，例如认证令牌。'
- en: After a successful authentication, we will be able to use the `request.user`
    attribute within the different methods in our class-based views that receive the
    `request` parameter. This way, we will be able to retrieve additional information
    about the `user` that generated the request.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功认证之后，我们就能在我们的基于类的视图中使用`request.user`属性，这些视图接收`request`参数。这样，我们就能检索到生成请求的`user`的额外信息。
- en: Learning about the authentication classes
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解认证类
- en: 'The Django REST framework provides the following three authentication classes
    in the `rest_framework.authentication` module. All of them are subclasses of the
    `BaseAuthentication` class:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架在`rest_framework.authentication`模块中提供了以下三个认证类。它们都是`BaseAuthentication`类的子类：
- en: '`BasicAuthentication`: This class provides an HTTP basic authentication against
    a username and a password.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BasicAuthentication`：此类提供基于用户名和密码的HTTP基本认证。'
- en: '`SessionAuthentication`: This class works with Django''s session framework
    for authentication.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SessionAuthentication`：此类与Django的会话框架一起用于认证。'
- en: '`TokenAuthentication`: This class provides a simple token-based authentication.
    The request must include the token generated for a user as the value for the `Authorization`
    HTTP header key with the `''Token ''` string as a prefix for the token.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TokenAuthentication`：此类提供了一种基于令牌的简单认证。请求必须包含为用户生成的令牌，并将其作为`Authorization`
    HTTP头键的值，令牌前缀为`''Token ''`字符串。'
- en: Of course, in a production environment, we must make sure that the RESTful Web
    Service is only available over HTTPS, with the usage of the latest TLS versions.
    We shouldn't use an HTTP basic authentication or a simple token-based authentication
    over plain HTTP in a production environment.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在生产环境中，我们必须确保RESTful Web服务仅通过HTTPS提供，并使用最新的TLS版本。我们不应在生产环境中使用HTTP基本认证或简单的基于令牌的认证。
- en: The previous classes are included in the Django REST framework out of the box.
    There are many additional authentication classes provided by many third-party
    libraries. We will work with some of these libraries later in this chapter.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的类是Django REST框架自带的。许多第三方库提供了许多额外的认证类。我们将在本章的后面部分使用一些这些库。
- en: Make sure you quit Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or go to the Command Prompt window in which
    it is running. We have to edit the models and then execute migrations before starting
    Django's development server again.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已退出Django的开发服务器。记住，你只需在终端中按*Ctrl* + *C*，或者前往开发服务器正在运行的命令提示符窗口。我们必须编辑模型，然后执行迁移，再次启动Django的开发服务器之前。
- en: We will make the necessary changes to combine HTTP basic authentication against
    a username and a password with Django's session framework for authentication.
    Hence, we will add the `BasicAuthentication` and `SessionAuthentication` classes
    in the global authentication classes list.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对HTTP基本认证和Django的会话框架进行必要的修改以实现认证。因此，我们将`BasicAuthentication`和`SessionAuthentication`类添加到全局认证类列表中。
- en: 'Open the `restful01/restful01/settings.py` file that declares the module-level
    variables that define the configuration of Django for the `restful01` project.
    We will make some changes to this Django settings file. Add the highlighted lines
    to the `REST_FRAMEWORK` dictionary. The following lines show the new declaration
    of the `REST_FRAMEWORK` dictionary. The code file for the sample is included in
    the `hillar_django_restful_08_01` folder in the `restful01/restful01/settings.py`
    file:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 打开声明`restful01`项目Django配置的模块级变量的`restful01/restful01/settings.py`文件。我们将对此Django设置文件进行一些修改。将突出显示的行添加到`REST_FRAMEWORK`字典中。以下行显示了`REST_FRAMEWORK`字典的新声明。示例的代码文件包含在`hillar_django_restful_08_01`文件夹中的`restful01/restful01/settings.py`文件中：
- en: '[PRE63]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We added the `DEFAULT_AUTHENTICATION_CLASSES` settings key to the `REST_FRAMEWORK`
    dictionary. This new key specifies a global setting with a tuple of string whose
    values indicate the classes that we want to use for authentication: `BasicAuthentication`
    and `SessionAuthentication`.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`REST_FRAMEWORK`字典中添加了`DEFAULT_AUTHENTICATION_CLASSES`设置键。这个新键指定了一个全局设置，其值是一个字符串元组，表示我们想要用于身份验证的类：`BasicAuthentication`和`SessionAuthentication`。
- en: Including security and permissions-related data to models
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将安全性和权限相关数据包含到模型中
- en: We want each drone to have an owner. Only an authenticated user will be able
    to create a drone and it will automatically become the owner of this new drone.
    We want only the owner of a drone to be able to update or delete the drone. Hence,
    an authenticated user that is also the owner of the drone will be able to execute
    `PATCH`, `PUT`, and `DELETE` methods on the drone resource that he owns.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每架无人机都有一个所有者。只有经过身份验证的用户才能创建无人机，并且它将自动成为这架新无人机的所有者。我们希望只有无人机的所有者才能更新或删除无人机。因此，既是身份验证用户又是无人机所有者的人将能够对其拥有的无人机资源执行`PATCH`、`PUT`和`DELETE`方法。
- en: Any authenticated user that isn't the owner of a specific drone resource will
    have read-only access to this drone. In addition, unauthenticated requests will
    also have read-only access to drones.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不是特定无人机资源所有者的经过身份验证的用户将只有对该无人机的只读访问权限。此外，未经身份验证的请求也将只有对无人机的只读访问权限。
- en: We will combine authentication with specific permissions. Permissions use the
    authentication information included in the `request.user` and `request.auth` attributes
    to determine whether the request should be granted or denied access. Permissions
    allow us to control which types of users will be granted or denied access to the
    different features, methods, resources, or resource collections of our RESTful
    Web Service.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将身份验证与特定权限结合起来。权限使用`request.user`和`request.auth`属性中包含的认证信息来确定请求是否应该被授予或拒绝访问。权限允许我们控制哪些类型的用户将被授予或拒绝访问我们RESTful
    Web服务的不同功能、方法、资源或资源集合。
- en: We will use the permissions features in the Django REST framework to allow only
    authenticated users to create new drones and automatically become their owners.
    We will make the necessary changes in the models to make a drone have a user as
    its owner. We will take advantage of the out-of-the-box permission classes included
    in the framework combined with a customized permission class, to define the previously
    explained permission policies for the drones and their related HTTP verbs supported
    in our web service.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Django REST框架中的权限功能，只允许经过身份验证的用户创建新的无人机并自动成为其所有者。我们将在模型中进行必要的更改，使无人机有一个用户作为其所有者。我们将利用框架中包含的现成权限类与自定义权限类相结合，来定义之前解释的无人机及其在我们Web服务中支持的HTTP动词的权限策略。
- en: In this case, we will stay focused on security and permissions and we will leave
    throttling rules for the next chapters. Bear in mind that throttling rules also
    determine whether a specific request must be authorized or not. However, we will
    work on throttling rules later and we will combine them with authentication and
    permissions.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我们将专注于安全和权限，并将节流规则留到下一章。请记住，节流规则还决定了特定请求是否必须授权。然而，我们将在稍后处理节流规则，并将它们与身份验证和权限结合起来。
- en: 'Open the `restful01/drones/models.py` file and replace the code that declares
    the `Drone` class with the following code. The new lines are highlighted in the
    code listing. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/models.py` file:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`restful01/drones/models.py`文件，并用以下代码替换声明`Drone`类的代码。代码列表中的新行被突出显示。示例的代码文件包含在`hillar_django_restful_08_01`文件夹中的`restful01/drones/models.py`文件中：
- en: '[PRE64]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The highlighted lines declare a new `owner` field for the `Drone` model. The
    new field uses the `django.db.models.ForeignKey` class to provide a many-to-one
    relationship to the `django.contrib.auth.User` model.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行声明了`Drone`模型的新`owner`字段。这个新字段使用`django.db.models.ForeignKey`类来提供与`django.contrib.auth.User`模型的多个到一的关系。
- en: This `User` model persists the users for the Django authentication system. Now,
    we are using this authentication system for our RESTful Web Service. The `'drones'`
    value specified for the `related_name` argument creates a backward relation from
    the `User` to the `Drone` model. Remember that this value indicates the name to
    use for the relation from the related `User` object back to a `Drone` object.
    This way, we will be able to access all the drones owned by a specific user.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`User`模型为Django认证系统持久化用户。现在，我们正在使用这个认证系统为我们自己的RESTful Web服务。为`related_name`参数指定的`'drones'`值创建了一个从`User`到`Drone`模型的反向关系。请记住，这个值表示从相关`User`对象回指到`Drone`对象时使用的名称。这样，我们将能够访问特定用户拥有的所有无人机。
- en: Whenever we delete a `User`, we want all drones owned by this user to be deleted
    too, and therefore, we specified the `models.CASCADE` value for the `on_delete`
    argument.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们删除一个`User`时，我们希望删除该用户拥有的所有无人机，因此我们为`on_delete`参数指定了`models.CASCADE`值。
- en: 'Open the `restful01/drones/serializers.py` file and add the following code
    after the last line that declares the imports, before the declaration of the `DroneCategorySerializer`
    class. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/serializers.py` file:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`restful01/drones/serializers.py`文件，在声明导入的最后一行之后、`DroneCategorySerializer`类声明之前添加以下代码。示例代码文件包含在`hillar_django_restful_08_01`文件夹中，位于`restful01/drones/serializers.py`文件内：
- en: '[PRE65]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We don''t want to use the `DroneSerializer` serializer class for the drones
    related to a user because we want to serialize fewer fields, and therefore, we
    created the `UserDroneSerializer` class. This class is a subclass of the `HyperlinkedModelSerializer`
    class. This new serializer allows us to serialize the drones related to a `User`.
    The `UserDroneSerializer` class defines a `Meta` inner class that declares the
    following two attributes:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想为与用户相关的无人机使用`DroneSerializer`序列化类，因为我们想序列化更少的字段，因此我们创建了`UserDroneSerializer`类。这个类是`HyperlinkedModelSerializer`类的子类。这个新的序列化器允许我们序列化与`User`相关的无人机。`UserDroneSerializer`类定义了一个`Meta`内部类，声明以下两个属性：
- en: '`model`: This attribute specifies the model related to the serializer, that
    is, the `Drone` class.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`：此属性指定与序列化器相关的模型，即`Drone`类。'
- en: '`fields`: This attribute specifies a tuple of string whose values indicate
    the field names that we want to include in the serialization from the related
    model. We just want to include the URL and the drone''s name, and therefore, the
    code includes `''url''` and `''name''` as members of the tuple.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields`：此属性指定了一个字符串值的元组，这些值指示我们想要包含在从相关模型序列化中的字段名称。我们只想包含URL和无人机名称，因此代码将`''url''`和`''name''`作为元组的成员。'
- en: The `UserSerializer` is a subclass of the `HyperlinkedModelSerializer` class.
    This new serializer class declares a `drones` attribute as an instance of the
    previously explained `UserDroneSerializer` class, with the `many` and `read_only`
    arguments equal to `True` because it is a one-to-many relationship and it is read-only.
    The code specifies the `drones` name that we specified as the string value for
    the `related_name` argument when we added the `owner` field as a `models.ForeignKey`
    instance in the `Drone` model. This way, the `drones` field will provide us with
    an array of URLs and names for each drone that belongs to the user.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserSerializer`是`HyperlinkedModelSerializer`类的子类。这个新的序列化器类声明了一个`drones`属性，它是之前解释过的`UserDroneSerializer`类的实例，`many`和`read_only`参数等于`True`，因为这是一个一对一关系，并且是只读的。代码指定了`drones`名称，我们在将`owner`字段作为`models.ForeignKey`实例添加到`Drone`模型时，将其指定为`related_name`参数的字符串值。这样，`drones`字段将为我们提供每个属于用户的无人机的URL和名称数组。'
- en: Now, we will add an `owner` field to the existing `DroneSerializer` class. Open
    the `restful01/drones/serializers.py` file and replace the code that declares
    the `DroneSerializer` class with the following code. The new lines are highlighted
    in the code listing. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/serializers.py` file.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向现有的`DroneSerializer`类添加一个`owner`字段。打开`restful01/drones/serializers.py`文件，将声明`DroneSerializer`类的代码替换为以下代码。新行在代码列表中突出显示。示例代码文件包含在`hillar_django_restful_08_01`文件夹中，`restful01/drones/serializers.py`文件中。
- en: '[PRE66]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The new version of the `DroneSerializer` class declares an `owner` attribute
    as an instance of `serializers.ReadOnlyField` with the `source` argument equal
    to `'owner.username'`. This way, the serializer will serialize the value for the
    `username` field of the related `django.contrib.auth.User` instance stored in
    the `owner` field.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`DroneSerializer`类的新版本声明了一个`owner`属性，它是一个`serializers.ReadOnlyField`的实例，其`source`参数等于`''owner.username''`。这样，序列化器将序列化存储在`owner`字段中的相关`django.contrib.auth.User`实例的`username`字段的值。'
- en: The code uses the `ReadOnlyField` class because the owner is automatically populated
    when an authenticated user creates a new drone. It will be impossible to change
    the owner after a drone has been created with an HTTP `POST` method call. This
    way, the `owner` field will render the username that created the related drone.
    In addition, we added `'owner'` to the `fields` string tuple within the `Meta`
    inner class.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`ReadOnlyField`类，因为所有者会在认证用户创建新无人机时自动填充。使用HTTP `POST`方法调用创建无人机后，将无法更改所有者。这样，`owner`字段将渲染创建相关无人机的用户名。此外，我们在`Meta`内部类的`fields`字符串元组中添加了`'owner'`。
- en: We made the necessary changes to the `Drone` model and its serializer (the `DroneSerializer`
    class) to make drones have owners.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`Drone`模型及其序列化器（`DroneSerializer`类）进行了必要的更改，以便无人机拥有所有者。
- en: Working with object-level permissions via customized permission classes
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过自定义权限类进行对象级权限操作
- en: The `rest_framework.permissions.BasePermission` class is the base class from
    which all customized permission classes should inherit to work with the Django
    REST framework. We want to make sure that only a drone owner can update or delete
    an existing drone.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`rest_framework.permissions.BasePermission`类是所有自定义权限类应该继承以与Django REST框架一起工作的基类。我们想确保只有无人机所有者才能更新或删除现有的无人机。'
- en: 'Go to the `restful01/drones` folder and create a new file named `custompermission.py`.
    Write the following code in this new file. The following lines show the code for
    this file that declares the new `IsCurrentUserOwnerOrReadOnly` class declared
    as a subclass of the `BasePermission` class. The code file for the sample is included
    in the `hillar_django_restful_08_01` folder in the `restful01/drones/custompermission.py`
    file:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`restful01/drones`文件夹，创建一个名为`custompermission.py`的新文件。在这个新文件中写下以下代码。以下行显示了该文件中声明的`IsCurrentUserOwnerOrReadOnly`类，该类作为`BasePermission`类的子类。示例代码文件包含在`hillar_django_restful_08_01`文件夹中的`restful01/drones/custompermission.py`文件中：
- en: '[PRE67]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The previous lines declare the `IsCurrentUserOwnerOrReadOnly` class and override
    the `has_object_permission` method defined in the `BasePermission` superclass
    that returns a `bool` value indicating whether the permission should be granted
    or not.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行声明了`IsCurrentUserOwnerOrReadOnly`类，并覆盖了在`BasePermission`超类中定义的`has_object_permission`方法，该方法返回一个表示是否应授予权限的`bool`值。
- en: 'The `permissions.SAFE_METHODS` tuple of string includes the three HTTP methods
    or verbs that are considered safe because they are read-only and they don''t produce
    changes to the related resource or resource collection: `''GET''`, `''HEAD''`,
    and `''OPTIONS''`. The code in the `has_object_permission` method checks whether
    the HTTP verb specified in the `request.method` attribute is any of the three
    safe methods specified in `permission.SAFE_METHODS`. If this expression evaluates
    to `True`, the `has_object_permission` method returns `True` and grants permission
    to the request.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串元组`permissions.SAFE_METHODS`包括三个被认为是安全的HTTP方法或动词，因为它们是只读的，并且不会对相关资源或资源集合产生更改：`'GET'`、`'HEAD'`和`'OPTIONS'`。`has_object_permission`方法中的代码检查`request.method`属性中指定的HTTP动词是否是`permission.SAFE_METHODS`中指定的三个安全方法之一。如果此表达式评估为`True`，则`has_object_permission`方法返回`True`并授予请求权限。
- en: If the HTTP verb specified in the `request.method` attribute is not any of the
    three safe methods, the code returns `True` and grants permission only when the
    `owner` attribute of the received `obj` object (`obj.owner`) matches the user
    that originated the request (`request.user`). The user that originated the request
    will always be the authenticated user. This way, only the owner of the related
    resource will be granted permission for those requests that include HTTP verbs
    that aren't safe.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`request.method`属性中指定的HTTP动词不是三种安全方法中的任何一种，则代码返回`True`，并且只有在接收到的`obj`对象（`obj.owner`）的`owner`属性与发起请求的用户（`request.user`）匹配时才授予权限。发起请求的用户始终是认证用户。这样，只有相关资源的所有者才会被授予包含非安全HTTP动词的请求的权限。
- en: We will use the new `IsCurrentUserOwnerOrReadOnly` customized permission class
    to make sure that only the drone owners can make changes to an existing drone.
    We will combine this permission class with the `rest_framework.permissions.IsAuthenticatedOrReadOnly`
    one that only allows read-only access to resources when the request doesn't belong
    to an authenticated user. This way, whenever an anonymous user performs a request,
    he will only have read-only access to the resources.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用新的`IsCurrentUserOwnerOrReadOnly`自定义权限类来确保只有无人机所有者才能更改现有的无人机。我们将此权限类与`rest_framework.permissions.IsAuthenticatedOrReadOnly`结合使用，后者在请求不属于认证用户时只允许对资源进行只读访问。这样，每当匿名用户执行请求时，他将对资源只有只读访问权限。
- en: Saving information about users that make requests
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存请求用户的详细信息
- en: Whenever a user performs an HTTP `POST` request to the drone resource collection
    to create a new drone resource, we want to make the authenticated user that makes
    the request the owner of the new drone. In order to make this happen, we will
    override the `perform_create` method in the `DroneList` class declared in the
    `views.py` file.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户向无人机资源集合执行HTTP `POST`请求以创建新的无人机资源时，我们希望使发起请求的认证用户成为新无人机的所有者。为了实现这一点，我们将在`views.py`文件中声明的`DroneList`类中覆盖`perform_create`方法。
- en: 'Open the `restful01/drones/views.py` file and replace the code that declares
    the `DroneList` class with the following code. The new lines are highlighted in
    the code listing. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`restful01/drones/views.py`文件，将声明`DroneList`类的代码替换为以下代码。代码列表中的新行被突出显示。示例的代码文件包含在`hillar_django_restful_08_01`文件夹中，位于`restful01/drones/views.py`文件中：
- en: '[PRE68]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `generics.ListCreateAPIView` class inherits from the `CreateModelMixin`
    class and other classes. The `DroneList` class inherits the `perform_create` method
    from the `rest_framework.mixins.CreateModelMixin` class.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`generics.ListCreateAPIView`类从`CreateModelMixin`类和其他类继承。`DroneList`类从`rest_framework.mixins.CreateModelMixin`类继承`perform_create`方法。'
- en: The code that overrides the `perform_create` method provides an additional `owner`
    field to the `create` method by setting a value for the `owner` argument in the
    call to the `serializer.save` method. The code sets the `owner` argument to the
    value of `self.request.user`, that is, to the authenticated user that is making
    the request. This way, whenever a new `Drone` is created and persisted, it will
    save the `User` associated to the request as its owner.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖`perform_create`方法的代码通过在调用`serializer.save`方法时设置`owner`参数的值，向`create`方法提供了额外的`owner`字段。代码将`owner`参数设置为`self.request.user`的值，即发起请求的认证用户。这样，每当创建并持久化新的`Drone`时，它将保存与请求关联的`User`作为其所有者。
- en: Setting permission policies
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置权限策略
- en: We will configure permission policies for the class-based views that work with
    the `Drone` model. We will override the value for the `permission_classes` class
    attribute for the `DroneDetail` and `DroneList` classes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为与`Drone`模型一起工作的基于类的视图配置权限策略。我们将覆盖`DroneDetail`和`DroneList`类的`permission_classes`类属性的值。
- en: We will add the same lines of code in the two classes. We will include the `IsAuthenticatedOrReadOnly`
    class and our recently declared `IsCurrentUserOwnerOrReadOnly` permission class
    in the `permission_classes` tuple.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在两个类中添加相同的代码行。我们将包括`IsAuthenticatedOrReadOnly`类和我们最近声明的`IsCurrentUserOwnerOrReadOnly`权限类在`permission_classes`元组中。
- en: 'Open the `restful01/drones/views.py` file and add the following lines after
    the last line that declares the imports, before the declaration of the `DroneCategorySerializer`
    class:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`restful01/drones/views.py`文件，在声明导入的最后一行之后、`DroneCategorySerializer`类声明之前添加以下行：
- en: '[PRE69]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Replace the code that declares the `DroneDetail` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一`views.py`文件中将声明`DroneDetail`类的代码替换为以下代码。新行在代码列表中突出显示。示例的代码文件包含在`hillar_django_restful_08_01`文件夹中，在`restful01/drones/views.py`文件中：
- en: '[PRE70]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Replace the code that declares the `DroneList` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一`views.py`文件中将声明`DroneList`类的代码替换为以下代码。新行在代码列表中突出显示。示例的代码文件包含在`hillar_django_restful_08_01`文件夹中，在`restful01/drones/views.py`文件中：
- en: '[PRE71]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Creating the superuser for Django
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Django的超级用户
- en: Now, we will run the necessary command to create the `superuser` for Django
    that will allow us to authenticate our requests. We will create other users later.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将运行必要的命令来创建Django的`superuser`，这将允许我们验证我们的请求。我们将在稍后创建其他用户。
- en: 'Make sure you are in the `restful01` folder that includes the `manage.py` file
    in the activated virtual environment. Execute the following command that executes
    the `createsuperuser` subcommand for the `manage.py` script to allow us to create
    the `superuser`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您位于包含`manage.py`文件的`restful01`文件夹中，该文件位于已激活的虚拟环境中。执行以下命令以执行`manage.py`脚本的`createsuperuser`子命令，以便我们可以创建`superuser`：
- en: '[PRE72]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The command will ask you for the username you want to use for the `superuser`.
    Enter the desired username and press *Enter*. We will use `djangosuper` as the
    username for this example. You will see a line similar to the following one:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将要求您输入用于`superuser`的想要使用的用户名。输入所需的用户名并按*Enter*键。在这个例子中，我们将使用`djangosuper`作为用户名。您将看到类似以下的一行：
- en: '[PRE73]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, the command will ask you for the email address. Enter an email address
    and press *Enter.* You can enter `djangosuper@example.com`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，命令将要求您输入电子邮件地址。输入电子邮件地址并按*Enter*键。您可以输入`djangosuper@example.com`：
- en: '[PRE74]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, the command will ask you for the password for the new superuser. Enter
    your desired password and press *Enter*. We will use `passwordforsuper` as an
    example in our tests. Of course, this password is not the best example of a strong
    password. However, the password is easy to type and read in our tests:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，命令将要求您输入新超级用户的密码。输入您想要的密码并按*Enter*键。在我们的测试中，我们将使用`passwordforsuper`作为示例。当然，这个密码并不是一个强大的密码的最佳例子。然而，在我们的测试中，这个密码易于输入和阅读：
- en: '[PRE75]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The command will ask you to enter the password again. Enter it and press *Enter*.
    If both entered passwords match, the superuser will be created:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将要求您再次输入密码。输入它并按*Enter*键。如果输入的两个密码匹配，则将创建超级用户：
- en: '[PRE76]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Our database has many rows in the `drones_drone` table. We added a new `owner`
    field for the `Drone` model and this required field will be added to the `drones_drone`
    table after we execute migrations. We have to assign a default owner for all the
    existing drones to make it possible to add this new required field without having
    to delete all these drones. We will use one of the features included in Django
    to solve the issue.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库在`drones_drone`表中有很多行。我们为`Drone`模型添加了一个新的`owner`字段，并在执行迁移后，这个必需的字段将被添加到`drones_drone`表中。我们必须为所有现有无人机指定一个默认所有者，以便在不删除这些无人机的情况下添加这个新必需字段。我们将使用Django包含的其中一个功能来解决这个问题。
- en: First, we have to know the `id` value for the superuser we have created to use
    it as the default owner for the existing drones. Then, we will use this value
    to let Django know which is the default owner for the existing drones.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须知道我们创建的超级用户的`id`值，以便将其用作现有无人机的默认所有者。然后，我们将使用此值让Django知道哪个是现有无人机的默认所有者。
- en: We created the first user, and therefore, the `id` will be equal to `1`. However,
    we will check the procedure to determine the `id` value in case you create other
    users and you want to assign any other user as the default owner.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了第一个用户，因此，`id`将等于`1`。但是，我们将检查确定`id`值的程序，以防您创建其他用户，并且您想将任何其他用户指定为默认所有者。
- en: You can check the row in the `auth_user` table whose `username` field matches
    `'djangosuper'` in any tool that works with PostgreSQL. Another option is to run
    the following commands to retrieve the ID from the auth_user table for the row
    whose username is equal to `'djangosuper'`. In case you specified a different
    name, make sure you use the appropriate one. In addition, replace the username
    in the command with the username you used to create the PostgreSQL database and
    password with your chosen password for this database user. You specified this
    information when you executed the steps explained in [Chapter 6](dj-rst-websvc_ch16.html),
    *Working with Advanced Relationships and Serialization*, in the *Running migrations
    that generate relationships* section.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何与 PostgreSQL 兼容的工具检查 `auth_user` 表中 `username` 字段与 `'djangosuper'` 匹配的行。另一个选项是运行以下命令，从
    `auth_user` 表中检索用户名为 `'djangosuper'` 的行的 ID。如果你指定了不同的名称，请确保使用适当的名称。此外，在命令中将用户名替换为你创建
    PostgreSQL 数据库时使用的用户名，将密码替换为你为该数据库用户选择的密码。你是在执行第 [6 章](dj-rst-websvc_ch16.html)
    中解释的步骤时指定这些信息的，该章节是 *Running migrations that generate relationships* 部分，标题为 *使用高级关系和序列化*。
- en: 'The command assumes that you are running PostgreSQL on the same computer in
    which you are executing the command:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 命令假设你在执行命令的同一台计算机上运行 PostgreSQL：
- en: '[PRE77]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following lines show the output with the value for the `id` field: `1`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了 `id` 字段的值为 `1` 的输出：
- en: '[PRE78]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, run the following Python script to generate the migrations that will allow
    us to synchronize the database with the new field we added to the `Drone` model:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下 Python 脚本来生成迁移，这将允许我们同步数据库与我们添加到 `Drone` 模型的新字段：
- en: '[PRE79]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Django will explain to us that we cannot add a non-nullable field without a
    default and will ask us to select an option with the following message:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Django 将向我们解释，我们无法在不提供默认值的情况下添加不可为空的字段，并要求我们选择以下消息的选项：
- en: '[PRE80]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Enter `1` and press *Enter*. This way, we will select the first option to provide
    the one-off default that will be set on all the existing `drones_drone` rows.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `1` 并按 *Enter*。这样，我们将选择第一个选项，为所有现有的 `drones_drone` 行设置一次性默认值。
- en: 'Django will ask us to provide the default value we want to set for the `owner`
    field of the `drones_drone` table:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Django 将要求我们提供要为 `drones_drone` 表的 `owner` 字段设置的默认值：
- en: '[PRE81]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Enter the value for the previously retrieved `id`: `1`. Then, press *Enter*.
    The following lines show the output generated after running the previous command:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 输入之前检索到的 `id` 值：`1`。然后，按 *Enter*。以下行显示了运行前面的命令后生成的输出：
- en: '[PRE82]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output indicates that the `restful01/drones/migrations/0003_drone_owner.py`
    file includes the code to add the field named `owner` to the `drone` table. The
    following lines show the code for this file that was automatically generated by
    Django. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `restful01/drones/migrations/0003_drone_owner.py` file:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 输出指示 `restful01/drones/migrations/0003_drone_owner.py` 文件包含将名为 `owner` 的字段添加到
    `drone` 表的代码。以下行显示了由 Django 自动生成的此文件的代码。示例的代码文件包含在 `hillar_django_restful_08_01`
    文件夹中的 `restful01/drones/migrations/0003_drone_owner.py` 文件中：
- en: '[PRE83]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The code declares the `Migration` class as a subclass of the `django.db.migrations.Migration`
    class. The `Migration` class defines an `operations` list with a `migrations.AddField`
    instance that will add the `owner` field to the table related to the `drone` model.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将 `Migration` 类声明为 `django.db.migrations.Migration` 类的子类。`Migration` 类定义了一个包含
    `migrations.AddField` 实例的 `operations` 列表，该实例将添加 `owner` 字段到与 `drone` 模型相关的表中。
- en: 'Now, run the following Python script to apply all the generated migrations
    and execute the changes in the database tables:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下 Python 脚本来应用所有生成的迁移并执行数据库表中的更改：
- en: '[PRE84]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The following lines show the output generated after running the previous command:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行前面的命令后生成的输出：
- en: '[PRE85]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'After we run the previous command, we will have a new `owner_id` field in the
    `drones_drone` table in the PostgreSQL database. The existing rows in the `drones_drone`
    table will use the default value we instructed Django to use for the new `owner_id`
    field: `1`. This way, the superuser named `''djangosuper''` will be the owner
    for all the existing drones.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行前面的命令后，PostgreSQL 数据库中的 `drones_drone` 表将有一个新的 `owner_id` 字段。`drones_drone`
    表中现有的行将使用我们指示 Django 为新的 `owner_id` 字段使用的默认值：`1`。这样，名为 `'djangosuper'` 的超级用户将成为所有现有无人机的所有者。
- en: We can use the PostgreSQL command line or any other application that allows
    us to easily check the contents of the PostreSQL database to browse the `drones_drone`
    table that Django updated.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 PostgreSQL 命令行或任何其他允许我们轻松检查 PostgreSQL 数据库内容的程序来浏览 Django 更新的 `drones_drone`
    表。
- en: 'The following screenshot shows the new structure for the `drones_drone` table
    at the left-hand side and all its rows at the right-hand side:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了左侧 `drones_drone` 表的新结构及其右侧的所有行：
- en: '![](img/a9099daf-bfb1-41a2-aec6-80de7af1a110.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9099daf-bfb1-41a2-aec6-80de7af1a110.png)'
- en: Creating a user for Django
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Django 创建用户
- en: 'Now, we will use Django''s interactive shell to create a new user for Django.
    Run the following command to launch Django''s interactive shell. Make sure you
    are within the `restful01` folder in the terminal, Command Prompt, or Windows
    Powershell window in which you have the virtual environment activated:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Django 的交互式 shell 来为 Django 创建一个新用户。运行以下命令以启动 Django 的交互式 shell。确保你在终端、命令提示符或
    Windows Powershell 窗口中位于已激活虚拟环境的 `restful01` 文件夹内：
- en: '[PRE86]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You will notice that a line that says **(**InteractiveConsole**)** is displayed
    after the usual lines that introduce your default Python interactive shell. Enter
    the following code in the shell to create another user that is not a superuser.
    We will use this user and the superuser to test our changes in the permissions
    policies. The code file for the sample is included in the `hillar_django_restful_08_01`
    folder, in the `scripts/create_user.py` file. You can replace `user01` with your
    desired username, `user01@example.com` with the email and `user01password` with
    the password you want to use for this user. Notice that we will be using these
    credentials in the following sections. Make sure you always replace the credentials
    with your own credentials:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在介绍默认 Python 交互式 shell 的常规行之后，会显示一条说 **(**InteractiveConsole**)** 的行。在
    shell 中输入以下代码以创建另一个非超级用户。我们将使用此用户和超级用户来测试我们的权限策略更改。示例代码文件包含在 `hillar_django_restful_08_01`
    文件夹中的 `scripts/create_user.py` 文件中。您可以将 `user01` 替换为您想要的用户名，`user01@example.com`
    替换为电子邮件，`user01password` 替换为您想要为此用户使用的密码。请注意，我们将在以下部分中使用这些凭据。请确保您始终使用自己的凭据替换凭据：
- en: '[PRE87]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Finally, enter the following command to quit the interactive console:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输入以下命令以退出交互式控制台：
- en: '[PRE88]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You can achieve the same goal by pressing *Ctrl + D*. Now, we have a new user
    for Django named `user01`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过按 *Ctrl + D* 来达到相同的目的。现在，我们为 Django 创建了一个名为 `user01` 的新用户。
- en: Making authenticated requests
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送认证请求
- en: 'Now, we can launch Django''s development server to compose and send authenticated
    HTTP requests to understand how the configured authentication classes, combined
    with the permission policies, work. Execute any of the following two commands
    based on your needs to access the API in other devices or computers connected
    to your LAN. Remember that we analyzed the difference between them in [Chapter
    3](dj-rst-websvc_ch13.html),*Creating API Views*, in the *Launching Django''s
    development server* section:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动 Django 的开发服务器，以编写和发送认证的 HTTP 请求，了解配置的认证类与权限策略是如何协同工作的。根据您的需求执行以下两个命令之一以访问连接到您的局域网的其他设备或计算机上的
    API。请记住，我们在 *启动 Django 的开发服务器* 部分的 [第 3 章](dj-rst-websvc_ch13.html) 中分析了它们之间的区别：
- en: '[PRE89]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前的任何命令后，开发服务器将在端口 `8000` 上开始监听。
- en: 'We will compose and send an HTTP `POST` request without authentication credentials
    to try to create a new drone:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发送一个不带认证凭据的 HTTP `POST` 请求，尝试创建一个新的无人机：
- en: '[PRE90]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE91]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We will receive an `HTTP 401 Unauthorized` status code in the response header
    and a `detail` message indicating that we didn''t provide authentication credentials
    in the JSON body. The following lines show a sample response:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在响应头中收到 `HTTP 401 未授权` 状态码和一个 `detail` 消息，表明我们没有在 JSON 主体中提供认证凭据。以下行显示了示例响应：
- en: '[PRE92]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'After the changes we made, if we want to create a new drone, that is, to make
    an HTTP `POST` request to `/drones/`, we need to provide authentication credentials
    by using HTTP authentication. Now, we will compose and send an HTTP request to
    create a new drone with authentication credentials, that is, with the superuser
    name and his password. Remember to replace `djangosuper` with the name you used
    for the superuser and `passwordforsuper` with the password you configured for
    this user:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做出的更改之后，如果我们想要创建一个新的无人机，即向 `/drones/` 发送 HTTP `POST` 请求，我们需要通过使用 HTTP 身份验证提供身份验证凭据。现在，我们将使用具有身份验证凭据（即超级用户名和密码）创建新无人机的
    HTTP 请求进行组合和发送。请记住将 `djangosuper` 替换为您用于超级用户的名字，将 `passwordforsuper` 替换为您为该用户配置的密码：
- en: '[PRE93]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE94]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The new `Drone` with the superuser named `djangosuper` as its owner has been
    successfully created and persisted in the database because the request was authenticated.
    As a result of the request, we will receive an `HTTP 201 Created` status code
    in the response header and the recently persisted `Drone` serialized to JSON in
    the response body. The following lines show an example response for the HTTP request,
    with the new `Drone` object in the JSON response body. Notice that the JSON response
    body includes the `owner` key and the username that created the drone as its value:
    `djangosuper`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `djangosuper` 为所有者的新 `Drone` 已成功创建并持久化到数据库中，因为请求已通过身份验证。作为请求的结果，我们将在响应头中收到
    `HTTP 201 Created` 状态码，并在响应体中将最近持久化的 `Drone` 序列化为 JSON。以下行显示了 HTTP 请求的示例响应，其中新的
    `Drone` 对象在 JSON 响应体中。请注意，JSON 响应体包括 `owner` 键和创建无人机的用户名作为其值：`djangosuper`：
- en: '[PRE95]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Now, we will try to update the `has_it_competed` field value for the previously
    created drone with an HTTP `PATCH` request. However, we will use the other user
    we created in Django to authenticate this HTTP `PATCH` request. This user isn't
    the owner of the drone, and therefore, the request shouldn't succeed.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试使用 HTTP `PATCH` 请求更新之前创建的无人机的 `has_it_competed` 字段值。然而，我们将使用在 Django
    中创建的另一个用户来对 HTTP `PATCH` 请求进行身份验证。这个用户不是无人机的所有者，因此请求不应成功。
- en: 'Replace `user01` and `user01password` in the next command with the name and
    password you configured for this user. In addition, replace `12` with the ID generated
    for the previously created drone in your configuration:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个命令中将 `user01` 和 `user01password` 替换为您为该用户配置的名称和密码。此外，将 `12` 替换为您在配置中为之前创建的无人机生成的
    ID：
- en: '[PRE96]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE97]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We will receive an `HTTP 403 Forbidden` status code in the response header
    and a detail message indicating that we do not have permission to perform the
    action in the JSON body. The owner for the drone we want to update is `djangosuper`
    and the authentication credentials for this request use a different user: `user01`.
    Hence, the operation is rejected by the `has_object_permission` method in the
    `IsCurrentUserOwnerOrReadOnly` customized permission class we created. The following
    lines show a sample response:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在响应头中收到 `HTTP 403 Forbidden` 状态码，并在 JSON 主体中收到一个详细消息，表明我们没有权限执行该操作。我们想要更新的无人机的所有者是
    `djangosuper`，而此请求的身份验证凭据使用的是不同的用户：`user01`。因此，操作被我们创建的 `IsCurrentUserOwnerOrReadOnly`
    定制权限类中的 `has_object_permission` 方法拒绝。以下行显示了示例响应：
- en: '[PRE98]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The user that isn''t the drone''s owner cannot make changes to the drone. However,
    he must be able to have read-only access to the drone. Hence, we must be able
    to compose and retrieve the previous drone details with an HTTP `GET` request
    with the same authentication credentials. It will work because `GET` is one of
    the safe methods and a user that is not the owner is allowed to read the resource.
    Replace `user01` and `user01password` in the next command with the name and password
    you configured for this user. In addition, replace `12` with the ID generated
    for the previously created drone in your configuration:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 不是无人机所有者的用户不能对无人机进行更改。然而，他必须能够以只读方式访问无人机。因此，我们必须能够使用具有相同身份验证凭据的 HTTP `GET` 请求组合和检索之前的无人机详细信息。这将有效，因为
    `GET` 是安全方法之一，并且非所有者用户被允许读取资源。在下一个命令中将 `user01` 和 `user01password` 替换为您为该用户配置的名称和密码。此外，将
    `12` 替换为您在配置中为之前创建的无人机生成的 ID：
- en: '[PRE99]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE100]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The response will return an `HTTP 200 OK` status code in the header and the
    requested `Drone` serialized to JSON in the response body.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将在头部返回 `HTTP 200 OK` 状态代码，并在响应体中将请求的 `Drone` 序列化为 JSON 格式。
- en: Making authenticated HTTP PATCH requests with Postman
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Postman 制作经过身份验证的 HTTP PATCH 请求
- en: Now, we will use one of the GUI tools we installed in *Chapter 1,* *Installing
    the Required Software and Tools*, specifically, Postman. We will use this GUI
    tool to compose and send an HTTP `PATCH` request with the appropriate authentication
    credentials to the web service. In the previous chapters, whenever we worked with
    Postman, we didn't specify authentication credentials.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用我们在 *第 1 章* 中安装的图形界面工具之一，即 Postman。我们将使用此图形界面工具来编写并发送带有适当身份验证凭据的 HTTP
    `PATCH` 请求到 Web 服务。在前面的章节中，每当我们在 Postman 中工作时，我们都没有指定身份验证凭据。
- en: 'We will use the Builder tab in Postman to compose and send an HTTP `PATCH`
    request to update the `has_it_competed` field for the previously created drone.
    Follow these steps:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Postman 中的“构建器”标签来编写并发送一个 HTTP `PATCH` 请求，以更新之前创建的无人机的 `has_it_competed`
    字段。按照以下步骤操作：
- en: In case you made previous requests with Postman, click on the plus (**+**) button
    at the right-hand side of the tab that displayed the previous request. This way,
    you will create a new tab.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您之前使用 Postman 发送过请求，请点击标签右侧的加号（**+**）按钮。这样，您将创建一个新的标签。
- en: Select PATCH in the drop-down menu at the left-hand side of the Enter request
    URL textbox.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“输入请求 URL”文本框左侧的下拉菜单中选择 PATCH。
- en: Enter `http://localhost:8000/drones/12` in that textbox at the right-hand side
    of the drop-down. Replace `12` with the ID generated for the previously created
    drone in your configuration.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单右侧的文本框中输入 `http://localhost:8000/drones/12`。将 `12` 替换为您在配置中为之前创建的无人机生成的
    ID。
- en: Click the Authorization tab below the textbox.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文本框下方的“授权”标签。
- en: Select Basic Auth in the TYPE drop-down.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类型下拉菜单中选择基本身份验证。
- en: Enter the name you used to create `djangosuper` in the Username textbox.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户名文本框中输入您用于创建 `djangosuper` 的名称。
- en: 'Enter the password you used instead of `passwordforsuper` for this user in
    the Password textbox. The following screenshot shows the basic authentication
    configured in Postman for the HTTP `PATCH` request:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在密码文本框中输入您为该用户使用的密码，而不是 `passwordforsuper`。以下截图显示了 Postman 中为 HTTP `PATCH` 请求配置的基本身份验证：
- en: '![](img/0883be60-59a2-4a55-84b0-e89d32eb7be9.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0883be60-59a2-4a55-84b0-e89d32eb7be9.png)'
- en: Click Body at the right-hand side of the Authorization and Headers tabs, within
    the panel that composes the request.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求面板中，点击授权和头部标签右侧的“Body”。
- en: Activate the raw radio button and select JSON (application/json) in the drop-down
    at the right-hand side of the binary radio button. Postman will automatically
    add a Content-type = application/json header, and therefore, you will notice the
    Headers tab will be renamed to Headers (1), indicating to us that there is one
    key/value pair specified for the request headers.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活原始单选按钮，并在二进制单选按钮右侧的下拉菜单中选择 JSON（application/json）。Postman 将自动添加 Content-type
    = application/json 头部，因此您会注意到头部标签将被重命名为头部（1），这表示我们已为请求头部指定了一个键/值对。
- en: 'Enter the following lines in the textbox below the radio buttons, within the
    Body tab:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Body”标签下的单选按钮下方的文本框中输入以下行：
- en: '[PRE101]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The following screenshot shows the request body in Postman:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Postman 中的请求体：
- en: '![](img/043a3075-b78c-4ab1-839a-d2f2c47f6f94.png)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![](img/043a3075-b78c-4ab1-839a-d2f2c47f6f94.png)'
- en: 'We followed the necessary steps to create an HTTP `PATCH` request with a JSON
    body that specifies the necessary key/value pairs to update the value for the
    `was_included_in_home` field of an existing drone, with the necessary HTTP authentication
    credentials. Click Send and Postman will display the following information:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了必要的步骤，使用 JSON 正文创建了一个 HTTP `PATCH` 请求，该正文指定了更新现有无人机 `was_included_in_home`
    字段所需的关键/值对，并带有必要的 HTTP 身份验证凭据。点击发送，Postman 将显示以下信息：
- en: 'Status: `200 OK`'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态：`200 OK`
- en: 'Time: The time it took for the request to be processed'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间：请求处理所需的时间
- en: 'Size: The approximate response size (sum of body size plus headers size)'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小：响应的大致大小（正文大小加头部大小）
- en: 'Body: The response body with the recently updated drone formatted as JSON with
    syntax highlighting'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正文：带有语法高亮的最近更新的无人机格式的响应体
- en: 'The following screenshot shows the JSON response body in Postman for the HTTP
    `PATCH` request. In this case, the request updated the existing drone because
    we authenticated the request with the user that is the drone''s owner:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Postman 中 HTTP `PATCH` 请求的 JSON 响应体。在这种情况下，请求更新了现有的无人机，因为我们使用拥有该无人机所有权的用户进行了请求认证：
- en: '![](img/1d2fa033-b76a-418a-9082-c3ebaffef574.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d2fa033-b76a-418a-9082-c3ebaffef574.png)'
- en: Browsing the secured API with the required authentication
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用所需的身份验证浏览受保护的 API
- en: We want the browsable API to display the log in and log out views. In order
    to make this possible, we have to add a line in the `urls.py` file in the `restful01/restful01`
    folder, specifically, in the `restful01/restful01/urls.py` file. The file defines
    the root URL configurations and we want to include the URL patterns provided by
    the Django REST framework that provide the log in and log out views.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望可浏览的 API 显示登录和注销视图。为了实现这一点，我们必须在 `restful01/restful01` 文件夹中的 `urls.py` 文件中添加一行，具体来说，在
    `restful01/restful01/urls.py` 文件中。该文件定义了根 URL 配置，我们希望包含 Django REST 框架提供的 URL
    模式，这些模式提供了登录和注销视图。
- en: 'The following lines show the new code for the `restful01/restful01/urls.py`
    file. The new line is highlighted. The code file for the sample is included in
    the `hillar_django_restful_08_01` folder, in the `restful01/restful01/urls.py`
    file:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了 `restful01/restful01/urls.py` 文件的新代码。新行已被突出显示。示例代码文件包含在 `hillar_django_restful_08_01`
    文件夹中的 `restful01/restful01/urls.py` 文件中：
- en: '[PRE102]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Open a web browser and go to `http://localhost:8000/`. Replace localhost by
    the IP of the computer that is running Django's development server in case you
    use another computer or device to run the browser. The browsable API will compose
    and send a `GET` request to `/` and will display the results of its execution,
    that is, the Api Root. You will notice there is a Log in hyperlink at the upper-right
    corner.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 打开网页浏览器并访问 `http://localhost:8000/`。如果你使用另一台计算机或设备来运行浏览器，请将 localhost 替换为运行
    Django 开发服务器的计算机的 IP 地址。可浏览的 API 将会向 `/` 发送一个 `GET` 请求，并显示其执行结果，即 API 根目录。你会在右上角注意到有一个登录超链接。
- en: Click or tap Log in and the browser will display the Django REST framework login
    page. Enter the name you used to create `djangosuper` in the Username textbox
    and the password you used instead of `passwordforsuper` for this user in the Password
    textbox. Then, click Log in.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触登录，浏览器将显示 Django REST 框架的登录页面。在用户名文本框中输入你创建 `djangosuper` 时使用的名称，在密码文本框中输入你为该用户使用的密码（而不是
    `passwordforsuper`），然后点击登录。
- en: 'Now, you will be logged in as `djangosuper` and all the requests you compose
    and send through the browsable API will use this user. You will be redirected
    again to the Api Root and you will notice the Log in hyperlink is replaced with
    the username (djangosuper) and a drop-down menu that allows you to log out. The
    following screenshot shows the Api Root after we are logged in as `djangosuper`:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用 `djangosuper` 登录，并且你通过可浏览的 API 创建和发送的所有请求都将使用此用户。你将被重定向回 API 根目录，并且你会注意到登录超链接已被用户名（djangosuper）替换，并且出现一个下拉菜单，允许你注销。以下截图显示了以
    `djangosuper` 登录后的 API 根目录：
- en: '![](img/b59a2e88-187a-492d-872b-64a39cc7b4fd.png)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59a2e88-187a-492d-872b-64a39cc7b4fd.png)'
- en: Click or tap on the username that is logged in (djangosuper) and select Log
    Out from the drop-down menu. We will log in as a different user.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触已登录的用户名（djangosuper）并从下拉菜单中选择注销。我们将以不同的用户登录。
- en: Click or tap Log in and the browser will display the Django REST framework login
    page. Enter the name you used to create `user01` in the Username textbox and the
    password you used instead of `user01password` for this user in the Password textbox.
    Then, click Log in.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触登录，浏览器将显示 Django REST 框架的登录页面。在用户名文本框中输入你创建 `user01` 时使用的名称，在密码文本框中输入你为该用户使用的密码（而不是
    `user01password`），然后点击登录。
- en: Now, you will be logged in as `user01` and all the requests you compose and
    send through the browsable API will use this user. You will be redirected again
    to the Api Root and you will notice the Log in hyperlink is replaced with the
    username (user01).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用 `user01` 登录，并且你通过可浏览的 API 创建和发送的所有请求都将使用此用户。你将被重定向回 API 根目录，并且你会注意到登录超链接已被用户名（user01）替换。
- en: Go to `http://localhost:8000/drones/12`. Replace `12` with the ID generated
    for the previously created drone in your configuration. The browsable API will
    render the web page with the results for the `GET` request to `localhost:8000/drones/12`.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8000/drones/12`。将`12`替换为您在配置中为之前创建的无人机生成的ID。可浏览的API将渲染包含对`localhost:8000/drones/12`的`GET`请求结果的网页。
- en: Click or tap the OPTIONS button and the browsable API will render the results
    of the HTTP `OPTIONS` request to `http://localhost:8000/drones/12` and will include
    the DELETE button at the right-hand side of the Drone Detail title.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触“选项”按钮，可浏览的API将渲染对`http://localhost:8000/drones/12`的HTTP `OPTIONS`请求的结果，并在“无人机详情”标题的右侧包含“删除”按钮。
- en: 'Click or tap DELETE. The web browser will display a confirmation modal. Click
    or tap the DELETE button in the modal. As a result of the HTTP `DELETE` request,
    the web browser will display an `HTTP 403 Forbidden` status code in the response
    header and a detail message indicating that we do not have permission to perform
    the action in the JSON body. The owner for the drone we want to delete is `djangosuper`
    and the authentication credentials for this request use a different user, specifically,
    `user01`. Hence, the operation is rejected by the `has_object_permission` method
    in the `IsCurrentUserOwnerOrReadOnly` class. The following screenshot shows a
    sample response for the HTTP `DELETE` request:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触“删除”。网页浏览器将显示一个确认模态。在模态中点击或轻触“删除”按钮。由于HTTP `DELETE`请求的结果，网页浏览器将在响应头中显示`HTTP
    403 Forbidden`状态码，并在JSON体中显示一条详细消息，指出我们没有权限执行该操作。我们想要删除的无人机的所有者是`djangosuper`，而此请求的认证凭证使用的是不同的用户，具体为`user01`。因此，操作被`IsCurrentUserOwnerOrReadOnly`类中的`has_object_permission`方法拒绝。以下截图显示了HTTP
    `DELETE`请求的示例响应：
- en: '![](img/cd15f21d-27fe-49fc-a215-b63bfb46d6e6.png)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/cd15f21d-27fe-49fc-a215-b63bfb46d6e6.png)'
- en: The browsable API makes it easy to compose and send authenticated requests to
    our RESTful Web Service.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 可浏览的API使得向我们的RESTful Web服务发送认证请求变得容易。
- en: Working with token-based authentication
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于令牌的认证
- en: Now, we will make changes to use token-based authentication to retrieve, update,
    or delete pilots. Only those users that have a token will be able to make these
    operations with pilots. Hence, we will setup a specific authentication for pilots.
    It will still be possible to see the pilot's name rendered in unauthenticated
    requests.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进行更改以使用基于令牌的认证来检索、更新或删除飞行员。只有拥有令牌的用户才能对飞行员执行这些操作。因此，我们将为飞行员设置特定的认证。在未认证的请求中仍然可以看到飞行员的名字。
- en: The token-based authentication requires a new model named `Token`. Make sure
    you quit the Django's development server. Remember that you just need to press
    *Ctrl* + *C* in the terminal or command prompt window in which it is running.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的认证需要一个名为`Token`的新模型。确保您已退出Django的开发服务器。请记住，您只需在终端或命令提示符窗口中按*Ctrl* + *C*即可。
- en: Of course, in a production environment, we must make sure that the RESTful Web
    Service is only available over HTTPS, with the usage of the latest TLS versions.
    We shouldn't use a token-based authentication over plain HTTP in a production
    environment.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在生产环境中，我们必须确保RESTful Web服务仅通过HTTPS提供，并使用最新的TLS版本。我们不应在生产环境中使用基于令牌的认证通过纯HTTP。
- en: 'Open the `restful01/restful01/settings.py` file that declares module-level
    variables that define the configuration of Django for the `restful01` project.
    Locate the lines that assign a strings list to `INSTALLED_APPS` to declare the
    installed apps. Add the following string to the `INSTALLED_APPS` strings list
    and save the changes to the `settings.py` file:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 打开声明`restful01`项目Django配置的模块级变量的`restful01/restful01/settings.py`文件。找到将字符串列表分配给`INSTALLED_APPS`的行以声明已安装的应用程序。将以下字符串添加到`INSTALLED_APPS`字符串列表中，并将更改保存到`settings.py`文件中：
- en: '[PRE103]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The following lines show the new code that declares the `INSTALLED_APPS` strings
    list with the added line highlighted and with comments to understand what each
    added string means. The code file for the sample is included in the `hillar_django_restful_08_02`
    folder in the `restful01/restful01/settings.py` file:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了声明`INSTALLED_APPS`字符串列表的新代码，其中添加的行被突出显示，并带有注释以了解每个添加的字符串的含义。示例代码文件包含在`hillar_django_restful_08_02`文件夹中的`restful01/restful01/settings.py`文件中：
- en: '[PRE104]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This way, we have added the `rest_framework.authtoken` application to our Django
    project named `restful01`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就已将`rest_framework.authtoken`应用程序添加到名为`restful01`的Django项目中。
- en: 'Now, run the following Python script to execute all migrations required for
    the recently added `authtoken` application and apply the changes in the underlying
    database tables. This way, we will install the app:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下 Python 脚本来执行为最近添加的 `authtoken` 应用程序所需的全部迁移，并在底层数据库表中应用这些更改。这样，我们将安装该应用：
- en: '[PRE105]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The following lines show the output generated after running the previous command.
    Notice that the order in which the migrations are executed can differ in your
    development computer:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一条命令后生成的输出。请注意，迁移执行的顺序可能在你的开发计算机中有所不同：
- en: '[PRE106]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: After we run the previous command, we will have a new `authtoken_token` table
    in the PostgreSQL database. This table will persist the generated tokens and has
    a foreign key to the `auth_user` table.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上一条命令后，我们将在 PostgreSQL 数据库中有一个新的 `authtoken_token` 表。此表将持久化生成的令牌，并有一个指向 `auth_user`
    表的外键。
- en: We will configure authentication and permission policies for the class-based
    views that work with the `Pilot` model. We will override the values for the `authentication_classes`
    and `permission_classes` class attributes for the `PilotDetail` and `PilotList`
    classes.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为与 `Pilot` 模型一起工作的基于类的视图配置身份验证和权限策略。我们将覆盖 `PilotDetail` 和 `PilotList` 类的
    `authentication_classes` 和 `permission_classes` 类属性值。
- en: We will add the same lines of code in the two classes. We will include the `TokenAuthentication`
    authentication class in the `authentication_classes` tuple, and the `IsAuthenticated`
    permission class in the `permission_classes` tuple.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在两个类中添加相同的代码行。我们将包括 `TokenAuthentication` 身份验证类在 `authentication_classes`
    元组中，以及 `IsAuthenticated` 权限类在 `permission_classes` 元组中。
- en: 'Open the `restful01/drones/views.py` file and add the following lines after
    the last line that declares the imports, before the declaration of the `DroneCategorySerializer`
    class. The code file for the sample is included in the `hillar_django_restful_08_02`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `restful01/drones/views.py` 文件，在声明导入的最后一行之后、`DroneCategorySerializer` 类声明之前添加以下行。示例代码文件包含在
    `hillar_django_restful_08_02` 文件夹中的 `restful01/drones/views.py` 文件里：
- en: '[PRE107]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Replace the code that declares the `PilotDetail` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_08_02`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的 `views.py` 文件中，用以下代码替换声明 `PilotDetail` 类的代码。代码列表中的新行被突出显示。示例代码文件包含在 `hillar_django_restful_08_02`
    文件夹中的 `restful01/drones/views.py` 文件里：
- en: '[PRE108]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Replace the code that declares the `PilotList` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_08_02`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的 `views.py` 文件中，用以下代码替换声明 `PilotList` 类的代码。代码列表中的新行被突出显示。示例代码文件包含在 `hillar_django_restful_08_02`
    文件夹中的 `restful01/drones/views.py` 文件里：
- en: '[PRE109]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Generating and using tokens
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成和使用令牌
- en: Now, we will launch our default Python interactive shell in our virtual environment
    and make all the Django project modules available to write code that will generate
    a token for an existing user. We will do this to understand how the token generation
    works.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在虚拟环境中启动默认的 Python 交互式 shell，并使所有 Django 项目模块可用，以便编写生成现有用户令牌的代码。我们将这样做以了解令牌生成的工作原理。
- en: 'Run the following command to launch the interactive shell. Make sure you are
    within the `restful01` folder in the terminal, Command Prompt, or Windows Powershell:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以启动交互式 shell。确保你在终端、命令提示符或 Windows Powershell 中的 `restful01` 文件夹内：
- en: '[PRE110]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You will notice that a line that says (InteractiveConsole) is displayed after
    the usual lines that introduce your default Python interactive shell. Enter the
    following code in the Python interactive shell to import all the things we will
    need to retrieve a `User` instance and generate a new token. The code file for
    the sample is included in the `hillar_django_restful_08_02` folder, in the `restful01/tokens_test_01.py`
    file.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在介绍默认 Python 交互式 shell 的常规行之后，会显示一行写着（InteractiveConsole）的文本。在 Python 交互式
    shell 中输入以下代码以导入我们检索 `User` 实例和生成新令牌所需的所有内容。示例代码文件包含在 `hillar_django_restful_08_02`
    文件夹中的 `restful01/tokens_test_01.py` 文件里。
- en: '[PRE111]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Enter the following code to retrieve an instance of the `User` model whose
    username matches "user01" and create a new `Token` instance related to this user.
    The last line prints the value for the `key` attribute for the generated `Token`
    instance saved in the `token` variable. Replace `user01` in the next lines with
    the name you configured for this user. The code file for the sample is included
    in the `hillar_django_restful_08_02` folder, in the `restful01/tokens_test_01.py`
    file:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码以检索用户名为“user01”的`User`模型实例，并创建一个与该用户相关的新`Token`实例。最后一行打印出保存在`token`变量中的生成的`Token`实例的`key`属性值。在下一行中将`user01`替换为您为该用户配置的名称。示例代码文件包含在`hillar_django_restful_08_02`文件夹中的`restful01/tokens_test_01.py`文件中：
- en: '[PRE112]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The following line shows a sample output from the previous code with the string
    value for `token.key`. Copy the output generated when running the code because
    we will use this token to authenticate requests. Notice that the token generated
    in your system will be different:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了使用`token.key`字符串值的上一段代码的示例输出。复制运行代码时生成的输出，因为我们将会使用这个令牌来认证请求。请注意，您系统生成的令牌将不同：
- en: '[PRE113]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Finally, enter the following command to quit the interactive console:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输入以下命令以退出交互式控制台：
- en: '[PRE114]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Now, we have a token for the Django user named `user01`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`user01`的Django用户的令牌。
- en: 'Now, we can launch Django''s development server to compose and send HTTP requests
    to retrieve pilots to understand how the configured token authentication class
    combined with the permission policies work. Execute any of the following two commands
    based on your needs to access the API in other devices or computers connected
    to your LAN. Remember that we analyzed the difference between them in [Chapter
    3](dj-rst-websvc_ch13.html),*Creating API Views*, in the *Launching Django''s
    development server* section:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动Django的开发服务器，以编写和发送HTTP请求来检索飞行员，以了解配置的令牌认证类与权限策略是如何协同工作的。根据您的需求，执行以下两个命令之一以访问连接到您的局域网的其他设备或计算机上的API。请记住，我们在[第3章](dj-rst-websvc_ch13.html)的“启动Django开发服务器”部分中分析了它们之间的区别：
- en: '[PRE115]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行上述任何命令之后，开发服务器将开始监听端口`8000`。
- en: 'We will compose and send an HTTP `GET` request without authentication credentials
    to try to retrieve the first page of the `pilots` collection:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写并发送一个不带认证凭据的HTTP `GET`请求，尝试检索`pilots`集合的第一页：
- en: '[PRE116]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE117]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We will receive an `HTTP 401 Unauthorized` status code in the response header
    and a detail message indicating that we didn''t provide authentication credentials
    in the JSON body. In addition, the value for the `WWW-Authenticate` header specifies
    the authentication method that must be applied to access the resource collection:
    `Token`. The following lines show a sample response:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在响应头中收到`HTTP 401 Unauthorized`状态码和一个详细消息，表明我们没有在JSON体中提供认证凭据。此外，`WWW-Authenticate`头部的值指定了必须应用于访问资源集合的认证方法：`Token`。以下行显示了示例响应：
- en: '[PRE118]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'After the changes we made, if we want to retrieve the collection of pilots,
    that is, to make an HTTP `GET` request to `/pilots/`, we need to provide authentication
    credentials by using the token-based authentication. Now, we will compose and
    send an HTTP request to retrieve the collection of pilots with authentication
    credentials, that is, with the token. Remember to replace `PASTE-TOKEN-HERE` with
    the previously generated token:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做出的更改之后，如果我们想检索飞行员集合，即向`/pilots/`发送HTTP `GET`请求，我们需要使用基于令牌的认证提供认证凭据。现在，我们将编写并发送一个带有认证凭据的HTTP请求来检索飞行员集合，即使用令牌。请记住将`PASTE-TOKEN-HERE`替换为之前生成的令牌：
- en: '[PRE119]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE120]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'As a result of the request, we will receive an `HTTP 200 OK` status code in
    the response header and the first page of the pilots collection serialized to
    JSON in the response body. The following screenshot shows the first lines of a
    sample response for the request with the appropriate token:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 作为请求的结果，我们将在响应头中收到`HTTP 200 OK`状态码，以及序列化为JSON的飞行员集合的第一页在响应体中。以下截图显示了具有适当令牌的请求的示例响应的第一行：
- en: '![](img/7b83974c-e9cd-4f8d-bddd-8f2dc13faea0.png)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b83974c-e9cd-4f8d-bddd-8f2dc13faea0.png)'
- en: The token-based authentication provided with the Django REST framework is very
    simple and it requires customization to make it production ready. Tokens never
    expire and there is no setting to specify the default expiration time for a token.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST 框架提供的基于令牌的认证非常简单，并且需要定制才能使其适用于生产环境。令牌永远不会过期，没有设置可以指定令牌的默认过期时间。
- en: Test your knowledge
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Let's see whether you can answer the following questions correctly.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题。
- en: 'The `permissions.SAFE_METHODS` tuple of string includes the following HTTP
    methods or verbs that are considered safe:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串的 `permissions.SAFE_METHODS` 元组包括以下被认为是安全的 HTTP 方法或动词：
- en: '`''GET''`, `''HEAD''`, and `''OPTIONS''`'
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''GET''`, `''HEAD''`, 和 `''OPTIONS''`'
- en: '`''POST''`, `''PATCH''`, and `''OPTIONS''`'
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''POST''`, `''PATCH''`, 和 `''OPTIONS''`'
- en: '`''GET''`, `''PUT''`, and `''OPTIONS''`'
  id: totrans-568
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''GET''`, `''PUT''`, 和 `''OPTIONS''`'
- en: Which of the following settings key in the `REST_FRAMEWORK` dictionary specifies
    the global setting with a tuple of string whose values indicate the classes that
    we want to use for authentication?
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个设置键在 `REST_FRAMEWORK` 字典中指定了全局设置，该设置是一个字符串值的元组，表示我们想要用于认证的类？
- en: '`''GLOBAL_AUTHENTICATION_CLASSES''`'
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''GLOBAL_AUTHENTICATION_CLASSES''`'
- en: '`''DEFAULT_AUTHENTICATION_CLASSES''`'
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''DEFAULT_AUTHENTICATION_CLASSES''`'
- en: '`''REST_FRAMEWORK_AUTHENTICATION_CLASSES''`'
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''REST_FRAMEWORK_AUTHENTICATION_CLASSES''`'
- en: Which of the following is the model that persists a Django user?
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个模型持久化 Django 用户？
- en: '`Django.contrib.auth.DjangoUser`'
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Django.contrib.auth.DjangoUser`'
- en: '`Django.contrib.auth.User`'
  id: totrans-575
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Django.contrib.auth.User`'
- en: '`Django.rest-framework.User`'
  id: totrans-576
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Django.rest-framework.User`'
- en: Which of the following classes is the base class from which all customized permission
    classes should inherit to work with the Django REST framework?
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个类是所有自定义权限类应该继承以与 Django REST 框架一起工作的基类？
- en: '`Django.contrib.auth.MainPermission`'
  id: totrans-578
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Django.contrib.auth.MainPermission`'
- en: '`rest_framework.permissions.MainPermission`'
  id: totrans-579
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.permissions.MainPermission`'
- en: '`rest_framework.permissions.BasePermission`'
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.permissions.BasePermission`'
- en: In order to configure permission policies for a class-based view, which of the
    following class attributes do we have to override?
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了为基于类的视图配置权限策略，我们必须覆盖以下哪个类属性？
- en: '`permission_classes`'
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`permission_classes`'
- en: '`permission_policies_classes`'
  id: totrans-583
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`permission_policies_classes`'
- en: '`rest_framework_permission_classes`'
  id: totrans-584
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework_permission_classes`'
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案包含在 [附录](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454)，*解决方案*
    中。
- en: Summary
  id: totrans-586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the differences between authentication and permissions
    in Django, the Django REST framework, and RESTful Web Services. We analyzed the
    authentication classes included in the Django REST framework out of the box.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Django、Django REST 框架和 RESTful Web 服务中认证和权限之间的区别。我们分析了 Django REST
    框架中包含的内置认证类。
- en: We followed the necessary steps to include security and permissions-related
    data to models. We worked with object-level permissions via customized permission
    classes and we saved information about users that make requests. We understood
    that there are three HTTP methods or verbs that are considered safe.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了必要的步骤，将安全性和权限相关的数据包含到模型中。我们通过自定义权限类处理对象级权限，并保存有关发起请求的用户的信息。我们了解到有三种 HTTP
    方法或动词被认为是安全的。
- en: We configured permission policies for the class-based views that worked with
    the `Drone` model. Then, we created a superuser and another user for Django to
    compose and send authenticated requests and to understand how the permission policies
    we configured were working.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为与 `Drone` 模型一起工作的基于类的视图配置了权限策略。然后，我们为 Django 创建了一个超级用户和另一个用户，以编写和发送经过身份验证的请求，并了解我们配置的权限策略是如何工作的。
- en: We used command-line tools and GUI tools to compose and send authenticated requests.
    Then, we browsed the secured RESTful Web Service with the browsable API feature.
    Finally, we worked with a simple token-based authentication provided by the Django
    REST framework to understand another way of authenticating requests.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了命令行工具和图形用户界面工具来编写和发送经过身份验证的请求。然后，我们使用可浏览的 API 功能浏览受保护的 RESTful Web 服务。最后，我们使用
    Django REST 框架提供的简单基于令牌的身份验证来了解另一种请求认证的方式。
- en: Now that we have improved our RESTful Web Service with authentication and permission
    policies, it is time to combine these policies with throttling rules and versioning.
    We will cover these topics in the next chapter.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过身份验证和权限策略改进了我们的RESTful Web Service，是时候将这些策略与节流规则和版本控制相结合了。我们将在下一章中介绍这些主题。
- en: Applying Throttling Rules and Versioning Management
  id: totrans-592
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用节流规则和版本控制管理
- en: 'In this chapter, we will work with throttling rules to limit the usage of our
    RESTful Web Service. We don''t want to process requests until our RESTful Web
    Service runs out of resources, and therefore, we will analyze the importance of
    throttling rules. We will take advantage of the features included in the Django
    REST framework to manage different versions of our web service. We will gain an
    understanding of:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用节流规则来限制我们对RESTful Web Service的使用。我们不希望我们的RESTful Web Service资源耗尽之前处理请求，因此，我们将分析节流规则的重要性。我们将利用Django
    REST框架中包含的功能来管理我们Web服务的不同版本。我们将了解：
- en: Understanding the importance of throttling rules
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解节流规则的重要性
- en: Learning the purpose of the different throttling classes in the Django REST
    framework
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Django REST框架中不同节流类的目的
- en: Configuring throttling policies in the Django REST framework
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Django REST框架中配置节流策略
- en: Running tests to check that throttling policies work as expected
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试以检查节流策略是否按预期工作
- en: Understanding versioning classes
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解版本控制类
- en: Configuring the versioning scheme
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置版本控制方案
- en: Running tests to check that versioning works as expected
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试以检查版本控制是否按预期工作
- en: Understanding the importance of throttling rules
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解节流规则的重要性
- en: In [Chapter 8](dj-rst-websvc_ch17.html), *Securing the API with Authentication
    and Permissions*, we made sure that some requests were authenticated before processing
    them. We took advantage of many authentication schemes to identify the user that
    originated the request. Throttling rules also determine whether the request must
    be authorized or not. We will work with them in combination with authentication.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](dj-rst-websvc_ch17.html)，“使用身份验证和权限保护API”，我们确保在处理请求之前对某些请求进行了身份验证。我们利用了许多身份验证方案来识别发起请求的用户。节流规则还决定请求是否需要授权。我们将与它们结合使用身份验证。
- en: So far, we haven't established any limits on the usage of our RESTful Web Service.
    As a result of this configuration, both unauthenticated and authenticated users
    can compose and send as many requests as they want to. The only thing we have
    limited is the resultset size throughout the configuration of the pagination features
    available in the Django REST framework. Hence, large results sets are split into
    individual pages of data. However, a user might compose and send thousands of
    requests to be processed with any kind of limitation. Of course, the servers or
    virtual machines that run our RESTful Web Services or the underlying database
    can be overloaded by the huge amount of requests because we don't have limits.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有对我们的RESTful Web Service的使用设置任何限制。由于这种配置，未经身份验证和已身份验证的用户都可以随意组合并发送尽可能多的请求。我们唯一限制的是Django
    REST框架中可用的分页功能配置过程中的结果集大小。因此，大型结果集被分割成单独的数据页。然而，用户可能会发送成千上万的请求进行处理，而没有任何限制。当然，运行我们的RESTful
    Web Service或底层数据库的服务器或虚拟机可能会因为大量请求而超载，因为我们没有设置限制。
- en: 'Throttles control the rate of requests that users can make to our RESTful Web
    Service. The Django REST framework makes it easy to configure throttling rules.
    We will use throttling rules to configure the following limitations to the usage
    of our RESTful Web Service:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 节流控制用户对我们RESTful Web Service发起请求的速率。Django REST框架使得配置节流规则变得简单。我们将使用节流规则来配置以下对我们RESTful
    Web Service使用的限制：
- en: A maximum of 3 requests per hour for unauthenticated users
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未经身份验证的用户每小时最多3个请求
- en: A maximum of 10 requests per hour for authenticated users
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已身份验证的用户每小时最多10个请求
- en: A maximum of 20 requests per hour for the drones related views
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与相关视图相关的每小时最多20个请求
- en: A maximum of 15 requests per hour for the pilots related views
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与相关视图相关的每小时最多15个请求
- en: Learning the purpose of the different throttling classes in the Django REST
    framework
  id: totrans-609
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Django REST框架中不同节流类的目的
- en: The Django REST framework provides three throttling classes in the `rest_framework.throttling`
    module. All of them are subclasses of the `SimpleRateThrottle` class which inherits
    from the `BaseThrottle` class.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架在`rest_framework.throttling`模块中提供了三个节流类。它们都是`SimpleRateThrottle`类的子类，该类继承自`BaseThrottle`类。
- en: The three classes allow us to specify throttling rules that indicate the maximum
    number of requests in a specific period of time and within a determined scope.
    Each class is responsible for computing and validating the maximum number of requests
    per period. The classes provide different mechanisms to determine the previous
    request information to specify the scope by comparing it with the new request.
    The Django REST framework stores the required data to analyze each throttling
    rule in the cache. Thus, the classes override the inherited `get_cache_key` method
    that determines the scope that will be used for computing and validating.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类允许我们指定节流规则，这些规则指示在特定时间段内和确定范围内允许的最大请求数。每个类负责计算和验证每个周期内的最大请求数。这些类提供不同的机制来确定先前的请求信息，通过将其与新的请求进行比较来指定范围。Django
    REST框架在缓存中存储分析每个节流规则所需的数据。因此，这些类覆盖了继承的`get_cache_key`方法，该方法确定用于计算和验证的范围。
- en: 'The following are the three throttling classes:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为三种节流类别：
- en: '`AnonRateThrottle`: This class limits the rate of requests that an anonymous
    user can make, and therefore, its rules apply to unauthenticated users. The unique
    cache key is the IP address of the incoming request. Hence, all the requests originated
    in the same IP address will accumulate the total number of requests for this IP.'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnonRateThrottle`：此类限制匿名用户可以发起的请求速率，因此，其规则适用于未认证用户。唯一的缓存键是传入请求的IP地址。因此，来自同一IP地址的所有请求将累积该IP的总请求数。'
- en: '`UserRateThrottle`: This class limits the rate of requests that a specific
    user can make and applies to both authenticated and non-authenticated users. Obviously,
    when the requests are authenticated, the authenticated user ID is the unique cache
    key. When the requests are unauthenticated and come from anonymous users, the
    unique cache key is the IP address of the incoming request.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserRateThrottle`：此类限制特定用户可以发起的请求速率，并适用于已认证和未认证的用户。显然，当请求已认证时，认证的用户ID是唯一的缓存键。当请求未认证且来自匿名用户时，唯一的缓存键是传入请求的IP地址。'
- en: '`ScopedRateThrottle`: This class is useful whenever we have to restrict access
    to specific features of our RESTful Web Service with different rates. The class
    uses the value assigned to the `throttle_scope` attribute to limit requests to
    the parts that are identified with the same value.'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScopedRateThrottle`：此类在需要以不同速率限制对RESTful Web Service的特定功能访问时非常有用。该类使用分配给`throttle_scope`属性的值来限制对具有相同值的部分的请求。'
- en: The previous classes are included in the Django REST framework out of the box.
    There are many additional throttling classes provided by many third-party libraries.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的类是Django REST框架自带的。许多第三方库提供了许多额外的节流类。
- en: Make sure you quit the Django's development server. Remember that you just need
    to press *Ctrl* + *C* in the terminal or Command Prompt window in which it is
    running. We will make the necessary changes to combine the different authentication
    mechanisms we set up in the previous chapter with the application of throttling
    rules. Hence, we will add the `AnonRateThrottle` and `UserRateThrottle` classes
    in the global throttling classes list.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您退出Django的开发服务器。请记住，您只需在终端或命令提示符窗口中按*Ctrl* + *C*即可。我们将对之前章节中设置的不同的认证机制进行必要的更改，以应用节流规则。因此，我们将向全局节流类列表中添加`AnonRateThrottle`和`UserRateThrottle`类。
- en: The value for the `DEFAULT_THROTTLE_CLASSES` settings key specifies a global
    setting with a tuple of string whose values indicate the default classes that
    we want to use for throttling rules. We will specify the `AnonRateThrottle` and
    `UserRateThrottle` classes.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_THROTTLE_CLASSES` 设置键的值指定了一个全局设置，它是一个字符串的元组，其值指示我们想要用于节流规则的默认类。我们将指定`AnonRateThrottle`和`UserRateThrottle`类。'
- en: 'The `DEFAULT_THROTTLE_RATES` settings key specifies a dictionary with the default
    throttle rates. The next list specifies the keys, the values that we will assign
    and their meaning:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_THROTTLE_RATES` 设置键指定了一个包含默认节流速率的字典。下一个列表指定了键、我们将分配的值及其含义：'
- en: '`''anon''`: We will specify `''3/hour''` as the value for this key, which means
    we want a maximum of 3 requests per hour for anonymous users. The `AnonRateThrottle`
    class will apply this throttling rule.'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''anon''`: 我们将指定 `''3/hour''` 作为此键的值，这意味着我们希望匿名用户每小时最多有 3 个请求。`AnonRateThrottle`
    类将应用此限制规则。'
- en: '`''user''`: We will specify `''10/hour''` as the value for this key, which
    means we want a maximum of 10 requests per hour for authenticated users. The `UserRateThrottle`
    class will apply this throttling rule.'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''user''`: 我们将指定 `''10/hour''` 作为此键的值，这意味着我们希望认证用户每小时最多有 10 个请求。`UserRateThrottle`
    类将应用此限制规则。'
- en: '`''drones''`: We will specify `''20/hour''` as the value for this key, which
    means we want a maximum of 20 requests per hour for the drones-related views.
    The `ScopedRateThrottle` class will apply this throttling rule.'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''drones''`: 我们将指定 `''20/hour''` 作为此键的值，这意味着我们希望与无人机相关的视图每小时最多有 20 个请求。`ScopedRateThrottle`
    类将应用此限制规则。'
- en: '`''pilots''`: We will specify `''15/hour''` as the value for this key, which
    means we want a maximum of 15 requests per hour for the drones-related views.
    The `ScopedRateThrottle` class will apply this throttling rule.'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''pilots''`: 我们将指定 `''15/hour''` 作为此键的值，这意味着我们希望与无人机相关的视图每小时最多有 15 个请求。`ScopedRateThrottle`
    类将应用此限制规则。'
- en: 'The maximum rate value for each key is a string that specifies the number of
    requests per period with the following format: `''number_of_requests/period''`,
    where `period` can be any of the following:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键的最大速率值是一个字符串，指定了周期内请求的数量，格式如下：`'number_of_requests/period'`，其中 `period` 可以是以下任何一个：
- en: '`d`: day'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`: 天'
- en: '`day`: day'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`day`: 天'
- en: '`h`: hour'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h`: 小时'
- en: '`hour`: hour'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hour`: 小时'
- en: '`m`: minute'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`: 分钟'
- en: '`min`: minute'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`: 分钟'
- en: '`s`: second'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`: 秒'
- en: '`sec`: second'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sec`: 秒'
- en: In this case, we will always work with a maximum number of requests per hour,
    and therefore, the values will use `/hour` after the maximum number of requests.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们将始终处理每小时的最大请求数量，因此，值将在最大请求数量后使用 `/hour`。
- en: 'Open the `restful01/restful01/settings.py` file that declares module-level
    variables that define the configuration of Django for the `restful01` project.
    We will make some changes to this Django settings file. Add the highlighted lines
    to the `REST_FRAMEWORK` dictionary. The following lines show the new declaration
    of the `REST_FRAMEWORK` dictionary. The code file for the sample is included in
    the `hillar_django_restful_09_01` folder in the `restful01/restful01/settings.py`
    file:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 打开声明 Django 项目 `restful01` 配置的模块级变量的 `restful01/restful01/settings.py` 文件。我们将对此
    Django 设置文件进行一些修改。将高亮行添加到 `REST_FRAMEWORK` 字典中。以下行显示了 `REST_FRAMEWORK` 字典的新声明。示例代码文件包含在
    `restful01/restful01/settings.py` 文件中的 `hillar_django_restful_09_01` 文件夹中：
- en: '[PRE121]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: We added values for the `DEFAULT_THROTTLE_CLASSES` and the `DEFAULT_THROTTLE_RATES`
    settings keys to configure the default throttling classes and the desired rates.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `DEFAULT_THROTTLE_CLASSES` 和 `DEFAULT_THROTTLE_RATES` 设置键添加了值，以配置默认限制类和期望的速率。
- en: Configuring throttling policies in the Django REST framework
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Django REST 框架中配置限制策略
- en: 'Now, we will configure throttling policies for the class-based views related
    to drones: `DroneList` and `DroneDetail`. We will override the values for the
    following class attributes for the class-based views:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为与无人机相关的基于类视图（`DroneList` 和 `DroneDetail`）配置限制策略：我们将覆盖以下类属性值：
- en: '`throttle_classes`: This class attribute specifies a tuple with the names of
    the classes that will manage throttling rules for the class. In this case, we
    will specify the `ScopedRateThrottle` class as the only member of the tuple.'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throttle_classes`: 此类属性指定了一个包含将管理类限制规则的类名的元组。在这种情况下，我们将指定 `ScopedRateThrottle`
    类作为元组的唯一成员。'
- en: '`throttle_scope`: This class attribute specifies the throttle scope name that
    the `ScopedRateThrottle` class will use to accumulate the number of requests and
    limit the rate of requests.'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throttle_scope`: 此类属性指定了 `ScopedRateThrottle` 类将使用的限制作用域名称，以累计请求数量并限制请求速率。'
- en: This way, we will make these class-based views work with the `ScopedRateThrottle`
    class and we will configure the throttle scope that this class will consider for
    each of the class based views related to drones.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将使这些基于类的视图与 `ScopedRateThrottle` 类一起工作，并将配置此类将考虑的每个与无人机相关的基于类视图的限制作用域。
- en: 'Open the `restful01/drones/views.py` file and add the following lines after
    the last line that declares the imports, before the declaration of the `DroneCategoryList`
    class:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `restful01/drones/views.py` 文件，在声明导入的最后一行之后、`DroneCategoryList` 类声明之前添加以下行：
- en: '[PRE122]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Replace the code that declares the `DroneDetail` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_09_01`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一 `views.py` 文件中，用以下代码替换声明 `DroneDetail` 类的代码。代码列表中的新行被突出显示。示例的代码文件包含在 `hillar_django_restful_09_01`
    文件夹中，位于 `restful01/drones/views.py` 文件：
- en: '[PRE123]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Replace the code that declares the `DroneList` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_09_01`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一 `views.py` 文件中，用以下代码替换声明 `DroneList` 类的代码。代码列表中的新行被突出显示。示例的代码文件包含在 `hillar_django_restful_09_01`
    文件夹中，位于 `restful01/drones/views.py` 文件：
- en: '[PRE124]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We added the same lines in the two classes. We assigned `'drones'` to the `throttle_scope`
    class attribute and we included `ScopedRateThrottle` in the tuple that defines
    the value for `throttle_classes`. This way, the two class-based views will use
    the settings specified for the `'drones'` scope and the `ScopeRateThrottle` class
    for throttling. We added the `'drones'` key to the `DEFAULT_THROTTLE_RATES` key
    in the `REST_FRAMEWORK` dictionary, and therefore, the `'drones'` scope is configured
    to serve a maximum of 20 requests per hour.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个类中添加了相同的行。我们将 `'drones'` 分配给 `throttle_scope` 类属性，并将 `ScopedRateThrottle`
    包含在定义 `throttle_classes` 值的元组中。这样，两个基于类的视图将使用为 `'drones'` 范围指定的设置和 `ScopeRateThrottle`
    类进行节流。我们在 `REST_FRAMEWORK` 字典中添加了 `'drones'` 键到 `DEFAULT_THROTTLE_RATES` 键，因此
    `'drones'` 范围被配置为每小时最多服务 20 个请求。
- en: 'Now, we will configure throttling policies for the class-based views related
    to pilots: `PilotList` and `PilotDetail`. We will also override the values for
    the `throttle_scope` and `throttle_classes` class attributes.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为与飞行员相关的基于类的视图配置节流策略：`PilotList` 和 `PilotDetail`。我们还将覆盖 `throttle_scope`
    和 `throttle_classes` 类属性的值。
- en: 'Replace the code that declares the `PilotDetail` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_09_01`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一 `views.py` 文件中，用以下代码替换声明 `PilotDetail` 类的代码。代码列表中的新行被突出显示。示例的代码文件包含在 `hillar_django_restful_09_01`
    文件夹中，位于 `restful01/drones/views.py` 文件：
- en: '[PRE125]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Replace the code that declares the `PilotList` class with the following code
    in the same `views.py` file. The new lines are highlighted in the code listing.
    The code file for the sample is included in the `hillar_django_restful_09_01`
    folder, in the `restful01/drones/views.py` file:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一 `views.py` 文件中，用以下代码替换声明 `PilotList` 类的代码。代码列表中的新行被突出显示。示例的代码文件包含在 `hillar_django_restful_09_01`
    文件夹中，位于 `restful01/drones/views.py` 文件：
- en: '[PRE126]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We added the same lines in the two classes. We assigned `'pilots'` to the `throttle_scope`
    class attribute and we included `ScopedRateThrottle` in the tuple that defines
    the value for `throttle_classes`. This way, the two class-based views will use
    the settings specified for the `'pilots'` scope and the `ScopeRateThrottle` class
    for throttling. We added the `'pilots'` key to the `DEFAULT_THROTTLE_RATES` key
    in the `REST_FRAMEWORK` dictionary, and therefore, the `'drones'` scope is configured
    to serve a maximum of 15 requests per hour.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个类中添加了相同的行。我们将 `'pilots'` 分配给 `throttle_scope` 类属性，并将 `ScopedRateThrottle`
    包含在定义 `throttle_classes` 值的元组中。这样，两个基于类的视图将使用为 `'pilots'` 范围指定的设置和 `ScopeRateThrottle`
    类进行节流。我们在 `REST_FRAMEWORK` 字典中添加了 `'pilots'` 键到 `DEFAULT_THROTTLE_RATES` 键，因此
    `'pilots'` 范围被配置为每小时最多服务 15 个请求。
- en: 'All the class-based views we have edited won''t take into account the global
    settings that applied the default classes that we use for throttling: `AnonRateThrottle`
    and `UserRateThrottle`. These class-based views will use the configuration we
    have specified for them.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编辑的所有基于类的视图将不会考虑应用了默认类（我们用于节流的默认类）的全局设置：`AnonRateThrottle` 和 `UserRateThrottle`。这些基于类的视图将使用我们为它们指定的配置。
- en: Running tests to check that throttling policies work as expected
  id: totrans-656
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试以检查节流策略是否按预期工作
- en: Before Django runs the main body of a class-based view, it performs the checks
    for each throttle class specified in the throttle classes settings. In the drones
    and pilots-related views, we wrote code that overrides the default settings.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Django 运行基于类的视图的主体之前，它会对在节流类设置中指定的每个节流类进行检查。在无人机和飞行员相关的视图中，我们编写了覆盖默认设置的代码。
- en: If a single throttle check fails, the code will raise a `Throttled` exception
    and Django won't execute the main body of the view. The cache is responsible for
    storing previous request information for throttling checking.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单个节流检查失败，代码将引发 `Throttled` 异常，Django 不会执行视图的主体。缓存负责存储用于节流检查的先前请求信息。
- en: Now, we can launch Django's development server to compose and send HTTP requests
    to understand how the configured throttling rules, combined with all the previous
    configurations, work. Execute any of the following two commands based on your
    needs to access the API in other devices or computers connected to your LAN. Remember
    that we analyzed the difference between them in [Chapter 3](dj-rst-websvc_ch13.html),*Creating
    API Views*, in the *Launching Django's development server* section.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动 Django 的开发服务器，以编写并发送 HTTP 请求，以了解配置的节流规则与所有之前的配置相结合是如何工作的。根据您的需求执行以下两个命令之一，以访问连接到您的局域网的其他设备或计算机上的
    API。请记住，我们在 *启动 Django 的开发服务器* 部分的 [第 3 章](dj-rst-websvc_ch13.html) *创建 API 视图*
    中分析了它们之间的区别。
- en: '[PRE127]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行任何之前的命令之后，开发服务器将在端口 `8000` 上开始监听。
- en: 'Now, we will compose and send the following HTTP `GET` request without authentication
    credentials to retrieve the first page of the competitions four times:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将四次编写并发送以下不带认证凭据的 HTTP `GET` 请求，以获取比赛的首页：
- en: '[PRE128]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'We can also use the features of the shell in macOS or Linux to run the previous
    command four times with just a single line with a bash shell. The command is compatible
    with a Cygwin terminal in Windows. We must take into account that we will see
    all the results one after the other and we will have to scroll to understand what
    happened with each execution:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 macOS 或 Linux 的 shell 功能，使用 bash shell 在单行中运行之前的命令四次。该命令与 Windows 的
    Cygwin 终端兼容。我们必须考虑到我们将依次看到所有结果，并且我们需要滚动以了解每次执行的情况：
- en: '[PRE129]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The following line allows you to run the command four times with a single line
    in Windows PowerShell:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行允许您在 Windows PowerShell 中使用单行命令运行该命令四次：
- en: '[PRE130]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The following is the equivalent curl command that we must execute four times:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们必须执行四次的等价 curl 命令：
- en: '[PRE131]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The following is the equivalent curl command that is executed four times with
    a single line in a bash shell in a macOS or Linux, or a Cygwin terminal in Windows:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 macOS 或 Linux 的 bash shell 或 Windows 的 Cygwin 终端中，使用单行执行四次等价的 curl 命令：
- en: '[PRE132]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The following is the equivalent curl command that is executed four times with
    a single line in Windows PowerShell:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Windows PowerShell 中执行四次等价的 curl 命令的单行：
- en: '[PRE133]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The Django REST framework won''t process the request number 4\. The `AnonRateThrottle`
    class is configured as one of the default throttle classes and its throttle settings
    specify a maximum of 3 requests per hour. Hence, we will receive an HTTP `429
    Too many requests` status code in the response header and a message indicating
    that the request was throttled and the time in which the server will be able to
    process an additional request. The value for the `Retry-After` key in the response
    header provides the number of seconds that we must wait until the next request:
    `2347`. The following lines show a sample response. Notice that the number of
    seconds might be different in your configuration:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST 框架不会处理第 4 次请求。`AnonRateThrottle` 类被配置为默认节流类之一，其节流设置指定每小时最多 3 个请求。因此，我们将在响应头中收到
    HTTP `429 Too many requests` 状态码，以及一条消息，表明请求已被节流，以及服务器将能够处理额外请求的时间。响应头中的 `Retry-After`
    键的值提供了我们必须等待直到下一次请求的秒数：`2347`。以下行显示了一个示例响应。请注意，秒数可能因您的配置而异：
- en: '[PRE134]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now, we will compose and send the following HTTP `GET` request with authentication
    credentials to retrieve the first page of the competitions four times. We will
    use the superuser we created in the previous chapter. Remember to replace `djangosuper`
    with the name you used for the superuser and `passwordforsuper` with the password
    you configured for this user as shown here:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送以下带有身份验证凭据的 HTTP `GET` 请求，以获取比赛的第一页，共执行四次。我们将使用上一章中创建的超级用户。请记住将 `djangosuper`
    替换为您用于超级用户的名称，将 `passwordforsuper` 替换为您为该用户配置的密码，如下所示：
- en: '[PRE135]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'In a Linux, macOS or a Cygwin terminal, we can run the previous command four
    times with the following single line:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux、macOS 或 Cygwin 终端中，我们可以使用以下单行运行之前的命令四次：
- en: '[PRE136]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The following line allows you to run the command four times with a single line
    in Windows PowerShell.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行允许您在 Windows PowerShell 中使用单行运行该命令四次。
- en: '[PRE137]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The following is the equivalent curl command that we must execute four times:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们必须执行四次的等效 curl 命令：
- en: '[PRE138]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The following is the equivalent curl command that we can execute four times
    in a Linux, macOS or a Cygwin terminal with a single line:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Linux、macOS 或 Cygwin 终端中使用单行执行四次等效 curl 命令：
- en: '[PRE139]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The following is the equivalent curl command that is executed four times with
    a single line in Windows PowerShell:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Windows PowerShell 中使用单行执行四次等效 curl 命令：
- en: '[PRE140]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: In this case, Django will process the request number 4 because we have composed
    and sent 4 authenticated requests with the same user. The `UserRateThrottle` class
    is configured as one of the default throttle classes and its throttle settings
    specify 10 requests per hour. We still have 6 requests before we accumulate the
    maximum number of requests per hour.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Django 将处理第 4 个请求，因为我们已经使用相同的用户编写并发送了 4 个认证请求。`UserRateThrottle` 类被配置为默认限制类之一，其限制设置指定每小时
    10 个请求。在我们累积每小时最大请求数之前，我们还有 6 个请求。
- en: If we compose and send the same request 7 times more, we will accumulate 11
    requests and we will will receive an HTTP `429 Too many requests` status code
    in the response header, a message indicating that the request was throttled and
    the time in which the server will be able to process an additional request after
    the last execution.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再发送相同的请求 7 次，我们将累积 11 个请求，并且会在响应头中收到一个 HTTP `429 Too many requests` 状态码，这是一个表示请求被限制，并且服务器将在最后一次执行后能够处理额外请求的时间的消息。
- en: 'Now, we will compose and send the following HTTP `GET` request without authentication
    credentials to retrieve the first page of the drones collection 20 times:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送以下不带身份验证凭据的 HTTP `GET` 请求，以获取无人机集合的第一页，共执行 20 次：
- en: '[PRE141]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can use the features of the shell in macOS or Linux to run the previous
    command 20 times with just a single line with a bash shell. The command is compatible
    with a Cygwin terminal in Windows:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 macOS 或 Linux 的 shell 功能，使用 bash shell 在单行中运行之前的命令 20 次。该命令与 Windows
    的 Cygwin 终端兼容：
- en: '[PRE142]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The following line allows you to run the command 20 times with a single line
    in Windows PowerShell:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行允许您在 Windows PowerShell 中使用单行运行该命令 20 次：
- en: '[PRE143]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The following is the equivalent curl command that we must execute 20 times:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们必须执行 20 次的等效 curl 命令：
- en: '[PRE144]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The following is the equivalent curl command that is executed 20 times with
    a single line in a bash shell in macOS or Linux, or a Cygwin terminal in Windows:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 macOS 或 Linux 的 bash shell 中，或在 Windows 的 Cygwin 终端中执行 20 次的单行等效 curl 命令：
- en: '[PRE145]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The following is the equivalent curl command that is executed 20 times with
    a single line in Windows PowerShell:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Windows PowerShell 中使用单行执行 20 次等效 curl 命令：
- en: '[PRE146]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The Django REST framework will process the 20 requests. The `DroneList` class
    has its `throttle_scope` class attribute set to `'drones'` and uses the `ScopedRateThrottle`
    class to accumulate the requests in the specified scope. The `'drones'` scope
    is configured to accept a maximum of 20 requests per hour, and therefore, if we
    make another request with the same non-authenticated user and this request accumulates
    in the same scope, the request will be throttled.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST 框架将处理 20 个请求。`DroneList` 类的 `throttle_scope` 类属性设置为 `'drones'`，并使用
    `ScopedRateThrottle` 类在指定的作用域中累积请求。`'drones'` 作用域配置为每小时最多接受 20 个请求，因此，如果我们使用相同的非认证用户发送另一个请求，并且这个请求累积在相同的作用域中，请求将被限制。
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve the details
    for a drone. Make sure you replace `1` for any existing drone ID value that was
    listed in the results for the previous requests:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个 HTTP `GET` 请求来检索无人机的详细信息。确保您将任何现有无人机 ID 值替换为之前请求结果中列出的 `1`：
- en: '[PRE147]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The following is the equivalent curl command:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE148]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The Django REST framework won''t process this request. The request ends up
    routed to the `DroneDetail` class. The `DroneDetail` class has its `throttle_scope`
    class attribute set to `''drones''` and uses the `ScopedRateThrottle` class to
    accumulate the requests in the specified scope. Thus, both the `DroneList` and
    the `DroneDetail` class accumulate in the same scope. The new request from the
    same non-authenticated user becomes the request number 21 for the `''drones''`
    scope that is configured to accept a maximum of 20 requests per hour, and therefore,
    we will receive an HTTP `429 Too many requests` status code in the response header
    and a message indicating that the request was throttled and the time in which
    the server will be able to process an additional request. The value for the `Retry-After`
    key in the response header provides the number of seconds that we must wait until
    the next request: `3138`. The following lines show a sample response. Notice that
    the number of seconds might be different in your configuration:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST 框架不会处理这个请求。请求最终被路由到 `DroneDetail` 类。`DroneDetail` 类的 `throttle_scope`
    类属性设置为 `'drones'`，并使用 `ScopedRateThrottle` 类在指定的范围内累积请求。因此，`DroneList` 和 `DroneDetail`
    类在相同的范围内累积。来自同一非认证用户的新的请求成为 `'drones'` 范围内的第 21 个请求，该范围配置为每小时接受最多 20 个请求，因此，我们将在响应头中收到
    HTTP `429 Too many requests` 状态码和一个消息，表明请求已被限制，以及服务器将能够处理额外请求的时间。响应头中 `Retry-After`
    键的值提供了我们必须等待的秒数：`3138`。以下行显示了示例响应。请注意，秒数可能因您的配置而异：
- en: '[PRE149]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Throttling rules are extremely important to make sure that users don't abuse
    our RESTful Web Service and that we keep control of the resources that are being
    used to process incoming requests. We should never put a RESTful Web Service in
    production without a clear configuration for throttling rules.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 限制规则对于确保用户不会滥用我们的 RESTful 网络服务以及保持对用于处理传入请求的资源控制至关重要。我们绝不应该在没有明确的限制规则配置的情况下将
    RESTful 网络服务投入生产。
- en: Understanding versioning classes
  id: totrans-710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解版本控制类
- en: Sometimes, we have to keep many different versions of a RESTful Web Service
    alive at the same time. For example, we might need to have version 1 and version
    2 of our RESTful Web Service accepting and processing requests. There are many
    versioning schemes that make it possible to serve many versions of a web service.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不得不同时保持许多不同版本的 RESTful 网络服务活跃。例如，我们可能需要让我们的 RESTful 网络服务的第 1 版和第 2 版都能接受和处理请求。有许多版本控制方案使得能够提供多个版本的
    Web 服务成为可能。
- en: The Django REST framework provides five classes in the `rest_framework.versioning`
    module. All of them are subclasses of the `BaseVersioning` class. The five classes
    allow us to work with a specific versioning scheme.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST 框架在 `rest_framework.versioning` 模块中提供了五个类。它们都是 `BaseVersioning`
    类的子类。这五个类允许我们使用特定的版本控制方案。
- en: 'We can use one of these classes in combination with changes in the URL configurations
    and other pieces of code to support the selected versioning scheme. Each class
    is responsible for determining the version based on the implemented schema and
    to make sure that the specified version number is a valid one based on the allowed
    version settings. The classes provide different mechanisms to determine the version
    number. The following are the five versioning classes:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些类之一，结合对 URL 配置和其他代码片段的更改，以支持所选的版本控制方案。每个类都负责根据实现的方案确定版本，并确保指定的版本号基于允许的版本设置是有效的。这些类提供了不同的机制来确定版本号。以下是有五个版本控制类：
- en: '`AcceptHeaderVersioning`: This class configures a versioning scheme that requires
    each request to specify the desired version as an additional value of the media
    type specified as a value for the `Accept` key in the header. For example, if
    a request specifies `''application/json; version=1.2''` as the value for the `Accept`
    key in the header, the `AcceptHeaderVersioning` class will set the `request.version`
    attribute to `''1.2''`. This scheme is known as media type versioning, content
    negotiation versioning or accept header versioning.'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AcceptHeaderVersioning`: 这个类配置了一个版本化方案，要求每个请求将所需的版本作为媒体类型的一个附加值指定为头部中`Accept`键的值。例如，如果请求将`''application/json;
    version=1.2''`指定为头部中`Accept`键的值，`AcceptHeaderVersioning`类将设置`request.version`属性为`''1.2''`。这个方案被称为媒体类型版本化、内容协商版本化或接受头版本化。'
- en: '`HostNameVersioning`: This class configures a versioning scheme that requires
    each request to specify the desired version as a value included in the hostname
    in the URL. For example, if a request specifies `v2.myrestfulservice.com/drones/`
    as the URL, it means that the request wants to work with version number 2 of the
    RESTful Web Service. This scheme is known as hostname versioning or domain versioning.'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostNameVersioning`: 这个类配置了一个版本化方案，要求每个请求在URL中的主机名中指定所需的版本作为值。例如，如果请求指定`v2.myrestfulservice.com/drones/`作为URL，这意味着请求想要与RESTful
    Web服务的第2个版本一起工作。这个方案被称为主机名版本化或域名版本化。'
- en: '`URLPathVersioning`: This class configures a versioning scheme that requires
    each request to specify the desired version as a value included in the URL path.
    For example, if a request specifies `v2/myrestfulservice.com/drones/` as the URL,
    it means that the request wants to work with version number 2 of the RESTful Web
    Service. The class requires us to work with a `version` URL keyword argument.
    This scheme is known as URI versioning or URL path versioning.'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URLPathVersioning`: 这个类配置了一个版本化方案，要求每个请求在URL路径中指定所需的版本作为值。例如，如果请求指定`v2/myrestfulservice.com/drones/`作为URL，这意味着请求想要与RESTful
    Web服务的第2个版本一起工作。这个方案被称为URI版本化或URL路径版本化。'
- en: '`NamespaceVersioning`: This class configures the versioning scheme explained
    for the `URLPathVersioning` class. The only difference compared with this other
    class is that the configuration in the Django REST framework application is different.
    In this case, it is necessary to use URL namespacing.'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NamespaceVersioning`: 这个类配置了与`URLPathVersioning`类中解释的版本化方案。与其他类相比，唯一的区别在于Django
    REST框架应用程序中的配置不同。在这种情况下，使用URL命名空间是必要的。'
- en: '`QueryParameterVersioning`: This class configures a versioning scheme that
    requires each request to specify the desired version as a query parameter. For
    example, if a request specifies `myrestfulservice.com/?version=1.2`, the `QueryParameterVersioning`
    class will set the `request.version` attribute to `''1.2''`. This scheme is known
    as query parameter versioning or request parameter versioning.'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QueryParameterVersioning`: 这个类配置了一个版本化方案，要求每个请求将所需的版本作为查询参数指定。例如，如果请求指定`myrestfulservice.com/?version=1.2`，`QueryParameterVersioning`类将设置`request.version`属性为`''1.2''`。这个方案被称为查询参数版本化或请求参数版本化。'
- en: The previous classes are included in the Django REST framework out of the box.
    It is also possible to code our own customized versioning scheme. Each versioning
    scheme has its advantages and trade-offs. In this case, we will work with the
    `NamespaceVersioning` class to provide a new version of the RESTful Web Service
    with a minor change compared to the first version. However, it is necessary to
    analyze carefully whether you really need to use any versioning scheme. Then,
    you need to figure out which is the most appropriate one based on your specific
    needs. Of course, if possible, we should always avoid any versioning scheme because
    they add complexity to our RESTful Web Service.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的类是Django REST框架自带的。我们也可以编写自己的定制版本化方案。每个版本化方案都有其优势和权衡。在这种情况下，我们将使用`NamespaceVersioning`类来提供一个与第一个版本相比只有微小变化的RESTful
    Web服务的新版本。然而，仔细分析你是否真的需要使用任何版本化方案是必要的。然后，你需要根据你的具体需求确定最合适的一个。当然，如果可能的话，我们应始终避免使用任何版本化方案，因为它们会增加我们的RESTful
    Web服务的复杂性。
- en: Configuring a versioning scheme
  id: totrans-720
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置版本化方案
- en: 'Let''s imagine we have to serve the following two versions of our RESTful Web
    Service:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们必须为以下两个版本的RESTful Web服务提供服务：
- en: '**Version 1**: The version we have developed so far. However, we want to make
    sure that the clients understand that they are working with version 1, and therefore,
    we want to include a reference to the version number in the URL for each HTTP
    request.'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本 1**：我们迄今为止开发的版本。然而，我们想确保客户端明白他们正在使用版本 1，因此，我们希望在每个 HTTP 请求的 URL 中包含版本号的引用。'
- en: '**Version 2**: This version has to allow clients to reference the drones resource
    collection with the `vehicles` name instead of `drones`. In addition, the drone
    categories resource collection must be accessed with the `vehicle-categories`
    name instead of `drone-categories`. We also want to make sure that the clients
    understand that they are working with version 2, and therefore, we want to include
    a reference to the version number in the URL for each HTTP request.'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本 2**：这个版本必须允许客户端使用 `vehicles` 名称而不是 `drones` 来引用无人机资源集合。此外，无人机类别资源集合必须使用
    `vehicle-categories` 名称而不是 `drone-categories` 来访问。我们还想确保客户端明白他们正在使用版本 2，因此，我们希望在每个
    HTTP 请求的 URL 中包含版本号的引用。'
- en: The difference between the second and the first version will be minimal because
    we want to keep the example simple. In this case, we will take advantage of the
    previously explained `NamespaceVersioning` class to configure a `URL path versioning
    scheme.`
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 第二版和第一版之间的差异将是最小的，因为我们希望保持示例简单。在这种情况下，我们将利用之前解释的 `NamespaceVersioning` 类来配置
    `URL 路径版本控制方案`。
- en: Make sure you quit the Django's development server. Remember that you just need
    to press *Ctrl + C* in the terminal or command prompt window in which it is running.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已退出 Django 的开发服务器。请记住，您只需在运行它的终端或命令提示符窗口中按 *Ctrl + C* 即可。
- en: 'We will make the necessary changes to configure the usage of the `NameSpaceVersioning`
    class as the default versioning class for our RESTful Web Service. Open the `restful01/restful01/settings.py`
    file that declares module-level variables that define the configuration of Django
    for the `restful01` project. We will make some changes to this Django settings
    file. Add the highlighted lines to the `REST_FRAMEWORK` dictionary. The following
    lines show the new declaration of the `REST_FRAMEWORK` dictionary. The code file
    for the sample is included in the `hillar_django_restful_09_02` folder in the
    `restful01/restful01/settings.py` file:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对配置 `NameSpaceVersioning` 类作为我们 RESTful Web 服务默认版本控制类的必要更改。打开声明 `restful01`
    项目 Django 配置的模块级变量的 `restful01/restful01/settings.py` 文件。我们将对这个 Django 设置文件进行一些更改。将高亮行添加到
    `REST_FRAMEWORK` 字典中。以下行显示了 `REST_FRAMEWORK` 字典的新声明。示例的代码文件包含在 `restful01/restful01/settings.py`
    文件中的 `hillar_django_restful_09_02` 文件夹中：
- en: '[PRE150]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: We added a value for the `DEFAULT_VERSIONING_CLASS` settings key to configure
    the default versioning class that we want to use. As happened whenever we added
    values for settings keys, the new configuration will be applied to all the views
    as a global setting that we are able to override if necessary in specific classes.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `DEFAULT_VERSIONING_CLASS` 设置键添加了一个值来配置我们想要使用的默认版本控制类。就像我们每次为设置键添加值时一样，新的配置将作为全局设置应用于所有视图，如果需要，我们可以在特定类中覆盖它。
- en: Create a new sub-folder named `v2` within the `restful01/drones` folder (`restful01\drones`
    in Windows). This new folder will be the baseline for the specific code required
    for version 2 of our RESTful Web Service.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `restful01/drones` 文件夹内（Windows 中为 `restful01\drones`）创建一个名为 `v2` 的新子文件夹。这个新文件夹将成为我们
    RESTful Web 服务第二版所需特定代码的基准。
- en: Go to the recently created `restful01/drones/v2` folder and create a new file
    named `views.py`. Write the following code in this new file. The following lines
    show the code for this file that creates the new `ApiRootVersion2` class declared
    as a subclass of the `generics.GenericAPIView` class. The code file for the sample
    is included in the `hillar_django_restful_09_02` folder in the `restful01/drones/v2/views.py`
    file.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 前往最近创建的 `restful01/drones/v2` 文件夹，并创建一个名为 `views.py` 的新文件。在这个新文件中编写以下代码。以下行显示了创建
    `ApiRootVersion2` 类的代码，该类被声明为 `generics.GenericAPIView` 类的子类。示例的代码文件包含在 `restful01/drones/v2/views.py`
    文件中的 `hillar_django_restful_09_02` 文件夹中。
- en: '[PRE151]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The `ApiRootVersion2` class is a subclass of the `rest_framework.generics.GenericAPIView`
    class and declares the `get` method. As we learned in *[Chapter 6](dj-rst-websvc_ch16.html),
    Working with Advanced Relationships and Serialization*, the `GenericAPIView` class
    is the base class for all the generic views we have been working with. We will
    make the Django REST framework use this class instead of the `ApiRoot` class when
    the requests work with version 2.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiRootVersion2` 类是 `rest_framework.generics.GenericAPIView` 类的子类，并声明了 `get`
    方法。正如我们在 *[第 6 章](dj-rst-websvc_ch16.html) 中所学到的，*使用高级关系和序列化*，`GenericAPIView`
    类是我们一直在使用的所有通用视图的基类。当请求与版本 2 一起工作时，我们将使 Django REST 框架使用此类而不是 `ApiRoot` 类。'
- en: The `ApiRootVersion2` class defines the `get` method that returns a `Response`
    object with key/value pairs of strings that provide a descriptive name for the
    view and its URL, generated with the `rest_framework.reverse.reverse` function.
    This URL resolver function returns a fully qualified URL for the view. Whenever
    we call the `reverse` function, we include the `request` value for the `request`
    argument. It is very important to do this in order to make sure that the `NameSpaceVersioning`
    class can work as expected to configure the versioning scheme.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiRootVersion2` 类定义了返回一个包含字符串键/值对的 `Response` 对象的 `get` 方法，这些字符串提供了视图及其 URL
    的描述性名称，该 URL 是使用 `rest_framework.reverse.reverse` 函数生成的。此 URL 解析器函数返回视图的完全限定 URL。每次我们调用
    `reverse` 函数时，我们都会包括 `request` 参数的 `request` 值。这样做非常重要，以确保 `NameSpaceVersioning`
    类可以按预期工作以配置版本化方案。'
- en: In this case, the response defines keys named `'vehicle-categories'` and `'vehicles'`
    instead of the `'drone-cagories'` and `'drones'` keys that are included in the
    `views.py` file, in the `ApiRoot` class that will be used for version 1.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，响应定义了名为 `'vehicle-categories'` 和 `'vehicles'` 的键，而不是在 `views.py` 文件中包含的
    `'drone-cagories'` 和 `'drones'` 键，这些键将用于版本 1 的 `ApiRoot` 类。
- en: Now, go to the recently created `restful01/drones/v2` folder and create a new
    file named `urls.py`. Write the following code in this new file. The following
    lines show the code for this file that declares the `urlpatterns` array. The lines
    that are different compared to the first version are highlighted. The code file
    for the sample is included in the `hillar_django_restful_09_02` folder in the
    `restful01/drones/v2/urls.py` file.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往最近创建的 `restful01/drones/v2` 文件夹，并创建一个名为 `urls.py` 的新文件。在这个新文件中写下以下代码。以下行显示了此文件的
    `urlpatterns` 数组的代码。与第一个版本不同的行被突出显示。示例的代码文件包含在 `hillar_django_restful_09_02` 文件夹中的
    `restful01/drones/v2/urls.py` 文件中。
- en: '[PRE152]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The previous code defines the URL patterns that specify the regular expressions
    that have to be matched in the request to run a specific method for a class-based
    view defined in the original version of the `views.py` file. We want version 2
    to use `vehicle-categories` and `vehicles` instead of `drone-categories` and `drones`.
    However, we won't make changes in the serializer, and therefore, we will only
    change the URL that the clients must use to make requests related to drone categories
    and drones.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了 URL 模式，这些模式指定了请求中必须匹配的正则表达式，以便运行在 `views.py` 文件原始版本中定义的基于类的视图的特定方法。我们希望版本
    2 使用 `vehicle-categories` 和 `vehicles` 而不是 `drone-categories` 和 `drones`。然而，我们不会在序列化器中做任何更改，因此我们只会更改客户端必须使用的
    URL 来进行与无人机类别和无人机相关的请求。
- en: Now, we have to replace the code in the `urls.py` file in the `restful01/restful01`
    folder, specifically, the `restful01/restful01/urls.py` file. The file defines
    the root URL configurations, and therefore, we must include the URL patterns for
    the two versions declared in the `restful01/drones/urls.py` and in the `restful01/drones/v2/urls.py`.
    The following lines show the new code for the `restful01/restful01/urls.py` file.
    The code file for the sample is included in the `hillar_django_restful_09_02`
    folder, in the `restful01/restful01/urls.py` file.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须替换 `restful01/restful01` 文件夹中的 `urls.py` 文件中的代码，特别是 `restful01/restful01/urls.py`
    文件。该文件定义了根 URL 配置，因此我们必须包含在 `restful01/drones/urls.py` 和 `restful01/drones/v2/urls.py`
    中声明的两个版本的 URL 模式。以下行显示了 `restful01/restful01/urls.py` 文件的新代码。示例的代码文件包含在 `hillar_django_restful_09_02`
    文件夹中的 `restful01/restful01/urls.py` 文件中。
- en: '[PRE153]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Whenever a URL starts with `v1/`, the url patterns defined for the previous
    version will be used and the `namespace` will be set to `'v1'`. Whenever a URL
    starts with `v2/`, the url patterns defined for version 2 will be used and the
    namespace will be set to `'v2'`. We want the browsable API to display the log
    in and log out views for the two versions, and therefore, we included the necessary
    code to include the definitions included in `rest_framework.urls` for each of
    the versions, with different namespaces. This way, we will be able to easily test
    the two versions with the browsable API and the configured authentication.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个URL以`v1/`开头时，将使用为先前版本定义的URL模式，并将`namespace`设置为`'v1'`。每当一个URL以`v2/`开头时，将使用为版本2定义的URL模式，并将`namespace`设置为`'v2'`。我们希望可浏览的API显示两个版本的登录和注销视图，因此，我们包含了必要的代码，以包含每个版本中`rest_framework.urls`中包含的定义，并使用不同的命名空间。这样，我们将能够通过可浏览的API和配置的认证轻松测试两个版本。
- en: Running tests to check that versioning works as expected
  id: totrans-741
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试以检查版本控制是否按预期工作
- en: Now, we can launch Django's development server to compose and send HTTP requests
    to understand how the configured versioning scheme works. Execute any of the following
    two commands based on your needs to access the API in other devices or computers
    connected to your LAN. Remember that we analyzed the difference between them in
    [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*, in the *Launching
    Django's development server* section.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动Django的开发服务器来编写并发送HTTP请求，以了解配置的版本控制方案是如何工作的。根据您的需求执行以下两个命令之一，以在其他连接到您的局域网的设备或计算机上访问API。请记住，我们在*启动Django开发服务器*部分的[第3章](dj-rst-websvc_ch13.html)中分析了它们之间的区别。
- en: '[PRE154]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行任何之前的命令后，开发服务器将开始监听端口`8000`。
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve the first page
    of the drone categories by working with the first version of our RESTful Web Service:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过使用我们RESTful Web服务的第一个版本来编写并发送一个HTTP `GET`请求，以检索无人机类别的第一页：
- en: '[PRE155]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The following is the equivalent curl command:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE156]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/v1/drone-categories/`. The request URL starts with `v1/`
    after the domain and the port number (`http://localhost:8000/`), and therefore,
    it will match the `''^v1/''` regular expression and will test the regular expressions
    defined in the `restful01/drones/urls.py` file and will work with a namespace
    equal to `''v1''`. Then, the URL without the version prefix (`''v1/''`) will match
    the `''drone-categories/$''`regular expression and run the `get` method for the
    `views.DroneCategoryList` class-based view.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下HTTP请求：`GET http://localhost:8000/v1/drone-categories/`。请求URL在域名和端口号（`http://localhost:8000/`）之后以`v1/`开头，因此，它将匹配`'^v1/'`正则表达式，并将测试`restful01/drones/urls.py`文件中定义的正则表达式，并将使用等于`'v1'`的命名空间。然后，没有版本前缀的URL（`'v1/'`）将匹配`'drone-categories/$'`正则表达式，并运行`views.DroneCategoryList`类视图的`get`方法。
- en: The `NamespaceVersioning` class makes sure that the rendered URLs include the
    appropriate version prefix in the response. The following lines show a sample
    response for the HTTP request, with the first and only page of drone categories.
    Notice that the URLs for the drones list for each category include the version
    prefix. In addition, the value of the `url` key for each drone category includes
    the version prefix.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '`NamespaceVersioning`类确保渲染的URL在响应中包含适当的版本前缀。以下行显示了一个HTTP请求的示例响应，包括无人机类别的第一页。注意，每个类别的无人机列表的URL都包含版本前缀。此外，每个无人机类别的`url`键的值也包含版本前缀。'
- en: '[PRE157]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Now, we will compose and send an HTTP `GET` request to retrieve the first page
    of the vehicle categories by working with the second version of our RESTful Web
    Service:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过使用我们RESTful Web服务的第二个版本来编写并发送一个HTTP `GET`请求，以检索车辆类别的第一页：
- en: '[PRE158]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The following is the equivalent curl command:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE159]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/v2/vehicle-categories/`. The request URL starts with `v2/`
    after the domain and the port number (`http://localhost:8000/`), and therefore,
    it will match the `''^v2/''` regular expression and will test the regular expressions
    defined in the `restful01/drones/v2/urls.py` file and will work with a namespace
    equal to `''v2''`. Then, the URL without the version prefix (`''v2/''`) will match
    the `''vehicle-categories/$''`regular expression and run the `get` method for
    the `views.DroneCategoryList` class-based view.'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将构造并发送以下 HTTP 请求：`GET http://localhost:8000/v2/vehicle-categories/`。请求
    URL 在域名和端口号（`http://localhost:8000/`）之后以 `v2/` 开头，因此它将匹配 `'^v2/'` 正则表达式，并将测试位于
    `restful01/drones/v2/urls.py` 文件中定义的正则表达式，并使用 `'v2'` 作为命名空间。然后，没有版本前缀的 URL (`'v2/'`)
    将匹配 `'vehicle-categories/$'` 正则表达式，并运行 `views.DroneCategoryList` 类视图的 `get` 方法。
- en: As happened with the previous request, the `NamespaceVersioning` class makes
    sure that the rendered URLs include the appropriate version prefix in the response.
    The following lines show a sample response for the HTTP request, with the first
    and only page of vehicle categories. We haven't made changes to the serializer
    in the new version, and therefore, each category will render a list named `drones`.
    However, the URLs for the drones list for each category include the version prefix
    and they use the appropriate URL with a `vehicle` in the URL instead of a drone.
    In addition, the value of the `url` key for each vehicle category includes the
    version prefix.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个请求发生的情况一样，`NamespaceVersioning` 类确保渲染的 URL 包含适当的版本前缀。以下行显示了 HTTP 请求的示例响应，包含第一页和唯一的车辆类别。我们没有对新的版本中的序列化器进行更改，因此每个类别将渲染一个名为
    `drones` 的列表。然而，每个类别的无人机列表的 URL 包含版本前缀，并且它们使用包含 `vehicle` 的适当 URL 而不是无人机。此外，每个车辆类别的
    `url` 键的值包含版本前缀。
- en: '[PRE160]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Open a web browser and enter `http://localhost:8000/v1`. The browser will compose
    and send a `GET` request to `/v1` with `text/html` as the desired content type
    and the returned HTML web page will be rendered. The request will end up executing
    the `get` method defined in the `ApiRoot` class within the `restful01/drones/views.py`
    file. The following screenshot shows the rendered web page with the resource description:
    Api Root. The Api Root for the first version uses the appropriate URLs for version
    1, and therefore, all the URLs start with `http://localhost:8000/v1/`.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并输入 `http://localhost:8000/v1`。浏览器将构造并发送一个带有 `text/html` 作为期望内容类型的
    `GET` 请求到 `/v1`，返回的 HTML 网页将被渲染。该请求最终将执行位于 `restful01/drones/views.py` 文件中的 `ApiRoot`
    类定义的 `get` 方法。以下截图显示了带有资源描述的渲染网页：Api Root。第一版本的 Api Root 使用了第一版本的适当 URL，因此所有 URL
    都以 `http://localhost:8000/v1/` 开头。
- en: '![](img/b03ca25a-db69-4fe5-a709-08da995e95a0.png)'
  id: totrans-760
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b03ca25a-db69-4fe5-a709-08da995e95a0.png)'
- en: 'Now, go to `http://localhost:8000/v2`. The browser will compose and send a
    `GET` request to `/v2` with `text/html` as the desired content type and the returned
    HTML web page will be rendered. The request will end up executing the `get` method
    defined in the `ApiRootVersion2` class within the `restful01/drones/v2/views.py`
    file. The following screenshot shows the rendered web page with the resource description:
    Api Root Version2\. The Api Root for the first version uses the appropriate URLs
    for version 2, and therefore, all the URLs start with `http://localhost:8000/v2/`.
    You can check the differences with the Api Root rendered for version 1.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往 `http://localhost:8000/v2`。浏览器将构造并发送一个带有 `text/html` 作为期望内容类型的 `GET` 请求到
    `/v2`，返回的 HTML 网页将被渲染。该请求最终将执行位于 `restful01/drones/v2/views.py` 文件中的 `ApiRootVersion2`
    类定义的 `get` 方法。以下截图显示了带有资源描述的渲染网页：Api Root Version2。第一版本的 Api Root 使用了第二版本的适当 URL，因此所有
    URL 都以 `http://localhost:8000/v2/` 开头。您可以检查与第一版本渲染的 Api Root 的差异。
- en: '![](img/2d9c65a1-f6a5-41ea-904e-847a463e6510.png)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d9c65a1-f6a5-41ea-904e-847a463e6510.png)'
- en: 'This new version of the Api Root renders the following hyperlinks:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 Api Root 版本渲染了以下超链接：
- en: '`http://localhost:8000/v2/vehicle-categories/`: The collection of vehicle categories'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/v2/vehicle-categories/`: 车辆类别的集合'
- en: '`http://localhost:8000/v2/vehicles/`: The collection of vehicles'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/v2/vehicles/`: 车辆集合'
- en: '`http://localhost:8000/v2/pilots/`: The collection of pilots'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/v2/pilots/`: 飞行员集合'
- en: '`http://localhost:8000/v2/competitions/`: The collection of competitions'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/v2/competitions/`: 竞赛集合'
- en: We can use all the features provided by the browsable API with the two versions
    we have configured.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们配置的两个版本提供的所有可浏览API功能。
- en: Developing and maintaining multiple versions of a RESTful Web Service is an
    extremely complex task that requires a lot of planning. We must take into account
    the different versioning schemes that the Django REST framework provides out of
    the box to make our job simpler. However, it is always very important to avoid
    making things more complex than necessary. We should keep any versioning scheme
    as simple as possible and we must make sure that we continue to provide RESTful
    Web Services with easily identifiable resources and resource collections in the
    URLs.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和维护多个版本的RESTful Web Service是一项极其复杂的任务，需要大量的规划。我们必须考虑到Django REST框架提供的不同版本方案，以简化我们的工作。然而，始终非常重要，避免使事情比必要的更复杂。我们应该尽可能保持任何版本方案简单，并确保我们继续在URL中提供易于识别的资源及其集合的RESTful
    Web服务。
- en: Test your knowledge
  id: totrans-770
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Let''s see whether you can answer the following questions correctly:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否能正确回答以下问题：
- en: 'The `rest_framework.throttling.UserRateThrottle` class:'
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.throttling.UserRateThrottle`类：'
- en: Limits the rate of requests that a specific user can make and applies to *both
    authenticated and non-authenticated users*
  id: totrans-773
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制特定用户可以发起的请求数量，并适用于*已认证和未认证的用户*
- en: Limits the rate of requests that a specific user can make and applies *only
    to authenticated users*
  id: totrans-774
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制特定用户可以发起的请求数量，并仅适用于*已认证的用户*
- en: Limits the rate of requests that a specific user can make and applies *only
    to non-authenticated users*
  id: totrans-775
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制特定用户可以发起的请求数量，并仅适用于*未认证的用户*
- en: 'Which of the following settings key in the `REST_FRAMEWORK` dictionary specifies
    the global setting with a tuple of string whose values indicate the classes that
    we want to use for throttling rules:'
  id: totrans-776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`REST_FRAMEWORK`字典中，以下哪个设置键指定了全局设置，该设置是一个字符串值的元组，表示我们想要用于速率限制规则的类：
- en: '`''DEFAULT_THROTTLE_CLASSES''`'
  id: totrans-777
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''DEFAULT_THROTTLE_CLASSES''`'
- en: '`''GLOBAL_THROTTLE_CLASSES''`'
  id: totrans-778
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''GLOBAL_THROTTLE_CLASSES''`'
- en: '`''REST_FRAMEWORK_THROTTLE_CLASSES''`'
  id: totrans-779
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''REST_FRAMEWORK_THROTTLE_CLASSES''`'
- en: 'Which of the following settings key in the `REST_FRAMEWORK` dictionary specifies
    a dictionary with the default throttle rates:'
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`REST_FRAMEWORK`字典中，以下哪个设置键指定了一个包含默认速率限制的字典：
- en: '`''GLOBAL_THROTTLE_RATES''`'
  id: totrans-781
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''GLOBAL_THROTTLE_RATES''`'
- en: '`''DEFAULT_THROTTLE_RATES''`'
  id: totrans-782
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''DEFAULT_THROTTLE_RATES''`'
- en: '`''REST_FRAMEWORK_THROTTLE_RATES''`'
  id: totrans-783
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''REST_FRAMEWORK_THROTTLE_RATES''`'
- en: 'The `rest_framework.throttling.ScopedRateThrottle` class:'
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.throttling.ScopedRateThrottle`类：'
- en: Limits the rate of requests that an anonymous user can make
  id: totrans-785
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制匿名用户可以发起的请求数量
- en: Limits the rate of requests that a specific user can make
  id: totrans-786
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制特定用户可以发起的请求数量
- en: Limits the rate of requests for specific parts of the RESTful Web Service identified
    with the value assigned to the `throttle_scope` property
  id: totrans-787
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制与`throttle_scope`属性分配的值标识的RESTful Web Service特定部分的请求数量
- en: 'The `rest_framework.versioning.NamespaceVersioning` class configures a versioning
    scheme known as:'
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.versioning.NamespaceVersioning`类配置了一个称为的版本方案：'
- en: Query parameter versioning or request parameter versioning
  id: totrans-789
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询参数版本或请求参数版本
- en: Media type versioning, content negotiation versioning or accept header versioning
  id: totrans-790
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 媒体类型版本、内容协商版本或接受头版本
- en: URI versioning or URL path versioning
  id: totrans-791
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: URI版本或URL路径版本
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案包含在[附录](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454)，*解决方案*中。
- en: Summary
  id: totrans-793
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood the importance of throttling rules and how we
    can combine them with authentication and permissions in Django, the Django REST
    framework and RESTful Web Services. We analyzed the throttling classes included
    in the Django REST framework out of the box.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了速率限制规则的重要性以及我们如何将它们与Django、Django REST框架和RESTful Web服务的身份验证和权限相结合。我们分析了Django
    REST框架中包含的速率限制类。
- en: We followed the necessary steps to configure many throttling policies in the
    Django REST framework. We worked with global and scope-related settings. Then,
    we used command-line tools to compose and send many requests to test how the throttling
    rules worked.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了必要的步骤在Django REST框架中配置了许多速率限制策略。我们处理了全局和范围相关的设置。然后，我们使用命令行工具组合并发送了许多请求来测试速率限制规则的工作情况。
- en: We understood versioning classes and we configured a URL path versioning scheme
    to allow us to work with two versions of our RESTful Web Service. We used command-line
    tools and the browsable API to understand the differences between the two versions.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解了版本控制类，并配置了一个URL路径版本控制方案，以便我们能够处理我们RESTful Web服务的两个版本。我们使用了命令行工具和可浏览的API来了解这两个版本之间的差异。
- en: Now that we can combine throttling rules, authentication and permission policies
    with versioning schemes, it is time to explore other features offered by the Django
    REST framework and third-party packages to improve our RESTful Web Service and
    automate tests. We will cover these topics in the next chapter.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够将节流规则、身份验证和权限策略与版本控制方案相结合，是时候探索Django REST框架和第三方包提供的其他功能，以改进我们的RESTful
    Web服务并自动化测试。我们将在下一章中介绍这些主题。
