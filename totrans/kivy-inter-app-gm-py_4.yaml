- en: Chapter 4. Improving the User Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter presents an overview of useful components that Kivy provides to
    make the programmer''s life easier when it is time to improve the user experience.
    Some Kivy components reviewed in this chapter are related to widgets that include
    very particular functionalities (for example, a color palette); in this case,
    you will learn the basic techniques to control them. Other widgets will help us
    expand the use of the canvas, for example, changing the color, rotating and scaling
    shapes, or handling gestures. Finally, we will quickly improve the look and feel
    of the application with a few tips. All the sections are intended to increase
    the usability of the application and are self-contained. The following is the
    list of topics we will review in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Switching between different screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Kivy palette widget to select colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the visible area of the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating and scaling with multi-touch gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating single gestures to draw on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the design with a few global changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More importantly, we will discuss how to incorporate these topics into a current
    working project. This will reinforce your previously acquired knowledge and explore
    a new programming situation in which we need to add functionality to an existent
    code. At the end of this chapter, you should feel comfortable with exploring all
    the different widgets that the Kivy API offers, and quickly understand how to
    integrate them into your code.
  prefs: []
  type: TYPE_NORMAL
- en: ScreenManager – selecting colors for the figures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **`ScreenManager`** class lets us handle different screens in the same window.
    In Kivy, screens are preferred over windows, because we are programming for different
    devices with different screen sizes. Therefore, it is difficult (if not impossible)
    to have windows that adapt properly to all devices. Just imagine yourself juggling
    windows with your fingers on your mobile phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, all our figures have been of the same color. Let''s allow the user
    to add some color to make the *Comic Creator* more versatile. Kivy provides us
    with a `Widget` called **`ColorPicker`**, which is displayed in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ScreenManager – selecting colors for the figures](img/B04244_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this `Widget` requires a wide space, so it would be difficult
    to accommodate it in our current interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a bug in Kivy 1.9.0 that prevents `ColorPicker` from working in Python
    3 (it is already fixed in the development version 1.9.1-dev, which is available
    at [https://github.com/kivy/kivy/](https://github.com/kivy/kivy/)). You can use
    Python 2, or there is an alternative code for Python 3 included in the code that
    you can download from the Packt Publishing website. Instead of the `ColorPicker`,
    there is a widget based on `GridLayout` to select a few colors. The concepts that
    we will discuss in this section are also reflected in that code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **`ScreenManager`** class allows us to have multiple screens instead of
    just one `Widget` (`ComicCreator`), and also lets us switch easily between the
    screens. Here is a new Kivy file (`comicscreenmanager.kv`) that contains the `ComicScreenManager`
    class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We embedded the `ColorPicker` instance inside a **`Screen`** widget (line 7),
    instead of adding it directly to the `ComicScreenManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **`ScreenManager`** instance must contain widgets of the **`Screen`** base
    class. No other types of `Widget` (label, button, or layouts) are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have also added our `ComicCreator` to `ScreenManager` (line 6), we
    need to make sure that our `ComicCreator` inherits from the `Screen` class in
    the `comiccreator.kv` file, so we need to change the file header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The **`name`** property (line 20) is used to identify the screen with an ID,
    in this case `comicscreen`, and it is used to change between the screens of `ScreenManeger`
    through its **`current`** property. For example, the `Button` instance that we
    added to `ColorPicker` (line 12), uses the `name` property to change the `current`
    screen in the `on_press` event (line 17). The `root` refers to the `ScreenManager`
    class and the **`current`** property tells it what the active `Screen` is. In
    this case `comicscreen`, the name we assigned to identify the `ComicCreator` instance.
    Notice that we add the Python code directly (line 17) instead of calling a method
    as we did in [Chapter 3](ch03.html "Chapter 3. Widget Events – Binding Actions"),
    *Widget Events – Binding Actions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also gave a name (`colorscreen`) to the screen that contains the `ColorPicker`
    instance. We will use this name to activate `ColorPicker` with the **Color** button
    in the *general options* area. We need to modify the `color` method of `generaloptions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **Color** button now switches the screen in order to display the `ColorPicker`
    instance. Notice the way we access `ScreenManager` (line 23). First, we use the
    `comic_creator` reference in the `GeneralOptions` class to access the `ComicCreator`
    instance. Second, we use the **`manager`** attribute of `Screen` to access its
    corresponding `ScreenManager`. Finally, we change `current` `Screen`, analogous
    to line 17.
  prefs: []
  type: TYPE_NORMAL
- en: '`ComicScreenManager` now becomes the main `Widget` of the `ComicCreator` project
    so the `comicreator.py` file has to change accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since we changed the name of the app to `ComicScreenManagerApp` (line 44), we
    explicitly load the `comiccreator.kv` file (line 34). Remember that the `comicscreenmanager.kv`
    file is going to be called automatically since the name of the app is now `ComicScreenManagerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: One last interesting thing about the `ScreenManager` is that we can use **transitions**.
    Just as an example, the lines 2 and 4 import and use a simple **`FadeTransition`**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kivy provides a set of transitions (**`FadeTransition`**, **`SwapTransition`**,
    **`SlideTransition`**, and **`WipeTransition`**) to switch between the `Screen`
    instances of `ScreenManager`. Check the Kivy API for more information on how to
    customize them with different parameters at [http://kivy.org/docs/api-kivy.uix.screenmanager.html](http://kivy.org/docs/api-kivy.uix.screenmanager.html)
  prefs: []
  type: TYPE_NORMAL
- en: After these changes, we can switch between the two screens, `ColorPicker` and
    `ComicCreator`, by clicking on the `Color` button of *general options*, or the
    `Select` button of `ColorPicker`. We also set a different color in the `ColorPicker`
    instance with the **`color`** property (line 11); however, the selection of the
    color still has no effect on the drawing process. The next section covers how
    to set the selected color to the figures we draw.
  prefs: []
  type: TYPE_NORMAL
- en: Color control on the canvas – coloring figures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section focused on the selection of colors from a canvas but this
    selection didn't really have an effect yet. In this section, we will actually
    use the selected color. Assigning a color can be tricky if we are not careful.
    If you recall, in [Chapter 3](ch03.html "Chapter 3. Widget Events – Binding Actions"),
    *Widget Events – Binding Actions*, `Color` is a context instruction that we must
    add to the canvas. Moreover, we have to be sure that we add the instruction before
    we draw the actual figure. Basically, selecting a color is similar to picking
    a crayon color to draw on a piece of paper. Until you change the crayon, you will
    continue drawing with its color.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the color of the context changes, it stays in that state until some other
    instruction modifies it explicitly. In [Chapter 2](ch02.html "Chapter 2. Graphics
    – the Canvas"), *Graphics – the Canvas*, we use `PushMatrix` and `PopMatrix` for
    a similar problem but they only apply to transformation instructions (`Translate`,
    `Rotate`, and `Scale`) because they relate to the coordinate space (that explains
    the matrix part of the instructions names: `PushMatrix` and `PopMatrix`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s study a small example (from the *Comic Creator* project) to understand
    this concept better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we use the **`load_string`** method of the **`Builder`** class instead
    of using the **`load_file`** method. This method allows us to embed Kivy language
    statements inside a Python code file.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the properties of `Label` is called `color`; it changes the color of
    the `Label` text. We change `color` to gray (line 54) in the first `Label` but
    it doesn''t clean the context. Observe the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color control on the canvas – coloring figures](img/B04244_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The rectangle of `Label` (line 56), but also the rectangle of `Widget` (Line
    61) have both changed color. Kivy tries to keep all its components as simple as
    possible to avoid unnecessary instructions. We will follow this approach for the
    colors, so we won't worry about the color until we need to use it. Any other components
    can take care of their own color.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now implement the changes in the *Comic Creator*. There are only three
    methods where we draw in the *drawing space* (all of them are in the `toolbox.py`
    file). Here are those methods with the corresponding new lines highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `draw` method in the `ToolStickman` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `draw` method in the `ToolFigure` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `widgetize` method in the `ToolFigure` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All three methods have a pair of specific instructions in common; you can find
    them in lines 75 and 76, 81 and 82, and 92 and 93\. These are reference chains
    to get access to the `ColorPicker` instance. After this, we just add a `Color`
    instruction to the canvas (as we learned in [Chapter 2](ch02.html "Chapter 2. Graphics
    – the Canvas"), *Graphics – the Canvas*) using the selected `color` in `color_picker`
    (lines 77, 84, and 94).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The "splat" operator (`*`) on lines 77, 84, and 94 is used in Python to unpack
    argument lists. In this case, the `Color` constructor is meant to receive three
    parameters with the red, green, and blue values, but we have a list stored in
    **`color_picker.color`**, for example, (`1,0,1`), so we need to unpack it to get
    three separated values `1,0,1`.
  prefs: []
  type: TYPE_NORMAL
- en: We also use `canvas.before` in the `draw` method of the `ToolStickman` class
    (line 77). This is used to ensure that the `Color` instruction is executed before
    the instructions we added in `canvas` of `Stickman` (the `comicwidgets.kv` file).
    This is not necessary in the other two methods because we have full control of
    the canvas order inside those methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must import the `Color` class in the header of the file `from kivy.graphics
    import Line, Color`. We can now take a break and enjoy the result of our hard
    work with our *Comic Creator*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color control on the canvas – coloring figures](img/B04244_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At a later point in time, we can discuss whether our drawing is just an avid
    *Comic Creator* fan or a narcissistic alien with an oversized t-shirt. For now,
    it seems more useful to learn how to limit the *drawing space* to the specific
    area that occupies the window.
  prefs: []
  type: TYPE_NORMAL
- en: StencilView – limiting the drawing space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Widget Events – Binding Actions"), *Widget
    Events – Binding Actions*, we avoided drawing outside of the *drawing space* by
    using simple mathematics and `collide_points`. It was far from perfect (for example,
    it fails in the group mode or when we resize it), and it was tedious and prone
    to programming mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was sufficient for a first example, however, **`StencilView`** is the
    easier way to go here. **`StencilView`** limits the drawing area to the space
    occupied by itself. Anything drawn outside that area is hidden. First, let''s
    modify the file `drawingspace.py` with the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`The` `DrawingSpace` instance inherits now from `StencilView`, instead of `RelativeLayout`.
    The `StencilView` class doesn''t use relative coordinates (as the `RelativeLayout`
    class does) but we would like to keep relative coordinates in the *drawing space*
    because they are convenient for drawing purposes. In order to do this, we can
    modify the top-right `AnchorLayout`, so the `DrawingSpace` instance is inside
    a `RelativeLayout` instance. We do this in the `comiccreator.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we embed the `DrawingSpace` instance (line 109) inside a `RelativeLayout`
    instance (line 105) of the same size (by default, the `DrawingSpace` instance
    uses `size_hint: 1, 1` occupying all the area of the `RelativeLayout` parent),
    then the coordinates inside the `DrawingSpace` instance are relative to the `RelativeLayout`
    instance. Since they are of the same size, then the coordinates are also relative
    to the `DrawingSpace` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We kept the `DrawingSpace` ID (line 110) and attributes (lines 111 to 113).
    Since we have a new level of indentation and the `DrawingSpace` class is not relative
    itself, this affects the way we localize the coordinates in the `ToolBox` instance,
    specifically, in `on_touch_down` of the `ToolButton` class, and `update_figure`
    and `end_figure` of the `ToolFigure` class. The following is the new code for
    `on_touch_down` of the `ToolButton` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We receive absolute coordinates in this method since we are inside `ToolButton`,
    which doesn't belong to any `RelativeLayout` instance. The *drawing space* also
    receives absolute coordinates, but it will interpret them inside the context of
    the `RelativeLayout` instance that it is embedded in. The right approach for the
    `DrawingSpace` instance is to ask its `RelativeLayout` parent who will collide
    the coordinates (received in the `ToolButton`) correctly (line 116)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the new code of `update_figure` and `end_figure` of the `ToolFigure`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We removed some instructions because we no longer need them. First off, we don't
    need to use the `to_widget` method anymore in either of the two methods, since
    we are already getting the coordinates from the `RelativeLayout` parent. And secondly,
    we don't need to worry about applying the `collide_point` method in the `update_figure`
    method because `StencilView` will be in charge of it; any drawing that takes place
    outside the bounds is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: With just a few changes, we ensured that nothing will be drawn outside of the
    *drawing space*, and, with that guarantee, we can now proceed to discuss how to
    drag, rotate, and scale the figures.
  prefs: []
  type: TYPE_NORMAL
- en: Scatter – multi-touching to drag, rotate, and scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter ([Chapter 3](ch03.html "Chapter 3. Widget Events –
    Binding Actions"), *Widget Events – Binding Actions*), you learned how to use
    events to drag widgets. You learned how to use the `on_touch_up`, `on_touch_move`,
    and `on_touch_down` events. However, the **`Scatter`** class already provides
    that functionality and also lets us scale and rotate using two fingers, as one
    would on a mobile or tablet screen. All the functionality is included inside the
    **`Scatter`** class; however, we need to apply a few changes to keep our project
    consistent. In particular, we still want our *group mode* to work, so that translating,
    scaling, and rotating can happen at the same time. Let us implement the changes
    in four big steps in the `comicwidgets.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `DraggableWidget` base class. Let''s use `Scatter` instead of `RelativeLayout`
    (line `132` and `135`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Both `Scatter` and `RelativeLayout` use relative coordinates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure that the `on_touch_down` event of `DraggableWidget` is sent to the
    base class (`Scatter`) by calling the `super` method (line `140`) before `return
    True` (line `141`) inside the condition. If you don''t do that, the `Scatter`
    base class will never receive the event `on_touch_down` and nothing will happen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `super` method is useful for the base class (`Scatter`) and the `return`
    statement is useful for the parent (`DrawingSpace`)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remove the `on_touch_move` method and add an `on_pos` method, which is called
    when the `pos` property is modified. Since `Scatter` will be responsible for dragging,
    we don''t need `on_touch_move` anymore. Instead, we will use the `pos` property
    that is modified by `Scatter`. Remember that the properties trigger an event that
    will call on the `on_pos` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Scatter has two other properties: `rotation` and `scale`. We can use the same
    idea as with `pos` and `on_pos`, and add the `on_rotation` and `on_scale` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `on_rotation` and `on_scale` methods modify a couple of new properties
    (lines 152 and 157) that we need to add to the `GeneralOptions` class. This will
    help us to keep the group mode working. The following code is the new header of
    `generaloptions.py` that includes the new properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We import `NumericProperty` along with `ListProperty` (line 160); and we create
    the two missing properties: `rotation` and `scale` (lines 165 and 166). We also
    need to add the `on_rotation` (line 167) and `on_scale` (line 172) methods (associated
    with the `rotation` and `scale` properties), which will ensure that all the `selected`
    components are rotated or scaled at once, by traversing the list of children that
    have been added to the *drawing space* (line 173 and 177):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A final modification is necessary. We need to change the `on_translation` method
    to check that the current `child` in the loop is not the one being touched (if
    this happens, call the police!), because this could cause an infinitive recursion
    since we modify the properties that call on this event in the first place. Here
    is the new `on_translation` method in the `generaloptions.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we are able to translate, rotate, or scale the figures with our
    fingers, even in the *group mode*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kivy provides a way to simulate multi-touch with the mouse. It is limited but
    you can still test this section with your one-mouse laptop. All you have to do
    is right-click on the figure you want to rotate. A translucent red circle will
    appear on the screen. Then, you can use the normal left dragging as if it were
    a second finger to rotate or scale. To clear the simulated multi-touch, you left-click
    on the red icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot cut shows our `StickMan` being rotated and scaled at the
    same time as the line next to him. The small `StickMan` on the right is just a
    reference to compare against the original size. The simulated multi-touch gesture
    is being applied to the line on the right and that is why you can see a red (gray
    in the printed version) dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scatter – multi-touching to drag, rotate, and scale](img/B04244_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 1](ch01.html "Chapter 1. GUI Basics – Building an Interface"), *GUI
    Basics – Building an Interface*, we briefly mention **`ScatterLayout`** but now
    the difference between **`ScatterLayout`** and **`Scatter`** may be clear.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**`ScatterLayout`** is a Kivy layout that inherits from `Scatter` and contains
    `FloatLayout`. This allows you to use the `size_hint` and `pos_hint` properties
    when you add widgets inside it. `ScatterLayout` also uses relative coordinates.
    This doesn''t mean you cannot add other widgets inside a simple `Scatter`; it
    just means that `Scatter` doesn''t honor `size_hint` or `pos_hint`.'
  prefs: []
  type: TYPE_NORMAL
- en: With the use of `Scatter`, we are able to drag, rotate, and scale our figures.
    This is a great improvement of functionality in our *Comic Creator*. Let's now
    increase the interaction with the user even more, learn how to create our own
    gestures, and use them inside our project.
  prefs: []
  type: TYPE_NORMAL
- en: Recording gestures – line, circle, and cross
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What about drawing with one finger? Can we recognize gestures? It is possible
    to do this with Kivy. First, we need to record the gestures that we want to use.
    A gesture is represented as a long string that contains the points of a stroke
    over the screen. The following code uses the Kivy `Gesture` and `GestureDatabase`
    classes to record gesture strokes. It can be run with Python `gesturerecorder.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code prints the gesture string representations using the **`Gesture`**
    and **`GestureDatabase`** classes (line 184). The `on_touch_down`, `on_touch_move`,
    and `on_touch_up` methods collect `points` of the stroke lines 189, 195, and 199\.
    The following screenshots are examples of strokes collected with `gesturerecorded.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording gestures – line, circle, and cross](img/B04244_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The small `Circle` in the preceding figures (lines 190 and 191) indicates the
    starting point, and the line indicates the path that the stroke follows. The most
    relevant part is coded in lines 200 to 204\. We create `Gesture` (line 200), add
    `points` for the stroke with the **`add_stroke`** method (line 201), **`normalize`**
    to a default number of points (line 202), and create a `GestureDatabase` instance
    (line 203) that we use in line 204 to generate the string (**`gesture_to_str`**)
    and print it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the terminal output for the stroke line (corresponding
    to the first figure on the left in the preceding figures set):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording gestures – line, circle, and cross](img/B04244_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, the long string starting with `'eNq1Vktu…'` is
    the gesture serialization. We use these long strings as descriptors of the gestures
    that Kivy understands and uses to associate the stroke with any action we want
    to perform. The next section explains how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing gestures – drawing with the finger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section explained how to obtain string representations from gestures.
    The current section explains how to use those string representations to recognize
    the gestures. Kivy has some tolerance error in the gesture recognition, so you
    don't have to worry about repeating exactly the same stroke.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we copied the strings that were generated from the strokes in the
    previous section into a new file called `gestures.py`. The strings are assigned
    to different variables. The following code corresponds to `gestures.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Only the first few characters of the strings are shown in the previous code
    but you can download the complete file from the Packt Publishing website, or use
    the previous section to generate your own strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will use these strings in the `drawingspace.py` file. Let''s start
    importing the necessary classes in the header first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we import the `Gesture` and `GestureDatabase` classes
    (line 218) along with the gesture string representations added to `gestures.py`
    (lines 219). We added several methods to the `DrawingSpace` class. Let''s quickly
    review each of the methods, and, at the end, highlight the key parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__`: This method creates the attributes of the class and fills `GestureDatabase`
    using **`str_to_gesture`** in order to transform the strings into gestures, and
    **`add_gesture`** to add the gestures to the database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`activate` and `deactivate`: These methods bind or unbind the methods to the
    touch events in order to start the gesture recognition mode. These methods are
    called by the gesture `Button` of the *general options*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`down`, `move` and `ups`: These methods record the points of the stroke in
    a very similar way that the previous section did:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`gesturize`: This method creates a `Gesture` instance from the collected points
    in the previous methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`min_and_max`: This method keeps track of the extreme points of the stroke:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Discriminate`: This method calls the corresponding method according to the
    recognized gesture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`add_circle`, `add_Line`, `add_stickman`: These methods use the corresponding
    `ToolButton` of `ToolBox` to add a figure according to the recognized gesture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`on_children`: This method keeps the counter of the *Status Bar* updated:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DrawingSpace` class is now in charge of capturing strokes on the screen,
    search for them in the gesture database (that contains the gestures of the last
    section), and draw a shape accordingly. It also offers the possibility of activating
    and deactivating the gesture recognition. Let's cover this in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create the `GestureDatabase` instance (line 224) and use it
    to create the gestures from the strings (lines 225 to 227). We rotate the `line45`
    gesture by 90 degrees (lines 228 to 230) four times with the **`rotate`** method,
    so the `GestureDatabase` instance recognizes the line gesture in different directions.
    Then, we load `GestureDatabase` with the generated gestures (lines 231 to 236).
    We added all of these instructions in the constructor of the class, the `__init__`
    method (lines 222 to 236), so the `DrawingSpace` class has all the elements to
    recognize gestures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we need to capture the gesture stroke. In order to do this, we use
    the touch events. We have created the methods associated with them: `down` (line
    248), `move` (line 255), and `up` (line 261). These methods are similar to the
    `on_touch_down`, `on_touch_move`, and `on_touch_up` methods of the last section
    in the sense that they register the points of the stroke. However, they also keep
    track of the *extreme* axes of the stroke to define a bounding box for the stroke
    as the following figure illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recognizing gestures – drawing with the finger](img/B04244_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These points are used to define the size of the shape we will draw. The `up`
    method, firstly, uses the registered points to create a `Gesture` instance (line
    265), secondly, makes the query to the `GestureDatabase` instance using the **`find`**
    method (line 266), and thirdly, calls the `discriminate` method to draw the appropriate
    shape (line 280). The **`minscore`** parameter of the **`find`** method (line
    266) is used to indicate the precision of the search.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use a low level (`0.50`) since we know that the strokes are very different,
    and that a mistake in this application can be easily undone.
  prefs: []
  type: TYPE_NORMAL
- en: Third, we implement the `discriminate` method (line 280) to discriminate the
    `recognized` variable from among the three possible shapes of our *tool box*.
    The recognized variable (returned by the **`find`** method of `GestureDatabase`)
    is a pair, where the first element is the score of the recognition, and the second
    element is the actual recognized gesture. We use the second value (`recognized[1]`)
    for the discrimination process (line 281) and then call the corresponding method
    (`add_stickman`, `add_line`, and `add_circle`). In the case of lines, it also
    decides the order in which to send the coordinates to match the direction.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, the `activate` and `deactivate` methods provide an interface in order
    to activate or deactivate the *gesture mode* (the application mode in which we
    can use gestures). To activate the mode, the `activate` method binds the `on_touch_up`,
    `on_touch_move`, and `on_tourch_down` events to the corresponding `up`, `move`,
    and `down` methods. It also uses the **`disabled`** property (lines 238) to disable
    the *tool box* widget when the gesture mode is on. The `deactivate` method unbinds
    the events and restores the **`disabled`** property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We applied the **`disabled`** property to the entire `ToolBox` instance, but
    it automatically looks for the children that belong to it and deactivates them
    as well. Basically, the event is never sent to the children.
  prefs: []
  type: TYPE_NORMAL
- en: 'The gestures mode is activated and deactivated from the general options buttons
    with the gestures `ToggleButton`. We need to change the definition of the `gestures`
    method in the `generaloptions.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When **`gestures`** `ToggleButton` is `down`, then the *gesture mode* is activated;
    otherwise, the normal functionality of the *tool box* operates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next lesson, we will learn how to enhance the functionality of our widgets
    using behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors – enhancing widget's functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**`Behaviors`** were introduced recently in the Kivy version 1.8.0, and allow
    us to increase the functionality and flexibility of the existing widgets. Basically,
    they let us inject classic behaviors of certain widgets into other behaviors.
    For example, we can use **`ButtonBehavior`** in order to add the `on_press` and
    `on_release` functionality to a `Label` or `Image` widget. Currently, there are
    three types of behavior (**`ButtonBehavior`**, **`ToggleButtonBehavior`**, and
    **`DragBehavior`**) and more will be coming in the next Kivy releases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some credits to our application. We want to add some functionality
    to the *Status Bar* so that when we click, a **`Popup`** will appear and show
    some text. First, we will import the necessary components into the `statusbar.py`
    header, and also change the class definition of `StatusBar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we have added the **`ButtonBehavior`**, **`Popup`**,
    and **`Label`** class (lines 316 and 318). Moreover, we made `StatusBar` inherit
    from both `ButtonBehavior` and `BoxLayout` at the same time with Python''s multiple
    inheritance. We can add behaviors to any type of widget, and remember from [Chapter
    1](ch01.html "Chapter 1. GUI Basics – Building an Interface"), *GUI Basics – Building
    an Interface*, that layouts are also widgets. We take advantage of the **`ButtonBehavior`**
    that **`StatusBar`** is inheriting from, in order to use the **`on_press`** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We override the **`on_press`** method to display a **`Popup`** window on the
    screen with the credits of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that behaviors don't change the appearance of the widget; only the functionality
    that is most often related to processing interactions based upon the users input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In lines 322 and 323, we create a `Label` instance with the text we want to
    show, and make sure that the color is white. In line 324, we create the `Popup`
    instance with a title, and the `Label` instance as content. Finally, in line 325,
    we display the `Popup` instance. Here is the result we get after clicking the
    *Status Bar*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Behaviors – enhancing widget''s functionality](img/B04244_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In theory, we can add behaviors to any widget. However, there are practical
    limitations that could lead to unexpected results. For example, what happens when
    we add `ButtonBehavior` to `ToggleButton`? `ToggleButton` inherits from `Button`
    and `Button` from `ButtonBehavior`. As a consequence, we inherit the same method
    twice. Multiple inheritance is indeed tricky sometimes. This example was obvious
    (why would we think about making a class that inherits from `ButtonBehavior` and
    `ToggleButton`?). However, there are many other complex widgets that already include
    functionality for the touch events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be careful when adding behaviors to widgets that overlap the functionality
    related to the behaviors. The current behaviors, `ButtonBehavior`, `ToggleButtonBehavior`,
    `DragBehavior`, `CompoundSelectionBehavior`, and `FocusBehavior` are related to
    touch events.
  prefs: []
  type: TYPE_NORMAL
- en: A special example of this is the `Video` widget, which we will explore in [Chapter
    6](ch06.html "Chapter 6. Kivy Player – a TED Video Streamer"), *Kivy Player –
    a TED Video Streamer*. This widget has a property called `state`, the same name
    as the state property of `ToggleButton`. This will cause a name conflict if we
    want to use multiple inheritances from both classes.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we set the **`Label`** color of the label explicitly
    to white (line 323), which is the label's default color anyway. We did this in
    order to have everything ready for the next section in which we will decorate
    our interface.
  prefs: []
  type: TYPE_NORMAL
- en: Style – decorating the interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will redecorate our interface to improve the look and feel
    of it. With very few strategic changes, we will completely renovate the way our
    application looks with a few steps. Let''s start changing the background color
    from black to white. We will do this in the `comicreator.py` file, and here is
    its new header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We imported the **`Window`** class that manages the configurations of the application
    window, and controls some global parameters and events, such as the keyboard events,
    which will be covered in [Chapter 5](ch05.html "Chapter 5. Invaders Revenge –
    an Interactive Multi-touch Game"), *Invaders Revenge – an Interactive Multitouch
    Game*. We use the `Window` class to change the background color of the application
    to white with the **`clearcolor`** property (line 333). Finally, we add a new
    file to `Builder`. The file called `style.kv` is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We need colors that contrast with the white background that we just applied
    on the entire window. Therefore, we are making changes on two of the basic widgets
    of Kivy, `Label` and `Button`, and this affects all the components that inherit
    from them. We have set the **`bold`** property (line 339) of `Label` to `True`,
    and set the `color` property (line 340) to blue (gray in the printed version).
  prefs: []
  type: TYPE_NORMAL
- en: We have also changed the default background of the `Button` class and introduced
    how to create rounded buttons. The **`background_normal`** property (line 343)
    indicates the background image that `Button` uses in its normal state, whereas
    the **`background_down`** property (line 344) indicates the image that `Button`
    uses when it is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have reset the `color` property (line 345) of `Button` to white.
    You may wonder why we did that if the default color of the text of the `Button`
    class is white. The problem is that we just changed the color of the `Label` class,
    and, since `Button` inherits from label, the change also affects the `Button`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order of the rules also matters. If we put the `<Button>:` rule first, then
    it won't work anymore because the `<Label>:` rule will overwrite the `<Button>:`
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the result of our embellished interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Style – decorating the interface](img/B04244_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is still something not quite right with the new design. The lines of our
    figures are quite thin compared to the rest of the fonts, and somehow the contrast
    is lost with a white background. Let's learn a quick remedy to change the default
    properties of our lines.
  prefs: []
  type: TYPE_NORMAL
- en: Factory – replacing a vertex instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final section of this chapter teaches a valuable trick to change the default
    properties of the **vertex instructions**. We want to change the width of all
    the lines on our interface. This includes the circles, lines, and stickmen. Of
    course, we could revisit all the classes that create the `Line` vertex instructions
    (remember that the circles are also `Line` instances, and the stickmen are composed
    of `Line` instances as well), and change the width property in all of them. Needless
    to say, that would be tedious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we will replace the default `Line` class. Indeed, this is equivalent
    to what we just did in the previous section when we changed the label and button
    default properties. We have a problem in that we cannot create rules in the Kivy
    language to change the vertex instructions. But there is an equivalent way around
    this, using Python code in a new file called `style.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we have created our own `NewLine` class that inherits from the
    Kivy `Line` class (line 350). With a little Python trick, we have changed the
    `kwargs` parameter of the constructor method (`__init__`) in order to set a different
    default width (line 353). The `kwargs` parameter is a dictionary that contains
    all the properties that are explicitly set when a `Line` instance is created.
    In this case, if the `width` property is not indicated in the constructor (line
    352), we set the width default to `1.5` (line 353). Then, we call the constructor
    of the base class with the adjusted `kwargs` (line 354).
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to replace the default Kivy `Line` class with ours. We need
    to import the Kivy **`Factory`** (line 348) that we can use to register or unregister
    classes, and instance them in the Kivy language. First, we need to unregister
    the current `Line` with the **`unregister`** method (line 356). Then, we need
    to register our `NewLine` with the **`register`** method (line 357). In both methods,
    the first parameter represents the name that is used to instance the class from
    the Kivy language. Since we are replacing the class, we will register the `NewLine`
    class with the same name. In the **`register`** method (line 357), the second
    parameter (`cls`) indicates the class that we register.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could use the **`Factory`** class to add different lines that we need to
    constantly use in the Kivy language. For example, we could register our new class
    with the name `ThickLine` and then instance it in the Kivy language.
  prefs: []
  type: TYPE_NORMAL
- en: 'We purposely avoided this strategy, since we actually want to replace the default
    `Line`, so we can affect all the `Line` instances that we create directly in the
    Kivy language. However, we shouldn''t forget to use the `NewLine` class to create
    the instances that the user will create dynamically. We need to import `NewLine`
    from the style file and set an alias name (`Line`) so we can reference the class
    with the same name (line 362). We also need to remove the one we imported from
    `kivy.graphics` (line 362) in the `toolbox.py` file to avoid a name conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the final screenshot of our *Comic Creator*, which shows off the thicker
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Factory – replacing a vertex instruction](img/B04244_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered some specific and useful topics that improve the user experience.
    We added several screens and switched between them with `ScreenManager`. We learned
    how to use colors in the canvas, and we should now have a good understanding of
    how this works internally. We also learned how to limit the drawing area to the
    **`drawing space`** with `StencilView`. We used `Scatter` to add rotating and
    scaling capabilities to `DraggableWidget` and expanded the functionality through
    the use of properties and associated events. We also introduced the use of gestures
    to make the interface more dynamic. We covered how to enhance widget using behaviors.
    Finally, we learned how to improve the interface by modifying the default widgets
    and vertex instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a review of all the classes with their respective methods, properties,
    and attributes that we learned to use in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ScreenManager`: The `transistion` and `current` properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FadeTransition`, `SwapTransition`, `SlideTransition`, and `WipeTransition`
    transitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Screen`: The `name` and `manager` properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorPicker`: The `color` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StencilView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scatter`: The `rotate` and `scale` properties, and the `on_translate`, `on_rotate`
    and `on_scale` methods (events)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScatterLayout`: The `size_hint` and `pos_hint` properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gesture`: The `add_stroke`, `normalize`, and `rotate` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GestureDatabase`: The `gesture_to_str`, `str_to_gesture`, `add_gesture`, and
    `find` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Widget`: The `disabled` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ButtonBehavior`, `ToggleBehavior` and `DragBehavior`: The `on_press` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Popup`: The `title` and `content` properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Window`: The `clearcolor` attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Factory`: The `register` and `unregister` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all useful components that help us create more attractive and dynamic
    applications. In this chapter, we gave an example on how to demonstrate the possibilities
    of the classes. Although we didn't exhaustively explore all the options, we should
    feel comfortable to use any of these components to enhance applications. We can
    always check the Kivy API for a more comprehensive list of properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce personalized multi-touch control, animations,
    as well as the clock and keyboard events. We will create a new interactive project,
    a game that resembles the Arcade game *Space Invaders*.
  prefs: []
  type: TYPE_NORMAL
