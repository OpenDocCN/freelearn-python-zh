- en: Chapter 4. Improving the User Experience
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 提升用户体验
- en: 'This chapter presents an overview of useful components that Kivy provides to
    make the programmer''s life easier when it is time to improve the user experience.
    Some Kivy components reviewed in this chapter are related to widgets that include
    very particular functionalities (for example, a color palette); in this case,
    you will learn the basic techniques to control them. Other widgets will help us
    expand the use of the canvas, for example, changing the color, rotating and scaling
    shapes, or handling gestures. Finally, we will quickly improve the look and feel
    of the application with a few tips. All the sections are intended to increase
    the usability of the application and are self-contained. The following is the
    list of topics we will review in the chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了Kivy提供的实用组件，这些组件可以帮助程序员在提升用户体验时更加轻松。本章中回顾的一些Kivy组件与具有非常特定功能的控件（例如，调色板）相关；在这种情况下，你将学习控制它们的基本技巧。其他控件将帮助我们扩展画布的使用，例如，改变颜色、旋转和缩放形状，或处理手势。最后，我们将通过一些小技巧快速提升应用程序的外观和感觉。所有章节都旨在提高应用程序的可用性，并且是独立的。以下是本章我们将回顾的主题列表：
- en: Switching between different screens
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的屏幕间切换
- en: Using the Kivy palette widget to select colors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kivy调色板控件选择颜色
- en: Controlling the visible area of the canvas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制画布的可见区域
- en: Rotating and scaling with multi-touch gestures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多指手势进行旋转和缩放
- en: Creating single gestures to draw on the screen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单指手势在屏幕上绘制
- en: Enhancing the design with a few global changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一些全局变化增强设计
- en: More importantly, we will discuss how to incorporate these topics into a current
    working project. This will reinforce your previously acquired knowledge and explore
    a new programming situation in which we need to add functionality to an existent
    code. At the end of this chapter, you should feel comfortable with exploring all
    the different widgets that the Kivy API offers, and quickly understand how to
    integrate them into your code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们将讨论如何将这些主题融入当前的工作项目中。这将加强你之前获得的知识，并探索一个新的编程场景，在这个场景中我们需要向现有代码中添加功能。在本章结束时，你应该能够舒适地探索Kivy
    API提供的所有不同控件，并快速理解如何将它们集成到你的代码中。
- en: ScreenManager – selecting colors for the figures
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ScreenManager – 为图形选择颜色
- en: The **`ScreenManager`** class lets us handle different screens in the same window.
    In Kivy, screens are preferred over windows, because we are programming for different
    devices with different screen sizes. Therefore, it is difficult (if not impossible)
    to have windows that adapt properly to all devices. Just imagine yourself juggling
    windows with your fingers on your mobile phone.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ScreenManager`**类允许我们在同一个窗口中处理不同的屏幕。在Kivy中，屏幕比窗口更受欢迎，因为我们正在为具有不同屏幕尺寸的不同设备编程。因此，要正确适应所有设备的窗口是困难的（如果不是不可能的）。只需想象一下，用你的手指在手机上玩弄窗口。'
- en: 'So far, all our figures have been of the same color. Let''s allow the user
    to add some color to make the *Comic Creator* more versatile. Kivy provides us
    with a `Widget` called **`ColorPicker`**, which is displayed in the following
    screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的图形都是同一种颜色。让我们允许用户添加一些颜色，使“漫画创作者”更加灵活。Kivy为我们提供了一个名为**`ColorPicker`**的`Widget`，如下面的截图所示：
- en: '![ScreenManager – selecting colors for the figures](img/B04244_04_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![ScreenManager – 为图形选择颜色](img/B04244_04_01.jpg)'
- en: As you can see, this `Widget` requires a wide space, so it would be difficult
    to accommodate it in our current interface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个`Widget`需要很大的空间，所以在我们的当前界面中很难容纳。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is a bug in Kivy 1.9.0 that prevents `ColorPicker` from working in Python
    3 (it is already fixed in the development version 1.9.1-dev, which is available
    at [https://github.com/kivy/kivy/](https://github.com/kivy/kivy/)). You can use
    Python 2, or there is an alternative code for Python 3 included in the code that
    you can download from the Packt Publishing website. Instead of the `ColorPicker`,
    there is a widget based on `GridLayout` to select a few colors. The concepts that
    we will discuss in this section are also reflected in that code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 1.9.0版本中存在一个bug，阻止了`ColorPicker`在Python 3中工作（它已在开发版本1.9.1-dev中修复，可在[https://github.com/kivy/kivy/](https://github.com/kivy/kivy/)找到）。你可以使用Python
    2，或者可以从Packt Publishing网站下载的代码中找到Python 3的替代代码。代替`ColorPicker`，有一个基于`GridLayout`的控件用于选择一些颜色。本节中讨论的概念也反映在那段代码中。
- en: 'The **`ScreenManager`** class allows us to have multiple screens instead of
    just one `Widget` (`ComicCreator`), and also lets us switch easily between the
    screens. Here is a new Kivy file (`comicscreenmanager.kv`) that contains the `ComicScreenManager`
    class definition:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ScreenManager`** 类允许我们拥有多个屏幕，而不仅仅是单个 `Widget`（`ComicCreator`），并且还允许我们轻松地在屏幕之间切换。以下是一个新的
    Kivy 文件（`comicscreenmanager.kv`），其中包含 `ComicScreenManager` 类的定义：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We embedded the `ColorPicker` instance inside a **`Screen`** widget (line 7),
    instead of adding it directly to the `ComicScreenManager`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `ColorPicker` 实例嵌入到一个 **`Screen`** 小部件中（第 7 行），而不是直接添加到 `ComicScreenManager`。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: A **`ScreenManager`** instance must contain widgets of the **`Screen`** base
    class. No other types of `Widget` (label, button, or layouts) are allowed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ScreenManager`** 实例必须包含 **`Screen`** 基类的小部件。不允许其他类型的 `Widget`（标签、按钮或布局）。'
- en: 'Since we have also added our `ComicCreator` to `ScreenManager` (line 6), we
    need to make sure that our `ComicCreator` inherits from the `Screen` class in
    the `comiccreator.kv` file, so we need to change the file header:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还将我们的 `ComicCreator` 添加到了 `ScreenManager`（第 6 行），我们需要确保在 `comiccreator.kv`
    文件中，我们的 `ComicCreator` 继承自 `Screen` 类，因此我们需要更改文件头：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The **`name`** property (line 20) is used to identify the screen with an ID,
    in this case `comicscreen`, and it is used to change between the screens of `ScreenManeger`
    through its **`current`** property. For example, the `Button` instance that we
    added to `ColorPicker` (line 12), uses the `name` property to change the `current`
    screen in the `on_press` event (line 17). The `root` refers to the `ScreenManager`
    class and the **`current`** property tells it what the active `Screen` is. In
    this case `comicscreen`, the name we assigned to identify the `ComicCreator` instance.
    Notice that we add the Python code directly (line 17) instead of calling a method
    as we did in [Chapter 3](ch03.html "Chapter 3. Widget Events – Binding Actions"),
    *Widget Events – Binding Actions*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**`name`** 属性（第 20 行）用于通过 ID 识别屏幕，在这种情况下是 `comicscreen`，并且它通过其 **`current`**
    属性在 `ScreenManeger` 的屏幕之间切换。例如，我们添加到 `ColorPicker`（第 12 行）的 `Button` 实例使用 `name`
    属性在 `on_press` 事件（第 17 行）中更改 `current` 屏幕。`root` 指的是 `ScreenManager` 类，而 **`current`**
    属性告诉它当前活动的 `Screen` 是什么。在这种情况下是 `comicscreen`，我们用来识别 `ComicCreator` 实例的名称。请注意，我们直接添加了
    Python 代码（第 17 行），而不是像我们在 [第 3 章](ch03.html "第 3 章。小部件事件 – 绑定动作") 中所做的那样调用方法，*小部件事件
    – 绑定动作*。'
- en: 'We also gave a name (`colorscreen`) to the screen that contains the `ColorPicker`
    instance. We will use this name to activate `ColorPicker` with the **Color** button
    in the *general options* area. We need to modify the `color` method of `generaloptions.py`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还给了包含 `ColorPicker` 实例的屏幕一个名称（`colorscreen`）。我们将使用此名称在 *常规选项* 区域中使用 **颜色**按钮激活
    `ColorPicker`。我们需要修改 `generaloptions.py` 中的 `color` 方法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **Color** button now switches the screen in order to display the `ColorPicker`
    instance. Notice the way we access `ScreenManager` (line 23). First, we use the
    `comic_creator` reference in the `GeneralOptions` class to access the `ComicCreator`
    instance. Second, we use the **`manager`** attribute of `Screen` to access its
    corresponding `ScreenManager`. Finally, we change `current` `Screen`, analogous
    to line 17.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色**按钮现在切换屏幕以显示 `ColorPicker` 实例。注意我们访问 `ScreenManager` 的方式（第 23 行）。首先，我们使用
    `GeneralOptions` 类中的 `comic_creator` 引用来访问 `ComicCreator` 实例。其次，我们使用 `Screen`
    的 **`manager`** 属性来访问其相应的 `ScreenManager`。最后，我们更改 `current` `Screen`，类似于第 17 行。'
- en: '`ComicScreenManager` now becomes the main `Widget` of the `ComicCreator` project
    so the `comicreator.py` file has to change accordingly:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComicScreenManager` 现在成为 `ComicCreator` 项目的主体 `Widget`，因此 `comicreator.py`
    文件必须相应更改：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since we changed the name of the app to `ComicScreenManagerApp` (line 44), we
    explicitly load the `comiccreator.kv` file (line 34). Remember that the `comicscreenmanager.kv`
    file is going to be called automatically since the name of the app is now `ComicScreenManagerApp`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将应用程序的名称更改为 `ComicScreenManagerApp`（第 44 行），我们明确加载了 `comiccreator.kv` 文件（第
    34 行）。请记住，由于应用程序的名称现在是 `ComicScreenManagerApp`，`comicscreenmanager.kv` 文件将被自动调用。
- en: One last interesting thing about the `ScreenManager` is that we can use **transitions**.
    Just as an example, the lines 2 and 4 import and use a simple **`FadeTransition`**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `ScreenManager` 的最后一个有趣的事情是我们可以使用 **过渡**。例如，第 2 行和第 4 行导入并使用了一个简单的 **`FadeTransition`**。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Kivy provides a set of transitions (**`FadeTransition`**, **`SwapTransition`**,
    **`SlideTransition`**, and **`WipeTransition`**) to switch between the `Screen`
    instances of `ScreenManager`. Check the Kivy API for more information on how to
    customize them with different parameters at [http://kivy.org/docs/api-kivy.uix.screenmanager.html](http://kivy.org/docs/api-kivy.uix.screenmanager.html)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy提供了一套过渡效果（**`FadeTransition`**、**`SwapTransition`**、**`SlideTransition`**和**`WipeTransition`**）来在`ScreenManager`的`Screen`实例之间切换。有关如何使用不同参数自定义它们的更多信息，请查看Kivy
    API：[http://kivy.org/docs/api-kivy.uix.screenmanager.html](http://kivy.org/docs/api-kivy.uix.screenmanager.html)
- en: After these changes, we can switch between the two screens, `ColorPicker` and
    `ComicCreator`, by clicking on the `Color` button of *general options*, or the
    `Select` button of `ColorPicker`. We also set a different color in the `ColorPicker`
    instance with the **`color`** property (line 11); however, the selection of the
    color still has no effect on the drawing process. The next section covers how
    to set the selected color to the figures we draw.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，我们可以通过点击*通用选项*中的`Color`按钮或`ColorPicker`的`Select`按钮在两个屏幕`ColorPicker`和`ComicCreator`之间切换。我们还使用**`color`**属性（第11行）在`ColorPicker`实例中设置不同的颜色；然而，颜色的选择对绘图过程仍然没有影响。下一节将介绍如何将选定的颜色设置为我们所绘制的图形。
- en: Color control on the canvas – coloring figures
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布上的颜色控制 – 给图形上色
- en: The previous section focused on the selection of colors from a canvas but this
    selection didn't really have an effect yet. In this section, we will actually
    use the selected color. Assigning a color can be tricky if we are not careful.
    If you recall, in [Chapter 3](ch03.html "Chapter 3. Widget Events – Binding Actions"),
    *Widget Events – Binding Actions*, `Color` is a context instruction that we must
    add to the canvas. Moreover, we have to be sure that we add the instruction before
    we draw the actual figure. Basically, selecting a color is similar to picking
    a crayon color to draw on a piece of paper. Until you change the crayon, you will
    continue drawing with its color.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节主要关注从画布中选择颜色，但这个选择实际上还没有产生效果。在本节中，我们将实际使用选定的颜色。如果我们不小心，分配颜色可能会变得复杂。如果你还记得，在[第3章](ch03.html
    "第3章。小部件事件 - 绑定动作"，`Color`是一个必须添加到画布中的上下文指令。此外，我们必须确保在绘制实际图形之前添加这个指令。基本上，选择颜色类似于选择一支蜡笔颜色在纸上绘图。直到你改变蜡笔，你才会继续用它的颜色绘图。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When the color of the context changes, it stays in that state until some other
    instruction modifies it explicitly. In [Chapter 2](ch02.html "Chapter 2. Graphics
    – the Canvas"), *Graphics – the Canvas*, we use `PushMatrix` and `PopMatrix` for
    a similar problem but they only apply to transformation instructions (`Translate`,
    `Rotate`, and `Scale`) because they relate to the coordinate space (that explains
    the matrix part of the instructions names: `PushMatrix` and `PopMatrix`).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下文颜色改变时，它会保持在那个状态，直到其他指令明确地修改它。在[第2章](ch02.html "第2章。图形 – 画布")，*图形 – 画布*中，我们使用`PushMatrix`和`PopMatrix`来解决类似问题，但它们只适用于变换指令（`Translate`、`Rotate`和`Scale`），因为它们与坐标空间相关（这也解释了指令名称中的矩阵部分：`PushMatrix`和`PopMatrix`）。
- en: 'Let''s study a small example (from the *Comic Creator* project) to understand
    this concept better:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究一个小例子（来自*Comic Creator*项目）来更好地理解这个概念：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we use the **`load_string`** method of the **`Builder`** class instead
    of using the **`load_file`** method. This method allows us to embed Kivy language
    statements inside a Python code file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们使用**`Builder`**类的**`load_string`**方法而不是使用**`load_file`**方法。这个方法允许我们在Python代码文件中嵌入Kivy语言语句。
- en: 'One of the properties of `Label` is called `color`; it changes the color of
    the `Label` text. We change `color` to gray (line 54) in the first `Label` but
    it doesn''t clean the context. Observe the result in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`的一个属性称为`color`；它改变`Label`文本的颜色。我们在第一个`Label`中将`color`改为灰色（第54行），但它并没有清除上下文。请观察以下截图中的结果：'
- en: '![Color control on the canvas – coloring figures](img/B04244_04_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![画布上的颜色控制 – 给图形上色](img/B04244_04_02.jpg)'
- en: The rectangle of `Label` (line 56), but also the rectangle of `Widget` (Line
    61) have both changed color. Kivy tries to keep all its components as simple as
    possible to avoid unnecessary instructions. We will follow this approach for the
    colors, so we won't worry about the color until we need to use it. Any other components
    can take care of their own color.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`的矩形（第56行），以及`Widget`的矩形（第61行）都改变了颜色。Kivy试图尽可能简化所有组件，以避免不必要的指令。我们将遵循这种方法来处理颜色，因此我们不必担心颜色，直到我们需要使用它。其他任何组件都可以自己处理自己的颜色。'
- en: 'We can now implement the changes in the *Comic Creator*. There are only three
    methods where we draw in the *drawing space* (all of them are in the `toolbox.py`
    file). Here are those methods with the corresponding new lines highlighted:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现`Comic Creator`中的更改。只有三个方法在*绘图空间*中绘制（它们都在`toolbox.py`文件中）。以下是这些方法，其中对应的新行被突出显示：
- en: 'The `draw` method in the `ToolStickman` class:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToolStickman`类中的`draw`方法：'
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `draw` method in the `ToolFigure` class:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToolFigure`类中的`draw`方法：'
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `widgetize` method in the `ToolFigure` class:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToolFigure`类中的`widgetize`方法：'
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All three methods have a pair of specific instructions in common; you can find
    them in lines 75 and 76, 81 and 82, and 92 and 93\. These are reference chains
    to get access to the `ColorPicker` instance. After this, we just add a `Color`
    instruction to the canvas (as we learned in [Chapter 2](ch02.html "Chapter 2. Graphics
    – the Canvas"), *Graphics – the Canvas*) using the selected `color` in `color_picker`
    (lines 77, 84, and 94).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种方法都有一个共同的特定指令对；你可以在第75和76行、第81和82行、第92和93行找到它们。这些是获取访问`ColorPicker`实例的参考链。之后，我们只需在画布上添加一个`Color`指令（正如我们在[第2章](ch02.html
    "第2章。图形 – 画布")，*图形 – 画布*中学到的），使用`color_picker`中选择的`color`（第77、84和94行）。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The "splat" operator (`*`) on lines 77, 84, and 94 is used in Python to unpack
    argument lists. In this case, the `Color` constructor is meant to receive three
    parameters with the red, green, and blue values, but we have a list stored in
    **`color_picker.color`**, for example, (`1,0,1`), so we need to unpack it to get
    three separated values `1,0,1`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第77、84和94行上的“splat”运算符（`*`）在Python中用于解包参数列表。在这种情况下，`Color`构造函数旨在接收三个参数，即红色、绿色和蓝色值，但我们有一个存储在**`color_picker.color`**中的列表，例如（`1,0,1`），因此我们需要解包它以获取三个分离的值`1,0,1`。
- en: We also use `canvas.before` in the `draw` method of the `ToolStickman` class
    (line 77). This is used to ensure that the `Color` instruction is executed before
    the instructions we added in `canvas` of `Stickman` (the `comicwidgets.kv` file).
    This is not necessary in the other two methods because we have full control of
    the canvas order inside those methods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`ToolStickman`类的`draw`方法中使用了`canvas.before`（第77行）。这是用来确保在`Stickman`的`canvas`（`comicwidgets.kv`文件）中添加的指令之前执行`Color`指令。在其他两种方法中这不是必要的，因为我们完全控制了那些方法内部的画布顺序。
- en: 'Finally, we must import the `Color` class in the header of the file `from kivy.graphics
    import Line, Color`. We can now take a break and enjoy the result of our hard
    work with our *Comic Creator*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在文件`from kivy.graphics import Line, Color`的头部导入`Color`类。现在我们可以休息一下，享受我们用*漫画创作者*辛勤工作的成果：
- en: '![Color control on the canvas – coloring figures](img/B04244_04_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![画布上的颜色控制 – 着色图形](img/B04244_04_03.jpg)'
- en: At a later point in time, we can discuss whether our drawing is just an avid
    *Comic Creator* fan or a narcissistic alien with an oversized t-shirt. For now,
    it seems more useful to learn how to limit the *drawing space* to the specific
    area that occupies the window.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后的某个时间点，我们可以讨论我们的绘图是否只是一个狂热的*漫画创作者*粉丝，或者是一个穿着超大T恤的自恋外星人。现在，学习如何将*绘图空间*限制在占据窗口的特定区域似乎更有用。
- en: StencilView – limiting the drawing space
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StencilView – 限制绘图空间
- en: In [Chapter 3](ch03.html "Chapter 3. Widget Events – Binding Actions"), *Widget
    Events – Binding Actions*, we avoided drawing outside of the *drawing space* by
    using simple mathematics and `collide_points`. It was far from perfect (for example,
    it fails in the group mode or when we resize it), and it was tedious and prone
    to programming mistakes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。小部件事件 – 绑定动作")，*小部件事件 – 绑定动作*中，我们通过使用简单的数学和`collide_points`来避免在*绘图空间*外绘制。这远非完美（例如，在组模式或我们调整大小时会失败），而且很繁琐且容易出错。
- en: 'That was sufficient for a first example, however, **`StencilView`** is the
    easier way to go here. **`StencilView`** limits the drawing area to the space
    occupied by itself. Anything drawn outside that area is hidden. First, let''s
    modify the file `drawingspace.py` with the following header:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于第一个例子已经足够了，然而，**`StencilView`**在这里是一个更简单的方法。**`StencilView`**将绘制区域限制在它自己占据的空间内。任何在该区域之外的绘制都将被隐藏。首先，让我们修改`drawingspace.py`文件，添加以下头部：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`The` `DrawingSpace` instance inherits now from `StencilView`, instead of `RelativeLayout`.
    The `StencilView` class doesn''t use relative coordinates (as the `RelativeLayout`
    class does) but we would like to keep relative coordinates in the *drawing space*
    because they are convenient for drawing purposes. In order to do this, we can
    modify the top-right `AnchorLayout`, so the `DrawingSpace` instance is inside
    a `RelativeLayout` instance. We do this in the `comiccreator.kv` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`The` `DrawingSpace`实例现在从`StencilView`继承，而不是`RelativeLayout`。`StencilView`类不使用相对坐标（如`RelativeLayout`类所做的那样），但我们希望保留*绘制空间*中的相对坐标，因为它们对绘制很有用。为了做到这一点，我们可以修改右上角的`AnchorLayout`，使`DrawingSpace`实例位于一个`RelativeLayout`实例内部。我们在`comiccreator.kv`文件中这样做：'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we embed the `DrawingSpace` instance (line 109) inside a `RelativeLayout`
    instance (line 105) of the same size (by default, the `DrawingSpace` instance
    uses `size_hint: 1, 1` occupying all the area of the `RelativeLayout` parent),
    then the coordinates inside the `DrawingSpace` instance are relative to the `RelativeLayout`
    instance. Since they are of the same size, then the coordinates are also relative
    to the `DrawingSpace` instance.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们将`DrawingSpace`实例（第109行）嵌入到相同大小的`RelativeLayout`实例（第105行）中时（默认情况下，`DrawingSpace`实例使用`size_hint:
    1, 1`占据`RelativeLayout`父实例的所有区域），那么`DrawingSpace`实例内部的坐标相对于`RelativeLayout`实例。由于它们大小相同，因此坐标也相对于`DrawingSpace`实例。'
- en: 'We kept the `DrawingSpace` ID (line 110) and attributes (lines 111 to 113).
    Since we have a new level of indentation and the `DrawingSpace` class is not relative
    itself, this affects the way we localize the coordinates in the `ToolBox` instance,
    specifically, in `on_touch_down` of the `ToolButton` class, and `update_figure`
    and `end_figure` of the `ToolFigure` class. The following is the new code for
    `on_touch_down` of the `ToolButton` class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了`DrawingSpace` ID（第110行）和属性（第111至113行）。由于我们有一个新的缩进级别，并且`DrawingSpace`类本身不是相对的，这影响了我们在`ToolBox`实例中定位坐标的方式，具体来说，是在`ToolButton`类的`on_touch_down`和`ToolFigure`类的`update_figure`和`end_figure`中。以下是`ToolButton`类`on_touch_down`的新代码：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We receive absolute coordinates in this method since we are inside `ToolButton`,
    which doesn't belong to any `RelativeLayout` instance. The *drawing space* also
    receives absolute coordinates, but it will interpret them inside the context of
    the `RelativeLayout` instance that it is embedded in. The right approach for the
    `DrawingSpace` instance is to ask its `RelativeLayout` parent who will collide
    the coordinates (received in the `ToolButton`) correctly (line 116)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们位于`ToolButton`内部，它不属于任何`RelativeLayout`实例，所以我们在这个方法中接收绝对坐标。*绘制空间*也接收绝对坐标，但它将在嵌入的`RelativeLayout`实例的上下文中解释它们。对于`DrawingSpace`实例的正确做法是询问它的`RelativeLayout`父实例，该实例将正确地碰撞（第116行）坐标（在`ToolButton`中接收到的）
- en: 'The following is the new code of `update_figure` and `end_figure` of the `ToolFigure`
    class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ToolFigure`类`update_figure`和`end_figure`的新代码：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We removed some instructions because we no longer need them. First off, we don't
    need to use the `to_widget` method anymore in either of the two methods, since
    we are already getting the coordinates from the `RelativeLayout` parent. And secondly,
    we don't need to worry about applying the `collide_point` method in the `update_figure`
    method because `StencilView` will be in charge of it; any drawing that takes place
    outside the bounds is discarded.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除了一些指令，因为我们不再需要它们。首先，我们不再需要在两个方法中的任何一个中使用`to_widget`方法，因为我们已经从`RelativeLayout`父实例中获取了坐标。其次，我们不需要担心在`update_figure`方法中应用`collide_point`方法，因为`StencilView`将负责它；任何在边界之外的绘制都将被丢弃。
- en: With just a few changes, we ensured that nothing will be drawn outside of the
    *drawing space*, and, with that guarantee, we can now proceed to discuss how to
    drag, rotate, and scale the figures.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 只需进行少量更改，我们就确保了不会在*绘制空间*之外绘制任何内容，并且有了这个保证，我们现在可以讨论如何拖动、旋转和缩放图形。
- en: Scatter – multi-touching to drag, rotate, and scale
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 散点图 – 多点触摸以拖动、旋转和缩放
- en: 'In the previous chapter ([Chapter 3](ch03.html "Chapter 3. Widget Events –
    Binding Actions"), *Widget Events – Binding Actions*), you learned how to use
    events to drag widgets. You learned how to use the `on_touch_up`, `on_touch_move`,
    and `on_touch_down` events. However, the **`Scatter`** class already provides
    that functionality and also lets us scale and rotate using two fingers, as one
    would on a mobile or tablet screen. All the functionality is included inside the
    **`Scatter`** class; however, we need to apply a few changes to keep our project
    consistent. In particular, we still want our *group mode* to work, so that translating,
    scaling, and rotating can happen at the same time. Let us implement the changes
    in four big steps in the `comicwidgets.py` file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章（[第 3 章](ch03.html "第 3 章。小部件事件 – 绑定动作"), *小部件事件 – 绑定动作*），你学习了如何使用事件来拖动小部件。你学习了如何使用
    `on_touch_up`、`on_touch_move` 和 `on_touch_down` 事件。然而，**`Scatter`** 类已经提供了该功能，并允许我们使用两个手指进行缩放和旋转，就像在移动或平板屏幕上一样。所有功能都包含在
    **`Scatter`** 类中；然而，我们需要进行一些更改以保持我们的项目一致性。特别是，我们仍然希望我们的 *组模式* 能够工作，以便同时进行平移、缩放和旋转。让我们在
    `comicwidgets.py` 文件中分四步实现这些更改：
- en: 'Replace the `DraggableWidget` base class. Let''s use `Scatter` instead of `RelativeLayout`
    (line `132` and `135`):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换 `DraggableWidget` 基类。让我们使用 `Scatter` 而不是 `RelativeLayout`（第 `132` 行和 `135`
    行）：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both `Scatter` and `RelativeLayout` use relative coordinates.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Scatter` 和 `RelativeLayout` 都使用相对坐标。'
- en: 'Make sure that the `on_touch_down` event of `DraggableWidget` is sent to the
    base class (`Scatter`) by calling the `super` method (line `140`) before `return
    True` (line `141`) inside the condition. If you don''t do that, the `Scatter`
    base class will never receive the event `on_touch_down` and nothing will happen:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过调用 `super` 方法（第 `140` 行）在 `return True`（第 `141` 行）之前将 `DraggableWidget`
    的 `on_touch_down` 事件发送到基类（`Scatter`）。如果不这样做，`Scatter` 基类将永远不会收到 `on_touch_down`
    事件，什么也不会发生：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `super` method is useful for the base class (`Scatter`) and the `return`
    statement is useful for the parent (`DrawingSpace`)
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`super` 方法对基类（`Scatter`）很有用，而 `return` 语句对父类（`DrawingSpace`）很有用'
- en: 'Remove the `on_touch_move` method and add an `on_pos` method, which is called
    when the `pos` property is modified. Since `Scatter` will be responsible for dragging,
    we don''t need `on_touch_move` anymore. Instead, we will use the `pos` property
    that is modified by `Scatter`. Remember that the properties trigger an event that
    will call on the `on_pos` method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `on_touch_move` 方法并添加一个 `on_pos` 方法，当 `pos` 属性被修改时调用。由于 `Scatter` 将负责拖动，我们不再需要
    `on_touch_move`。相反，我们将使用 `Scatter` 修改的 `pos` 属性。记住，属性会触发一个事件，该事件将调用 `on_pos` 方法：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Scatter has two other properties: `rotation` and `scale`. We can use the same
    idea as with `pos` and `on_pos`, and add the `on_rotation` and `on_scale` methods:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Scatter` 有两个其他属性：`rotation` 和 `scale`。我们可以使用与 `pos` 和 `on_pos` 相同的想法，并添加 `on_rotation`
    和 `on_scale` 方法：'
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `on_rotation` and `on_scale` methods modify a couple of new properties
    (lines 152 and 157) that we need to add to the `GeneralOptions` class. This will
    help us to keep the group mode working. The following code is the new header of
    `generaloptions.py` that includes the new properties:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_rotation` 和 `on_scale` 方法修改了几个新属性（第 152 行和 157 行），我们需要将这些属性添加到 `GeneralOptions`
    类中。这将帮助我们保持组模式的工作。以下代码是 `generaloptions.py` 的新头文件，其中包含新属性：'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We import `NumericProperty` along with `ListProperty` (line 160); and we create
    the two missing properties: `rotation` and `scale` (lines 165 and 166). We also
    need to add the `on_rotation` (line 167) and `on_scale` (line 172) methods (associated
    with the `rotation` and `scale` properties), which will ensure that all the `selected`
    components are rotated or scaled at once, by traversing the list of children that
    have been added to the *drawing space* (line 173 and 177):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `NumericProperty` 和 `ListProperty`（第 160 行）；并创建两个缺失的属性：`rotation` 和 `scale`（第
    165 行和 166 行）。我们还需要添加 `on_rotation`（第 167 行）和 `on_scale`（第 172 行）方法（与 `rotation`
    和 `scale` 属性相关联），这将确保所有 `selected` 组件通过遍历添加到 *绘图空间*（第 173 行和 177 行）的子组件列表一次旋转或缩放：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A final modification is necessary. We need to change the `on_translation` method
    to check that the current `child` in the loop is not the one being touched (if
    this happens, call the police!), because this could cause an infinitive recursion
    since we modify the properties that call on this event in the first place. Here
    is the new `on_translation` method in the `generaloptions.py` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行最后的修改。我们需要将`on_translation`方法修改为检查循环中的当前`child`是否不是被触摸的那个（如果发生这种情况，请报警！），因为这样可能会引起无限递归，因为我们修改了最初调用此事件的属性。以下是`generaloptions.py`文件中的新`on_translation`方法：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, we are able to translate, rotate, or scale the figures with our
    fingers, even in the *group mode*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够用手指来平移、旋转或缩放图形，甚至在*分组模式*下也是如此。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Kivy provides a way to simulate multi-touch with the mouse. It is limited but
    you can still test this section with your one-mouse laptop. All you have to do
    is right-click on the figure you want to rotate. A translucent red circle will
    appear on the screen. Then, you can use the normal left dragging as if it were
    a second finger to rotate or scale. To clear the simulated multi-touch, you left-click
    on the red icon.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy提供了一种使用鼠标模拟多点触控的方法。虽然有限，但你仍然可以用你的单点鼠标笔记本电脑测试这一部分。你所要做的就是右击你想要旋转的图形。屏幕上会出现一个半透明的红色圆圈。然后，你可以使用正常的左键拖动，就像它是第二个手指一样来旋转或缩放。要清除模拟的多点触控，你只需左击红色图标。
- en: 'The next screenshot cut shows our `StickMan` being rotated and scaled at the
    same time as the line next to him. The small `StickMan` on the right is just a
    reference to compare against the original size. The simulated multi-touch gesture
    is being applied to the line on the right and that is why you can see a red (gray
    in the printed version) dot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图展示了我们的`StickMan`在他旁边的线条同时旋转和缩放的情况。右侧的小`StickMan`只是一个用来比较原始大小的参考。模拟的多点触控手势被应用于右侧的线条上，这就是为什么你可以看到一个红色的（在打印版本中为灰色）点：
- en: '![Scatter – multi-touching to drag, rotate, and scale](img/B04244_04_04.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Scatter – 多点触控以拖动、旋转和缩放](img/B04244_04_04.jpg)'
- en: In [Chapter 1](ch01.html "Chapter 1. GUI Basics – Building an Interface"), *GUI
    Basics – Building an Interface*, we briefly mention **`ScatterLayout`** but now
    the difference between **`ScatterLayout`** and **`Scatter`** may be clear.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。GUI基础 – 构建界面") *GUI基础 – 构建界面* 中，我们简要提到了**`ScatterLayout`**，但现在**`ScatterLayout`**和**`Scatter`**之间的区别可能已经清晰。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**`ScatterLayout`** is a Kivy layout that inherits from `Scatter` and contains
    `FloatLayout`. This allows you to use the `size_hint` and `pos_hint` properties
    when you add widgets inside it. `ScatterLayout` also uses relative coordinates.
    This doesn''t mean you cannot add other widgets inside a simple `Scatter`; it
    just means that `Scatter` doesn''t honor `size_hint` or `pos_hint`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ScatterLayout`**是一个继承自`Scatter`并包含`FloatLayout`的Kivy布局。这允许你在其中添加小部件时使用`size_hint`和`pos_hint`属性。`ScatterLayout`也使用相对坐标。这并不意味着你无法在简单的`Scatter`中添加其他小部件；它只是意味着`Scatter`不遵守`size_hint`或`pos_hint`。'
- en: With the use of `Scatter`, we are able to drag, rotate, and scale our figures.
    This is a great improvement of functionality in our *Comic Creator*. Let's now
    increase the interaction with the user even more, learn how to create our own
    gestures, and use them inside our project.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Scatter`，我们能够拖动、旋转和缩放我们的图形。这是对我们*漫画创作器*功能性的巨大改进。现在让我们进一步增强与用户的交互，学习如何创建我们自己的手势，并在我们的项目中使用它们。
- en: Recording gestures – line, circle, and cross
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录手势 – 线、圆和十字
- en: 'What about drawing with one finger? Can we recognize gestures? It is possible
    to do this with Kivy. First, we need to record the gestures that we want to use.
    A gesture is represented as a long string that contains the points of a stroke
    over the screen. The following code uses the Kivy `Gesture` and `GestureDatabase`
    classes to record gesture strokes. It can be run with Python `gesturerecorder.py`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个手指画画怎么样？我们能识别手势吗？使用Kivy是可以做到的。首先，我们需要记录我们想要使用的手势。手势表示为包含屏幕上笔划点的长字符串。以下代码使用Kivy的`Gesture`和`GestureDatabase`类来记录手势笔划。它可以与Python
    `gesturerecorder.py`一起运行：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The previous code prints the gesture string representations using the **`Gesture`**
    and **`GestureDatabase`** classes (line 184). The `on_touch_down`, `on_touch_move`,
    and `on_touch_up` methods collect `points` of the stroke lines 189, 195, and 199\.
    The following screenshots are examples of strokes collected with `gesturerecorded.py`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用**`Gesture`**和**`GestureDatabase`**类（第184行）打印了手势字符串表示。`on_touch_down`、`on_touch_move`和`on_touch_up`方法收集笔触线条的`points`（第189行、第195行和第199行）。以下截图是使用`gesturerecorded.py`收集的笔触示例：
- en: '![Recording gestures – line, circle, and cross](img/B04244_04_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![录制手势 – 线、圆和十字](img/B04244_04_05.jpg)'
- en: The small `Circle` in the preceding figures (lines 190 and 191) indicates the
    starting point, and the line indicates the path that the stroke follows. The most
    relevant part is coded in lines 200 to 204\. We create `Gesture` (line 200), add
    `points` for the stroke with the **`add_stroke`** method (line 201), **`normalize`**
    to a default number of points (line 202), and create a `GestureDatabase` instance
    (line 203) that we use in line 204 to generate the string (**`gesture_to_str`**)
    and print it on the screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图形（第190行和第191行）中的小圆圈表示起点，线条表示笔触的路径。最相关的部分在200到204行中编码。我们在第200行创建`Gesture`，使用**`add_stroke`**方法（第201行）为笔触添加`points`，**`normalize`**到默认的点数（第202行），并在第203行创建一个`GestureDatabase`实例，我们在第204行使用它来生成字符串（**`gesture_to_str`**）并在屏幕上打印。
- en: 'The following screenshot shows the terminal output for the stroke line (corresponding
    to the first figure on the left in the preceding figures set):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了笔触线条的终端输出（对应于前面图形集中左边的第一个图形）：
- en: '![Recording gestures – line, circle, and cross](img/B04244_04_06.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![录制手势 – 线、圆和十字](img/B04244_04_06.jpg)'
- en: In the preceding screenshot, the long string starting with `'eNq1Vktu…'` is
    the gesture serialization. We use these long strings as descriptors of the gestures
    that Kivy understands and uses to associate the stroke with any action we want
    to perform. The next section explains how to achieve this.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，以 `'eNq1Vktu…'` 开头的长字符串是手势序列化。我们使用这些长字符串作为Kivy理解并使用的手势描述符，以将笔触与我们要执行的动作关联起来。下一节将解释如何实现这一点。
- en: Recognizing gestures – drawing with the finger
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别手势 – 用手指绘制
- en: The previous section explained how to obtain string representations from gestures.
    The current section explains how to use those string representations to recognize
    the gestures. Kivy has some tolerance error in the gesture recognition, so you
    don't have to worry about repeating exactly the same stroke.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节解释了如何从手势中获得字符串表示。本节解释了如何使用这些字符串表示来识别手势。Kivy在手势识别中存在一些容错误差，因此您不必担心重复执行完全相同的笔触。
- en: 'To start, we copied the strings that were generated from the strokes in the
    previous section into a new file called `gestures.py`. The strings are assigned
    to different variables. The following code corresponds to `gestures.py`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将上一节中从笔触生成的字符串复制到一个名为`gestures.py`的新文件中。这些字符串分配给不同的变量。以下代码对应于`gestures.py`：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Only the first few characters of the strings are shown in the previous code
    but you can download the complete file from the Packt Publishing website, or use
    the previous section to generate your own strings.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码只显示了字符串的前几个字符，但您可以从Packt Publishing网站下载完整的文件，或者使用上一节生成您自己的字符串。
- en: 'Next, we will use these strings in the `drawingspace.py` file. Let''s start
    importing the necessary classes in the header first:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`drawingspace.py`文件中使用这些字符串。首先，让我们在标题中导入必要的类：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we import the `Gesture` and `GestureDatabase` classes
    (line 218) along with the gesture string representations added to `gestures.py`
    (lines 219). We added several methods to the `DrawingSpace` class. Let''s quickly
    review each of the methods, and, at the end, highlight the key parts:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了`Gesture`和`GestureDatabase`类（第218行），以及添加到`gestures.py`中的手势字符串表示（第219行）。我们向`DrawingSpace`类添加了几个方法。让我们快速回顾每个方法，并在最后突出关键部分：
- en: '`__init__`: This method creates the attributes of the class and fills `GestureDatabase`
    using **`str_to_gesture`** in order to transform the strings into gestures, and
    **`add_gesture`** to add the gestures to the database:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__`：该方法创建类的属性，并使用**`str_to_gesture`**将字符串转换为手势，并使用**`add_gesture`**将手势添加到数据库中：'
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`activate` and `deactivate`: These methods bind or unbind the methods to the
    touch events in order to start the gesture recognition mode. These methods are
    called by the gesture `Button` of the *general options*:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activate`和`deactivate`：这些方法将方法绑定或解绑到触摸事件上，以便启动手势识别模式。这些方法由*通用选项*中的手势`Button`调用：'
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`down`, `move` and `ups`: These methods record the points of the stroke in
    a very similar way that the previous section did:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down`, `move` 和 `ups`：这些方法以非常相似的方式记录笔画的点，就像上一节所做的那样：'
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`gesturize`: This method creates a `Gesture` instance from the collected points
    in the previous methods:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gesturize`：这种方法从之前方法中收集的点创建一个`Gesture`实例：'
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`min_and_max`: This method keeps track of the extreme points of the stroke:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_and_max`：这种方法跟踪笔画的极值点：'
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`Discriminate`: This method calls the corresponding method according to the
    recognized gesture:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Discriminate`：这种方法根据识别的手势调用相应的方法：'
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`add_circle`, `add_Line`, `add_stickman`: These methods use the corresponding
    `ToolButton` of `ToolBox` to add a figure according to the recognized gesture:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_circle`、`add_Line`、`add_stickman`：这些方法使用`ToolBox`的相应`ToolButton`根据识别的手势添加一个图形：'
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`on_children`: This method keeps the counter of the *Status Bar* updated:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_children`：这种方法保持*状态栏*计数器的更新：'
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `DrawingSpace` class is now in charge of capturing strokes on the screen,
    search for them in the gesture database (that contains the gestures of the last
    section), and draw a shape accordingly. It also offers the possibility of activating
    and deactivating the gesture recognition. Let's cover this in four parts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`DrawingSpace`类负责在屏幕上捕捉笔画，在手势数据库（包含上一节中的手势）中搜索它们，并根据搜索结果绘制形状。它还提供了激活和停用手势识别的可能性。让我们分四部分来讨论这个问题。
- en: First, we need to create the `GestureDatabase` instance (line 224) and use it
    to create the gestures from the strings (lines 225 to 227). We rotate the `line45`
    gesture by 90 degrees (lines 228 to 230) four times with the **`rotate`** method,
    so the `GestureDatabase` instance recognizes the line gesture in different directions.
    Then, we load `GestureDatabase` with the generated gestures (lines 231 to 236).
    We added all of these instructions in the constructor of the class, the `__init__`
    method (lines 222 to 236), so the `DrawingSpace` class has all the elements to
    recognize gestures.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建`GestureDatabase`实例（第224行）并使用它从字符串中创建手势（第225至227行）。我们使用**`rotate`**方法将`line45`手势旋转90度（第228至230行）四次，这样`GestureDatabase`实例就能识别不同方向上的线条手势。然后，我们使用生成的手势加载`GestureDatabase`（第231至236行）。我们将所有这些指令添加到类的构造函数中，即`__init__`方法（第222至236行），这样`DrawingSpace`类就有识别手势的所有元素。
- en: 'Second, we need to capture the gesture stroke. In order to do this, we use
    the touch events. We have created the methods associated with them: `down` (line
    248), `move` (line 255), and `up` (line 261). These methods are similar to the
    `on_touch_down`, `on_touch_move`, and `on_touch_up` methods of the last section
    in the sense that they register the points of the stroke. However, they also keep
    track of the *extreme* axes of the stroke to define a bounding box for the stroke
    as the following figure illustrates:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要捕捉手势笔画。为了做到这一点，我们使用触摸事件。我们已经创建了与它们相关的这些方法：`down`（第248行），`move`（第255行），以及`up`（第261行）。这些方法与上一节中的`on_touch_down`、`on_touch_move`和`on_touch_up`方法类似，因为它们注册了笔画的点。然而，它们还跟踪笔画的*极端*轴，以定义笔画的边界框，如下面的图所示：
- en: '![Recognizing gestures – drawing with the finger](img/B04244_04_07.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![识别手势 – 用手指绘图](img/B04244_04_07.jpg)'
- en: These points are used to define the size of the shape we will draw. The `up`
    method, firstly, uses the registered points to create a `Gesture` instance (line
    265), secondly, makes the query to the `GestureDatabase` instance using the **`find`**
    method (line 266), and thirdly, calls the `discriminate` method to draw the appropriate
    shape (line 280). The **`minscore`** parameter of the **`find`** method (line
    266) is used to indicate the precision of the search.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点用于定义我们将要绘制的形状的大小。`up`方法首先使用注册的点创建一个`Gesture`实例（第265行），其次使用**`find`**方法（第266行）对`GestureDatabase`实例进行查询，然后调用`discriminate`方法绘制适当的形状（第280行）。**`find`**方法的**`minscore`**参数（第266行）用于指示搜索的精度。
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We use a low level (`0.50`) since we know that the strokes are very different,
    and that a mistake in this application can be easily undone.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用低级别（`0.50`），因为我们知道笔画非常不同，并且在这个应用程序中的错误可以很容易地撤销。
- en: Third, we implement the `discriminate` method (line 280) to discriminate the
    `recognized` variable from among the three possible shapes of our *tool box*.
    The recognized variable (returned by the **`find`** method of `GestureDatabase`)
    is a pair, where the first element is the score of the recognition, and the second
    element is the actual recognized gesture. We use the second value (`recognized[1]`)
    for the discrimination process (line 281) and then call the corresponding method
    (`add_stickman`, `add_line`, and `add_circle`). In the case of lines, it also
    decides the order in which to send the coordinates to match the direction.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们实现了`discriminate`方法（第280行），以从我们的*工具箱*的三个可能形状中区分`recognized`变量。被识别的变量（由`GestureDatabase`的**`find`**方法返回）是一对，其中第一个元素是识别的分数，第二个元素是实际识别的手势。我们使用第二个值（`recognized[1]`）进行区分过程（第281行），然后调用相应的方法（`add_stickman`、`add_line`和`add_circle`）。对于线条，它还决定发送坐标的顺序以匹配方向。
- en: Fourth, the `activate` and `deactivate` methods provide an interface in order
    to activate or deactivate the *gesture mode* (the application mode in which we
    can use gestures). To activate the mode, the `activate` method binds the `on_touch_up`,
    `on_touch_move`, and `on_tourch_down` events to the corresponding `up`, `move`,
    and `down` methods. It also uses the **`disabled`** property (lines 238) to disable
    the *tool box* widget when the gesture mode is on. The `deactivate` method unbinds
    the events and restores the **`disabled`** property.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，`activate`和`deactivate`方法提供了一个接口，以便激活或关闭*手势模式*（我们可以使用手势的应用模式）。要激活模式，`activate`方法将`on_touch_up`、`on_touch_move`和`on_tourch_down`事件绑定到相应的`up`、`move`和`down`方法。它还使用**`disabled`**属性（第238行）在手势模式激活时禁用*工具箱*小部件。`deactivate`方法解绑事件并恢复**`disabled`**属性。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We applied the **`disabled`** property to the entire `ToolBox` instance, but
    it automatically looks for the children that belong to it and deactivates them
    as well. Basically, the event is never sent to the children.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将**`disabled`**属性应用于整个`ToolBox`实例，但它会自动查找属于它的子项并将它们也禁用。基本上，事件永远不会发送到子项。
- en: 'The gestures mode is activated and deactivated from the general options buttons
    with the gestures `ToggleButton`. We need to change the definition of the `gestures`
    method in the `generaloptions.py` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过手势切换按钮，从常规选项按钮激活和关闭手势模式。我们需要在`generaloptions.py`文件中更改`gestures`方法的定义：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When **`gestures`** `ToggleButton` is `down`, then the *gesture mode* is activated;
    otherwise, the normal functionality of the *tool box* operates.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当**`gestures`** `ToggleButton`处于`down`状态时，则*手势模式*被激活；否则，*工具箱*的正常功能运行。
- en: In the next lesson, we will learn how to enhance the functionality of our widgets
    using behaviors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将学习如何使用行为来增强我们小部件的功能。
- en: Behaviors – enhancing widget's functionality
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为 – 增强小部件的功能
- en: '**`Behaviors`** were introduced recently in the Kivy version 1.8.0, and allow
    us to increase the functionality and flexibility of the existing widgets. Basically,
    they let us inject classic behaviors of certain widgets into other behaviors.
    For example, we can use **`ButtonBehavior`** in order to add the `on_press` and
    `on_release` functionality to a `Label` or `Image` widget. Currently, there are
    three types of behavior (**`ButtonBehavior`**, **`ToggleButtonBehavior`**, and
    **`DragBehavior`**) and more will be coming in the next Kivy releases.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Behaviors`**最近在Kivy版本1.8.0中引入，允许我们增加现有小部件的功能性和灵活性。基本上，它们让我们将某些小部件的经典行为注入到其他行为中。例如，我们可以使用**`ButtonBehavior`**来向`Label`或`Image`小部件添加`on_press`和`on_release`功能。目前，有三种类型的行为（**`ButtonBehavior`**、**`ToggleButtonBehavior`**和**`DragBehavior`**），在下一个Kivy版本中还将有更多。'
- en: 'Let''s add some credits to our application. We want to add some functionality
    to the *Status Bar* so that when we click, a **`Popup`** will appear and show
    some text. First, we will import the necessary components into the `statusbar.py`
    header, and also change the class definition of `StatusBar`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的应用程序中添加一些致谢。我们希望向*状态栏*添加一些功能，以便当我们点击时，会出现一个**`Popup`**并显示一些文本。首先，我们将必要的组件导入到`statusbar.py`头文件中，并更改`StatusBar`类的定义：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the previous code, we have added the **`ButtonBehavior`**, **`Popup`**,
    and **`Label`** class (lines 316 and 318). Moreover, we made `StatusBar` inherit
    from both `ButtonBehavior` and `BoxLayout` at the same time with Python''s multiple
    inheritance. We can add behaviors to any type of widget, and remember from [Chapter
    1](ch01.html "Chapter 1. GUI Basics – Building an Interface"), *GUI Basics – Building
    an Interface*, that layouts are also widgets. We take advantage of the **`ButtonBehavior`**
    that **`StatusBar`** is inheriting from, in order to use the **`on_press`** method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们添加了**`ButtonBehavior`**、**`Popup`**和**`Label`**类（第316行和第318行）。此外，我们使用Python的多重继承同时让`StatusBar`从`ButtonBehavior`和`BoxLayout`继承。我们可以将行为添加到任何类型的部件中，并记得从[第1章](ch01.html
    "第1章。GUI基础 - 构建界面")，*GUI基础 - 构建界面*，中了解到布局也是部件。我们利用**`ButtonBehavior`**从**`StatusBar`**继承的优势，以便使用**`on_press`**方法：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We override the **`on_press`** method to display a **`Popup`** window on the
    screen with the credits of the application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了**`on_press`**方法，在屏幕上显示一个包含应用程序版权信息的**`Popup`**窗口。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that behaviors don't change the appearance of the widget; only the functionality
    that is most often related to processing interactions based upon the users input.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，行为不会改变部件的外观；只有与用户输入相关的交互处理功能才会发生变化。
- en: 'In lines 322 and 323, we create a `Label` instance with the text we want to
    show, and make sure that the color is white. In line 324, we create the `Popup`
    instance with a title, and the `Label` instance as content. Finally, in line 325,
    we display the `Popup` instance. Here is the result we get after clicking the
    *Status Bar*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第322行和第323行，我们创建了一个包含我们想要显示的文本的`Label`实例，并确保颜色为白色。在第324行，我们创建了一个带有标题的`Popup`实例，并将`Label`实例作为内容。最后，在第325行，我们显示了`Popup`实例。以下是点击**状态栏**后我们得到的结果：
- en: '![Behaviors – enhancing widget''s functionality](img/B04244_04_08.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![行为 - 增强部件的功能](img/B04244_04_08.jpg)'
- en: In theory, we can add behaviors to any widget. However, there are practical
    limitations that could lead to unexpected results. For example, what happens when
    we add `ButtonBehavior` to `ToggleButton`? `ToggleButton` inherits from `Button`
    and `Button` from `ButtonBehavior`. As a consequence, we inherit the same method
    twice. Multiple inheritance is indeed tricky sometimes. This example was obvious
    (why would we think about making a class that inherits from `ButtonBehavior` and
    `ToggleButton`?). However, there are many other complex widgets that already include
    functionality for the touch events.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以将行为添加到任何部件。然而，实际限制可能导致意外结果。例如，当我们向`ToggleButton`添加`ButtonBehavior`会发生什么？`ToggleButton`从`Button`继承，而`Button`从`ButtonBehavior`继承。因此，我们继承了相同的方法两次。多重继承有时确实很棘手。这个例子很明显（我们为什么会考虑创建一个从`ButtonBehavior`和`ToggleButton`继承的类呢？）。然而，还有许多其他复杂的部件已经包含了触摸事件的功能。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should be careful when adding behaviors to widgets that overlap the functionality
    related to the behaviors. The current behaviors, `ButtonBehavior`, `ToggleButtonBehavior`,
    `DragBehavior`, `CompoundSelectionBehavior`, and `FocusBehavior` are related to
    touch events.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向重叠功能相关的部件添加行为时，你应该小心。当前的行为，`ButtonBehavior`、`ToggleButtonBehavior`、`DragBehavior`、`CompoundSelectionBehavior`和`FocusBehavior`都与触摸事件相关。
- en: A special example of this is the `Video` widget, which we will explore in [Chapter
    6](ch06.html "Chapter 6. Kivy Player – a TED Video Streamer"), *Kivy Player –
    a TED Video Streamer*. This widget has a property called `state`, the same name
    as the state property of `ToggleButton`. This will cause a name conflict if we
    want to use multiple inheritances from both classes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个特殊例子是`Video`部件，我们将在[第6章](ch06.html "第6章。Kivy播放器 - TED视频流播放器")，*Kivy播放器
    - TED视频流播放器*中对其进行探讨。这个部件有一个名为`state`的属性，与`ToggleButton`的状态属性同名。如果我们想从这两个类中同时进行多重继承，这将会引起名称冲突。
- en: You may have noticed that we set the **`Label`** color of the label explicitly
    to white (line 323), which is the label's default color anyway. We did this in
    order to have everything ready for the next section in which we will decorate
    our interface.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们明确地将标签的**`Label`**颜色设置为白色（第323行），这本来就是标签的默认颜色。我们这样做是为了让一切准备就绪，以便在下一节中装饰我们的界面。
- en: Style – decorating the interface
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式 - 装饰界面
- en: 'In this section, we will redecorate our interface to improve the look and feel
    of it. With very few strategic changes, we will completely renovate the way our
    application looks with a few steps. Let''s start changing the background color
    from black to white. We will do this in the `comicreator.py` file, and here is
    its new header:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新装饰我们的界面，以改善其外观和感觉。通过一些战略性的少量更改，我们将通过几个步骤完全改变应用程序的外观。让我们从将背景颜色从黑色更改为白色开始。我们将在
    `comicreator.py` 文件中这样做，以下是它的新标题：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We imported the **`Window`** class that manages the configurations of the application
    window, and controls some global parameters and events, such as the keyboard events,
    which will be covered in [Chapter 5](ch05.html "Chapter 5. Invaders Revenge –
    an Interactive Multi-touch Game"), *Invaders Revenge – an Interactive Multitouch
    Game*. We use the `Window` class to change the background color of the application
    to white with the **`clearcolor`** property (line 333). Finally, we add a new
    file to `Builder`. The file called `style.kv` is presented here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了管理应用程序窗口配置的 **`Window`** 类，并控制一些全局参数和事件，例如键盘事件，这些将在 [第 5 章](ch05.html "第
    5 章。入侵者复仇 – 一个交互式多点触控游戏") *入侵者复仇 – 一个交互式多点触控游戏* 中介绍。我们使用 `Window` 类通过 `clearcolor`
    属性（第 333 行）将应用程序的背景颜色更改为白色。最后，我们向 `Builder` 添加了一个新文件。这个名为 `style.kv` 的文件如下所示：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We need colors that contrast with the white background that we just applied
    on the entire window. Therefore, we are making changes on two of the basic widgets
    of Kivy, `Label` and `Button`, and this affects all the components that inherit
    from them. We have set the **`bold`** property (line 339) of `Label` to `True`,
    and set the `color` property (line 340) to blue (gray in the printed version).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要与刚刚应用于整个窗口的白色背景形成对比的颜色。因此，我们对 Kivy 的两个基本小部件 `Label` 和 `Button` 进行了修改，这影响了所有继承自它们的所有组件。我们将
    `Label` 的 **`bold`** 属性（第 339 行）设置为 `True`，并将 `color` 属性（第 340 行）设置为蓝色（在打印版本中为灰色）。
- en: We have also changed the default background of the `Button` class and introduced
    how to create rounded buttons. The **`background_normal`** property (line 343)
    indicates the background image that `Button` uses in its normal state, whereas
    the **`background_down`** property (line 344) indicates the image that `Button`
    uses when it is pressed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更改了 `Button` 类的默认背景，并介绍了如何创建圆角按钮。**`background_normal`** 属性（第 343 行）表示 `Button`
    在其正常状态下使用的背景图像，而 **`background_down`** 属性（第 344 行）表示 `Button` 在按下时使用的图像。
- en: Finally, we have reset the `color` property (line 345) of `Button` to white.
    You may wonder why we did that if the default color of the text of the `Button`
    class is white. The problem is that we just changed the color of the `Label` class,
    and, since `Button` inherits from label, the change also affects the `Button`
    class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `Button` 的 `color` 属性（第 345 行）重置为白色。你可能想知道，如果 `Button` 类的文本默认颜色是白色，我们为什么要这样做。问题在于我们刚刚更改了
    `Label` 类的颜色，由于 `Button` 继承自 `Label`，这种更改也影响了 `Button` 类。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order of the rules also matters. If we put the `<Button>:` rule first, then
    it won't work anymore because the `<Label>:` rule will overwrite the `<Button>:`
    rule.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的顺序也很重要。如果我们首先放置 `<Button>:` 规则，那么它将不再工作，因为 `<Label>:` 规则将覆盖 `<Button>:` 规则。
- en: 'We can see the result of our embellished interface:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们装饰过的界面的结果：
- en: '![Style – decorating the interface](img/B04244_04_09.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![风格 – 装饰界面](img/B04244_04_09.jpg)'
- en: There is still something not quite right with the new design. The lines of our
    figures are quite thin compared to the rest of the fonts, and somehow the contrast
    is lost with a white background. Let's learn a quick remedy to change the default
    properties of our lines.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 新的设计仍有不尽如人意之处。与字体相比，我们的图形线条相当细，而且与白色背景相比，对比度似乎有所丧失。让我们快速学习一种补救方法来更改我们线条的默认属性。
- en: Factory – replacing a vertex instruction
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂 – 替换顶点指令
- en: This final section of this chapter teaches a valuable trick to change the default
    properties of the **vertex instructions**. We want to change the width of all
    the lines on our interface. This includes the circles, lines, and stickmen. Of
    course, we could revisit all the classes that create the `Line` vertex instructions
    (remember that the circles are also `Line` instances, and the stickmen are composed
    of `Line` instances as well), and change the width property in all of them. Needless
    to say, that would be tedious.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分教给我们一个宝贵的技巧，用于更改 **顶点指令** 的默认属性。我们想要更改界面上所有线条的宽度。这包括圆圈、线条和棍人。当然，我们可以重新访问创建
    `Line` 顶点指令的所有类（记住，圆圈也是 `Line` 实例，棍人也是由 `Line` 实例组成的），并在它们中更改宽度属性。不用说，那将是繁琐的。
- en: 'Instead, we will replace the default `Line` class. Indeed, this is equivalent
    to what we just did in the previous section when we changed the label and button
    default properties. We have a problem in that we cannot create rules in the Kivy
    language to change the vertex instructions. But there is an equivalent way around
    this, using Python code in a new file called `style.py`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将替换默认的 `Line` 类。实际上，这与我们在上一节中更改标签和按钮默认属性时所做的是等效的。我们有一个问题，那就是我们无法在 Kivy
    语言中创建规则来更改顶点指令。但是，有一个等效的方法可以绕过这个问题，使用名为 `style.py` 的新文件中的 Python 代码：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this code, we have created our own `NewLine` class that inherits from the
    Kivy `Line` class (line 350). With a little Python trick, we have changed the
    `kwargs` parameter of the constructor method (`__init__`) in order to set a different
    default width (line 353). The `kwargs` parameter is a dictionary that contains
    all the properties that are explicitly set when a `Line` instance is created.
    In this case, if the `width` property is not indicated in the constructor (line
    352), we set the width default to `1.5` (line 353). Then, we call the constructor
    of the base class with the adjusted `kwargs` (line 354).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了自己的 `NewLine` 类，它继承自 Kivy 的 `Line` 类（第 350 行）。通过一点 Python 小技巧，我们改变了构造方法（`__init__`）的
    `kwargs` 参数，以便设置不同的默认宽度（第 353 行）。`kwargs` 参数是一个字典，包含在创建 `Line` 实例时明确设置的属性。在这种情况下，如果构造函数（第
    352 行）中没有指定 `width` 属性，我们将宽度默认设置为 `1.5`（第 353 行）。然后，我们使用调整后的 `kwargs` 调用基类的构造函数（第
    354 行）。
- en: Now, it is time to replace the default Kivy `Line` class with ours. We need
    to import the Kivy **`Factory`** (line 348) that we can use to register or unregister
    classes, and instance them in the Kivy language. First, we need to unregister
    the current `Line` with the **`unregister`** method (line 356). Then, we need
    to register our `NewLine` with the **`register`** method (line 357). In both methods,
    the first parameter represents the name that is used to instance the class from
    the Kivy language. Since we are replacing the class, we will register the `NewLine`
    class with the same name. In the **`register`** method (line 357), the second
    parameter (`cls`) indicates the class that we register.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候用我们的类替换默认的 Kivy `Line` 类了。我们需要导入 Kivy 的 **`Factory`**（第 348 行），我们可以用它来注册或注销类，并在
    Kivy 语言中使用它们。首先，我们需要使用 **`unregister`** 方法（第 356 行）注销当前的 `Line` 类。然后，我们需要使用 **`register`**
    方法（第 357 行）注册我们的 `NewLine` 类。在这两种方法中，第一个参数代表用于从 Kivy 语言实例化类的名称。由于我们要替换类，我们将使用相同的名称注册
    `NewLine` 类。在 **`register`** 方法（第 357 行）中，第二个参数（`cls`）表示我们注册的类。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could use the **`Factory`** class to add different lines that we need to
    constantly use in the Kivy language. For example, we could register our new class
    with the name `ThickLine` and then instance it in the Kivy language.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **`Factory`** 类在 Kivy 语言中添加我们经常需要使用的不同线条。例如，我们可以用 `ThickLine` 名称注册我们的新类，然后在
    Kivy 语言中实例化它。
- en: 'We purposely avoided this strategy, since we actually want to replace the default
    `Line`, so we can affect all the `Line` instances that we create directly in the
    Kivy language. However, we shouldn''t forget to use the `NewLine` class to create
    the instances that the user will create dynamically. We need to import `NewLine`
    from the style file and set an alias name (`Line`) so we can reference the class
    with the same name (line 362). We also need to remove the one we imported from
    `kivy.graphics` (line 362) in the `toolbox.py` file to avoid a name conflict:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意避免这种策略，因为我们实际上想要替换默认的 `Line`，这样我们就可以直接在 Kivy 语言中影响我们创建的所有 `Line` 实例。然而，我们不应该忘记使用
    `NewLine` 类来创建用户将动态创建的实例。我们需要从样式文件中导入 `NewLine` 并设置别名（`Line`），这样我们就可以使用相同的名称引用该类（第
    362 行）。我们还需要从 `toolbox.py` 文件中移除我们导入的 `kivy.graphics`（第 362 行），以避免名称冲突：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is the final screenshot of our *Comic Creator*, which shows off the thicker
    lines:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 *Comic Creator* 的最终截图，展示了更粗的线条：
- en: '![Factory – replacing a vertex instruction](img/B04244_04_10.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![Factory – 替换顶点指令](img/B04244_04_10.jpg)'
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered some specific and useful topics that improve the user experience.
    We added several screens and switched between them with `ScreenManager`. We learned
    how to use colors in the canvas, and we should now have a good understanding of
    how this works internally. We also learned how to limit the drawing area to the
    **`drawing space`** with `StencilView`. We used `Scatter` to add rotating and
    scaling capabilities to `DraggableWidget` and expanded the functionality through
    the use of properties and associated events. We also introduced the use of gestures
    to make the interface more dynamic. We covered how to enhance widget using behaviors.
    Finally, we learned how to improve the interface by modifying the default widgets
    and vertex instructions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了一些特定且有用的主题，这些主题可以改善用户体验。我们添加了几个屏幕，并通过 `ScreenManager` 在它们之间切换。我们学习了如何在画布中使用颜色，现在我们应该对内部工作方式有很好的理解。我们还学习了如何使用
    `StencilView` 限制绘图区域到 **`drawing space`**。我们使用 `Scatter` 为 `DraggableWidget` 添加旋转和缩放功能，并通过使用属性和相关事件扩展了功能。我们还介绍了使用手势使界面更具动态性的方法。我们介绍了如何使用行为增强小部件。最后，我们学习了如何通过修改默认小部件和顶点指令来改进界面。
- en: 'Here is a review of all the classes with their respective methods, properties,
    and attributes that we learned to use in this chapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章中我们学习使用的所有类的回顾，包括它们各自的方法、属性和属性：
- en: '`ScreenManager`: The `transistion` and `current` properties'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScreenManager`: `transistion` 和 `current` 属性'
- en: '`FadeTransition`, `SwapTransition`, `SlideTransition`, and `WipeTransition`
    transitions'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FadeTransition`、`SwapTransition`、`SlideTransition` 和 `WipeTransition` 过渡'
- en: '`Screen`: The `name` and `manager` properties'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Screen`: `name` 和 `manager` 属性'
- en: '`ColorPicker`: The `color` property'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorPicker`: `color` 属性'
- en: '`StencilView`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StencilView`'
- en: '`Scatter`: The `rotate` and `scale` properties, and the `on_translate`, `on_rotate`
    and `on_scale` methods (events)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scatter`: `rotate` 和 `scale` 属性，以及 `on_translate`、`on_rotate` 和 `on_scale`
    方法（事件）'
- en: '`ScatterLayout`: The `size_hint` and `pos_hint` properties'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScatterLayout`: `size_hint` 和 `pos_hint` 属性'
- en: '`Gesture`: The `add_stroke`, `normalize`, and `rotate` methods'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gesture`: `add_stroke`、`normalize` 和 `rotate` 方法'
- en: '`GestureDatabase`: The `gesture_to_str`, `str_to_gesture`, `add_gesture`, and
    `find` methods'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GestureDatabase`: `gesture_to_str`、`str_to_gesture`、`add_gesture` 和 `find`
    方法'
- en: '`Widget`: The `disabled` property'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Widget`: `disabled` 属性'
- en: '`ButtonBehavior`, `ToggleBehavior` and `DragBehavior`: The `on_press` method'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ButtonBehavior`、`ToggleBehavior` 和 `DragBehavior`: `on_press` 方法'
- en: '`Popup`: The `title` and `content` properties'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Popup`: `title` 和 `content` 属性'
- en: '`Window`: The `clearcolor` attribute'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Window`: `clearcolor` 属性'
- en: '`Factory`: The `register` and `unregister` methods'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Factory`: `register` 和 `unregister` 方法'
- en: These are all useful components that help us create more attractive and dynamic
    applications. In this chapter, we gave an example on how to demonstrate the possibilities
    of the classes. Although we didn't exhaustively explore all the options, we should
    feel comfortable to use any of these components to enhance applications. We can
    always check the Kivy API for a more comprehensive list of properties and methods.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是非常有用的组件，帮助我们创建更具吸引力和动态的应用程序。在本章中，我们提供了一个示例，展示了如何展示这些类的能力。尽管我们没有详尽地探索所有选项，但我们应该能够舒适地使用这些组件来增强应用程序。我们始终可以查看
    Kivy API 以获取更全面的属性和方法列表。
- en: The next chapter will introduce personalized multi-touch control, animations,
    as well as the clock and keyboard events. We will create a new interactive project,
    a game that resembles the Arcade game *Space Invaders*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍个性化多点触控、动画以及时钟和键盘事件。我们将创建一个新的交互式项目，一款类似于街机游戏 *太空侵略者* 的游戏。
