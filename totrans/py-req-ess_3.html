<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Authenticating with Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Authenticating with Requests</h1></div></div></div><p>Requests supports diverse kinds of authentication procedures, and it is built in such a way that the method of authentication feels like a cakewalk. In this chapter, we opt to throw light on various types of authentication procedures that are used by various tech giants for accessing the web resources.</p><p>We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic authentication</li><li class="listitem" style="list-style-type: disc">Digest authentication</li><li class="listitem" style="list-style-type: disc">Kerberos authentication</li><li class="listitem" style="list-style-type: disc">OAuth authentication</li><li class="listitem" style="list-style-type: disc">Custom authentication</li></ul></div><div class="section" title="Basic authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Basic authentication</h1></div></div></div><p>Basic authentication <a class="indexterm" id="id89"/>is a popular, industry-standard scheme of authentication, which is specified in <code class="literal">HTTP 1.0</code>. This method makes use of a <code class="literal">user-ID</code> and <code class="literal">password</code> submitted by the user to get authenticated. The submitted <code class="literal">user-ID</code> and <code class="literal">password</code> are encoded using <code class="literal">Base64</code> encoding standards and transmitted across HTTP. The server gives access to the user only if the <code class="literal">user-ID</code> and the <code class="literal">password</code> are valid. The following are the advantages of using basic authentication:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The main <a class="indexterm" id="id90"/>advantage of using this scheme is that it is supported by most of the web browsers and servers. Even though it is simple and straightforward, it does have some disadvantages. Though all the credentials are encoded and transferred in the requests, they are not encrypted which makes the process insecure. One way to overcome this problem is by using SSL support while initiating a secure session.</li><li class="listitem" style="list-style-type: disc">Secondly, the credentials persist on the server until the end of the browser session, which may lead to the seizure of the resources. And also, this authentication process is wide open to <span class="strong"><strong>Cross Site Request Forgery</strong></span> (<span class="strong"><strong>CSRF</strong></span>) attacks, as the <a class="indexterm" id="id91"/>browser automatically sends the credentials of the user in the subsequent requests.</li></ul></div><p>The basic authentication <a class="indexterm" id="id92"/>flow contains two steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If a requested resource needs authentication, the server returns <code class="literal">http 401</code> response containing a <code class="literal">WWW-Authenticate</code> header.</li><li class="listitem">If the user sends another request with the user ID and password in the <code class="literal">Authorization</code> header, the server processes the submitted credentials and gives the access.</li></ol></div><p>You can see this in the following diagram:</p><div class="mediaobject"><img alt="Basic authentication" src="graphics/3661_03_01.jpg"/></div><div class="section" title="Using basic authentication with Requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Using basic authentication with Requests</h2></div></div></div><p>We can use the <a class="indexterm" id="id93"/>
<code class="literal">requests</code> module to send a request to <a class="indexterm" id="id94"/>undergo basic authentication very easily. The process can be seen as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from requests.auth import HTTPBasicAuth</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; requests.get('https://demo.example.com/resource/path', auth=HTTPBasicAuth('user-ID', 'password'))</strong></span>
</pre></div><p>In the preceding lines of code, we performed basic authentication by creating an <code class="literal">HTTPBasicAuth</code> object; then we passed it to the <code class="literal">auth</code> parameter, which will be submitted to the server. If the submitted credentials gets authenticated successfully, the server returns a <code class="literal">200</code> (Successful) response, otherwise, it will return a <code class="literal">401</code> (Unauthorized) response.</p></div></div></div>
<div class="section" title="Digest authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Digest authentication</h1></div></div></div><p>Digest authentication is <a class="indexterm" id="id95"/>one of the well known HTTP authentication schemes, which were introduced to overcome most of the drawbacks of basic authentication. This type of authentication makes use of <code class="literal">user-ID</code> and <code class="literal">password</code> just like Basic authentication, but the major difference comes in the picture, when the credentials get transferred to the server.</p><p>Digest authentication increases the security of the credentials by going an extra mile with the concept of cryptographic encryption. When the user submits the password for the sake of authentication, the browser will apply an MD5 hashing scheme on it. The crux of the process lies in using nonce values (pseudo-random numbers) while encrypting the password which decreases the replay attacks.</p><div class="mediaobject"><img alt="Digest authentication" src="graphics/3661_03_02.jpg"/></div><p>This type of authentication gains more strength, as the password in this encryption is not used in the form of plain text. The cracking of the password hashes becomes difficult in digest authentication with the use of a nonce, which counters the chosen plain text attacks.</p><p>Even though Digest authentication overcomes most of the drawbacks of Basic authentication, it does have some disadvantages. This scheme of authentication is vulnerable to man-in-the-middle attacks. It reduces the flexibility of storing the password in the password's database, as all the well designed password databases use other encryption methods to store them.</p><div class="section" title="Using Digest authentication with Requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Using Digest authentication with Requests</h2></div></div></div><p>Using Digest <a class="indexterm" id="id96"/>authentication with <code class="literal">requests</code> is very <a class="indexterm" id="id97"/>simple. Let us see how it's done:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from requests.auth import HTTPDigestAuth</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; requests.get('https://demo.example.com/resource/path', auth=HTTPDigestAuth('user-ID', 'password'))</strong></span>
</pre></div><p>In the preceding lines of code, we carried out digest authentication by creating an <code class="literal">HTTPDigestAuth</code> object and setting it to the 'auth' parameter which will be submitted to the server. If the <a class="indexterm" id="id98"/>submitted credentials gets authenticated <a class="indexterm" id="id99"/>successfully, the server returns a <code class="literal">200</code> response, otherwise, it will return a <code class="literal">401</code> response.</p></div></div>
<div class="section" title="Kerberos authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Kerberos authentication</h1></div></div></div><p>Kerberos is a type of <a class="indexterm" id="id100"/>Network authentication protocol, which uses a secret key cryptography to communicate between the client and the server. It was developed at MIT to mitigate many security problems like replay attacks and spying. It makes use of <span class="emphasis"><em>tickets</em></span> to provide authentication for the server-side resources. It followed the idea of avoiding additional logins (single sign on) and storing the passwords at a centralized location.</p><p>In a nutshell, the authentication server, the ticket granting server and the host machine act as the leading cast in the process of authentication.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Authentication Server</strong></span>: A server-side application which aids in the process of authentication <a class="indexterm" id="id101"/>by making the use of submitted credentials of a user</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ticket Granting Server</strong></span>: A <a class="indexterm" id="id102"/>logical <span class="strong"><strong>key distribution center</strong></span> (<span class="strong"><strong>KDC</strong></span>) which validates the tickets</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Host Machine</strong></span>: A <a class="indexterm" id="id103"/>server which accepts the requests and provides the resources</li></ul></div><p>You can see this in the following diagram:</p><div class="mediaobject"><img alt="Kerberos authentication" src="graphics/B03661_03_03.jpg"/></div><p>Authentication with <a class="indexterm" id="id104"/>Kerberos takes place in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">When a person logs into his machine with the credentials, a request will be sent to <span class="strong"><strong>ticket </strong></span><a class="indexterm" id="id105"/><span class="strong"><strong>granting ticket</strong></span> (<span class="strong"><strong>TGT</strong></span>).</li><li class="listitem">If the verification of the user turns out to be true, when checked from the user database, a session key and a TGT will be created by the authentication server (AS).</li><li class="listitem">Thus, the obtained TGT and session key will be sent back to the user in the form of two messages, in which TGT will be encrypted with the ticket granting the server's secret key. The session key will be encrypted with the client secret key and it contains a time stamp, life time, TGS name and TGS session key.</li><li class="listitem">The user on the other end, after receiving the two messages, uses the client secret key that is, the user's password to decrypt the messages of the session key. The TGT cannot be decrypted without the TGS secret key.</li><li class="listitem">With the available information of the <code class="literal">session</code> key and the TGT, the user can send a request for accessing the service. The request contains two messages and some information at this point. In the two messages, one is an encrypted message, containing a user ID and timestamp. The other is a decrypted message, containing the HTTP service name and the life time of the ticket. With the above two messages, an authenticator and TGT will be sent to the ticket granting server.</li><li class="listitem">The messages and the information (Authenticator and TGT) will be received by the TGS, and it will check for the credibility of the HTTP service from the KDC database and decrypt both the authenticator and the TGT. Once everything goes fine, the TGS tries to verify some important parts like client ID, time stamp, lifetime of TGT and authenticator. If the verification turns out to be successful, then the TGS generates an encrypted HTTP service ticket, HTTP service name, time stamp, information about the ticket validity and the session key of HTTP service. All of the preceding ones will be encrypted by the HTTP Service session key and will be sent back to the user.</li><li class="listitem">Now, the user receives the information and decrypts it with the TGS session key that he/she received in the earlier step.</li><li class="listitem">In the next step, to <a class="indexterm" id="id106"/>access the HTTP service, the user sends an encrypted HTTP service ticket and an authenticator which is encrypted with the HTTP service session key to the HTTP service. The HTTP service uses its <a class="indexterm" id="id107"/>secret key to decrypt the ticket and takes hold of the HTTP service session key. With the acquired HTTP service session key, it decrypts the authenticator and verifies the client ID time stamp, lifetime of ticket, and so on.</li><li class="listitem">If the verification turns out to be successful, the HTTP service sends an authenticator message with its ID and time stamp to confirm its identity to the user. The user's machine verifies the authenticator by making use of HTTP service session key and identifies the user as an authenticated one who accesses the HTTP service. From then onwards, the HTTP service can be accessed by the user without any bumps, until the session key expires.</li></ol></div><p>Kerberos is a secure protocol as the passwords from the user can never be sent as plain text. As the process of authentication takes place with the agreement of both the client and the server through encryption and decryption, it turns out to be a rigid one to break to some extent. The other advantage comes from its capability to give server access to the user until the session key expires without reentering the password.</p><p>Kerberos does have some disadvantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The server must be continuously available for the verification of the tickets which may result in blocking, if the server goes down.</li><li class="listitem" style="list-style-type: disc">User's keys are saved on a central server. A breach of this server may compromise security for the whole infrastructure.</li><li class="listitem" style="list-style-type: disc">Kerberos necessitates a heavy infrastructure, which means a simple web server is not sufficient.</li><li class="listitem" style="list-style-type: disc">The setup and the <a class="indexterm" id="id108"/>administration of Kerberos requires specialized skills.</li></ul></div><div class="section" title="Using Kerberos authentication with Requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Using Kerberos authentication with Requests</h2></div></div></div><p>Requests takes the <a class="indexterm" id="id109"/>support of the <code class="literal">requests-kerberos</code> library for the purpose of authentication. For this reason, we should first <a class="indexterm" id="id110"/>install the <code class="literal">requests-kerberos</code> module.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; pip install 'requests-kerberos'</strong></span>
</pre></div><p>Let's have a look at the syntax:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import requests</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from requests.kerberos import HTTPKerberosAuth</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; requests.get('https://demo.example.com/resource/path', auth=HTTTPKerberosAuth())</strong></span>
</pre></div><p>In the preceding lines of code, we carried out Kerberos authentication by creating an <code class="literal">HTTPKerberosAuth</code> object and setting it to the <code class="literal">auth</code> parameter which will be submitted to the server.</p></div></div>
<div class="section" title="OAuth authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>OAuth authentication</h1></div></div></div><p>OAuth is an open standard <a class="indexterm" id="id111"/>authorization protocol, which allows client applications a <span class="emphasis"><em>secure delegated access</em></span> to the user accounts on third party services such as Google, Twitter, GitHub and so on. In this topic, we are going to introduce the two versions:- OAuth 1.0 and OAuth 2.0.</p><div class="section" title="OAuth 1.0"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>OAuth 1.0</h2></div></div></div><p>OAuth authentication protocol <a class="indexterm" id="id112"/>came up with an idea of mitigating the <a class="indexterm" id="id113"/>usage of passwords, replacing them with secure handshakes with API calls between the applications. This was developed by a small group of web developers who are inspired by OpenID.</p><p>Here are the Key terms used in the process of OAuth authentication.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Consumer</strong></span>: The HTTP Client who can make authenticated requests</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Service Provider</strong></span>: The <a class="indexterm" id="id114"/>HTTP Server, which deals with the requests of OAuth</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>User</strong></span>: A person who has the control over the protected resources on the HTTP Server</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Consumer Key and Secret</strong></span>: Identifiers which have the capability to authenticate and authorize a request</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Request Token and Secret</strong></span>: Credentials used to gain authorization from the user</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Access Token and Secret</strong></span>: Credentials to get access to the protected resources of the user</li></ul></div><p>You can see this in the following diagram:</p><div class="mediaobject"><img alt="OAuth 1.0" src="graphics/B03661_03_04.jpg"/></div><p>Initially, the client application asks the service provider to grant a request token. A user can be identified as an approved user by taking the credibility of the request token. It also helps in acquiring the access token with which the client application can access the service provider's resources.</p><p>In the second step, the service <a class="indexterm" id="id115"/>provider receives the request and issues request token, which will be sent back to the client application. Later, the user gets redirected to the service provider's authorization page along with the request token received before as an argument.</p><p>In the next step, the user grants permission to use the consumer application. Now, the service provider returns the user back to the client application, where the application accepts an authorized request <a class="indexterm" id="id116"/>token and gives back an access token. Using <a class="indexterm" id="id117"/>the access token, the user will gain an access to the application.</p></div><div class="section" title="Using OAuth 1.0 authentication with Requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Using OAuth 1.0 authentication with Requests</h2></div></div></div><p>The <code class="literal">requests_oauthlib</code> is a an optional library for <code class="literal">oauth</code> which is not included in the Requests <a class="indexterm" id="id118"/>module. For this reason, we <a class="indexterm" id="id119"/>should install <code class="literal">requests_oauthlib</code> separately.</p><p>Let us take a look at the syntax:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import requests</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from requests_oauthlib import OAuth1</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; auth = OAuth1('&lt;consumer key&gt;', '&lt;consumer secret&gt;',</strong></span>
<span class="strong"><strong>...               '&lt;user oauth token&gt;', '&lt;user oauth token secret&gt;')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; requests.get('https://demo.example.com/resource/path', auth=auth)</strong></span>
</pre></div></div><div class="section" title="OAuth 2.0"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>OAuth 2.0</h2></div></div></div><p>OAuth 2.0 is next in line to <a class="indexterm" id="id120"/>OAuth 1.0 which has been developed to overcome the drawbacks of its predecessor. In modern days, OAuth 2.0 has been used vividly in <a class="indexterm" id="id121"/>almost all leading web services. Due to its ease of use with more security, it has attracted many people. The beauty of OAuth 2.0 comes from its simplicity and its capability to provide specific authorization methods for different types of application like web, mobile and desktop.</p><p>Basically, there are four workflows available while using OAuth 2.0, which are also called <span class="strong"><strong>grant types</strong></span>. They <a class="indexterm" id="id122"/>are:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Authorization code grant</strong></span>: This <a class="indexterm" id="id123"/>is basically used in <a class="indexterm" id="id124"/>web applications for the ease of authorization and secure resource delegation.</li><li class="listitem"><span class="strong"><strong>Implicit grant</strong></span>: This <a class="indexterm" id="id125"/>flow is used to provide OAuth authorization in Mobile Applications.</li><li class="listitem"><span class="strong"><strong>Resource owner password credentials grant</strong></span>: This type of grant is used for applications <a class="indexterm" id="id126"/>using trusted clients.</li><li class="listitem"><span class="strong"><strong>Client credentials grant</strong></span>: This type of grant is used in machine to machine authentication. An <a class="indexterm" id="id127"/>in-depth explanation about grant types is out of the scope of this book.</li></ol></div><p>OAuth 2.0 came up with capabilities which could overcome the concerns of OAuth 1.0. The process of using signatures to verify the credibility of API requests has been replaced by the use of SSL in <a class="indexterm" id="id128"/>OAuth 2.0. It came up with the idea of supporting different types of flow for different environments ranging from web to mobile applications. Also, the concept of refresh tokens has been introduced to increase the security.</p><p>Let us take a look at the usage:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from requests_oauthlib import OAuth2Session</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; client = OAuth2Session('&lt;client id&gt;', token='token')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; resp = client.get('https://demo.example.com/resource/path')</strong></span>
</pre></div></div></div>
<div class="section" title="Custom authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Custom authentication</h1></div></div></div><p>Requests also <a class="indexterm" id="id129"/>provides the ability to write a new or custom authentication based on the user's needs and flexibility. It is equipped with <code class="literal">requests.auth.AuthBase</code> class which is a base class for all the authentication types. This can be achieved by implementing the custom authentication in the <code class="literal">__call__()</code> of <code class="literal">requests.auth.AuthBase</code>.</p><p>Let us take a look at its syntax:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import requests</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; class CustomAuth(requests.auth.AuthBase):</strong></span>
<span class="strong"><strong>...     def __call__(self, r):</strong></span>
<span class="strong"><strong>...         # Custom Authentication Implemention</strong></span>
<span class="strong"><strong>...         return r</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; requests.get('https://demo.example.com/resource/path',</strong></span>
<span class="strong"><strong>... auth=CustomAuth())</strong></span>
</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Summary</h1></div></div></div><p>In this chapter, we gained knowledge of various types of authentication like Basic authentication, Digest authentication, Kerberos authentication, OAuth 1.0 authentication and OAuth 2.0 authentication which are supported by Requests. Later, we got an idea of how to use various types of authentications and the flows of the process. We also learned to use our own custom authentication and gained the knowledge of making different authentications work with Requests and the ways to use them with Requests. </p><p>In the next chapter, we will be getting to know all about a handy module, <code class="literal">HTTPretty</code>.</p></div></body></html>